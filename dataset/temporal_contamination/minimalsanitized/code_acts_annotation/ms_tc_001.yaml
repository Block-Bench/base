schema_version: "1.0"
sample_id: "ms_tc_001"
vulnerability_type: "improper_initialization"
vulnerable_lines: [18, 53]

# Full line coverage for scoring. UNRELATED items are batched for efficiency.
# Detailed rationales only for security-relevant code acts.

code_acts:

  # ============================================
  # SECURITY-RELEVANT CODE ACTS (detailed)
  # ============================================

  - id: "CA1"
    type: "DECLARATION"
    lines: [18]
    code: "bytes32 public acceptedRoot;"
    security_function: "ROOT_CAUSE"
    rationale: "Critical state variable declared without initialization. In Solidity, bytes32 defaults to 0x00...00. This uninitialized state is the primary root cause of the Nomad Bridge vulnerability. Attackers could craft messages with zero roots that matched this default value, bypassing message validation entirely."

  - id: "CA2"
    type: "INITIALIZATION"
    lines: [28, 29, 30]
    code: |
      constructor(address _bridgeRouter) {
          bridgeRouter = _bridgeRouter;
      }
    security_function: "ROOT_CAUSE"
    rationale: "Constructor initializes bridgeRouter but critically omits initialization of acceptedRoot. This is where acceptedRoot should have been set to a valid non-zero merkle root. The absence of initialization directly enables the exploit."

  - id: "CA3"
    type: "COMPUTATION"
    lines: [42]
    code: "bytes32 messageHash = keccak256(_message);"
    security_function: "BENIGN"
    rationale: "Computes keccak256 hash of the message for replay protection. Correctly implemented hash computation from memory parameter."

  - id: "CA4"
    type: "INPUT_VAL"
    lines: [45, 46, 47, 48]
    code: |
      require(
          messages[messageHash] != MessageStatus.Processed,
          "Already processed"
      );
    security_function: "BENIGN"
    rationale: "Replay protection that prevents the same message from being processed twice. Correctly implemented."

  - id: "CA5"
    type: "CTRL_FLOW"
    lines: [52]
    code: "bytes32 root = _messageRoot(_message);"
    security_function: "PREREQ"
    rationale: "Calls internal function to compute message root. Prerequisite because _messageRoot() can return bytes32(0) for crafted messages, which then matches uninitialized acceptedRoot."

  - id: "CA6"
    type: "INPUT_VAL"
    lines: [53]
    code: 'require(root == acceptedRoot, "Invalid root");'
    security_function: "ROOT_CAUSE"
    rationale: "The critical validation check. ROOT_CAUSE because it passes when both root and acceptedRoot are zero (0x00 == 0x00). The check is syntactically correct but semantically broken due to uninitialized state."

  - id: "CA7"
    type: "STATE_MOD"
    lines: [56]
    code: "messages[messageHash] = MessageStatus.Processed;"
    security_function: "BENIGN"
    rationale: "Marks message as processed BEFORE external call, following CEI pattern. Correctly prevents reentrancy."

  - id: "CA8"
    type: "EXT_CALL"
    lines: [59]
    code: "(bool routerSuccess, ) = bridgeRouter.call(_message);"
    security_function: "PREREQ"
    rationale: "External call that forwards message to bridgeRouter for token transfer. This is where funds are stolen. PREREQ because the call itself is correct, but enables financial impact of the exploit."

  - id: "CA9"
    type: "EVENT_EMIT"
    lines: [61]
    code: "emit MessageProcessed(messageHash, routerSuccess);"
    security_function: "BENIGN"
    rationale: "Event emission for logging. No state modification, writes to transaction logs only."

  - id: "CA10"
    type: "CTRL_FLOW"
    lines: [62]
    code: "return routerSuccess;"
    security_function: "BENIGN"
    rationale: "Return statement propagating router call result."

  - id: "CA11"
    type: "CTRL_FLOW"
    lines: [76, 77, 78]
    code: |
      if (_message.length > 32 && uint256(bytes32(_message)) == 0) {
          return bytes32(0);
      }
    security_function: "PREREQ"
    rationale: "Conditional in _messageRoot that returns bytes32(0) for messages starting with 32 zero bytes. PREREQ because this provides mechanism for attackers to craft messages with predictable zero roots."

  - id: "CA12"
    type: "CTRL_FLOW"
    lines: [80]
    code: "return keccak256(_message);"
    security_function: "BENIGN"
    rationale: "Default return path in _messageRoot computing keccak256 hash. Correctly implemented."

  - id: "CA13"
    type: "ACCESS_CTRL"
    lines: [83, 84, 85]
    code: |
      function setAcceptedRoot(bytes32 _newRoot) external {
          acceptedRoot = _newRoot;
      }
    security_function: "SECONDARY_VULN"
    rationale: "This function allows ANYONE to set acceptedRoot - no onlyOwner modifier. This is a REAL vulnerability (CWE-284: Improper Access Control) but NOT the documented vulnerability. The Nomad exploit used the UNINITIALIZED zero value, not this function."

  # ============================================
  # BATCHED UNRELATED CODE ACTS (for scoring)
  # ============================================

  - id: "CA_DIRECTIVES"
    type: "DIRECTIVE"
    lines: [1, 2]
    security_function: "UNRELATED"
    rationale: "License and pragma statements"

  - id: "CA_COMMENTS"
    type: "COMMENT"
    lines: [5, 12, 17, 20, 23, 32, 33, 34, 35, 36, 37, 38, 39, 40, 44, 55, 58, 65, 66, 67, 68, 72, 75]
    security_function: "UNRELATED"
    rationale: "Inline comments and NatSpec documentation"

  - id: "CA_DECLARATIONS"
    type: "DECLARATION"
    lines: [4, 6, 7, 8, 9, 10, 14, 21, 24, 41, 69, 70, 71]
    security_function: "UNRELATED"
    rationale: "Contract, enum, mapping, and function signature declarations"

  - id: "CA_EVENT_DEFS"
    type: "EVENT_DEF"
    lines: [26]
    security_function: "UNRELATED"
    rationale: "Event declaration"

  - id: "CA_SYNTAX"
    type: "SYNTAX"
    lines: [63, 81, 86]
    security_function: "UNRELATED"
    rationale: "Closing braces"

summary:
  total_code_acts: 18
  total_lines_covered: 63  # excludes 24 empty lines (3, 11, 13, 15, 16, 19, 22, 25, 27, 31, 39, 43, 49, 50, 51, 54, 57, 60, 64, 73, 74, 79, 82, 87)

  by_security_function:
    ROOT_CAUSE: 3
    SECONDARY_VULN: 1
    PREREQ: 3
    BENIGN: 6
    UNRELATED: 5  # batched

  by_code_act_type:
    CTRL_FLOW: 4
    INPUT_VAL: 2
    DECLARATION: 2  # 1 ROOT_CAUSE + 1 batched UNRELATED
    INITIALIZATION: 1
    STATE_MOD: 1
    EXT_CALL: 1
    COMPUTATION: 1
    EVENT_EMIT: 1
    ACCESS_CTRL: 1
    DIRECTIVE: 1
    COMMENT: 1
    EVENT_DEF: 1
    SYNTAX: 1

  root_causes:
    - id: "CA1"
      line: 18
      type: "DECLARATION"
      description: "Uninitialized acceptedRoot declaration"
    - id: "CA2"
      lines: [28, 29, 30]
      type: "INITIALIZATION"
      description: "Constructor missing acceptedRoot initialization"
    - id: "CA6"
      line: 53
      type: "INPUT_VAL"
      description: "Validation check passes when both values are zero"

  secondary_vulns:
    - id: "CA13"
      lines: [83, 84, 85]
      type: "ACCESS_CTRL"
      description: "Missing access control on setAcceptedRoot"
      vuln_type: "access_control"

  prerequisites:
    - id: "CA5"
      line: 52
      type: "CTRL_FLOW"
      description: "Root computation call"
    - id: "CA8"
      line: 59
      type: "EXT_CALL"
      description: "External call to bridge router"
    - id: "CA11"
      lines: [76, 77, 78]
      type: "CTRL_FLOW"
      description: "Conditional enabling zero root creation"

  vulnerable_lines_mapping:
    18: "CA1 - ROOT_CAUSE - acceptedRoot declaration without initialization"
    53: "CA6 - ROOT_CAUSE - validation check that passes incorrectly"

  # For scoring: lookup line → code_act → security_function
  # This avoids marking closing braces as ROOT_CAUSE; the code act is the meaningful unit.
  # Scoring: if model references any line in a code act, lookup code act's security_function.
line_to_code_act:
  # Directives (UNRELATED)
  1: "CA_DIRECTIVES"
  2: "CA_DIRECTIVES"
  # Contract/enum declarations (UNRELATED)
  4: "CA_DECLARATIONS"
  6: "CA_DECLARATIONS"
  7: "CA_DECLARATIONS"
  8: "CA_DECLARATIONS"
  9: "CA_DECLARATIONS"
  10: "CA_DECLARATIONS"
  # Comments (UNRELATED)
  5: "CA_COMMENTS"
  12: "CA_COMMENTS"
  17: "CA_COMMENTS"
  20: "CA_COMMENTS"
  23: "CA_COMMENTS"
  32: "CA_COMMENTS"
  33: "CA_COMMENTS"
  34: "CA_COMMENTS"
  35: "CA_COMMENTS"
  36: "CA_COMMENTS"
  37: "CA_COMMENTS"
  38: "CA_COMMENTS"
  # Line 39: empty
  40: "CA_COMMENTS"
  44: "CA_COMMENTS"
  55: "CA_COMMENTS"
  58: "CA_COMMENTS"
  65: "CA_COMMENTS"
  66: "CA_COMMENTS"
  67: "CA_COMMENTS"
  68: "CA_COMMENTS"
  72: "CA_COMMENTS"
  75: "CA_COMMENTS"
  # Declarations (UNRELATED)
  14: "CA_DECLARATIONS"
  21: "CA_DECLARATIONS"
  24: "CA_DECLARATIONS"
  41: "CA_DECLARATIONS"
  69: "CA_DECLARATIONS"
  70: "CA_DECLARATIONS"
  71: "CA_DECLARATIONS"
  # Event definition (UNRELATED)
  26: "CA_EVENT_DEFS"
  # Syntax - closing braces (UNRELATED)
  63: "CA_SYNTAX"
  81: "CA_SYNTAX"
  86: "CA_SYNTAX"
  # === SECURITY-RELEVANT CODE ACTS ===
  # CA1: acceptedRoot declaration (ROOT_CAUSE)
  18: "CA1"
  # CA2: Constructor (ROOT_CAUSE) - all lines map to same code act
  28: "CA2"
  29: "CA2"
  30: "CA2"
  # CA3: Hash computation (BENIGN)
  42: "CA3"
  # CA4: Replay protection (BENIGN)
  45: "CA4"
  46: "CA4"
  47: "CA4"
  48: "CA4"
  # CA5: Root computation call (PREREQ)
  52: "CA5"
  # CA6: Root validation (ROOT_CAUSE)
  53: "CA6"
  # CA7: Mark processed (BENIGN)
  56: "CA7"
  # CA8: External call (PREREQ)
  59: "CA8"
  # CA9: Event emission (BENIGN)
  61: "CA9"
  # CA10: Return statement (BENIGN)
  62: "CA10"
  # CA11: Zero root conditional (PREREQ)
  76: "CA11"
  77: "CA11"
  78: "CA11"
  # CA12: Default keccak return (BENIGN)
  80: "CA12"
  # CA13: setAcceptedRoot (SECONDARY_VULN)
  83: "CA13"
  84: "CA13"
  85: "CA13"

# Quick lookup: code_act_id → security_function
code_act_security_functions:
  CA1: "ROOT_CAUSE"
  CA2: "ROOT_CAUSE"
  CA3: "BENIGN"
  CA4: "BENIGN"
  CA5: "PREREQ"
  CA6: "ROOT_CAUSE"
  CA7: "BENIGN"
  CA8: "PREREQ"
  CA9: "BENIGN"
  CA10: "BENIGN"
  CA11: "PREREQ"
  CA12: "BENIGN"
  CA13: "SECONDARY_VULN"
  CA_DIRECTIVES: "UNRELATED"
  CA_COMMENTS: "UNRELATED"
  CA_DECLARATIONS: "UNRELATED"
  CA_EVENT_DEFS: "UNRELATED"
  CA_SYNTAX: "UNRELATED"
