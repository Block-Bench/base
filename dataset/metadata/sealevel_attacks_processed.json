[
  {
    "id": "sealevel_0_signer_authorization",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "0-signer-authorization_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n#[program]\npub mod signer_authorization_insecure {\n    use super::*;\n\n    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {\n        msg!(\"GM {}\", ctx.accounts.authority.key().to_string());\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct LogMessage<'info> {\n    authority: AccountInfo<'info>,\n}\n",
    "vulnerable_function": "signer_authorization_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "missing_signer_check",
    "category": "0-signer-authorization",
    "severity": "critical",
    "difficulty_tier": 2,
    "description": "Missing signer check allows unauthorized users to call functions that should be restricted",
    "fix_description": "Add is_signer check: require!(ctx.accounts.authority.is_signer, ErrorCode::Unauthorized)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/0-signer-authorization/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_1_account_data_matching",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "1-account-data-matching_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program_pack::Pack;\nuse spl_token::state::Account as SplTokenAccount;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod account_data_matching_insecure {\n    use super::*;\n\n    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {\n        let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?;\n        msg!(\"Your account balance is: {}\", token.amount);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct LogMessage<'info> {\n    token: AccountInfo<'info>,\n    authority: Signer<'info>,\n}\n",
    "vulnerable_function": "account_data_matching_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "account_validation",
    "category": "1-account-data-matching",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Lack of account data validation allows account substitution attacks",
    "fix_description": "Validate account data matches expected values before use",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/1-account-data-matching/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_10_sysvar_address_checking",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "10-sysvar-address-checking_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod insecure {\n    use super::*;\n\n    pub fn check_sysvar_address(ctx: Context<CheckSysvarAddress>) -> Result<()> {\n        msg!(\"Rent Key -> {}\", ctx.accounts.rent.key().to_string());\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CheckSysvarAddress<'info> {\n    rent: AccountInfo<'info>,\n}\n",
    "vulnerable_function": "insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "sysvar_validation",
    "category": "10-sysvar-address-checking",
    "severity": "medium",
    "difficulty_tier": 2,
    "description": "Missing sysvar address validation allows fake sysvar injection",
    "fix_description": "Validate sysvar address: require!(sysvar.key() == expected_sysvar_address)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/10-sysvar-address-checking/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_2_owner_checks",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "2-owner-checks_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program_error::ProgramError;\nuse anchor_lang::solana_program::program_pack::Pack;\nuse spl_token::state::Account as SplTokenAccount;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod owner_checks_insecure {\n    use super::*;\n\n    pub fn log_message(ctx: Context<LogMessage>) -> ProgramResult {\n        let token = SplTokenAccount::unpack(&ctx.accounts.token.data.borrow())?;\n        if ctx.accounts.authority.key != &token.owner {\n            return Err(ProgramError::InvalidAccountData);\n        }\n        msg!(\"Your account balance is: {}\", token.amount);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct LogMessage<'info> {\n    token: AccountInfo<'info>,\n    authority: Signer<'info>,\n}\n",
    "vulnerable_function": "owner_checks_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "missing_owner_check",
    "category": "2-owner-checks",
    "severity": "critical",
    "difficulty_tier": 2,
    "description": "Missing owner validation allows use of accounts owned by wrong programs",
    "fix_description": "Check account owner: require!(account.owner == expected_program_id, ErrorCode::InvalidOwner)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/2-owner-checks/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_3_type_cosplay",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "3-type-cosplay_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse borsh::{BorshDeserialize, BorshSerialize};\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod type_cosplay_insecure {\n    use super::*;\n\n    pub fn update_user(ctx: Context<UpdateUser>) -> ProgramResult {\n        let user = User::try_from_slice(&ctx.accounts.user.data.borrow()).unwrap();\n        if ctx.accounts.user.owner != ctx.program_id {\n            return Err(ProgramError::IllegalOwner);\n        }\n        if user.authority != ctx.accounts.authority.key() {\n            return Err(ProgramError::InvalidAccountData);\n        }\n        msg!(\"GM {}\", user.authority);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UpdateUser<'info> {\n    user: AccountInfo<'info>,\n    authority: Signer<'info>,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct User {\n    authority: Pubkey,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct Metadata {\n    account: Pubkey,\n}\n",
    "vulnerable_function": "type_cosplay_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "type_cosplay",
    "category": "3-type-cosplay",
    "severity": "high",
    "difficulty_tier": 3,
    "description": "Account type confusion - accounts can impersonate other account types",
    "fix_description": "Use Anchor's Account<'info, T> type to enforce account type validation",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/3-type-cosplay/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_4_initialization",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "4-initialization_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse std::ops::DerefMut;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod initialization_insecure {\n    use super::*;\n\n    pub fn initialize(ctx: Context<Initialize>) -> ProgramResult {\n        let mut user = User::try_from_slice(&ctx.accounts.user.data.borrow()).unwrap();\n\n        user.authority = ctx.accounts.authority.key();\n\n        let mut storage = ctx.accounts.user.try_borrow_mut_data()?;\n        user.serialize(storage.deref_mut()).unwrap();\n        Ok(())\n    }\n}\n\n/*\n- reinitialize\n- create and dont initialize\n- passing previously initialzed accounts from other programs\n  (e.g. token program => need to check delegate and authority)\n*/\n\n#[derive(Accounts)]\npub struct Initialize<'info> {\n    user: AccountInfo<'info>,\n    authority: Signer<'info>,\n}\n\n#[derive(BorshSerialize, BorshDeserialize)]\npub struct User {\n    authority: Pubkey,\n}\n",
    "vulnerable_function": "initialization_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "missing_initialization_check",
    "category": "4-initialization",
    "severity": "critical",
    "difficulty_tier": 2,
    "description": "Missing initialization checks allow reinitialization attacks",
    "fix_description": "Add initialization flag and check: require!(!account.is_initialized, ErrorCode::AlreadyInitialized)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/4-initialization/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_5_arbitrary_cpi",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "5-arbitrary-cpi_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod arbitrary_cpi_insecure {\n    use super::*;\n\n    pub fn cpi(ctx: Context<Cpi>, amount: u64) -> ProgramResult {\n        solana_program::program::invoke(\n            &spl_token::instruction::transfer(\n                ctx.accounts.token_program.key,\n                ctx.accounts.source.key,\n                ctx.accounts.destination.key,\n                ctx.accounts.authority.key,\n                &[],\n                amount,\n            )?,\n            &[\n                ctx.accounts.source.clone(),\n                ctx.accounts.destination.clone(),\n                ctx.accounts.authority.clone(),\n            ],\n        )\n    }\n}\n\n#[derive(Accounts)]\npub struct Cpi<'info> {\n    source: AccountInfo<'info>,\n    destination: AccountInfo<'info>,\n    authority: AccountInfo<'info>,\n    token_program: AccountInfo<'info>,\n}\n",
    "vulnerable_function": "arbitrary_cpi_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "cpi_injection",
    "category": "5-arbitrary-cpi",
    "severity": "critical",
    "difficulty_tier": 3,
    "description": "Unconstrained Cross-Program Invocation (CPI) allows arbitrary program calls",
    "fix_description": "Constrain target program in CPI: require!(ctx.accounts.target_program.key() == expected_program_id)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/5-arbitrary-cpi/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_6_duplicate_mutable_accounts",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "6-duplicate-mutable-accounts_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod duplicate_mutable_accounts_insecure {\n    use super::*;\n\n    pub fn update(ctx: Context<Update>, a: u64, b: u64) -> ProgramResult {\n        let user_a = &mut ctx.accounts.user_a;\n        let user_b = &mut ctx.accounts.user_b;\n\n        user_a.data = a;\n        user_b.data = b;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Update<'info> {\n    user_a: Account<'info, User>,\n    user_b: Account<'info, User>,\n}\n\n#[account]\npub struct User {\n    data: u64,\n}\n",
    "vulnerable_function": "duplicate_mutable_accounts_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "duplicate_mutable_accounts",
    "category": "6-duplicate-mutable-accounts",
    "severity": "high",
    "difficulty_tier": 4,
    "description": "Passing the same account twice as mutable can cause unexpected behavior",
    "fix_description": "Add constraint to ensure accounts are different: #[account(constraint = account1.key() != account2.key())]",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/6-duplicate-mutable-accounts/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_7_bump_seed_canonicalization",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "7-bump-seed-canonicalization_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod bump_seed_canonicalization_insecure {\n    use super::*;\n\n    pub fn set_value(ctx: Context<BumpSeed>, key: u64, new_value: u64, bump: u8) -> ProgramResult {\n        let address =\n            Pubkey::create_program_address(&[key.to_le_bytes().as_ref(), &[bump]], ctx.program_id)?;\n        if address != ctx.accounts.data.key() {\n            return Err(ProgramError::InvalidArgument);\n        }\n\n        ctx.accounts.data.value = new_value;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct BumpSeed<'info> {\n    data: Account<'info, Data>,\n}\n\n#[account]\npub struct Data {\n    value: u64,\n}\n",
    "vulnerable_function": "bump_seed_canonicalization_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "pda_manipulation",
    "category": "7-bump-seed-canonicalization",
    "severity": "high",
    "difficulty_tier": 3,
    "description": "Non-canonical bump seeds in PDA derivation can be exploited",
    "fix_description": "Use canonical bump: let (pda, bump) = Pubkey::find_program_address(&[seed], program_id); require!(bump == provided_bump)",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/7-bump-seed-canonicalization/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_8_pda_sharing",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "8-pda-sharing_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount};\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod pda_sharing_insecure {\n    use super::*;\n\n    pub fn withdraw_tokens(ctx: Context<WithdrawTokens>) -> ProgramResult {\n        let amount = ctx.accounts.vault.amount;\n        let seeds = &[ctx.accounts.pool.mint.as_ref(), &[ctx.accounts.pool.bump]];\n        token::transfer(ctx.accounts.transfer_ctx().with_signer(&[seeds]), amount)\n    }\n}\n\n#[derive(Accounts)]\npub struct WithdrawTokens<'info> {\n    #[account(has_one = vault, has_one = withdraw_destination)]\n    pool: Account<'info, TokenPool>,\n    vault: Account<'info, TokenAccount>,\n    withdraw_destination: Account<'info, TokenAccount>,\n    authority: Signer<'info>,\n    token_program: Program<'info, Token>,\n}\n\nimpl<'info> WithdrawTokens<'info> {\n    pub fn transfer_ctx(&self) -> CpiContext<'_, '_, '_, 'info, token::Transfer<'info>> {\n        let program = self.token_program.to_account_info();\n        let accounts = token::Transfer {\n            from: self.vault.to_account_info(),\n            to: self.withdraw_destination.to_account_info(),\n            authority: self.authority.to_account_info(),\n        };\n        CpiContext::new(program, accounts)\n    }\n}\n\n#[account]\npub struct TokenPool {\n    vault: Pubkey,\n    mint: Pubkey,\n    withdraw_destination: Pubkey,\n    bump: u8,\n}\n",
    "vulnerable_function": "pda_sharing_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "pda_sharing",
    "category": "8-pda-sharing",
    "severity": "medium",
    "difficulty_tier": 3,
    "description": "Improper PDA seed design allows accounts to be controlled by unintended parties",
    "fix_description": "Use unique seeds per user: &[b\"prefix\", user.key().as_ref(), &[bump]]",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/8-pda-sharing/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  },
  {
    "id": "sealevel_9_closing_accounts",
    "source_dataset": "sealevel-attacks",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "9-closing-accounts_insecure.rs",
    "file_content": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod closing_accounts_insecure {\n    use super::*;\n\n    pub fn close(ctx: Context<Close>) -> ProgramResult {\n        let dest_starting_lamports = ctx.accounts.destination.lamports();\n\n        **ctx.accounts.destination.lamports.borrow_mut() = dest_starting_lamports\n            .checked_add(ctx.accounts.account.to_account_info().lamports())\n            .unwrap();\n        **ctx.accounts.account.to_account_info().lamports.borrow_mut() = 0;\n\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Close<'info> {\n    account: Account<'info, Data>,\n    destination: AccountInfo<'info>,\n}\n\n#[account]\npub struct Data {\n    data: u64,\n}\n",
    "vulnerable_function": "closing_accounts_insecure",
    "vulnerable_lines": [],
    "vulnerability_type": "unclosed_accounts",
    "category": "9-closing-accounts",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Improper account closure leaves accounts open to revival attacks",
    "fix_description": "Zero out data and transfer lamports to recipient, use close constraint in Anchor",
    "references": [
      "https://github.com/coral-xyz/sealevel-attacks"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": false,
    "context_level": "single_file",
    "original_source_path": "programs/9-closing-accounts/insecure/src/lib.rs",
    "source": "Coral XYZ / Sealevel Attacks"
  }
]