[
  {
    "id": "smartbugs_arithmetic_BECToken",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "BECToken.sol",
    "file_content": "/*\n * @source: https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#bectokensol\n * @author: -\n * @vulnerable_at_lines: 264\n */\n\npragma solidity ^0.4.16;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n    // require(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\n/**\n * @title ERC20Basic\n * @dev Simpler version of ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/179\n */\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title Basic token\n * @dev Basic version of StandardToken, with no allowances.\n */\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n}\n\n/**\n * @title ERC20 interface\n * @dev see https://github.com/ethereum/EIPs/issues/20\n */\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * @dev https://github.com/ethereum/EIPs/issues/20\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   *\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\n/**\n * @title Pausable token\n *\n * @dev StandardToken modified with pausable transfers.\n **/\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n    return super.approve(_spender, _value);\n  }\n\n  function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    // <yes> <report> ARITHMETIC\n    uint256 amount = uint256(cnt) * _value;\n    require(cnt > 0 && cnt <= 20);\n    require(_value > 0 && balances[msg.sender] >= amount);\n\n    balances[msg.sender] = balances[msg.sender].sub(amount);\n    for (uint i = 0; i < cnt; i++) {\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n  }\n}\n\n/**\n * @title Bec Token\n *\n * @dev Implementation of Bec Token based on the basic standard token.\n */\ncontract BecToken is PausableToken {\n    /**\n    * Public variables of the token\n    * The following variables are OPTIONAL vanities. One does not have to include them.\n    * They allow one to customise the token contract & in no way influences the core functionality.\n    * Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name = \"BeautyChain\";\n    string public symbol = \"BEC\";\n    string public version = '1.0.0';\n    uint8 public decimals = 18;\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     */\n    function BecToken() {\n      totalSupply = 7000000000 * (10**(uint256(decimals)));\n      balances[msg.sender] = totalSupply;    // Give the creator all initial tokens\n    }\n\n    function () {\n        //if ether is sent to this address, send it back.\n        revert();\n    }\n}\n",
    "vulnerable_function": "batchTransfer",
    "vulnerable_lines": [
      264
    ],
    "vulnerability_type": "integer_issues",
    "original_category": "arithmetic",
    "severity": "high",
    "difficulty_tier": 4,
    "description": "Integer overflow/underflow vulnerability - arithmetic operations without bounds checking at line(s) 264",
    "fix_description": "Use SafeMath library or Solidity 0.8+ with built-in overflow checks",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/arithmetic/BECToken.sol",
    "pragma": "0.4.16",
    "source_url": "https://smartcontractsecurity.github.io/SWC-registry/docs/SWC-101#bectokensol"
  },
  {
    "id": "smartbugs_bad_randomness_blackjack",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "blackjack.sol",
    "file_content": "/*\n * @article: https://blog.positive.com/predicting-random-numbers-in-ethereum-smart-contracts-e5358c6b8620\n * @source: https://etherscan.io/address/0xa65d59708838581520511d98fb8b5d1f76a96cad#code\n * @vulnerable_at_lines: 17,19,21\n * @author: -\n */\n\n pragma solidity ^0.4.9;\n\nlibrary Deck {\n\t// returns random number from 0 to 51\n\t// let's say 'value' % 4 means suit (0 - Hearts, 1 - Spades, 2 - Diamonds, 3 - Clubs)\n\t//\t\t\t 'value' / 4 means: 0 - King, 1 - Ace, 2 - 10 - pip values, 11 - Jacket, 12 - Queen\n\n\tfunction deal(address player, uint8 cardNumber) internal returns (uint8) {\n\t\t// <yes> <report> BAD_RANDOMNESS\n\t\tuint b = block.number;\n\t\t// <yes> <report> BAD_RANDOMNESS\n\t\tuint timestamp = block.timestamp;\n\t\t// <yes> <report> BAD_RANDOMNESS\n\t\treturn uint8(uint256(keccak256(block.blockhash(b), player, cardNumber, timestamp)) % 52);\n\t}\n\n\tfunction valueOf(uint8 card, bool isBigAce) internal constant returns (uint8) {\n\t\tuint8 value = card / 4;\n\t\tif (value == 0 || value == 11 || value == 12) { // Face cards\n\t\t\treturn 10;\n\t\t}\n\t\tif (value == 1 && isBigAce) { // Ace is worth 11\n\t\t\treturn 11;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction isAce(uint8 card) internal constant returns (bool) {\n\t\treturn card / 4 == 1;\n\t}\n\n\tfunction isTen(uint8 card) internal constant returns (bool) {\n\t\treturn card / 4 == 10;\n\t}\n}\n\n\ncontract BlackJack {\n\tusing Deck for *;\n\n\tuint public minBet = 50 finney; // 0.05 eth\n\tuint public maxBet = 5 ether;\n\n\tuint8 BLACKJACK = 21;\n\n  enum GameState { Ongoing, Player, Tie, House }\n\n\tstruct Game {\n\t\taddress player; // address \u0438\u0433\u0440\u043e\u043a\u0430\n\t\tuint bet; // \u0441\u0442\u044b\u0432\u043a\u0430\n\n\t\tuint8[] houseCards; // \u043a\u0430\u0440\u0442\u044b \u0434\u0438\u043b\u043b\u0435\u0440\u0430\n\t\tuint8[] playerCards; // \u043a\u0430\u0440\u0442\u044b \u0438\u0433\u0440\u043e\u043a\u0430\n\n\t\tGameState state; // \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435\n\t\tuint8 cardsDealt;\n\t}\n\n\tmapping (address => Game) public games;\n\n\tmodifier gameIsGoingOn() {\n\t\tif (games[msg.sender].player == 0 || games[msg.sender].state != GameState.Ongoing) {\n\t\t\tthrow; // game doesn't exist or already finished\n\t\t}\n\t\t_;\n\t}\n\n\tevent Deal(\n        bool isUser,\n        uint8 _card\n    );\n\n    event GameStatus(\n    \tuint8 houseScore,\n    \tuint8 houseScoreBig,\n    \tuint8 playerScore,\n    \tuint8 playerScoreBig\n    );\n\n    event Log(\n    \tuint8 value\n    );\n\n\tfunction BlackJack() {\n\n\t}\n\n\tfunction () payable {\n\n\t}\n\n\t// starts a new game\n\tfunction deal() public payable {\n\t\tif (games[msg.sender].player != 0 && games[msg.sender].state == GameState.Ongoing) {\n\t\t\tthrow; // game is already going on\n\t\t}\n\n\t\tif (msg.value < minBet || msg.value > maxBet) {\n\t\t\tthrow; // incorrect bet\n\t\t}\n\n\t\tuint8[] memory houseCards = new uint8[](1);\n\t\tuint8[] memory playerCards = new uint8[](2);\n\n\t\t// deal the cards\n\t\tplayerCards[0] = Deck.deal(msg.sender, 0);\n\t\tDeal(true, playerCards[0]);\n\t\thouseCards[0] = Deck.deal(msg.sender, 1);\n\t\tDeal(false, houseCards[0]);\n\t\tplayerCards[1] = Deck.deal(msg.sender, 2);\n\t\tDeal(true, playerCards[1]);\n\n\t\tgames[msg.sender] = Game({\n\t\t\tplayer: msg.sender,\n\t\t\tbet: msg.value,\n\t\t\thouseCards: houseCards,\n\t\t\tplayerCards: playerCards,\n\t\t\tstate: GameState.Ongoing,\n\t\t\tcardsDealt: 3\n\t\t});\n\n\t\tcheckGameResult(games[msg.sender], false);\n\t}\n\n\t// deals one more card to the player\n\tfunction hit() public gameIsGoingOn {\n\t\tuint8 nextCard = games[msg.sender].cardsDealt;\n\t\tgames[msg.sender].playerCards.push(Deck.deal(msg.sender, nextCard));\n\t\tgames[msg.sender].cardsDealt = nextCard + 1;\n\t\tDeal(true, games[msg.sender].playerCards[games[msg.sender].playerCards.length - 1]);\n\t\tcheckGameResult(games[msg.sender], false);\n\t}\n\n\t// finishes the game\n\tfunction stand() public gameIsGoingOn {\n\n\t\tvar (houseScore, houseScoreBig) = calculateScore(games[msg.sender].houseCards);\n\n\t\twhile (houseScoreBig < 17) {\n\t\t\tuint8 nextCard = games[msg.sender].cardsDealt;\n\t\t\tuint8 newCard = Deck.deal(msg.sender, nextCard);\n\t\t\tgames[msg.sender].houseCards.push(newCard);\n\t\t\tgames[msg.sender].cardsDealt = nextCard + 1;\n\t\t\thouseScoreBig += Deck.valueOf(newCard, true);\n\t\t\tDeal(false, newCard);\n\t\t}\n\n\t\tcheckGameResult(games[msg.sender], true);\n\t}\n\n\t// @param finishGame - whether to finish the game or not (in case of Blackjack the game finishes anyway)\n\tfunction checkGameResult(Game game, bool finishGame) private {\n\t\t// calculate house score\n\t\tvar (houseScore, houseScoreBig) = calculateScore(game.houseCards);\n\t\t// calculate player score\n\t\tvar (playerScore, playerScoreBig) = calculateScore(game.playerCards);\n\n\t\tGameStatus(houseScore, houseScoreBig, playerScore, playerScoreBig);\n\n\t\tif (houseScoreBig == BLACKJACK || houseScore == BLACKJACK) {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\t\t\t\t// TIE\n\t\t\t\tif (!msg.sender.send(game.bet)) throw; // return bet to the player\n\t\t\t\tgames[msg.sender].state = GameState.Tie; // finish the game\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\t// HOUSE WON\n\t\t\t\tgames[msg.sender].state = GameState.House; // simply finish the game\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\t\t\t\t// PLAYER WON\n\t\t\t\tif (game.playerCards.length == 2 && (Deck.isTen(game.playerCards[0]) || Deck.isTen(game.playerCards[1]))) {\n\t\t\t\t\t// Natural blackjack => return x2.5\n\t\t\t\t\tif (!msg.sender.send((game.bet * 5) / 2)) throw; // send prize to the player\n\t\t\t\t} else {\n\t\t\t\t\t// Usual blackjack => return x2\n\t\t\t\t\tif (!msg.sender.send(game.bet * 2)) throw; // send prize to the player\n\t\t\t\t}\n\t\t\t\tgames[msg.sender].state = GameState.Player; // finish the game\n\t\t\t\treturn;\n\t\t\t} else {\n\n\t\t\t\tif (playerScore > BLACKJACK) {\n\t\t\t\t\t// BUST, HOUSE WON\n\t\t\t\t\tLog(1);\n\t\t\t\t\tgames[msg.sender].state = GameState.House; // finish the game\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!finishGame) {\n\t\t\t\t\treturn; // continue the game\n\t\t\t\t}\n\n                // \u043d\u0435\u0434\u043e\u0431\u043e\u0440\n\t\t\t\tuint8 playerShortage = 0;\n\t\t\t\tuint8 houseShortage = 0;\n\n\t\t\t\t// player decided to finish the game\n\t\t\t\tif (playerScoreBig > BLACKJACK) {\n\t\t\t\t\tif (playerScore > BLACKJACK) {\n\t\t\t\t\t\t// HOUSE WON\n\t\t\t\t\t\tgames[msg.sender].state = GameState.House; // simply finish the game\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplayerShortage = BLACKJACK - playerScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tplayerShortage = BLACKJACK - playerScoreBig;\n\t\t\t\t}\n\n\t\t\t\tif (houseScoreBig > BLACKJACK) {\n\t\t\t\t\tif (houseScore > BLACKJACK) {\n\t\t\t\t\t\t// PLAYER WON\n\t\t\t\t\t\tif (!msg.sender.send(game.bet * 2)) throw; // send prize to the player\n\t\t\t\t\t\tgames[msg.sender].state = GameState.Player;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thouseShortage = BLACKJACK - houseScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thouseShortage = BLACKJACK - houseScoreBig;\n\t\t\t\t}\n\n                // ?????????????????????? \u043f\u043e\u0447\u0435\u043c\u0443 \u0438\u0433\u0440\u0430 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f?\n\t\t\t\tif (houseShortage == playerShortage) {\n\t\t\t\t\t// TIE\n\t\t\t\t\tif (!msg.sender.send(game.bet)) throw; // return bet to the player\n\t\t\t\t\tgames[msg.sender].state = GameState.Tie;\n\t\t\t\t} else if (houseShortage > playerShortage) {\n\t\t\t\t\t// PLAYER WON\n\t\t\t\t\tif (!msg.sender.send(game.bet * 2)) throw; // send prize to the player\n\t\t\t\t\tgames[msg.sender].state = GameState.Player;\n\t\t\t\t} else {\n\t\t\t\t\tgames[msg.sender].state = GameState.House;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction calculateScore(uint8[] cards) private constant returns (uint8, uint8) {\n\t\tuint8 score = 0;\n\t\tuint8 scoreBig = 0; // in case of Ace there could be 2 different scores\n\t\tbool bigAceUsed = false;\n\t\tfor (uint i = 0; i < cards.length; ++i) {\n\t\t\tuint8 card = cards[i];\n\t\t\tif (Deck.isAce(card) && !bigAceUsed) { // doesn't make sense to use the second Ace as 11, because it leads to the losing\n\t\t\t\tscoreBig += Deck.valueOf(card, true);\n\t\t\t\tbigAceUsed = true;\n\t\t\t} else {\n\t\t\t\tscoreBig += Deck.valueOf(card, false);\n\t\t\t}\n\t\t\tscore += Deck.valueOf(card, false);\n\t\t}\n\t\treturn (score, scoreBig);\n\t}\n\n\tfunction getPlayerCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif (id < 0 || id > games[msg.sender].playerCards.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn games[msg.sender].playerCards[id];\n\t}\n\n\tfunction getHouseCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif (id < 0 || id > games[msg.sender].houseCards.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn games[msg.sender].houseCards[id];\n\t}\n\n\tfunction getPlayerCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn games[msg.sender].playerCards.length;\n\t}\n\n\tfunction getHouseCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn games[msg.sender].houseCards.length;\n\t}\n\n\tfunction getGameState() public constant returns (uint8) {\n\t\tif (games[msg.sender].player == 0) {\n\t\t\tthrow; // game doesn't exist\n\t\t}\n\n\t\tGame game = games[msg.sender];\n\n\t\tif (game.state == GameState.Player) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (game.state == GameState.House) {\n\t\t\treturn 2;\n\t\t}\n\t\tif (game.state == GameState.Tie) {\n\t\t\treturn 3;\n\t\t}\n\n\t\treturn 0; // the game is still going on\n\t}\n\n}\n",
    "vulnerable_function": "deal",
    "vulnerable_lines": [
      17
    ],
    "vulnerability_type": "weak_randomness",
    "original_category": "bad_randomness",
    "severity": "medium",
    "difficulty_tier": 4,
    "description": "Weak randomness - predictable random number generation at line(s) 17",
    "fix_description": "Use Chainlink VRF or commit-reveal scheme for randomness",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/bad_randomness/blackjack.sol",
    "pragma": "0.4.9",
    "source_url": "https://etherscan.io/address/0xa65d59708838581520511d98fb8b5d1f76a96cad#code"
  },
  {
    "id": "smartbugs_bad_randomness_smart_billions",
    "source_dataset": "smartbugs-curated",
    "language": "solidity",
    "chain": "evm",
    "file_name": "smart_billions.sol",
    "file_content": "/*\n * @source: https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code\n * @author: -\n * @vulnerable_at_lines: 523,560,700,702,704,706,708,710,712,714,716,718\n */\n\npragma solidity ^0.4.13;\n\nlibrary SafeMath {\n  function sub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n  function add(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint public totalSupply;\n  address public owner; //owner\n  address public animator; //animator\n  function balanceOf(address who) constant returns (uint);\n  function transfer(address to, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n  function commitDividend(address who) internal; // pays remaining dividend\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) constant returns (uint);\n  function transferFrom(address from, address to, uint value);\n  function approve(address spender, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n  mapping(address => uint) balances;\n\n  modifier onlyPayloadSize(uint size) {\n     assert(msg.data.length >= size + 4);\n     _;\n  }\n  /**\n  * @dev transfer token for a specified address\n  * @param _to The address to transfer to.\n  * @param _value The amount to be transferred.\n  */\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    commitDividend(msg.sender);\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    if(_to == address(this)) {\n        commitDividend(owner);\n        balances[owner] = balances[owner].add(_value);\n        Transfer(msg.sender, owner, _value);\n    }\n    else {\n        commitDividend(_to);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n    }\n  }\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param _owner The address to query the the balance of.\n  * @return An uint representing the amount owned by the passed address.\n  */\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\ncontract StandardToken is BasicToken, ERC20 {\n  mapping (address => mapping (address => uint)) allowed;\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param _from address The address which you want to send tokens from\n   * @param _to address The address which you want to transfer to\n   * @param _value uint the amout of tokens to be transfered\n   */\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n    commitDividend(_from);\n    commitDividend(_to);\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n  /**\n   * @dev Aprove the passed address to spend the specified amount of tokens on beahlf of msg.sender.\n   * @param _spender The address which will spend the funds.\n   * @param _value The amount of tokens to be spent.\n   */\n  function approve(address _spender, uint _value) {\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n  /**\n   * @dev Function to check the amount of tokens than an owner allowed to a spender.\n   * @param _owner address The address which owns the funds.\n   * @param _spender address The address which will spend the funds.\n   * @return A uint specifing the amount of tokens still avaible for the spender.\n   */\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\n/**\n * @title SmartBillions contract\n */\ncontract SmartBillions is StandardToken {\n\n    // metadata\n    string public constant name = \"SmartBillions Token\";\n    string public constant symbol = \"PLAY\";\n    uint public constant decimals = 0;\n\n    // contract state\n    struct Wallet {\n        uint208 balance; // current balance of user\n    \tuint16 lastDividendPeriod; // last processed dividend period of user's tokens\n    \tuint32 nextWithdrawBlock; // next withdrawal possible after this block number\n    }\n    mapping (address => Wallet) wallets;\n    struct Bet {\n        uint192 value; // bet size\n        uint32 betHash; // selected numbers\n        uint32 blockNum; // blocknumber when lottery runs\n    }\n    mapping (address => Bet) bets;\n\n    uint public walletBalance = 0; // sum of funds in wallets\n\n    // investment parameters\n    uint public investStart = 1; // investment start block, 0: closed, 1: preparation\n    uint public investBalance = 0; // funding from investors\n    uint public investBalanceMax = 200000 ether; // maximum funding\n    uint public dividendPeriod = 1;\n    uint[] public dividends; // dividens collected per period, growing array\n\n    // betting parameters\n    uint public maxWin = 0; // maximum prize won\n    uint public hashFirst = 0; // start time of building hashes database\n    uint public hashLast = 0; // last saved block of hashes\n    uint public hashNext = 0; // next available bet block.number\n    uint public hashBetSum = 0; // used bet volume of next block\n    uint public hashBetMax = 5 ether; // maximum bet size per block\n    uint[] public hashes; // space for storing lottery results\n\n    // constants\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\n    uint public constant hashesSize = 16384 ; // 30 days of blocks\n    uint public coldStoreLast = 0 ; // block of last cold store transfer\n\n    // events\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\n    event LogLoss(address indexed player, uint bethash, uint hash);\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\n    event LogRecordWin(address indexed player, uint amount);\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\n    event LogDividend(address indexed investor, uint amount, uint period);\n\n    modifier onlyOwner() {\n        assert(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyAnimator() {\n        assert(msg.sender == animator);\n        _;\n    }\n\n    // constructor\n    function SmartBillions() {\n        owner = msg.sender;\n        animator = msg.sender;\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\n        dividends.push(0); // not used\n        dividends.push(0); // current dividend\n    }\n\n/* getters */\n\n    /**\n     * @dev Show length of allocated swap space\n     */\n    function hashesLength() constant external returns (uint) {\n        return uint(hashes.length);\n    }\n\n    /**\n     * @dev Show balance of wallet\n     * @param _owner The address of the account.\n     */\n    function walletBalanceOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].balance);\n    }\n\n    /**\n     * @dev Show last dividend period processed\n     * @param _owner The address of the account.\n     */\n    function walletPeriodOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].lastDividendPeriod);\n    }\n\n    /**\n     * @dev Show block number when withdraw can continue\n     * @param _owner The address of the account.\n     */\n    function walletBlockOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].nextWithdrawBlock);\n    }\n\n    /**\n     * @dev Show bet size.\n     * @param _owner The address of the player.\n     */\n    function betValueOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].value);\n    }\n\n    /**\n     * @dev Show block number of lottery run for the bet.\n     * @param _owner The address of the player.\n     */\n    function betHashOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].betHash);\n    }\n\n    /**\n     * @dev Show block number of lottery run for the bet.\n     * @param _owner The address of the player.\n     */\n    function betBlockNumberOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].blockNum);\n    }\n\n    /**\n     * @dev Print number of block till next expected dividend payment\n     */\n    function dividendsBlocks() constant external returns (uint) {\n        if(investStart > 0) {\n            return(0);\n        }\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\n        if(period > dividendPeriod) {\n            return(0);\n        }\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\n    }\n\n/* administrative functions */\n\n    /**\n     * @dev Change owner.\n     * @param _who The address of new owner.\n     */\n    function changeOwner(address _who) external onlyOwner {\n        assert(_who != address(0));\n        commitDividend(msg.sender);\n        commitDividend(_who);\n        owner = _who;\n    }\n\n    /**\n     * @dev Change animator.\n     * @param _who The address of new animator.\n     */\n    function changeAnimator(address _who) external onlyAnimator {\n        assert(_who != address(0));\n        commitDividend(msg.sender);\n        commitDividend(_who);\n        animator = _who;\n    }\n\n    /**\n     * @dev Set ICO Start block.\n     * @param _when The block number of the ICO.\n     */\n    function setInvestStart(uint _when) external onlyOwner {\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\n        investStart = _when;\n    }\n\n    /**\n     * @dev Set maximum bet size per block\n     * @param _maxsum The maximum bet size in wei.\n     */\n    function setBetMax(uint _maxsum) external onlyOwner {\n        hashBetMax = _maxsum;\n    }\n\n    /**\n     * @dev Reset bet size accounting, to increase bet volume above safe limits\n     */\n    function resetBet() external onlyOwner {\n        hashNext = block.number + 3;\n        hashBetSum = 0;\n    }\n\n    /**\n     * @dev Move funds to cold storage\n     * @dev investBalance and walletBalance is protected from withdraw by owner\n     * @dev if funding is > 50% admin can withdraw only 0.25% of balance weakly\n     * @param _amount The amount of wei to move to cold storage\n     */\n    function coldStore(uint _amount) external onlyOwner {\n        houseKeeping();\n        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\n        if(investBalance >= investBalanceMax / 2){ // additional jackpot protection\n            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\n        }\n        msg.sender.transfer(_amount);\n        coldStoreLast = block.number;\n    }\n\n    /**\n     * @dev Move funds to contract jackpot\n     */\n    function hotStore() payable external {\n        houseKeeping();\n    }\n\n/* housekeeping functions */\n\n    /**\n     * @dev Update accounting\n     */\n    function houseKeeping() public {\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){ // ca. 14 days\n            investStart = 0; // start dividend payments\n        }\n        else {\n            if(hashFirst > 0){\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\n                if(period > dividends.length - 2) {\n                    dividends.push(0);\n                }\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\n                    dividendPeriod++;\n                }\n            }\n        }\n    }\n\n/* payments */\n\n    /**\n     * @dev Pay balance from wallet\n     */\n    function payWallet() public {\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\n            uint balance = wallets[msg.sender].balance;\n            wallets[msg.sender].balance = 0;\n            walletBalance -= balance;\n            pay(balance);\n        }\n    }\n\n    function pay(uint _amount) private {\n        uint maxpay = this.balance / 2;\n        if(maxpay >= _amount) {\n            msg.sender.transfer(_amount);\n            if(_amount > 1 finney) {\n                houseKeeping();\n            }\n        }\n        else {\n            uint keepbalance = _amount - maxpay;\n            walletBalance += keepbalance;\n            wallets[msg.sender].balance += uint208(keepbalance);\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\n            msg.sender.transfer(maxpay);\n        }\n    }\n\n/* investment functions */\n\n    /**\n     * @dev Buy tokens\n     */\n    function investDirect() payable external {\n        invest(owner);\n    }\n\n    /**\n     * @dev Buy tokens with affiliate partner\n     * @param _partner Affiliate partner\n     */\n    function invest(address _partner) payable public {\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\n        uint investing = msg.value;\n        if(investing > investBalanceMax - investBalance) {\n            investing = investBalanceMax - investBalance;\n            investBalance = investBalanceMax;\n            investStart = 0; // close investment round\n            msg.sender.transfer(msg.value.sub(investing)); // send back funds immediately\n        }\n        else{\n            investBalance += investing;\n        }\n        if(_partner == address(0) || _partner == owner){\n            walletBalance += investing / 10;\n            wallets[owner].balance += uint208(investing / 10);} // 10% for marketing if no affiliates\n        else{\n            walletBalance += (investing * 5 / 100) * 2;\n            wallets[owner].balance += uint208(investing * 5 / 100); // 5% initial marketing funds\n            wallets[_partner].balance += uint208(investing * 5 / 100);} // 5% for affiliates\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod); // assert(dividendPeriod == 1);\n        uint senderBalance = investing / 10**15;\n        uint ownerBalance = investing * 16 / 10**17  ;\n        uint animatorBalance = investing * 10 / 10**17  ;\n        balances[msg.sender] += senderBalance;\n        balances[owner] += ownerBalance ; // 13% of shares go to developers\n        balances[animator] += animatorBalance ; // 8% of shares go to animator\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\n        Transfer(address(0),msg.sender,senderBalance); // for etherscan\n        Transfer(address(0),owner,ownerBalance); // for etherscan\n        Transfer(address(0),animator,animatorBalance); // for etherscan\n        LogInvestment(msg.sender,_partner,investing);\n    }\n\n    /**\n     * @dev Delete all tokens owned by sender and return unpaid dividends and 90% of initial investment\n     */\n    function disinvest() external {\n        require(investStart == 0);\n        commitDividend(msg.sender);\n        uint initialInvestment = balances[msg.sender] * 10**15;\n        Transfer(msg.sender,address(0),balances[msg.sender]); // for etherscan\n        delete balances[msg.sender]; // totalSupply stays the same, investBalance is reduced\n        investBalance -= initialInvestment;\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\n        payWallet();\n    }\n\n    /**\n     * @dev Pay unpaid dividends\n     */\n    function payDividends() external {\n        require(investStart == 0);\n        commitDividend(msg.sender);\n        payWallet();\n    }\n\n    /**\n     * @dev Commit remaining dividends before transfer of tokens\n     */\n    function commitDividend(address _who) internal {\n        uint last = wallets[_who].lastDividendPeriod;\n        if((balances[_who]==0) || (last==0)){\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\n            return;\n        }\n        if(last==dividendPeriod) {\n            return;\n        }\n        uint share = balances[_who] * 0xffffffff / totalSupply;\n        uint balance = 0;\n        for(;last<dividendPeriod;last++) {\n            balance += share * dividends[last];\n        }\n        balance = (balance / 0xffffffff);\n        walletBalance += balance;\n        wallets[_who].balance += uint208(balance);\n        wallets[_who].lastDividendPeriod = uint16(last);\n        LogDividend(_who,balance,last);\n    }\n\n/* lottery functions */\n\n    function betPrize(Bet _player, uint24 _hash) constant private returns (uint) { // house fee 13.85%\n        uint24 bethash = uint24(_player.betHash);\n        uint24 hit = bethash ^ _hash;\n        uint24 matches =\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\n        if(matches == 6){\n            return(uint(_player.value) * 7000000);\n        }\n        if(matches == 5){\n            return(uint(_player.value) * 20000);\n        }\n        if(matches == 4){\n            return(uint(_player.value) * 500);\n        }\n        if(matches == 3){\n            return(uint(_player.value) * 25);\n        }\n        if(matches == 2){\n            return(uint(_player.value) * 3);\n        }\n        return(0);\n    }\n\n    /**\n     * @dev Check if won in lottery\n     */\n    function betOf(address _who) constant external returns (uint)  {\n        Bet memory player = bets[_who];\n        if( (player.value==0) ||\n            (player.blockNum<=1) ||\n            (block.number<player.blockNum) ||\n            (block.number>=player.blockNum + (10 * hashesSize))){\n            return(0);\n        }\n        if(block.number<player.blockNum+256){\n            // <yes> <report> BAD_RANDOMNESS\n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\n        }\n        if(hashFirst>0){\n            uint32 hash = getHash(player.blockNum);\n            if(hash == 0x1000000) { // load hash failed :-(, return funds\n                return(uint(player.value));\n            }\n            else{\n                return(betPrize(player,uint24(hash)));\n            }\n\t}\n        return(0);\n    }\n\n    /**\n     * @dev Check if won in lottery\n     */\n    function won() public {\n        Bet memory player = bets[msg.sender];\n        if(player.blockNum==0){ // create a new player\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n            return;\n        }\n        if((player.value==0) || (player.blockNum==1)){\n            payWallet();\n            return;\n        }\n        require(block.number>player.blockNum); // if there is an active bet, throw()\n        if(player.blockNum + (10 * hashesSize) <= block.number){ // last bet too long ago, lost !\n            LogLate(msg.sender,player.blockNum,block.number);\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n            return;\n        }\n        uint prize = 0;\n        uint32 hash = 0;\n        if(block.number<player.blockNum+256){\n            // <yes> <report> BAD_RANDOMNESS\n            hash = uint24(block.blockhash(player.blockNum));\n            prize = betPrize(player,uint24(hash));\n        }\n        else {\n            if(hashFirst>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\n                hash = getHash(player.blockNum);\n                if(hash == 0x1000000) { // load hash failed :-(, return funds\n                    prize = uint(player.value);\n                }\n                else{\n                    prize = betPrize(player,uint24(hash));\n                }\n\t    }\n            else{\n                LogLate(msg.sender,player.blockNum,block.number);\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n                return();\n            }\n        }\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n        if(prize>0) {\n            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\n            if(prize > maxWin){\n                maxWin = prize;\n                LogRecordWin(msg.sender,prize);\n            }\n            pay(prize);\n        }\n        else{\n            LogLoss(msg.sender,uint(player.betHash),uint(hash));\n        }\n    }\n\n    /**\n     * @dev Send ether to buy tokens during ICO\n     * @dev or send less than 1 ether to contract to play\n     * @dev or send 0 to collect prize\n     */\n    function () payable external {\n        if(msg.value > 0){\n            if(investStart>1){ // during ICO payment to the contract is treated as investment\n                invest(owner);\n            }\n            else{ // if not ICO running payment to contract is treated as play\n                play();\n            }\n            return;\n        }\n        //check for dividends and other assets\n        if(investStart == 0 && balances[msg.sender]>0){\n            commitDividend(msg.sender);}\n        won(); // will run payWallet() if nothing else available\n    }\n\n    /**\n     * @dev Play in lottery\n     */\n    function play() payable public returns (uint) {\n        return playSystem(uint(sha3(msg.sender,block.number)), address(0));\n    }\n\n    /**\n     * @dev Play in lottery with random numbers\n     * @param _partner Affiliate partner\n     */\n    function playRandom(address _partner) payable public returns (uint) {\n        return playSystem(uint(sha3(msg.sender,block.number)), _partner);\n    }\n\n    /**\n     * @dev Play in lottery with own numbers\n     * @param _partner Affiliate partner\n     */\n    function playSystem(uint _hash, address _partner) payable public returns (uint) {\n        won(); // check if player did not win\n        uint24 bethash = uint24(_hash);\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\n        if(msg.value > 0){\n            if(investStart==0) { // dividends only after investment finished\n                dividends[dividendPeriod] += msg.value / 20; // 5% dividend\n            }\n            if(_partner != address(0)) {\n                uint fee = msg.value / 100;\n                walletBalance += fee;\n                wallets[_partner].balance += uint208(fee); // 1% for affiliates\n            }\n            if(hashNext < block.number + 3) {\n                hashNext = block.number + 3;\n                hashBetSum = msg.value;\n            }\n            else{\n                if(hashBetSum > hashBetMax) {\n                    hashNext++;\n                    hashBetSum = msg.value;\n                }\n                else{\n                    hashBetSum += msg.value;\n                }\n            }\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\n            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\n        }\n        putHash(); // players help collecing data\n        return(hashNext);\n    }\n\n/* database functions */\n\n    /**\n     * @dev Create hash data swap space\n     * @param _sadd Number of hashes to add (<=256)\n     */\n    function addHashes(uint _sadd) public returns (uint) {\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\n        uint n = hashes.length;\n        if(n + _sadd > hashesSize){\n            hashes.length = hashesSize;\n        }\n        else{\n            hashes.length += _sadd;\n        }\n        for(;n<hashes.length;n++){ // make sure to burn gas\n            hashes[n] = 1;\n        }\n        if(hashes.length>=hashesSize) { // assume block.number > 10\n            hashFirst = block.number - ( block.number % 10);\n            hashLast = hashFirst;\n        }\n        return(hashes.length);\n    }\n\n    /**\n     * @dev Create hash data swap space, add 128 hashes\n     */\n    function addHashes128() external returns (uint) {\n        return(addHashes(128));\n    }\n\n    function calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {\n        // <yes> <report> BAD_RANDOMNESS\n        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\n        // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\n            // <yes> <report> BAD_RANDOMNESS\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\n            | ( ( uint(_delta) / hashesSize) << 240));\n    }\n\n    function getHash(uint _block) constant private returns (uint32) {\n        uint delta = (_block - hashFirst) / 10;\n        uint hash = hashes[delta % hashesSize];\n        if(delta / hashesSize != hash >> 240) {\n            return(0x1000000); // load failed, incorrect data in hashes\n        }\n        uint slotp = (_block - hashFirst) % 10;\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\n    }\n\n    /**\n     * @dev Fill hash data\n     */\n    function putHash() public returns (bool) {\n        uint lastb = hashLast;\n        if(lastb == 0 || block.number <= lastb + 10) {\n            return(false);\n        }\n        uint blockn256;\n        if(block.number<256) { // useless test for testnet :-(\n            blockn256 = 0;\n        }\n        else{\n            blockn256 = block.number - 256;\n        }\n        if(lastb < blockn256) {\n            uint num = blockn256;\n            num += num % 10;\n            lastb = num;\n        }\n        uint delta = (lastb - hashFirst) / 10;\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\n        hashLast = lastb + 10;\n        return(true);\n    }\n\n    /**\n     * @dev Fill hash data many times\n     * @param _num Number of iterations\n     */\n    function putHashes(uint _num) external {\n        uint n=0;\n        for(;n<_num;n++){\n            if(!putHash()){\n                return;\n            }\n        }\n    }\n\n}\n",
    "vulnerable_function": "betOf",
    "vulnerable_lines": [
      523
    ],
    "vulnerability_type": "weak_randomness",
    "original_category": "bad_randomness",
    "severity": "medium",
    "difficulty_tier": 4,
    "description": "Weak randomness - predictable random number generation at line(s) 523",
    "fix_description": "Use Chainlink VRF or commit-reveal scheme for randomness",
    "is_vulnerable": true,
    "context_level": "single_file",
    "original_source_path": "dataset/bad_randomness/smart_billions.sol",
    "pragma": "0.4.13",
    "source_url": "https://etherscan.io/address/0x5ace17f87c7391e5792a7683069a8025b83bbd85#code"
  }
]