[
  {
    "id": "sample_2_0000",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// 0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code\n\n*/\n\n\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n*/\n\n\n*/\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n*/\n\n\n*/\n\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks > now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days > now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n*/\n\n\n*/\n\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0\n            || _debatingPeriod < minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}\n",
    "pragma": "unknown",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0001",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// https://etherscan.io/address/0xf91546835f756da0c10cfa0cda95b15577b84aa7#code\n\npragma solidity ^0.4.23;\n// produced by the Solididy File Flattener (c) David Appleton 2018\n// contact : dave@akomba.com\n// released under Apache 2.0 licence\ncontract Token {\n    */\n    /// total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) public constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) public returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) public returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\nlibrary ECTools {\n\n    // @dev Recovers the address which has signed a message\n    // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n    function recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\n        require(_hashedMsg != 0x00);\n\n        // need this for test RPC\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\n\n        if (bytes(_sig).length != 132) {\n            return 0x0;\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27) {\n            v += 27;\n        }\n        if (v < 27 || v > 28) {\n            return 0x0;\n        }\n        return ecrecover(prefixedHash, v, r, s);\n    }\n\n    // @dev Verifies if the message is signed by an address\n    function isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\n        require(_addr != 0x0);\n\n        return _addr == recoverSigner(_hashedMsg, _sig);\n    }\n\n    // @dev Converts an hexstring to bytes\n    function hexstrToBytes(string _hexstr) public pure returns (bytes) {\n        uint len = bytes(_hexstr).length;\n        require(len % 2 == 0);\n\n        bytes memory bstr = bytes(new string(len / 2));\n        uint k = 0;\n        string memory s;\n        string memory r;\n        for (uint i = 0; i < len; i += 2) {\n            s = substring(_hexstr, i, i + 1);\n            r = substring(_hexstr, i + 1, i + 2);\n            uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n            bstr[k++] = uintToBytes32(p)[31];\n        }\n        return bstr;\n    }\n\n    // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n    function parseInt16Char(string _char) public pure returns (uint) {\n        bytes memory bresult = bytes(_char);\n        // bool decimals = false;\n        if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\n            return uint(bresult[0]) - 48;\n        } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n            return uint(bresult[0]) - 55;\n        } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n            return uint(bresult[0]) - 87;\n        } else {\n            revert();\n        }\n    }\n\n    // @dev Converts a uint to a bytes32\n    // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n    function uintToBytes32(uint _uint) public pure returns (bytes b) {\n        b = new bytes(32);\n        assembly {mstore(add(b, 32), _uint)}\n    }\n\n    // @dev Hashes the signed message\n    // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n    function toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\n        uint len = bytes(_msg).length;\n        require(len > 0);\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n        return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n    }\n\n    // @dev Converts a uint in a string\n    function uintToString(uint _uint) public pure returns (string str) {\n        uint len = 0;\n        uint m = _uint + 0;\n        while (m != 0) {\n            len++;\n            m /= 10;\n        }\n        bytes memory b = new bytes(len);\n        uint i = len - 1;\n        while (_uint != 0) {\n            uint remainder = _uint % 10;\n            _uint = _uint / 10;\n            b[i--] = byte(48 + remainder);\n        }\n        str = string(b);\n    }\n\n\n    // @dev extract a substring\n    // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n    function substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\n        bytes memory strBytes = bytes(_str);\n        require(_startIndex <= _endIndex);\n        require(_startIndex >= 0);\n        require(_endIndex <= strBytes.length);\n\n        bytes memory result = new bytes(_endIndex - _startIndex);\n        for (uint i = _startIndex; i < _endIndex; i++) {\n            result[i - _startIndex] = strBytes[i];\n        }\n        return string(result);\n    }\n}\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n    /* Public variables of the token */\n\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n    string public symbol;                 //An identifier: eg SBX\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n    constructor(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol\n        ) public {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    /* Approves and then calls the receiving contract */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n        return true;\n    }\n}\n\ncontract LedgerChannel {\n\n    string public constant NAME = \"Ledger Channel\";\n    string public constant VERSION = \"0.0.1\";\n\n    uint256 public numChannels = 0;\n\n    event DidLCOpen (\n        bytes32 indexed channelId,\n        address indexed partyA,\n        address indexed partyI,\n        uint256 ethBalanceA,\n        address token,\n        uint256 tokenBalanceA,\n        uint256 LCopenTimeout\n    );\n\n    event DidLCJoin (\n        bytes32 indexed channelId,\n        uint256 ethBalanceI,\n        uint256 tokenBalanceI\n    );\n\n    event DidLCDeposit (\n        bytes32 indexed channelId,\n        address indexed recipient,\n        uint256 deposit,\n        bool isToken\n    );\n\n    event DidLCUpdateState (\n        bytes32 indexed channelId, \n        uint256 sequence, \n        uint256 numOpenVc, \n        uint256 ethBalanceA,\n        uint256 tokenBalanceA,\n        uint256 ethBalanceI,\n        uint256 tokenBalanceI,\n        bytes32 vcRoot,\n        uint256 updateLCtimeout\n    );\n\n    event DidLCClose (\n        bytes32 indexed channelId,\n        uint256 sequence,\n        uint256 ethBalanceA,\n        uint256 tokenBalanceA,\n        uint256 ethBalanceI,\n        uint256 tokenBalanceI\n    );\n\n    event DidVCInit (\n        bytes32 indexed lcId, \n        bytes32 indexed vcId, \n        bytes proof, \n        uint256 sequence, \n        address partyA, \n        address partyB, \n        uint256 balanceA, \n        uint256 balanceB \n    );\n\n    event DidVCSettle (\n        bytes32 indexed lcId, \n        bytes32 indexed vcId,\n        uint256 updateSeq, \n        uint256 updateBalA, \n        uint256 updateBalB,\n        address challenger,\n        uint256 updateVCtimeout\n    );\n\n    event DidVCClose(\n        bytes32 indexed lcId, \n        bytes32 indexed vcId, \n        uint256 balanceA, \n        uint256 balanceB\n    );\n\n    struct Channel {\n        //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n        address[2] partyAddresses; // 0: partyA 1: partyI\n        uint256[4] ethBalances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n        uint256[4] erc20Balances; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n        uint256[2] initialDeposit; // 0: eth 1: tokens\n        uint256 sequence;\n        uint256 confirmTime;\n        bytes32 VCrootHash;\n        uint256 LCopenTimeout;\n        uint256 updateLCtimeout; // when update LC times out\n        bool isOpen; // true when both parties have joined\n        bool isUpdateLCSettling;\n        uint256 numOpenVC;\n        HumanStandardToken token;\n    }\n\n    // virtual-channel state\n    struct VirtualChannel {\n        bool isClose;\n        bool isInSettlementState;\n        uint256 sequence;\n        address challenger; // Initiator of challenge\n        uint256 updateVCtimeout; // when update VC times out\n        // channel state\n        address partyA; // VC participant A\n        address partyB; // VC participant B\n        address partyI; // LC hub\n        uint256[2] ethBalances;\n        uint256[2] erc20Balances;\n        uint256[2] bond;\n        HumanStandardToken token;\n    }\n\n    mapping(bytes32 => VirtualChannel) public virtualChannels;\n    mapping(bytes32 => Channel) public Channels;\n\n    function createChannel(\n        bytes32 _lcID,\n        address _partyI,\n        uint256 _confirmTime,\n        address _token,\n        uint256[2] _balances // [eth, token]\n    ) \n        public\n        payable \n    {\n        require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\n        require(_partyI != 0x0, \"No partyI address provided to LC creation\");\n        require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\n        // Set initial ledger channel state\n        // Alice must execute this and we assume the initial state \n        // to be signed from this requirement\n        // Alternative is to check a sig as in joinChannel\n        Channels[_lcID].partyAddresses[0] = msg.sender;\n        Channels[_lcID].partyAddresses[1] = _partyI;\n\n        if(_balances[0] != 0) {\n            require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n            Channels[_lcID].ethBalances[0] = msg.value;\n        } \n        if(_balances[1] != 0) {\n            Channels[_lcID].token = HumanStandardToken(_token);\n            require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n            Channels[_lcID].erc20Balances[0] = _balances[1];\n        }\n\n        Channels[_lcID].sequence = 0;\n        Channels[_lcID].confirmTime = _confirmTime;\n        // is close flag, lc state sequence, number open vc, vc root hash, partyA... \n        //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n        Channels[_lcID].LCopenTimeout = now + _confirmTime;\n        Channels[_lcID].initialDeposit = _balances;\n\n        emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n    }\n\n    function LCOpenTimeout(bytes32 _lcID) public {\n        require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\n        require(now > Channels[_lcID].LCopenTimeout);\n\n        if(Channels[_lcID].initialDeposit[0] != 0) {\n            Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n        } \n        if(Channels[_lcID].initialDeposit[1] != 0) {\n            require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n        }\n\n        emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\n\n        // only safe to delete since no action was taken on this channel\n        delete Channels[_lcID];\n    }\n\n    function joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {\n        // require the channel is not open yet\n        require(Channels[_lcID].isOpen == false);\n        require(msg.sender == Channels[_lcID].partyAddresses[1]);\n\n        if(_balances[0] != 0) {\n            require(msg.value == _balances[0], \"state balance does not match sent value\");\n            Channels[_lcID].ethBalances[1] = msg.value;\n        } \n        if(_balances[1] != 0) {\n            require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n            Channels[_lcID].erc20Balances[1] = _balances[1];          \n        }\n\n        Channels[_lcID].initialDeposit[0]+=_balances[0];\n        Channels[_lcID].initialDeposit[1]+=_balances[1];\n        // no longer allow joining functions to be called\n        Channels[_lcID].isOpen = true;\n        numChannels++;\n\n        emit DidLCJoin(_lcID, _balances[0], _balances[1]);\n    }\n\n\n    // additive updates of monetary state\n    function deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {\n        require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\n        require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\n\n        //if(Channels[_lcID].token)\n\n        if (Channels[_lcID].partyAddresses[0] == recipient) {\n            if(isToken) {\n                require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                Channels[_lcID].erc20Balances[2] += _balance;\n            } else {\n                require(msg.value == _balance, \"state balance does not match sent value\");\n                Channels[_lcID].ethBalances[2] += msg.value;\n            }\n        }\n\n        if (Channels[_lcID].partyAddresses[1] == recipient) {\n            if(isToken) {\n                require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                Channels[_lcID].erc20Balances[3] += _balance;\n            } else {\n                require(msg.value == _balance, \"state balance does not match sent value\");\n                Channels[_lcID].ethBalances[3] += msg.value; \n            }\n        }\n        \n        emit DidLCDeposit(_lcID, recipient, _balance, isToken);\n    }\n\n    // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n    function consensusCloseChannel(\n        bytes32 _lcID, \n        uint256 _sequence, \n        uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n        string _sigA, \n        string _sigI\n    ) \n        public \n    {\n        // assume num open vc is 0 and root hash is 0x0\n        //require(Channels[_lcID].sequence < _sequence);\n        require(Channels[_lcID].isOpen == true);\n        uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\n        uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\n        require(totalEthDeposit == _balances[0] + _balances[1]);\n        require(totalTokenDeposit == _balances[2] + _balances[3]);\n\n        bytes32 _state = keccak256(\n            abi.encodePacked(\n                _lcID,\n                true,\n                _sequence,\n                uint256(0),\n                bytes32(0x0),\n                Channels[_lcID].partyAddresses[0], \n                Channels[_lcID].partyAddresses[1], \n                _balances[0], \n                _balances[1],\n                _balances[2],\n                _balances[3]\n            )\n        );\n\n        require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n        require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n        Channels[_lcID].isOpen = false;\n\n        if(_balances[0] != 0 || _balances[1] != 0) {\n            Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n            Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n        }\n\n        if(_balances[2] != 0 || _balances[3] != 0) {\n            require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n            require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");          \n        }\n\n        numChannels--;\n\n        emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n    }\n\n    // Byzantine functions\n\n    function updateLCstate(\n        bytes32 _lcID, \n        uint256[6] updateParams, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n        bytes32 _VCroot, \n        string _sigA, \n        string _sigI\n    ) \n        public \n    {\n        Channel storage channel = Channels[_lcID];\n        require(channel.isOpen);\n        require(channel.sequence < updateParams[0]); // do same as vc sequence check\n        require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\n        require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\n\n        if(channel.isUpdateLCSettling == true) { \n            require(channel.updateLCtimeout > now);\n        }\n      \n        bytes32 _state = keccak256(\n            abi.encodePacked(\n                _lcID,\n                false, \n                updateParams[0], \n                updateParams[1], \n                _VCroot, \n                channel.partyAddresses[0], \n                channel.partyAddresses[1], \n                updateParams[2], \n                updateParams[3],\n                updateParams[4], \n                updateParams[5]\n            )\n        );\n\n        require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n        require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n        // update LC state\n        channel.sequence = updateParams[0];\n        channel.numOpenVC = updateParams[1];\n        channel.ethBalances[0] = updateParams[2];\n        channel.ethBalances[1] = updateParams[3];\n        channel.erc20Balances[0] = updateParams[4];\n        channel.erc20Balances[1] = updateParams[5];\n        channel.VCrootHash = _VCroot;\n        channel.isUpdateLCSettling = true;\n        channel.updateLCtimeout = now + channel.confirmTime;\n\n        // make settlement flag\n\n        emit DidLCUpdateState (\n            _lcID, \n            updateParams[0], \n            updateParams[1], \n            updateParams[2], \n            updateParams[3],\n            updateParams[4],\n            updateParams[5], \n            _VCroot,\n            channel.updateLCtimeout\n        );\n    }\n\n    // supply initial state of VC to \"prime\" the force push game  \n    function initVCstate(\n        bytes32 _lcID, \n        bytes32 _vcID, \n        bytes _proof, \n        address _partyA, \n        address _partyB, \n        uint256[2] _bond,\n        uint256[4] _balances, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n        string sigA\n    ) \n        public \n    {\n        require(Channels[_lcID].isOpen, \"LC is closed.\");\n        // sub-channel must be open\n        require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n        require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\n        // prevent rentry of initializing vc state\n        require(virtualChannels[_vcID].updateVCtimeout == 0);\n        // partyB is now Ingrid\n        bytes32 _initState = keccak256(\n            abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n        );\n\n        // Make sure Alice has signed initial vc state (A/B in oldState)\n        require(_partyA == ECTools.recoverSigner(_initState, sigA));\n\n        // Check the oldState is in the root hash\n        require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\n\n        virtualChannels[_vcID].partyA = _partyA; // VC participant A\n        virtualChannels[_vcID].partyB = _partyB; // VC participant B\n        virtualChannels[_vcID].sequence = uint256(0);\n        virtualChannels[_vcID].ethBalances[0] = _balances[0];\n        virtualChannels[_vcID].ethBalances[1] = _balances[1];\n        virtualChannels[_vcID].erc20Balances[0] = _balances[2];\n        virtualChannels[_vcID].erc20Balances[1] = _balances[3];\n        virtualChannels[_vcID].bond = _bond;\n        virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n        virtualChannels[_vcID].isInSettlementState = true;\n\n        emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n    }\n\n    //TODO: verify state transition since the hub did not agree to this state\n    // make sure the A/B balances are not beyond ingrids bonds  \n    // Params: vc init state, vc final balance, vcID\n    function settleVC(\n        bytes32 _lcID, \n        bytes32 _vcID, \n        uint256 updateSeq, \n        address _partyA, \n        address _partyB,\n        uint256[4] updateBal, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n        string sigA\n    ) \n        public \n    {\n        require(Channels[_lcID].isOpen, \"LC is closed.\");\n        // sub-channel must be open\n        require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n        require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\n        require(\n            virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n            \"State updates may only increase recipient balance.\"\n        );\n        require(\n            virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n            virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3], \n            \"Incorrect balances for bonded amount\");\n        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n        // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n        // fail if initVC() isn't called first\n        // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n        require(Channels[_lcID].updateLCtimeout < now); // for testing!\n\n        bytes32 _updateState = keccak256(\n            abi.encodePacked(\n                _vcID, \n                updateSeq, \n                _partyA, \n                _partyB, \n                virtualChannels[_vcID].bond[0], \n                virtualChannels[_vcID].bond[1], \n                updateBal[0], \n                updateBal[1], \n                updateBal[2], \n                updateBal[3]\n            )\n        );\n\n        // Make sure Alice has signed a higher sequence new state\n        require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\n\n        // store VC data\n        // we may want to record who is initiating on-chain settles\n        virtualChannels[_vcID].challenger = msg.sender;\n        virtualChannels[_vcID].sequence = updateSeq;\n\n        // channel state\n        virtualChannels[_vcID].ethBalances[0] = updateBal[0];\n        virtualChannels[_vcID].ethBalances[1] = updateBal[1];\n        virtualChannels[_vcID].erc20Balances[0] = updateBal[2];\n        virtualChannels[_vcID].erc20Balances[1] = updateBal[3];\n\n        virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n\n        emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n    }\n\n    function closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {\n        // require(updateLCtimeout > now)\n        require(Channels[_lcID].isOpen, \"LC is closed.\");\n        require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\n        require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\n        require(!virtualChannels[_vcID].isClose, \"VC is already closed\");\n        // reduce the number of open virtual channels stored on LC\n        Channels[_lcID].numOpenVC--;\n        // close vc flags\n        virtualChannels[_vcID].isClose = true;\n        // re-introduce the balances back into the LC state from the settled VC\n        // decide if this lc is alice or bob in the vc\n        if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\n            Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n            Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n\n            Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n            Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n        } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n            Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n            Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n            Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n            Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n        }\n\n        emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n    }\n\n\n    // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n    function byzantineCloseChannel(bytes32 _lcID) public {\n        Channel storage channel = Channels[_lcID];\n\n        // check settlement flag\n        require(channel.isOpen, \"Channel is not open\");\n        require(channel.isUpdateLCSettling == true);\n        require(channel.numOpenVC == 0);\n        require(channel.updateLCtimeout < now, \"LC timeout over.\");\n\n        // if off chain state update didnt reblance deposits, just return to deposit owner\n        uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\n        uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\n\n        uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1]; \n        uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\n\n        if(possibleTotalEthBeforeDeposit < totalEthDeposit) {\n            channel.ethBalances[0]+=channel.ethBalances[2];\n            channel.ethBalances[1]+=channel.ethBalances[3];\n        } else {\n            require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n        }\n\n        if(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\n            channel.erc20Balances[0]+=channel.erc20Balances[2];\n            channel.erc20Balances[1]+=channel.erc20Balances[3];\n        } else {\n            require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n        }\n\n        // reentrancy\n        uint256 ethbalanceA = channel.ethBalances[0];\n        uint256 ethbalanceI = channel.ethBalances[1];\n        uint256 tokenbalanceA = channel.erc20Balances[0];\n        uint256 tokenbalanceI = channel.erc20Balances[1];\n\n        channel.ethBalances[0] = 0;\n        channel.ethBalances[1] = 0;\n        channel.erc20Balances[0] = 0;\n        channel.erc20Balances[1] = 0;\n\n        if(ethbalanceA != 0 || ethbalanceI != 0) {\n            channel.partyAddresses[0].transfer(ethbalanceA);\n            channel.partyAddresses[1].transfer(ethbalanceI);\n        }\n\n        if(tokenbalanceA != 0 || tokenbalanceI != 0) {\n            require(\n                channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n            require(\n                channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                \"byzantineCloseChannel: token transfer failure\"\n            );          \n        }\n\n        channel.isOpen = false;\n        numChannels--;\n\n        emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n    }\n\n    function _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\n        bytes32 cursor = _hash;\n        bytes32 proofElem;\n\n        for (uint256 i = 64; i <= _proof.length; i += 32) {\n            assembly { proofElem := mload(add(_proof, i)) }\n\n            if (cursor < proofElem) {\n                cursor = keccak256(abi.encodePacked(cursor, proofElem));\n            } else {\n                cursor = keccak256(abi.encodePacked(proofElem, cursor));\n            }\n        }\n\n        return cursor == _root;\n    }\n\n    //Struct Getters\n    function getChannel(bytes32 id) public view returns (\n        address[2],\n        uint256[4],\n        uint256[4],\n        uint256[2],\n        uint256,\n        uint256,\n        bytes32,\n        uint256,\n        uint256,\n        bool,\n        bool,\n        uint256\n    ) {\n        Channel memory channel = Channels[id];\n        return (\n            channel.partyAddresses,\n            channel.ethBalances,\n            channel.erc20Balances,\n            channel.initialDeposit,\n            channel.sequence,\n            channel.confirmTime,\n            channel.VCrootHash,\n            channel.LCopenTimeout,\n            channel.updateLCtimeout,\n            channel.isOpen,\n            channel.isUpdateLCSettling,\n            channel.numOpenVC\n        );\n    }\n\n    function getVirtualChannel(bytes32 id) public view returns(\n        bool,\n        bool,\n        uint256,\n        address,\n        uint256,\n        address,\n        address,\n        address,\n        uint256[2],\n        uint256[2],\n        uint256[2]\n    ) {\n        VirtualChannel memory virtualChannel = virtualChannels[id];\n        return(\n            virtualChannel.isClose,\n            virtualChannel.isInSettlementState,\n            virtualChannel.sequence,\n            virtualChannel.challenger,\n            virtualChannel.updateVCtimeout,\n            virtualChannel.partyA,\n            virtualChannel.partyB,\n            virtualChannel.partyI,\n            virtualChannel.ethBalances,\n            virtualChannel.erc20Balances,\n            virtualChannel.bond\n        );\n    }\n}\n",
    "pragma": "^0.4.23",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0002",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// https://etherscan.io/address/0x42d6622dece394b54999fbd73d108123806f6a18#code\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity 0.4.15;\n\ncontract Token {\n    */\n    /// total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n\n.*/\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n}\n\n.*/\ncontract HumanStandardToken is StandardToken {\n\n    /* Public variables of the token */\n\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n    string public symbol;                 //An identifier: eg SBX\n    string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n    function HumanStandardToken(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol\n        ) {\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    /* Approves and then calls the receiving contract */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n        return true;\n    }\n}\n",
    "pragma": "0.4.15",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0003",
    "language": "solidity",
    "chain": "evm",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    // The name of the constructor should be Missing\n    // Anyone can call the IamMissing once the contract is deployed\n    function IamMissing()\n        public \n    {\n        owner = msg.sender;\n    }\n\n    function withdraw() \n        public \n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n}\n",
    "pragma": "^0.4.15",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0004",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\npragma solidity ^0.4.15;\n\ncontract Rubixi {\n\n        //Declare variables for storage critical to contract\n        uint private balance = 0;\n        uint private collectedFees = 0;\n        uint private feePercent = 10;\n        uint private pyramidMultiplier = 300;\n        uint private payoutOrder = 0;\n\n        address private creator;\n\n        //Sets creator\n        function DynamicPyramid() {\n                creator = msg.sender;\n        }\n\n        modifier onlyowner {\n                if (msg.sender == creator) _;\n        }\n\n        struct Participant {\n                address etherAddress;\n                uint payout;\n        }\n\n        Participant[] private participants;\n\n        //Fallback function\n        function() {\n                init();\n        }\n\n        //init function run on fallback\n        function init() private {\n                //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                if (msg.value < 1 ether) {\n                        collectedFees += msg.value;\n                        return;\n                }\n\n                uint _fee = feePercent;\n                //50% fee rebate on any ether value of 50 or greater\n                if (msg.value >= 50 ether) _fee /= 2;\n\n                addPayout(_fee);\n        }\n\n        //Function called for valid tx to the contract\n        function addPayout(uint _fee) private {\n                //Adds new address to participant array\n                participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                if (participants.length == 10) pyramidMultiplier = 200;\n                else if (participants.length == 25) pyramidMultiplier = 150;\n\n                // collect fees and update contract balance\n                balance += (msg.value * (100 - _fee)) / 100;\n                collectedFees += (msg.value * _fee) / 100;\n\n                //Pays earlier participiants if balance sufficient\n                while (balance > participants[payoutOrder].payout) {\n                        uint payoutToSend = participants[payoutOrder].payout;\n                        participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                        balance -= participants[payoutOrder].payout;\n                        payoutOrder += 1;\n                }\n        }\n\n        //Fee functions for creator\n        function collectAllFees() onlyowner {\n                if (collectedFees == 0) throw;\n\n                creator.send(collectedFees);\n                collectedFees = 0;\n        }\n\n        function collectFeesInEther(uint _amt) onlyowner {\n                _amt *= 1 ether;\n                if (_amt > collectedFees) collectAllFees();\n\n                if (collectedFees == 0) throw;\n\n                creator.send(_amt);\n                collectedFees -= _amt;\n        }\n\n        function collectPercentOfFees(uint _pcent) onlyowner {\n                if (collectedFees == 0 || _pcent > 100) throw;\n\n                uint feesToCollect = collectedFees / 100 * _pcent;\n                creator.send(feesToCollect);\n                collectedFees -= feesToCollect;\n        }\n\n        //Functions for changing variables related to the contract\n        function changeOwner(address _owner) onlyowner {\n                creator = _owner;\n        }\n\n        function changeMultiplier(uint _mult) onlyowner {\n                if (_mult > 300 || _mult < 120) throw;\n\n                pyramidMultiplier = _mult;\n        }\n\n        function changeFeePercentage(uint _fee) onlyowner {\n                if (_fee > 10) throw;\n\n                feePercent = _fee;\n        }\n\n        //Functions to provide information to end-user using JSON interface or other interfaces\n        function currentMultiplier() constant returns(uint multiplier, string info) {\n                multiplier = pyramidMultiplier;\n                info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n        }\n\n        function currentFeePercentage() constant returns(uint fee, string info) {\n                fee = feePercent;\n                info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n        }\n\n        function currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\n                pyramidBalance = balance / 1 ether;\n                info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n        }\n\n        function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\n                balancePayout = participants[payoutOrder].payout / 1 ether;\n        }\n\n        function feesSeperateFromBalanceApproximately() constant returns(uint fees) {\n                fees = collectedFees / 1 ether;\n        }\n\n        function totalParticipants() constant returns(uint count) {\n                count = participants.length;\n        }\n\n        function numberOfParticipantsWaitingForPayout() constant returns(uint count) {\n                count = participants.length - payoutOrder;\n        }\n\n        function participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\n                if (orderInPyramid <= participants.length) {\n                        Address = participants[orderInPyramid].etherAddress;\n                        Payout = participants[orderInPyramid].payout / 1 ether;\n                }\n        }\n}\n",
    "pragma": "^0.4.15",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0005",
    "language": "solidity",
    "chain": "evm",
    "file_content": "contract Suicidal {\n  address owner;\n  function suicide() public returns (address) {\n    require(owner == msg.sender);\n    selfdestruct(owner);\n  }\n}\ncontract C is Suicidal {\n  address owner;\n  function C() {\n    owner = msg.sender;\n  }\n}\n",
    "pragma": "unknown",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0006",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\npragma solidity ^0.4.19;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address etherAddress;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string name;\n        // How much did they pay to become monarch?\n        uint claimPrice;\n        // When did their rule start (based on block.timestamp)?\n        uint coronationTimestamp;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address wizardAddress;\n\n    // Used to ensure only the wizard can do some things.\n    modifier onlywizard { if (msg.sender == wizardAddress) _; }\n\n    // How much must the first monarch pay?\n    uint constant startingClaimPrice = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant claimPriceAdjustNum = 3;\n    uint constant claimPriceAdjustDen = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant wizardCommissionFractionNum = 1;\n    uint constant wizardCommissionFractionDen = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public currentClaimPrice;\n\n    // The King (or Queen) of the Ether.\n    Monarch public currentMonarch;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public pastMonarchs;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        wizardAddress = msg.sender;\n        currentClaimPrice = startingClaimPrice;\n        currentMonarch = Monarch(\n            wizardAddress,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint n) {\n        return pastMonarchs.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address usurperEtherAddress,\n        string usurperName,\n        uint newClaimPrice\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        claimThrone(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function claimThrone(string name) {\n\n        uint valuePaid = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (valuePaid < currentClaimPrice) {\n            msg.sender.send(valuePaid);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (valuePaid > currentClaimPrice) {\n            uint excessPaid = valuePaid - currentClaimPrice;\n            msg.sender.send(excessPaid);\n            valuePaid = valuePaid - excessPaid;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint wizardCommission = (valuePaid * wizardCommissionFractionNum) / wizardCommissionFractionDen;\n\n        uint compensation = valuePaid - wizardCommission;\n\n        if (currentMonarch.etherAddress != wizardAddress) {\n            currentMonarch.etherAddress.send(compensation);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        pastMonarchs.push(currentMonarch);\n        currentMonarch = Monarch(\n            msg.sender,\n            name,\n            valuePaid,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint rawNewClaimPrice = currentClaimPrice * claimPriceAdjustNum / claimPriceAdjustDen;\n        if (rawNewClaimPrice < 10 finney) {\n            currentClaimPrice = rawNewClaimPrice;\n        } else if (rawNewClaimPrice < 100 finney) {\n            currentClaimPrice = 100 szabo * (rawNewClaimPrice / 100 szabo);\n        } else if (rawNewClaimPrice < 1 ether) {\n            currentClaimPrice = 1 finney * (rawNewClaimPrice / 1 finney);\n        } else if (rawNewClaimPrice < 10 ether) {\n            currentClaimPrice = 10 finney * (rawNewClaimPrice / 10 finney);\n        } else if (rawNewClaimPrice < 100 ether) {\n            currentClaimPrice = 100 finney * (rawNewClaimPrice / 100 finney);\n        } else if (rawNewClaimPrice < 1000 ether) {\n            currentClaimPrice = 1 ether * (rawNewClaimPrice / 1 ether);\n        } else if (rawNewClaimPrice < 10000 ether) {\n            currentClaimPrice = 10 ether * (rawNewClaimPrice / 10 ether);\n        } else {\n            currentClaimPrice = rawNewClaimPrice;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(currentMonarch.etherAddress, currentMonarch.name, currentClaimPrice);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function sweepCommission(uint amount) onlywizard {\n        wizardAddress.send(amount);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function transferOwnership(address newOwner) onlywizard {\n        wizardAddress = newOwner;\n    }\n\n}\n",
    "pragma": "^0.4.19",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0007",
    "language": "solidity",
    "chain": "evm",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract CrowdFundBad {\n  address[] private refundAddresses;\n  mapping(address => uint) public refundAmount;\n\n  function refundDos() public {\n    for(uint i; i < refundAddresses.length; i++) {\n      require(refundAddresses[i].transfer(refundAmount[refundAddresses[i]]));\n    }\n  }\n}\n\ncontract CrowdFundPull {\n  address[] private refundAddresses;\n  mapping(address => uint) public refundAmount;\n\n  function withdraw() external {\n    uint refund = refundAmount[msg.sender];\n    refundAmount[msg.sender] = 0;\n    msg.sender.transfer(refund);\n  }\n}\n\n\n//This is safe against the list length causing out of gas issues\n//but is not safe against the payee causing the execution to revert\ncontract CrowdFundSafe {\n  address[] private refundAddresses;\n  mapping(address => uint) public refundAmount;\n  uint256 nextIdx;\n  \n  function refundSafe() public {\n    uint256 i = nextIdx;\n    while(i < refundAddresses.length && msg.gas > 200000) {\n      refundAddresses[i].transfer(refundAmount[i]);\n      i++;\n    }\n    nextIdx = i;\n  }\n}\n",
    "pragma": "^0.4.15",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0008",
    "language": "solidity",
    "chain": "evm",
    "file_content": "pragma solidity ^0.4.15;\n\ncontract DosAuction {\n  address currentFrontrunner;\n  uint currentBid;\n\n  //Takes in bid, refunding the frontrunner if they are outbid\n  function bid() payable {\n    require(msg.value > currentBid);\n\n    //If the refund fails, the entire transaction reverts.\n    //Therefore a frontrunner who always fails will win\n    if (currentFrontrunner != 0) {\n      //E.g. if recipients fallback function is just revert()\n      require(currentFrontrunner.send(currentBid));\n    }\n\n    currentFrontrunner = msg.sender;\n    currentBid         = msg.value;\n  }\n}\n\n\n//Secure auction that cannot be DoS'd\ncontract SecureAuction {\n  address currentFrontrunner;\n  uint    currentBid;\n  //Store refunds in mapping to avoid DoS\n  mapping(address => uint) refunds;\n\n  //Avoids \"pushing\" balance to users favoring \"pull\" architecture\n  function bid() payable external {\n    require(msg.value > currentBid);\n\n    if (currentFrontrunner != 0) {\n      refunds[currentFrontrunner] += currentBid;\n    }\n\n    currentFrontrunner = msg.sender;\n    currentBid         = msg.value;\n  }\n\n  //Allows users to get their refund from auction\n  function withdraw() external {\n    //Do all state manipulation before external call to\n    uint refund = refunds[msg.sender];\n    refunds[msg.sender] = 0;\n\n    msg.sender.send(refund);\n  }\n}\n",
    "pragma": "^0.4.15",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0009",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// 0xa657491c1e7f16adb39b9b60e87bbb8d93988bc3#code\n//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address owner, bytes32 operation);\n  event Revoke(address owner, bytes32 operation);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address oldOwner, address newOwner);\n  event OwnerAdded(address newOwner);\n  event OwnerRemoved(address oldOwner);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint newRequirement);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _from, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address owner, uint value, address to, bytes data, address created);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function revoke(bytes32 _operation) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function changeOwner(address _from, address _to) external;\n\n  function addOwner(address _owner) external;\n\n  function removeOwner(address _owner) external;\n\n  function changeRequirement(uint _newRequired) external;\n\n  function isOwner(address _addr) constant returns (bool);\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function setDailyLimit(uint _newLimit) external;\n\n  function execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\n  function confirm(bytes32 _h) returns (bool o_success);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint yetNeeded;\n    uint ownersDone;\n    uint index;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address to;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier onlyowner {\n    if (isOwner(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier onlymanyowners(bytes32 _operation) {\n    if (confirmAndCheck(_operation))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function initMultiowned(address[] _owners, uint _required) {\n    m_numOwners = _owners.length + 1;\n    m_owners[1] = uint(msg.sender);\n    m_ownerIndex[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _owners.length; ++i)\n    {\n      m_owners[2 + i] = uint(_owners[i]);\n      m_ownerIndex[uint(_owners[i])] = 2 + i;\n    }\n    m_required = _required;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function revoke(bytes32 _operation) external {\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n    // make sure they're an owner\n    if (ownerIndex == 0) return;\n    uint ownerIndexBit = 2**ownerIndex;\n    var pending = m_pending[_operation];\n    if (pending.ownersDone & ownerIndexBit > 0) {\n      pending.yetNeeded++;\n      pending.ownersDone -= ownerIndexBit;\n      Revoke(msg.sender, _operation);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_to)) return;\n    uint ownerIndex = m_ownerIndex[uint(_from)];\n    if (ownerIndex == 0) return;\n\n    clearPending();\n    m_owners[ownerIndex] = uint(_to);\n    m_ownerIndex[uint(_from)] = 0;\n    m_ownerIndex[uint(_to)] = ownerIndex;\n    OwnerChanged(_from, _to);\n  }\n\n  function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_owner)) return;\n\n    clearPending();\n    if (m_numOwners >= c_maxOwners)\n      reorganizeOwners();\n    if (m_numOwners >= c_maxOwners)\n      return;\n    m_numOwners++;\n    m_owners[m_numOwners] = uint(_owner);\n    m_ownerIndex[uint(_owner)] = m_numOwners;\n    OwnerAdded(_owner);\n  }\n\n  function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n    if (ownerIndex == 0) return;\n    if (m_required > m_numOwners - 1) return;\n\n    m_owners[ownerIndex] = 0;\n    m_ownerIndex[uint(_owner)] = 0;\n    clearPending();\n    reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_owner);\n  }\n\n  function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\n    if (_newRequired > m_numOwners) return;\n    m_required = _newRequired;\n    clearPending();\n    RequirementChanged(_newRequired);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function getOwner(uint ownerIndex) external constant returns (address) {\n    return address(m_owners[ownerIndex + 1]);\n  }\n\n  function isOwner(address _addr) constant returns (bool) {\n    return m_ownerIndex[uint(_addr)] > 0;\n  }\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n    var pending = m_pending[_operation];\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n    // make sure they're an owner\n    if (ownerIndex == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint ownerIndexBit = 2**ownerIndex;\n    return !(pending.ownersDone & ownerIndexBit == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function initDaylimit(uint _limit) {\n    m_dailyLimit = _limit;\n    m_lastDay = today();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\n    m_dailyLimit = _newLimit;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\n    m_spentToday = 0;\n  }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function initWallet(address[] _owners, uint _required, uint _daylimit) {\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n    suicide(_to);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_data.length == 0 && underLimit(_value)) || m_required == 1) {\n      // yes - just execute the call.\n      address created;\n      if (_to == 0) {\n        created = create(_value, _data);\n      } else {\n        if (!_to.call.value(_value)(_data))\n          throw;\n      }\n      SingleTransact(msg.sender, _value, _to, _data, created);\n    } else {\n      // determine our operation hash.\n      o_hash = sha3(msg.data, block.number);\n      // store if it's new\n      if (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {\n        m_txs[o_hash].to = _to;\n        m_txs[o_hash].value = _value;\n        m_txs[o_hash].data = _data;\n      }\n      if (!confirm(o_hash)) {\n        ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n      }\n    }\n  }\n\n  function create(uint _value, bytes _code) internal returns (address o_addr) {\n    assembly {\n      o_addr := create(_value, add(_code, 0x20), mload(_code))\n      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))\n    }\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\n    if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\n      address created;\n      if (m_txs[_h].to == 0) {\n        created = create(m_txs[_h].value, m_txs[_h].data);\n      } else {\n        if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\n      delete m_txs[_h];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n    // determine what index the present sender is:\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n    // make sure they're an owner\n    if (ownerIndex == 0) return;\n\n    var pending = m_pending[_operation];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (pending.yetNeeded == 0) {\n      // reset count of confirmations needed.\n      pending.yetNeeded = m_required;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      pending.ownersDone = 0;\n      pending.index = m_pendingIndex.length++;\n      m_pendingIndex[pending.index] = _operation;\n    }\n    // determine the bit to set for this owner.\n    uint ownerIndexBit = 2**ownerIndex;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (pending.ownersDone & ownerIndexBit == 0) {\n      Confirmation(msg.sender, _operation);\n      // ok - check if count is enough to go ahead.\n      if (pending.yetNeeded <= 1) {\n        // enough confirmations: reset and run interior.\n        delete m_pendingIndex[m_pending[_operation].index];\n        delete m_pending[_operation];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        pending.yetNeeded--;\n        pending.ownersDone |= ownerIndexBit;\n      }\n    }\n  }\n\n  function reorganizeOwners() private {\n    uint free = 1;\n    while (free < m_numOwners)\n    {\n      while (free < m_numOwners && m_owners[free] != 0) free++;\n      while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n      if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n      {\n        m_owners[free] = m_owners[m_numOwners];\n        m_ownerIndex[m_owners[free]] = free;\n        m_owners[m_numOwners] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function underLimit(uint _value) internal onlyowner returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (today() > m_lastDay) {\n      m_spentToday = 0;\n      m_lastDay = today();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n    // overflow protection                    // dailyLimit check\n    if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n      m_spentToday += _value;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function today() private constant returns (uint) { return now / 1 days; }\n\n  function clearPending() internal {\n    uint length = m_pendingIndex.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete m_txs[m_pendingIndex[i]];\n\n      if (m_pendingIndex[i] != 0)\n        delete m_pending[m_pendingIndex[i]];\n    }\n\n    delete m_pendingIndex;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public m_required;\n  // pointer used to find a free slot in m_owners\n  uint public m_numOwners;\n\n  uint public m_dailyLimit;\n  uint public m_spentToday;\n  uint public m_lastDay;\n\n  // list of owners\n  uint[256] m_owners;\n\n  uint constant c_maxOwners = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) m_ownerIndex;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) m_pending;\n  bytes32[] m_pendingIndex;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) m_txs;\n}\n\ncontract Wallet is WalletEvents {\n\n  // WALLET CONSTRUCTOR\n  //   calls the `initWallet` method of the Library in this context\n  function Wallet(address[] _owners, uint _required, uint _daylimit) {\n    // Signature of the Wallet Library's init function\n    bytes4 sig = bytes4(sha3(\"initWallet(address[],uint256,uint256)\"));\n    address target = _walletLibrary;\n\n    // Compute the size of the call data : arrays has 2\n    // 32bytes for offset and length, plus 32bytes per element ;\n    // plus 2 32bytes for each uint\n    uint argarraysize = (2 + _owners.length);\n    uint argsize = (2 + argarraysize) * 32;\n\n    assembly {\n      // Add the signature first to memory\n      mstore(0x0, sig)\n      // Add the call data, which is at the end of the\n      // code\n      codecopy(0x4,  sub(codesize, argsize), argsize)\n      // Delegate call to the library\n      delegatecall(sub(gas, 10000), target, 0x0, add(argsize, 0x4), 0x0, 0x0)\n    }\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function getOwner(uint ownerIndex) constant returns (address) {\n    return address(m_owners[ownerIndex + 1]);\n  }\n\n  // As return statement unavailable in fallback, explicit the method here\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function isOwner(address _addr) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public m_required;\n  // pointer used to find a free slot in m_owners\n  uint public m_numOwners;\n\n  uint public m_dailyLimit;\n  uint public m_spentToday;\n  uint public m_lastDay;\n\n  // list of owners\n  uint[256] m_owners;\n}\n",
    "pragma": "^0.4.9",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0010",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// taken from https://www.ethereum.org/token#the-coin (4/9/2018)\n\npragma solidity ^0.4.16;\n\ncontract owned {\n    address public owner;\n\n    function owned() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public {\n        owner = newOwner;\n    }\n}\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public totalSupply;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n     */\n    function TokenERC20(\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. \n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n     */\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n     */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n     */\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n     */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n}\n\n/******************************************/\n/*       ADVANCED TOKEN STARTS HERE       */\n/******************************************/\n\ncontract MyAdvancedToken is owned, TokenERC20 {\n\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function MyAdvancedToken(\n        string tokenName,\n        string tokenSymbol\n    ) TokenERC20(tokenName, tokenSymbol) public {}\n\n    /* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address.\n        require (balanceOf[_from] >= _value);               // Check if the sender has enough\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n        require(!frozenAccount[_to]);                       // Check if recipient is frozen\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n        emit Transfer(_from, _to, _value);\n    }\n\n    /// @notice Buy tokens from contract by sending ether\n    function buy() payable public {\n        uint amount = msg.value;                          // calculates the amount\n\tbalanceOf[msg.sender] += amount;                  // updates the balance\n        totalSupply += amount;                            // updates the total supply\n        _transfer(address(0x0), msg.sender, amount);      // makes the transfer\n    }\n\n    /* Migration function */\n    function migrate_and_destroy() onlyOwner {\n\tassert(this.balance == totalSupply);                 // consistency check                                    \n\tsuicide(owner);                                      // transfer the ether to the owner and kill the contract\n    }\n}\n",
    "pragma": "^0.4.16",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0011",
    "language": "solidity",
    "chain": "evm",
    "file_content": "\npragma solidity ^0.4.15;\n\ncontract Alice { \n    function set(uint); \n    function set_fixed(int); \n}\n\ncontract Bob { \n    function set(Alice c){ \n        c.set(42); \n    }\n\n    function set_fixed(Alice c){ \n        c.set_fixed(42); \n    } \n}\n",
    "pragma": "^0.4.15",
    "difficulty_tier": 2,
    "context_level": "single_file"
  }
]