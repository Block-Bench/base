{
  "id": "gs_037",
  "original_id": "gs_quantstamp_startale_sta002",
  "source_dataset": "gold_standard",
  "vulnerability_type": "logic_error",
  "severity": "high",
  "difficulty_tier": 3,
  "context_level": "cross_contract",
  "is_vulnerable": true,
  "finding_title": "Missing Boost Rewards Settlement During Deposit",
  "finding_description": "The deposit() and depositWithPermit() functions in EarnVaultUpgradeable call _settleRewards() for USDSC rewards but fail to call _settleBoost() before increasing the user's principal. This allows users to double-dip on boost rewards by depositing a second time without settling accrued boost index, causing the subsequent distributions to apply stale index deltas to increased principal amounts.",
  "vulnerable_lines": [
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    62,
    63,
    64,
    65,
    66,
    67,
    68,
    69
  ],
  "vulnerable_functions": [
    "deposit",
    "depositWithPermit"
  ],
  "has_context": true,
  "attack_scenario": "1. User deposits 100k USDSC, receives 100k vault shares, userBoostIndex set to current globalBoostIndex (e.g., 1e18)\n2. Time passes, globalBoostIndex increases to 1.2e18 due to distributions\n3. User calls deposit(100k USDSC) again\n4. Vault calls _settleRewards() for USDSC yield (accrued correctly)\n5. Vault FAILS to call _settleBoost() - userBoostIndex still 1e18\n6. User's principal increased from 100k to 200k shares\n7. Next boost distribution: newYield = 200k * (1.2e18 - 1e18) / 1e18 = 200k * 0.2 = 40k boost tokens\n8. Should have been: settled 100k * 0.2 = 20k, then new principal has 0 accrual = 20k total\n9. User receives 40k instead of 20k, gaining 20k unearned boost rewards\n10. Repeated deposits compound the over-allocation until vault reserves are depleted",
  "fix_description": "Add _settleBoost() call before principal modification in both deposit functions. The correct pattern (shown in withdraw) is: (1) Call _settleRewards() for USDSC (2) Call _settleBoost() for external tokens (3) Then modify principal (4) Then emit events. Code fix: Add 'earnVault._settleBoost(msg.sender);' after line 36 in deposit() and line 64 in depositWithPermit() before principal is increased. This ensures boost index deltas are captured with old principal before new shares are minted.",
  "expert_notes": "Index-based reward systems (similar to Aave's index updates) must be settled before any operation that changes a user's balance. This is a subtle but critical invariant. The fact that withdraw() correctly calls _settleBoost() while deposit() doesn't suggests this was introduced during a code merge or refactoring. Good security practice would be to enforce this invariant with comments or asserts in critical functions.",
  "context_hint": "Index-based reward accounting requires settlement at all state-change points. The EarnVault correctly settles USDSC rewards but misses boost settlement. The withdraw() function shows the correct pattern - it calls both _settleRewards() and _settleBoost() before modifying principal. This is likely a refactoring oversight where boost reward support was added to an existing pattern without updating all deposit paths.",
  "call_flow": "User.deposit() \u2192 EarnVault.deposit() \u2192 _settleRewards() (\u2713) but NOT _settleBoost() (\u2717) \u2192 Principal increased \u2192 Next distribution \u2192 BoostRewardsLib.distributeBoostReward() \u2192 Over-allocation occurs"
}