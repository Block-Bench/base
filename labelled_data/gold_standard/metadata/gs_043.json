{
  "id": "gs_043",
  "original_id": "gs_cantina_kyber_002",
  "source_dataset": "gold_standard",
  "vulnerability_type": "frontrunning_nonce_invalidation",
  "severity": "medium",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "is_vulnerable": true,
  "finding_title": "Quotes Can Be Frontrun and Invalidated by MEV Bots Through Router-Level Nonce Consumption",
  "finding_description": "The Kyber hooks validate signatures by checking that the sender field matches the router contract address, restricting execution to the Kyber router but not to any specific user. This allows MEV bots to copy any signed swap calldata from the mempool, replay it through the public router before the original transaction, consume the nonce, and invalidate the original quote with a dust transaction.",
  "vulnerable_lines": [],
  "vulnerable_functions": [],
  "has_context": true,
  "fix_description": "Include the original caller in the signature by retrieving it via router.msgSender() as specified in Uniswap V4 hook guidelines.",
  "expert_notes": "This is a fundamental authorization scope error. The signed payload should commit to the original end-user (obtained via router.msgSender() per Uniswap V4 hook documentation), not the router contract itself. The current design exposes every quote to: (1) Dust swap frontrunning that invalidates legitimate orders, (2) MEV bot mempool sniping without providing protective guarantees to takers, (3) Denial of service where attackers force users to re-sign new nonces. While Kyber notes that taker protection occurs at the Aggregator contract level, this places critical routing security outside the hook scope. The fix requires including the original msg.sender in the signed digest.",
  "context_hint": "The vulnerability stems from router-level nonce validation instead of user-level validation. The signature commits to the router address (sender), not to the original caller (msg.sender within router). Since the Kyber router is a public contract accepting arbitrary callers, any mempool observer can re-execute the same swapData with the same signature before the original caller. This design treats the router as the single authorized party, exposing individual users to frontrunning and nonce consumption attacks.",
  "call_flow": [
    "1. Alice broadcasts signed swap: signature(router, PoolKey, swapParams, amount, nonce=42, expiry=T+1h)",
    "2. MEV bot detects transaction in mempool",
    "3. Bot extracts calldata and signature (sender field = router address)",
    "4. Bot calls router.swap() with identical calldata, including nonce=42",
    "5. Hook validates signature: sender matches router \u2713, signature valid \u2713",
    "6. Hook calls _useUnorderedNonce(42) - marks nonce 42 as consumed",
    "7. Bot's transaction succeeds, consuming minimal liquidity (dust swap)",
    "8. Alice's original transaction arrives at mempool",
    "9. Hook validates signature again: sender \u2713, signature \u2713",
    "10. Hook calls _useUnorderedNonce(42) - reverts with NonceAlreadyUsed(42)",
    "11. Alice's transaction reverts, quote invalidated"
  ]
}