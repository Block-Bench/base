{
  "timestamp": "2025-12-18T06:18:49.004044",
  "mode": "dispatcher",
  "source": "nocomments",
  "total_files": 252,
  "successful": 156,
  "failed": 96,
  "results": [
    {
      "original_id": "nc_ds_001",
      "transformed_id": "rs_mg_dis_nc_ds_001",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_002",
      "transformed_id": "rs_mg_dis_nc_ds_002",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_003",
      "transformed_id": "rs_mg_dis_nc_ds_003",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract VaultOperator {\n    bool public operationActive=false;\n    address public target_contract;\n    address public owner;\n\n    function VaultOperator() public{\n        owner = msg.sender;\n    }\n\n    function deposit(address _target_contract) public payable{\n        target_contract = _target_contract ;\n\n        require(target_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\"))));\n    }\n\n    function launch_handler() public{\n        operationActive = true;\n\n\n        require(target_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n    }\n\n    function () public payable{\n\n        if (operationActive){\n            operationActive = false;\n                require(target_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n        }\n    }\n\n    function get_money(){\n        suicide(owner);\n    }\n\n\n    // Unified dispatcher - merged from: VaultOperator, deposit, launch_handler\n    // Selectors: VaultOperator=0, deposit=1, launch_handler=2\n    function execute(uint8 _selector, address _target_contract) public payable {\n        // Original: VaultOperator()\n        if (_selector == 0) {\n            owner = msg.sender;\n        }\n        // Original: deposit()\n        else if (_selector == 1) {\n            target_contract = _target_contract ;\n            require(target_contract.call.value(msg.value)(bytes4(sha3(\"addToBalance()\"))));\n        }\n        // Original: launch_handler()\n        else if (_selector == 2) {\n            operationActive = true;\n            require(target_contract.call(bytes4(sha3(\"withdrawBalance()\"))));\n        }\n    }\n}",
      "merged_functions": [
        "VaultOperator",
        "deposit",
        "launch_handler"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: VaultOperator, deposit, launch_handler"
      ],
      "function_to_selector": {
        "VaultOperator": 0,
        "deposit": 1,
        "launch_handler": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_004",
      "transformed_id": "rs_mg_dis_nc_ds_004",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_005",
      "transformed_id": "rs_mg_dis_nc_ds_005",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract OpenAccess{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n    function OpenAccess()\n        public\n    {\n        owner = msg.sender;\n    }\n\n\n    function changeOwner(address _newOwner)\n        public\n    {\n       owner = _newOwner;\n    }\n\n    function changeOwnerV2(address _newOwner)\n        public\n        onlyowner\n    {\n       owner = _newOwner;\n    }\n\n    // Unified dispatcher - merged from: OpenAccess, changeOwner, changeOwnerV2\n    // Selectors: OpenAccess=0, changeOwner=1, changeOwnerV2=2\n    function execute(uint8 _selector, address _newOwner) public {\n        // Original: OpenAccess()\n        if (_selector == 0) {\n            owner = msg.sender;\n        }\n        // Original: changeOwner()\n        else if (_selector == 1) {\n            owner = _newOwner;\n        }\n        // Original: changeOwnerV2()\n        else if (_selector == 2) {\n            owner = _newOwner;\n        }\n    }\n}",
      "merged_functions": [
        "OpenAccess",
        "changeOwner",
        "changeOwnerV2"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: OpenAccess, changeOwner, changeOwnerV2"
      ],
      "function_to_selector": {
        "OpenAccess": 0,
        "changeOwner": 1,
        "changeOwnerV2": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_006",
      "transformed_id": "rs_mg_dis_nc_ds_006",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_007",
      "transformed_id": "rs_mg_dis_nc_ds_007",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.22;\n\ncontract FibonacciBalance {\n\n    address public fibonacciLibrary;\n\n    uint public calculatedFibNumber;\n\n    uint public start = 3;\n    uint public withdrawalCounter;\n\n    bytes4 constant fibSig = bytes4(sha3(\"setFibonacci(uint256)\"));\n\n\n    constructor(address _fibonacciLibrary) public payable {\n        fibonacciLibrary = _fibonacciLibrary;\n    }\n\n    function withdraw() {\n        withdrawalCounter += 1;\n\n\n        require(fibonacciLibrary.delegatecall(fibSig, withdrawalCounter));\n        msg.sender.transfer(calculatedFibNumber * 1 ether);\n    }\n\n\n    function() public {\n        require(fibonacciLibrary.delegatecall(msg.data));\n    }\n}\n\n\ncontract FibonacciLib {\n\n    uint public start;\n    uint public calculatedFibNumber;\n\n\n    function setStart(uint _start) public {\n        start = _start;\n    }\n\n    function setFibonacci(uint n) public {\n        calculatedFibNumber = fibonacci(n);\n    }\n\n    function fibonacci(uint n) internal returns (uint) {\n        if (n == 0) return start;\n        else if (n == 1) return start + 1;\n        else return fibonacci(n - 1) + fibonacci(n - 2);\n    }\n\n    // Unified dispatcher - merged from: setStart, setFibonacci\n    // Selectors: setStart=0, setFibonacci=1\n    function execute(uint8 _selector, uint _start, uint n) public {\n        // Original: setStart()\n        if (_selector == 0) {\n            start = _start;\n        }\n        // Original: setFibonacci()\n        else if (_selector == 1) {\n            calculatedFibNumber = fibonacci(n);\n        }\n    }\n}",
      "merged_functions": [
        "setStart",
        "setFibonacci"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: setStart, setFibonacci"
      ],
      "function_to_selector": {
        "setStart": 0,
        "setFibonacci": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_008",
      "transformed_id": "rs_mg_dis_nc_ds_008",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\n contract Wallet {\n     uint[] private bonusCodes;\n     address private owner;\n\n     constructor() public {\n         bonusCodes = new uint[](0);\n         owner = msg.sender;\n     }\n\n     function () public payable {\n     }\n\n     function PushBonusCode(uint c) public {\n         bonusCodes.push(c);\n     }\n\n     function PopBonusCode() public {\n         require(0 <= bonusCodes.length);\n         bonusCodes.length--;\n     }\n\n     function UpdateBonusCodeAt(uint idx, uint c) public {\n         require(idx < bonusCodes.length);\n         bonusCodes[idx] = c;\n     }\n\n     function Destroy() public {\n         require(msg.sender == owner);\n         selfdestruct(msg.sender);\n     }\n \n    // Unified dispatcher - merged from: PopBonusCode, PushBonusCode, UpdateBonusCodeAt\n    // Selectors: PopBonusCode=0, PushBonusCode=1, UpdateBonusCodeAt=2\n    function execute(uint8 _selector, uint c, uint idx) public {\n        // Original: PopBonusCode()\n        if (_selector == 0) {\n            require(0 <= bonusCodes.length);\n            bonusCodes.length--;\n        }\n        // Original: PushBonusCode()\n        else if (_selector == 1) {\n            bonusCodes.push(c);\n        }\n        // Original: UpdateBonusCodeAt()\n        else if (_selector == 2) {\n            require(idx < bonusCodes.length);\n            bonusCodes[idx] = c;\n        }\n    }\n}",
      "merged_functions": [
        "PopBonusCode",
        "PushBonusCode",
        "UpdateBonusCodeAt"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: PopBonusCode, PushBonusCode, UpdateBonusCodeAt"
      ],
      "function_to_selector": {
        "PopBonusCode": 0,
        "PushBonusCode": 1,
        "UpdateBonusCodeAt": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_009",
      "transformed_id": "rs_mg_dis_nc_ds_009",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Map {\n     address public owner;\n     uint256[] map;\n\n     function set(uint256 key, uint256 value) public {\n         if (map.length <= key) {\n             map.length = key + 1;\n         }\n         map[key] = value;\n     }\n\n     function get(uint256 key) public view returns (uint256) {\n         return map[key];\n     }\n     function withdraw() public{\n       require(msg.sender == owner);\n       msg.sender.transfer(address(this).balance);\n     }\n \n    // Unified dispatcher - merged from: set, withdraw\n    // Selectors: set=0, withdraw=1\n    function execute(uint8 _selector, uint256 key, uint256 value) public {\n        // Original: set()\n        if (_selector == 0) {\n            if (map.length <= key) {\n            map.length = key + 1;\n            }\n            map[key] = value;\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            require(msg.sender == owner);\n            msg.sender.transfer(address(this).balance);\n        }\n    }\n}",
      "merged_functions": [
        "set",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: set, withdraw"
      ],
      "function_to_selector": {
        "set": 0,
        "withdraw": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_010",
      "transformed_id": "rs_mg_dis_nc_ds_010",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract MyContract {\n\n    address owner;\n\n    function MyContract() public {\n        owner = msg.sender;\n    }\n\n    function sendTo(address receiver, uint amount) public {\n        require(tx.origin == owner);\n        receiver.transfer(amount);\n    }\n\n\n    // Unified dispatcher - merged from: sendTo, MyContract\n    // Selectors: sendTo=0, MyContract=1\n    function execute(uint8 _selector, address receiver, uint amount) public {\n        // Original: sendTo()\n        if (_selector == 0) {\n            require(tx.origin == owner);\n            receiver.transfer(amount);\n        }\n        // Original: MyContract()\n        else if (_selector == 1) {\n            owner = msg.sender;\n        }\n    }\n}",
      "merged_functions": [
        "sendTo",
        "MyContract"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: sendTo, MyContract"
      ],
      "function_to_selector": {
        "sendTo": 0,
        "MyContract": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_011",
      "transformed_id": "rs_mg_dis_nc_ds_011",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_012",
      "transformed_id": "rs_mg_dis_nc_ds_012",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_013",
      "transformed_id": "rs_mg_dis_nc_ds_013",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_014",
      "transformed_id": "rs_mg_dis_nc_ds_014",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Wallet {\n     address creator;\n\n     mapping(address => uint256) balances;\n\n     constructor() public {\n         creator = msg.sender;\n     }\n\n     function deposit() public payable {\n         assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n         balances[msg.sender] += msg.value;\n     }\n\n     function withdraw(uint256 amount) public {\n         require(amount <= balances[msg.sender]);\n         msg.sender.transfer(amount);\n         balances[msg.sender] -= amount;\n     }\n\n     function refund() public {\n         msg.sender.transfer(balances[msg.sender]);\n     }\n\n\n     function migrateTo(address to) public {\n         require(creator == msg.sender);\n         to.transfer(this.balance);\n     }\n\n \n    // Unified dispatcher - merged from: refund, deposit, withdraw\n    // Selectors: refund=0, deposit=1, withdraw=2\n    function execute(uint8 _selector, uint256 amount) public payable {\n        // Original: refund()\n        if (_selector == 0) {\n            msg.sender.transfer(balances[msg.sender]);\n        }\n        // Original: deposit()\n        else if (_selector == 1) {\n            assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n            balances[msg.sender] += msg.value;\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            require(amount <= balances[msg.sender]);\n            msg.sender.transfer(amount);\n            balances[msg.sender] -= amount;\n        }\n    }\n}",
      "merged_functions": [
        "refund",
        "deposit",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: refund, deposit, withdraw"
      ],
      "function_to_selector": {
        "refund": 0,
        "deposit": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_015",
      "transformed_id": "rs_mg_dis_nc_ds_015",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Wallet {\n     address creator;\n\n     mapping(address => uint256) balances;\n\n     function initWallet() public {\n         creator = msg.sender;\n     }\n\n     function deposit() public payable {\n         assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n         balances[msg.sender] += msg.value;\n     }\n\n     function withdraw(uint256 amount) public {\n         require(amount <= balances[msg.sender]);\n         msg.sender.transfer(amount);\n         balances[msg.sender] -= amount;\n     }\n\n\n     function migrateTo(address to) public {\n         require(creator == msg.sender);\n         to.transfer(this.balance);\n     }\n\n \n    // Unified dispatcher - merged from: initWallet, deposit, withdraw\n    // Selectors: initWallet=0, deposit=1, withdraw=2\n    function execute(uint8 _selector, uint256 amount) public payable {\n        // Original: initWallet()\n        if (_selector == 0) {\n            creator = msg.sender;\n        }\n        // Original: deposit()\n        else if (_selector == 1) {\n            assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n            balances[msg.sender] += msg.value;\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            require(amount <= balances[msg.sender]);\n            msg.sender.transfer(amount);\n            balances[msg.sender] -= amount;\n        }\n    }\n}",
      "merged_functions": [
        "initWallet",
        "deposit",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: initWallet, deposit, withdraw"
      ],
      "function_to_selector": {
        "initWallet": 0,
        "deposit": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_016",
      "transformed_id": "rs_mg_dis_nc_ds_016",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Wallet {\n     address creator;\n\n     mapping(address => uint256) balances;\n\n     constructor() public {\n         creator = msg.sender;\n     }\n\n     function deposit() public payable {\n         assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n         balances[msg.sender] += msg.value;\n     }\n\n     function withdraw(uint256 amount) public {\n         require(amount >= balances[msg.sender]);\n         msg.sender.transfer(amount);\n         balances[msg.sender] -= amount;\n     }\n\n\n     function migrateTo(address to) public {\n         require(creator == msg.sender);\n         to.transfer(this.balance);\n     }\n\n \n    // Unified dispatcher - merged from: withdraw, deposit, migrateTo\n    // Selectors: withdraw=0, deposit=1, migrateTo=2\n    function execute(uint8 _selector, address to, uint256 amount) public payable {\n        // Original: withdraw()\n        if (_selector == 0) {\n            require(amount >= balances[msg.sender]);\n            msg.sender.transfer(amount);\n            balances[msg.sender] -= amount;\n        }\n        // Original: deposit()\n        else if (_selector == 1) {\n            assert(balances[msg.sender] + msg.value > balances[msg.sender]);\n            balances[msg.sender] += msg.value;\n        }\n        // Original: migrateTo()\n        else if (_selector == 2) {\n            require(creator == msg.sender);\n            to.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "withdraw",
        "deposit",
        "migrateTo"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: withdraw, deposit, migrateTo"
      ],
      "function_to_selector": {
        "withdraw": 0,
        "deposit": 1,
        "migrateTo": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_017",
      "transformed_id": "rs_mg_dis_nc_ds_017",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PERSONAL_BANK\n{\n    mapping (address=>uint256) public balances;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool intitalized;\n\n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)revert();\n        MinSum = _val;\n    }\n\n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)revert();\n        Log = LogFile(_log);\n    }\n\n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, SetMinSum, SetLogFile\n    // Selectors: Collect=0, SetMinSum=1, SetLogFile=2\n    function execute(uint8 _selector, address _log, uint _am, uint _val) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            balances[msg.sender]-=_am;\n            Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: SetMinSum()\n        else if (_selector == 1) {\n            if(intitalized)revert();\n            MinSum = _val;\n        }\n        // Original: SetLogFile()\n        else if (_selector == 2) {\n            if(intitalized)revert();\n            Log = LogFile(_log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "SetMinSum",
        "SetLogFile"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, SetMinSum, SetLogFile"
      ],
      "function_to_selector": {
        "Collect": 0,
        "SetMinSum": 1,
        "SetLogFile": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_018",
      "transformed_id": "rs_mg_dis_nc_ds_018",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public balances;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Deposit, AddMessage\n    // Selectors: Deposit=0, AddMessage=1\n    function execute(uint8 _selector, address _adr, string _data, uint _val) public payable {\n        // Original: Deposit()\n        if (_selector == 0) {\n            if(msg.value >= MinDeposit)\n            {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            }\n        }\n        // Original: AddMessage()\n        else if (_selector == 1) {\n            LastMsg.Sender = _adr;\n            LastMsg.Time = now;\n            LastMsg.Val = _val;\n            LastMsg.Data = _data;\n            History.push(LastMsg);\n        }\n    }\n}",
      "merged_functions": [
        "Deposit",
        "AddMessage"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: Deposit, AddMessage"
      ],
      "function_to_selector": {
        "Deposit": 0,
        "AddMessage": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_019",
      "transformed_id": "rs_mg_dis_nc_ds_019",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ACCURAL_DEPOSIT\n{\n    mapping (address=>uint256) public balances;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool intitalized;\n\n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)revert();\n        MinSum = _val;\n    }\n\n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)revert();\n        Log = LogFile(_log);\n    }\n\n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, SetMinSum, SetLogFile\n    // Selectors: Collect=0, SetMinSum=1, SetLogFile=2\n    function execute(uint8 _selector, address _log, uint _am, uint _val) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            balances[msg.sender]-=_am;\n            Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: SetMinSum()\n        else if (_selector == 1) {\n            if(intitalized)revert();\n            MinSum = _val;\n        }\n        // Original: SetLogFile()\n        else if (_selector == 2) {\n            if(intitalized)revert();\n            Log = LogFile(_log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "SetMinSum",
        "SetLogFile"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, SetMinSum, SetLogFile"
      ],
      "function_to_selector": {
        "Collect": 0,
        "SetMinSum": 1,
        "SetLogFile": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_020",
      "transformed_id": "rs_mg_dis_nc_ds_020",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PRIVATE_ETH_CELL\n{\n    mapping (address=>uint256) public balances;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool intitalized;\n\n    function SetMinSum(uint _val)\n    public\n    {\n        require(!intitalized);\n        MinSum = _val;\n    }\n\n    function SetLogFile(address _log)\n    public\n    {\n        require(!intitalized);\n        Log = LogFile(_log);\n    }\n\n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, SetMinSum, SetLogFile\n    // Selectors: Collect=0, SetMinSum=1, SetLogFile=2\n    function execute(uint8 _selector, address _log, uint _am, uint _val) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            balances[msg.sender]-=_am;\n            Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: SetMinSum()\n        else if (_selector == 1) {\n            require(!intitalized);\n            MinSum = _val;\n        }\n        // Original: SetLogFile()\n        else if (_selector == 2) {\n            require(!intitalized);\n            Log = LogFile(_log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "SetMinSum",
        "SetLogFile"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, SetMinSum, SetLogFile"
      ],
      "function_to_selector": {
        "Collect": 0,
        "SetMinSum": 1,
        "SetLogFile": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_021",
      "transformed_id": "rs_mg_dis_nc_ds_021",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract BANK_SAFE\n{\n    mapping (address=>uint256) public balances;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool intitalized;\n\n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n\n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n\n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, SetMinSum, SetLogFile\n    // Selectors: Collect=0, SetMinSum=1, SetLogFile=2\n    function execute(uint8 _selector, address _log, uint _am, uint _val) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            balances[msg.sender]-=_am;\n            Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: SetMinSum()\n        else if (_selector == 1) {\n            if(intitalized)throw;\n            MinSum = _val;\n        }\n        // Original: SetLogFile()\n        else if (_selector == 2) {\n            if(intitalized)throw;\n            Log = LogFile(_log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "SetMinSum",
        "SetLogFile"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, SetMinSum, SetLogFile"
      ],
      "function_to_selector": {
        "Collect": 0,
        "SetMinSum": 1,
        "SetLogFile": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_022",
      "transformed_id": "rs_mg_dis_nc_ds_022",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n\n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n\n    function confirmOwner()\n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n\n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public\n    onlyOwner\n    {\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);\n        }\n    }\n\n    function WithdrawToHolder(address _addr, uint _wei)\n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[_addr]>0)\n        {\n            if(_addr.call.value(_wei)())\n            {\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n\n    // Unified dispatcher - merged from: WithdrawToHolder, changeOwner, confirmOwner\n    // Selectors: WithdrawToHolder=0, changeOwner=1, confirmOwner=2\n    function execute(uint8 _selector, address _addr, address addr, uint _wei) public payable {\n        // Original: WithdrawToHolder()\n        if (_selector == 0) {\n            if(Holders[_addr]>0)\n            {\n            if(_addr.call.value(_wei)())\n            {\n            Holders[_addr]-=_wei;\n            }\n            }\n        }\n        // Original: changeOwner()\n        else if (_selector == 1) {\n            newOwner = addr;\n        }\n        // Original: confirmOwner()\n        else if (_selector == 2) {\n            if(msg.sender==newOwner)\n            {\n            owner=newOwner;\n            }\n        }\n    }\n}",
      "merged_functions": [
        "WithdrawToHolder",
        "changeOwner",
        "confirmOwner"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: WithdrawToHolder, changeOwner, confirmOwner"
      ],
      "function_to_selector": {
        "WithdrawToHolder": 0,
        "changeOwner": 1,
        "confirmOwner": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_023",
      "transformed_id": "rs_mg_dis_nc_ds_023",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract U_BANK\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 2 ether;\n\n    function U_BANK(address log) public{\n        LogFile = Log(log);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, Put, U_BANK\n    // Selectors: Collect=0, Put=1, U_BANK=2\n    function execute(uint8 _selector, address log, uint _am, uint _unlockTime) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            var acc = Acc[msg.sender];\n            if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            acc.balance-=_am;\n            LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: Put()\n        else if (_selector == 1) {\n            var acc = Acc[msg.sender];\n            acc.balance += msg.value;\n            acc.unlockTime = _unlockTime>now?_unlockTime:now;\n            LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n        }\n        // Original: U_BANK()\n        else if (_selector == 2) {\n            LogFile = Log(log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "Put",
        "U_BANK"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, Put, U_BANK"
      ],
      "function_to_selector": {
        "Collect": 0,
        "Put": 1,
        "U_BANK": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_024",
      "transformed_id": "rs_mg_dis_nc_ds_024",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PrivateDeposit\n{\n    mapping (address => uint) public balances;\n\n    uint public MinDeposit = 1 ether;\n    address public owner;\n\n    Log TransferLog;\n\n    modifier onlyOwner() {\n        require(tx.origin == owner);\n        _;\n    }\n\n    function PrivateDeposit()\n    {\n        owner = msg.sender;\n        TransferLog = new Log();\n    }\n\n    function setLog(address _lib) onlyOwner\n    {\n        TransferLog = Log(_lib);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Deposit, AddMessage\n    // Selectors: Deposit=0, AddMessage=1\n    function execute(uint8 _selector, address _adr, string _data, uint _val) public payable {\n        // Original: Deposit()\n        if (_selector == 0) {\n            if(msg.value >= MinDeposit)\n            {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            }\n        }\n        // Original: AddMessage()\n        else if (_selector == 1) {\n            LastMsg.Sender = _adr;\n            LastMsg.Time = now;\n            LastMsg.Val = _val;\n            LastMsg.Data = _data;\n            History.push(LastMsg);\n        }\n    }\n}",
      "merged_functions": [
        "Deposit",
        "AddMessage"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: Deposit, AddMessage"
      ],
      "function_to_selector": {
        "Deposit": 0,
        "AddMessage": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_025",
      "transformed_id": "rs_mg_dis_nc_ds_025",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract W_WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function W_WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, Put, W_WALLET\n    // Selectors: Collect=0, Put=1, W_WALLET=2\n    function execute(uint8 _selector, address log, uint _am, uint _unlockTime) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            var acc = Acc[msg.sender];\n            if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            acc.balance-=_am;\n            LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: Put()\n        else if (_selector == 1) {\n            var acc = Acc[msg.sender];\n            acc.balance += msg.value;\n            acc.unlockTime = _unlockTime>now?_unlockTime:now;\n            LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n        }\n        // Original: W_WALLET()\n        else if (_selector == 2) {\n            LogFile = Log(log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "Put",
        "W_WALLET"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, Put, W_WALLET"
      ],
      "function_to_selector": {
        "Collect": 0,
        "Put": 1,
        "W_WALLET": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_026",
      "transformed_id": "rs_mg_dis_nc_ds_026",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public balances;\n\n    Log TransferLog;\n\n    uint public MinDeposit = 1 ether;\n\n    function ETH_VAULT(address _log)\n    public\n    {\n        TransferLog = Log(_log);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: CashOut, ETH_VAULT, Deposit\n    // Selectors: CashOut=0, ETH_VAULT=1, Deposit=2\n    function execute(uint8 _selector, address _log, uint _am) public payable {\n        // Original: CashOut()\n        if (_selector == 0) {\n            if(_am<=balances[msg.sender])\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            balances[msg.sender]-=_am;\n            TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n            }\n        }\n        // Original: ETH_VAULT()\n        else if (_selector == 1) {\n            TransferLog = Log(_log);\n        }\n        // Original: Deposit()\n        else if (_selector == 2) {\n            if(msg.value > MinDeposit)\n            {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            }\n        }\n    }\n}",
      "merged_functions": [
        "CashOut",
        "ETH_VAULT",
        "Deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: CashOut, ETH_VAULT, Deposit"
      ],
      "function_to_selector": {
        "CashOut": 0,
        "ETH_VAULT": 1,
        "Deposit": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_027",
      "transformed_id": "rs_mg_dis_nc_ds_027",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract X_WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function X_WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, Put, X_WALLET\n    // Selectors: Collect=0, Put=1, X_WALLET=2\n    function execute(uint8 _selector, address log, uint _am, uint _unlockTime) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            var acc = Acc[msg.sender];\n            if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            acc.balance-=_am;\n            LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: Put()\n        else if (_selector == 1) {\n            var acc = Acc[msg.sender];\n            acc.balance += msg.value;\n            acc.unlockTime = _unlockTime>now?_unlockTime:now;\n            LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n        }\n        // Original: X_WALLET()\n        else if (_selector == 2) {\n            LogFile = Log(log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "Put",
        "X_WALLET"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, Put, X_WALLET"
      ],
      "function_to_selector": {
        "Collect": 0,
        "Put": 1,
        "X_WALLET": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_028",
      "transformed_id": "rs_mg_dis_nc_ds_028",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ETH_FUND\n{\n    mapping (address => uint) public balances;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    uint lastBlock;\n\n    function ETH_FUND(address _log)\n    public\n    {\n        TransferLog = Log(_log);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            lastBlock = block.number;\n        }\n    }\n\n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender]&&block.number>lastBlock)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: CashOut, ETH_FUND, Deposit\n    // Selectors: CashOut=0, ETH_FUND=1, Deposit=2\n    function execute(uint8 _selector, address _log, uint _am) public payable {\n        // Original: CashOut()\n        if (_selector == 0) {\n            if(_am<=balances[msg.sender]&&block.number>lastBlock)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            balances[msg.sender]-=_am;\n            TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n            }\n        }\n        // Original: ETH_FUND()\n        else if (_selector == 1) {\n            TransferLog = Log(_log);\n        }\n        // Original: Deposit()\n        else if (_selector == 2) {\n            if(msg.value > MinDeposit)\n            {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            lastBlock = block.number;\n            }\n        }\n    }\n}",
      "merged_functions": [
        "CashOut",
        "ETH_FUND",
        "Deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: CashOut, ETH_FUND, Deposit"
      ],
      "function_to_selector": {
        "CashOut": 0,
        "ETH_FUND": 1,
        "Deposit": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_029",
      "transformed_id": "rs_mg_dis_nc_ds_029",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PENNY_BY_PENNY\n{\n    struct Holder\n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool intitalized;\n\n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n\n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n\n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n\n    function Put(uint _lockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, SetMinSum, SetLogFile\n    // Selectors: Collect=0, SetMinSum=1, SetLogFile=2\n    function execute(uint8 _selector, address _log, uint _am, uint _val) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            var acc = Acc[msg.sender];\n            if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            acc.balance-=_am;\n            Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: SetMinSum()\n        else if (_selector == 1) {\n            if(intitalized)throw;\n            MinSum = _val;\n        }\n        // Original: SetLogFile()\n        else if (_selector == 2) {\n            if(intitalized)throw;\n            Log = LogFile(_log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "SetMinSum",
        "SetLogFile"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, SetMinSum, SetLogFile"
      ],
      "function_to_selector": {
        "Collect": 0,
        "SetMinSum": 1,
        "SetLogFile": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_030",
      "transformed_id": "rs_mg_dis_nc_ds_030",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract DEP_BANK\n{\n    mapping (address=>uint256) public balances;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool intitalized;\n\n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n\n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        Log = LogFile(_log);\n    }\n\n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        balances[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, SetMinSum, SetLogFile\n    // Selectors: Collect=0, SetMinSum=1, SetLogFile=2\n    function execute(uint8 _selector, address _log, uint _am, uint _val) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            if(balances[msg.sender]>=MinSum && balances[msg.sender]>=_am)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            balances[msg.sender]-=_am;\n            Log.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: SetMinSum()\n        else if (_selector == 1) {\n            if(intitalized)throw;\n            MinSum = _val;\n        }\n        // Original: SetLogFile()\n        else if (_selector == 2) {\n            if(intitalized)throw;\n            Log = LogFile(_log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "SetMinSum",
        "SetLogFile"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, SetMinSum, SetLogFile"
      ],
      "function_to_selector": {
        "Collect": 0,
        "SetMinSum": 1,
        "SetLogFile": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_031",
      "transformed_id": "rs_mg_dis_nc_ds_031",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public balances;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: CashOut, Deposit, AddMessage\n    // Selectors: CashOut=0, Deposit=1, AddMessage=2\n    function execute(uint8 _selector, address _adr, string _data, uint _am, uint _val) public payable {\n        // Original: CashOut()\n        if (_selector == 0) {\n            if(_am<=balances[msg.sender])\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            balances[msg.sender]-=_am;\n            TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n            }\n        }\n        // Original: Deposit()\n        else if (_selector == 1) {\n            if(msg.value > MinDeposit)\n            {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            }\n        }\n        // Original: AddMessage()\n        else if (_selector == 2) {\n            LastMsg.Sender = _adr;\n            LastMsg.Time = now;\n            LastMsg.Val = _val;\n            LastMsg.Data = _data;\n            History.push(LastMsg);\n        }\n    }\n}",
      "merged_functions": [
        "CashOut",
        "Deposit",
        "AddMessage"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: CashOut, Deposit, AddMessage"
      ],
      "function_to_selector": {
        "CashOut": 0,
        "Deposit": 1,
        "AddMessage": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_032",
      "transformed_id": "rs_mg_dis_nc_ds_032",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public balances;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address _lib)\n    {\n        TransferLog = Log(_lib);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Deposit, AddMessage\n    // Selectors: Deposit=0, AddMessage=1\n    function execute(uint8 _selector, address _adr, string _data, uint _val) public payable {\n        // Original: Deposit()\n        if (_selector == 0) {\n            if(msg.value >= MinDeposit)\n            {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            }\n        }\n        // Original: AddMessage()\n        else if (_selector == 1) {\n            LastMsg.Sender = _adr;\n            LastMsg.Time = now;\n            LastMsg.Val = _val;\n            LastMsg.Data = _data;\n            History.push(LastMsg);\n        }\n    }\n}",
      "merged_functions": [
        "Deposit",
        "AddMessage"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: Deposit, AddMessage"
      ],
      "function_to_selector": {
        "Deposit": 0,
        "AddMessage": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_033",
      "transformed_id": "rs_mg_dis_nc_ds_033",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public balances;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function ETH_VAULT(address _log)\n    public\n    {\n        TransferLog = Log(_log);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _am)\n    public\n    payable\n    {\n        if(_am<=balances[msg.sender])\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: CashOut, ETH_VAULT, Deposit\n    // Selectors: CashOut=0, ETH_VAULT=1, Deposit=2\n    function execute(uint8 _selector, address _log, uint _am) public payable {\n        // Original: CashOut()\n        if (_selector == 0) {\n            if(_am<=balances[msg.sender])\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            balances[msg.sender]-=_am;\n            TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n            }\n        }\n        // Original: ETH_VAULT()\n        else if (_selector == 1) {\n            TransferLog = Log(_log);\n        }\n        // Original: Deposit()\n        else if (_selector == 2) {\n            if(msg.value > MinDeposit)\n            {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            }\n        }\n    }\n}",
      "merged_functions": [
        "CashOut",
        "ETH_VAULT",
        "Deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: CashOut, ETH_VAULT, Deposit"
      ],
      "function_to_selector": {
        "CashOut": 0,
        "ETH_VAULT": 1,
        "Deposit": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_034",
      "transformed_id": "rs_mg_dis_nc_ds_034",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract MONEY_BOX\n{\n    struct Holder\n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    Log LogFile;\n\n    bool intitalized;\n\n    function SetMinSum(uint _val)\n    public\n    {\n        if(intitalized)throw;\n        MinSum = _val;\n    }\n\n    function SetLogFile(address _log)\n    public\n    {\n        if(intitalized)throw;\n        LogFile = Log(_log);\n    }\n\n    function Initialized()\n    public\n    {\n        intitalized = true;\n    }\n\n    function Put(uint _lockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        if(now+_lockTime>acc.unlockTime)acc.unlockTime=now+_lockTime;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, SetMinSum, SetLogFile\n    // Selectors: Collect=0, SetMinSum=1, SetLogFile=2\n    function execute(uint8 _selector, address _log, uint _am, uint _val) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            var acc = Acc[msg.sender];\n            if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            acc.balance-=_am;\n            LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: SetMinSum()\n        else if (_selector == 1) {\n            if(intitalized)throw;\n            MinSum = _val;\n        }\n        // Original: SetLogFile()\n        else if (_selector == 2) {\n            if(intitalized)throw;\n            LogFile = Log(_log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "SetMinSum",
        "SetLogFile"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, SetMinSum, SetLogFile"
      ],
      "function_to_selector": {
        "Collect": 0,
        "SetMinSum": 1,
        "SetLogFile": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_035",
      "transformed_id": "rs_mg_dis_nc_ds_035",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract WALLET\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function WALLET(address log) public{\n        LogFile = Log(log);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, Put, WALLET\n    // Selectors: Collect=0, Put=1, WALLET=2\n    function execute(uint8 _selector, address log, uint _am, uint _unlockTime) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            var acc = Acc[msg.sender];\n            if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            acc.balance-=_am;\n            LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: Put()\n        else if (_selector == 1) {\n            var acc = Acc[msg.sender];\n            acc.balance += msg.value;\n            acc.unlockTime = _unlockTime>now?_unlockTime:now;\n            LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n        }\n        // Original: WALLET()\n        else if (_selector == 2) {\n            LogFile = Log(log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "Put",
        "WALLET"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, Put, WALLET"
      ],
      "function_to_selector": {
        "Collect": 0,
        "Put": 1,
        "WALLET": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_036",
      "transformed_id": "rs_mg_dis_nc_ds_036",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract MY_BANK\n{\n    function Put(uint _unlockTime)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        acc.balance += msg.value;\n        acc.unlockTime = _unlockTime>now?_unlockTime:now;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _am)\n    public\n    payable\n    {\n        var acc = Acc[msg.sender];\n        if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n        {\n            if(msg.sender.call.value(_am)())\n            {\n                acc.balance-=_am;\n                LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint unlockTime;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function MY_BANK(address log) public{\n        LogFile = Log(log);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Collect, Put, MY_BANK\n    // Selectors: Collect=0, Put=1, MY_BANK=2\n    function execute(uint8 _selector, address log, uint _am, uint _unlockTime) public payable {\n        // Original: Collect()\n        if (_selector == 0) {\n            var acc = Acc[msg.sender];\n            if( acc.balance>=MinSum && acc.balance>=_am && now>acc.unlockTime)\n            {\n            if(msg.sender.call.value(_am)())\n            {\n            acc.balance-=_am;\n            LogFile.AddMessage(msg.sender,_am,\"Collect\");\n            }\n            }\n        }\n        // Original: Put()\n        else if (_selector == 1) {\n            var acc = Acc[msg.sender];\n            acc.balance += msg.value;\n            acc.unlockTime = _unlockTime>now?_unlockTime:now;\n            LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n        }\n        // Original: MY_BANK()\n        else if (_selector == 2) {\n            LogFile = Log(log);\n        }\n    }\n}",
      "merged_functions": [
        "Collect",
        "Put",
        "MY_BANK"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Collect, Put, MY_BANK"
      ],
      "function_to_selector": {
        "Collect": 0,
        "Put": 1,
        "MY_BANK": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_037",
      "transformed_id": "rs_mg_dis_nc_ds_037",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_038",
      "transformed_id": "rs_mg_dis_nc_ds_038",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\ncontract EtherStore {\n\n    uint256 public withdrawalLimit = 1 ether;\n    mapping(address => uint256) public lastWithdrawTime;\n    mapping(address => uint256) public balances;\n\n    function depositFunds() public payable {\n        balances[msg.sender] += msg.value;\n    }\n\n    function withdrawFunds (uint256 _weiToWithdraw) public {\n        require(balances[msg.sender] >= _weiToWithdraw);\n\n        require(_weiToWithdraw <= withdrawalLimit);\n\n        require(now >= lastWithdrawTime[msg.sender] + 1 weeks);\n        require(msg.sender.call.value(_weiToWithdraw)());\n        balances[msg.sender] -= _weiToWithdraw;\n        lastWithdrawTime[msg.sender] = now;\n    }\n \n    // Unified dispatcher - merged from: withdrawFunds, depositFunds\n    // Selectors: withdrawFunds=0, depositFunds=1\n    function execute(uint8 _selector, uint256 _weiToWithdraw) public payable {\n        // Original: withdrawFunds()\n        if (_selector == 0) {\n            require(balances[msg.sender] >= _weiToWithdraw);\n            require(_weiToWithdraw <= withdrawalLimit);\n            require(now >= lastWithdrawTime[msg.sender] + 1 weeks);\n            require(msg.sender.call.value(_weiToWithdraw)());\n            balances[msg.sender] -= _weiToWithdraw;\n            lastWithdrawTime[msg.sender] = now;\n        }\n        // Original: depositFunds()\n        else if (_selector == 1) {\n            balances[msg.sender] += msg.value;\n        }\n    }\n}",
      "merged_functions": [
        "withdrawFunds",
        "depositFunds"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: withdrawFunds, depositFunds"
      ],
      "function_to_selector": {
        "withdrawFunds": 0,
        "depositFunds": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_039",
      "transformed_id": "rs_mg_dis_nc_ds_039",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract ModifierBank {\n  mapping (address => uint) public tokenBalance;\n  string constant name = \"Nu Token\";\n\n\n  function airDrop() hasNoBalance supportsToken  public{\n    tokenBalance[msg.sender] += 20;\n  }\n\n\n  modifier supportsToken() {\n    require(keccak256(abi.encodePacked(\"Nu Token\")) == Bank(msg.sender).supportsToken());\n    _;\n  }\n\n  modifier hasNoBalance {\n      require(tokenBalance[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n    function supportsToken() external pure returns(bytes32){\n        return(keccak256(abi.encodePacked(\"Nu Token\")));\n    }\n}\n\ncontract executor {\n    bool hasBeenCalled;\n    function supportsToken() external returns(bytes32){\n        if(!hasBeenCalled){\n            hasBeenCalled = true;\n            ModifierBank(msg.sender).airDrop();\n        }\n        return(keccak256(abi.encodePacked(\"Nu Token\")));\n    }\n    function call(address token) public{\n        ModifierBank(token).airDrop();\n    }\n\n    // Unified dispatcher - merged from: airDrop, supportsToken, call\n    // Selectors: airDrop=0, supportsToken=1, call=2\n    function execute(uint8 _selector, address token) public {\n        // Original: airDrop()\n        if (_selector == 0) {\n            tokenBalance[msg.sender] += 20;\n        }\n        // Original: supportsToken()\n        else if (_selector == 1) {\n            if(!hasBeenCalled){\n            hasBeenCalled = true;\n            ModifierBank(msg.sender).airDrop();\n            }\n            return(keccak256(abi.encodePacked(\"Nu Token\")));\n        }\n        // Original: call()\n        else if (_selector == 2) {\n            ModifierBank(token).airDrop();\n        }\n    }\n}",
      "merged_functions": [
        "airDrop",
        "supportsToken",
        "call"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: airDrop, supportsToken, call"
      ],
      "function_to_selector": {
        "airDrop": 0,
        "supportsToken": 1,
        "call": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_040",
      "transformed_id": "rs_mg_dis_nc_ds_040",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract TokenVault {\n\n  mapping(address => uint) public balances;\n\n  function donate(address _to) public payable {\n    balances[_to] += msg.value;\n  }\n\n  function balanceOf(address _who) public view returns (uint balance) {\n    return balances[_who];\n  }\n\n  function withdraw(uint _amount) public {\n    if(balances[msg.sender] >= _amount) {\n      if(msg.sender.call.value(_amount)()) {\n        _amount;\n      }\n      balances[msg.sender] -= _amount;\n    }\n  }\n\n  function() public payable {}\n\n    // Unified dispatcher - merged from: withdraw, donate\n    // Selectors: withdraw=0, donate=1\n    function execute(uint8 _selector, address _to, uint _amount) public payable {\n        // Original: withdraw()\n        if (_selector == 0) {\n            if(balances[msg.sender] >= _amount) {\n            if(msg.sender.call.value(_amount)()) {\n            _amount;\n            }\n            balances[msg.sender] -= _amount;\n            }\n        }\n        // Original: donate()\n        else if (_selector == 1) {\n            balances[_to] += msg.value;\n        }\n    }\n}",
      "merged_functions": [
        "withdraw",
        "donate"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: withdraw, donate"
      ],
      "function_to_selector": {
        "withdraw": 0,
        "donate": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_041",
      "transformed_id": "rs_mg_dis_nc_ds_041",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract BonusVault{\n\n    mapping (address => uint) private userBalances;\n    mapping (address => bool) private claimedBonus;\n    mapping (address => uint) private rewardsForA;\n\n    function withdrawReward(address recipient) public {\n        uint amountToWithdraw = rewardsForA[recipient];\n        rewardsForA[recipient] = 0;\n        (bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\n        require(success);\n    }\n\n    function getFirstWithdrawalBonus(address recipient) public {\n        require(!claimedBonus[recipient]);\n\n        rewardsForA[recipient] += 100;\n        withdrawReward(recipient);\n        claimedBonus[recipient] = true;\n    }\n\n    // Unified dispatcher - merged from: getFirstWithdrawalBonus, withdrawReward\n    // Selectors: getFirstWithdrawalBonus=0, withdrawReward=1\n    function execute(uint8 _selector, address recipient) public {\n        // Original: getFirstWithdrawalBonus()\n        if (_selector == 0) {\n            require(!claimedBonus[recipient]);\n            rewardsForA[recipient] += 100;\n            withdrawReward(recipient);\n            claimedBonus[recipient] = true;\n        }\n        // Original: withdrawReward()\n        else if (_selector == 1) {\n            uint amountToWithdraw = rewardsForA[recipient];\n            rewardsForA[recipient] = 0;\n            (bool success, ) = recipient.call.value(amountToWithdraw)(\"\");\n            require(success);\n        }\n    }\n}",
      "merged_functions": [
        "getFirstWithdrawalBonus",
        "withdrawReward"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: getFirstWithdrawalBonus, withdrawReward"
      ],
      "function_to_selector": {
        "getFirstWithdrawalBonus": 0,
        "withdrawReward": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_042",
      "transformed_id": "rs_mg_dis_nc_ds_042",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_043",
      "transformed_id": "rs_mg_dis_nc_ds_043",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract CommunityVault {\n    mapping (address => uint) credit;\n    uint balance;\n\n    function withdrawAll() public {\n        uint oCredit = credit[msg.sender];\n        if (oCredit > 0) {\n            balance -= oCredit;\n            bool callResult = msg.sender.call.value(oCredit)();\n            require (callResult);\n            credit[msg.sender] = 0;\n        }\n    }\n\n    function deposit() public payable {\n        credit[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n\n    // Unified dispatcher - merged from: withdrawAll, deposit\n    // Selectors: withdrawAll=0, deposit=1\n    function execute(uint8 _selector) public payable {\n        // Original: withdrawAll()\n        if (_selector == 0) {\n            uint oCredit = credit[msg.sender];\n            if (oCredit > 0) {\n            balance -= oCredit;\n            bool callResult = msg.sender.call.value(oCredit)();\n            require (callResult);\n            credit[msg.sender] = 0;\n            }\n        }\n        // Original: deposit()\n        else if (_selector == 1) {\n            credit[msg.sender] += msg.value;\n            balance += msg.value;\n        }\n    }\n}",
      "merged_functions": [
        "withdrawAll",
        "deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: withdrawAll, deposit"
      ],
      "function_to_selector": {
        "withdrawAll": 0,
        "deposit": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_044",
      "transformed_id": "rs_mg_dis_nc_ds_044",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_045",
      "transformed_id": "rs_mg_dis_nc_ds_045",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_046",
      "transformed_id": "rs_mg_dis_nc_ds_046",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_047",
      "transformed_id": "rs_mg_dis_nc_ds_047",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_048",
      "transformed_id": "rs_mg_dis_nc_ds_048",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_049",
      "transformed_id": "rs_mg_dis_nc_ds_049",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n\n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n\n    function confirmOwner()\n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n\n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public\n    onlyOwner\n    {\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);\n        }\n    }\n\n    function WithdrawToHolder(address _addr, uint _wei)\n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n\n\n    // Unified dispatcher - merged from: WithdrawToken, changeOwner, confirmOwner\n    // Selectors: WithdrawToken=0, changeOwner=1, confirmOwner=2\n    function execute(uint8 _selector, address addr, address to, address token, uint256 amount) public {\n        // Original: WithdrawToken()\n        if (_selector == 0) {\n            token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n        }\n        // Original: changeOwner()\n        else if (_selector == 1) {\n            newOwner = addr;\n        }\n        // Original: confirmOwner()\n        else if (_selector == 2) {\n            if(msg.sender==newOwner)\n            {\n            owner=newOwner;\n            }\n        }\n    }\n}",
      "merged_functions": [
        "WithdrawToken",
        "changeOwner",
        "confirmOwner"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: WithdrawToken, changeOwner, confirmOwner"
      ],
      "function_to_selector": {
        "WithdrawToken": 0,
        "changeOwner": 1,
        "confirmOwner": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_050",
      "transformed_id": "rs_mg_dis_nc_ds_050",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n\n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n\n    function confirmOwner()\n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n\n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public\n    onlyOwner\n    {\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);\n        }\n    }\n\n    function WithdrawToHolder(address _addr, uint _wei)\n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n\n    // Unified dispatcher - merged from: WithdrawToken, changeOwner, confirmOwner\n    // Selectors: WithdrawToken=0, changeOwner=1, confirmOwner=2\n    function execute(uint8 _selector, address addr, address to, address token, uint256 amount) public {\n        // Original: WithdrawToken()\n        if (_selector == 0) {\n            token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n        }\n        // Original: changeOwner()\n        else if (_selector == 1) {\n            newOwner = addr;\n        }\n        // Original: confirmOwner()\n        else if (_selector == 2) {\n            if(msg.sender==newOwner)\n            {\n            owner=newOwner;\n            }\n        }\n    }\n}",
      "merged_functions": [
        "WithdrawToken",
        "changeOwner",
        "confirmOwner"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: WithdrawToken, changeOwner, confirmOwner"
      ],
      "function_to_selector": {
        "WithdrawToken": 0,
        "changeOwner": 1,
        "confirmOwner": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_051",
      "transformed_id": "rs_mg_dis_nc_ds_051",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract MultiplicatorX4\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    function multiplicate(address adr)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            adr.transfer(this.balance+msg.value);\n        }\n    }\n\n    // Unified dispatcher - merged from: Command, withdraw, multiplicate\n    // Selectors: Command=0, withdraw=1, multiplicate=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n        // Original: multiplicate()\n        else if (_selector == 2) {\n            if(msg.value>=this.balance)\n            {\n            adr.transfer(this.balance+msg.value);\n            }\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "withdraw",
        "multiplicate"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, withdraw, multiplicate"
      ],
      "function_to_selector": {
        "Command": 0,
        "withdraw": 1,
        "multiplicate": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_052",
      "transformed_id": "rs_mg_dis_nc_ds_052",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n    uint constant public minEligibility = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function redeem()\n    public\n    payable\n    {\n        if(msg.value>=minEligibility)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    // Unified dispatcher - merged from: Command, redeem, withdraw\n    // Selectors: Command=0, redeem=1, withdraw=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: redeem()\n        else if (_selector == 1) {\n            if(msg.value>=minEligibility)\n            {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "redeem",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, redeem, withdraw"
      ],
      "function_to_selector": {
        "Command": 0,
        "redeem": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_053",
      "transformed_id": "rs_mg_dis_nc_ds_053",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_054",
      "transformed_id": "rs_mg_dis_nc_ds_054",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_055",
      "transformed_id": "rs_mg_dis_nc_ds_055",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_056",
      "transformed_id": "rs_mg_dis_nc_ds_056",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_057",
      "transformed_id": "rs_mg_dis_nc_ds_057",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Token {\n    function transfer(address _to, uint _value) returns (bool success);\n    function balanceOf(address _owner) constant returns (uint balance);\n}\ncontract EtherGet {\n    address owner;\n    function EtherGet() {\n        owner = msg.sender;\n    }\n    function withdrawTokens(address tokenContract) public {\n        Token tc = Token(tokenContract);\n        tc.transfer(owner, tc.balanceOf(this));\n    }\n    function withdrawEther() public {\n        owner.transfer(this.balance);\n    }\n    function getTokens(uint num, address addr) public {\n        for(uint i = 0; i < num; i++){\n            addr.call.value(0 wei)();\n        }\n    }\n\n    // Unified dispatcher - merged from: getTokens, withdrawTokens, withdrawEther\n    // Selectors: getTokens=0, withdrawTokens=1, withdrawEther=2\n    function execute(uint8 _selector, address addr, address tokenContract, uint num) public {\n        // Original: getTokens()\n        if (_selector == 0) {\n            for(uint i = 0; i < num; i++){\n            addr.call.value(0 wei)();\n            }\n        }\n        // Original: withdrawTokens()\n        else if (_selector == 1) {\n            Token tc = Token(tokenContract);\n            tc.transfer(owner, tc.balanceOf(this));\n        }\n        // Original: withdrawEther()\n        else if (_selector == 2) {\n            owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "getTokens",
        "withdrawTokens",
        "withdrawEther"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: getTokens, withdrawTokens, withdrawEther"
      ],
      "function_to_selector": {
        "getTokens": 0,
        "withdrawTokens": 1,
        "withdrawEther": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_058",
      "transformed_id": "rs_mg_dis_nc_ds_058",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract MultiplicatorX3\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    function multiplicate(address adr)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            adr.transfer(this.balance+msg.value);\n        }\n    }\n\n    // Unified dispatcher - merged from: Command, withdraw, multiplicate\n    // Selectors: Command=0, withdraw=1, multiplicate=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n        // Original: multiplicate()\n        else if (_selector == 2) {\n            if(msg.value>=this.balance)\n            {\n            adr.transfer(this.balance+msg.value);\n            }\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "withdraw",
        "multiplicate"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, withdraw, multiplicate"
      ],
      "function_to_selector": {
        "Command": 0,
        "withdraw": 1,
        "multiplicate": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_059",
      "transformed_id": "rs_mg_dis_nc_ds_059",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public owner = msg.sender;\n    uint public depositsCount;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function() public payable {\n        depositsCount++;\n    }\n\n    function withdrawAll() public onlyOwner {\n        withdraw(address(this).balance);\n    }\n\n    function withdraw(uint _value) public onlyOwner {\n        msg.sender.transfer(_value);\n    }\n\n    function sendMoney(address _target, uint _value, bytes _data) public onlyOwner {\n        _target.call.value(_value)(_data);\n    }\n\n    // Unified dispatcher - merged from: sendMoney, withdrawAll, withdraw\n    // Selectors: sendMoney=0, withdrawAll=1, withdraw=2\n    function execute(uint8 _selector, address _target, bytes _data, uint _value) public {\n        // Original: sendMoney()\n        if (_selector == 0) {\n            _target.call.value(_value)(_data);\n        }\n        // Original: withdrawAll()\n        else if (_selector == 1) {\n            withdraw(address(this).balance);\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            msg.sender.transfer(_value);\n        }\n    }\n}",
      "merged_functions": [
        "sendMoney",
        "withdrawAll",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: sendMoney, withdrawAll, withdraw"
      ],
      "function_to_selector": {
        "sendMoney": 0,
        "withdrawAll": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_060",
      "transformed_id": "rs_mg_dis_nc_ds_060",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n\n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n\n    function confirmOwner()\n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n\n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public\n    onlyOwner\n    {\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);\n        }\n    }\n\n    function WithdrawToHolder(address _addr, uint _wei)\n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[_addr]>0)\n        {\n            if(_addr.call.value(_wei)())\n            {\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n\n    // Unified dispatcher - merged from: WithdrawToken, changeOwner, confirmOwner\n    // Selectors: WithdrawToken=0, changeOwner=1, confirmOwner=2\n    function execute(uint8 _selector, address addr, address to, address token, uint256 amount) public {\n        // Original: WithdrawToken()\n        if (_selector == 0) {\n            token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n        }\n        // Original: changeOwner()\n        else if (_selector == 1) {\n            newOwner = addr;\n        }\n        // Original: confirmOwner()\n        else if (_selector == 2) {\n            if(msg.sender==newOwner)\n            {\n            owner=newOwner;\n            }\n        }\n    }\n}",
      "merged_functions": [
        "WithdrawToken",
        "changeOwner",
        "confirmOwner"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: WithdrawToken, changeOwner, confirmOwner"
      ],
      "function_to_selector": {
        "WithdrawToken": 0,
        "changeOwner": 1,
        "confirmOwner": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_061",
      "transformed_id": "rs_mg_dis_nc_ds_061",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract HomeyJar {\n    address public Owner = msg.sender;\n\n    function() public payable {}\n\n    function GetHoneyFromJar() public payable {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function withdraw() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data) payable public {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    // Unified dispatcher - merged from: Command, GetHoneyFromJar, withdraw\n    // Selectors: Command=0, GetHoneyFromJar=1, withdraw=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: GetHoneyFromJar()\n        else if (_selector == 1) {\n            if(msg.value>1 ether)\n            {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "GetHoneyFromJar",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, GetHoneyFromJar, withdraw"
      ],
      "function_to_selector": {
        "Command": 0,
        "GetHoneyFromJar": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_062",
      "transformed_id": "rs_mg_dis_nc_ds_062",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n    uint constant public minEligibility = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function redeem()\n    public\n    payable\n    {\n        if(msg.value>=minEligibility)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    // Unified dispatcher - merged from: Command, redeem, withdraw\n    // Selectors: Command=0, redeem=1, withdraw=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: redeem()\n        else if (_selector == 1) {\n            if(msg.value>=minEligibility)\n            {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "redeem",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, redeem, withdraw"
      ],
      "function_to_selector": {
        "Command": 0,
        "redeem": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_063",
      "transformed_id": "rs_mg_dis_nc_ds_063",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    // Unified dispatcher - merged from: Command, GetFreebie, withdraw\n    // Selectors: Command=0, GetFreebie=1, withdraw=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: GetFreebie()\n        else if (_selector == 1) {\n            if(msg.value>1 ether)\n            {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "GetFreebie",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, GetFreebie, withdraw"
      ],
      "function_to_selector": {
        "Command": 0,
        "GetFreebie": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_064",
      "transformed_id": "rs_mg_dis_nc_ds_064",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetPie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    // Unified dispatcher - merged from: Command, GetPie, withdraw\n    // Selectors: Command=0, GetPie=1, withdraw=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: GetPie()\n        else if (_selector == 1) {\n            if(msg.value>1 ether)\n            {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "GetPie",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, GetPie, withdraw"
      ],
      "function_to_selector": {
        "Command": 0,
        "GetPie": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_065",
      "transformed_id": "rs_mg_dis_nc_ds_065",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_066",
      "transformed_id": "rs_mg_dis_nc_ds_066",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address newOwner;\n    address owner = msg.sender;\n\n    function changeOwner(address addr)\n    public\n    onlyOwner\n    {\n        newOwner = addr;\n    }\n\n    function confirmOwner()\n    public\n    {\n        if(msg.sender==newOwner)\n        {\n            owner=newOwner;\n        }\n    }\n\n    modifier onlyOwner\n    {\n        if(owner == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address owner = msg.sender;\n    function WithdrawToken(address token, uint256 amount,address to)\n    public\n    onlyOwner\n    {\n        token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function initTokenBank()\n    public\n    {\n        owner = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>=MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _to,address _token,uint _amount)\n    public\n    onlyOwner\n    {\n        if(Holders[_to]>0)\n        {\n            Holders[_to]=0;\n            WithdrawToken(_token,_amount,_to);\n        }\n    }\n\n    function WithdrawToHolder(address _addr, uint _wei)\n    public\n    onlyOwner\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_addr]>=_wei)\n            {\n                _addr.call.value(_wei);\n                Holders[_addr]-=_wei;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n\n    // Unified dispatcher - merged from: WithdrawToken, changeOwner, confirmOwner\n    // Selectors: WithdrawToken=0, changeOwner=1, confirmOwner=2\n    function execute(uint8 _selector, address addr, address to, address token, uint256 amount) public {\n        // Original: WithdrawToken()\n        if (_selector == 0) {\n            token.call(bytes4(sha3(\"transfer(address,uint256)\")),to,amount);\n        }\n        // Original: changeOwner()\n        else if (_selector == 1) {\n            newOwner = addr;\n        }\n        // Original: confirmOwner()\n        else if (_selector == 2) {\n            if(msg.sender==newOwner)\n            {\n            owner=newOwner;\n            }\n        }\n    }\n}",
      "merged_functions": [
        "WithdrawToken",
        "changeOwner",
        "confirmOwner"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: WithdrawToken, changeOwner, confirmOwner"
      ],
      "function_to_selector": {
        "WithdrawToken": 0,
        "changeOwner": 1,
        "confirmOwner": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_067",
      "transformed_id": "rs_mg_dis_nc_ds_067",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_068",
      "transformed_id": "rs_mg_dis_nc_ds_068",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract AirDropContract{\n\n    function AirDropContract() public {\n    }\n\n    modifier validAddress( address addr ) {\n        require(addr != address(0x0));\n        require(addr != address(this));\n        _;\n    }\n\n    function transfer(address contract_address,address[] tos,uint[] vs)\n        public\n        validAddress(contract_address)\n        returns (bool){\n\n        require(tos.length > 0);\n        require(vs.length > 0);\n        require(tos.length == vs.length);\n        bytes4 id = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n        for(uint i = 0 ; i < tos.length; i++){\n            contract_address.call(id, msg.sender, tos[i], vs[i]);\n        }\n        return true;\n    }\n\n    // Unified dispatcher - merged from: transfer, AirDropContract\n    // Selectors: transfer=0, AirDropContract=1\n    function execute(uint8 _selector, address contract_address, address[] tos, uint[] vs) public {\n        // Original: transfer()\n        if (_selector == 0) {\n            require(tos.length > 0);\n            require(vs.length > 0);\n            require(tos.length == vs.length);\n            bytes4 id = bytes4(keccak256(\"transferFrom(address,address,uint256)\"));\n            for(uint i = 0 ; i < tos.length; i++){\n            contract_address.call(id, msg.sender, tos[i], vs[i]);\n            }\n            return true;\n        }\n        // Original: AirDropContract()\n        else if (_selector == 1) {\n        }\n    }\n}",
      "merged_functions": [
        "transfer",
        "AirDropContract"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: transfer, AirDropContract"
      ],
      "function_to_selector": {
        "transfer": 0,
        "AirDropContract": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_069",
      "transformed_id": "rs_mg_dis_nc_ds_069",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_070",
      "transformed_id": "rs_mg_dis_nc_ds_070",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; }\n    function proxy(address target, bytes data) public payable {\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract DepositProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n\n    function deposit() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n\n    // Unified dispatcher - merged from: proxy, transferOwner, Vault\n    // Selectors: proxy=0, transferOwner=1, Vault=2\n    function execute(uint8 _selector, address _owner, address target, bytes data) public payable {\n        // Original: proxy()\n        if (_selector == 0) {\n            target.call.value(msg.value)(data);\n        }\n        // Original: transferOwner()\n        else if (_selector == 1) {\n            Owner = _owner;\n        }\n        // Original: Vault()\n        else if (_selector == 2) {\n            if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n            }\n        }\n    }\n}",
      "merged_functions": [
        "proxy",
        "transferOwner",
        "Vault"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: proxy, transferOwner, Vault"
      ],
      "function_to_selector": {
        "proxy": 0,
        "transferOwner": 1,
        "Vault": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_071",
      "transformed_id": "rs_mg_dis_nc_ds_071",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public owner = msg.sender;\n    uint public depositsCount;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function() public payable {\n        depositsCount++;\n    }\n\n    function withdrawAll() public onlyOwner {\n        withdraw(address(this).balance);\n    }\n\n    function withdraw(uint _value) public onlyOwner {\n        msg.sender.transfer(_value);\n    }\n\n    function sendMoney(address _target, uint _value) public onlyOwner {\n        _target.call.value(_value)();\n    }\n\n    // Unified dispatcher - merged from: sendMoney, withdrawAll, withdraw\n    // Selectors: sendMoney=0, withdrawAll=1, withdraw=2\n    function execute(uint8 _selector, address _target, uint _value) public {\n        // Original: sendMoney()\n        if (_selector == 0) {\n            _target.call.value(_value)();\n        }\n        // Original: withdrawAll()\n        else if (_selector == 1) {\n            withdraw(address(this).balance);\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            msg.sender.transfer(_value);\n        }\n    }\n}",
      "merged_functions": [
        "sendMoney",
        "withdrawAll",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: sendMoney, withdrawAll, withdraw"
      ],
      "function_to_selector": {
        "sendMoney": 0,
        "withdrawAll": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_072",
      "transformed_id": "rs_mg_dis_nc_ds_072",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_073",
      "transformed_id": "rs_mg_dis_nc_ds_073",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; }\n    function proxy(address target, bytes data) public payable {\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n\n    function deposit() public payable {\n        if (msg.value > 0.25 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n\n    // Unified dispatcher - merged from: proxy, transferOwner, Vault\n    // Selectors: proxy=0, transferOwner=1, Vault=2\n    function execute(uint8 _selector, address _owner, address target, bytes data) public payable {\n        // Original: proxy()\n        if (_selector == 0) {\n            target.call.value(msg.value)(data);\n        }\n        // Original: transferOwner()\n        else if (_selector == 1) {\n            Owner = _owner;\n        }\n        // Original: Vault()\n        else if (_selector == 2) {\n            if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n            }\n        }\n    }\n}",
      "merged_functions": [
        "proxy",
        "transferOwner",
        "Vault"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: proxy, transferOwner, Vault"
      ],
      "function_to_selector": {
        "proxy": 0,
        "transferOwner": 1,
        "Vault": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_074",
      "transformed_id": "rs_mg_dis_nc_ds_074",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier onlyOwner { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function transferOwner(address _owner) public onlyOwner { Owner = _owner; }\n    function proxy(address target, bytes data) public payable {\n        target.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n        }\n    }\n\n    function deposit() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function withdraw(uint256 amount) public onlyOwner {\n        if (amount>0 && Deposits[msg.sender]>=amount) {\n            msg.sender.transfer(amount);\n        }\n    }\n\n    // Unified dispatcher - merged from: proxy, transferOwner, Vault\n    // Selectors: proxy=0, transferOwner=1, Vault=2\n    function execute(uint8 _selector, address _owner, address target, bytes data) public payable {\n        // Original: proxy()\n        if (_selector == 0) {\n            target.call.value(msg.value)(data);\n        }\n        // Original: transferOwner()\n        else if (_selector == 1) {\n            Owner = _owner;\n        }\n        // Original: Vault()\n        else if (_selector == 2) {\n            if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            deposit();\n            }\n        }\n    }\n}",
      "merged_functions": [
        "proxy",
        "transferOwner",
        "Vault"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: proxy, transferOwner, Vault"
      ],
      "function_to_selector": {
        "proxy": 0,
        "transferOwner": 1,
        "Vault": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_075",
      "transformed_id": "rs_mg_dis_nc_ds_075",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function Get()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    // Unified dispatcher - merged from: Command, Get, withdraw\n    // Selectors: Command=0, Get=1, withdraw=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: Get()\n        else if (_selector == 1) {\n            if(msg.value>1 ether)\n            {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "Get",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, Get, withdraw"
      ],
      "function_to_selector": {
        "Command": 0,
        "Get": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_076",
      "transformed_id": "rs_mg_dis_nc_ds_076",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_077",
      "transformed_id": "rs_mg_dis_nc_ds_077",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract FreeEth\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    // Unified dispatcher - merged from: Command, GetFreebie, withdraw\n    // Selectors: Command=0, GetFreebie=1, withdraw=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: GetFreebie()\n        else if (_selector == 1) {\n            if(msg.value>1 ether)\n            {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "GetFreebie",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, GetFreebie, withdraw"
      ],
      "function_to_selector": {
        "Command": 0,
        "GetFreebie": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_078",
      "transformed_id": "rs_mg_dis_nc_ds_078",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Honey\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    // Unified dispatcher - merged from: Command, GetFreebie, withdraw\n    // Selectors: Command=0, GetFreebie=1, withdraw=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: GetFreebie()\n        else if (_selector == 1) {\n            if(msg.value>1 ether)\n            {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "GetFreebie",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, GetFreebie, withdraw"
      ],
      "function_to_selector": {
        "Command": 0,
        "GetFreebie": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_079",
      "transformed_id": "rs_mg_dis_nc_ds_079",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Freebie\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    // Unified dispatcher - merged from: Command, GetFreebie, withdraw\n    // Selectors: Command=0, GetFreebie=1, withdraw=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: GetFreebie()\n        else if (_selector == 1) {\n            if(msg.value>1 ether)\n            {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "GetFreebie",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, GetFreebie, withdraw"
      ],
      "function_to_selector": {
        "Command": 0,
        "GetFreebie": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_080",
      "transformed_id": "rs_mg_dis_nc_ds_080",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_081",
      "transformed_id": "rs_mg_dis_nc_ds_081",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_082",
      "transformed_id": "rs_mg_dis_nc_ds_082",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_083",
      "transformed_id": "rs_mg_dis_nc_ds_083",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function withdraw()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address adr,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        adr.call.value(msg.value)(data);\n    }\n\n    // Unified dispatcher - merged from: Command, GetFreebie, withdraw\n    // Selectors: Command=0, GetFreebie=1, withdraw=2\n    function execute(uint8 _selector, address adr, bytes data) public payable {\n        // Original: Command()\n        if (_selector == 0) {\n            require(msg.sender == Owner);\n            adr.call.value(msg.value)(data);\n        }\n        // Original: GetFreebie()\n        else if (_selector == 1) {\n            if(msg.value>1 ether)\n            {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n            require(msg.sender == Owner);\n            Owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Command",
        "GetFreebie",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Command, GetFreebie, withdraw"
      ],
      "function_to_selector": {
        "Command": 0,
        "GetFreebie": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_084",
      "transformed_id": "rs_mg_dis_nc_ds_084",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_085",
      "transformed_id": "rs_mg_dis_nc_ds_085",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\n contract Lotto {\n\n     bool public payedOut = false;\n     address public winner;\n     uint public winAmount;\n\n\n     function sendToWinner() public {\n         require(!payedOut);\n         winner.send(winAmount);\n         payedOut = true;\n     }\n\n     function withdrawLeftOver() public {\n         require(payedOut);\n         msg.sender.send(this.balance);\n     }\n \n    // Unified dispatcher - merged from: sendToWinner, withdrawLeftOver\n    // Selectors: sendToWinner=0, withdrawLeftOver=1\n    function execute(uint8 _selector) public {\n        // Original: sendToWinner()\n        if (_selector == 0) {\n            require(!payedOut);\n            winner.send(winAmount);\n            payedOut = true;\n        }\n        // Original: withdrawLeftOver()\n        else if (_selector == 1) {\n            require(payedOut);\n            msg.sender.send(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "sendToWinner",
        "withdrawLeftOver"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: sendToWinner, withdrawLeftOver"
      ],
      "function_to_selector": {
        "sendToWinner": 0,
        "withdrawLeftOver": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_086",
      "transformed_id": "rs_mg_dis_nc_ds_086",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_087",
      "transformed_id": "rs_mg_dis_nc_ds_087",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function callchecked(address callee) public {\n    require(callee.call());\n  }\n\n  function callnotchecked(address callee) public {\n    callee.call();\n  }\n\n    // Unified dispatcher - merged from: callnotchecked, callchecked\n    // Selectors: callnotchecked=0, callchecked=1\n    function execute(uint8 _selector, address callee) public {\n        // Original: callnotchecked()\n        if (_selector == 0) {\n            callee.call();\n        }\n        // Original: callchecked()\n        else if (_selector == 1) {\n            require(callee.call());\n        }\n    }\n}",
      "merged_functions": [
        "callnotchecked",
        "callchecked"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: callnotchecked, callchecked"
      ],
      "function_to_selector": {
        "callnotchecked": 0,
        "callchecked": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_113",
      "transformed_id": "rs_mg_dis_nc_ds_113",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_ds_114",
      "transformed_id": "rs_mg_dis_nc_ds_114",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_ds_115",
      "transformed_id": "rs_mg_dis_nc_ds_115",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_116",
      "transformed_id": "rs_mg_dis_nc_ds_116",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n\n    function IamMissing()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n\n    // Unified dispatcher - merged from: IamMissing, withdraw\n    // Selectors: IamMissing=0, withdraw=1\n    function execute(uint8 _selector) public {\n        // Original: IamMissing()\n        if (_selector == 0) {\n            owner = msg.sender;\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "IamMissing",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: IamMissing, withdraw"
      ],
      "function_to_selector": {
        "IamMissing": 0,
        "withdraw": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_117",
      "transformed_id": "rs_mg_dis_nc_ds_117",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_118",
      "transformed_id": "rs_mg_dis_nc_ds_118",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_119",
      "transformed_id": "rs_mg_dis_nc_ds_119",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_120",
      "transformed_id": "rs_mg_dis_nc_ds_120",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract CrowdFundBasic {\n  address[] private refundAddresses;\n  mapping(address => uint) public refundAmount;\n\n  function refundAll() public {\n    for(uint i; i < refundAddresses.length; i++) {\n      require(refundAddresses[i].transfer(refundAmount[refundAddresses[i]]));\n    }\n  }\n}\n\ncontract CrowdFundPull {\n  address[] private refundAddresses;\n  mapping(address => uint) public refundAmount;\n\n  function withdraw() external {\n    uint refund = refundAmount[msg.sender];\n    refundAmount[msg.sender] = 0;\n    msg.sender.transfer(refund);\n  }\n}\n\ncontract CrowdFundBatched {\n  address[] private refundAddresses;\n  mapping(address => uint) public refundAmount;\n  uint256 nextIdx;\n\n  function refundBatched() public {\n    uint256 i = nextIdx;\n    while(i < refundAddresses.length && msg.gas > 200000) {\n      refundAddresses[i].transfer(refundAmount[i]);\n      i++;\n    }\n    nextIdx = i;\n  }\n\n    // Unified dispatcher - merged from: refundAll, withdraw, refundBatched\n    // Selectors: refundAll=0, withdraw=1, refundBatched=2\n    function execute(uint8 _selector) public {\n        // Original: refundAll()\n        if (_selector == 0) {\n            for(uint i; i < refundAddresses.length; i++) {\n            require(refundAddresses[i].transfer(refundAmount[refundAddresses[i]]));\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            uint refund = refundAmount[msg.sender];\n            refundAmount[msg.sender] = 0;\n            msg.sender.transfer(refund);\n        }\n        // Original: refundBatched()\n        else if (_selector == 2) {\n            uint256 i = nextIdx;\n            while(i < refundAddresses.length && msg.gas > 200000) {\n            refundAddresses[i].transfer(refundAmount[i]);\n            i++;\n            }\n            nextIdx = i;\n        }\n    }\n}",
      "merged_functions": [
        "refundAll",
        "withdraw",
        "refundBatched"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: refundAll, withdraw, refundBatched"
      ],
      "function_to_selector": {
        "refundAll": 0,
        "withdraw": 1,
        "refundBatched": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_121",
      "transformed_id": "rs_mg_dis_nc_ds_121",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address currentFrontrunner;\n  uint currentBid;\n\n  function bid() payable {\n    require(msg.value > currentBid);\n\n\n    if (currentFrontrunner != 0) {\n\n      require(currentFrontrunner.send(currentBid));\n    }\n\n    currentFrontrunner = msg.sender;\n    currentBid         = msg.value;\n  }\n}\n\ncontract AuctionV2 {\n  address currentFrontrunner;\n  uint    currentBid;\n\n  mapping(address => uint) refunds;\n\n\n  function bid() payable external {\n    require(msg.value > currentBid);\n\n    if (currentFrontrunner != 0) {\n      refunds[currentFrontrunner] += currentBid;\n    }\n\n    currentFrontrunner = msg.sender;\n    currentBid         = msg.value;\n  }\n\n\n  function withdraw() external {\n\n    uint refund = refunds[msg.sender];\n    refunds[msg.sender] = 0;\n\n    msg.sender.send(refund);\n  }\n\n    // Unified dispatcher - merged from: bid, withdraw\n    // Selectors: bid=0, withdraw=1\n    function execute(uint8 _selector) public payable {\n        // Original: bid()\n        if (_selector == 0) {\n            require(msg.value > currentBid);\n            if (currentFrontrunner != 0) {\n            refunds[currentFrontrunner] += currentBid;\n            }\n            currentFrontrunner = msg.sender;\n            currentBid         = msg.value;\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            uint refund = refunds[msg.sender];\n            refunds[msg.sender] = 0;\n            msg.sender.send(refund);\n        }\n    }\n}",
      "merged_functions": [
        "bid",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: bid, withdraw"
      ],
      "function_to_selector": {
        "bid": 0,
        "withdraw": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_122",
      "transformed_id": "rs_mg_dis_nc_ds_122",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\ncontract WalletEvents {\n\n\n  event Confirmation(address owner, bytes32 operation);\n  event Revoke(address owner, bytes32 operation);\n\n\n  event OwnerChanged(address oldOwner, address newOwner);\n  event OwnerAdded(address newOwner);\n  event OwnerRemoved(address oldOwner);\n\n\n  event RequirementChanged(uint newRequirement);\n\n\n  event Deposit(address _from, uint value);\n\n  event SingleTransact(address owner, uint value, address to, bytes data, address created);\n\n  event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data, address created);\n\n  event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n}\n\ncontract WalletAbi {\n\n  function revoke(bytes32 _operation) external;\n\n\n  function changeOwner(address _from, address _to) external;\n\n  function addOwner(address _owner) external;\n\n  function removeOwner(address _owner) external;\n\n  function changeRequirement(uint _newRequired) external;\n\n  function isOwner(address _addr) constant returns (bool);\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool);\n\n\n  function setDailyLimit(uint _newLimit) external;\n\n  function execute(address _to, uint _value, bytes _data) external returns (bytes32 o_hash);\n  function confirm(bytes32 _h) returns (bool o_success);\n}\n\ncontract WalletLibrary is WalletEvents {\n\n\n  struct PendingState {\n    uint yetNeeded;\n    uint ownersDone;\n    uint index;\n  }\n\n\n  struct Transaction {\n    address to;\n    uint value;\n    bytes data;\n  }\n\n\n  modifier onlyowner {\n    if (isOwner(msg.sender))\n      _;\n  }\n\n\n  modifier onlymanyowners(bytes32 _operation) {\n    if (confirmAndCheck(_operation))\n      _;\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n\n  function initMultiowned(address[] _owners, uint _required) {\n    m_numOwners = _owners.length + 1;\n    m_owners[1] = uint(msg.sender);\n    m_ownerIndex[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _owners.length; ++i)\n    {\n      m_owners[2 + i] = uint(_owners[i]);\n      m_ownerIndex[uint(_owners[i])] = 2 + i;\n    }\n    m_required = _required;\n  }\n\n\n  function revoke(bytes32 _operation) external {\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n\n    if (ownerIndex == 0) return;\n    uint ownerIndexBit = 2**ownerIndex;\n    var pending = m_pending[_operation];\n    if (pending.ownersDone & ownerIndexBit > 0) {\n      pending.yetNeeded++;\n      pending.ownersDone -= ownerIndexBit;\n      Revoke(msg.sender, _operation);\n    }\n  }\n\n\n  function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_to)) return;\n    uint ownerIndex = m_ownerIndex[uint(_from)];\n    if (ownerIndex == 0) return;\n\n    clearPending();\n    m_owners[ownerIndex] = uint(_to);\n    m_ownerIndex[uint(_from)] = 0;\n    m_ownerIndex[uint(_to)] = ownerIndex;\n    OwnerChanged(_from, _to);\n  }\n\n  function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    if (isOwner(_owner)) return;\n\n    clearPending();\n    if (m_numOwners >= c_maxOwners)\n      reorganizeOwners();\n    if (m_numOwners >= c_maxOwners)\n      return;\n    m_numOwners++;\n    m_owners[m_numOwners] = uint(_owner);\n    m_ownerIndex[uint(_owner)] = m_numOwners;\n    OwnerAdded(_owner);\n  }\n\n  function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n    if (ownerIndex == 0) return;\n    if (m_required > m_numOwners - 1) return;\n\n    m_owners[ownerIndex] = 0;\n    m_ownerIndex[uint(_owner)] = 0;\n    clearPending();\n    reorganizeOwners();\n    OwnerRemoved(_owner);\n  }\n\n  function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\n    if (_newRequired > m_numOwners) return;\n    m_required = _newRequired;\n    clearPending();\n    RequirementChanged(_newRequired);\n  }\n\n\n  function getOwner(uint ownerIndex) external constant returns (address) {\n    return address(m_owners[ownerIndex + 1]);\n  }\n\n  function isOwner(address _addr) constant returns (bool) {\n    return m_ownerIndex[uint(_addr)] > 0;\n  }\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n    var pending = m_pending[_operation];\n    uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n\n    if (ownerIndex == 0) return false;\n\n\n    uint ownerIndexBit = 2**ownerIndex;\n    return !(pending.ownersDone & ownerIndexBit == 0);\n  }\n\n\n  function initDaylimit(uint _limit) {\n    m_dailyLimit = _limit;\n    m_lastDay = today();\n  }\n\n  function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\n    m_dailyLimit = _newLimit;\n  }\n\n  function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\n    m_spentToday = 0;\n  }\n\n\n  function initWallet(address[] _owners, uint _required, uint _daylimit) {\n    initDaylimit(_daylimit);\n    initMultiowned(_owners, _required);\n  }\n\n\n  function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n    suicide(_to);\n  }\n\n\n  function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 o_hash) {\n\n    if ((_data.length == 0 && underLimit(_value)) || m_required == 1) {\n\n      address created;\n      if (_to == 0) {\n        created = create(_value, _data);\n      } else {\n        if (!_to.call.value(_value)(_data))\n          throw;\n      }\n      SingleTransact(msg.sender, _value, _to, _data, created);\n    } else {\n\n      o_hash = sha3(msg.data, block.number);\n\n      if (m_txs[o_hash].to == 0 && m_txs[o_hash].value == 0 && m_txs[o_hash].data.length == 0) {\n        m_txs[o_hash].to = _to;\n        m_txs[o_hash].value = _value;\n        m_txs[o_hash].data = _data;\n      }\n      if (!confirm(o_hash)) {\n        ConfirmationNeeded(o_hash, msg.sender, _value, _to, _data);\n      }\n    }\n  }\n\n  function create(uint _value, bytes _code) internal returns (address o_addr) {\n    assembly {\n      o_addr := create(_value, add(_code, 0x20), mload(_code))\n      jumpi(invalidJumpLabel, iszero(extcodesize(o_addr)))\n    }\n  }\n\n\n  function confirm(bytes32 _h) onlymanyowners(_h) returns (bool o_success) {\n    if (m_txs[_h].to != 0 || m_txs[_h].value != 0 || m_txs[_h].data.length != 0) {\n      address created;\n      if (m_txs[_h].to == 0) {\n        created = create(m_txs[_h].value, m_txs[_h].data);\n      } else {\n        if (!m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data, created);\n      delete m_txs[_h];\n      return true;\n    }\n  }\n\n\n  function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n\n    uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n\n    if (ownerIndex == 0) return;\n\n    var pending = m_pending[_operation];\n\n    if (pending.yetNeeded == 0) {\n\n      pending.yetNeeded = m_required;\n\n      pending.ownersDone = 0;\n      pending.index = m_pendingIndex.length++;\n      m_pendingIndex[pending.index] = _operation;\n    }\n\n    uint ownerIndexBit = 2**ownerIndex;\n\n    if (pending.ownersDone & ownerIndexBit == 0) {\n      Confirmation(msg.sender, _operation);\n\n      if (pending.yetNeeded <= 1) {\n\n        delete m_pendingIndex[m_pending[_operation].index];\n        delete m_pending[_operation];\n        return true;\n      }\n      else\n      {\n\n        pending.yetNeeded--;\n        pending.ownersDone |= ownerIndexBit;\n      }\n    }\n  }\n\n  function reorganizeOwners() private {\n    uint free = 1;\n    while (free < m_numOwners)\n    {\n      while (free < m_numOwners && m_owners[free] != 0) free++;\n      while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n      if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n      {\n        m_owners[free] = m_owners[m_numOwners];\n        m_ownerIndex[m_owners[free]] = free;\n        m_owners[m_numOwners] = 0;\n      }\n    }\n  }\n\n\n  function underLimit(uint _value) internal onlyowner returns (bool) {\n\n    if (today() > m_lastDay) {\n      m_spentToday = 0;\n      m_lastDay = today();\n    }\n\n\n    if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n      m_spentToday += _value;\n      return true;\n    }\n    return false;\n  }\n\n\n  function today() private constant returns (uint) { return now / 1 days; }\n\n  function clearPending() internal {\n    uint length = m_pendingIndex.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete m_txs[m_pendingIndex[i]];\n\n      if (m_pendingIndex[i] != 0)\n        delete m_pending[m_pendingIndex[i]];\n    }\n\n    delete m_pendingIndex;\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public m_required;\n\n  uint public m_numOwners;\n\n  uint public m_dailyLimit;\n  uint public m_spentToday;\n  uint public m_lastDay;\n\n\n  uint[256] m_owners;\n\n  uint constant c_maxOwners = 250;\n\n  mapping(uint => uint) m_ownerIndex;\n\n  mapping(bytes32 => PendingState) m_pending;\n  bytes32[] m_pendingIndex;\n\n\n  mapping (bytes32 => Transaction) m_txs;\n}\n\ncontract Wallet is WalletEvents {\n\n\n  function Wallet(address[] _owners, uint _required, uint _daylimit) {\n\n    bytes4 sig = bytes4(sha3(\"initWallet(address[],uint256,uint256)\"));\n    address target = _walletLibrary;\n\n\n    uint argarraysize = (2 + _owners.length);\n    uint argsize = (2 + argarraysize) * 32;\n\n    assembly {\n\n      mstore(0x0, sig)\n\n\n      codecopy(0x4,  sub(codesize, argsize), argsize)\n\n      delegatecall(sub(gas, 10000), target, 0x0, add(argsize, 0x4), 0x0, 0x0)\n    }\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n\n  function getOwner(uint ownerIndex) constant returns (address) {\n    return address(m_owners[ownerIndex + 1]);\n  }\n\n\n  function hasConfirmed(bytes32 _operation, address _owner) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function isOwner(address _addr) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public m_required;\n\n  uint public m_numOwners;\n\n  uint public m_dailyLimit;\n  uint public m_spentToday;\n  uint public m_lastDay;\n\n\n  uint[256] m_owners;\n\n    // Unified dispatcher - merged from: revoke\n    // Selectors: revoke=0\n    function execute(uint8 _selector, bytes32 _operation) public {\n        // Original: revoke()\n        if (_selector == 0) {\n            uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n            if (ownerIndex == 0) return;\n            uint ownerIndexBit = 2**ownerIndex;\n            var pending = m_pending[_operation];\n            if (pending.ownersDone & ownerIndexBit > 0) {\n            pending.yetNeeded++;\n            pending.ownersDone -= ownerIndexBit;\n            Revoke(msg.sender, _operation);\n            }\n        }\n    }\n}",
      "merged_functions": [
        "revoke"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: revoke"
      ],
      "function_to_selector": {
        "revoke": 0
      },
      "error": null
    },
    {
      "original_id": "nc_ds_123",
      "transformed_id": "rs_mg_dis_nc_ds_123",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract owned {\n    address public owner;\n\n    function owned() public {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function transferOwnership(address newOwner) onlyOwner public {\n        owner = newOwner;\n    }\n}\n\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\n\ncontract TokenERC20 {\n\n    string public name;\n    string public symbol;\n    uint8 public decimals = 18;\n\n    uint256 public totalSupply;\n\n\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function TokenERC20(\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        name = tokenName;\n        symbol = tokenSymbol;\n    }\n\n    function _transfer(address _from, address _to, uint _value) internal {\n\n        require(_to != 0x0);\n\n        require(balanceOf[_from] >= _value);\n\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n\n        balanceOf[_from] -= _value;\n\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        _transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n}\n\n\ncontract MyAdvancedToken is owned, TokenERC20 {\n\n    mapping (address => bool) public frozenAccount;\n\n\n    event FrozenFunds(address target, bool frozen);\n\n\n    function MyAdvancedToken(\n        string tokenName,\n        string tokenSymbol\n    ) TokenERC20(tokenName, tokenSymbol) public {}\n\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        require (_to != 0x0);\n        require (balanceOf[_from] >= _value);\n        require (balanceOf[_to] + _value >= balanceOf[_to]);\n        require(!frozenAccount[_from]);\n        require(!frozenAccount[_to]);\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n    }\n\n\n    function buy() payable public {\n        uint amount = msg.value;\n\tbalanceOf[msg.sender] += amount;\n        totalSupply += amount;\n        _transfer(address(0x0), msg.sender, amount);\n    }\n\n\n    function migrate_and_destroy() onlyOwner {\n\tassert(this.balance == totalSupply);\n\tsuicide(owner);\n    }\n\n    // Unified dispatcher - merged from: owned, transferOwnership\n    // Selectors: owned=0, transferOwnership=1\n    function execute(uint8 _selector, address newOwner) public {\n        // Original: owned()\n        if (_selector == 0) {\n            owner = msg.sender;\n        }\n        // Original: transferOwnership()\n        else if (_selector == 1) {\n            owner = newOwner;\n        }\n    }\n}",
      "merged_functions": [
        "owned",
        "transferOwnership"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: owned, transferOwnership"
      ],
      "function_to_selector": {
        "owned": 0,
        "transferOwnership": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_124",
      "transformed_id": "rs_mg_dis_nc_ds_124",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_125",
      "transformed_id": "rs_mg_dis_nc_ds_125",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n\n\n    function IamMissing()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n\n    // Unified dispatcher - merged from: IamMissing, withdraw\n    // Selectors: IamMissing=0, withdraw=1\n    function execute(uint8 _selector) public {\n        // Original: IamMissing()\n        if (_selector == 0) {\n            owner = msg.sender;\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "IamMissing",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: IamMissing, withdraw"
      ],
      "function_to_selector": {
        "IamMissing": 0,
        "withdraw": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_126",
      "transformed_id": "rs_mg_dis_nc_ds_126",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n    function missing()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n\n    // Unified dispatcher - merged from: missing, withdraw\n    // Selectors: missing=0, withdraw=1\n    function execute(uint8 _selector) public {\n        // Original: missing()\n        if (_selector == 0) {\n            owner = msg.sender;\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "missing",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: missing, withdraw"
      ],
      "function_to_selector": {
        "missing": 0,
        "withdraw": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_127",
      "transformed_id": "rs_mg_dis_nc_ds_127",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Missing{\n    address private owner;\n\n    modifier onlyowner {\n        require(msg.sender==owner);\n        _;\n    }\n    function Constructor()\n        public\n    {\n        owner = msg.sender;\n    }\n\n    function () payable {}\n\n    function withdraw()\n        public\n        onlyowner\n    {\n       owner.transfer(this.balance);\n    }\n\n\n    // Unified dispatcher - merged from: Constructor, withdraw\n    // Selectors: Constructor=0, withdraw=1\n    function execute(uint8 _selector) public {\n        // Original: Constructor()\n        if (_selector == 0) {\n            owner = msg.sender;\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            owner.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Constructor",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: Constructor, withdraw"
      ],
      "function_to_selector": {
        "Constructor": 0,
        "withdraw": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_128",
      "transformed_id": "rs_mg_dis_nc_ds_128",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract MultiOwnable {\n  address public root;\n  mapping (address => address) public owners;\n\n  constructor() public {\n    root = msg.sender;\n    owners[root] = root;\n  }\n\n  modifier onlyOwner() {\n    require(owners[msg.sender] != 0);\n    _;\n  }\n\n  function newOwner(address _owner) external returns (bool) {\n    require(_owner != 0);\n    owners[_owner] = msg.sender;\n    return true;\n  }\n\n  function deleteOwner(address _owner) onlyOwner external returns (bool) {\n    require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));\n    owners[_owner] = 0;\n    return true;\n  }\n}\n\ncontract TestContract is MultiOwnable {\n\n  function withdrawAll() onlyOwner {\n    msg.sender.transfer(this.balance);\n  }\n\n  function() payable {\n  }\n\n\n    // Unified dispatcher - merged from: newOwner, deleteOwner\n    // Selectors: newOwner=0, deleteOwner=1\n    function execute(uint8 _selector, address _owner) public {\n        // Original: newOwner()\n        if (_selector == 0) {\n            require(_owner != 0);\n            owners[_owner] = msg.sender;\n            return true;\n        }\n        // Original: deleteOwner()\n        else if (_selector == 1) {\n            require(owners[_owner] == msg.sender || (owners[_owner] != 0 && msg.sender == root));\n            owners[_owner] = 0;\n            return true;\n        }\n    }\n}",
      "merged_functions": [
        "newOwner",
        "deleteOwner"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: newOwner, deleteOwner"
      ],
      "function_to_selector": {
        "newOwner": 0,
        "deleteOwner": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_129",
      "transformed_id": "rs_mg_dis_nc_ds_129",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_130",
      "transformed_id": "rs_mg_dis_nc_ds_130",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n contract OpenAccess{\n     address private owner;\n\n     modifier onlyowner {\n         require(msg.sender==owner);\n         _;\n     }\n\n     function OpenAccess()\n         public\n     {\n         owner = msg.sender;\n     }\n\n\n     function changeOwner(address _newOwner)\n         public\n     {\n        owner = _newOwner;\n     }\n\n \n    // Unified dispatcher - merged from: changeOwner, OpenAccess\n    // Selectors: changeOwner=0, OpenAccess=1\n    function execute(uint8 _selector, address _newOwner) public {\n        // Original: changeOwner()\n        if (_selector == 0) {\n            owner = _newOwner;\n        }\n        // Original: OpenAccess()\n        else if (_selector == 1) {\n            owner = msg.sender;\n        }\n    }\n}",
      "merged_functions": [
        "changeOwner",
        "OpenAccess"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: changeOwner, OpenAccess"
      ],
      "function_to_selector": {
        "changeOwner": 0,
        "OpenAccess": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_131",
      "transformed_id": "rs_mg_dis_nc_ds_131",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_132",
      "transformed_id": "rs_mg_dis_nc_ds_132",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_133",
      "transformed_id": "rs_mg_dis_nc_ds_133",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_134",
      "transformed_id": "rs_mg_dis_nc_ds_134",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_135",
      "transformed_id": "rs_mg_dis_nc_ds_135",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_136",
      "transformed_id": "rs_mg_dis_nc_ds_136",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_137",
      "transformed_id": "rs_mg_dis_nc_ds_137",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_138",
      "transformed_id": "rs_mg_dis_nc_ds_138",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_139",
      "transformed_id": "rs_mg_dis_nc_ds_139",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_140",
      "transformed_id": "rs_mg_dis_nc_ds_140",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_141",
      "transformed_id": "rs_mg_dis_nc_ds_141",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract SingleTxCounter {\n    uint public count = 1;\n\n    function addtostate(uint256 input) public {\n        count += input;\n    }\n\n    function multostate(uint256 input) public {\n        count *= input;\n    }\n\n    function underflowtostate(uint256 input) public {\n        count -= input;\n    }\n\n    function localcalc(uint256 input) public {\n        uint res = count + input;\n    }\n\n    function mullocalonly(uint256 input) public {\n        uint res = count * input;\n    }\n\n    function underflowlocalonly(uint256 input) public {\n       \tuint res = count - input;\n    }\n\n\n    // Unified dispatcher - merged from: addtostate, multostate, underflowtostate\n    // Selectors: addtostate=0, multostate=1, underflowtostate=2\n    function execute(uint8 _selector, uint256 input) public {\n        // Original: addtostate()\n        if (_selector == 0) {\n            count += input;\n        }\n        // Original: multostate()\n        else if (_selector == 1) {\n            count *= input;\n        }\n        // Original: underflowtostate()\n        else if (_selector == 2) {\n            count -= input;\n        }\n    }\n}",
      "merged_functions": [
        "addtostate",
        "multostate",
        "underflowtostate"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: addtostate, multostate, underflowtostate"
      ],
      "function_to_selector": {
        "addtostate": 0,
        "multostate": 1,
        "underflowtostate": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_142",
      "transformed_id": "rs_mg_dis_nc_ds_142",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\n contract TimeLock {\n\n     mapping(address => uint) public balances;\n     mapping(address => uint) public lockTime;\n\n     function deposit() public payable {\n         balances[msg.sender] += msg.value;\n         lockTime[msg.sender] = now + 1 weeks;\n     }\n\n     function increaseLockTime(uint _secondsToIncrease) public {\n         lockTime[msg.sender] += _secondsToIncrease;\n     }\n\n     function withdraw() public {\n         require(balances[msg.sender] > 0);\n         require(now > lockTime[msg.sender]);\n         uint transferValue = balances[msg.sender];\n         balances[msg.sender] = 0;\n         msg.sender.transfer(transferValue);\n     }\n \n    // Unified dispatcher - merged from: increaseLockTime, deposit, withdraw\n    // Selectors: increaseLockTime=0, deposit=1, withdraw=2\n    function execute(uint8 _selector, uint _secondsToIncrease) public payable {\n        // Original: increaseLockTime()\n        if (_selector == 0) {\n            lockTime[msg.sender] += _secondsToIncrease;\n        }\n        // Original: deposit()\n        else if (_selector == 1) {\n            balances[msg.sender] += msg.value;\n            lockTime[msg.sender] = now + 1 weeks;\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            require(balances[msg.sender] > 0);\n            require(now > lockTime[msg.sender]);\n            uint transferValue = balances[msg.sender];\n            balances[msg.sender] = 0;\n            msg.sender.transfer(transferValue);\n        }\n    }\n}",
      "merged_functions": [
        "increaseLockTime",
        "deposit",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: increaseLockTime, deposit, withdraw"
      ],
      "function_to_selector": {
        "increaseLockTime": 0,
        "deposit": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_143",
      "transformed_id": "rs_mg_dis_nc_ds_143",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) balances;\n   uint public totalSupply;\n\n   function Token(uint _initialSupply) {\n     balances[msg.sender] = totalSupply = _initialSupply;\n   }\n\n   function transfer(address _to, uint _value) public returns (bool) {\n     require(balances[msg.sender] - _value >= 0);\n     balances[msg.sender] -= _value;\n     balances[_to] += _value;\n     return true;\n   }\n\n   function balanceOf(address _owner) public constant returns (uint balance) {\n     return balances[_owner];\n   }\n \n    // Unified dispatcher - merged from: transfer, balanceOf\n    // Selectors: transfer=0, balanceOf=1\n    function execute(uint8 _selector, address _owner, address _to, uint _value) public {\n        // Original: transfer()\n        if (_selector == 0) {\n            require(balances[msg.sender] - _value >= 0);\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            return true;\n        }\n        // Original: balanceOf()\n        else if (_selector == 1) {\n            return balances[_owner];\n        }\n    }\n}",
      "merged_functions": [
        "transfer",
        "balanceOf"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: transfer, balanceOf"
      ],
      "function_to_selector": {
        "transfer": 0,
        "balanceOf": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_144",
      "transformed_id": "rs_mg_dis_nc_ds_144",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public balanceOf;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _player) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function buy(uint256 numTokens) public payable {\n        require(msg.value == numTokens * PRICE_PER_TOKEN);\n        balanceOf[msg.sender] += numTokens;\n    }\n\n    function sell(uint256 numTokens) public {\n        require(balanceOf[msg.sender] >= numTokens);\n\n        balanceOf[msg.sender] -= numTokens;\n        msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n    }\n\n    // Unified dispatcher - merged from: buy, TokenSaleChallenge, sell\n    // Selectors: buy=0, TokenSaleChallenge=1, sell=2\n    function execute(uint8 _selector, address _player, uint256 numTokens) public payable {\n        // Original: buy()\n        if (_selector == 0) {\n            require(msg.value == numTokens * PRICE_PER_TOKEN);\n            balanceOf[msg.sender] += numTokens;\n        }\n        // Original: TokenSaleChallenge()\n        else if (_selector == 1) {\n            require(msg.value == 1 ether);\n        }\n        // Original: sell()\n        else if (_selector == 2) {\n            require(balanceOf[msg.sender] >= numTokens);\n            balanceOf[msg.sender] -= numTokens;\n            msg.sender.transfer(numTokens * PRICE_PER_TOKEN);\n        }\n    }\n}",
      "merged_functions": [
        "buy",
        "TokenSaleChallenge",
        "sell"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: buy, TokenSaleChallenge, sell"
      ],
      "function_to_selector": {
        "buy": 0,
        "TokenSaleChallenge": 1,
        "sell": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_145",
      "transformed_id": "rs_mg_dis_nc_ds_145",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    event RaffleResult(\n        uint raffleId,\n        uint winningNumber,\n        address winningAddress,\n        address seed1,\n        address seed2,\n        uint seed3,\n        bytes32 randHash\n    );\n\n    event TicketPurchase(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint raffleId,\n        address contestant,\n        uint number\n    );\n\n\n    uint public constant prize = 2.5 ether;\n    uint public constant fee = 0.03 ether;\n    uint public constant totalTickets = 50;\n    uint public constant pricePerTicket = (prize + fee) / totalTickets;\n    address feeAddress;\n\n\n    bool public paused = false;\n    uint public raffleId = 1;\n    uint public blockNumber = block.number;\n    uint nextTicket = 0;\n    mapping (uint => Contestant) contestants;\n    uint[] gaps;\n\n\n    function Ethraffle_v4b() public {\n        feeAddress = msg.sender;\n    }\n\n\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n\n        if (nextTicket == totalTickets) {\n            chooseWinner();\n        }\n\n\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n        uint seed3 = block.difficulty;\n        bytes32 randHash = keccak256(seed1, seed2, seed3);\n\n        uint winningNumber = uint(randHash) % totalTickets;\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n\n\n        raffleId++;\n        nextTicket = 0;\n        blockNumber = block.number;\n\n\n        winningAddress.transfer(prize);\n        feeAddress.transfer(fee);\n    }\n\n\n    function getRefund() public {\n        uint refund = 0;\n        for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refund += pricePerTicket;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n\n    function endRaffle() public {\n        if (msg.sender == feeAddress) {\n            paused = true;\n\n            for (uint i = 0; i < totalTickets; i++) {\n                if (raffleId == contestants[i].raffleId) {\n                    TicketRefund(raffleId, contestants[i].addr, i);\n                    contestants[i].addr.transfer(pricePerTicket);\n                }\n            }\n\n            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\n            raffleId++;\n            nextTicket = 0;\n            blockNumber = block.number;\n            gaps.length = 0;\n        }\n    }\n\n    function togglePause() public {\n        if (msg.sender == feeAddress) {\n            paused = !paused;\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == feeAddress) {\n            selfdestruct(feeAddress);\n        }\n    }\n\n    // Unified dispatcher - merged from: Ethraffle_v4b, buyTickets, getRefund\n    // Selectors: Ethraffle_v4b=0, buyTickets=1, getRefund=2\n    function execute(uint8 _selector) public payable {\n        // Original: Ethraffle_v4b()\n        if (_selector == 0) {\n            feeAddress = msg.sender;\n        }\n        // Original: buyTickets()\n        else if (_selector == 1) {\n            if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n            }\n            uint moneySent = msg.value;\n            while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n            currTicket = gaps[gaps.length-1];\n            gaps.length--;\n            } else {\n            currTicket = nextTicket++;\n            }\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n            }\n            if (nextTicket == totalTickets) {\n            chooseWinner();\n            }\n            if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n            }\n        }\n        // Original: getRefund()\n        else if (_selector == 2) {\n            uint refund = 0;\n            for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n            refund += pricePerTicket;\n            contestants[i] = Contestant(address(0), 0);\n            gaps.push(i);\n            TicketRefund(raffleId, msg.sender, i);\n            }\n            }\n            if (refund > 0) {\n            msg.sender.transfer(refund);\n            }\n        }\n    }\n}",
      "merged_functions": [
        "Ethraffle_v4b",
        "buyTickets",
        "getRefund"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Ethraffle_v4b, buyTickets, getRefund"
      ],
      "function_to_selector": {
        "Ethraffle_v4b": 0,
        "buyTickets": 1,
        "getRefund": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_146",
      "transformed_id": "rs_mg_dis_nc_ds_146",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 answer;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n        answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n    }\n\n    function isComplete() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function guess(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n\n    // Unified dispatcher - merged from: GuessTheRandomNumberChallenge, guess\n    // Selectors: GuessTheRandomNumberChallenge=0, guess=1\n    function execute(uint8 _selector, uint8 n) public payable {\n        // Original: GuessTheRandomNumberChallenge()\n        if (_selector == 0) {\n            require(msg.value == 1 ether);\n            answer = uint8(keccak256(block.blockhash(block.number - 1), now));\n        }\n        // Original: guess()\n        else if (_selector == 1) {\n            require(msg.value == 1 ether);\n            if (n == answer) {\n            msg.sender.transfer(2 ether);\n            }\n        }\n    }\n}",
      "merged_functions": [
        "GuessTheRandomNumberChallenge",
        "guess"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: GuessTheRandomNumberChallenge, guess"
      ],
      "function_to_selector": {
        "GuessTheRandomNumberChallenge": 0,
        "guess": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_147",
      "transformed_id": "rs_mg_dis_nc_ds_147",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_148",
      "transformed_id": "rs_mg_dis_nc_ds_148",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n\ncontract PredictTheBlockHashChallenge {\n\n    struct guess{\n      uint block;\n      bytes32 guess;\n    }\n\n    mapping(address => guess) guesses;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function lockInGuess(bytes32 hash) public payable {\n        require(guesses[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        guesses[msg.sender].guess = hash;\n        guesses[msg.sender].block  = block.number + 1;\n    }\n\n    function settle() public {\n        require(block.number > guesses[msg.sender].block);\n        bytes32 answer = blockhash(guesses[msg.sender].block);\n\n        guesses[msg.sender].block = 0;\n        if (guesses[msg.sender].guess == answer) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n\n    // Unified dispatcher - merged from: settle, lockInGuess\n    // Selectors: settle=0, lockInGuess=1\n    function execute(uint8 _selector, bytes32 hash) public payable {\n        // Original: settle()\n        if (_selector == 0) {\n            require(block.number > guesses[msg.sender].block);\n            bytes32 answer = blockhash(guesses[msg.sender].block);\n            guesses[msg.sender].block = 0;\n            if (guesses[msg.sender].guess == answer) {\n            msg.sender.transfer(2 ether);\n            }\n        }\n        // Original: lockInGuess()\n        else if (_selector == 1) {\n            require(guesses[msg.sender].block == 0);\n            require(msg.value == 1 ether);\n            guesses[msg.sender].guess = hash;\n            guesses[msg.sender].block  = block.number + 1;\n        }\n    }\n}",
      "merged_functions": [
        "settle",
        "lockInGuess"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: settle, lockInGuess"
      ],
      "function_to_selector": {
        "settle": 0,
        "lockInGuess": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_149",
      "transformed_id": "rs_mg_dis_nc_ds_149",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_150",
      "transformed_id": "rs_mg_dis_nc_ds_150",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_151",
      "transformed_id": "rs_mg_dis_nc_ds_151",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract GasAuction {\n\n    address[] creditorAddresses;\n    bool win = false;\n\n    function emptyCreditors() public {\n        if(creditorAddresses.length>1500) {\n            creditorAddresses = new address[](0);\n            win = true;\n        }\n    }\n\n    function addCreditors() public returns (bool) {\n        for(uint i=0;i<350;i++) {\n          creditorAddresses.push(msg.sender);\n        }\n        return true;\n    }\n\n    function iWin() public view returns (bool) {\n        return win;\n    }\n\n    function numberCreditors() public view returns (uint) {\n        return creditorAddresses.length;\n    }\n\n    // Unified dispatcher - merged from: emptyCreditors, addCreditors\n    // Selectors: emptyCreditors=0, addCreditors=1\n    function execute(uint8 _selector) public {\n        // Original: emptyCreditors()\n        if (_selector == 0) {\n            if(creditorAddresses.length>1500) {\n            creditorAddresses = new address[](0);\n            win = true;\n            }\n        }\n        // Original: addCreditors()\n        else if (_selector == 1) {\n            for(uint i=0;i<350;i++) {\n            creditorAddresses.push(msg.sender);\n            }\n            return true;\n        }\n    }\n}",
      "merged_functions": [
        "emptyCreditors",
        "addCreditors"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: emptyCreditors, addCreditors"
      ],
      "function_to_selector": {
        "emptyCreditors": 0,
        "addCreditors": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_152",
      "transformed_id": "rs_mg_dis_nc_ds_152",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract NumberRegistry {\n\n    uint numElements = 0;\n    uint[] array;\n\n    function insertNnumbers(uint value,uint numbers) public {\n\n        for(uint i=0;i<numbers;i++) {\n            if(numElements == array.length) {\n                array.length += 1;\n            }\n            array[numElements++] = value;\n        }\n    }\n\n    function clear() public {\n        require(numElements>1500);\n        numElements = 0;\n    }\n\n    function clearDOS() public {\n\n\n        require(numElements>1500);\n        array = new uint[](0);\n        numElements = 0;\n    }\n\n    function getLengthArray() public view returns(uint) {\n        return numElements;\n    }\n\n    function getRealLengthArray() public view returns(uint) {\n        return array.length;\n    }\n\n    // Unified dispatcher - merged from: insertNnumbers, clear, clearDOS\n    // Selectors: insertNnumbers=0, clear=1, clearDOS=2\n    function execute(uint8 _selector, uint numbers, uint value) public {\n        // Original: insertNnumbers()\n        if (_selector == 0) {\n            for(uint i=0;i<numbers;i++) {\n            if(numElements == array.length) {\n            array.length += 1;\n            }\n            array[numElements++] = value;\n            }\n        }\n        // Original: clear()\n        else if (_selector == 1) {\n            require(numElements>1500);\n            numElements = 0;\n        }\n        // Original: clearDOS()\n        else if (_selector == 2) {\n            require(numElements>1500);\n            array = new uint[](0);\n            numElements = 0;\n        }\n    }\n}",
      "merged_functions": [
        "insertNnumbers",
        "clear",
        "clearDOS"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: insertNnumbers, clear, clearDOS"
      ],
      "function_to_selector": {
        "insertNnumbers": 0,
        "clear": 1,
        "clearDOS": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_153",
      "transformed_id": "rs_mg_dis_nc_ds_153",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_154",
      "transformed_id": "rs_mg_dis_nc_ds_154",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_155",
      "transformed_id": "rs_mg_dis_nc_ds_155",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_156",
      "transformed_id": "rs_mg_dis_nc_ds_156",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0);\n    uint256 c = a / b;\n\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\ncontract ERC20 {\n\n  event Transfer( address indexed from, address indexed to, uint256 value );\n  event Approval( address indexed owner, address indexed spender, uint256 value);\n  using SafeMath for *;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  constructor(uint totalSupply){\n    _balances[msg.sender] = totalSupply;\n  }\n\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  function allowance(address owner, address spender) public view returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  function transfer(address to, uint256 value) public returns (bool) {\n    require(value <= _balances[msg.sender]);\n    require(to != address(0));\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  function transferFrom(address from, address to, uint256 value) public returns (bool) {\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n\n    // Unified dispatcher - merged from: approve, transfer, transferFrom\n    // Selectors: approve=0, transfer=1, transferFrom=2\n    function execute(uint8 _selector, address from, address spender, address to, uint256 value) public {\n        // Original: approve()\n        if (_selector == 0) {\n            require(spender != address(0));\n            _allowed[msg.sender][spender] = value;\n            emit Approval(msg.sender, spender, value);\n            return true;\n        }\n        // Original: transfer()\n        else if (_selector == 1) {\n            require(value <= _balances[msg.sender]);\n            require(to != address(0));\n            _balances[msg.sender] = _balances[msg.sender].sub(value);\n            _balances[to] = _balances[to].add(value);\n            emit Transfer(msg.sender, to, value);\n            return true;\n        }\n        // Original: transferFrom()\n        else if (_selector == 2) {\n            require(value <= _balances[from]);\n            require(value <= _allowed[from][msg.sender]);\n            require(to != address(0));\n            _balances[from] = _balances[from].sub(value);\n            _balances[to] = _balances[to].add(value);\n            _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n            emit Transfer(from, to, value);\n            return true;\n        }\n    }\n}",
      "merged_functions": [
        "approve",
        "transfer",
        "transferFrom"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: approve, transfer, transferFrom"
      ],
      "function_to_selector": {
        "approve": 0,
        "transfer": 1,
        "transferFrom": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_157",
      "transformed_id": "rs_mg_dis_nc_ds_157",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_158",
      "transformed_id": "rs_mg_dis_nc_ds_158",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n    address public owner;\n    bool public claimed;\n    uint public reward;\n\n    function EthTxOrderDependenceMinimal() public {\n        owner = msg.sender;\n    }\n\n    function setReward() public payable {\n        require (!claimed);\n\n        require(msg.sender == owner);\n        owner.transfer(reward);\n        reward = msg.value;\n    }\n\n    function claimReward(uint256 submission) {\n        require (!claimed);\n        require(submission < 10);\n        msg.sender.transfer(reward);\n        claimed = true;\n    }\n\n    // Unified dispatcher - merged from: setReward, EthTxOrderDependenceMinimal\n    // Selectors: setReward=0, EthTxOrderDependenceMinimal=1\n    function execute(uint8 _selector) public payable {\n        // Original: setReward()\n        if (_selector == 0) {\n            require (!claimed);\n            require(msg.sender == owner);\n            owner.transfer(reward);\n            reward = msg.value;\n        }\n        // Original: EthTxOrderDependenceMinimal()\n        else if (_selector == 1) {\n            owner = msg.sender;\n        }\n    }\n}",
      "merged_functions": [
        "setReward",
        "EthTxOrderDependenceMinimal"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: setReward, EthTxOrderDependenceMinimal"
      ],
      "function_to_selector": {
        "setReward": 0,
        "EthTxOrderDependenceMinimal": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_159",
      "transformed_id": "rs_mg_dis_nc_ds_159",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_160",
      "transformed_id": "rs_mg_dis_nc_ds_160",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\n\ncontract CryptoRoulette {\n\n    uint256 private secretNumber;\n    uint256 public lastPlayed;\n    uint256 public betPrice = 0.1 ether;\n    address public ownerAddr;\n\n    struct Game {\n        address player;\n        uint256 number;\n    }\n    Game[] public gamesPlayed;\n\n    function CryptoRoulette() public {\n        ownerAddr = msg.sender;\n        shuffle();\n    }\n\n    function shuffle() internal {\n\n        secretNumber = uint8(sha3(now, block.blockhash(block.number-1))) % 20 + 1;\n    }\n\n    function play(uint256 number) payable public {\n        require(msg.value >= betPrice && number <= 10);\n        Game game;\n        game.player = msg.sender;\n        game.number = number;\n        gamesPlayed.push(game);\n\n        if (number == secretNumber) {\n\n            msg.sender.transfer(this.balance);\n        }\n\n        shuffle();\n        lastPlayed = now;\n    }\n\n    function kill() public {\n        if (msg.sender == ownerAddr && now > lastPlayed + 1 days) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n\n    // Unified dispatcher - merged from: play, CryptoRoulette, kill\n    // Selectors: play=0, CryptoRoulette=1, kill=2\n    function execute(uint8 _selector, uint256 number) public payable {\n        // Original: play()\n        if (_selector == 0) {\n            require(msg.value >= betPrice && number <= 10);\n            Game game;\n            game.player = msg.sender;\n            game.number = number;\n            gamesPlayed.push(game);\n            if (number == secretNumber) {\n            msg.sender.transfer(this.balance);\n            }\n            shuffle();\n            lastPlayed = now;\n        }\n        // Original: CryptoRoulette()\n        else if (_selector == 1) {\n            ownerAddr = msg.sender;\n            shuffle();\n        }\n        // Original: kill()\n        else if (_selector == 2) {\n            if (msg.sender == ownerAddr && now > lastPlayed + 1 days) {\n            suicide(msg.sender);\n            }\n        }\n    }\n}",
      "merged_functions": [
        "play",
        "CryptoRoulette",
        "kill"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: play, CryptoRoulette, kill"
      ],
      "function_to_selector": {
        "play": 0,
        "CryptoRoulette": 1,
        "kill": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_161",
      "transformed_id": "rs_mg_dis_nc_ds_161",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_162",
      "transformed_id": "rs_mg_dis_nc_ds_162",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_163",
      "transformed_id": "rs_mg_dis_nc_ds_163",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_164",
      "transformed_id": "rs_mg_dis_nc_ds_164",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_165",
      "transformed_id": "rs_mg_dis_nc_ds_165",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_166",
      "transformed_id": "rs_mg_dis_nc_ds_166",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_167",
      "transformed_id": "rs_mg_dis_nc_ds_167",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_168",
      "transformed_id": "rs_mg_dis_nc_ds_168",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_169",
      "transformed_id": "rs_mg_dis_nc_ds_169",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\ncontract TownCrier {\n    struct Request {\n        address requester;\n        uint fee;\n        address callbackAddr;\n        bytes4 callbackFID;\n        bytes32 paramsHash;\n    }\n\n    event Upgrade(address newAddr);\n    event Reset(uint gas_price, uint min_fee, uint cancellation_fee);\n    event RequestInfo(uint64 id, uint8 requestType, address requester, uint fee, address callbackAddr, bytes32 paramsHash, uint timestamp, bytes32[] requestData);\n    event DeliverInfo(uint64 requestId, uint fee, uint gasPrice, uint gasLeft, uint callbackGas, bytes32 paramsHash, uint64 error, bytes32 respData);\n    event Cancel(uint64 requestId, address canceller, address requester, uint fee, int flag);\n\n    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;\n\n    uint public GAS_PRICE = 5 * 10**10;\n    uint public MIN_FEE = 30000 * GAS_PRICE;\n    uint public CANCELLATION_FEE = 25000 * GAS_PRICE;\n\n    uint public constant CANCELLED_FEE_FLAG = 1;\n    uint public constant DELIVERED_FEE_FLAG = 0;\n    int public constant FAIL_FLAG = -2 ** 250;\n    int public constant SUCCESS_FLAG = 1;\n\n    bool public killswitch;\n\n    bool public externalCallFlag;\n\n    uint64 public requestCnt;\n    uint64 public unrespondedCnt;\n    Request[2**64] public requests;\n\n    int public newVersion = 0;\n\n\n    function () {}\n\n    function TownCrier() public {\n\n\n        requestCnt = 1;\n        requests[0].requester = msg.sender;\n        killswitch = false;\n        unrespondedCnt = 0;\n        externalCallFlag = false;\n    }\n\n    function upgrade(address newAddr) {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            newVersion = -int(newAddr);\n            killswitch = true;\n            Upgrade(newAddr);\n        }\n    }\n\n    function reset(uint price, uint minGas, uint cancellationGas) public {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            GAS_PRICE = price;\n            MIN_FEE = price * minGas;\n            CANCELLATION_FEE = price * cancellationGas;\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n        }\n    }\n\n    function suspend() public {\n        if (msg.sender == requests[0].requester) {\n            killswitch = true;\n        }\n    }\n\n    function restart() public {\n        if (msg.sender == requests[0].requester && newVersion == 0) {\n            killswitch = false;\n        }\n    }\n\n    function withdraw() public {\n        if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            if (!requests[0].requester.call.value(this.balance)()) {\n                throw;\n            }\n        }\n    }\n\n    function request(uint8 requestType, address callbackAddr, bytes4 callbackFID, uint timestamp, bytes32[] requestData) public payable returns (int) {\n        if (externalCallFlag) {\n            throw;\n        }\n\n        if (killswitch) {\n            externalCallFlag = true;\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            return newVersion;\n        }\n\n        if (msg.value < MIN_FEE) {\n            externalCallFlag = true;\n\n\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            return FAIL_FLAG;\n        } else {\n\n            uint64 requestId = requestCnt;\n            requestCnt++;\n            unrespondedCnt++;\n\n            bytes32 paramsHash = sha3(requestType, requestData);\n            requests[requestId].requester = msg.sender;\n            requests[requestId].fee = msg.value;\n            requests[requestId].callbackAddr = callbackAddr;\n            requests[requestId].callbackFID = callbackFID;\n            requests[requestId].paramsHash = paramsHash;\n\n\n            RequestInfo(requestId, requestType, msg.sender, msg.value, callbackAddr, paramsHash, timestamp, requestData);\n            return requestId;\n        }\n    }\n\n    function deliver(uint64 requestId, bytes32 paramsHash, uint64 error, bytes32 respData) public {\n        if (msg.sender != SGX_ADDRESS ||\n                requestId <= 0 ||\n                requests[requestId].requester == 0 ||\n                requests[requestId].fee == DELIVERED_FEE_FLAG) {\n\n\n            return;\n        }\n\n        uint fee = requests[requestId].fee;\n        if (requests[requestId].paramsHash != paramsHash) {\n\n\n            return;\n        } else if (fee == CANCELLED_FEE_FLAG) {\n\n\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            requests[requestId].fee = DELIVERED_FEE_FLAG;\n            unrespondedCnt--;\n            return;\n        }\n\n        requests[requestId].fee = DELIVERED_FEE_FLAG;\n        unrespondedCnt--;\n\n        if (error < 2) {\n\n\n            SGX_ADDRESS.send(fee);\n        } else {\n\n            externalCallFlag = true;\n            requests[requestId].requester.call.gas(2300).value(fee)();\n            externalCallFlag = false;\n        }\n\n        uint callbackGas = (fee - MIN_FEE) / tx.gasprice;\n        DeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData);\n        if (callbackGas > msg.gas - 5000) {\n            callbackGas = msg.gas - 5000;\n        }\n\n        externalCallFlag = true;\n        requests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData);\n        externalCallFlag = false;\n    }\n\n    function cancel(uint64 requestId) public returns (int) {\n        if (externalCallFlag) {\n            throw;\n        }\n\n        if (killswitch) {\n            return 0;\n        }\n\n        uint fee = requests[requestId].fee;\n        if (requests[requestId].requester == msg.sender && fee >= CANCELLATION_FEE) {\n\n\n            requests[requestId].fee = CANCELLED_FEE_FLAG;\n            externalCallFlag = true;\n            if (!msg.sender.call.value(fee - CANCELLATION_FEE)()) {\n                throw;\n            }\n            externalCallFlag = false;\n            Cancel(requestId, msg.sender, requests[requestId].requester, requests[requestId].fee, 1);\n            return SUCCESS_FLAG;\n        } else {\n            Cancel(requestId, msg.sender, requests[requestId].requester, fee, -1);\n            return FAIL_FLAG;\n        }\n    }\n\n    // Unified dispatcher - merged from: deliver, TownCrier, reset\n    // Selectors: deliver=0, TownCrier=1, reset=2\n    function execute(uint8 _selector, bytes32 paramsHash, bytes32 respData, uint cancellationGas, uint minGas, uint price, uint64 error, uint64 requestId) public {\n        // Original: deliver()\n        if (_selector == 0) {\n            if (msg.sender != SGX_ADDRESS ||\n            requestId <= 0 ||\n            requests[requestId].requester == 0 ||\n            requests[requestId].fee == DELIVERED_FEE_FLAG) {\n            return;\n            }\n            uint fee = requests[requestId].fee;\n            if (requests[requestId].paramsHash != paramsHash) {\n            return;\n            } else if (fee == CANCELLED_FEE_FLAG) {\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            requests[requestId].fee = DELIVERED_FEE_FLAG;\n            unrespondedCnt--;\n            return;\n            }\n            requests[requestId].fee = DELIVERED_FEE_FLAG;\n            unrespondedCnt--;\n            if (error < 2) {\n            SGX_ADDRESS.send(fee);\n            } else {\n            externalCallFlag = true;\n            requests[requestId].requester.call.gas(2300).value(fee)();\n            externalCallFlag = false;\n            }\n            uint callbackGas = (fee - MIN_FEE) / tx.gasprice;\n            DeliverInfo(requestId, fee, tx.gasprice, msg.gas, callbackGas, paramsHash, error, respData);\n            if (callbackGas > msg.gas - 5000) {\n            callbackGas = msg.gas - 5000;\n            }\n            externalCallFlag = true;\n            requests[requestId].callbackAddr.call.gas(callbackGas)(requests[requestId].callbackFID, requestId, error, respData);\n            externalCallFlag = false;\n        }\n        // Original: TownCrier()\n        else if (_selector == 1) {\n            requestCnt = 1;\n            requests[0].requester = msg.sender;\n            killswitch = false;\n            unrespondedCnt = 0;\n            externalCallFlag = false;\n        }\n        // Original: reset()\n        else if (_selector == 2) {\n            if (msg.sender == requests[0].requester && unrespondedCnt == 0) {\n            GAS_PRICE = price;\n            MIN_FEE = price * minGas;\n            CANCELLATION_FEE = price * cancellationGas;\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n            }\n        }\n    }\n}",
      "merged_functions": [
        "deliver",
        "TownCrier",
        "reset"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: deliver, TownCrier, reset"
      ],
      "function_to_selector": {
        "deliver": 0,
        "TownCrier": 1,
        "reset": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_170",
      "transformed_id": "rs_mg_dis_nc_ds_170",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\n\ncontract Owned {\n\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    address public owner;\n\n\n    function Owned() {\n        owner = msg.sender;\n    }\n\n    address public newOwner;\n\n\n    function changeOwner(address _newOwner) onlyOwner {\n        newOwner = _newOwner;\n    }\n\n\n    function acceptOwnership() {\n        if (msg.sender == newOwner) {\n            owner = newOwner;\n        }\n    }\n\n\n    function execute(address _dst, uint _value, bytes _data) onlyOwner {\n        _dst.call.value(_value)(_data);\n    }\n}\n\ncontract Marriage is Owned\n{\n\n    string public partner1;\n    string public partner2;\n    uint public marriageDate;\n    string public marriageStatus;\n    string public vows;\n\n    Event[] public majorEvents;\n    Message[] public messages;\n\n    struct Event {\n        uint date;\n        string name;\n        string description;\n        string url;\n    }\n\n    struct Message {\n        uint date;\n        string nameFrom;\n        string text;\n        string url;\n        uint value;\n    }\n\n    modifier areMarried {\n        require(sha3(marriageStatus) == sha3(\"Married\"));\n        _;\n    }\n\n\n    function Marriage(address _owner) {\n        owner = _owner;\n    }\n\n    function numberOfMajorEvents() constant public returns (uint) {\n        return majorEvents.length;\n    }\n\n    function numberOfMessages() constant public returns (uint) {\n        return messages.length;\n    }\n\n\n    function createMarriage(\n        string _partner1,\n        string _partner2,\n        string _vows,\n        string url) onlyOwner\n    {\n        require(majorEvents.length == 0);\n        partner1 = _partner1;\n        partner2 = _partner2;\n        marriageDate = now;\n        vows = _vows;\n        marriageStatus = \"Married\";\n        majorEvents.push(Event(now, \"Marriage\", vows, url));\n        MajorEvent(\"Marrigage\", vows, url);\n    }\n\n\n    function setStatus(string status, string url) onlyOwner\n    {\n        marriageStatus = status;\n        setMajorEvent(\"Changed Status\", status, url);\n    }\n\n\n    function setMajorEvent(string name, string description, string url) onlyOwner areMarried\n    {\n        majorEvents.push(Event(now, name, description, url));\n        MajorEvent(name, description, url);\n    }\n\n    function sendMessage(string nameFrom, string text, string url) payable areMarried {\n        if (msg.value > 0) {\n            owner.transfer(this.balance);\n        }\n        messages.push(Message(now, nameFrom, text, url, msg.value));\n        MessageSent(nameFrom, text, url, msg.value);\n    }\n\n\n    event MajorEvent(string name, string description, string url);\n    event MessageSent(string name, string description, string url, uint value);\n\n    // Unified dispatcher - merged from: numberOfMajorEvents, numberOfMessages\n    // Selectors: numberOfMajorEvents=0, numberOfMessages=1\n    function execute(uint8 _selector) public {\n        // Original: numberOfMajorEvents()\n        if (_selector == 0) {\n            return majorEvents.length;\n        }\n        // Original: numberOfMessages()\n        else if (_selector == 1) {\n            return messages.length;\n        }\n    }\n}",
      "merged_functions": [
        "numberOfMajorEvents",
        "numberOfMessages"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: numberOfMajorEvents, numberOfMessages"
      ],
      "function_to_selector": {
        "numberOfMajorEvents": 0,
        "numberOfMessages": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_171",
      "transformed_id": "rs_mg_dis_nc_ds_171",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract Splitter{\n\n\taddress public owner;\n\taddress[] public puppets;\n\tmapping (uint256 => address) public extra;\n\taddress private _addy;\n\tuint256 private _share;\n\tuint256 private _count;\n\n\n\tconstructor() payable public{\n\t\towner = msg.sender;\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\tnewPuppet();\n\t\textra[0] = puppets[0];\n        extra[1] = puppets[1];\n        extra[2] = puppets[2];\n        extra[3] = puppets[3];\n\t}\n\n\n\tfunction withdraw() public{\n\t\trequire(msg.sender == owner);\n\t\towner.transfer(address(this).balance);\n\t}\n\n\n\tfunction getPuppetCount() public constant returns(uint256 puppetCount){\n    \treturn puppets.length;\n  \t}\n\n\n\tfunction newPuppet() public returns(address newPuppet){\n\t    require(msg.sender == owner);\n    \tPuppet p = new Puppet();\n    \tpuppets.push(p);\n    \treturn p;\n  \t\t}\n\n\n    function setExtra(uint256 _id, address _newExtra) public {\n        require(_newExtra != address(0));\n        extra[_id] = _newExtra;\n    }\n\n\n    function fundPuppets() public payable {\n        require(msg.sender == owner);\n    \t_share = SafeMath.div(msg.value, 4);\n        extra[0].call.value(_share).gas(800000)();\n        extra[1].call.value(_share).gas(800000)();\n        extra[2].call.value(_share).gas(800000)();\n        extra[3].call.value(_share).gas(800000)();\n        }\n\n\nfunction() payable public{\n\t}\n}\n\ncontract Puppet {\n\n    mapping (uint256 => address) public target;\n    mapping (uint256 => address) public master;\n\n\tconstructor() payable public{\n\n\t\ttarget[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        master[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\n\n\tfunction() public payable{\n\t    if(msg.sender != target[0]){\n\t\t\ttarget[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\n\n\tfunction withdraw() public{\n\t\trequire(msg.sender == master[0]);\n\t\tmaster[0].transfer(address(this).balance);\n\t}\n}\n\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n\n    // Unified dispatcher - merged from: fundPuppets, withdraw, getPuppetCount\n    // Selectors: fundPuppets=0, withdraw=1, getPuppetCount=2\n    function execute(uint8 _selector) public payable {\n        // Original: fundPuppets()\n        if (_selector == 0) {\n            require(msg.sender == owner);\n            _share = SafeMath.div(msg.value, 4);\n            extra[0].call.value(_share).gas(800000)();\n            extra[1].call.value(_share).gas(800000)();\n            extra[2].call.value(_share).gas(800000)();\n            extra[3].call.value(_share).gas(800000)();\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            require(msg.sender == owner);\n            owner.transfer(address(this).balance);\n        }\n        // Original: getPuppetCount()\n        else if (_selector == 2) {\n            return puppets.length;\n        }\n    }\n}",
      "merged_functions": [
        "fundPuppets",
        "withdraw",
        "getPuppetCount"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: fundPuppets, withdraw, getPuppetCount"
      ],
      "function_to_selector": {
        "fundPuppets": 0,
        "withdraw": 1,
        "getPuppetCount": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_172",
      "transformed_id": "rs_mg_dis_nc_ds_172",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract FundManager {\n\n\naddress public winner = 0x0;\naddress public owner;\naddress public firstTarget = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public secondTarget = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public players;\n\nmapping(address=>bool) approvedPlayers;\n\nuint256 public secret;\nuint256[] public seed = [951828771,158769871220];\nuint256[] public balance;\n\n\nfunction DranMe() public payable{\n\towner = msg.sender;\n}\n\n\nmodifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n}\n\nmodifier onlyWinner() {\n    require(msg.sender == winner);\n    _;\n}\n\nmodifier onlyPlayers() {\n    require(approvedPlayers[msg.sender]);\n    _;\n}\n\n\nfunction getLength() public constant returns(uint256) {\n\treturn seed.length;\n}\n\nfunction setSecret(uint256 _secret) public payable onlyOwner{\n\tsecret = _secret;\n}\n\nfunction getPlayerCount() public constant returns(uint256) {\n\treturn players.length;\n}\n\nfunction getPrize() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction becomePlayer() public payable{\n\trequire(msg.value >= 0.02 ether);\n\tplayers.push(msg.sender);\n\tapprovedPlayers[msg.sender]=true;\n}\n\nfunction manipulateSecret() public payable onlyPlayers{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=owner || unlockSecret()){\n\t    uint256 amount = 0;\n        msg.sender.transfer(amount);\n\t}\n}\n\nfunction unlockSecret() private returns(bool){\n    bytes32 hash = keccak256(blockhash(block.number-1));\n    uint256 secret = uint256(hash);\n        if(secret%5==0){\n            winner = msg.sender;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction callFirstTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\tfirstTarget.call.value(msg.value)();\n}\n\nfunction callSecondTarget () public payable onlyPlayers {\n\trequire (msg.value >= 0.005 ether);\n\tsecondTarget.call.value(msg.value)();\n}\n\nfunction setSeed (uint256 _index, uint256 _value) public payable onlyPlayers {\n\tseed[_index] = _value;\n}\n\nfunction addSeed (uint256 _add) public payable onlyPlayers {\n\tseed.length = _add;\n}\n\nfunction guessSeed (uint256 _seed) public payable onlyPlayers returns(uint256) {\n\treturn (_seed / (seed[0]*seed[1]));\n\tif((_seed / (seed[0]*seed[1])) == secret) {\n\t\towner = winner;\n\t}\n}\n\nfunction checkSecret () public payable onlyPlayers returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == secret){\n        return true;\n    }\n}\n\nfunction winPrize() public payable onlyOwner {\n\towner.call.value(1 wei)();\n}\n\nfunction claimPrize() public payable onlyWinner {\n\twinner.transfer(address(this).balance);\n}\n\n\nfunction() public payable{\n\t}\n\n    // Unified dispatcher - merged from: callFirstTarget, DranMe, getLength\n    // Selectors: callFirstTarget=0, DranMe=1, getLength=2\n    function execute(uint8 _selector) public payable {\n        // Original: callFirstTarget()\n        if (_selector == 0) {\n            require (msg.value >= 0.005 ether);\n            firstTarget.call.value(msg.value)();\n        }\n        // Original: DranMe()\n        else if (_selector == 1) {\n            owner = msg.sender;\n        }\n        // Original: getLength()\n        else if (_selector == 2) {\n            return seed.length;\n        }\n    }\n}",
      "merged_functions": [
        "callFirstTarget",
        "DranMe",
        "getLength"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: callFirstTarget, DranMe, getLength"
      ],
      "function_to_selector": {
        "callFirstTarget": 0,
        "DranMe": 1,
        "getLength": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_173",
      "transformed_id": "rs_mg_dis_nc_ds_173",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_174",
      "transformed_id": "rs_mg_dis_nc_ds_174",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_201",
      "transformed_id": "rs_mg_dis_nc_ds_201",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public balances;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address _log)\n    {\n        TransferLog = Log(_log);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _am)\n    {\n        if(_am<=balances[msg.sender])\n        {\n\n            if(msg.sender.call.value(_am)())\n            {\n                balances[msg.sender]-=_am;\n                TransferLog.AddMessage(msg.sender,_am,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _adr,uint _val,string _data)\n    public\n    {\n        LastMsg.Sender = _adr;\n        LastMsg.Time = now;\n        LastMsg.Val = _val;\n        LastMsg.Data = _data;\n        History.push(LastMsg);\n    }\n\n    // Unified dispatcher - merged from: Deposit, AddMessage\n    // Selectors: Deposit=0, AddMessage=1\n    function execute(uint8 _selector, address _adr, string _data, uint _val) public payable {\n        // Original: Deposit()\n        if (_selector == 0) {\n            if(msg.value >= MinDeposit)\n            {\n            balances[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            }\n        }\n        // Original: AddMessage()\n        else if (_selector == 1) {\n            LastMsg.Sender = _adr;\n            LastMsg.Time = now;\n            LastMsg.Val = _val;\n            LastMsg.Data = _data;\n            History.push(LastMsg);\n        }\n    }\n}",
      "merged_functions": [
        "Deposit",
        "AddMessage"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: Deposit, AddMessage"
      ],
      "function_to_selector": {
        "Deposit": 0,
        "AddMessage": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_202",
      "transformed_id": "rs_mg_dis_nc_ds_202",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_203",
      "transformed_id": "rs_mg_dis_nc_ds_203",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\n\ncontract Ownable {\n    address public owner;\n    function Ownable() public {owner = msg.sender;}\n    modifier onlyOwner() {require(msg.sender == owner); _;\n    }\n}\n\n\ncontract CEOThrone is Ownable {\n    address public owner;\n    uint public largestStake;\n\n\n    function Stake() public payable {\n\n        if (msg.value > largestStake) {\n            owner = msg.sender;\n            largestStake = msg.value;\n        }\n    }\n\n    function withdraw() public onlyOwner {\n\n        msg.sender.transfer(this.balance);\n    }\n\n    // Unified dispatcher - merged from: Ownable, Stake, withdraw\n    // Selectors: Ownable=0, Stake=1, withdraw=2\n    function execute(uint8 _selector) public payable {\n        // Original: Ownable()\n        if (_selector == 0) {\n            owner = msg.sender;\n        }\n        // Original: Stake()\n        else if (_selector == 1) {\n            if (msg.value > largestStake) {\n            owner = msg.sender;\n            largestStake = msg.value;\n            }\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            msg.sender.transfer(this.balance);\n        }\n    }\n}",
      "merged_functions": [
        "Ownable",
        "Stake",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: Ownable, Stake, withdraw"
      ],
      "function_to_selector": {
        "Ownable": 0,
        "Stake": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_204",
      "transformed_id": "rs_mg_dis_nc_ds_204",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_205",
      "transformed_id": "rs_mg_dis_nc_ds_205",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract NEW_YEARS_GIFT\n{\n    string message;\n\n    bool passHasBeenSet = false;\n\n    address sender;\n\n    bytes32 public hashPass;\n\n    function() public payable{}\n\n    function GetHash(bytes pass) public constant returns (bytes32) {return sha3(pass);}\n\n    function SetPass(bytes32 hash)\n    public\n    payable\n    {\n        if( (!passHasBeenSet&&(msg.value > 1 ether)) || hashPass==0x0 )\n        {\n            hashPass = hash;\n            sender = msg.sender;\n        }\n    }\n\n    function SetMessage(string _message)\n    public\n    {\n        if(msg.sender==sender)\n        {\n            message =_message;\n        }\n    }\n\n    function GetGift(bytes pass)\n    external\n    payable\n    returns (string)\n    {\n        if(hashPass == sha3(pass))\n        {\n            msg.sender.transfer(this.balance);\n            return message;\n        }\n    }\n\n    function Revoce()\n    public\n    payable\n    {\n        if(msg.sender==sender)\n        {\n            sender.transfer(this.balance);\n            message=\"\";\n        }\n    }\n\n    function PassHasBeenSet(bytes32 hash)\n    public\n    {\n        if(msg.sender==sender&&hash==hashPass)\n        {\n           passHasBeenSet=true;\n        }\n    }\n\n    // Unified dispatcher - merged from: GetHash, SetPass, SetMessage\n    // Selectors: GetHash=0, SetPass=1, SetMessage=2\n    function execute(uint8 _selector, bytes pass, bytes32 hash, string _message) public payable {\n        // Original: GetHash()\n        if (_selector == 0) {\n            return sha3(pass);\n        }\n        // Original: SetPass()\n        else if (_selector == 1) {\n            if( (!passHasBeenSet&&(msg.value > 1 ether)) || hashPass==0x0 )\n            {\n            hashPass = hash;\n            sender = msg.sender;\n            }\n        }\n        // Original: SetMessage()\n        else if (_selector == 2) {\n            if(msg.sender==sender)\n            {\n            message =_message;\n            }\n        }\n    }\n}",
      "merged_functions": [
        "GetHash",
        "SetPass",
        "SetMessage"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: GetHash, SetPass, SetMessage"
      ],
      "function_to_selector": {
        "GetHash": 0,
        "SetPass": 1,
        "SetMessage": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_206",
      "transformed_id": "rs_mg_dis_nc_ds_206",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Test1\n{\n    address owner = msg.sender;\n\n    function withdraw()\n    payable\n    public\n    {\n        require(msg.sender==owner);\n        owner.transfer(this.balance);\n    }\n\n    function() payable {}\n\n    function Test()\n    payable\n    public\n    {\n        if(msg.value>=1 ether)\n        {\n\n            var i1 = 1;\n            var i2 = 0;\n            var amX2 = msg.value*2;\n\n            while(true)\n            {\n                if(i1<i2)break;\n                if(i1>amX2)break;\n\n                i2=i1;\n                i1++;\n            }\n            msg.sender.transfer(i2);\n        }\n    }\n\n    // Unified dispatcher - merged from: withdraw, Test\n    // Selectors: withdraw=0, Test=1\n    function execute(uint8 _selector) public payable {\n        // Original: withdraw()\n        if (_selector == 0) {\n            require(msg.sender==owner);\n            owner.transfer(this.balance);\n        }\n        // Original: Test()\n        else if (_selector == 1) {\n            if(msg.value>=1 ether)\n            {\n            var i1 = 1;\n            var i2 = 0;\n            var amX2 = msg.value*2;\n            while(true)\n            {\n            if(i1<i2)break;\n            if(i1>amX2)break;\n            i2=i1;\n            i1++;\n            }\n            msg.sender.transfer(i2);\n            }\n        }\n    }\n}",
      "merged_functions": [
        "withdraw",
        "Test"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: withdraw, Test"
      ],
      "function_to_selector": {
        "withdraw": 0,
        "Test": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_207",
      "transformed_id": "rs_mg_dis_nc_ds_207",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\n\ncontract ERC20 {\n    function totalSupply() constant returns (uint totalSupply);\n    function balanceOf(address _owner) constant returns (uint balance);\n    function transfer(address _to, uint _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\n    function approve(address _spender, uint _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint remaining);\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n}\n\ncontract TokenExchange{\n    address private owner;\n    uint public price;\n    ERC20 token;\n\n    function TokenExchange(uint _price, ERC20 _token)\n        public\n    {\n        owner = msg.sender;\n        price = _price;\n        token = _token;\n    }\n\n\n    function buy(uint new_price) payable\n        public\n    {\n        require(msg.value >= price);\n\n\n        token.transferFrom(msg.sender, owner, price);\n\n        price = new_price;\n        owner = msg.sender;\n    }\n\n    function changePrice(uint new_price){\n        require(msg.sender == owner);\n        price = new_price;\n    }\n\n\n    // Unified dispatcher - merged from: buy, TokenExchange\n    // Selectors: buy=0, TokenExchange=1\n    function execute(uint8 _selector, ERC20 _token, uint _price, uint new_price) public payable {\n        // Original: buy()\n        if (_selector == 0) {\n            require(msg.value >= price);\n            token.transferFrom(msg.sender, owner, price);\n            price = new_price;\n            owner = msg.sender;\n        }\n        // Original: TokenExchange()\n        else if (_selector == 1) {\n            owner = msg.sender;\n            price = _price;\n            token = _token;\n        }\n    }\n}",
      "merged_functions": [
        "buy",
        "TokenExchange"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: buy, TokenExchange"
      ],
      "function_to_selector": {
        "buy": 0,
        "TokenExchange": 1
      },
      "error": null
    },
    {
      "original_id": "nc_ds_208",
      "transformed_id": "rs_mg_dis_nc_ds_208",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_ds_209",
      "transformed_id": "rs_mg_dis_nc_ds_209",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_ds_210",
      "transformed_id": "rs_mg_dis_nc_ds_210",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_ds_211",
      "transformed_id": "rs_mg_dis_nc_ds_211",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\n\n contract Token {\n\n     uint256 public totalSupply;\n\n\n     function balanceOf(address _owner) public constant returns (uint256 balance);\n\n\n     function transfer(address _to, uint256 _value) public returns (bool success);\n\n\n     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\n\n\n     function approve(address _spender, uint256 _value) public returns (bool success);\n\n\n     function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\n\n     event Transfer(address indexed _from, address indexed _to, uint256 _value);\n     event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n }\n\n library ECTools {\n\n\n     function recoverSigner(bytes32 _hashedMsg, string _sig) public pure returns (address) {\n         require(_hashedMsg != 0x00);\n\n\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 prefixedHash = keccak256(abi.encodePacked(prefix, _hashedMsg));\n\n         if (bytes(_sig).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = hexstrToBytes(substring(_sig, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return ecrecover(prefixedHash, v, r, s);\n     }\n\n\n     function isSignedBy(bytes32 _hashedMsg, string _sig, address _addr) public pure returns (bool) {\n         require(_addr != 0x0);\n\n         return _addr == recoverSigner(_hashedMsg, _sig);\n     }\n\n\n     function hexstrToBytes(string _hexstr) public pure returns (bytes) {\n         uint len = bytes(_hexstr).length;\n         require(len % 2 == 0);\n\n         bytes memory bstr = bytes(new string(len / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < len; i += 2) {\n             s = substring(_hexstr, i, i + 1);\n             r = substring(_hexstr, i + 1, i + 2);\n             uint p = parseInt16Char(s) * 16 + parseInt16Char(r);\n             bstr[k++] = uintToBytes32(p)[31];\n         }\n         return bstr;\n     }\n\n\n     function parseInt16Char(string _char) public pure returns (uint) {\n         bytes memory bresult = bytes(_char);\n\n         if ((bresult[0] >= 48) && (bresult[0] <= 57)) {\n             return uint(bresult[0]) - 48;\n         } else if ((bresult[0] >= 65) && (bresult[0] <= 70)) {\n             return uint(bresult[0]) - 55;\n         } else if ((bresult[0] >= 97) && (bresult[0] <= 102)) {\n             return uint(bresult[0]) - 87;\n         } else {\n             revert();\n         }\n     }\n\n\n     function uintToBytes32(uint _uint) public pure returns (bytes b) {\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), _uint)}\n     }\n\n\n     function toEthereumSignedMessage(string _msg) public pure returns (bytes32) {\n         uint len = bytes(_msg).length;\n         require(len > 0);\n         bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\n         return keccak256(abi.encodePacked(prefix, uintToString(len), _msg));\n     }\n\n\n     function uintToString(uint _uint) public pure returns (string str) {\n         uint len = 0;\n         uint m = _uint + 0;\n         while (m != 0) {\n             len++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(len);\n         uint i = len - 1;\n         while (_uint != 0) {\n             uint remainder = _uint % 10;\n             _uint = _uint / 10;\n             b[i--] = byte(48 + remainder);\n         }\n         str = string(b);\n     }\n\n\n     function substring(string _str, uint _startIndex, uint _endIndex) public pure returns (string) {\n         bytes memory strBytes = bytes(_str);\n         require(_startIndex <= _endIndex);\n         require(_startIndex >= 0);\n         require(_endIndex <= strBytes.length);\n\n         bytes memory result = new bytes(_endIndex - _startIndex);\n         for (uint i = _startIndex; i < _endIndex; i++) {\n             result[i - _startIndex] = strBytes[i];\n         }\n         return string(result);\n     }\n }\n contract StandardToken is Token {\n\n     function transfer(address _to, uint256 _value) public returns (bool success) {\n\n\n         require(balances[msg.sender] >= _value);\n         balances[msg.sender] -= _value;\n         balances[_to] += _value;\n         emit Transfer(msg.sender, _to, _value);\n         return true;\n     }\n\n     function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n\n\n         require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value);\n         balances[_to] += _value;\n         balances[_from] -= _value;\n         allowed[_from][msg.sender] -= _value;\n         emit Transfer(_from, _to, _value);\n         return true;\n     }\n\n     function balanceOf(address _owner) public constant returns (uint256 balance) {\n         return balances[_owner];\n     }\n\n     function approve(address _spender, uint256 _value) public returns (bool success) {\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n         return true;\n     }\n\n     function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n       return allowed[_owner][_spender];\n     }\n\n     mapping (address => uint256) balances;\n     mapping (address => mapping (address => uint256)) allowed;\n }\n\n contract HumanStandardToken is StandardToken {\n\n\n     string public name;\n     uint8 public decimals;\n     string public symbol;\n     string public version = 'H0.1';\n\n     constructor(\n         uint256 _initialAmount,\n         string _tokenName,\n         uint8 _decimalUnits,\n         string _tokenSymbol\n         ) public {\n         balances[msg.sender] = _initialAmount;\n         totalSupply = _initialAmount;\n         name = _tokenName;\n         decimals = _decimalUnits;\n         symbol = _tokenSymbol;\n     }\n\n\n     function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\n         allowed[msg.sender][_spender] = _value;\n         emit Approval(msg.sender, _spender, _value);\n\n\n         require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\n         return true;\n     }\n }\n\n contract LedgerChannel {\n\n     string public constant NAME = \"Ledger Channel\";\n     string public constant VERSION = \"0.0.1\";\n\n     uint256 public numChannels = 0;\n\n     event DidLCOpen (\n         bytes32 indexed channelId,\n         address indexed partyA,\n         address indexed partyI,\n         uint256 ethBalanceA,\n         address token,\n         uint256 tokenBalanceA,\n         uint256 LCopenTimeout\n     );\n\n     event DidLCJoin (\n         bytes32 indexed channelId,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     );\n\n     event DidLCDeposit (\n         bytes32 indexed channelId,\n         address indexed recipient,\n         uint256 deposit,\n         bool isToken\n     );\n\n     event DidLCUpdateState (\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 numOpenVc,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI,\n         bytes32 vcRoot,\n         uint256 updateLCtimeout\n     );\n\n     event DidLCClose (\n         bytes32 indexed channelId,\n         uint256 sequence,\n         uint256 ethBalanceA,\n         uint256 tokenBalanceA,\n         uint256 ethBalanceI,\n         uint256 tokenBalanceI\n     );\n\n     event DidVCInit (\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         bytes proof,\n         uint256 sequence,\n         address partyA,\n         address partyB,\n         uint256 balanceA,\n         uint256 balanceB\n     );\n\n     event DidVCSettle (\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 updateSeq,\n         uint256 updateBalA,\n         uint256 updateBalB,\n         address challenger,\n         uint256 updateVCtimeout\n     );\n\n     event DidVCClose(\n         bytes32 indexed lcId,\n         bytes32 indexed vcId,\n         uint256 balanceA,\n         uint256 balanceB\n     );\n\n     struct Channel {\n\n         address[2] partyAddresses;\n         uint256[4] ethBalances;\n         uint256[4] erc20Balances;\n         uint256[2] initialDeposit;\n         uint256 sequence;\n         uint256 confirmTime;\n         bytes32 VCrootHash;\n         uint256 LCopenTimeout;\n         uint256 updateLCtimeout;\n         bool isOpen;\n         bool isUpdateLCSettling;\n         uint256 numOpenVC;\n         HumanStandardToken token;\n     }\n\n\n     struct VirtualChannel {\n         bool isClose;\n         bool isInSettlementState;\n         uint256 sequence;\n         address challenger;\n         uint256 updateVCtimeout;\n\n         address partyA;\n         address partyB;\n         address partyI;\n         uint256[2] ethBalances;\n         uint256[2] erc20Balances;\n         uint256[2] bond;\n         HumanStandardToken token;\n     }\n\n     mapping(bytes32 => VirtualChannel) public virtualChannels;\n     mapping(bytes32 => Channel) public Channels;\n\n     function createChannel(\n         bytes32 _lcID,\n         address _partyI,\n         uint256 _confirmTime,\n         address _token,\n         uint256[2] _balances\n     )\n         public\n         payable\n     {\n         require(Channels[_lcID].partyAddresses[0] == address(0), \"Channel has already been created.\");\n         require(_partyI != 0x0, \"No partyI address provided to LC creation\");\n         require(_balances[0] >= 0 && _balances[1] >= 0, \"Balances cannot be negative\");\n\n\n         Channels[_lcID].partyAddresses[0] = msg.sender;\n         Channels[_lcID].partyAddresses[1] = _partyI;\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"Eth balance does not match sent value\");\n             Channels[_lcID].ethBalances[0] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             Channels[_lcID].token = HumanStandardToken(_token);\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"CreateChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[0] = _balances[1];\n         }\n\n         Channels[_lcID].sequence = 0;\n         Channels[_lcID].confirmTime = _confirmTime;\n\n\n         Channels[_lcID].LCopenTimeout = now + _confirmTime;\n         Channels[_lcID].initialDeposit = _balances;\n\n         emit DidLCOpen(_lcID, msg.sender, _partyI, _balances[0], _token, _balances[1], Channels[_lcID].LCopenTimeout);\n     }\n\n     function LCOpenTimeout(bytes32 _lcID) public {\n         require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\n         require(now > Channels[_lcID].LCopenTimeout);\n\n         if(Channels[_lcID].initialDeposit[0] != 0) {\n             Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n         }\n         if(Channels[_lcID].initialDeposit[1] != 0) {\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\n\n\n         delete Channels[_lcID];\n     }\n\n     function joinChannel(bytes32 _lcID, uint256[2] _balances) public payable {\n\n         require(Channels[_lcID].isOpen == false);\n         require(msg.sender == Channels[_lcID].partyAddresses[1]);\n\n         if(_balances[0] != 0) {\n             require(msg.value == _balances[0], \"state balance does not match sent value\");\n             Channels[_lcID].ethBalances[1] = msg.value;\n         }\n         if(_balances[1] != 0) {\n             require(Channels[_lcID].token.transferFrom(msg.sender, this, _balances[1]),\"joinChannel: token transfer failure\");\n             Channels[_lcID].erc20Balances[1] = _balances[1];\n         }\n\n         Channels[_lcID].initialDeposit[0]+=_balances[0];\n         Channels[_lcID].initialDeposit[1]+=_balances[1];\n\n         Channels[_lcID].isOpen = true;\n         numChannels++;\n\n         emit DidLCJoin(_lcID, _balances[0], _balances[1]);\n     }\n\n\n     function deposit(bytes32 _lcID, address recipient, uint256 _balance, bool isToken) public payable {\n         require(Channels[_lcID].isOpen == true, \"Tried adding funds to a closed channel\");\n         require(recipient == Channels[_lcID].partyAddresses[0] || recipient == Channels[_lcID].partyAddresses[1]);\n\n\n         if (Channels[_lcID].partyAddresses[0] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[2] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[2] += msg.value;\n             }\n         }\n\n         if (Channels[_lcID].partyAddresses[1] == recipient) {\n             if(isToken) {\n                 require(Channels[_lcID].token.transferFrom(msg.sender, this, _balance),\"deposit: token transfer failure\");\n                 Channels[_lcID].erc20Balances[3] += _balance;\n             } else {\n                 require(msg.value == _balance, \"state balance does not match sent value\");\n                 Channels[_lcID].ethBalances[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(_lcID, recipient, _balance, isToken);\n     }\n\n\n     function consensusCloseChannel(\n         bytes32 _lcID,\n         uint256 _sequence,\n         uint256[4] _balances,\n         string _sigA,\n         string _sigI\n     )\n         public\n     {\n\n\n         require(Channels[_lcID].isOpen == true);\n         uint256 totalEthDeposit = Channels[_lcID].initialDeposit[0] + Channels[_lcID].ethBalances[2] + Channels[_lcID].ethBalances[3];\n         uint256 totalTokenDeposit = Channels[_lcID].initialDeposit[1] + Channels[_lcID].erc20Balances[2] + Channels[_lcID].erc20Balances[3];\n         require(totalEthDeposit == _balances[0] + _balances[1]);\n         require(totalTokenDeposit == _balances[2] + _balances[3]);\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 true,\n                 _sequence,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_lcID].partyAddresses[0],\n                 Channels[_lcID].partyAddresses[1],\n                 _balances[0],\n                 _balances[1],\n                 _balances[2],\n                 _balances[3]\n             )\n         );\n\n         require(Channels[_lcID].partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(Channels[_lcID].partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n         Channels[_lcID].isOpen = false;\n\n         if(_balances[0] != 0 || _balances[1] != 0) {\n             Channels[_lcID].partyAddresses[0].transfer(_balances[0]);\n             Channels[_lcID].partyAddresses[1].transfer(_balances[1]);\n         }\n\n         if(_balances[2] != 0 || _balances[3] != 0) {\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], _balances[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[1], _balances[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         numChannels--;\n\n         emit DidLCClose(_lcID, _sequence, _balances[0], _balances[1], _balances[2], _balances[3]);\n     }\n\n\n     function updateLCstate(\n         bytes32 _lcID,\n         uint256[6] updateParams,\n         bytes32 _VCroot,\n         string _sigA,\n         string _sigI\n     )\n         public\n     {\n         Channel storage channel = Channels[_lcID];\n         require(channel.isOpen);\n         require(channel.sequence < updateParams[0]);\n         require(channel.ethBalances[0] + channel.ethBalances[1] >= updateParams[2] + updateParams[3]);\n         require(channel.erc20Balances[0] + channel.erc20Balances[1] >= updateParams[4] + updateParams[5]);\n\n         if(channel.isUpdateLCSettling == true) {\n             require(channel.updateLCtimeout > now);\n         }\n\n         bytes32 _state = keccak256(\n             abi.encodePacked(\n                 _lcID,\n                 false,\n                 updateParams[0],\n                 updateParams[1],\n                 _VCroot,\n                 channel.partyAddresses[0],\n                 channel.partyAddresses[1],\n                 updateParams[2],\n                 updateParams[3],\n                 updateParams[4],\n                 updateParams[5]\n             )\n         );\n\n         require(channel.partyAddresses[0] == ECTools.recoverSigner(_state, _sigA));\n         require(channel.partyAddresses[1] == ECTools.recoverSigner(_state, _sigI));\n\n\n         channel.sequence = updateParams[0];\n         channel.numOpenVC = updateParams[1];\n         channel.ethBalances[0] = updateParams[2];\n         channel.ethBalances[1] = updateParams[3];\n         channel.erc20Balances[0] = updateParams[4];\n         channel.erc20Balances[1] = updateParams[5];\n         channel.VCrootHash = _VCroot;\n         channel.isUpdateLCSettling = true;\n         channel.updateLCtimeout = now + channel.confirmTime;\n\n\n         emit DidLCUpdateState (\n             _lcID,\n             updateParams[0],\n             updateParams[1],\n             updateParams[2],\n             updateParams[3],\n             updateParams[4],\n             updateParams[5],\n             _VCroot,\n             channel.updateLCtimeout\n         );\n     }\n\n\n     function initVCstate(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         bytes _proof,\n         address _partyA,\n         address _partyB,\n         uint256[2] _bond,\n         uint256[4] _balances,\n         string sigA\n     )\n         public\n     {\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n\n         require(Channels[_lcID].updateLCtimeout < now, \"LC timeout not over.\");\n\n         require(virtualChannels[_vcID].updateVCtimeout == 0);\n\n         bytes32 _initState = keccak256(\n             abi.encodePacked(_vcID, uint256(0), _partyA, _partyB, _bond[0], _bond[1], _balances[0], _balances[1], _balances[2], _balances[3])\n         );\n\n\n         require(_partyA == ECTools.recoverSigner(_initState, sigA));\n\n\n         require(_isContained(_initState, _proof, Channels[_lcID].VCrootHash) == true);\n\n         virtualChannels[_vcID].partyA = _partyA;\n         virtualChannels[_vcID].partyB = _partyB;\n         virtualChannels[_vcID].sequence = uint256(0);\n         virtualChannels[_vcID].ethBalances[0] = _balances[0];\n         virtualChannels[_vcID].ethBalances[1] = _balances[1];\n         virtualChannels[_vcID].erc20Balances[0] = _balances[2];\n         virtualChannels[_vcID].erc20Balances[1] = _balances[3];\n         virtualChannels[_vcID].bond = _bond;\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n         virtualChannels[_vcID].isInSettlementState = true;\n\n         emit DidVCInit(_lcID, _vcID, _proof, uint256(0), _partyA, _partyB, _balances[0], _balances[1]);\n     }\n\n\n     function settleVC(\n         bytes32 _lcID,\n         bytes32 _vcID,\n         uint256 updateSeq,\n         address _partyA,\n         address _partyB,\n         uint256[4] updateBal,\n         string sigA\n     )\n         public\n     {\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n\n         require(!virtualChannels[_vcID].isClose, \"VC is closed.\");\n         require(virtualChannels[_vcID].sequence < updateSeq, \"VC sequence is higher than update sequence.\");\n         require(\n             virtualChannels[_vcID].ethBalances[1] < updateBal[1] && virtualChannels[_vcID].erc20Balances[1] < updateBal[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             virtualChannels[_vcID].bond[0] == updateBal[0] + updateBal[1] &&\n             virtualChannels[_vcID].bond[1] == updateBal[2] + updateBal[3],\n             \"Incorrect balances for bonded amount\");\n\n\n         require(Channels[_lcID].updateLCtimeout < now);\n\n         bytes32 _updateState = keccak256(\n             abi.encodePacked(\n                 _vcID,\n                 updateSeq,\n                 _partyA,\n                 _partyB,\n                 virtualChannels[_vcID].bond[0],\n                 virtualChannels[_vcID].bond[1],\n                 updateBal[0],\n                 updateBal[1],\n                 updateBal[2],\n                 updateBal[3]\n             )\n         );\n\n\n         require(virtualChannels[_vcID].partyA == ECTools.recoverSigner(_updateState, sigA));\n\n\n         virtualChannels[_vcID].challenger = msg.sender;\n         virtualChannels[_vcID].sequence = updateSeq;\n\n\n         virtualChannels[_vcID].ethBalances[0] = updateBal[0];\n         virtualChannels[_vcID].ethBalances[1] = updateBal[1];\n         virtualChannels[_vcID].erc20Balances[0] = updateBal[2];\n         virtualChannels[_vcID].erc20Balances[1] = updateBal[3];\n\n         virtualChannels[_vcID].updateVCtimeout = now + Channels[_lcID].confirmTime;\n\n         emit DidVCSettle(_lcID, _vcID, updateSeq, updateBal[0], updateBal[1], msg.sender, virtualChannels[_vcID].updateVCtimeout);\n     }\n\n     function closeVirtualChannel(bytes32 _lcID, bytes32 _vcID) public {\n\n         require(Channels[_lcID].isOpen, \"LC is closed.\");\n         require(virtualChannels[_vcID].isInSettlementState, \"VC is not in settlement state.\");\n         require(virtualChannels[_vcID].updateVCtimeout < now, \"Update vc timeout has not elapsed.\");\n         require(!virtualChannels[_vcID].isClose, \"VC is already closed\");\n\n         Channels[_lcID].numOpenVC--;\n\n         virtualChannels[_vcID].isClose = true;\n\n\n         if(virtualChannels[_vcID].partyA == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[0];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[1];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[0];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[1];\n         } else if (virtualChannels[_vcID].partyB == Channels[_lcID].partyAddresses[0]) {\n             Channels[_lcID].ethBalances[0] += virtualChannels[_vcID].ethBalances[1];\n             Channels[_lcID].ethBalances[1] += virtualChannels[_vcID].ethBalances[0];\n\n             Channels[_lcID].erc20Balances[0] += virtualChannels[_vcID].erc20Balances[1];\n             Channels[_lcID].erc20Balances[1] += virtualChannels[_vcID].erc20Balances[0];\n         }\n\n         emit DidVCClose(_lcID, _vcID, virtualChannels[_vcID].erc20Balances[0], virtualChannels[_vcID].erc20Balances[1]);\n     }\n\n\n     function byzantineCloseChannel(bytes32 _lcID) public {\n         Channel storage channel = Channels[_lcID];\n\n\n         require(channel.isOpen, \"Channel is not open\");\n         require(channel.isUpdateLCSettling == true);\n         require(channel.numOpenVC == 0);\n         require(channel.updateLCtimeout < now, \"LC timeout over.\");\n\n\n         uint256 totalEthDeposit = channel.initialDeposit[0] + channel.ethBalances[2] + channel.ethBalances[3];\n         uint256 totalTokenDeposit = channel.initialDeposit[1] + channel.erc20Balances[2] + channel.erc20Balances[3];\n\n         uint256 possibleTotalEthBeforeDeposit = channel.ethBalances[0] + channel.ethBalances[1];\n         uint256 possibleTotalTokenBeforeDeposit = channel.erc20Balances[0] + channel.erc20Balances[1];\n\n         if(possibleTotalEthBeforeDeposit < totalEthDeposit) {\n             channel.ethBalances[0]+=channel.ethBalances[2];\n             channel.ethBalances[1]+=channel.ethBalances[3];\n         } else {\n             require(possibleTotalEthBeforeDeposit == totalEthDeposit);\n         }\n\n         if(possibleTotalTokenBeforeDeposit < totalTokenDeposit) {\n             channel.erc20Balances[0]+=channel.erc20Balances[2];\n             channel.erc20Balances[1]+=channel.erc20Balances[3];\n         } else {\n             require(possibleTotalTokenBeforeDeposit == totalTokenDeposit);\n         }\n\n         uint256 ethbalanceA = channel.ethBalances[0];\n         uint256 ethbalanceI = channel.ethBalances[1];\n         uint256 tokenbalanceA = channel.erc20Balances[0];\n         uint256 tokenbalanceI = channel.erc20Balances[1];\n\n         channel.ethBalances[0] = 0;\n         channel.ethBalances[1] = 0;\n         channel.erc20Balances[0] = 0;\n         channel.erc20Balances[1] = 0;\n\n         if(ethbalanceA != 0 || ethbalanceI != 0) {\n             channel.partyAddresses[0].transfer(ethbalanceA);\n             channel.partyAddresses[1].transfer(ethbalanceI);\n         }\n\n         if(tokenbalanceA != 0 || tokenbalanceI != 0) {\n             require(\n                 channel.token.transfer(channel.partyAddresses[0], tokenbalanceA),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 channel.token.transfer(channel.partyAddresses[1], tokenbalanceI),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         channel.isOpen = false;\n         numChannels--;\n\n         emit DidLCClose(_lcID, channel.sequence, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI);\n     }\n\n     function _isContained(bytes32 _hash, bytes _proof, bytes32 _root) internal pure returns (bool) {\n         bytes32 cursor = _hash;\n         bytes32 proofElem;\n\n         for (uint256 i = 64; i <= _proof.length; i += 32) {\n             assembly { proofElem := mload(add(_proof, i)) }\n\n             if (cursor < proofElem) {\n                 cursor = keccak256(abi.encodePacked(cursor, proofElem));\n             } else {\n                 cursor = keccak256(abi.encodePacked(proofElem, cursor));\n             }\n         }\n\n         return cursor == _root;\n     }\n\n\n     function getChannel(bytes32 id) public view returns (\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     ) {\n         Channel memory channel = Channels[id];\n         return (\n             channel.partyAddresses,\n             channel.ethBalances,\n             channel.erc20Balances,\n             channel.initialDeposit,\n             channel.sequence,\n             channel.confirmTime,\n             channel.VCrootHash,\n             channel.LCopenTimeout,\n             channel.updateLCtimeout,\n             channel.isOpen,\n             channel.isUpdateLCSettling,\n             channel.numOpenVC\n         );\n     }\n\n     function getVirtualChannel(bytes32 id) public view returns(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     ) {\n         VirtualChannel memory virtualChannel = virtualChannels[id];\n         return(\n             virtualChannel.isClose,\n             virtualChannel.isInSettlementState,\n             virtualChannel.sequence,\n             virtualChannel.challenger,\n             virtualChannel.updateVCtimeout,\n             virtualChannel.partyA,\n             virtualChannel.partyB,\n             virtualChannel.partyI,\n             virtualChannel.ethBalances,\n             virtualChannel.erc20Balances,\n             virtualChannel.bond\n         );\n     }\n \n    // Unified dispatcher - merged from: LCOpenTimeout\n    // Selectors: LCOpenTimeout=0\n    function execute(uint8 _selector, bytes32 _lcID) public {\n        // Original: LCOpenTimeout()\n        if (_selector == 0) {\n            require(msg.sender == Channels[_lcID].partyAddresses[0] && Channels[_lcID].isOpen == false);\n            require(now > Channels[_lcID].LCopenTimeout);\n            if(Channels[_lcID].initialDeposit[0] != 0) {\n            Channels[_lcID].partyAddresses[0].transfer(Channels[_lcID].ethBalances[0]);\n            }\n            if(Channels[_lcID].initialDeposit[1] != 0) {\n            require(Channels[_lcID].token.transfer(Channels[_lcID].partyAddresses[0], Channels[_lcID].erc20Balances[0]),\"CreateChannel: token transfer failure\");\n            }\n            emit DidLCClose(_lcID, 0, Channels[_lcID].ethBalances[0], Channels[_lcID].erc20Balances[0], 0, 0);\n            delete Channels[_lcID];\n        }\n    }\n}",
      "merged_functions": [
        "LCOpenTimeout"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: LCOpenTimeout"
      ],
      "function_to_selector": {
        "LCOpenTimeout": 0
      },
      "error": null
    },
    {
      "original_id": "nc_ds_212",
      "transformed_id": "rs_mg_dis_nc_ds_212",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier onlyOwner()\n    {\n        require(msg.sender == owner);\n        _;\n    }\n\n   modifier isOpenToPublic()\n    {\n        require(openToPublic);\n        _;\n    }\n\n    modifier onlyRealPeople()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  onlyPlayers()\n    {\n        require (wagers[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 amount, address depositer);\n    event Win(uint256 amount, address paidTo);\n    event Lose(uint256 amount, address loser);\n    event Donate(uint256 amount, address paidTo, address donator);\n    event DifficultyChanged(uint256 currentDifficulty);\n    event BetLimitChanged(uint256 currentBetLimit);\n\n    address private whale;\n    uint256 betLimit;\n    uint difficulty;\n    uint private randomSeed;\n    address owner;\n    mapping(address => uint256) timestamps;\n    mapping(address => uint256) wagers;\n    bool openToPublic;\n    uint256 totalDonated;\n\n    constructor(address whaleAddress, uint256 wagerLimit)\n    onlyRealPeople()\n    public\n    {\n        openToPublic = false;\n        owner = msg.sender;\n        whale = whaleAddress;\n        totalDonated = 0;\n        betLimit = wagerLimit;\n\n    }\n\n    function OpenToThePublic()\n    onlyOwner()\n    public\n    {\n        openToPublic = true;\n    }\n\n    function AdjustBetAmounts(uint256 amount)\n    onlyOwner()\n    public\n    {\n        betLimit = amount;\n\n        emit BetLimitChanged(betLimit);\n    }\n\n    function AdjustDifficulty(uint256 amount)\n    onlyOwner()\n    public\n    {\n        difficulty = amount;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function wager()\n    isOpenToPublic()\n    onlyRealPeople()\n    payable\n    public\n    {\n\n        require(msg.value == betLimit);\n\n\n        require(wagers[msg.sender] == 0);\n\n\n        timestamps[msg.sender] = block.number;\n        wagers[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function play()\n    isOpenToPublic()\n    onlyRealPeople()\n    onlyPlayers()\n    public\n    {\n        uint256 blockNumber = timestamps[msg.sender];\n        if(blockNumber < block.number)\n        {\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n\n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n\n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else\n            {\n\n                loseWager(betLimit / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function donate()\n    isOpenToPublic()\n    public\n    payable\n    {\n        donateToWhale(msg.value);\n    }\n\n    function payout(address winner)\n    internal\n    {\n        uint256 ethToTransfer = address(this).balance / 2;\n\n        winner.transfer(ethToTransfer);\n        emit Win(ethToTransfer, winner);\n    }\n\n    function donateToWhale(uint256 amount)\n    internal\n    {\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Donate(amount, whale, msg.sender);\n    }\n\n    function loseWager(uint256 amount)\n    internal\n    {\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Lose(amount, msg.sender);\n    }\n\n    function ethBalance()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function currentDifficulty()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function currentBetLimit()\n    public\n    view\n    returns (uint256)\n    {\n        return betLimit;\n    }\n\n    function hasPlayerWagered(address player)\n    public\n    view\n    returns (bool)\n    {\n        if(wagers[player] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function winnersPot()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\n    public\n    onlyOwner()\n    returns (bool success)\n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}\n\n\ncontract ERC20Interface\n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n\n    // Unified dispatcher - merged from: OpenToThePublic, AdjustBetAmounts, AdjustDifficulty\n    // Selectors: OpenToThePublic=0, AdjustBetAmounts=1, AdjustDifficulty=2\n    function execute(uint8 _selector, uint256 amount) public {\n        // Original: OpenToThePublic()\n        if (_selector == 0) {\n            openToPublic = true;\n        }\n        // Original: AdjustBetAmounts()\n        else if (_selector == 1) {\n            betLimit = amount;\n            emit BetLimitChanged(betLimit);\n        }\n        // Original: AdjustDifficulty()\n        else if (_selector == 2) {\n            difficulty = amount;\n            emit DifficultyChanged(difficulty);\n        }\n    }\n}",
      "merged_functions": [
        "OpenToThePublic",
        "AdjustBetAmounts",
        "AdjustDifficulty"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: OpenToThePublic, AdjustBetAmounts, AdjustDifficulty"
      ],
      "function_to_selector": {
        "OpenToThePublic": 0,
        "AdjustBetAmounts": 1,
        "AdjustDifficulty": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_213",
      "transformed_id": "rs_mg_dis_nc_ds_213",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.11;\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; }\n\n\ncontract MigrationAgent {\n    function migrateFrom(address _from, uint256 _value);\n}\n\ncontract ERC20 {\n  uint public totalSupply;\n  function balanceOf(address who) constant returns (uint);\n  function allowance(address owner, address spender) constant returns (uint);\n\n  function transfer(address to, uint value) returns (bool ok);\n  function transferFrom(address from, address to, uint value) returns (bool ok);\n  function approve(address spender, uint value) returns (bool ok);\n  event Transfer(address indexed from, address indexed to, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract SafeMath {\n  function safeMul(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function safeDiv(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function safeSub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function safeAdd(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function max64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function min64(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function max256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function min256(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function assert(bool assertion) internal {\n    if (!assertion) {\n      throw;\n    }\n  }\n}\n\ncontract StandardToken is ERC20, SafeMath {\n\n\n  event Minted(address receiver, uint amount);\n\n\n  mapping(address => uint) balances;\n\n  mapping(address => uint) balancesRAW;\n\n  mapping (address => mapping (address => uint)) allowed;\n\n\n  function isToken() public constant returns (bool weAre) {\n    return true;\n  }\n\n  function transfer(address _to, uint _value) returns (bool success) {\n    balances[msg.sender] = safeSub(balances[msg.sender], _value);\n    balances[_to] = safeAdd(balances[_to], _value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferFrom(address _from, address _to, uint _value) returns (bool success) {\n    uint _allowance = allowed[_from][msg.sender];\n\n    balances[_to] = safeAdd(balances[_to], _value);\n    balances[_from] = safeSub(balances[_from], _value);\n    allowed[_from][msg.sender] = safeSub(_allowance, _value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint _value) returns (bool success) {\n\n\n    if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw;\n\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n\n}\n\n\ncontract daoPOLSKAtokens{\n\n    string public name = \"DAO POLSKA TOKEN version 1\";\n    string public symbol = \"DPL\";\n    uint8 public constant decimals = 18;\n\n\n    address public owner;\n    address public migrationMaster;\n\n\n    uint256 public otherchainstotalsupply =1.0 ether;\n    uint256 public supplylimit      = 10000.0 ether;\n\n   uint256 public  totalSupply      = 0.0 ether;\n\n\taddress public Chain1 = 0x0;\n\taddress public Chain2 = 0x0;\n\taddress public Chain3 = 0x0;\n\taddress public Chain4 = 0x0;\n\n\taddress public migrationAgent=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\n    uint256 public totalMigrated;\n\n    event Migrate(address indexed _from, address indexed _to, uint256 _value);\n    event Refund(address indexed _from, uint256 _value);\n\n\tstruct sendTokenAway{\n\t\tStandardToken coinContract;\n\t\tuint amount;\n\t\taddress recipient;\n\t}\n\tmapping(uint => sendTokenAway) transfers;\n\tuint numTransfers=0;\n\n  mapping (address => uint256) balances;\nmapping (address => uint256) balancesRAW;\n  mapping (address => mapping (address => uint256)) allowed;\n\n\tevent UpdatedTokenInformation(string newName, string newSymbol);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n\tevent receivedEther(address indexed _from,uint256 _value);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n\n    event Burn(address indexed from, uint256 value);\n\n  bool public supplylimitset = false;\n  bool public otherchainstotalset = false;\n\n  function daoPOLSKAtokens() {\nowner=msg.sender;\nmigrationMaster=msg.sender;\n}\n\nfunction  setSupply(uint256 supplyLOCKER) public {\n    \t   if (msg.sender != owner) {\n      throw;\n    }\n\t\t    \t   if (supplylimitset != false) {\n      throw;\n    }\n\tsupplylimitset = true;\n\n\tsupplylimit = supplyLOCKER ** uint256(decimals);\n\n  }\nfunction setotherchainstotalsupply(uint256 supplyLOCKER) public {\n    \t   if (msg.sender != owner) {\n      throw;\n    }\n\t    \t   if (supplylimitset != false) {\n      throw;\n    }\n\n\totherchainstotalset = true;\n\totherchainstotalsupply = supplyLOCKER ** uint256(decimals);\n\n  }\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    function burn(uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        totalSupply -= _value;\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    function burnFrom(address _from, uint256 _value) public returns (bool success) {\n        require(balances[_from] >= _value);\n        require(_value <= allowed[_from][msg.sender]);\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        totalSupply -= _value;\n        Burn(_from, _value);\n        return true;\n    }\n\n  function transfer(address _to, uint256 _value) returns (bool success) {\n\n\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n\n      balances[msg.sender] -= _value;\n      balances[_to] += _value;\n      Transfer(msg.sender, _to, _value);\n      return true;\n    } else { return false; }\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n\n      balances[_to] += _value;\n      balances[_from] -= _value;\n      allowed[_from][msg.sender] -= _value;\n      Transfer(_from, _to, _value);\n      return true;\n    } else { return false; }\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n\t    function () payable  public {\n\t\t if(funding){\n        receivedEther(msg.sender, msg.value);\n\t\tbalances[msg.sender]=balances[msg.sender]+msg.value;\n\t\t} else throw;\n\n    }\n\n  function setTokenInformation(string _name, string _symbol) {\n\n\t   if (msg.sender != owner) {\n      throw;\n    }\n\tname = _name;\n    symbol = _symbol;\n\n    UpdatedTokenInformation(name, symbol);\n  }\n\nfunction setChainsAddresses(address chainAd, int chainnumber) {\n\n\t   if (msg.sender != owner) {\n      throw;\n    }\n\tif(chainnumber==1){Chain1=chainAd;}\n\tif(chainnumber==2){Chain2=chainAd;}\n\tif(chainnumber==3){Chain3=chainAd;}\n\tif(chainnumber==4){Chain4=chainAd;}\n  }\n\n  function DAOPolskaTokenICOregulations() external returns(string wow) {\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\n}\n\n\n\tfunction sendTokenAw(address StandardTokenAddress, address receiver, uint amount){\n\t\tif (msg.sender != owner) {\n\t\tthrow;\n\t\t}\n\t\tsendTokenAway t = transfers[numTransfers];\n\t\tt.coinContract = StandardToken(StandardTokenAddress);\n\t\tt.amount = amount;\n\t\tt.recipient = receiver;\n\t\tt.coinContract.transfer(receiver, amount);\n\t\tnumTransfers++;\n\t}\n\n\nuint public tokenCreationRate=1000;\nuint public bonusCreationRate=1000;\nuint public CreationRate=1761;\n   uint256 public constant oneweek = 36000;\nuint256 public fundingEndBlock = 5433616;\nbool public funding = true;\nbool public refundstate = false;\nbool public migratestate= false;\n        function createDaoPOLSKAtokens(address holder) payable {\n\n        if (!funding) throw;\n\n\n        if (msg.value == 0) throw;\n\n        if (msg.value > (supplylimit - totalSupply) / CreationRate)\n          throw;\n\n\n\t var numTokensRAW = msg.value;\n\n        var numTokens = msg.value * CreationRate;\n        totalSupply += numTokens;\n\n\n        balances[holder] += numTokens;\n        balancesRAW[holder] += numTokensRAW;\n\n        Transfer(0, holder, numTokens);\n\n\n        uint256 percentOfTotal = 12;\n        uint256 additionalTokens = \tnumTokens * percentOfTotal / (100);\n\n        totalSupply += additionalTokens;\n\n        balances[migrationMaster] += additionalTokens;\n        Transfer(0, migrationMaster, additionalTokens);\n\n\t}\n\tfunction setBonusCreationRate(uint newRate){\n\tif(msg.sender == owner) {\n\tbonusCreationRate=newRate;\n\tCreationRate=tokenCreationRate+bonusCreationRate;\n\t}\n\t}\n\n    function FundsTransfer() external {\n\tif(funding==true) throw;\n\t\t \tif (!owner.send(this.balance)) throw;\n    }\n\n    function PartialFundsTransfer(uint SubX) external {\n\t      if (msg.sender != owner) throw;\n        owner.send(this.balance - SubX);\n\t}\n\tfunction turnrefund() external {\n\t      if (msg.sender != owner) throw;\n\trefundstate=!refundstate;\n        }\n\n\t\t\tfunction fundingState() external {\n\t      if (msg.sender != owner) throw;\n\tfunding=!funding;\n        }\n    function turnmigrate() external {\n\t      if (msg.sender != migrationMaster) throw;\n\tmigratestate=!migratestate;\n}\n\n\nfunction finalize() external {\n        if (block.number <= fundingEndBlock+8*oneweek) throw;\n\n        funding = false;\n\t\trefundstate=!refundstate;\n\n        if (msg.sender==owner)\n\t\towner.send(this.balance);\n    }\n    function migrate(uint256 _value) external {\n\n        if (migratestate) throw;\n\n\n        if (_value == 0) throw;\n        if (_value > balances[msg.sender]) throw;\n\n        balances[msg.sender] -= _value;\n        totalSupply -= _value;\n        totalMigrated += _value;\n        MigrationAgent(migrationAgent).migrateFrom(msg.sender, _value);\n        Migrate(msg.sender, migrationAgent, _value);\n    }\n\nfunction refundTRA() external {\n\n        if (funding) throw;\n        if (!refundstate) throw;\n\n        var DAOPLTokenValue = balances[msg.sender];\n        var ETHValue = balancesRAW[msg.sender];\n        if (ETHValue == 0) throw;\n        balancesRAW[msg.sender] = 0;\n        totalSupply -= DAOPLTokenValue;\n\n        Refund(msg.sender, ETHValue);\n        msg.sender.transfer(ETHValue);\n}\n\nfunction preICOregulations() external returns(string wow) {\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\n}\n\n\n    // Unified dispatcher - merged from: PartialFundsTransfer, isToken\n    // Selectors: PartialFundsTransfer=0, isToken=2\n    function execute(uint8 _selector, uint SubX) public {\n        // Original: PartialFundsTransfer()\n        if (_selector == 0) {\n            if (msg.sender != owner) throw;\n            owner.send(this.balance - SubX);\n        }\n        // Original: isToken()\n        else if (_selector == 1) {\n            return true;\n        }\n    }\n}",
      "merged_functions": [
        "PartialFundsTransfer",
        "isToken"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: PartialFundsTransfer, isToken"
      ],
      "function_to_selector": {
        "PartialFundsTransfer": 0,
        "isToken": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_214",
      "transformed_id": "rs_mg_dis_nc_ds_214",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_ds_215",
      "transformed_id": "rs_mg_dis_nc_ds_215",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier onlyOwner()\n    {\n        require(msg.sender == owner);\n        _;\n    }\n\n   modifier isOpenToPublic()\n    {\n        require(openToPublic);\n        _;\n    }\n\n    modifier onlyRealPeople()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  onlyPlayers()\n    {\n        require (wagers[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 amount, address depositer);\n    event Win(uint256 amount, address paidTo);\n    event Lose(uint256 amount, address loser);\n    event Donate(uint256 amount, address paidTo, address donator);\n    event DifficultyChanged(uint256 currentDifficulty);\n    event BetLimitChanged(uint256 currentBetLimit);\n\n    address private whale;\n    uint256 betLimit;\n    uint difficulty;\n    uint private randomSeed;\n    address owner;\n    mapping(address => uint256) timestamps;\n    mapping(address => uint256) wagers;\n    bool openToPublic;\n    uint256 totalDonated;\n\n    constructor(address whaleAddress, uint256 wagerLimit)\n    onlyRealPeople()\n    public\n    {\n        openToPublic = false;\n        owner = msg.sender;\n        whale = whaleAddress;\n        totalDonated = 0;\n        betLimit = wagerLimit;\n\n    }\n\n    function OpenToThePublic()\n    onlyOwner()\n    public\n    {\n        openToPublic = true;\n    }\n\n    function AdjustBetAmounts(uint256 amount)\n    onlyOwner()\n    public\n    {\n        betLimit = amount;\n\n        emit BetLimitChanged(betLimit);\n    }\n\n    function AdjustDifficulty(uint256 amount)\n    onlyOwner()\n    public\n    {\n        difficulty = amount;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function wager()\n    isOpenToPublic()\n    onlyRealPeople()\n    payable\n    public\n    {\n\n        require(msg.value == betLimit);\n\n\n        timestamps[msg.sender] = block.number;\n        wagers[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function play()\n    isOpenToPublic()\n    onlyRealPeople()\n    onlyPlayers()\n    public\n    {\n        uint256 blockNumber = timestamps[msg.sender];\n        if(blockNumber < block.number)\n        {\n            timestamps[msg.sender] = 0;\n            wagers[msg.sender] = 0;\n\n            uint256 winningNumber = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  msg.sender)))%difficulty +1;\n\n            if(winningNumber == difficulty / 2)\n            {\n                payout(msg.sender);\n            }\n            else\n            {\n\n                loseWager(betLimit / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function donate()\n    isOpenToPublic()\n    public\n    payable\n    {\n        donateToWhale(msg.value);\n    }\n\n    function payout(address winner)\n    internal\n    {\n        uint256 ethToTransfer = address(this).balance / 2;\n\n        winner.transfer(ethToTransfer);\n        emit Win(ethToTransfer, winner);\n    }\n\n    function donateToWhale(uint256 amount)\n    internal\n    {\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Donate(amount, whale, msg.sender);\n    }\n\n    function loseWager(uint256 amount)\n    internal\n    {\n        whale.call.value(amount)(bytes4(keccak256(\"donate()\")));\n        totalDonated += amount;\n        emit Lose(amount, msg.sender);\n    }\n\n    function ethBalance()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function currentDifficulty()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function currentBetLimit()\n    public\n    view\n    returns (uint256)\n    {\n        return betLimit;\n    }\n\n    function hasPlayerWagered(address player)\n    public\n    view\n    returns (bool)\n    {\n        if(wagers[player] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function winnersPot()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\n    public\n    onlyOwner()\n    returns (bool success)\n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}\n\n\ncontract ERC20Interface\n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n\n    // Unified dispatcher - merged from: OpenToThePublic, AdjustBetAmounts, AdjustDifficulty\n    // Selectors: OpenToThePublic=0, AdjustBetAmounts=1, AdjustDifficulty=2\n    function execute(uint8 _selector, uint256 amount) public {\n        // Original: OpenToThePublic()\n        if (_selector == 0) {\n            openToPublic = true;\n        }\n        // Original: AdjustBetAmounts()\n        else if (_selector == 1) {\n            betLimit = amount;\n            emit BetLimitChanged(betLimit);\n        }\n        // Original: AdjustDifficulty()\n        else if (_selector == 2) {\n            difficulty = amount;\n            emit DifficultyChanged(difficulty);\n        }\n    }\n}",
      "merged_functions": [
        "OpenToThePublic",
        "AdjustBetAmounts",
        "AdjustDifficulty"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: OpenToThePublic, AdjustBetAmounts, AdjustDifficulty"
      ],
      "function_to_selector": {
        "OpenToThePublic": 0,
        "AdjustBetAmounts": 1,
        "AdjustDifficulty": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_216",
      "transformed_id": "rs_mg_dis_nc_ds_216",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract FiftyFlip {\n    uint constant DONATING_X = 20;\n\n\n    uint constant JACKPOT_FEE = 10;\n    uint constant JACKPOT_MODULO = 1000;\n    uint constant DEV_FEE = 20;\n    uint constant WIN_X = 1900;\n\n\n    uint constant MIN_BET = 0.01 ether;\n    uint constant MAX_BET = 1 ether;\n\n    uint constant BET_EXPIRATION_BLOCKS = 250;\n\n\n    address public owner;\n    address public autoPlayBot;\n    address public secretSigner;\n    address private whale;\n\n\n    uint256 public jackpotSize;\n    uint256 public devFeeSize;\n\n\n    uint256 public lockedInBets;\n    uint256 public totalAmountToWhale;\n\n    struct Bet {\n\n        uint amount;\n\n        uint256 blockNumber;\n\n        bool betMask;\n\n        address player;\n    }\n\n    mapping (uint => Bet) bets;\n    mapping (address => uint) donateAmount;\n\n\n    event Wager(uint ticketID, uint betAmount, uint256 betBlockNumber, bool betMask, address betPlayer);\n    event Win(address winner, uint amount, uint ticketID, bool maskRes, uint jackpotRes);\n    event Lose(address loser, uint amount, uint ticketID, bool maskRes, uint jackpotRes);\n    event Refund(uint ticketID, uint256 amount, address requester);\n    event Donate(uint256 amount, address donator);\n    event FailedPayment(address paidUser, uint amount);\n    event Payment(address noPaidUser, uint amount);\n    event JackpotPayment(address player, uint ticketID, uint jackpotWin);\n\n\n    constructor (address whaleAddress, address autoPlayBotAddress, address secretSignerAddress) public {\n        owner = msg.sender;\n        autoPlayBot = autoPlayBotAddress;\n        whale = whaleAddress;\n        secretSigner = secretSignerAddress;\n        jackpotSize = 0;\n        devFeeSize = 0;\n        lockedInBets = 0;\n        totalAmountToWhale = 0;\n    }\n\n\n    modifier onlyOwner() {\n        require (msg.sender == owner, \"You are not the owner of this contract!\");\n        _;\n    }\n\n    modifier onlyBot() {\n        require (msg.sender == autoPlayBot, \"You are not the bot of this contract!\");\n        _;\n    }\n\n    modifier checkContractHealth() {\n        require (address(this).balance >= lockedInBets + jackpotSize + devFeeSize, \"This contract doesn't have enough balance, it is stopped till someone donate to this game!\");\n        _;\n    }\n\n\n    function() public payable { }\n\n    function setBotAddress(address autoPlayBotAddress)\n    onlyOwner()\n    external\n    {\n        autoPlayBot = autoPlayBotAddress;\n    }\n\n    function setSecretSigner(address _secretSigner)\n    onlyOwner()\n    external\n    {\n        secretSigner = _secretSigner;\n    }\n\n\n    function wager(bool bMask, uint ticketID, uint ticketLastBlock, uint8 v, bytes32 r, bytes32 s)\n    checkContractHealth()\n    external\n    payable {\n        Bet storage bet = bets[ticketID];\n        uint amount = msg.value;\n        address player = msg.sender;\n        require (bet.player == address(0), \"Ticket is not new one!\");\n        require (amount >= MIN_BET, \"Your bet is lower than minimum bet amount\");\n        require (amount <= MAX_BET, \"Your bet is higher than maximum bet amount\");\n        require (getCollateralBalance() >= 2 * amount, \"If we accept this, this contract will be in danger!\");\n\n        require (block.number <= ticketLastBlock, \"Ticket has expired.\");\n        bytes32 signatureHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n37', uint40(ticketLastBlock), ticketID));\n        require (secretSigner == ecrecover(signatureHash, v, r, s), \"web3 vrs signature is not valid.\");\n\n        jackpotSize += amount * JACKPOT_FEE / 1000;\n        devFeeSize += amount * DEV_FEE / 1000;\n        lockedInBets += amount * WIN_X / 1000;\n\n        uint donate_amount = amount * DONATING_X / 1000;\n        whale.call.value(donate_amount)(bytes4(keccak256(\"donate()\")));\n        totalAmountToWhale += donate_amount;\n\n        bet.amount = amount;\n        bet.blockNumber = block.number;\n        bet.betMask = bMask;\n        bet.player = player;\n\n        emit Wager(ticketID, bet.amount, bet.blockNumber, bet.betMask, bet.player);\n    }\n\n\n    function play(uint ticketReveal)\n    checkContractHealth()\n    external\n    {\n        uint ticketID = uint(keccak256(abi.encodePacked(ticketReveal)));\n        Bet storage bet = bets[ticketID];\n        require (bet.player != address(0), \"TicketID is not correct!\");\n        require (bet.amount != 0, \"Ticket is already used one!\");\n        uint256 blockNumber = bet.blockNumber;\n        if(blockNumber < block.number && blockNumber >= block.number - BET_EXPIRATION_BLOCKS)\n        {\n            uint256 random = uint256(keccak256(abi.encodePacked(blockhash(blockNumber),  ticketReveal)));\n            bool maskRes = (random % 2) !=0;\n            uint jackpotRes = random % JACKPOT_MODULO;\n\n            uint tossWinAmount = bet.amount * WIN_X / 1000;\n\n            uint tossWin = 0;\n            uint jackpotWin = 0;\n\n            if(bet.betMask == maskRes) {\n                tossWin = tossWinAmount;\n            }\n            if(jackpotRes == 0) {\n                jackpotWin = jackpotSize;\n                jackpotSize = 0;\n            }\n            if (jackpotWin > 0) {\n                emit JackpotPayment(bet.player, ticketID, jackpotWin);\n            }\n            if(tossWin + jackpotWin > 0)\n            {\n                payout(bet.player, tossWin + jackpotWin, ticketID, maskRes, jackpotRes);\n            }\n            else\n            {\n                loseWager(bet.player, bet.amount, ticketID, maskRes, jackpotRes);\n            }\n            lockedInBets -= tossWinAmount;\n            bet.amount = 0;\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function donateForContractHealth()\n    external\n    payable\n    {\n        donateAmount[msg.sender] += msg.value;\n        emit Donate(msg.value, msg.sender);\n    }\n\n    function withdrawDonation(uint amount)\n    external\n    {\n        require(donateAmount[msg.sender] >= amount, \"You are going to withdraw more than you donated!\");\n\n        if (sendFunds(msg.sender, amount)){\n            donateAmount[msg.sender] -= amount;\n        }\n    }\n\n\n    function refund(uint ticketID)\n    checkContractHealth()\n    external {\n        Bet storage bet = bets[ticketID];\n\n        require (bet.amount != 0, \"this ticket has no balance\");\n        require (block.number > bet.blockNumber + BET_EXPIRATION_BLOCKS, \"this ticket is expired.\");\n        sendRefund(ticketID);\n    }\n\n\n    function withdrawDevFee(address withdrawAddress, uint withdrawAmount)\n    onlyOwner()\n    checkContractHealth()\n    external {\n        require (devFeeSize >= withdrawAmount, \"You are trying to withdraw more amount than developer fee.\");\n        require (withdrawAmount <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (devFeeSize <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (sendFunds(withdrawAddress, withdrawAmount)){\n            devFeeSize -= withdrawAmount;\n        }\n    }\n\n\n    function withdrawBotFee(uint withdrawAmount)\n    onlyBot()\n    checkContractHealth()\n    external {\n        require (devFeeSize >= withdrawAmount, \"You are trying to withdraw more amount than developer fee.\");\n        require (withdrawAmount <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (devFeeSize <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (sendFunds(autoPlayBot, withdrawAmount)){\n            devFeeSize -= withdrawAmount;\n        }\n    }\n\n\n    function getBetInfo(uint ticketID)\n    constant\n    external\n    returns (uint, uint256, bool, address){\n        Bet storage bet = bets[ticketID];\n        return (bet.amount, bet.blockNumber, bet.betMask, bet.player);\n    }\n\n\n    function getContractBalance()\n    constant\n    external\n    returns (uint){\n        return address(this).balance;\n    }\n\n\n    function getCollateralBalance()\n    constant\n    public\n    returns (uint){\n        if (address(this).balance > lockedInBets + jackpotSize + devFeeSize)\n            return address(this).balance - lockedInBets - jackpotSize - devFeeSize;\n        return 0;\n    }\n\n\n    function kill() external onlyOwner() {\n        require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n        selfdestruct(owner);\n    }\n\n\n    function payout(address winner, uint ethToTransfer, uint ticketID, bool maskRes, uint jackpotRes)\n    internal\n    {\n        winner.transfer(ethToTransfer);\n        emit Win(winner, ethToTransfer, ticketID, maskRes, jackpotRes);\n    }\n\n\n    function sendRefund(uint ticketID)\n    internal\n    {\n        Bet storage bet = bets[ticketID];\n        address requester = bet.player;\n        uint256 ethToTransfer = bet.amount;\n        requester.transfer(ethToTransfer);\n\n        uint tossWinAmount = bet.amount * WIN_X / 1000;\n        lockedInBets -= tossWinAmount;\n\n        bet.amount = 0;\n        emit Refund(ticketID, ethToTransfer, requester);\n    }\n\n\n    function sendFunds(address paidUser, uint amount) private returns (bool){\n        bool success = paidUser.send(amount);\n        if (success) {\n            emit Payment(paidUser, amount);\n        } else {\n            emit FailedPayment(paidUser, amount);\n        }\n        return success;\n    }\n\n    function loseWager(address player, uint amount, uint ticketID, bool maskRes, uint jackpotRes)\n    internal\n    {\n        emit Lose(player, amount, ticketID, maskRes, jackpotRes);\n    }\n\n\n    function clearStorage(uint[] toCleanTicketIDs) external {\n        uint length = toCleanTicketIDs.length;\n\n        for (uint i = 0; i < length; i++) {\n            clearProcessedBet(toCleanTicketIDs[i]);\n        }\n    }\n\n\n    function clearProcessedBet(uint ticketID) private {\n        Bet storage bet = bets[ticketID];\n\n\n        if (bet.amount != 0 || block.number <= bet.blockNumber + BET_EXPIRATION_BLOCKS) {\n            return;\n        }\n\n        bet.blockNumber = 0;\n        bet.betMask = false;\n        bet.player = address(0);\n    }\n\n\n    function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens)\n    public\n    onlyOwner()\n    returns (bool success)\n    {\n        return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens);\n    }\n}\n\n\ncontract ERC20Interface\n{\n    function transfer(address to, uint256 tokens) public returns (bool success);\n\n    // Unified dispatcher - merged from: wager, setBotAddress, setSecretSigner\n    // Selectors: wager=0, setBotAddress=1, setSecretSigner=2\n    function execute(uint8 _selector, address _secretSigner, address autoPlayBotAddress, bool bMask, bytes32 r, bytes32 s, uint ticketID, uint ticketLastBlock, uint8 v) public payable {\n        // Original: wager()\n        if (_selector == 0) {\n            Bet storage bet = bets[ticketID];\n            uint amount = msg.value;\n            address player = msg.sender;\n            require (bet.player == address(0), \"Ticket is not new one!\");\n            require (amount >= MIN_BET, \"Your bet is lower than minimum bet amount\");\n            require (amount <= MAX_BET, \"Your bet is higher than maximum bet amount\");\n            require (getCollateralBalance() >= 2 * amount, \"If we accept this, this contract will be in danger!\");\n            require (block.number <= ticketLastBlock, \"Ticket has expired.\");\n            bytes32 signatureHash = keccak256(abi.encodePacked('\\x19Ethereum Signed Message:\\n37', uint40(ticketLastBlock), ticketID));\n            require (secretSigner == ecrecover(signatureHash, v, r, s), \"web3 vrs signature is not valid.\");\n            jackpotSize += amount * JACKPOT_FEE / 1000;\n            devFeeSize += amount * DEV_FEE / 1000;\n            lockedInBets += amount * WIN_X / 1000;\n            uint donate_amount = amount * DONATING_X / 1000;\n            whale.call.value(donate_amount)(bytes4(keccak256(\"donate()\")));\n            totalAmountToWhale += donate_amount;\n            bet.amount = amount;\n            bet.blockNumber = block.number;\n            bet.betMask = bMask;\n            bet.player = player;\n            emit Wager(ticketID, bet.amount, bet.blockNumber, bet.betMask, bet.player);\n        }\n        // Original: setBotAddress()\n        else if (_selector == 1) {\n            autoPlayBot = autoPlayBotAddress;\n        }\n        // Original: setSecretSigner()\n        else if (_selector == 2) {\n            secretSigner = _secretSigner;\n        }\n    }\n}",
      "merged_functions": [
        "wager",
        "setBotAddress",
        "setSecretSigner"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: wager, setBotAddress, setSecretSigner"
      ],
      "function_to_selector": {
        "wager": 0,
        "setBotAddress": 1,
        "setSecretSigner": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_232",
      "transformed_id": "rs_mg_dis_nc_ds_232",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\nlibrary SafeMath {\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a / b;\n\n    return c;\n  }\n\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint256 public totalSupply;\n  function balanceOf(address who) public constant returns (uint256);\n  function transfer(address to, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) balances;\n\n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[msg.sender]);\n\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) public constant returns (uint256);\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\n  function approve(address spender, uint256 value) public returns (bool);\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal allowed;\n\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n    require(_value > 0 && _value <= balances[_from]);\n    require(_value <= allowed[_from][msg.sender]);\n\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    Transfer(_from, _to, _value);\n    return true;\n  }\n\n  function approve(address _spender, uint256 _value) public returns (bool) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    return true;\n  }\n\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\ncontract Ownable {\n  address public owner;\n\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n  function Ownable() {\n    owner = msg.sender;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  function transferOwnership(address newOwner) onlyOwner public {\n    require(newOwner != address(0));\n    OwnershipTransferred(owner, newOwner);\n    owner = newOwner;\n  }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    Pause();\n  }\n\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    Unpause();\n  }\n}\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transfer(_to, _value);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\n    return super.transferFrom(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\n    return super.approve(_spender, _value);\n  }\n\n  function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) {\n    uint cnt = _receivers.length;\n    uint256 amount = uint256(cnt) * _value;\n    require(cnt > 0 && cnt <= 20);\n    require(_value > 0 && balances[msg.sender] >= amount);\n\n    balances[msg.sender] = balances[msg.sender].sub(amount);\n    for (uint i = 0; i < cnt; i++) {\n        balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n        Transfer(msg.sender, _receivers[i], _value);\n    }\n    return true;\n  }\n}\n\ncontract BecToken is PausableToken {\n    string public name = \"BeautyChain\";\n    string public symbol = \"BEC\";\n    string public version = '1.0.0';\n    uint8 public decimals = 18;\n\n    function BecToken() {\n      totalSupply = 7000000000 * (10**(uint256(decimals)));\n      balances[msg.sender] = totalSupply;\n    }\n\n    function () {\n\n        revert();\n    }\n\n    // Unified dispatcher - merged from: batchTransfer\n    // Selectors: batchTransfer=0\n    function execute(uint8 _selector, address[] _receivers, uint256 _value) public {\n        // Original: batchTransfer()\n        if (_selector == 0) {\n            uint cnt = _receivers.length;\n            uint256 amount = uint256(cnt) * _value;\n            require(cnt > 0 && cnt <= 20);\n            require(_value > 0 && balances[msg.sender] >= amount);\n            balances[msg.sender] = balances[msg.sender].sub(amount);\n            for (uint i = 0; i < cnt; i++) {\n            balances[_receivers[i]] = balances[_receivers[i]].add(_value);\n            Transfer(msg.sender, _receivers[i], _value);\n            }\n            return true;\n        }\n    }\n}",
      "merged_functions": [
        "batchTransfer"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: batchTransfer"
      ],
      "function_to_selector": {
        "batchTransfer": 0
      },
      "error": null
    },
    {
      "original_id": "nc_ds_233",
      "transformed_id": "rs_mg_dis_nc_ds_233",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\nlibrary Deck {\n\n\n\tfunction deal(address player, uint8 cardNumber) internal returns (uint8) {\n\t\tuint b = block.number;\n\t\tuint timestamp = block.timestamp;\n\t\treturn uint8(uint256(keccak256(block.blockhash(b), player, cardNumber, timestamp)) % 52);\n\t}\n\n\tfunction valueOf(uint8 card, bool isBigAce) internal constant returns (uint8) {\n\t\tuint8 value = card / 4;\n\t\tif (value == 0 || value == 11 || value == 12) {\n\t\t\treturn 10;\n\t\t}\n\t\tif (value == 1 && isBigAce) {\n\t\t\treturn 11;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction isAce(uint8 card) internal constant returns (bool) {\n\t\treturn card / 4 == 1;\n\t}\n\n\tfunction isTen(uint8 card) internal constant returns (bool) {\n\t\treturn card / 4 == 10;\n\t}\n}\n\ncontract BlackJack {\n\tusing Deck for *;\n\n\tuint public minBet = 50 finney;\n\tuint public maxBet = 5 ether;\n\n\tuint8 BLACKJACK = 21;\n\n  enum GameState { Ongoing, Player, Tie, House }\n\n\tstruct Game {\n\t\taddress player;\n\t\tuint bet;\n\n\t\tuint8[] houseCards;\n\t\tuint8[] playerCards;\n\n\t\tGameState state;\n\t\tuint8 cardsDealt;\n\t}\n\n\tmapping (address => Game) public games;\n\n\tmodifier gameIsGoingOn() {\n\t\tif (games[msg.sender].player == 0 || games[msg.sender].state != GameState.Ongoing) {\n\t\t\tthrow;\n\t\t}\n\t\t_;\n\t}\n\n\tevent Deal(\n        bool isUser,\n        uint8 _card\n    );\n\n    event GameStatus(\n    \tuint8 houseScore,\n    \tuint8 houseScoreBig,\n    \tuint8 playerScore,\n    \tuint8 playerScoreBig\n    );\n\n    event Log(\n    \tuint8 value\n    );\n\n\tfunction BlackJack() {\n\n\t}\n\n\tfunction () payable {\n\n\t}\n\n\n\tfunction deal() public payable {\n\t\tif (games[msg.sender].player != 0 && games[msg.sender].state == GameState.Ongoing) {\n\t\t\tthrow;\n\t\t}\n\n\t\tif (msg.value < minBet || msg.value > maxBet) {\n\t\t\tthrow;\n\t\t}\n\n\t\tuint8[] memory houseCards = new uint8[](1);\n\t\tuint8[] memory playerCards = new uint8[](2);\n\n\n\t\tplayerCards[0] = Deck.deal(msg.sender, 0);\n\t\tDeal(true, playerCards[0]);\n\t\thouseCards[0] = Deck.deal(msg.sender, 1);\n\t\tDeal(false, houseCards[0]);\n\t\tplayerCards[1] = Deck.deal(msg.sender, 2);\n\t\tDeal(true, playerCards[1]);\n\n\t\tgames[msg.sender] = Game({\n\t\t\tplayer: msg.sender,\n\t\t\tbet: msg.value,\n\t\t\thouseCards: houseCards,\n\t\t\tplayerCards: playerCards,\n\t\t\tstate: GameState.Ongoing,\n\t\t\tcardsDealt: 3\n\t\t});\n\n\t\tcheckGameResult(games[msg.sender], false);\n\t}\n\n\n\tfunction hit() public gameIsGoingOn {\n\t\tuint8 nextCard = games[msg.sender].cardsDealt;\n\t\tgames[msg.sender].playerCards.push(Deck.deal(msg.sender, nextCard));\n\t\tgames[msg.sender].cardsDealt = nextCard + 1;\n\t\tDeal(true, games[msg.sender].playerCards[games[msg.sender].playerCards.length - 1]);\n\t\tcheckGameResult(games[msg.sender], false);\n\t}\n\n\n\tfunction stand() public gameIsGoingOn {\n\n\t\tvar (houseScore, houseScoreBig) = calculateScore(games[msg.sender].houseCards);\n\n\t\twhile (houseScoreBig < 17) {\n\t\t\tuint8 nextCard = games[msg.sender].cardsDealt;\n\t\t\tuint8 newCard = Deck.deal(msg.sender, nextCard);\n\t\t\tgames[msg.sender].houseCards.push(newCard);\n\t\t\tgames[msg.sender].cardsDealt = nextCard + 1;\n\t\t\thouseScoreBig += Deck.valueOf(newCard, true);\n\t\t\tDeal(false, newCard);\n\t\t}\n\n\t\tcheckGameResult(games[msg.sender], true);\n\t}\n\n\n\tfunction checkGameResult(Game game, bool finishGame) private {\n\n\t\tvar (houseScore, houseScoreBig) = calculateScore(game.houseCards);\n\n\t\tvar (playerScore, playerScoreBig) = calculateScore(game.playerCards);\n\n\t\tGameStatus(houseScore, houseScoreBig, playerScore, playerScoreBig);\n\n\t\tif (houseScoreBig == BLACKJACK || houseScore == BLACKJACK) {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\n\t\t\t\tif (!msg.sender.send(game.bet)) throw;\n\t\t\t\tgames[msg.sender].state = GameState.Tie;\n\t\t\t\treturn;\n\t\t\t} else {\n\n\t\t\t\tgames[msg.sender].state = GameState.House;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\n\t\t\t\tif (game.playerCards.length == 2 && (Deck.isTen(game.playerCards[0]) || Deck.isTen(game.playerCards[1]))) {\n\n\t\t\t\t\tif (!msg.sender.send((game.bet * 5) / 2)) throw;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (!msg.sender.send(game.bet * 2)) throw;\n\t\t\t\t}\n\t\t\t\tgames[msg.sender].state = GameState.Player;\n\t\t\t\treturn;\n\t\t\t} else {\n\n\t\t\t\tif (playerScore > BLACKJACK) {\n\n\t\t\t\t\tLog(1);\n\t\t\t\t\tgames[msg.sender].state = GameState.House;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!finishGame) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\t\t\t\tuint8 playerShortage = 0;\n\t\t\t\tuint8 houseShortage = 0;\n\n\n\t\t\t\tif (playerScoreBig > BLACKJACK) {\n\t\t\t\t\tif (playerScore > BLACKJACK) {\n\n\t\t\t\t\t\tgames[msg.sender].state = GameState.House;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplayerShortage = BLACKJACK - playerScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tplayerShortage = BLACKJACK - playerScoreBig;\n\t\t\t\t}\n\n\t\t\t\tif (houseScoreBig > BLACKJACK) {\n\t\t\t\t\tif (houseScore > BLACKJACK) {\n\n\t\t\t\t\t\tif (!msg.sender.send(game.bet * 2)) throw;\n\t\t\t\t\t\tgames[msg.sender].state = GameState.Player;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thouseShortage = BLACKJACK - houseScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thouseShortage = BLACKJACK - houseScoreBig;\n\t\t\t\t}\n\n\n\t\t\t\tif (houseShortage == playerShortage) {\n\n\t\t\t\t\tif (!msg.sender.send(game.bet)) throw;\n\t\t\t\t\tgames[msg.sender].state = GameState.Tie;\n\t\t\t\t} else if (houseShortage > playerShortage) {\n\n\t\t\t\t\tif (!msg.sender.send(game.bet * 2)) throw;\n\t\t\t\t\tgames[msg.sender].state = GameState.Player;\n\t\t\t\t} else {\n\t\t\t\t\tgames[msg.sender].state = GameState.House;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction calculateScore(uint8[] cards) private constant returns (uint8, uint8) {\n\t\tuint8 score = 0;\n\t\tuint8 scoreBig = 0;\n\t\tbool bigAceUsed = false;\n\t\tfor (uint i = 0; i < cards.length; ++i) {\n\t\t\tuint8 card = cards[i];\n\t\t\tif (Deck.isAce(card) && !bigAceUsed) {\n\t\t\t\tscoreBig += Deck.valueOf(card, true);\n\t\t\t\tbigAceUsed = true;\n\t\t\t} else {\n\t\t\t\tscoreBig += Deck.valueOf(card, false);\n\t\t\t}\n\t\t\tscore += Deck.valueOf(card, false);\n\t\t}\n\t\treturn (score, scoreBig);\n\t}\n\n\tfunction getPlayerCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif (id < 0 || id > games[msg.sender].playerCards.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn games[msg.sender].playerCards[id];\n\t}\n\n\tfunction getHouseCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif (id < 0 || id > games[msg.sender].houseCards.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn games[msg.sender].houseCards[id];\n\t}\n\n\tfunction getPlayerCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn games[msg.sender].playerCards.length;\n\t}\n\n\tfunction getHouseCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn games[msg.sender].houseCards.length;\n\t}\n\n\tfunction getGameState() public constant returns (uint8) {\n\t\tif (games[msg.sender].player == 0) {\n\t\t\tthrow;\n\t\t}\n\n\t\tGame game = games[msg.sender];\n\n\t\tif (game.state == GameState.Player) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (game.state == GameState.House) {\n\t\t\treturn 2;\n\t\t}\n\t\tif (game.state == GameState.Tie) {\n\t\t\treturn 3;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n\n    // Unified dispatcher - merged from: deal, hit, stand\n    // Selectors: deal=0, hit=1, stand=2\n    function execute(uint8 _selector) public payable {\n        // Original: deal()\n        if (_selector == 0) {\n            if (games[msg.sender].player != 0 && games[msg.sender].state == GameState.Ongoing) {\n            throw;\n            }\n            if (msg.value < minBet || msg.value > maxBet) {\n            throw;\n            }\n            uint8[] memory houseCards = new uint8[](1);\n            uint8[] memory playerCards = new uint8[](2);\n            playerCards[0] = Deck.deal(msg.sender, 0);\n            Deal(true, playerCards[0]);\n            houseCards[0] = Deck.deal(msg.sender, 1);\n            Deal(false, houseCards[0]);\n            playerCards[1] = Deck.deal(msg.sender, 2);\n            Deal(true, playerCards[1]);\n            games[msg.sender] = Game({\n            player: msg.sender,\n            bet: msg.value,\n            houseCards: houseCards,\n            playerCards: playerCards,\n            state: GameState.Ongoing,\n            cardsDealt: 3\n            });\n            checkGameResult(games[msg.sender], false);\n        }\n        // Original: hit()\n        else if (_selector == 1) {\n            uint8 nextCard = games[msg.sender].cardsDealt;\n            games[msg.sender].playerCards.push(Deck.deal(msg.sender, nextCard));\n            games[msg.sender].cardsDealt = nextCard + 1;\n            Deal(true, games[msg.sender].playerCards[games[msg.sender].playerCards.length - 1]);\n            checkGameResult(games[msg.sender], false);\n        }\n        // Original: stand()\n        else if (_selector == 2) {\n            var (houseScore, houseScoreBig) = calculateScore(games[msg.sender].houseCards);\n            while (houseScoreBig < 17) {\n            uint8 nextCard = games[msg.sender].cardsDealt;\n            uint8 newCard = Deck.deal(msg.sender, nextCard);\n            games[msg.sender].houseCards.push(newCard);\n            games[msg.sender].cardsDealt = nextCard + 1;\n            houseScoreBig += Deck.valueOf(newCard, true);\n            Deal(false, newCard);\n            }\n            checkGameResult(games[msg.sender], true);\n        }\n    }\n}",
      "merged_functions": [
        "deal",
        "hit",
        "stand"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: deal, hit, stand"
      ],
      "function_to_selector": {
        "deal": 0,
        "hit": 1,
        "stand": 2
      },
      "error": null
    },
    {
      "original_id": "nc_ds_234",
      "transformed_id": "rs_mg_dis_nc_ds_234",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.13;\n\nlibrary SafeMath {\n  function sub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n  function add(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint public totalSupply;\n  address public owner;\n  address public animator;\n  function balanceOf(address who) constant returns (uint);\n  function transfer(address to, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n  function commitDividend(address who) internal;\n}\n\ncontract ERC20 is ERC20Basic {\n  function allowance(address owner, address spender) constant returns (uint);\n  function transferFrom(address from, address to, uint value);\n  function approve(address spender, uint value);\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n  mapping(address => uint) balances;\n\n  modifier onlyPayloadSize(uint size) {\n     assert(msg.data.length >= size + 4);\n     _;\n  }\n\n  function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) {\n    commitDividend(msg.sender);\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    if(_to == address(this)) {\n        commitDividend(owner);\n        balances[owner] = balances[owner].add(_value);\n        Transfer(msg.sender, owner, _value);\n    }\n    else {\n        commitDividend(_to);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n    }\n  }\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n}\n\ncontract StandardToken is BasicToken, ERC20 {\n  mapping (address => mapping (address => uint)) allowed;\n\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) {\n    var _allowance = allowed[_from][msg.sender];\n    commitDividend(_from);\n    commitDividend(_to);\n    balances[_to] = balances[_to].add(_value);\n    balances[_from] = balances[_from].sub(_value);\n    allowed[_from][msg.sender] = _allowance.sub(_value);\n    Transfer(_from, _to, _value);\n  }\n\n  function approve(address _spender, uint _value) {\n\n    assert(!((_value != 0) && (allowed[msg.sender][_spender] != 0)));\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint remaining) {\n    return allowed[_owner][_spender];\n  }\n}\n\ncontract SmartBillions is StandardToken {\n\n\n    string public constant name = \"SmartBillions Token\";\n    string public constant symbol = \"PLAY\";\n    uint public constant decimals = 0;\n\n\n    struct Wallet {\n        uint208 balance;\n    \tuint16 lastDividendPeriod;\n    \tuint32 nextWithdrawBlock;\n    }\n    mapping (address => Wallet) wallets;\n    struct Bet {\n        uint192 value;\n        uint32 betHash;\n        uint32 blockNum;\n    }\n    mapping (address => Bet) bets;\n\n    uint public walletBalance = 0;\n\n\n    uint public investStart = 1;\n    uint public investBalance = 0;\n    uint public investBalanceMax = 200000 ether;\n    uint public dividendPeriod = 1;\n    uint[] public dividends;\n\n\n    uint public maxWin = 0;\n    uint public hashFirst = 0;\n    uint public hashLast = 0;\n    uint public hashNext = 0;\n    uint public hashBetSum = 0;\n    uint public hashBetMax = 5 ether;\n    uint[] public hashes;\n\n\n    uint public constant hashesSize = 16384 ;\n    uint public coldStoreLast = 0 ;\n\n\n    event LogBet(address indexed player, uint bethash, uint blocknumber, uint betsize);\n    event LogLoss(address indexed player, uint bethash, uint hash);\n    event LogWin(address indexed player, uint bethash, uint hash, uint prize);\n    event LogInvestment(address indexed investor, address indexed partner, uint amount);\n    event LogRecordWin(address indexed player, uint amount);\n    event LogLate(address indexed player,uint playerBlockNumber,uint currentBlockNumber);\n    event LogDividend(address indexed investor, uint amount, uint period);\n\n    modifier onlyOwner() {\n        assert(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyAnimator() {\n        assert(msg.sender == animator);\n        _;\n    }\n\n\n    function SmartBillions() {\n        owner = msg.sender;\n        animator = msg.sender;\n        wallets[owner].lastDividendPeriod = uint16(dividendPeriod);\n        dividends.push(0);\n        dividends.push(0);\n    }\n\n\n    function hashesLength() constant external returns (uint) {\n        return uint(hashes.length);\n    }\n\n    function walletBalanceOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].balance);\n    }\n\n    function walletPeriodOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].lastDividendPeriod);\n    }\n\n    function walletBlockOf(address _owner) constant external returns (uint) {\n        return uint(wallets[_owner].nextWithdrawBlock);\n    }\n\n    function betValueOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].value);\n    }\n\n    function betHashOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].betHash);\n    }\n\n    function betBlockNumberOf(address _owner) constant external returns (uint) {\n        return uint(bets[_owner].blockNum);\n    }\n\n    function dividendsBlocks() constant external returns (uint) {\n        if(investStart > 0) {\n            return(0);\n        }\n        uint period = (block.number - hashFirst) / (10 * hashesSize);\n        if(period > dividendPeriod) {\n            return(0);\n        }\n        return((10 * hashesSize) - ((block.number - hashFirst) % (10 * hashesSize)));\n    }\n\n\n    function changeOwner(address _who) external onlyOwner {\n        assert(_who != address(0));\n        commitDividend(msg.sender);\n        commitDividend(_who);\n        owner = _who;\n    }\n\n    function changeAnimator(address _who) external onlyAnimator {\n        assert(_who != address(0));\n        commitDividend(msg.sender);\n        commitDividend(_who);\n        animator = _who;\n    }\n\n    function setInvestStart(uint _when) external onlyOwner {\n        require(investStart == 1 && hashFirst > 0 && block.number < _when);\n        investStart = _when;\n    }\n\n    function setBetMax(uint _maxsum) external onlyOwner {\n        hashBetMax = _maxsum;\n    }\n\n    function resetBet() external onlyOwner {\n        hashNext = block.number + 3;\n        hashBetSum = 0;\n    }\n\n    function coldStore(uint _amount) external onlyOwner {\n        houseKeeping();\n        require(_amount > 0 && this.balance >= (investBalance * 9 / 10) + walletBalance + _amount);\n        if(investBalance >= investBalanceMax / 2){\n            require((_amount <= this.balance / 400) && coldStoreLast + 4 * 60 * 24 * 7 <= block.number);\n        }\n        msg.sender.transfer(_amount);\n        coldStoreLast = block.number;\n    }\n\n    function hotStore() payable external {\n        houseKeeping();\n    }\n\n\n    function houseKeeping() public {\n        if(investStart > 1 && block.number >= investStart + (hashesSize * 5)){\n            investStart = 0;\n        }\n        else {\n            if(hashFirst > 0){\n\t\t        uint period = (block.number - hashFirst) / (10 * hashesSize );\n                if(period > dividends.length - 2) {\n                    dividends.push(0);\n                }\n                if(period > dividendPeriod && investStart == 0 && dividendPeriod < dividends.length - 1) {\n                    dividendPeriod++;\n                }\n            }\n        }\n    }\n\n\n    function payWallet() public {\n        if(wallets[msg.sender].balance > 0 && wallets[msg.sender].nextWithdrawBlock <= block.number){\n            uint balance = wallets[msg.sender].balance;\n            wallets[msg.sender].balance = 0;\n            walletBalance -= balance;\n            pay(balance);\n        }\n    }\n\n    function pay(uint _amount) private {\n        uint maxpay = this.balance / 2;\n        if(maxpay >= _amount) {\n            msg.sender.transfer(_amount);\n            if(_amount > 1 finney) {\n                houseKeeping();\n            }\n        }\n        else {\n            uint keepbalance = _amount - maxpay;\n            walletBalance += keepbalance;\n            wallets[msg.sender].balance += uint208(keepbalance);\n            wallets[msg.sender].nextWithdrawBlock = uint32(block.number + 4 * 60 * 24 * 30);\n            msg.sender.transfer(maxpay);\n        }\n    }\n\n\n    function investDirect() payable external {\n        invest(owner);\n    }\n\n    function invest(address _partner) payable public {\n\n        require(investStart > 1 && block.number < investStart + (hashesSize * 5) && investBalance < investBalanceMax);\n        uint investing = msg.value;\n        if(investing > investBalanceMax - investBalance) {\n            investing = investBalanceMax - investBalance;\n            investBalance = investBalanceMax;\n            investStart = 0;\n            msg.sender.transfer(msg.value.sub(investing));\n        }\n        else{\n            investBalance += investing;\n        }\n        if(_partner == address(0) || _partner == owner){\n            walletBalance += investing / 10;\n            wallets[owner].balance += uint208(investing / 10);}\n        else{\n            walletBalance += (investing * 5 / 100) * 2;\n            wallets[owner].balance += uint208(investing * 5 / 100);\n            wallets[_partner].balance += uint208(investing * 5 / 100);}\n        wallets[msg.sender].lastDividendPeriod = uint16(dividendPeriod);\n        uint senderBalance = investing / 10**15;\n        uint ownerBalance = investing * 16 / 10**17  ;\n        uint animatorBalance = investing * 10 / 10**17  ;\n        balances[msg.sender] += senderBalance;\n        balances[owner] += ownerBalance ;\n        balances[animator] += animatorBalance ;\n        totalSupply += senderBalance + ownerBalance + animatorBalance;\n        Transfer(address(0),msg.sender,senderBalance);\n        Transfer(address(0),owner,ownerBalance);\n        Transfer(address(0),animator,animatorBalance);\n        LogInvestment(msg.sender,_partner,investing);\n    }\n\n    function disinvest() external {\n        require(investStart == 0);\n        commitDividend(msg.sender);\n        uint initialInvestment = balances[msg.sender] * 10**15;\n        Transfer(msg.sender,address(0),balances[msg.sender]);\n        delete balances[msg.sender];\n        investBalance -= initialInvestment;\n        wallets[msg.sender].balance += uint208(initialInvestment * 9 / 10);\n        payWallet();\n    }\n\n    function payDividends() external {\n        require(investStart == 0);\n        commitDividend(msg.sender);\n        payWallet();\n    }\n\n    function commitDividend(address _who) internal {\n        uint last = wallets[_who].lastDividendPeriod;\n        if((balances[_who]==0) || (last==0)){\n            wallets[_who].lastDividendPeriod=uint16(dividendPeriod);\n            return;\n        }\n        if(last==dividendPeriod) {\n            return;\n        }\n        uint share = balances[_who] * 0xffffffff / totalSupply;\n        uint balance = 0;\n        for(;last<dividendPeriod;last++) {\n            balance += share * dividends[last];\n        }\n        balance = (balance / 0xffffffff);\n        walletBalance += balance;\n        wallets[_who].balance += uint208(balance);\n        wallets[_who].lastDividendPeriod = uint16(last);\n        LogDividend(_who,balance,last);\n    }\n\n\n    function betPrize(Bet _player, uint24 _hash) constant private returns (uint) {\n        uint24 bethash = uint24(_player.betHash);\n        uint24 hit = bethash ^ _hash;\n        uint24 matches =\n            ((hit & 0xF) == 0 ? 1 : 0 ) +\n            ((hit & 0xF0) == 0 ? 1 : 0 ) +\n            ((hit & 0xF00) == 0 ? 1 : 0 ) +\n            ((hit & 0xF000) == 0 ? 1 : 0 ) +\n            ((hit & 0xF0000) == 0 ? 1 : 0 ) +\n            ((hit & 0xF00000) == 0 ? 1 : 0 );\n        if(matches == 6){\n            return(uint(_player.value) * 7000000);\n        }\n        if(matches == 5){\n            return(uint(_player.value) * 20000);\n        }\n        if(matches == 4){\n            return(uint(_player.value) * 500);\n        }\n        if(matches == 3){\n            return(uint(_player.value) * 25);\n        }\n        if(matches == 2){\n            return(uint(_player.value) * 3);\n        }\n        return(0);\n    }\n\n    function betOf(address _who) constant external returns (uint)  {\n        Bet memory player = bets[_who];\n        if( (player.value==0) ||\n            (player.blockNum<=1) ||\n            (block.number<player.blockNum) ||\n            (block.number>=player.blockNum + (10 * hashesSize))){\n            return(0);\n        }\n        if(block.number<player.blockNum+256){\n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\n        }\n        if(hashFirst>0){\n            uint32 hash = getHash(player.blockNum);\n            if(hash == 0x1000000) {\n                return(uint(player.value));\n            }\n            else{\n                return(betPrize(player,uint24(hash)));\n            }\n\t}\n        return(0);\n    }\n\n    function won() public {\n        Bet memory player = bets[msg.sender];\n        if(player.blockNum==0){\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n            return;\n        }\n        if((player.value==0) || (player.blockNum==1)){\n            payWallet();\n            return;\n        }\n        require(block.number>player.blockNum);\n        if(player.blockNum + (10 * hashesSize) <= block.number){\n            LogLate(msg.sender,player.blockNum,block.number);\n            bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n            return;\n        }\n        uint prize = 0;\n        uint32 hash = 0;\n        if(block.number<player.blockNum+256){\n            hash = uint24(block.blockhash(player.blockNum));\n            prize = betPrize(player,uint24(hash));\n        }\n        else {\n            if(hashFirst>0){\n                hash = getHash(player.blockNum);\n                if(hash == 0x1000000) {\n                    prize = uint(player.value);\n                }\n                else{\n                    prize = betPrize(player,uint24(hash));\n                }\n\t    }\n            else{\n                LogLate(msg.sender,player.blockNum,block.number);\n                bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n                return();\n            }\n        }\n        bets[msg.sender] = Bet({value: 0, betHash: 0, blockNum: 1});\n        if(prize>0) {\n            LogWin(msg.sender,uint(player.betHash),uint(hash),prize);\n            if(prize > maxWin){\n                maxWin = prize;\n                LogRecordWin(msg.sender,prize);\n            }\n            pay(prize);\n        }\n        else{\n            LogLoss(msg.sender,uint(player.betHash),uint(hash));\n        }\n    }\n\n    function () payable external {\n        if(msg.value > 0){\n            if(investStart>1){\n                invest(owner);\n            }\n            else{\n                play();\n            }\n            return;\n        }\n\n        if(investStart == 0 && balances[msg.sender]>0){\n            commitDividend(msg.sender);}\n        won();\n    }\n\n    function play() payable public returns (uint) {\n        return playSystem(uint(sha3(msg.sender,block.number)), address(0));\n    }\n\n    function playRandom(address _partner) payable public returns (uint) {\n        return playSystem(uint(sha3(msg.sender,block.number)), _partner);\n    }\n\n    function playSystem(uint _hash, address _partner) payable public returns (uint) {\n        won();\n        uint24 bethash = uint24(_hash);\n        require(msg.value <= 1 ether && msg.value < hashBetMax);\n        if(msg.value > 0){\n            if(investStart==0) {\n                dividends[dividendPeriod] += msg.value / 20;\n            }\n            if(_partner != address(0)) {\n                uint fee = msg.value / 100;\n                walletBalance += fee;\n                wallets[_partner].balance += uint208(fee);\n            }\n            if(hashNext < block.number + 3) {\n                hashNext = block.number + 3;\n                hashBetSum = msg.value;\n            }\n            else{\n                if(hashBetSum > hashBetMax) {\n                    hashNext++;\n                    hashBetSum = msg.value;\n                }\n                else{\n                    hashBetSum += msg.value;\n                }\n            }\n            bets[msg.sender] = Bet({value: uint192(msg.value), betHash: uint32(bethash), blockNum: uint32(hashNext)});\n            LogBet(msg.sender,uint(bethash),hashNext,msg.value);\n        }\n        putHash();\n        return(hashNext);\n    }\n\n\n    function addHashes(uint _sadd) public returns (uint) {\n        require(hashFirst == 0 && _sadd > 0 && _sadd <= hashesSize);\n        uint n = hashes.length;\n        if(n + _sadd > hashesSize){\n            hashes.length = hashesSize;\n        }\n        else{\n            hashes.length += _sadd;\n        }\n        for(;n<hashes.length;n++){\n            hashes[n] = 1;\n        }\n        if(hashes.length>=hashesSize) {\n            hashFirst = block.number - ( block.number % 10);\n            hashLast = hashFirst;\n        }\n        return(hashes.length);\n    }\n\n    function addHashes128() external returns (uint) {\n        return(addHashes(128));\n    }\n\n    function calcHashes(uint32 _lastb, uint32 _delta) constant private returns (uint) {\n        return( ( uint(block.blockhash(_lastb  )) & 0xFFFFFF )\n            | ( ( uint(block.blockhash(_lastb+1)) & 0xFFFFFF ) << 24 )\n            | ( ( uint(block.blockhash(_lastb+2)) & 0xFFFFFF ) << 48 )\n            | ( ( uint(block.blockhash(_lastb+3)) & 0xFFFFFF ) << 72 )\n            | ( ( uint(block.blockhash(_lastb+4)) & 0xFFFFFF ) << 96 )\n            | ( ( uint(block.blockhash(_lastb+5)) & 0xFFFFFF ) << 120 )\n            | ( ( uint(block.blockhash(_lastb+6)) & 0xFFFFFF ) << 144 )\n            | ( ( uint(block.blockhash(_lastb+7)) & 0xFFFFFF ) << 168 )\n            | ( ( uint(block.blockhash(_lastb+8)) & 0xFFFFFF ) << 192 )\n            | ( ( uint(block.blockhash(_lastb+9)) & 0xFFFFFF ) << 216 )\n            | ( ( uint(_delta) / hashesSize) << 240));\n    }\n\n    function getHash(uint _block) constant private returns (uint32) {\n        uint delta = (_block - hashFirst) / 10;\n        uint hash = hashes[delta % hashesSize];\n        if(delta / hashesSize != hash >> 240) {\n            return(0x1000000);\n        }\n        uint slotp = (_block - hashFirst) % 10;\n        return(uint32((hash >> (24 * slotp)) & 0xFFFFFF));\n    }\n\n    function putHash() public returns (bool) {\n        uint lastb = hashLast;\n        if(lastb == 0 || block.number <= lastb + 10) {\n            return(false);\n        }\n        uint blockn256;\n        if(block.number<256) {\n            blockn256 = 0;\n        }\n        else{\n            blockn256 = block.number - 256;\n        }\n        if(lastb < blockn256) {\n            uint num = blockn256;\n            num += num % 10;\n            lastb = num;\n        }\n        uint delta = (lastb - hashFirst) / 10;\n        hashes[delta % hashesSize] = calcHashes(uint32(lastb),uint32(delta));\n        hashLast = lastb + 10;\n        return(true);\n    }\n\n    function putHashes(uint _num) external {\n        uint n=0;\n        for(;n<_num;n++){\n            if(!putHash()){\n                return;\n            }\n        }\n    }\n\n\n    // Unified dispatcher - merged from: betOf, hashesLength, walletBalanceOf\n    // Selectors: betOf=0, hashesLength=1, walletBalanceOf=2\n    function execute(uint8 _selector, address _owner, address _who) public {\n        // Original: betOf()\n        if (_selector == 0) {\n            Bet memory player = bets[_who];\n            if( (player.value==0) ||\n            (player.blockNum<=1) ||\n            (block.number<player.blockNum) ||\n            (block.number>=player.blockNum + (10 * hashesSize))){\n            return(0);\n            }\n            if(block.number<player.blockNum+256){\n            return(betPrize(player,uint24(block.blockhash(player.blockNum))));\n            }\n            if(hashFirst>0){\n            uint32 hash = getHash(player.blockNum);\n            if(hash == 0x1000000) {\n            return(uint(player.value));\n            }\n            else{\n            return(betPrize(player,uint24(hash)));\n            }\n            }\n            return(0);\n        }\n        // Original: hashesLength()\n        else if (_selector == 1) {\n            return uint(hashes.length);\n        }\n        // Original: walletBalanceOf()\n        else if (_selector == 2) {\n            return uint(wallets[_owner].balance);\n        }\n    }\n}",
      "merged_functions": [
        "betOf",
        "hashesLength",
        "walletBalanceOf"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: betOf, hashesLength, walletBalanceOf"
      ],
      "function_to_selector": {
        "betOf": 0,
        "hashesLength": 1,
        "walletBalanceOf": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_001",
      "transformed_id": "rs_mg_dis_nc_gs_001",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public transferLockPeriod = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public head_not_withdraw_time = 1200;\n    uint256 public tail_not_withdraw_time = 300;\n\n\n    uint256 public withdrawFee = 100;\n    uint256 public constant MIN_WITHDRAW_FEE = 10;\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant BASIS = 10000;\n    address public Team;\n    uint256 public rebase;\n    uint256 public penalty;\n    uint256 public votingYield;\n\n    struct UserLock {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    mapping(address => UserLock[]) public userLocks;\n    mapping(address => uint256) public lockedBalance;\n\n\n    address public immutable HYBR;\n    address public immutable votingEscrow;\n    address public voter;\n    address public rewardsDistributor;\n    address public gaugeManager;\n    uint256 public veTokenId;\n\n\n    address public operator;\n    uint256 public lastVoteEpoch;\n\n\n    uint256 public lastRebaseTime;\n    uint256 public lastCompoundTime;\n\n\n    ISwapper public swapper;\n\n\n    error NOT_AUTHORIZED();\n\n\n    event Deposit(address indexed user, uint256 hybrAmount, uint256 sharesReceived);\n    event Withdraw(address indexed user, uint256 shares, uint256 hybrAmount, uint256 fee);\n    event Compound(uint256 rewards, uint256 newTotalLocked);\n    event PenaltyRewardReceived(uint256 amount);\n    event TransferLockPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\n    event SwapperUpdated(address indexed oldSwapper, address indexed newSwapper);\n    event VoterSet(address voter);\n    event EmergencyUnlock(address indexed user);\n    event AutoVotingEnabled(bool enabled);\n    event OperatorUpdated(address indexed oldOperator, address indexed newOperator);\n    event DefaultVotingStrategyUpdated(address[] pools, uint256[] weights);\n    event AutoVoteExecuted(uint256 epoch, address[] pools, uint256[] weights);\n\n    constructor(\n        address _HYBR,\n        address _votingEscrow\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_HYBR != address(0), \"Invalid HYBR\");\n        require(_votingEscrow != address(0), \"Invalid VE\");\n\n        HYBR = _HYBR;\n        votingEscrow = _votingEscrow;\n        lastRebaseTime = block.timestamp;\n        lastCompoundTime = block.timestamp;\n        operator = msg.sender;\n    }\n\n    function setRewardsDistributor(address _rewardsDistributor) external onlyOwner {\n        require(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\n        rewardsDistributor = _rewardsDistributor;\n    }\n\n    function setGaugeManager(address _gaugeManager) external onlyOwner {\n        require(_gaugeManager != address(0), \"Invalid gauge manager\");\n        gaugeManager = _gaugeManager;\n    }\n\n\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n\n    function deposit(uint256 amount, address recipient) external nonReentrant {\n        require(amount > 0, \"Zero amount\");\n        recipient = recipient == address(0) ? msg.sender : recipient;\n\n\n        IERC20(HYBR).transferFrom(msg.sender, address(this), amount);\n\n\n        if (veTokenId == 0) {\n            _initializeVeNFT(amount);\n        } else {\n\n            IERC20(HYBR).approve(votingEscrow, amount);\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n\n\n            _extendLockToMax();\n        }\n\n\n        uint256 shares = calculateShares(amount);\n\n\n        _mint(recipient, shares);\n\n\n        _addTransferLock(recipient, shares);\n\n        emit Deposit(msg.sender, amount, shares);\n    }\n\n\n    function withdraw(uint256 shares) external nonReentrant returns (uint256 userTokenId) {\n        require(shares > 0, \"Zero shares\");\n        require(balanceOf(msg.sender) >= shares, \"Insufficient balance\");\n        require(veTokenId != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(votingEscrow).voted(veTokenId) == false, \"Cannot withdraw yet\");\n\n        uint256 epochStart = HybraTimeLibrary.epochStart(block.timestamp);\n        uint256 epochNext = HybraTimeLibrary.epochNext(block.timestamp);\n\n        require(block.timestamp >= epochStart + head_not_withdraw_time && block.timestamp < epochNext - tail_not_withdraw_time, \"Cannot withdraw yet\");\n\n\n        uint256 hybrAmount = calculateAssets(shares);\n        require(hybrAmount > 0, \"No assets to withdraw\");\n\n\n        uint256 feeAmount = 0;\n        if (withdrawFee > 0) {\n            feeAmount = (hybrAmount * withdrawFee) / BASIS;\n        }\n\n\n        uint256 userAmount = hybrAmount - feeAmount;\n        require(userAmount > 0, \"Amount too small after fee\");\n\n\n        uint256 veBalance = totalAssets();\n        require(hybrAmount <= veBalance, \"Insufficient veNFT balance\");\n\n        uint256 remainingAmount = veBalance - userAmount - feeAmount;\n        require(remainingAmount >= 0, \"Cannot withdraw entire veNFT\");\n\n\n        _burn(msg.sender, shares);\n\n\n        uint256[] memory amounts = new uint256[](3);\n        amounts[0] = remainingAmount;\n        amounts[1] = userAmount;\n        amounts[2] = feeAmount;\n\n        uint256[] memory newTokenIds = IVotingEscrow(votingEscrow).multiSplit(veTokenId, amounts);\n\n\n        veTokenId = newTokenIds[0];\n        userTokenId = newTokenIds[1];\n        uint256 feeTokenId = newTokenIds[2];\n\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), msg.sender, userTokenId);\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), Team, feeTokenId);\n        emit Withdraw(msg.sender, shares, userAmount, feeAmount);\n    }\n\n\n    function _initializeVeNFT(uint256 initialAmount) internal {\n\n        IERC20(HYBR).approve(votingEscrow, type(uint256).max);\n        uint256 lockTime = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n\n        veTokenId = IVotingEscrow(votingEscrow).create_lock_for(initialAmount, lockTime, address(this));\n\n    }\n\n\n    function calculateShares(uint256 amount) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        uint256 _totalAssets = totalAssets();\n        if (_totalSupply == 0 || _totalAssets == 0) {\n            return amount;\n        }\n        return (amount * _totalSupply) / _totalAssets;\n    }\n\n\n    function calculateAssets(uint256 shares) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return shares;\n        }\n        return (shares * totalAssets()) / _totalSupply;\n    }\n\n\n    function totalAssets() public view returns (uint256) {\n        if (veTokenId == 0) {\n            return 0;\n        }\n\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\n        return uint256(int256(locked.amount));\n    }\n\n\n    function _addTransferLock(address user, uint256 amount) internal {\n        uint256 unlockTime = block.timestamp + transferLockPeriod;\n        userLocks[user].push(UserLock({\n            amount: amount,\n            unlockTime: unlockTime\n        }));\n        lockedBalance[user] += amount;\n    }\n\n\n    function previewAvailable(address user) external view returns (uint256 available) {\n        uint256 totalBalance = balanceOf(user);\n        uint256 currentLocked = 0;\n\n        UserLock[] storage arr = userLocks[user];\n        for (uint256 i = 0; i < arr.length; i++) {\n            if (arr[i].unlockTime > block.timestamp) {\n                currentLocked += arr[i].amount;\n            }\n        }\n\n        return totalBalance > currentLocked ? totalBalance - currentLocked : 0;\n    }\n\n    function _cleanExpired(address user) internal returns (uint256 freed) {\n        UserLock[] storage arr = userLocks[user];\n        uint256 len = arr.length;\n        if (len == 0) return 0;\n\n        uint256 write = 0;\n        unchecked {\n            for (uint256 i = 0; i < len; i++) {\n                UserLock memory L = arr[i];\n                if (L.unlockTime <= block.timestamp) {\n                    freed += L.amount;\n                } else {\n                    if (write != i) arr[write] = L;\n                    write++;\n                }\n            }\n            if (freed > 0) {\n                lockedBalance[user] -= freed;\n            }\n            while (arr.length > write) {\n                arr.pop();\n            }\n        }\n    }\n\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0) && to != address(0)) {\n            uint256 totalBalance = balanceOf(from);\n\n\n            uint256 currentAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\n\n\n            if (currentAvailable >= amount) {\n                return;\n            }\n\n\n            _cleanExpired(from);\n            uint256 finalAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\n\n\n            require(finalAvailable >= amount, \"Tokens locked\");\n        }\n    }\n\n\n    function claimRewards() external onlyOperator {\n        require(voter != address(0), \"Voter not set\");\n        require(rewardsDistributor != address(0), \"Distributor not set\");\n\n\n        uint256  rebaseAmount = IRewardsDistributor(rewardsDistributor).claim(veTokenId);\n        rebase += rebaseAmount;\n\n        address[] memory votedPools = IVoter(voter).poolVote(veTokenId);\n\n        for (uint256 i = 0; i < votedPools.length; i++) {\n            if (votedPools[i] != address(0)) {\n                address gauge = IGaugeManager(gaugeManager).gauges(votedPools[i]);\n\n                if (gauge != address(0)) {\n\n                    address[] memory bribes = new address[](1);\n                    address[][] memory tokens = new address[][](1);\n\n\n                    address internalBribe = IGaugeManager(gaugeManager).internal_bribes(gauge);\n                    if (internalBribe != address(0)) {\n                        uint256 tokenCount = IBribe(internalBribe).rewardsListLength();\n                        if (tokenCount > 0) {\n                            address[] memory bribeTokens = new address[](tokenCount);\n                            for (uint256 j = 0; j < tokenCount; j++) {\n                                bribeTokens[j] = IBribe(internalBribe).bribeTokens(j);\n                            }\n                            bribes[0] = internalBribe;\n                            tokens[0] = bribeTokens;\n\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n                        }\n                    }\n\n\n                    address externalBribe = IGaugeManager(gaugeManager).external_bribes(gauge);\n                    if (externalBribe != address(0)) {\n                        uint256 tokenCount = IBribe(externalBribe).rewardsListLength();\n                        if (tokenCount > 0) {\n                            address[] memory bribeTokens = new address[](tokenCount);\n                            for (uint256 j = 0; j < tokenCount; j++) {\n                                bribeTokens[j] = IBribe(externalBribe).bribeTokens(j);\n                            }\n                            bribes[0] = externalBribe;\n                            tokens[0] = bribeTokens;\n\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    function executeSwap(ISwapper.SwapParams calldata _params) external nonReentrant onlyOperator {\n        require(address(swapper) != address(0), \"Swapper not set\");\n\n\n        uint256 tokenBalance = IERC20(_params.tokenIn).balanceOf(address(this));\n        require(tokenBalance >= _params.amountIn, \"Insufficient token balance\");\n\n\n        IERC20(_params.tokenIn).safeApprove(address(swapper), _params.amountIn);\n\n\n        uint256 hybrReceived = swapper.swapToHYBR(_params);\n\n\n        IERC20(_params.tokenIn).safeApprove(address(swapper), 0);\n\n\n        votingYield += hybrReceived;\n    }\n\n\n    function compound() external onlyOperator {\n\n\n        uint256 hybrBalance = IERC20(HYBR).balanceOf(address(this));\n\n        if (hybrBalance > 0) {\n\n            IERC20(HYBR).safeApprove(votingEscrow, hybrBalance);\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, hybrBalance);\n\n\n            _extendLockToMax();\n\n            lastCompoundTime = block.timestamp;\n\n            emit Compound(hybrBalance, totalAssets());\n        }\n    }\n\n\n    function vote(address[] calldata _poolVote, uint256[] calldata _weights) external {\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\n        require(voter != address(0), \"Voter not set\");\n\n        IVoter(voter).vote(veTokenId, _poolVote, _weights);\n        lastVoteEpoch = HybraTimeLibrary.epochStart(block.timestamp);\n\n    }\n\n\n    function reset() external {\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\n        require(voter != address(0), \"Voter not set\");\n\n        IVoter(voter).reset(veTokenId);\n    }\n\n\n    function receivePenaltyReward(uint256 amount) external {\n\n\n        if (amount > 0) {\n            IERC20(HYBR).approve(votingEscrow, amount);\n\n            if(veTokenId == 0){\n                _initializeVeNFT(amount);\n            } else{\n                IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n\n\n                _extendLockToMax();\n            }\n        }\n        penalty += amount;\n        emit PenaltyRewardReceived(amount);\n    }\n\n\n    function setVoter(address _voter) external onlyOwner {\n        require(_voter != address(0), \"Invalid voter\");\n        voter = _voter;\n        emit VoterSet(_voter);\n    }\n\n\n    function setTransferLockPeriod(uint256 _period) external onlyOwner {\n        require(_period >= MIN_LOCK_PERIOD && _period <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 oldPeriod = transferLockPeriod;\n        transferLockPeriod = _period;\n        emit TransferLockPeriodUpdated(oldPeriod, _period);\n    }\n\n\n    function setWithdrawFee(uint256 _fee) external onlyOwner {\n        require(_fee >= MIN_WITHDRAW_FEE && _fee <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        withdrawFee = _fee;\n    }\n\n    function setHeadNotWithdrawTime(uint256 _time) external onlyOwner {\n        head_not_withdraw_time = _time;\n    }\n\n    function setTailNotWithdrawTime(uint256 _time) external onlyOwner {\n        tail_not_withdraw_time = _time;\n    }\n\n\n    function setSwapper(address _swapper) external onlyOwner {\n        require(_swapper != address(0), \"Invalid swapper\");\n        address oldSwapper = address(swapper);\n        swapper = ISwapper(_swapper);\n        emit SwapperUpdated(oldSwapper, _swapper);\n    }\n\n\n    function setTeam(address _team) external onlyOwner {\n        require(_team != address(0), \"Invalid team\");\n        Team = _team;\n    }\n\n\n    function emergencyUnlock(address user) external onlyOperator {\n        delete userLocks[user];\n        lockedBalance[user] = 0;\n        emit EmergencyUnlock(user);\n    }\n\n\n    function getUserLocks(address user) external view returns (UserLock[] memory) {\n        return userLocks[user];\n    }\n\n\n    function setOperator(address _operator) external onlyOwner {\n        require(_operator != address(0), \"Invalid operator\");\n        address oldOperator = operator;\n        operator = _operator;\n        emit OperatorUpdated(oldOperator, _operator);\n    }\n\n\n    function getLockEndTime() external view returns (uint256) {\n        if (veTokenId == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\n        return uint256(locked.end);\n    }\n\n\n    function _extendLockToMax() internal {\n        if (veTokenId == 0) return;\n\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\n        if (locked.isPermanent || locked.end <= block.timestamp) return;\n\n        uint256 maxUnlockTime = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n\n        if (maxUnlockTime > locked.end + 2 hours) {\n            try IVotingEscrow(votingEscrow).increase_unlock_time(veTokenId, HybraTimeLibrary.MAX_LOCK_DURATION) {\n\n            } catch {\n\n\n            }\n        }\n    }\n\n\n    // Unified dispatcher - merged from: deposit, setRewardsDistributor, setGaugeManager\n    // Selectors: deposit=0, setRewardsDistributor=1, setGaugeManager=2\n    function execute(uint8 _selector, address _gaugeManager, address _rewardsDistributor, address recipient, uint256 amount) public {\n        // Original: deposit()\n        if (_selector == 0) {\n            require(amount > 0, \"Zero amount\");\n            recipient = recipient == address(0) ? msg.sender : recipient;\n            IERC20(HYBR).transferFrom(msg.sender, address(this), amount);\n            if (veTokenId == 0) {\n            _initializeVeNFT(amount);\n            } else {\n            IERC20(HYBR).approve(votingEscrow, amount);\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n            _extendLockToMax();\n            }\n            uint256 shares = calculateShares(amount);\n            _mint(recipient, shares);\n            _addTransferLock(recipient, shares);\n            emit Deposit(msg.sender, amount, shares);\n        }\n        // Original: setRewardsDistributor()\n        else if (_selector == 1) {\n            require(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\n            rewardsDistributor = _rewardsDistributor;\n        }\n        // Original: setGaugeManager()\n        else if (_selector == 2) {\n            require(_gaugeManager != address(0), \"Invalid gauge manager\");\n            gaugeManager = _gaugeManager;\n        }\n    }\n}",
      "merged_functions": [
        "deposit",
        "setRewardsDistributor",
        "setGaugeManager"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: deposit, setRewardsDistributor, setGaugeManager"
      ],
      "function_to_selector": {
        "deposit": 0,
        "setRewardsDistributor": 1,
        "setGaugeManager": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_002",
      "transformed_id": "rs_mg_dis_nc_gs_002",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity =0.7.6;\n\nimport \"./interfaces/ICLFactory.sol\";\nimport \"./interfaces/fees/IFeeModule.sol\";\n\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/IFactoryRegistry.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@nomad-xyz/src/ExcessivelySafeCall.sol\";\nimport \"./CLPool.sol\";\n\n\ncontract CLFactory is ICLFactory {\n    using ExcessivelySafeCall for address;\n\n\n    IGaugeManager public override gaugeManager;\n\n    address public immutable override poolImplementation;\n\n    address public override owner;\n\n    address public override swapFeeManager;\n\n    address public override swapFeeModule;\n\n    address public override unstakedFeeManager;\n\n    address public override unstakedFeeModule;\n\n    uint24 public override defaultUnstakedFee;\n\n\n    address public override protocolFeeManager;\n\n    address public override protocolFeeModule;\n\n    uint24 public override defaultProtocolFee;\n\n    mapping(int24 => uint24) public override tickSpacingToFee;\n\n    mapping(address => mapping(address => mapping(int24 => address))) public override getPool;\n\n    mapping(address => bool) private _isPool;\n\n    address[] public override allPools;\n\n    int24[] private _tickSpacings;\n\n    constructor(address _poolImplementation) {\n        owner = msg.sender;\n        swapFeeManager = msg.sender;\n        unstakedFeeManager = msg.sender;\n        protocolFeeManager = msg.sender;\n        poolImplementation = _poolImplementation;\n        defaultUnstakedFee = 100_000;\n        defaultProtocolFee = 250_000;\n        emit OwnerChanged(address(0), msg.sender);\n        emit SwapFeeManagerChanged(address(0), msg.sender);\n        emit UnstakedFeeManagerChanged(address(0), msg.sender);\n        emit DefaultUnstakedFeeChanged(0, 100_000);\n\n        enableTickSpacing(1, 100);\n        enableTickSpacing(50, 500);\n        enableTickSpacing(100, 500);\n        enableTickSpacing(200, 3_000);\n        enableTickSpacing(2_000, 10_000);\n    }\n\n    function setGaugeManager(address _gaugeManager) external {\n        require(msg.sender == owner);\n        gaugeManager = IGaugeManager(_gaugeManager);\n    }\n\n\n    function createPool(address tokenA, address tokenB, int24 tickSpacing, uint160 sqrtPriceX96)\n        external\n        override\n        returns (address pool)\n    {\n        require(tokenA != tokenB);\n        (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n        require(token0 != address(0));\n        require(tickSpacingToFee[tickSpacing] != 0);\n        require(getPool[token0][token1][tickSpacing] == address(0));\n        pool = Clones.cloneDeterministic({\n            master: poolImplementation,\n            salt: keccak256(abi.encode(token0, token1, tickSpacing))\n        });\n        CLPool(pool).initialize({\n            _factory: address(this),\n            _token0: token0,\n            _token1: token1,\n            _tickSpacing: tickSpacing,\n            _gaugeManager: address(gaugeManager),\n            _sqrtPriceX96: sqrtPriceX96\n        });\n        allPools.push(pool);\n        _isPool[pool] = true;\n        getPool[token0][token1][tickSpacing] = pool;\n\n        getPool[token1][token0][tickSpacing] = pool;\n        emit PoolCreated(token0, token1, tickSpacing, pool);\n    }\n\n\n    function setOwner(address _owner) external override {\n        address cachedOwner = owner;\n        require(msg.sender == cachedOwner);\n        require(_owner != address(0));\n        emit OwnerChanged(cachedOwner, _owner);\n        owner = _owner;\n    }\n\n\n    function setSwapFeeManager(address _swapFeeManager) external override {\n        address cachedSwapFeeManager = swapFeeManager;\n        require(msg.sender == cachedSwapFeeManager);\n        require(_swapFeeManager != address(0));\n        swapFeeManager = _swapFeeManager;\n        emit SwapFeeManagerChanged(cachedSwapFeeManager, _swapFeeManager);\n    }\n\n\n    function setUnstakedFeeManager(address _unstakedFeeManager) external override {\n        address cachedUnstakedFeeManager = unstakedFeeManager;\n        require(msg.sender == cachedUnstakedFeeManager);\n        require(_unstakedFeeManager != address(0));\n        unstakedFeeManager = _unstakedFeeManager;\n        emit UnstakedFeeManagerChanged(cachedUnstakedFeeManager, _unstakedFeeManager);\n    }\n\n\n    function setSwapFeeModule(address _swapFeeModule) external override {\n        require(msg.sender == swapFeeManager);\n        require(_swapFeeModule != address(0));\n        address oldFeeModule = swapFeeModule;\n        swapFeeModule = _swapFeeModule;\n        emit SwapFeeModuleChanged(oldFeeModule, _swapFeeModule);\n    }\n\n\n    function setUnstakedFeeModule(address _unstakedFeeModule) external override {\n        require(msg.sender == unstakedFeeManager);\n        require(_unstakedFeeModule != address(0));\n        address oldFeeModule = unstakedFeeModule;\n        unstakedFeeModule = _unstakedFeeModule;\n        emit UnstakedFeeModuleChanged(oldFeeModule, _unstakedFeeModule);\n    }\n\n\n    function setDefaultUnstakedFee(uint24 _defaultUnstakedFee) external override {\n        require(msg.sender == unstakedFeeManager);\n        require(_defaultUnstakedFee <= 500_000);\n        uint24 oldUnstakedFee = defaultUnstakedFee;\n        defaultUnstakedFee = _defaultUnstakedFee;\n        emit DefaultUnstakedFeeChanged(oldUnstakedFee, _defaultUnstakedFee);\n    }\n\n    function setProtocolFeeModule(address _protocolFeeModule) external override {\n        require(msg.sender == protocolFeeManager);\n        require(_protocolFeeModule != address(0));\n        protocolFeeModule = _protocolFeeModule;\n    }\n\n    function setProtocolFeeManager(address _protocolFeeManager) external override {\n        require(msg.sender == protocolFeeManager);\n        require(_protocolFeeManager != address(0));\n        protocolFeeManager = _protocolFeeManager;\n    }\n\n\n    function getSwapFee(address pool) external view override returns (uint24) {\n        if (swapFeeModule != address(0)) {\n            (bool success, bytes memory data) = swapFeeModule.excessivelySafeStaticCall(\n                200_000, 32, abi.encodeWithSelector(IFeeModule.getFee.selector, pool)\n            );\n            if (success) {\n                uint24 fee = abi.decode(data, (uint24));\n                if (fee <= 100_000) {\n                    return fee;\n                }\n            }\n        }\n        return tickSpacingToFee[CLPool(pool).tickSpacing()];\n    }\n\n\n    function getUnstakedFee(address pool) external view override returns (uint24) {\n\n        if (!gaugeManager.isGaugeAliveForPool(pool)) {\n            return 0;\n        }\n        if (unstakedFeeModule != address(0)) {\n            (bool success, bytes memory data) = unstakedFeeModule.excessivelySafeStaticCall(\n                200_000, 32, abi.encodeWithSelector(IFeeModule.getFee.selector, pool)\n            );\n            if (success) {\n                uint24 fee = abi.decode(data, (uint24));\n                if (fee <= 1_000_000) {\n                    return fee;\n                }\n            }\n        }\n        return defaultUnstakedFee;\n    }\n\n    function getProtocolFee(address pool) external view override returns (uint24) {\n\n        if (gaugeManager.isGaugeAliveForPool(pool)) {\n            return 0;\n        }\n\n        if (protocolFeeModule != address(0)) {\n            (bool success, bytes memory data) = protocolFeeModule.excessivelySafeStaticCall(\n                200_000, 32, abi.encodeWithSelector(IFeeModule.getFee.selector, pool)\n            );\n            if (success) {\n                uint24 fee = abi.decode(data, (uint24));\n                if (fee <= 500_000) {\n                    return fee;\n                }\n            }\n        }\n        return defaultProtocolFee;\n    }\n\n\n    function enableTickSpacing(int24 tickSpacing, uint24 fee) public override {\n        require(msg.sender == owner);\n        require(fee > 0 && fee <= 100_000);\n\n\n        require(tickSpacing > 0 && tickSpacing < 16384);\n        require(tickSpacingToFee[tickSpacing] == 0);\n\n        tickSpacingToFee[tickSpacing] = fee;\n        _tickSpacings.push(tickSpacing);\n        emit TickSpacingEnabled(tickSpacing, fee);\n    }\n\n    function collectAllProtocolFees() external  {\n        require(msg.sender == owner);\n\n        for (uint256 i = 0; i < allPools.length; i++) {\n            CLPool(allPools[i]).collectProtocolFees(msg.sender);\n        }\n    }\n\n    function collectProtocolFees(address pool) external returns (uint128 amount0, uint128 amount1) {\n        require(msg.sender == owner);\n        (amount0, amount1) = CLPool(pool).collectProtocolFees(msg.sender);\n    }\n\n\n    function tickSpacings() external view override returns (int24[] memory) {\n        return _tickSpacings;\n    }\n\n\n    function allPoolsLength() external view override returns (uint256) {\n        return allPools.length;\n    }\n\n\n    function isPool(address pool) external view override returns (bool) {\n        return _isPool[pool];\n    }\n\n    // Unified dispatcher - merged from: setGaugeManager, createPool, setOwner\n    // Selectors: setGaugeManager=0, createPool=1, setOwner=2\n    function execute(uint8 _selector, address _gaugeManager, address _owner, address tokenA, address tokenB, int24 tickSpacing, uint160 sqrtPriceX96) public {\n        // Original: setGaugeManager()\n        if (_selector == 0) {\n            require(msg.sender == owner);\n            gaugeManager = IGaugeManager(_gaugeManager);\n        }\n        // Original: createPool()\n        else if (_selector == 1) {\n            require(tokenA != tokenB);\n            (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\n            require(token0 != address(0));\n            require(tickSpacingToFee[tickSpacing] != 0);\n            require(getPool[token0][token1][tickSpacing] == address(0));\n            pool = Clones.cloneDeterministic({\n            master: poolImplementation,\n            salt: keccak256(abi.encode(token0, token1, tickSpacing))\n            });\n            CLPool(pool).initialize({\n            _factory: address(this),\n            _token0: token0,\n            _token1: token1,\n            _tickSpacing: tickSpacing,\n            _gaugeManager: address(gaugeManager),\n            _sqrtPriceX96: sqrtPriceX96\n            });\n            allPools.push(pool);\n            _isPool[pool] = true;\n            getPool[token0][token1][tickSpacing] = pool;\n            getPool[token1][token0][tickSpacing] = pool;\n            emit PoolCreated(token0, token1, tickSpacing, pool);\n        }\n        // Original: setOwner()\n        else if (_selector == 2) {\n            address cachedOwner = owner;\n            require(msg.sender == cachedOwner);\n            require(_owner != address(0));\n            emit OwnerChanged(cachedOwner, _owner);\n            owner = _owner;\n        }\n    }\n}",
      "merged_functions": [
        "setGaugeManager",
        "createPool",
        "setOwner"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: setGaugeManager, createPool, setOwner"
      ],
      "function_to_selector": {
        "setGaugeManager": 0,
        "createPool": 1,
        "setOwner": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_003",
      "transformed_id": "rs_mg_dis_nc_gs_003",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport './interfaces/IPair.sol';\nimport './interfaces/IBribe.sol';\nimport \"./libraries/Math.sol\";\n\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport './interfaces/IRHYBR.sol';\ninterface IRewarder {\n    function onReward(\n        address user,\n        address recipient,\n        uint256 userBalance\n    ) external;\n}\n\ncontract GaugeV2 is ReentrancyGuard, Ownable {\n\n    using SafeERC20 for IERC20;\n\n    bool public immutable isForPair;\n    bool public emergency;\n\n    IERC20 public immutable rewardToken;\n    IERC20 public immutable TOKEN;\n    address public immutable rHYBR;\n    address public VE;\n    address public DISTRIBUTION;\n    address public gaugeRewarder;\n    address public internal_bribe;\n    address public external_bribe;\n\n    uint256 public DURATION;\n    uint256 internal _periodFinish;\n    uint256 public rewardRate;\n    uint256 public lastUpdateTime;\n    uint256 public rewardPerTokenStored;\n\n    mapping(address => uint256) public userRewardPerTokenPaid;\n    mapping(address => uint256) public rewards;\n\n    uint256 internal _totalSupply;\n    mapping(address => uint256) internal _balances;\n    mapping(address => uint256) public maturityTime;\n\n    event RewardAdded(uint256 reward);\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Harvest(address indexed user, uint256 reward);\n\n    event ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\n    event EmergencyActivated(address indexed gauge, uint256 timestamp);\n    event EmergencyDeactivated(address indexed gauge, uint256 timestamp);\n\n    modifier updateReward(address account) {\n        rewardPerTokenStored = rewardPerToken();\n        lastUpdateTime = lastTimeRewardApplicable();\n        if (account != address(0)) {\n            rewards[account] = earned(account);\n            userRewardPerTokenPaid[account] = rewardPerTokenStored;\n        }\n        _;\n    }\n\n    modifier onlyDistribution() {\n        require(msg.sender == DISTRIBUTION, \"NA\");\n        _;\n    }\n\n    modifier isNotEmergency() {\n        require(emergency == false, \"EMER\");\n        _;\n    }\n\n    constructor(address _rewardToken,address _rHYBR,address _ve,address _token,address _distribution, address _internal_bribe, address _external_bribe, bool _isForPair) {\n        rewardToken = IERC20(_rewardToken);\n        rHYBR = _rHYBR;\n        VE = _ve;\n        TOKEN = IERC20(_token);\n        DISTRIBUTION = _distribution;\n        DURATION = HybraTimeLibrary.WEEK;\n\n        internal_bribe = _internal_bribe;\n        external_bribe = _external_bribe;\n\n        isForPair = _isForPair;\n\n        emergency = false;\n\n    }\n\n\n    function setDistribution(address _distribution) external onlyOwner {\n        require(_distribution != address(0), \"ZA\");\n        require(_distribution != DISTRIBUTION, \"SAME_ADDR\");\n        DISTRIBUTION = _distribution;\n    }\n\n\n    function setGaugeRewarder(address _gaugeRewarder) external onlyOwner {\n        require(_gaugeRewarder != gaugeRewarder, \"SAME_ADDR\");\n        gaugeRewarder = _gaugeRewarder;\n    }\n\n\n    function setInternalBribe(address _int) external onlyOwner {\n        require(_int >= address(0), \"ZA\");\n        internal_bribe = _int;\n    }\n\n    function activateEmergencyMode() external onlyOwner {\n        require(emergency == false, \"EMER\");\n        emergency = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function stopEmergencyMode() external onlyOwner {\n\n        require(emergency == true,\"EMER\");\n\n        emergency = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n\n\n    function balanceOf(address account) external view returns (uint256) {\n        return _balanceOf(account);\n    }\n\n    function _balanceOf(address account) internal view returns (uint256) {\n\n        return _balances[account];\n    }\n\n\n    function lastTimeRewardApplicable() public view returns (uint256) {\n        return Math.min(block.timestamp, _periodFinish);\n    }\n\n\n    function rewardPerToken() public view returns (uint256) {\n        if (_totalSupply == 0) {\n            return rewardPerTokenStored;\n        } else {\n            return rewardPerTokenStored + (lastTimeRewardApplicable() - lastUpdateTime) * rewardRate * 1e18 / _totalSupply;\n        }\n    }\n\n\n    function earned(address account) public view returns (uint256) {\n        return rewards[account] + _balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18;\n    }\n\n\n    function rewardForDuration() external view returns (uint256) {\n        return rewardRate * DURATION;\n    }\n\n    function periodFinish() external view returns (uint256) {\n        return _periodFinish;\n    }\n\n\n    function depositAll() external {\n        _deposit(TOKEN.balanceOf(msg.sender), msg.sender);\n    }\n\n\n    function deposit(uint256 amount) external {\n        _deposit(amount, msg.sender);\n    }\n\n\n    function _deposit(uint256 amount, address account) internal nonReentrant isNotEmergency updateReward(account) {\n        require(amount > 0, \"ZV\");\n\n        _balances[account] = _balances[account] + amount;\n        _totalSupply = _totalSupply + amount;\n        if (address(gaugeRewarder) != address(0)) {\n            IRewarder(gaugeRewarder).onReward(account, account, _balanceOf(account));\n        }\n\n        TOKEN.safeTransferFrom(account, address(this), amount);\n\n        emit Deposit(account, amount);\n    }\n\n\n    function withdrawAll() external {\n        _withdraw(_balanceOf(msg.sender));\n    }\n\n\n    function withdraw(uint256 amount) external {\n        _withdraw(amount);\n    }\n\n\n    function _withdraw(uint256 amount) internal nonReentrant isNotEmergency updateReward(msg.sender) {\n        require(amount > 0, \"ZV\");\n        require(_balanceOf(msg.sender) > 0, \"ZV\");\n        require(block.timestamp >= maturityTime[msg.sender], \"!MATURE\");\n\n        _totalSupply = _totalSupply - amount;\n        _balances[msg.sender] = _balances[msg.sender] - amount;\n\n        if (address(gaugeRewarder) != address(0)) {\n            IRewarder(gaugeRewarder).onReward(msg.sender, msg.sender,_balanceOf(msg.sender));\n        }\n\n        TOKEN.safeTransfer(msg.sender, amount);\n\n        emit Withdraw(msg.sender, amount);\n    }\n\n    function emergencyWithdraw() external nonReentrant {\n        require(emergency, \"EMER\");\n        uint256 _amount = _balanceOf(msg.sender);\n        require(_amount > 0, \"ZV\");\n        _totalSupply = _totalSupply - _amount;\n\n        _balances[msg.sender] = 0;\n\n        TOKEN.safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n    function emergencyWithdrawAmount(uint256 _amount) external nonReentrant {\n\n        require(emergency, \"EMER\");\n        _totalSupply = _totalSupply - _amount;\n\n        _balances[msg.sender] = _balances[msg.sender] - _amount;\n\n        TOKEN.safeTransfer(msg.sender, _amount);\n        emit Withdraw(msg.sender, _amount);\n    }\n\n\n    function withdrawAllAndHarvest(uint8 _redeemType) external {\n        _withdraw(_balanceOf(msg.sender));\n        getReward(_redeemType);\n    }\n\n\n    function getReward(address _user, uint8 _redeemType) public nonReentrant onlyDistribution updateReward(_user) {\n        uint256 reward = rewards[_user];\n        if (reward > 0) {\n            rewards[_user] = 0;\n            IERC20(rewardToken).safeApprove(rHYBR, reward);\n            IRHYBR(rHYBR).depostionEmissionsToken(reward);\n            IRHYBR(rHYBR).redeemFor(reward, _redeemType, _user);\n            emit Harvest(_user, reward);\n        }\n\n        if (gaugeRewarder != address(0)) {\n            IRewarder(gaugeRewarder).onReward(_user, _user, _balanceOf(_user));\n        }\n    }\n\n\n    function getReward(uint8 _redeemType) public nonReentrant updateReward(msg.sender) {\n        uint256 reward = rewards[msg.sender];\n        if (reward > 0) {\n            rewards[msg.sender] = 0;\n            IERC20(rewardToken).safeApprove(rHYBR, reward);\n            IRHYBR(rHYBR).depostionEmissionsToken(reward);\n            IRHYBR(rHYBR).redeemFor(reward, _redeemType, msg.sender);\n            emit Harvest(msg.sender, reward);\n        }\n\n        if (gaugeRewarder != address(0)) {\n            IRewarder(gaugeRewarder).onReward(msg.sender, msg.sender, _balanceOf(msg.sender));\n        }\n    }\n\n\n    function notifyRewardAmount(address token, uint256 reward) external nonReentrant isNotEmergency onlyDistribution updateReward(address(0)) {\n        require(token == address(rewardToken), \"IA\");\n        rewardToken.safeTransferFrom(DISTRIBUTION, address(this), reward);\n\n        if (block.timestamp >= _periodFinish) {\n            rewardRate = reward / DURATION;\n        } else {\n            uint256 remaining = _periodFinish - block.timestamp;\n            uint256 leftover = remaining * rewardRate;\n            rewardRate = (reward + leftover) / DURATION;\n        }\n\n\n        uint256 balance = rewardToken.balanceOf(address(this));\n        require(rewardRate <= balance / DURATION, \"REWARD_HIGH\");\n\n        lastUpdateTime = block.timestamp;\n        _periodFinish = block.timestamp + DURATION;\n        emit RewardAdded(reward);\n    }\n\n    function claimFees() external nonReentrant returns (uint256 claimed0, uint256 claimed1) {\n        return _claimFees();\n    }\n\n     function _claimFees() internal returns (uint256 claimed0, uint256 claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n        address _token = address(TOKEN);\n        (claimed0, claimed1) = IPair(_token).claimFees();\n        if (claimed0 > 0 || claimed1 > 0) {\n\n            uint256 _fees0 = claimed0;\n            uint256 _fees1 = claimed1;\n\n            (address _token0, address _token1) = IPair(_token).tokens();\n\n            if (_fees0  > 0) {\n                IERC20(_token0).safeApprove(internal_bribe, 0);\n                IERC20(_token0).safeApprove(internal_bribe, _fees0);\n                IBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\n            }\n            if (_fees1  > 0) {\n                IERC20(_token1).safeApprove(internal_bribe, 0);\n                IERC20(_token1).safeApprove(internal_bribe, _fees1);\n                IBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\n            }\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n\n    // Unified dispatcher - merged from: emergencyWithdraw, setDistribution\n    // Selectors: emergencyWithdraw=0, setDistribution=2\n    function execute(uint8 _selector, address _distribution) public {\n        // Original: emergencyWithdraw()\n        if (_selector == 0) {\n            require(emergency, \"EMER\");\n            uint256 _amount = _balanceOf(msg.sender);\n            require(_amount > 0, \"ZV\");\n            _totalSupply = _totalSupply - _amount;\n            _balances[msg.sender] = 0;\n            TOKEN.safeTransfer(msg.sender, _amount);\n            emit Withdraw(msg.sender, _amount);\n        }\n        // Original: setDistribution()\n        else if (_selector == 1) {\n            require(_distribution != address(0), \"ZA\");\n            require(_distribution != DISTRIBUTION, \"SAME_ADDR\");\n            DISTRIBUTION = _distribution;\n        }\n    }\n}",
      "merged_functions": [
        "emergencyWithdraw",
        "setDistribution"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: emergencyWithdraw, setDistribution"
      ],
      "function_to_selector": {
        "emergencyWithdraw": 0,
        "setDistribution": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_004",
      "transformed_id": "rs_mg_dis_nc_gs_004",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public transferLockPeriod = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public head_not_withdraw_time = 1200;\n    uint256 public tail_not_withdraw_time = 300;\n\n\n    uint256 public withdrawFee = 100;\n    uint256 public constant MIN_WITHDRAW_FEE = 10;\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant BASIS = 10000;\n    address public Team;\n    uint256 public rebase;\n    uint256 public penalty;\n    uint256 public votingYield;\n\n    struct UserLock {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    mapping(address => UserLock[]) public userLocks;\n    mapping(address => uint256) public lockedBalance;\n\n\n    address public immutable HYBR;\n    address public immutable votingEscrow;\n    address public voter;\n    address public rewardsDistributor;\n    address public gaugeManager;\n    uint256 public veTokenId;\n\n\n    address public operator;\n    uint256 public lastVoteEpoch;\n\n\n    uint256 public lastRebaseTime;\n    uint256 public lastCompoundTime;\n\n\n    ISwapper public swapper;\n\n\n    error NOT_AUTHORIZED();\n\n\n    event Deposit(address indexed user, uint256 hybrAmount, uint256 sharesReceived);\n    event Withdraw(address indexed user, uint256 shares, uint256 hybrAmount, uint256 fee);\n    event Compound(uint256 rewards, uint256 newTotalLocked);\n    event PenaltyRewardReceived(uint256 amount);\n    event TransferLockPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\n    event SwapperUpdated(address indexed oldSwapper, address indexed newSwapper);\n    event VoterSet(address voter);\n    event EmergencyUnlock(address indexed user);\n    event AutoVotingEnabled(bool enabled);\n    event OperatorUpdated(address indexed oldOperator, address indexed newOperator);\n    event DefaultVotingStrategyUpdated(address[] pools, uint256[] weights);\n    event AutoVoteExecuted(uint256 epoch, address[] pools, uint256[] weights);\n\n    constructor(\n        address _HYBR,\n        address _votingEscrow\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_HYBR != address(0), \"Invalid HYBR\");\n        require(_votingEscrow != address(0), \"Invalid VE\");\n\n        HYBR = _HYBR;\n        votingEscrow = _votingEscrow;\n        lastRebaseTime = block.timestamp;\n        lastCompoundTime = block.timestamp;\n        operator = msg.sender;\n    }\n\n    function setRewardsDistributor(address _rewardsDistributor) external onlyOwner {\n        require(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\n        rewardsDistributor = _rewardsDistributor;\n    }\n\n    function setGaugeManager(address _gaugeManager) external onlyOwner {\n        require(_gaugeManager != address(0), \"Invalid gauge manager\");\n        gaugeManager = _gaugeManager;\n    }\n\n\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n\n    function deposit(uint256 amount, address recipient) external nonReentrant {\n        require(amount > 0, \"Zero amount\");\n        recipient = recipient == address(0) ? msg.sender : recipient;\n\n\n        IERC20(HYBR).transferFrom(msg.sender, address(this), amount);\n\n\n        if (veTokenId == 0) {\n            _initializeVeNFT(amount);\n        } else {\n\n            IERC20(HYBR).approve(votingEscrow, amount);\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n\n\n            _extendLockToMax();\n        }\n\n\n        uint256 shares = calculateShares(amount);\n\n\n        _mint(recipient, shares);\n\n\n        _addTransferLock(recipient, shares);\n\n        emit Deposit(msg.sender, amount, shares);\n    }\n\n\n    function withdraw(uint256 shares) external nonReentrant returns (uint256 userTokenId) {\n        require(shares > 0, \"Zero shares\");\n        require(balanceOf(msg.sender) >= shares, \"Insufficient balance\");\n        require(veTokenId != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(votingEscrow).voted(veTokenId) == false, \"Cannot withdraw yet\");\n\n        uint256 epochStart = HybraTimeLibrary.epochStart(block.timestamp);\n        uint256 epochNext = HybraTimeLibrary.epochNext(block.timestamp);\n\n        require(block.timestamp >= epochStart + head_not_withdraw_time && block.timestamp < epochNext - tail_not_withdraw_time, \"Cannot withdraw yet\");\n\n\n        uint256 hybrAmount = calculateAssets(shares);\n        require(hybrAmount > 0, \"No assets to withdraw\");\n\n\n        uint256 feeAmount = 0;\n        if (withdrawFee > 0) {\n            feeAmount = (hybrAmount * withdrawFee) / BASIS;\n        }\n\n\n        uint256 userAmount = hybrAmount - feeAmount;\n        require(userAmount > 0, \"Amount too small after fee\");\n\n\n        uint256 veBalance = totalAssets();\n        require(hybrAmount <= veBalance, \"Insufficient veNFT balance\");\n\n        uint256 remainingAmount = veBalance - userAmount - feeAmount;\n        require(remainingAmount >= 0, \"Cannot withdraw entire veNFT\");\n\n\n        _burn(msg.sender, shares);\n\n\n        uint256[] memory amounts = new uint256[](3);\n        amounts[0] = remainingAmount;\n        amounts[1] = userAmount;\n        amounts[2] = feeAmount;\n\n        uint256[] memory newTokenIds = IVotingEscrow(votingEscrow).multiSplit(veTokenId, amounts);\n\n\n        veTokenId = newTokenIds[0];\n        userTokenId = newTokenIds[1];\n        uint256 feeTokenId = newTokenIds[2];\n\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), msg.sender, userTokenId);\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), Team, feeTokenId);\n        emit Withdraw(msg.sender, shares, userAmount, feeAmount);\n    }\n\n\n    function _initializeVeNFT(uint256 initialAmount) internal {\n\n        IERC20(HYBR).approve(votingEscrow, type(uint256).max);\n        uint256 lockTime = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n\n        veTokenId = IVotingEscrow(votingEscrow).create_lock_for(initialAmount, lockTime, address(this));\n\n    }\n\n\n    function calculateShares(uint256 amount) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        uint256 _totalAssets = totalAssets();\n        if (_totalSupply == 0 || _totalAssets == 0) {\n            return amount;\n        }\n        return (amount * _totalSupply) / _totalAssets;\n    }\n\n\n    function calculateAssets(uint256 shares) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return shares;\n        }\n        return (shares * totalAssets()) / _totalSupply;\n    }\n\n\n    function totalAssets() public view returns (uint256) {\n        if (veTokenId == 0) {\n            return 0;\n        }\n\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\n        return uint256(int256(locked.amount));\n    }\n\n\n    function _addTransferLock(address user, uint256 amount) internal {\n        uint256 unlockTime = block.timestamp + transferLockPeriod;\n        userLocks[user].push(UserLock({\n            amount: amount,\n            unlockTime: unlockTime\n        }));\n        lockedBalance[user] += amount;\n    }\n\n\n    function previewAvailable(address user) external view returns (uint256 available) {\n        uint256 totalBalance = balanceOf(user);\n        uint256 currentLocked = 0;\n\n        UserLock[] storage arr = userLocks[user];\n        for (uint256 i = 0; i < arr.length; i++) {\n            if (arr[i].unlockTime > block.timestamp) {\n                currentLocked += arr[i].amount;\n            }\n        }\n\n        return totalBalance > currentLocked ? totalBalance - currentLocked : 0;\n    }\n\n    function _cleanExpired(address user) internal returns (uint256 freed) {\n        UserLock[] storage arr = userLocks[user];\n        uint256 len = arr.length;\n        if (len == 0) return 0;\n\n        uint256 write = 0;\n        unchecked {\n            for (uint256 i = 0; i < len; i++) {\n                UserLock memory L = arr[i];\n                if (L.unlockTime <= block.timestamp) {\n                    freed += L.amount;\n                } else {\n                    if (write != i) arr[write] = L;\n                    write++;\n                }\n            }\n            if (freed > 0) {\n                lockedBalance[user] -= freed;\n            }\n            while (arr.length > write) {\n                arr.pop();\n            }\n        }\n    }\n\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0) && to != address(0)) {\n            uint256 totalBalance = balanceOf(from);\n\n\n            uint256 currentAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\n\n\n            if (currentAvailable >= amount) {\n                return;\n            }\n\n\n            _cleanExpired(from);\n            uint256 finalAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\n\n\n            require(finalAvailable >= amount, \"Tokens locked\");\n        }\n    }\n\n\n    function claimRewards() external onlyOperator {\n        require(voter != address(0), \"Voter not set\");\n        require(rewardsDistributor != address(0), \"Distributor not set\");\n\n\n        uint256  rebaseAmount = IRewardsDistributor(rewardsDistributor).claim(veTokenId);\n        rebase += rebaseAmount;\n\n        address[] memory votedPools = IVoter(voter).poolVote(veTokenId);\n\n        for (uint256 i = 0; i < votedPools.length; i++) {\n            if (votedPools[i] != address(0)) {\n                address gauge = IGaugeManager(gaugeManager).gauges(votedPools[i]);\n\n                if (gauge != address(0)) {\n\n                    address[] memory bribes = new address[](1);\n                    address[][] memory tokens = new address[][](1);\n\n\n                    address internalBribe = IGaugeManager(gaugeManager).internal_bribes(gauge);\n                    if (internalBribe != address(0)) {\n                        uint256 tokenCount = IBribe(internalBribe).rewardsListLength();\n                        if (tokenCount > 0) {\n                            address[] memory bribeTokens = new address[](tokenCount);\n                            for (uint256 j = 0; j < tokenCount; j++) {\n                                bribeTokens[j] = IBribe(internalBribe).bribeTokens(j);\n                            }\n                            bribes[0] = internalBribe;\n                            tokens[0] = bribeTokens;\n\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n                        }\n                    }\n\n\n                    address externalBribe = IGaugeManager(gaugeManager).external_bribes(gauge);\n                    if (externalBribe != address(0)) {\n                        uint256 tokenCount = IBribe(externalBribe).rewardsListLength();\n                        if (tokenCount > 0) {\n                            address[] memory bribeTokens = new address[](tokenCount);\n                            for (uint256 j = 0; j < tokenCount; j++) {\n                                bribeTokens[j] = IBribe(externalBribe).bribeTokens(j);\n                            }\n                            bribes[0] = externalBribe;\n                            tokens[0] = bribeTokens;\n\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    function executeSwap(ISwapper.SwapParams calldata _params) external nonReentrant onlyOperator {\n        require(address(swapper) != address(0), \"Swapper not set\");\n\n\n        uint256 tokenBalance = IERC20(_params.tokenIn).balanceOf(address(this));\n        require(tokenBalance >= _params.amountIn, \"Insufficient token balance\");\n\n\n        IERC20(_params.tokenIn).safeApprove(address(swapper), _params.amountIn);\n\n\n        uint256 hybrReceived = swapper.swapToHYBR(_params);\n\n\n        IERC20(_params.tokenIn).safeApprove(address(swapper), 0);\n\n\n        votingYield += hybrReceived;\n    }\n\n\n    function compound() external onlyOperator {\n\n\n        uint256 hybrBalance = IERC20(HYBR).balanceOf(address(this));\n\n        if (hybrBalance > 0) {\n\n            IERC20(HYBR).safeApprove(votingEscrow, hybrBalance);\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, hybrBalance);\n\n\n            _extendLockToMax();\n\n            lastCompoundTime = block.timestamp;\n\n            emit Compound(hybrBalance, totalAssets());\n        }\n    }\n\n\n    function vote(address[] calldata _poolVote, uint256[] calldata _weights) external {\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\n        require(voter != address(0), \"Voter not set\");\n\n        IVoter(voter).vote(veTokenId, _poolVote, _weights);\n        lastVoteEpoch = HybraTimeLibrary.epochStart(block.timestamp);\n\n    }\n\n\n    function reset() external {\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\n        require(voter != address(0), \"Voter not set\");\n\n        IVoter(voter).reset(veTokenId);\n    }\n\n\n    function receivePenaltyReward(uint256 amount) external {\n\n\n        if (amount > 0) {\n            IERC20(HYBR).approve(votingEscrow, amount);\n\n            if(veTokenId == 0){\n                _initializeVeNFT(amount);\n            } else{\n                IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n\n\n                _extendLockToMax();\n            }\n        }\n        penalty += amount;\n        emit PenaltyRewardReceived(amount);\n    }\n\n\n    function setVoter(address _voter) external onlyOwner {\n        require(_voter != address(0), \"Invalid voter\");\n        voter = _voter;\n        emit VoterSet(_voter);\n    }\n\n\n    function setTransferLockPeriod(uint256 _period) external onlyOwner {\n        require(_period >= MIN_LOCK_PERIOD && _period <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 oldPeriod = transferLockPeriod;\n        transferLockPeriod = _period;\n        emit TransferLockPeriodUpdated(oldPeriod, _period);\n    }\n\n\n    function setWithdrawFee(uint256 _fee) external onlyOwner {\n        require(_fee >= MIN_WITHDRAW_FEE && _fee <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        withdrawFee = _fee;\n    }\n\n    function setHeadNotWithdrawTime(uint256 _time) external onlyOwner {\n        head_not_withdraw_time = _time;\n    }\n\n    function setTailNotWithdrawTime(uint256 _time) external onlyOwner {\n        tail_not_withdraw_time = _time;\n    }\n\n\n    function setSwapper(address _swapper) external onlyOwner {\n        require(_swapper != address(0), \"Invalid swapper\");\n        address oldSwapper = address(swapper);\n        swapper = ISwapper(_swapper);\n        emit SwapperUpdated(oldSwapper, _swapper);\n    }\n\n\n    function setTeam(address _team) external onlyOwner {\n        require(_team != address(0), \"Invalid team\");\n        Team = _team;\n    }\n\n\n    function emergencyUnlock(address user) external onlyOperator {\n        delete userLocks[user];\n        lockedBalance[user] = 0;\n        emit EmergencyUnlock(user);\n    }\n\n\n    function getUserLocks(address user) external view returns (UserLock[] memory) {\n        return userLocks[user];\n    }\n\n\n    function setOperator(address _operator) external onlyOwner {\n        require(_operator != address(0), \"Invalid operator\");\n        address oldOperator = operator;\n        operator = _operator;\n        emit OperatorUpdated(oldOperator, _operator);\n    }\n\n\n    function getLockEndTime() external view returns (uint256) {\n        if (veTokenId == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\n        return uint256(locked.end);\n    }\n\n\n    function _extendLockToMax() internal {\n        if (veTokenId == 0) return;\n\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\n        if (locked.isPermanent || locked.end <= block.timestamp) return;\n\n        uint256 maxUnlockTime = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n\n        if (maxUnlockTime > locked.end + 2 hours) {\n            try IVotingEscrow(votingEscrow).increase_unlock_time(veTokenId, HybraTimeLibrary.MAX_LOCK_DURATION) {\n\n            } catch {\n\n\n            }\n        }\n    }\n\n\n    // Unified dispatcher - merged from: deposit, setRewardsDistributor, setGaugeManager\n    // Selectors: deposit=0, setRewardsDistributor=1, setGaugeManager=2\n    function execute(uint8 _selector, address _gaugeManager, address _rewardsDistributor, address recipient, uint256 amount) public {\n        // Original: deposit()\n        if (_selector == 0) {\n            require(amount > 0, \"Zero amount\");\n            recipient = recipient == address(0) ? msg.sender : recipient;\n            IERC20(HYBR).transferFrom(msg.sender, address(this), amount);\n            if (veTokenId == 0) {\n            _initializeVeNFT(amount);\n            } else {\n            IERC20(HYBR).approve(votingEscrow, amount);\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n            _extendLockToMax();\n            }\n            uint256 shares = calculateShares(amount);\n            _mint(recipient, shares);\n            _addTransferLock(recipient, shares);\n            emit Deposit(msg.sender, amount, shares);\n        }\n        // Original: setRewardsDistributor()\n        else if (_selector == 1) {\n            require(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\n            rewardsDistributor = _rewardsDistributor;\n        }\n        // Original: setGaugeManager()\n        else if (_selector == 2) {\n            require(_gaugeManager != address(0), \"Invalid gauge manager\");\n            gaugeManager = _gaugeManager;\n        }\n    }\n}",
      "merged_functions": [
        "deposit",
        "setRewardsDistributor",
        "setGaugeManager"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: deposit, setRewardsDistributor, setGaugeManager"
      ],
      "function_to_selector": {
        "deposit": 0,
        "setRewardsDistributor": 1,
        "setGaugeManager": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_005",
      "transformed_id": "rs_mg_dis_nc_gs_005",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPairInfo.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVotingEscrow.sol';\nimport './interfaces/IGaugeManager.sol';\nimport './interfaces/IPermissionsRegistry.sol';\nimport './interfaces/ITokenHandler.sol';\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract VoterV3 is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public _ve;\n    address internal base;\n    address public permissionRegistry;\n    address public tokenHandler;\n    uint256 public maxVotingNum;\n    uint public EPOCH_DURATION;\n    uint256 internal constant MIN_VOTING_NUM = 10;\n    IGaugeManager public gaugeManager;\n\n    mapping(uint256 => mapping(address => uint256)) public votes;\n    mapping(uint256 => address[]) public poolVote;\n\n    mapping(address => uint256) public weights;\n    uint256 public totalWeight;\n    mapping(uint256 => uint256) public usedWeights;\n\n    mapping(uint256 => uint256) public lastVoted;\n    mapping(uint256 => uint256) public lastVotedTimestamp;\n\n    event Voted(address indexed voter, uint256 tokenId, uint256 weight);\n    event Abstained(uint256 tokenId, uint256 weight);\n    event SetPermissionRegistry(address indexed old, address indexed latest);\n\n    constructor() {}\n\n\n    function initialize(\n        address __ve,\n        address _tokenHandler,\n        address _gaugeManager,\n        address _permissionRegistry\n    ) public initializer {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _ve = __ve;\n        base = IVotingEscrow(__ve).token();\n        gaugeManager = IGaugeManager(_gaugeManager);\n        permissionRegistry = _permissionRegistry;\n        tokenHandler = _tokenHandler;\n        maxVotingNum = 30;\n        EPOCH_DURATION = HybraTimeLibrary.WEEK;\n    }\n\n\n    modifier VoterAdmin() {\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"VOTER_ADMIN\",msg.sender), 'VOTER_ADMIN');\n        _;\n    }\n\n    modifier Governance() {\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"GOVERNANCE\",msg.sender), 'GOVERNANCE');\n        _;\n    }\n\n    modifier GenesisManager() {\n        require(IPermissionsRegistry(permissionRegistry).hasRole(\"GENESIS_MANAGER\", msg.sender), 'GENESIS_MANAGER');\n        _;\n    }\n\n\n    function setPermissionsRegistry(address _permissionRegistry) external VoterAdmin {\n        require(_permissionRegistry.code.length > 0, \"CODELEN\");\n        require(_permissionRegistry != address(0), \"ZA\");\n        emit SetPermissionRegistry(permissionRegistry, _permissionRegistry);\n        permissionRegistry = _permissionRegistry;\n    }\n\n    function setMaxVotingNum(uint256 _maxVotingNum) external VoterAdmin {\n        require (_maxVotingNum >= MIN_VOTING_NUM, \"LOW_VOTE\");\n        maxVotingNum = _maxVotingNum;\n    }\n\n\n    function reset(uint256 _tokenId) external onlyNewEpoch(_tokenId) nonReentrant {\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\n        _reset(_tokenId);\n        IVotingEscrow(_ve).abstain(_tokenId);\n    }\n\n    function _reset(uint256 _tokenId) internal {\n        address[] storage _poolVote = poolVote[_tokenId];\n        uint256 _poolVoteCnt = _poolVote.length;\n        uint256 _totalWeight = 0;\n\n        for (uint256 i = 0; i < _poolVoteCnt; i ++) {\n            address _pool = _poolVote[i];\n            uint256 _votes = votes[_tokenId][_pool];\n\n            if (_votes != 0) {\n                weights[_pool] -= _votes;\n\n                votes[_tokenId][_pool] -= _votes;\n                address internal_bribe = gaugeManager.fetchInternalBribeFromPool(_pool);\n                address external_bribe = gaugeManager.fetchExternalBribeFromPool(_pool);\n                IBribe(internal_bribe).withdraw(uint256(_votes), _tokenId);\n                IBribe(external_bribe).withdraw(uint256(_votes), _tokenId);\n\n\n                _totalWeight += _votes;\n\n                emit Abstained(_tokenId, _votes);\n            }\n        }\n        totalWeight -= _totalWeight;\n        usedWeights[_tokenId] = 0;\n        delete poolVote[_tokenId];\n    }\n\n\n    function poke(uint256 _tokenId) external nonReentrant {\n        uint256 _timestamp = block.timestamp;\n        if (_timestamp <= HybraTimeLibrary.epochVoteStart(_timestamp)){\n            revert(\"DW\");\n        }\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId) || msg.sender == _ve, \"NAO||VE\");\n        address[] memory _poolVote = poolVote[_tokenId];\n        uint256 _poolCnt = _poolVote.length;\n        uint256[] memory _weights = new uint256[](_poolCnt);\n\n        for (uint256 i = 0; i < _poolCnt; i ++) {\n            _weights[i] = votes[_tokenId][_poolVote[i]];\n        }\n\n        _vote(_tokenId, _poolVote, _weights);\n    }\n\n\n    function vote(uint256 _tokenId, address[] calldata _poolVote, uint256[] calldata _weights)\n        external onlyNewEpoch(_tokenId) nonReentrant {\n        require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\n        require(_poolVote.length == _weights.length, \"MISMATCH_LEN\");\n        require(_poolVote.length <= maxVotingNum, \"EXCEEDS\");\n        uint256 _timestamp = block.timestamp;\n\n        _vote(_tokenId, _poolVote, _weights);\n        lastVoted[_tokenId] = HybraTimeLibrary.epochStart(block.timestamp) + 1;\n        lastVotedTimestamp[_tokenId] = block.timestamp;\n    }\n\n    function _vote(uint256 _tokenId, address[] memory _poolVote, uint256[] memory _weights) internal {\n        _reset(_tokenId);\n        uint256 _poolCnt = _poolVote.length;\n        uint256 _weight = IVotingEscrow(_ve).balanceOfNFT(_tokenId);\n        uint256 _totalVoteWeight = 0;\n        uint256 _usedWeight = 0;\n\n        for (uint i = 0; i < _poolCnt; i++) {\n\n            if(gaugeManager.isGaugeAliveForPool(_poolVote[i])) _totalVoteWeight += _weights[i];\n        }\n\n        for (uint256 i = 0; i < _poolCnt; i++) {\n            address _pool = _poolVote[i];\n\n            if (gaugeManager.isGaugeAliveForPool(_pool)) {\n                uint256 _poolWeight = _weights[i] * _weight / _totalVoteWeight;\n\n                require(votes[_tokenId][_pool] == 0, \"ZV\");\n                require(_poolWeight != 0, \"ZV\");\n\n                poolVote[_tokenId].push(_pool);\n                weights[_pool] += _poolWeight;\n\n                votes[_tokenId][_pool] = _poolWeight;\n                address internal_bribe = gaugeManager.fetchInternalBribeFromPool(_pool);\n                address external_bribe = gaugeManager.fetchExternalBribeFromPool(_pool);\n\n                IBribe(internal_bribe).deposit(uint256(_poolWeight), _tokenId);\n                IBribe(external_bribe).deposit(uint256(_poolWeight), _tokenId);\n\n                _usedWeight += _poolWeight;\n                emit Voted(msg.sender, _tokenId, _poolWeight);\n            }\n        }\n        if (_usedWeight > 0) IVotingEscrow(_ve).voting(_tokenId);\n        totalWeight += _usedWeight;\n        usedWeights[_tokenId] = _usedWeight;\n    }\n\n    modifier onlyNewEpoch(uint256 _tokenId) {\n\n        if (HybraTimeLibrary.epochStart(block.timestamp) <= lastVoted[_tokenId]) revert(\"VOTED\");\n        if (block.timestamp <= HybraTimeLibrary.epochVoteStart(block.timestamp)) revert(\"DW\");\n        _;\n    }\n\n\n    function length() external view returns (uint256) {\n        return gaugeManager.pools().length;\n    }\n\n\n    function poolVoteLength(uint256 tokenId) external view returns(uint256) {\n        return poolVote[tokenId].length;\n    }\n\n    function setGaugeManager(address _gaugeManager) external VoterAdmin {\n        require(_gaugeManager != address(0));\n        gaugeManager = IGaugeManager(_gaugeManager);\n    }\n\n\n    // Unified dispatcher - merged from: poke, initialize, setPermissionsRegistry\n    // Selectors: poke=0, initialize=1, setPermissionsRegistry=2\n    function execute(uint8 _selector, address __ve, address _gaugeManager, address _permissionRegistry, address _tokenHandler, uint256 _tokenId) public {\n        // Original: poke()\n        if (_selector == 0) {\n            uint256 _timestamp = block.timestamp;\n            if (_timestamp <= HybraTimeLibrary.epochVoteStart(_timestamp)){\n            revert(\"DW\");\n            }\n            require(IVotingEscrow(_ve).isApprovedOrOwner(msg.sender, _tokenId) || msg.sender == _ve, \"NAO||VE\");\n            address[] memory _poolVote = poolVote[_tokenId];\n            uint256 _poolCnt = _poolVote.length;\n            uint256[] memory _weights = new uint256[](_poolCnt);\n            for (uint256 i = 0; i < _poolCnt; i ++) {\n            _weights[i] = votes[_tokenId][_poolVote[i]];\n            }\n            _vote(_tokenId, _poolVote, _weights);\n        }\n        // Original: initialize()\n        else if (_selector == 1) {\n            __Ownable_init();\n            __ReentrancyGuard_init();\n            _ve = __ve;\n            base = IVotingEscrow(__ve).token();\n            gaugeManager = IGaugeManager(_gaugeManager);\n            permissionRegistry = _permissionRegistry;\n            tokenHandler = _tokenHandler;\n            maxVotingNum = 30;\n            EPOCH_DURATION = HybraTimeLibrary.WEEK;\n        }\n        // Original: setPermissionsRegistry()\n        else if (_selector == 2) {\n            require(_permissionRegistry.code.length > 0, \"CODELEN\");\n            require(_permissionRegistry != address(0), \"ZA\");\n            emit SetPermissionRegistry(permissionRegistry, _permissionRegistry);\n            permissionRegistry = _permissionRegistry;\n        }\n    }\n}",
      "merged_functions": [
        "poke",
        "initialize",
        "setPermissionsRegistry"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: poke, initialize, setPermissionsRegistry"
      ],
      "function_to_selector": {
        "poke": 0,
        "initialize": 1,
        "setPermissionsRegistry": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_006",
      "transformed_id": "rs_mg_dis_nc_gs_006",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable rewardToken;\n    address public immutable rHYBR;\n    address public VE;\n    address public DISTRIBUTION;\n    address public internal_bribe;\n    address public external_bribe;\n\n    uint256 public DURATION;\n    uint256 internal _periodFinish;\n    uint256 public rewardRate;\n    ICLPool public clPool;\n    address public poolAddress;\n    INonfungiblePositionManager public nonfungiblePositionManager;\n\n    bool public emergency;\n    bool public immutable isForPair;\n    address immutable factory;\n\n    mapping(uint256 => uint256) public  rewardRateByEpoch;\n    mapping(address => EnumerableSet.UintSet) internal _stakes;\n    mapping(uint256 => uint256) public  rewardGrowthInside;\n\n    mapping(uint256 => uint256) public  rewards;\n\n    mapping(uint256 => uint256) public  lastUpdateTime;\n\n    event RewardAdded(uint256 reward);\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Harvest(address indexed user, uint256 reward);\n    event ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\n    event EmergencyActivated(address indexed gauge, uint256 timestamp);\n    event EmergencyDeactivated(address indexed gauge, uint256 timestamp);\n\n    constructor(address _rewardToken, address _rHYBR, address _ve, address _pool, address _distribution, address _internal_bribe,\n        address _external_bribe, bool _isForPair, address nfpm,  address _factory) {\n        factory = _factory;\n        rewardToken = IERC20(_rewardToken);\n        rHYBR = _rHYBR;\n        VE = _ve;\n        poolAddress = _pool;\n        clPool = ICLPool(_pool);\n        DISTRIBUTION = _distribution;\n        DURATION = HybraTimeLibrary.WEEK;\n\n        internal_bribe = _internal_bribe;\n        external_bribe = _external_bribe;\n        isForPair = _isForPair;\n        nonfungiblePositionManager = INonfungiblePositionManager(nfpm);\n        emergency = false;\n    }\n\n    modifier onlyDistribution() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier isNotEmergency() {\n        require(emergency == false, \"emergency\");\n        _;\n    }\n\n    function _updateRewards(uint256 tokenId, int24 tickLower, int24 tickUpper) internal {\n        if (lastUpdateTime[tokenId] == block.timestamp) return;\n        clPool.updateRewardsGrowthGlobal();\n        lastUpdateTime[tokenId] = block.timestamp;\n        rewards[tokenId] += _earned(tokenId);\n        rewardGrowthInside[tokenId] = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\n    }\n\n    function activateEmergencyMode() external onlyOwner {\n        require(emergency == false, \"emergency\");\n        emergency = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function stopEmergencyMode() external onlyOwner {\n\n        require(emergency == true,\"emergency\");\n\n        emergency = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function balanceOf(uint256 tokenId) external view returns (uint256) {\n        (,,,,,,,uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\n        return liquidity;\n    }\n\n    function _getPoolAddress(address token0, address token1, int24 tickSpacing) internal view returns (address) {\n        return ICLFactory(nonfungiblePositionManager.factory()).getPool(token0, token1, tickSpacing);\n    }\n\n    function earned(uint256 tokenId) external view returns (uint256 reward) {\n        require(_stakes[msg.sender].contains(tokenId), \"NA\");\n\n        uint256 reward = _earned(tokenId);\n        return (reward);\n    }\n\n       function _earned(uint256 tokenId) internal view returns (uint256) {\n        uint256 lastUpdated = clPool.lastUpdated();\n\n        uint256 timeDelta = block.timestamp - lastUpdated;\n\n        uint256 rewardGrowthGlobalX128 = clPool.rewardGrowthGlobalX128();\n        uint256 rewardReserve = clPool.rewardReserve();\n\n        if (timeDelta != 0 && rewardReserve > 0 && clPool.stakedLiquidity() > 0) {\n            uint256 reward = rewardRate * timeDelta;\n            if (reward > rewardReserve) reward = rewardReserve;\n\n            rewardGrowthGlobalX128 += FullMath.mulDiv(reward, FixedPoint128.Q128, clPool.stakedLiquidity());\n        }\n\n        (,,,,, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\n\n        uint256 rewardPerTokenInsideInitialX128 = rewardGrowthInside[tokenId];\n        uint256 rewardPerTokenInsideX128 = clPool.getRewardGrowthInside(tickLower, tickUpper, rewardGrowthGlobalX128);\n\n        uint256 claimable =\n            FullMath.mulDiv(rewardPerTokenInsideX128 - rewardPerTokenInsideInitialX128, liquidity, FixedPoint128.Q128);\n        return claimable;\n    }\n\n    function deposit(uint256 tokenId) external nonReentrant isNotEmergency {\n\n         (,,address token0, address token1, int24 tickSpacing, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) =\n            nonfungiblePositionManager.positions(tokenId);\n\n        require(liquidity > 0, \"Gauge: zero liquidity\");\n\n        address positionPool = _getPoolAddress(token0, token1, tickSpacing);\n\n        require(positionPool == poolAddress, \"Pool mismatch: Position not for this gauge pool\");\n\n        nonfungiblePositionManager.collect(INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: msg.sender,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            }));\n\n        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId);\n\n        clPool.stake(int128(liquidity), tickLower, tickUpper, true);\n\n        uint256 rewardGrowth = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\n        rewardGrowthInside[tokenId] = rewardGrowth;\n        lastUpdateTime[tokenId] = block.timestamp;\n\n        _stakes[msg.sender].add(tokenId);\n\n        emit Deposit(msg.sender, tokenId);\n    }\n\n    function withdraw(uint256 tokenId, uint8 redeemType) external nonReentrant isNotEmergency {\n           require(_stakes[msg.sender].contains(tokenId), \"NA\");\n\n\n        nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: msg.sender,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        (,,,,, int24 tickLower, int24 tickUpper, uint128 liquidityToStake,,,,) = nonfungiblePositionManager.positions(tokenId);\n        _getReward(tickLower, tickUpper, tokenId, msg.sender, redeemType);\n\n\n        if (liquidityToStake != 0) {\n            clPool.stake(-int128(liquidityToStake), tickLower, tickUpper, true);\n        }\n\n        _stakes[msg.sender].remove(tokenId);\n        nonfungiblePositionManager.safeTransferFrom(address(this), msg.sender, tokenId);\n\n        emit Withdraw(msg.sender, tokenId);\n    }\n\n    function getReward(uint256 tokenId, address account,uint8 redeemType ) public nonReentrant onlyDistribution {\n\n        require(_stakes[account].contains(tokenId), \"NA\");\n\n        (,,,,, int24 tickLower, int24 tickUpper,,,,,) = nonfungiblePositionManager.positions(tokenId);\n        _getReward(tickLower, tickUpper, tokenId, account, redeemType);\n    }\n\n    function _getReward(int24 tickLower, int24 tickUpper, uint256 tokenId,address account, uint8 redeemType) internal {\n        _updateRewards(tokenId, tickLower, tickUpper);\n        uint256 rewardAmount = rewards[tokenId];\n        if(rewardAmount > 0){\n            delete rewards[tokenId];\n            rewardToken.safeApprove(rHYBR, rewardAmount);\n            IRHYBR(rHYBR).depostionEmissionsToken(rewardAmount);\n            IRHYBR(rHYBR).redeemFor(rewardAmount, redeemType, account);\n        }\n        emit Harvest(msg.sender, rewardAmount);\n    }\n\n    function notifyRewardAmount(address token, uint256 rewardAmount) external nonReentrant\n        isNotEmergency onlyDistribution returns (uint256 currentRate) {\n        require(token == address(rewardToken), \"Invalid reward token\");\n\n\n        clPool.updateRewardsGrowthGlobal();\n\n\n        uint256 epochTimeRemaining = HybraTimeLibrary.epochNext(block.timestamp) - block.timestamp;\n        uint256 epochEndTimestamp = block.timestamp + epochTimeRemaining;\n\n\n        uint256 totalRewardAmount = rewardAmount + clPool.rollover();\n\n\n        if (block.timestamp >= _periodFinish) {\n\n            rewardRate = rewardAmount / epochTimeRemaining;\n            clPool.syncReward({\n                rewardRate: rewardRate,\n                rewardReserve: totalRewardAmount,\n                periodFinish: epochEndTimestamp\n            });\n        } else {\n\n            uint256 pendingRewards = epochTimeRemaining * rewardRate;\n            rewardRate = (rewardAmount + pendingRewards) / epochTimeRemaining;\n            clPool.syncReward({\n                rewardRate: rewardRate,\n                rewardReserve: totalRewardAmount + pendingRewards,\n                periodFinish: epochEndTimestamp\n            });\n        }\n\n\n        rewardRateByEpoch[HybraTimeLibrary.epochStart(block.timestamp)] = rewardRate;\n\n\n        rewardToken.safeTransferFrom(DISTRIBUTION, address(this), rewardAmount);\n\n\n        uint256 contractBalance = rewardToken.balanceOf(address(this));\n        require(rewardRate <= contractBalance / epochTimeRemaining, \"Insufficient balance for reward rate\");\n\n\n        _periodFinish = epochEndTimestamp;\n        currentRate = rewardRate;\n\n        emit RewardAdded(rewardAmount);\n    }\n\n    function gaugeBalances() external view returns (uint256 token0, uint256 token1){\n\n        (token0, token1) = clPool.gaugeFees();\n\n    }\n\n    function claimFees() external nonReentrant returns (uint256 claimed0, uint256 claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint256 claimed0, uint256 claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n\n        clPool.collectFees();\n\n        address _token0 = clPool.token0();\n        address _token1 = clPool.token1();\n\n        claimed0 = IERC20(_token0).balanceOf(address(this));\n        claimed1 = IERC20(_token1).balanceOf(address(this));\n\n        if (claimed0 > 0 || claimed1 > 0) {\n\n            uint256 _fees0 = claimed0;\n            uint256 _fees1 = claimed1;\n\n            if (_fees0  > 0) {\n                IERC20(_token0).safeApprove(internal_bribe, 0);\n                IERC20(_token0).safeApprove(internal_bribe, _fees0);\n                IBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\n            }\n            if (_fees1  > 0) {\n                IERC20(_token1).safeApprove(internal_bribe, 0);\n                IERC20(_token1).safeApprove(internal_bribe, _fees1);\n                IBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\n            }\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n\n    function rewardForDuration() external view returns (uint256) {\n        return rewardRate * DURATION;\n    }\n\n\n    function setInternalBribe(address _int) external onlyOwner {\n        require(_int >= address(0), \"zero\");\n        internal_bribe = _int;\n    }\n\n    function _safeTransfer(address token,address to,uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n\n    // Unified dispatcher - merged from: notifyRewardAmount, activateEmergencyMode, stopEmergencyMode\n    // Selectors: notifyRewardAmount=0, activateEmergencyMode=1, stopEmergencyMode=2\n    function execute(uint8 _selector, address token, uint256 rewardAmount) public {\n        // Original: notifyRewardAmount()\n        if (_selector == 0) {\n            require(token == address(rewardToken), \"Invalid reward token\");\n            clPool.updateRewardsGrowthGlobal();\n            uint256 epochTimeRemaining = HybraTimeLibrary.epochNext(block.timestamp) - block.timestamp;\n            uint256 epochEndTimestamp = block.timestamp + epochTimeRemaining;\n            uint256 totalRewardAmount = rewardAmount + clPool.rollover();\n            if (block.timestamp >= _periodFinish) {\n            rewardRate = rewardAmount / epochTimeRemaining;\n            clPool.syncReward({\n            rewardRate: rewardRate,\n            rewardReserve: totalRewardAmount,\n            periodFinish: epochEndTimestamp\n            });\n            } else {\n            uint256 pendingRewards = epochTimeRemaining * rewardRate;\n            rewardRate = (rewardAmount + pendingRewards) / epochTimeRemaining;\n            clPool.syncReward({\n            rewardRate: rewardRate,\n            rewardReserve: totalRewardAmount + pendingRewards,\n            periodFinish: epochEndTimestamp\n            });\n            }\n            rewardRateByEpoch[HybraTimeLibrary.epochStart(block.timestamp)] = rewardRate;\n            rewardToken.safeTransferFrom(DISTRIBUTION, address(this), rewardAmount);\n            uint256 contractBalance = rewardToken.balanceOf(address(this));\n            require(rewardRate <= contractBalance / epochTimeRemaining, \"Insufficient balance for reward rate\");\n            _periodFinish = epochEndTimestamp;\n            currentRate = rewardRate;\n            emit RewardAdded(rewardAmount);\n        }\n        // Original: activateEmergencyMode()\n        else if (_selector == 1) {\n            require(emergency == false, \"emergency\");\n            emergency = true;\n            emit EmergencyActivated(address(this), block.timestamp);\n        }\n        // Original: stopEmergencyMode()\n        else if (_selector == 2) {\n            require(emergency == true,\"emergency\");\n            emergency = false;\n            emit EmergencyDeactivated(address(this), block.timestamp);\n        }\n    }\n}",
      "merged_functions": [
        "notifyRewardAmount",
        "activateEmergencyMode",
        "stopEmergencyMode"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: notifyRewardAmount, activateEmergencyMode, stopEmergencyMode"
      ],
      "function_to_selector": {
        "notifyRewardAmount": 0,
        "activateEmergencyMode": 1,
        "stopEmergencyMode": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_007",
      "transformed_id": "rs_mg_dis_nc_gs_007",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable rewardToken;\n    address public immutable rHYBR;\n    address public VE;\n    address public DISTRIBUTION;\n    address public internal_bribe;\n    address public external_bribe;\n\n    uint256 public DURATION;\n    uint256 internal _periodFinish;\n    uint256 public rewardRate;\n    ICLPool public clPool;\n    address public poolAddress;\n    INonfungiblePositionManager public nonfungiblePositionManager;\n\n    bool public emergency;\n    bool public immutable isForPair;\n    address immutable factory;\n\n    mapping(uint256 => uint256) public  rewardRateByEpoch;\n    mapping(address => EnumerableSet.UintSet) internal _stakes;\n    mapping(uint256 => uint256) public  rewardGrowthInside;\n\n    mapping(uint256 => uint256) public  rewards;\n\n    mapping(uint256 => uint256) public  lastUpdateTime;\n\n    event RewardAdded(uint256 reward);\n    event Deposit(address indexed user, uint256 amount);\n    event Withdraw(address indexed user, uint256 amount);\n    event Harvest(address indexed user, uint256 reward);\n    event ClaimFees(address indexed from, uint256 claimed0, uint256 claimed1);\n    event EmergencyActivated(address indexed gauge, uint256 timestamp);\n    event EmergencyDeactivated(address indexed gauge, uint256 timestamp);\n\n    constructor(address _rewardToken, address _rHYBR, address _ve, address _pool, address _distribution, address _internal_bribe,\n        address _external_bribe, bool _isForPair, address nfpm,  address _factory) {\n        factory = _factory;\n        rewardToken = IERC20(_rewardToken);\n        rHYBR = _rHYBR;\n        VE = _ve;\n        poolAddress = _pool;\n        clPool = ICLPool(_pool);\n        DISTRIBUTION = _distribution;\n        DURATION = HybraTimeLibrary.WEEK;\n\n        internal_bribe = _internal_bribe;\n        external_bribe = _external_bribe;\n        isForPair = _isForPair;\n        nonfungiblePositionManager = INonfungiblePositionManager(nfpm);\n        emergency = false;\n    }\n\n    modifier onlyDistribution() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier isNotEmergency() {\n        require(emergency == false, \"emergency\");\n        _;\n    }\n\n    function _updateRewards(uint256 tokenId, int24 tickLower, int24 tickUpper) internal {\n        if (lastUpdateTime[tokenId] == block.timestamp) return;\n        clPool.updateRewardsGrowthGlobal();\n        lastUpdateTime[tokenId] = block.timestamp;\n        rewards[tokenId] += _earned(tokenId);\n        rewardGrowthInside[tokenId] = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\n    }\n\n    function activateEmergencyMode() external onlyOwner {\n        require(emergency == false, \"emergency\");\n        emergency = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function stopEmergencyMode() external onlyOwner {\n\n        require(emergency == true,\"emergency\");\n\n        emergency = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function balanceOf(uint256 tokenId) external view returns (uint256) {\n        (,,,,,,,uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\n        return liquidity;\n    }\n\n    function _getPoolAddress(address token0, address token1, int24 tickSpacing) internal view returns (address) {\n        return ICLFactory(nonfungiblePositionManager.factory()).getPool(token0, token1, tickSpacing);\n    }\n\n    function earned(uint256 tokenId) external view returns (uint256 reward) {\n        require(_stakes[msg.sender].contains(tokenId), \"NA\");\n\n        uint256 reward = _earned(tokenId);\n        return (reward);\n    }\n\n       function _earned(uint256 tokenId) internal view returns (uint256) {\n        uint256 lastUpdated = clPool.lastUpdated();\n\n        uint256 timeDelta = block.timestamp - lastUpdated;\n\n        uint256 rewardGrowthGlobalX128 = clPool.rewardGrowthGlobalX128();\n        uint256 rewardReserve = clPool.rewardReserve();\n\n        if (timeDelta != 0 && rewardReserve > 0 && clPool.stakedLiquidity() > 0) {\n            uint256 reward = rewardRate * timeDelta;\n            if (reward > rewardReserve) reward = rewardReserve;\n\n            rewardGrowthGlobalX128 += FullMath.mulDiv(reward, FixedPoint128.Q128, clPool.stakedLiquidity());\n        }\n\n        (,,,,, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) = nonfungiblePositionManager.positions(tokenId);\n\n        uint256 rewardPerTokenInsideInitialX128 = rewardGrowthInside[tokenId];\n        uint256 rewardPerTokenInsideX128 = clPool.getRewardGrowthInside(tickLower, tickUpper, rewardGrowthGlobalX128);\n\n        uint256 claimable =\n            FullMath.mulDiv(rewardPerTokenInsideX128 - rewardPerTokenInsideInitialX128, liquidity, FixedPoint128.Q128);\n        return claimable;\n    }\n\n    function deposit(uint256 tokenId) external nonReentrant isNotEmergency {\n\n         (,,address token0, address token1, int24 tickSpacing, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) =\n            nonfungiblePositionManager.positions(tokenId);\n\n        require(liquidity > 0, \"Gauge: zero liquidity\");\n\n        address positionPool = _getPoolAddress(token0, token1, tickSpacing);\n\n        require(positionPool == poolAddress, \"Pool mismatch: Position not for this gauge pool\");\n\n        nonfungiblePositionManager.collect(INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: msg.sender,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            }));\n\n        nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId);\n\n        clPool.stake(int128(liquidity), tickLower, tickUpper, true);\n\n        uint256 rewardGrowth = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\n        rewardGrowthInside[tokenId] = rewardGrowth;\n        lastUpdateTime[tokenId] = block.timestamp;\n\n        _stakes[msg.sender].add(tokenId);\n\n        emit Deposit(msg.sender, tokenId);\n    }\n\n    function withdraw(uint256 tokenId, uint8 redeemType) external nonReentrant isNotEmergency {\n           require(_stakes[msg.sender].contains(tokenId), \"NA\");\n\n\n        nonfungiblePositionManager.collect(\n            INonfungiblePositionManager.CollectParams({\n                tokenId: tokenId,\n                recipient: msg.sender,\n                amount0Max: type(uint128).max,\n                amount1Max: type(uint128).max\n            })\n        );\n\n        (,,,,, int24 tickLower, int24 tickUpper, uint128 liquidityToStake,,,,) = nonfungiblePositionManager.positions(tokenId);\n        _getReward(tickLower, tickUpper, tokenId, msg.sender, redeemType);\n\n\n        if (liquidityToStake != 0) {\n            clPool.stake(-int128(liquidityToStake), tickLower, tickUpper, true);\n        }\n\n        _stakes[msg.sender].remove(tokenId);\n        nonfungiblePositionManager.safeTransferFrom(address(this), msg.sender, tokenId);\n\n        emit Withdraw(msg.sender, tokenId);\n    }\n\n    function getReward(uint256 tokenId, address account,uint8 redeemType ) public nonReentrant onlyDistribution {\n\n        require(_stakes[account].contains(tokenId), \"NA\");\n\n        (,,,,, int24 tickLower, int24 tickUpper,,,,,) = nonfungiblePositionManager.positions(tokenId);\n        _getReward(tickLower, tickUpper, tokenId, account, redeemType);\n    }\n\n    function _getReward(int24 tickLower, int24 tickUpper, uint256 tokenId,address account, uint8 redeemType) internal {\n        _updateRewards(tokenId, tickLower, tickUpper);\n        uint256 rewardAmount = rewards[tokenId];\n        if(rewardAmount > 0){\n            delete rewards[tokenId];\n            rewardToken.safeApprove(rHYBR, rewardAmount);\n            IRHYBR(rHYBR).depostionEmissionsToken(rewardAmount);\n            IRHYBR(rHYBR).redeemFor(rewardAmount, redeemType, account);\n        }\n        emit Harvest(msg.sender, rewardAmount);\n    }\n\n    function notifyRewardAmount(address token, uint256 rewardAmount) external nonReentrant\n        isNotEmergency onlyDistribution returns (uint256 currentRate) {\n        require(token == address(rewardToken), \"Invalid reward token\");\n\n\n        clPool.updateRewardsGrowthGlobal();\n\n\n        uint256 epochTimeRemaining = HybraTimeLibrary.epochNext(block.timestamp) - block.timestamp;\n        uint256 epochEndTimestamp = block.timestamp + epochTimeRemaining;\n\n\n        uint256 totalRewardAmount = rewardAmount + clPool.rollover();\n\n\n        if (block.timestamp >= _periodFinish) {\n\n            rewardRate = rewardAmount / epochTimeRemaining;\n            clPool.syncReward({\n                rewardRate: rewardRate,\n                rewardReserve: totalRewardAmount,\n                periodFinish: epochEndTimestamp\n            });\n        } else {\n\n            uint256 pendingRewards = epochTimeRemaining * rewardRate;\n            rewardRate = (rewardAmount + pendingRewards) / epochTimeRemaining;\n            clPool.syncReward({\n                rewardRate: rewardRate,\n                rewardReserve: totalRewardAmount + pendingRewards,\n                periodFinish: epochEndTimestamp\n            });\n        }\n\n\n        rewardRateByEpoch[HybraTimeLibrary.epochStart(block.timestamp)] = rewardRate;\n\n\n        rewardToken.safeTransferFrom(DISTRIBUTION, address(this), rewardAmount);\n\n\n        uint256 contractBalance = rewardToken.balanceOf(address(this));\n        require(rewardRate <= contractBalance / epochTimeRemaining, \"Insufficient balance for reward rate\");\n\n\n        _periodFinish = epochEndTimestamp;\n        currentRate = rewardRate;\n\n        emit RewardAdded(rewardAmount);\n    }\n\n    function gaugeBalances() external view returns (uint256 token0, uint256 token1){\n\n        (token0, token1) = clPool.gaugeFees();\n\n    }\n\n    function claimFees() external nonReentrant returns (uint256 claimed0, uint256 claimed1) {\n        return _claimFees();\n    }\n\n    function _claimFees() internal returns (uint256 claimed0, uint256 claimed1) {\n        if (!isForPair) {\n            return (0, 0);\n        }\n\n        clPool.collectFees();\n\n        address _token0 = clPool.token0();\n        address _token1 = clPool.token1();\n\n        claimed0 = IERC20(_token0).balanceOf(address(this));\n        claimed1 = IERC20(_token1).balanceOf(address(this));\n\n        if (claimed0 > 0 || claimed1 > 0) {\n\n            uint256 _fees0 = claimed0;\n            uint256 _fees1 = claimed1;\n\n            if (_fees0  > 0) {\n                IERC20(_token0).safeApprove(internal_bribe, 0);\n                IERC20(_token0).safeApprove(internal_bribe, _fees0);\n                IBribe(internal_bribe).notifyRewardAmount(_token0, _fees0);\n            }\n            if (_fees1  > 0) {\n                IERC20(_token1).safeApprove(internal_bribe, 0);\n                IERC20(_token1).safeApprove(internal_bribe, _fees1);\n                IBribe(internal_bribe).notifyRewardAmount(_token1, _fees1);\n            }\n            emit ClaimFees(msg.sender, claimed0, claimed1);\n        }\n    }\n\n\n    function rewardForDuration() external view returns (uint256) {\n        return rewardRate * DURATION;\n    }\n\n\n    function setInternalBribe(address _int) external onlyOwner {\n        require(_int >= address(0), \"zero\");\n        internal_bribe = _int;\n    }\n\n    function _safeTransfer(address token,address to,uint256 value) internal {\n        require(token.code.length > 0);\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))));\n    }\n\n\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.onERC721Received.selector;\n    }\n\n\n    // Unified dispatcher - merged from: activateEmergencyMode, stopEmergencyMode, deposit\n    // Selectors: activateEmergencyMode=0, stopEmergencyMode=1, deposit=2\n    function execute(uint8 _selector, uint256 tokenId) public {\n        // Original: activateEmergencyMode()\n        if (_selector == 0) {\n            require(emergency == false, \"emergency\");\n            emergency = true;\n            emit EmergencyActivated(address(this), block.timestamp);\n        }\n        // Original: stopEmergencyMode()\n        else if (_selector == 1) {\n            require(emergency == true,\"emergency\");\n            emergency = false;\n            emit EmergencyDeactivated(address(this), block.timestamp);\n        }\n        // Original: deposit()\n        else if (_selector == 2) {\n            (,,address token0, address token1, int24 tickSpacing, int24 tickLower, int24 tickUpper, uint128 liquidity,,,,) =\n            nonfungiblePositionManager.positions(tokenId);\n            require(liquidity > 0, \"Gauge: zero liquidity\");\n            address positionPool = _getPoolAddress(token0, token1, tickSpacing);\n            require(positionPool == poolAddress, \"Pool mismatch: Position not for this gauge pool\");\n            nonfungiblePositionManager.collect(INonfungiblePositionManager.CollectParams({\n            tokenId: tokenId,\n            recipient: msg.sender,\n            amount0Max: type(uint128).max,\n            amount1Max: type(uint128).max\n            }));\n            nonfungiblePositionManager.safeTransferFrom(msg.sender, address(this), tokenId);\n            clPool.stake(int128(liquidity), tickLower, tickUpper, true);\n            uint256 rewardGrowth = clPool.getRewardGrowthInside(tickLower, tickUpper, 0);\n            rewardGrowthInside[tokenId] = rewardGrowth;\n            lastUpdateTime[tokenId] = block.timestamp;\n            _stakes[msg.sender].add(tokenId);\n            emit Deposit(msg.sender, tokenId);\n        }\n    }\n}",
      "merged_functions": [
        "activateEmergencyMode",
        "stopEmergencyMode",
        "deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: activateEmergencyMode, stopEmergencyMode, deposit"
      ],
      "function_to_selector": {
        "activateEmergencyMode": 0,
        "stopEmergencyMode": 1,
        "deposit": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_008",
      "transformed_id": "rs_mg_dis_nc_gs_008",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public transferLockPeriod = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public head_not_withdraw_time = 1200;\n    uint256 public tail_not_withdraw_time = 300;\n\n\n    uint256 public withdrawFee = 100;\n    uint256 public constant MIN_WITHDRAW_FEE = 10;\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant BASIS = 10000;\n    address public Team;\n    uint256 public rebase;\n    uint256 public penalty;\n    uint256 public votingYield;\n\n    struct UserLock {\n        uint256 amount;\n        uint256 unlockTime;\n    }\n\n    mapping(address => UserLock[]) public userLocks;\n    mapping(address => uint256) public lockedBalance;\n\n\n    address public immutable HYBR;\n    address public immutable votingEscrow;\n    address public voter;\n    address public rewardsDistributor;\n    address public gaugeManager;\n    uint256 public veTokenId;\n\n\n    address public operator;\n    uint256 public lastVoteEpoch;\n\n\n    uint256 public lastRebaseTime;\n    uint256 public lastCompoundTime;\n\n\n    ISwapper public swapper;\n\n\n    error NOT_AUTHORIZED();\n\n\n    event Deposit(address indexed user, uint256 hybrAmount, uint256 sharesReceived);\n    event Withdraw(address indexed user, uint256 shares, uint256 hybrAmount, uint256 fee);\n    event Compound(uint256 rewards, uint256 newTotalLocked);\n    event PenaltyRewardReceived(uint256 amount);\n    event TransferLockPeriodUpdated(uint256 oldPeriod, uint256 newPeriod);\n    event SwapperUpdated(address indexed oldSwapper, address indexed newSwapper);\n    event VoterSet(address voter);\n    event EmergencyUnlock(address indexed user);\n    event AutoVotingEnabled(bool enabled);\n    event OperatorUpdated(address indexed oldOperator, address indexed newOperator);\n    event DefaultVotingStrategyUpdated(address[] pools, uint256[] weights);\n    event AutoVoteExecuted(uint256 epoch, address[] pools, uint256[] weights);\n\n    constructor(\n        address _HYBR,\n        address _votingEscrow\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_HYBR != address(0), \"Invalid HYBR\");\n        require(_votingEscrow != address(0), \"Invalid VE\");\n\n        HYBR = _HYBR;\n        votingEscrow = _votingEscrow;\n        lastRebaseTime = block.timestamp;\n        lastCompoundTime = block.timestamp;\n        operator = msg.sender;\n    }\n\n    function setRewardsDistributor(address _rewardsDistributor) external onlyOwner {\n        require(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\n        rewardsDistributor = _rewardsDistributor;\n    }\n\n    function setGaugeManager(address _gaugeManager) external onlyOwner {\n        require(_gaugeManager != address(0), \"Invalid gauge manager\");\n        gaugeManager = _gaugeManager;\n    }\n\n\n    modifier onlyOperator() {\n        if (msg.sender != operator) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n\n    function deposit(uint256 amount, address recipient) external nonReentrant {\n        require(amount > 0, \"Zero amount\");\n        recipient = recipient == address(0) ? msg.sender : recipient;\n\n\n        IERC20(HYBR).transferFrom(msg.sender, address(this), amount);\n\n\n        if (veTokenId == 0) {\n            _initializeVeNFT(amount);\n        } else {\n\n            IERC20(HYBR).approve(votingEscrow, amount);\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n\n\n            _extendLockToMax();\n        }\n\n\n        uint256 shares = calculateShares(amount);\n\n\n        _mint(recipient, shares);\n\n\n        _addTransferLock(recipient, shares);\n\n        emit Deposit(msg.sender, amount, shares);\n    }\n\n\n    function withdraw(uint256 shares) external nonReentrant returns (uint256 userTokenId) {\n        require(shares > 0, \"Zero shares\");\n        require(balanceOf(msg.sender) >= shares, \"Insufficient balance\");\n        require(veTokenId != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(votingEscrow).voted(veTokenId) == false, \"Cannot withdraw yet\");\n\n        uint256 epochStart = HybraTimeLibrary.epochStart(block.timestamp);\n        uint256 epochNext = HybraTimeLibrary.epochNext(block.timestamp);\n\n        require(block.timestamp >= epochStart + head_not_withdraw_time && block.timestamp < epochNext - tail_not_withdraw_time, \"Cannot withdraw yet\");\n\n\n        uint256 hybrAmount = calculateAssets(shares);\n        require(hybrAmount > 0, \"No assets to withdraw\");\n\n\n        uint256 feeAmount = 0;\n        if (withdrawFee > 0) {\n            feeAmount = (hybrAmount * withdrawFee) / BASIS;\n        }\n\n\n        uint256 userAmount = hybrAmount - feeAmount;\n        require(userAmount > 0, \"Amount too small after fee\");\n\n\n        uint256 veBalance = totalAssets();\n        require(hybrAmount <= veBalance, \"Insufficient veNFT balance\");\n\n        uint256 remainingAmount = veBalance - userAmount - feeAmount;\n        require(remainingAmount >= 0, \"Cannot withdraw entire veNFT\");\n\n\n        _burn(msg.sender, shares);\n\n\n        uint256[] memory amounts = new uint256[](3);\n        amounts[0] = remainingAmount;\n        amounts[1] = userAmount;\n        amounts[2] = feeAmount;\n\n        uint256[] memory newTokenIds = IVotingEscrow(votingEscrow).multiSplit(veTokenId, amounts);\n\n\n        veTokenId = newTokenIds[0];\n        userTokenId = newTokenIds[1];\n        uint256 feeTokenId = newTokenIds[2];\n\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), msg.sender, userTokenId);\n        IVotingEscrow(votingEscrow).safeTransferFrom(address(this), Team, feeTokenId);\n        emit Withdraw(msg.sender, shares, userAmount, feeAmount);\n    }\n\n\n    function _initializeVeNFT(uint256 initialAmount) internal {\n\n        IERC20(HYBR).approve(votingEscrow, type(uint256).max);\n        uint256 lockTime = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n\n        veTokenId = IVotingEscrow(votingEscrow).create_lock_for(initialAmount, lockTime, address(this));\n\n    }\n\n\n    function calculateShares(uint256 amount) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        uint256 _totalAssets = totalAssets();\n        if (_totalSupply == 0 || _totalAssets == 0) {\n            return amount;\n        }\n        return (amount * _totalSupply) / _totalAssets;\n    }\n\n\n    function calculateAssets(uint256 shares) public view returns (uint256) {\n        uint256 _totalSupply = totalSupply();\n        if (_totalSupply == 0) {\n            return shares;\n        }\n        return (shares * totalAssets()) / _totalSupply;\n    }\n\n\n    function totalAssets() public view returns (uint256) {\n        if (veTokenId == 0) {\n            return 0;\n        }\n\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\n        return uint256(int256(locked.amount));\n    }\n\n\n    function _addTransferLock(address user, uint256 amount) internal {\n        uint256 unlockTime = block.timestamp + transferLockPeriod;\n        userLocks[user].push(UserLock({\n            amount: amount,\n            unlockTime: unlockTime\n        }));\n        lockedBalance[user] += amount;\n    }\n\n\n    function previewAvailable(address user) external view returns (uint256 available) {\n        uint256 totalBalance = balanceOf(user);\n        uint256 currentLocked = 0;\n\n        UserLock[] storage arr = userLocks[user];\n        for (uint256 i = 0; i < arr.length; i++) {\n            if (arr[i].unlockTime > block.timestamp) {\n                currentLocked += arr[i].amount;\n            }\n        }\n\n        return totalBalance > currentLocked ? totalBalance - currentLocked : 0;\n    }\n\n    function _cleanExpired(address user) internal returns (uint256 freed) {\n        UserLock[] storage arr = userLocks[user];\n        uint256 len = arr.length;\n        if (len == 0) return 0;\n\n        uint256 write = 0;\n        unchecked {\n            for (uint256 i = 0; i < len; i++) {\n                UserLock memory L = arr[i];\n                if (L.unlockTime <= block.timestamp) {\n                    freed += L.amount;\n                } else {\n                    if (write != i) arr[write] = L;\n                    write++;\n                }\n            }\n            if (freed > 0) {\n                lockedBalance[user] -= freed;\n            }\n            while (arr.length > write) {\n                arr.pop();\n            }\n        }\n    }\n\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override {\n        super._beforeTokenTransfer(from, to, amount);\n\n        if (from != address(0) && to != address(0)) {\n            uint256 totalBalance = balanceOf(from);\n\n\n            uint256 currentAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\n\n\n            if (currentAvailable >= amount) {\n                return;\n            }\n\n\n            _cleanExpired(from);\n            uint256 finalAvailable = totalBalance > lockedBalance[from] ? totalBalance - lockedBalance[from] : 0;\n\n\n            require(finalAvailable >= amount, \"Tokens locked\");\n        }\n    }\n\n\n    function claimRewards() external onlyOperator {\n        require(voter != address(0), \"Voter not set\");\n        require(rewardsDistributor != address(0), \"Distributor not set\");\n\n\n        uint256  rebaseAmount = IRewardsDistributor(rewardsDistributor).claim(veTokenId);\n        rebase += rebaseAmount;\n\n        address[] memory votedPools = IVoter(voter).poolVote(veTokenId);\n\n        for (uint256 i = 0; i < votedPools.length; i++) {\n            if (votedPools[i] != address(0)) {\n                address gauge = IGaugeManager(gaugeManager).gauges(votedPools[i]);\n\n                if (gauge != address(0)) {\n\n                    address[] memory bribes = new address[](1);\n                    address[][] memory tokens = new address[][](1);\n\n\n                    address internalBribe = IGaugeManager(gaugeManager).internal_bribes(gauge);\n                    if (internalBribe != address(0)) {\n                        uint256 tokenCount = IBribe(internalBribe).rewardsListLength();\n                        if (tokenCount > 0) {\n                            address[] memory bribeTokens = new address[](tokenCount);\n                            for (uint256 j = 0; j < tokenCount; j++) {\n                                bribeTokens[j] = IBribe(internalBribe).bribeTokens(j);\n                            }\n                            bribes[0] = internalBribe;\n                            tokens[0] = bribeTokens;\n\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n                        }\n                    }\n\n\n                    address externalBribe = IGaugeManager(gaugeManager).external_bribes(gauge);\n                    if (externalBribe != address(0)) {\n                        uint256 tokenCount = IBribe(externalBribe).rewardsListLength();\n                        if (tokenCount > 0) {\n                            address[] memory bribeTokens = new address[](tokenCount);\n                            for (uint256 j = 0; j < tokenCount; j++) {\n                                bribeTokens[j] = IBribe(externalBribe).bribeTokens(j);\n                            }\n                            bribes[0] = externalBribe;\n                            tokens[0] = bribeTokens;\n\n                            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    function executeSwap(ISwapper.SwapParams calldata _params) external nonReentrant onlyOperator {\n        require(address(swapper) != address(0), \"Swapper not set\");\n\n\n        uint256 tokenBalance = IERC20(_params.tokenIn).balanceOf(address(this));\n        require(tokenBalance >= _params.amountIn, \"Insufficient token balance\");\n\n\n        IERC20(_params.tokenIn).safeApprove(address(swapper), _params.amountIn);\n\n\n        uint256 hybrReceived = swapper.swapToHYBR(_params);\n\n\n        IERC20(_params.tokenIn).safeApprove(address(swapper), 0);\n\n\n        votingYield += hybrReceived;\n    }\n\n\n    function compound() external onlyOperator {\n\n\n        uint256 hybrBalance = IERC20(HYBR).balanceOf(address(this));\n\n        if (hybrBalance > 0) {\n\n            IERC20(HYBR).safeApprove(votingEscrow, hybrBalance);\n            IVotingEscrow(votingEscrow).deposit_for(veTokenId, hybrBalance);\n\n\n            _extendLockToMax();\n\n            lastCompoundTime = block.timestamp;\n\n            emit Compound(hybrBalance, totalAssets());\n        }\n    }\n\n\n    function vote(address[] calldata _poolVote, uint256[] calldata _weights) external {\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\n        require(voter != address(0), \"Voter not set\");\n\n        IVoter(voter).vote(veTokenId, _poolVote, _weights);\n        lastVoteEpoch = HybraTimeLibrary.epochStart(block.timestamp);\n\n    }\n\n\n    function reset() external {\n        require(msg.sender == owner() || msg.sender == operator, \"Not authorized\");\n        require(voter != address(0), \"Voter not set\");\n\n        IVoter(voter).reset(veTokenId);\n    }\n\n\n    function receivePenaltyReward(uint256 amount) external {\n\n\n        if (amount > 0) {\n            IERC20(HYBR).approve(votingEscrow, amount);\n\n            if(veTokenId == 0){\n                _initializeVeNFT(amount);\n            } else{\n                IVotingEscrow(votingEscrow).deposit_for(veTokenId, amount);\n\n\n                _extendLockToMax();\n            }\n        }\n        penalty += amount;\n        emit PenaltyRewardReceived(amount);\n    }\n\n\n    function setVoter(address _voter) external onlyOwner {\n        require(_voter != address(0), \"Invalid voter\");\n        voter = _voter;\n        emit VoterSet(_voter);\n    }\n\n\n    function setTransferLockPeriod(uint256 _period) external onlyOwner {\n        require(_period >= MIN_LOCK_PERIOD && _period <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 oldPeriod = transferLockPeriod;\n        transferLockPeriod = _period;\n        emit TransferLockPeriodUpdated(oldPeriod, _period);\n    }\n\n\n    function setWithdrawFee(uint256 _fee) external onlyOwner {\n        require(_fee >= MIN_WITHDRAW_FEE && _fee <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        withdrawFee = _fee;\n    }\n\n    function setHeadNotWithdrawTime(uint256 _time) external onlyOwner {\n        head_not_withdraw_time = _time;\n    }\n\n    function setTailNotWithdrawTime(uint256 _time) external onlyOwner {\n        tail_not_withdraw_time = _time;\n    }\n\n\n    function setSwapper(address _swapper) external onlyOwner {\n        require(_swapper != address(0), \"Invalid swapper\");\n        address oldSwapper = address(swapper);\n        swapper = ISwapper(_swapper);\n        emit SwapperUpdated(oldSwapper, _swapper);\n    }\n\n\n    function setTeam(address _team) external onlyOwner {\n        require(_team != address(0), \"Invalid team\");\n        Team = _team;\n    }\n\n\n    function emergencyUnlock(address user) external onlyOperator {\n        delete userLocks[user];\n        lockedBalance[user] = 0;\n        emit EmergencyUnlock(user);\n    }\n\n\n    function getUserLocks(address user) external view returns (UserLock[] memory) {\n        return userLocks[user];\n    }\n\n\n    function setOperator(address _operator) external onlyOwner {\n        require(_operator != address(0), \"Invalid operator\");\n        address oldOperator = operator;\n        operator = _operator;\n        emit OperatorUpdated(oldOperator, _operator);\n    }\n\n\n    function getLockEndTime() external view returns (uint256) {\n        if (veTokenId == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\n        return uint256(locked.end);\n    }\n\n\n    function _extendLockToMax() internal {\n        if (veTokenId == 0) return;\n\n        IVotingEscrow.LockedBalance memory locked = IVotingEscrow(votingEscrow).locked(veTokenId);\n        if (locked.isPermanent || locked.end <= block.timestamp) return;\n\n        uint256 maxUnlockTime = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n\n        if (maxUnlockTime > locked.end + 2 hours) {\n            try IVotingEscrow(votingEscrow).increase_unlock_time(veTokenId, HybraTimeLibrary.MAX_LOCK_DURATION) {\n\n            } catch {\n\n\n            }\n        }\n    }\n\n\n    // Unified dispatcher - merged from: claimRewards, setRewardsDistributor, setGaugeManager\n    // Selectors: claimRewards=0, setRewardsDistributor=1, setGaugeManager=2\n    function execute(uint8 _selector, address _gaugeManager, address _rewardsDistributor) public {\n        // Original: claimRewards()\n        if (_selector == 0) {\n            require(voter != address(0), \"Voter not set\");\n            require(rewardsDistributor != address(0), \"Distributor not set\");\n            uint256  rebaseAmount = IRewardsDistributor(rewardsDistributor).claim(veTokenId);\n            rebase += rebaseAmount;\n            address[] memory votedPools = IVoter(voter).poolVote(veTokenId);\n            for (uint256 i = 0; i < votedPools.length; i++) {\n            if (votedPools[i] != address(0)) {\n            address gauge = IGaugeManager(gaugeManager).gauges(votedPools[i]);\n            if (gauge != address(0)) {\n            address[] memory bribes = new address[](1);\n            address[][] memory tokens = new address[][](1);\n            address internalBribe = IGaugeManager(gaugeManager).internal_bribes(gauge);\n            if (internalBribe != address(0)) {\n            uint256 tokenCount = IBribe(internalBribe).rewardsListLength();\n            if (tokenCount > 0) {\n            address[] memory bribeTokens = new address[](tokenCount);\n            for (uint256 j = 0; j < tokenCount; j++) {\n            bribeTokens[j] = IBribe(internalBribe).bribeTokens(j);\n            }\n            bribes[0] = internalBribe;\n            tokens[0] = bribeTokens;\n            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n            }\n            }\n            address externalBribe = IGaugeManager(gaugeManager).external_bribes(gauge);\n            if (externalBribe != address(0)) {\n            uint256 tokenCount = IBribe(externalBribe).rewardsListLength();\n            if (tokenCount > 0) {\n            address[] memory bribeTokens = new address[](tokenCount);\n            for (uint256 j = 0; j < tokenCount; j++) {\n            bribeTokens[j] = IBribe(externalBribe).bribeTokens(j);\n            }\n            bribes[0] = externalBribe;\n            tokens[0] = bribeTokens;\n            IGaugeManager(gaugeManager).claimBribes(bribes, tokens, veTokenId);\n            }\n            }\n            }\n            }\n            }\n        }\n        // Original: setRewardsDistributor()\n        else if (_selector == 1) {\n            require(_rewardsDistributor != address(0), \"Invalid rewards distributor\");\n            rewardsDistributor = _rewardsDistributor;\n        }\n        // Original: setGaugeManager()\n        else if (_selector == 2) {\n            require(_gaugeManager != address(0), \"Invalid gauge manager\");\n            gaugeManager = _gaugeManager;\n        }\n    }\n}",
      "merged_functions": [
        "claimRewards",
        "setRewardsDistributor",
        "setGaugeManager"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: claimRewards, setRewardsDistributor, setGaugeManager"
      ],
      "function_to_selector": {
        "claimRewards": 0,
        "setRewardsDistributor": 1,
        "setGaugeManager": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_009",
      "transformed_id": "rs_mg_dis_nc_gs_009",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport {IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IHybra.sol\";\nimport {IHybraVotes} from \"./interfaces/IHybraVotes.sol\";\nimport {IVeArtProxy} from \"./interfaces/IVeArtProxy.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport {VotingDelegationLib} from \"./libraries/VotingDelegationLib.sol\";\nimport {VotingBalanceLogic} from \"./libraries/VotingBalanceLogic.sol\";\n\n\ncontract VotingEscrow is IERC721, IERC721Metadata, IHybraVotes {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n\n    event Deposit(\n        address indexed provider,\n        uint tokenId,\n        uint value,\n        uint indexed locktime,\n        DepositType deposit_type,\n        uint ts\n    );\n\n    event Merge(\n        address indexed _sender,\n        uint256 indexed _from,\n        uint256 indexed _to,\n        uint256 _amountFrom,\n        uint256 _amountTo,\n        uint256 _amountFinal,\n        uint256 _locktime,\n        uint256 _ts\n    );\n    event Split(\n        uint256 indexed _from,\n        uint256 indexed _tokenId1,\n        uint256 indexed _tokenId2,\n        address _sender,\n        uint256 _splitAmount1,\n        uint256 _splitAmount2,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    event MultiSplit(\n        uint256 indexed _from,\n        uint256[] _newTokenIds,\n        address _sender,\n        uint256[] _amounts,\n        uint256 _locktime,\n        uint256 _ts\n    );\n\n    event MetadataUpdate(uint256 _tokenId);\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n\n    event Withdraw(address indexed provider, uint tokenId, uint value, uint ts);\n    event LockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n    event UnlockPermanent(address indexed _owner, uint256 indexed _tokenId, uint256 amount, uint256 _ts);\n    event Supply(uint prevSupply, uint supply);\n\n\n    address public immutable token;\n    address public voter;\n    address public team;\n    address public artProxy;\n\n\n    uint public PRECISISON = 10000;\n\n\n    mapping(bytes4 => bool) internal supportedInterfaces;\n    mapping(uint => bool) internal isPartnerVeNFT;\n\n\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n\n    uint internal tokenId;\n\n    uint internal WEEK;\n\n    uint internal MAXTIME;\n    int128 internal iMAXTIME;\n    IHybra public _hybr;\n\n\n    VotingDelegationLib.Data private cpData;\n\n    VotingBalanceLogic.Data private votingBalanceLogicData;\n\n\n    constructor(address token_addr, address art_proxy) {\n        token = token_addr;\n        voter = msg.sender;\n        team = msg.sender;\n        artProxy = art_proxy;\n        WEEK = HybraTimeLibrary.WEEK;\n        MAXTIME = HybraTimeLibrary.MAX_LOCK_DURATION;\n        iMAXTIME = int128(int256(HybraTimeLibrary.MAX_LOCK_DURATION));\n\n        votingBalanceLogicData.point_history[0].blk = block.number;\n        votingBalanceLogicData.point_history[0].ts = block.timestamp;\n\n        supportedInterfaces[ERC165_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_INTERFACE_ID] = true;\n        supportedInterfaces[ERC721_METADATA_INTERFACE_ID] = true;\n        _hybr = IHybra(token);\n\n\n        emit Transfer(address(0), address(this), tokenId);\n\n        emit Transfer(address(this), address(0), tokenId);\n    }\n\n\n    uint8 internal constant _not_entered = 1;\n    uint8 internal constant _entered = 2;\n    uint8 internal _entered_state = 1;\n    modifier nonreentrant() {\n        require(_entered_state == _not_entered);\n        _entered_state = _entered;\n        _;\n        _entered_state = _not_entered;\n    }\n\n    modifier notPartnerNFT(uint256 _tokenId) {\n        require(!isPartnerVeNFT[_tokenId], \"PNFT\");\n        _;\n    }\n\n    modifier splitAllowed(uint _from) {\n        require(canSplit[msg.sender] || canSplit[address(0)], \"!SPLIT\");\n        require(attachments[_from] == 0 && !voted[_from], \"ATT\");\n        require(_isApprovedOrOwner(msg.sender, _from), \"NAO\");\n        _;\n    }\n\n\n    string constant public name = \"veHYBR\";\n    string constant public symbol = \"veHYBR\";\n    string constant public version = \"1.0.0\";\n    uint8 constant public decimals = 18;\n\n    function setTeam(address _team) external {\n        require(msg.sender == team);\n        team = _team;\n    }\n\n    function setArtProxy(address _proxy) external {\n        require(msg.sender == team);\n        artProxy = _proxy;\n        emit BatchMetadataUpdate(0, type(uint256).max);\n    }\n\n\n    function setPartnerVeNFT(uint _tokenId, bool _isPartner) external {\n        require(msg.sender == team, \"NA\");\n        require(idToOwner[_tokenId] != address(0), \"DNE\");\n        isPartnerVeNFT[_tokenId] = _isPartner;\n    }\n\n\n    function tokenURI(uint _tokenId) external view returns (string memory) {\n        require(idToOwner[_tokenId] != address(0), \"DNE\");\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n\n        return IVeArtProxy(artProxy)._tokenURI(_tokenId,VotingBalanceLogic.balanceOfNFT(_tokenId, block.timestamp, votingBalanceLogicData),_locked.end,uint(int256(_locked.amount)));\n    }\n\n\n    mapping(uint => address) internal idToOwner;\n\n\n    mapping(address => uint) internal ownerToNFTokenCount;\n\n\n    function ownerOf(uint _tokenId) public view returns (address) {\n        return idToOwner[_tokenId];\n    }\n\n    function ownerToNFTokenCountFn(address owner) public view returns (uint) {\n\n        return ownerToNFTokenCount[owner];\n    }\n\n\n    function _balance(address _owner) internal view returns (uint) {\n        return ownerToNFTokenCount[_owner];\n    }\n\n\n    function balanceOf(address _owner) external view returns (uint) {\n        return _balance(_owner);\n    }\n\n\n    mapping(uint => address) internal idToApprovals;\n\n\n    mapping(address => mapping(address => bool)) internal ownerToOperators;\n\n    mapping(uint => uint) public ownership_change;\n\n\n    function getApproved(uint _tokenId) external view returns (address) {\n        return idToApprovals[_tokenId];\n    }\n\n\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\n        return (ownerToOperators[_owner])[_operator];\n    }\n\n\n    function approve(address _approved, uint _tokenId) public {\n        address owner = idToOwner[_tokenId];\n\n        require(owner != address(0), \"ZA\");\n\n        require(_approved != owner, \"IA\");\n\n        bool senderIsOwner = (idToOwner[_tokenId] == msg.sender);\n        bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n        require(senderIsOwner || senderIsApprovedForAll, \"NAO\");\n\n        idToApprovals[_tokenId] = _approved;\n        emit Approval(owner, _approved, _tokenId);\n    }\n\n\n    function setApprovalForAll(address _operator, bool _approved) external {\n\n        assert(_operator != msg.sender);\n        ownerToOperators[msg.sender][_operator] = _approved;\n        emit ApprovalForAll(msg.sender, _operator, _approved);\n    }\n\n\n    function _clearApproval(address _owner, uint _tokenId) internal {\n\n        assert(idToOwner[_tokenId] == _owner);\n        if (idToApprovals[_tokenId] != address(0)) {\n\n            idToApprovals[_tokenId] = address(0);\n        }\n    }\n\n\n    function _isApprovedOrOwner(address _spender, uint _tokenId) internal view returns (bool) {\n        address owner = idToOwner[_tokenId];\n        bool spenderIsOwner = owner == _spender;\n        bool spenderIsApproved = _spender == idToApprovals[_tokenId];\n        bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n        return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n    }\n\n    function isApprovedOrOwner(address _spender, uint _tokenId) external view returns (bool) {\n        return _isApprovedOrOwner(_spender, _tokenId);\n    }\n\n\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        address _sender\n    ) internal notPartnerNFT(_tokenId) {\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\n\n        require(_isApprovedOrOwner(_sender, _tokenId), \"NAO\");\n\n\n        _clearApproval(_from, _tokenId);\n\n        _removeTokenFrom(_from, _tokenId);\n\n        VotingDelegationLib.moveTokenDelegates(cpData, delegates(_from), delegates(_to), _tokenId, ownerOf);\n\n        _addTokenTo(_to, _tokenId);\n\n        ownership_change[_tokenId] = block.number;\n\n\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) external {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n    }\n\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId\n    ) external {\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n\n\n        uint size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint _tokenId,\n        bytes memory _data\n    ) public {\n        _transferFrom(_from, _to, _tokenId, msg.sender);\n\n        if (_isContract(_to)) {\n\n            try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4 response) {\n                if (response != IERC721Receiver(_to).onERC721Received.selector) {\n                    revert(\"E721_RJ\");\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert('E721_NRCV');\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n\n\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\n        return supportedInterfaces[_interfaceID];\n    }\n\n\n    mapping(address => mapping(uint => uint)) internal ownerToNFTokenIdList;\n\n\n    mapping(uint => uint) internal tokenToOwnerIndex;\n\n\n    function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) public view returns (uint) {\n        return ownerToNFTokenIdList[_owner][_tokenIndex];\n    }\n\n\n    function _addTokenToOwnerList(address _to, uint _tokenId) internal {\n        uint current_count = _balance(_to);\n\n        ownerToNFTokenIdList[_to][current_count] = _tokenId;\n        tokenToOwnerIndex[_tokenId] = current_count;\n    }\n\n\n    function _addTokenTo(address _to, uint _tokenId) internal {\n\n        assert(idToOwner[_tokenId] == address(0));\n\n        idToOwner[_tokenId] = _to;\n\n        _addTokenToOwnerList(_to, _tokenId);\n\n        ownerToNFTokenCount[_to] += 1;\n    }\n\n\n    function _mint(address _to, uint _tokenId) internal returns (bool) {\n\n        assert(_to != address(0));\n\n        VotingDelegationLib.moveTokenDelegates(cpData, address(0), delegates(_to), _tokenId, ownerOf);\n\n        _addTokenTo(_to, _tokenId);\n        emit Transfer(address(0), _to, _tokenId);\n        return true;\n    }\n\n\n    function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\n\n        uint current_count = _balance(_from) - 1;\n        uint current_index = tokenToOwnerIndex[_tokenId];\n\n        if (current_count == current_index) {\n\n            ownerToNFTokenIdList[_from][current_count] = 0;\n\n            tokenToOwnerIndex[_tokenId] = 0;\n        } else {\n            uint lastTokenId = ownerToNFTokenIdList[_from][current_count];\n\n\n            ownerToNFTokenIdList[_from][current_index] = lastTokenId;\n\n            tokenToOwnerIndex[lastTokenId] = current_index;\n\n\n            ownerToNFTokenIdList[_from][current_count] = 0;\n\n            tokenToOwnerIndex[_tokenId] = 0;\n        }\n    }\n\n\n    function _removeTokenFrom(address _from, uint _tokenId) internal {\n\n        assert(idToOwner[_tokenId] == _from);\n\n        idToOwner[_tokenId] = address(0);\n\n        _removeTokenFromOwnerList(_from, _tokenId);\n\n        ownerToNFTokenCount[_from] -= 1;\n    }\n\n    function _burn(uint _tokenId) internal {\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\n\n        address owner = ownerOf(_tokenId);\n\n\n        delete idToApprovals[_tokenId];\n\n\n        _removeTokenFrom(owner, _tokenId);\n\n        VotingDelegationLib.moveTokenDelegates(cpData, delegates(owner), address(0), _tokenId, ownerOf);\n\n        emit Transfer(owner, address(0), _tokenId);\n    }\n\n\n    mapping(uint => IVotingEscrow.LockedBalance) public locked;\n    uint public permanentLockBalance;\n    uint public epoch;\n    mapping(uint => int128) public slope_changes;\n    uint public supply;\n    mapping(address => bool) public canSplit;\n\n    uint internal constant MULTIPLIER = 1 ether;\n\n\n    function get_last_user_slope(uint _tokenId) external view returns (int128) {\n        uint uepoch = votingBalanceLogicData.user_point_epoch[_tokenId];\n        return votingBalanceLogicData.user_point_history[_tokenId][uepoch].slope;\n    }\n\n\n    function user_point_history(uint _tokenId, uint _idx) external view returns (IVotingEscrow.Point memory) {\n        return votingBalanceLogicData.user_point_history[_tokenId][_idx];\n    }\n\n    function point_history(uint epoch) external view returns (IVotingEscrow.Point memory) {\n        return votingBalanceLogicData.point_history[epoch];\n    }\n\n    function user_point_epoch(uint tokenId) external view returns (uint) {\n        return votingBalanceLogicData.user_point_epoch[tokenId];\n    }\n\n\n    function _checkpoint(\n        uint _tokenId,\n        IVotingEscrow.LockedBalance memory old_locked,\n        IVotingEscrow.LockedBalance memory new_locked\n    ) internal {\n        IVotingEscrow.Point memory u_old;\n        IVotingEscrow.Point memory u_new;\n        int128 old_dslope = 0;\n        int128 new_dslope = 0;\n        uint _epoch = epoch;\n\n        if (_tokenId != 0) {\n            u_new.permanent = 0;\n\n            if(new_locked.isPermanent){\n                u_new.permanent = uint(int256(new_locked.amount));\n            }\n\n\n            if (old_locked.end > block.timestamp && old_locked.amount > 0) {\n                u_old.slope = old_locked.amount / iMAXTIME;\n                u_old.bias = u_old.slope * int128(int256(old_locked.end - block.timestamp));\n            }\n            if (new_locked.end > block.timestamp && new_locked.amount > 0) {\n                u_new.slope = new_locked.amount / iMAXTIME;\n                u_new.bias = u_new.slope * int128(int256(new_locked.end - block.timestamp));\n            }\n\n\n            old_dslope = slope_changes[old_locked.end];\n            if (new_locked.end != 0) {\n                if (new_locked.end == old_locked.end) {\n                    new_dslope = old_dslope;\n                } else {\n                    new_dslope = slope_changes[new_locked.end];\n                }\n            }\n        }\n\n        IVotingEscrow.Point memory last_point = IVotingEscrow.Point({bias: 0, slope: 0, ts: block.timestamp, blk: block.number, permanent: 0});\n        if (_epoch > 0) {\n            last_point = votingBalanceLogicData.point_history[_epoch];\n        }\n        uint last_checkpoint = last_point.ts;\n\n\n        IVotingEscrow.Point memory initial_last_point = last_point;\n        uint block_slope = 0;\n        if (block.timestamp > last_point.ts) {\n            block_slope = (MULTIPLIER * (block.number - last_point.blk)) / (block.timestamp - last_point.ts);\n        }\n\n\n        {\n            uint t_i = (last_checkpoint / WEEK) * WEEK;\n            for (uint i = 0; i < 255; ++i) {\n\n\n                t_i += WEEK;\n                int128 d_slope = 0;\n                if (t_i > block.timestamp) {\n                    t_i = block.timestamp;\n                } else {\n                    d_slope = slope_changes[t_i];\n                }\n                last_point.bias -= last_point.slope * int128(int256(t_i - last_checkpoint));\n                last_point.slope += d_slope;\n                if (last_point.bias < 0) {\n\n                    last_point.bias = 0;\n                }\n                if (last_point.slope < 0) {\n\n                    last_point.slope = 0;\n                }\n                last_checkpoint = t_i;\n                last_point.ts = t_i;\n                last_point.blk = initial_last_point.blk + (block_slope * (t_i - initial_last_point.ts)) / MULTIPLIER;\n                _epoch += 1;\n                if (t_i == block.timestamp) {\n                    last_point.blk = block.number;\n                    break;\n                } else {\n                    votingBalanceLogicData.point_history[_epoch] = last_point;\n                }\n            }\n        }\n\n        epoch = _epoch;\n\n\n        if (_tokenId != 0) {\n\n\n            last_point.slope += (u_new.slope - u_old.slope);\n            last_point.bias += (u_new.bias - u_old.bias);\n            if (last_point.slope < 0) {\n                last_point.slope = 0;\n            }\n            if (last_point.bias < 0) {\n                last_point.bias = 0;\n            }\n            last_point.permanent = permanentLockBalance;\n        }\n\n\n        votingBalanceLogicData.point_history[_epoch] = last_point;\n\n        if (_tokenId != 0) {\n\n\n            if (old_locked.end > block.timestamp) {\n\n                old_dslope += u_old.slope;\n                if (new_locked.end == old_locked.end) {\n                    old_dslope -= u_new.slope;\n                }\n                slope_changes[old_locked.end] = old_dslope;\n            }\n\n            if (new_locked.end > block.timestamp) {\n                if (new_locked.end > old_locked.end) {\n                    new_dslope -= u_new.slope;\n                    slope_changes[new_locked.end] = new_dslope;\n                }\n\n            }\n\n            uint user_epoch = votingBalanceLogicData.user_point_epoch[_tokenId] + 1;\n\n            votingBalanceLogicData.user_point_epoch[_tokenId] = user_epoch;\n            u_new.ts = block.timestamp;\n            u_new.blk = block.number;\n            votingBalanceLogicData.user_point_history[_tokenId][user_epoch] = u_new;\n        }\n    }\n\n\n    function _deposit_for(\n        uint _tokenId,\n        uint _value,\n        uint unlock_time,\n        IVotingEscrow.LockedBalance memory locked_balance,\n        DepositType deposit_type\n    ) internal {\n        IVotingEscrow.LockedBalance memory _locked = locked_balance;\n        uint supply_before = supply;\n\n        supply = supply_before + _value;\n        IVotingEscrow.LockedBalance memory old_locked;\n        (old_locked.amount, old_locked.end, old_locked.isPermanent) = (_locked.amount, _locked.end, _locked.isPermanent);\n\n        _locked.amount += int128(int256(_value));\n\n        if (unlock_time != 0) {\n            _locked.end = unlock_time;\n        }\n        locked[_tokenId] = _locked;\n\n\n        _checkpoint(_tokenId, old_locked, _locked);\n\n        address from = msg.sender;\n        if (_value != 0) {\n            assert(IERC20(token).transferFrom(from, address(this), _value));\n        }\n\n        emit Deposit(from, _tokenId, _value, _locked.end, deposit_type, block.timestamp);\n        emit Supply(supply_before, supply_before + _value);\n    }\n\n\n    function checkpoint() external {\n        _checkpoint(0, IVotingEscrow.LockedBalance(0, 0, false), IVotingEscrow.LockedBalance(0, 0, false));\n    }\n\n\n    function deposit_for(uint _tokenId, uint _value) external nonreentrant {\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n\n        require(_value > 0, \"ZV\");\n        require(_locked.amount > 0, 'ZL');\n        require(_locked.end > block.timestamp || _locked.isPermanent, 'EXP');\n\n        if (_locked.isPermanent) permanentLockBalance += _value;\n\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.DEPOSIT_FOR_TYPE);\n\n        if(voted[_tokenId]) {\n            IVoter(voter).poke(_tokenId);\n        }\n    }\n\n\n    function _create_lock(uint _value, uint _lock_duration, address _to) internal returns (uint) {\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK;\n\n        require(_value > 0, \"ZV\");\n        require(unlock_time > block.timestamp && (unlock_time <= block.timestamp + MAXTIME), 'IUT');\n\n        ++tokenId;\n        uint _tokenId = tokenId;\n        _mint(_to, _tokenId);\n\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n\n        _deposit_for(_tokenId, _value, unlock_time, _locked, DepositType.CREATE_LOCK_TYPE);\n        return _tokenId;\n    }\n\n\n    function create_lock(uint _value, uint _lock_duration) external nonreentrant returns (uint) {\n        return _create_lock(_value, _lock_duration, msg.sender);\n    }\n\n\n    function create_lock_for(uint _value, uint _lock_duration, address _to) external nonreentrant returns (uint) {\n        return _create_lock(_value, _lock_duration, _to);\n    }\n\n\n    function increase_amount(uint _tokenId, uint _value) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n\n        assert(_value > 0);\n        require(_locked.amount > 0, 'ZL');\n        require(_locked.end > block.timestamp || _locked.isPermanent, 'EXP');\n\n        if (_locked.isPermanent) permanentLockBalance += _value;\n        _deposit_for(_tokenId, _value, 0, _locked, DepositType.INCREASE_LOCK_AMOUNT);\n\n\n        if(voted[_tokenId]) {\n            IVoter(voter).poke(_tokenId);\n        }\n        emit MetadataUpdate(_tokenId);\n    }\n\n\n    function increase_unlock_time(uint _tokenId, uint _lock_duration) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n        require(!_locked.isPermanent, \"!NORM\");\n        uint unlock_time = (block.timestamp + _lock_duration) / WEEK * WEEK;\n\n        require(_locked.end > block.timestamp && _locked.amount > 0, 'EXP||ZV');\n        require(unlock_time > _locked.end && (unlock_time <= block.timestamp + MAXTIME), 'IUT');\n\n        _deposit_for(_tokenId, 0, unlock_time, _locked, DepositType.INCREASE_UNLOCK_TIME);\n\n\n        if(voted[_tokenId]) {\n            IVoter(voter).poke(_tokenId);\n        }\n        emit MetadataUpdate(_tokenId);\n    }\n\n\n    function withdraw(uint _tokenId) external nonreentrant {\n        assert(_isApprovedOrOwner(msg.sender, _tokenId));\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\n\n        IVotingEscrow.LockedBalance memory _locked = locked[_tokenId];\n        require(!_locked.isPermanent, \"!NORM\");\n        require(block.timestamp >= _locked.end, \"!EXP\");\n        uint value = uint(int256(_locked.amount));\n\n        locked[_tokenId] = IVotingEscrow.LockedBalance(0, 0, false);\n        uint supply_before = supply;\n        supply = supply_before - value;\n\n\n        _checkpoint(_tokenId, _locked, IVotingEscrow.LockedBalance(0, 0, false));\n\n        assert(IERC20(token).transfer(msg.sender, value));\n\n\n        _burn(_tokenId);\n\n        emit Withdraw(msg.sender, _tokenId, value, block.timestamp);\n        emit Supply(supply_before, supply_before - value);\n    }\n\n    function lockPermanent(uint _tokenId) external {\n        address sender = msg.sender;\n        require(_isApprovedOrOwner(sender, _tokenId), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory _newLocked = locked[_tokenId];\n        require(!_newLocked.isPermanent, \"!NORM\");\n        require(_newLocked.end > block.timestamp, \"EXP\");\n        require(_newLocked.amount > 0, \"ZV\");\n\n        uint _amount = uint(int256(_newLocked.amount));\n        permanentLockBalance += _amount;\n        _newLocked.end = 0;\n        _newLocked.isPermanent = true;\n        _checkpoint(_tokenId, locked[_tokenId], _newLocked);\n        locked[_tokenId] = _newLocked;\n        if(voted[_tokenId]) {\n            IVoter(voter).poke(_tokenId);\n        }\n        emit LockPermanent(sender, _tokenId, _amount, block.timestamp);\n        emit MetadataUpdate(_tokenId);\n    }\n\n    function unlockPermanent(uint _tokenId) external {\n        address sender = msg.sender;\n        require(_isApprovedOrOwner(msg.sender, _tokenId), \"NAO\");\n\n        require(attachments[_tokenId] == 0 && !voted[_tokenId], \"ATT\");\n        IVotingEscrow.LockedBalance memory _newLocked = locked[_tokenId];\n        require(_newLocked.isPermanent, \"!NORM\");\n        uint _amount = uint(int256(_newLocked.amount));\n        permanentLockBalance -= _amount;\n        _newLocked.end = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n        _newLocked.isPermanent = false;\n\n        _checkpoint(_tokenId, locked[_tokenId], _newLocked);\n        locked[_tokenId] = _newLocked;\n\n        emit UnlockPermanent(sender, _tokenId, _amount, block.timestamp);\n        emit MetadataUpdate(_tokenId);\n    }\n\n\n    function balanceOfNFT(uint _tokenId) external view returns (uint) {\n        if (ownership_change[_tokenId] == block.number) return 0;\n        return VotingBalanceLogic.balanceOfNFT(_tokenId, block.timestamp, votingBalanceLogicData);\n    }\n\n    function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\n        return VotingBalanceLogic.balanceOfNFT(_tokenId, _t, votingBalanceLogicData);\n    }\n\n    function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\n        return VotingBalanceLogic.balanceOfAtNFT(_tokenId, _block, votingBalanceLogicData, epoch);\n    }\n\n\n    function totalSupplyAt(uint _block) external view returns (uint) {\n        return VotingBalanceLogic.totalSupplyAt(_block, epoch, votingBalanceLogicData, slope_changes);\n    }\n\n    function totalSupply() external view returns (uint) {\n        return totalSupplyAtT(block.timestamp);\n    }\n\n\n    function totalSupplyAtT(uint t) public view returns (uint) {\n        return VotingBalanceLogic.totalSupplyAtT(t, epoch, slope_changes,  votingBalanceLogicData);\n    }\n\n\n    mapping(uint => uint) public attachments;\n    mapping(uint => bool) public voted;\n\n    function setVoter(address _voter) external {\n        require(msg.sender == team);\n        voter = _voter;\n    }\n\n    function voting(uint _tokenId) external {\n        require(msg.sender == voter);\n        voted[_tokenId] = true;\n    }\n\n    function abstain(uint _tokenId) external {\n        require(msg.sender == voter, \"NA\");\n        voted[_tokenId] = false;\n    }\n\n    function attach(uint _tokenId) external {\n        require(msg.sender == voter, \"NA\");\n        attachments[_tokenId] = attachments[_tokenId] + 1;\n    }\n\n    function detach(uint _tokenId) external {\n        require(msg.sender == voter, \"NA\");\n        attachments[_tokenId] = attachments[_tokenId] - 1;\n    }\n\n    function merge(uint _from, uint _to) external nonreentrant notPartnerNFT(_from) {\n        require(attachments[_from] == 0 && !voted[_from], \"ATT\");\n        require(_from != _to, \"SAME\");\n        require(_isApprovedOrOwner(msg.sender, _from) &&\n        _isApprovedOrOwner(msg.sender, _to), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory _locked0 = locked[_from];\n        IVotingEscrow.LockedBalance memory _locked1 = locked[_to];\n        require(_locked1.end > block.timestamp ||  _locked1.isPermanent,\"EXP||PERM\");\n        require(_locked0.isPermanent ? _locked1.isPermanent : true, \"!MERGE\");\n\n        uint value0 = uint(int256(_locked0.amount));\n        uint end = _locked0.end >= _locked1.end ? _locked0.end : _locked1.end;\n\n        locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n        _checkpoint(_from, _locked0, IVotingEscrow.LockedBalance(0, 0, false));\n        _burn(_from);\n\n        IVotingEscrow.LockedBalance memory newLockedTo;\n        newLockedTo.isPermanent = _locked1.isPermanent;\n\n        if (newLockedTo.isPermanent){\n            newLockedTo.amount = _locked1.amount + _locked0.amount;\n            if (!_locked0.isPermanent) {\n                permanentLockBalance += value0;\n            }\n        }else{\n            newLockedTo.amount = _locked1.amount + _locked0.amount;\n            newLockedTo.end = end;\n        }\n\n\n        _checkpoint(_to, _locked1, newLockedTo);\n        locked[_to] = newLockedTo;\n\n        if(voted[_to]) {\n            IVoter(voter).poke(_to);\n        }\n        emit Merge(\n            msg.sender,\n            _from,\n            _to,\n            uint(int256(_locked0.amount)),\n            uint(int256(_locked1.amount)),\n            uint(int256(newLockedTo.amount)),\n            newLockedTo.end,\n            block.timestamp\n        );\n        emit MetadataUpdate(_to);\n    }\n\n\n    function multiSplit(\n        uint _from,\n        uint[] memory amounts\n    ) external nonreentrant splitAllowed(_from) notPartnerNFT(_from) returns (uint256[] memory newTokenIds) {\n        require(amounts.length >= 2 && amounts.length <= 10, \"MIN2MAX10\");\n\n        address owner = idToOwner[_from];\n\n        IVotingEscrow.LockedBalance memory originalLocked = locked[_from];\n        require(originalLocked.end > block.timestamp || originalLocked.isPermanent, \"EXP\");\n        require(originalLocked.amount > 0, \"ZV\");\n\n\n        uint totalWeight = 0;\n        for(uint i = 0; i < amounts.length; i++) {\n            require(amounts[i] > 0, \"ZW\");\n            totalWeight += amounts[i];\n        }\n\n\n        locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n        _checkpoint(_from, originalLocked, IVotingEscrow.LockedBalance(0, 0, false));\n        _burn(_from);\n\n\n        newTokenIds = new uint256[](amounts.length);\n        uint[] memory actualAmounts = new uint[](amounts.length);\n\n        for(uint i = 0; i < amounts.length; i++) {\n            IVotingEscrow.LockedBalance memory newLocked = IVotingEscrow.LockedBalance({\n                amount: int128(int256(uint256(int256(originalLocked.amount)) * amounts[i] / totalWeight)),\n                end: originalLocked.end,\n                isPermanent: originalLocked.isPermanent\n            });\n\n            newTokenIds[i] = _createSplitNFT(owner, newLocked);\n            actualAmounts[i] = uint256(int256(newLocked.amount));\n        }\n\n        emit MultiSplit(\n            _from,\n            newTokenIds,\n            msg.sender,\n            actualAmounts,\n            originalLocked.end,\n            block.timestamp\n        );\n    }\n\n    function _createSplitNFT(address _to, IVotingEscrow.LockedBalance memory _newLocked) private returns (uint256 _tokenId) {\n        _tokenId = ++tokenId;\n        locked[_tokenId] = _newLocked;\n        _checkpoint(_tokenId, IVotingEscrow.LockedBalance(0, 0, false), _newLocked);\n        _mint(_to, _tokenId);\n    }\n\n    function toggleSplit(address _account, bool _bool) external {\n        require(msg.sender == team);\n        canSplit[_account] = _bool;\n    }\n\n\n    bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\n    bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n\n    mapping(address => address) private _delegates;\n\n\n    mapping(address => uint) public nonces;\n\n\n    function delegates(address delegator) public view returns (address) {\n        address current = _delegates[delegator];\n        return current == address(0) ? delegator : current;\n    }\n\n\n    function getVotes(address account) external view returns (uint) {\n        uint32 nCheckpoints = cpData.numCheckpoints[account];\n        if (nCheckpoints == 0) {\n            return 0;\n        }\n        uint[] storage _tokenIds = cpData.checkpoints[account][nCheckpoints - 1].tokenIds;\n        uint votes = 0;\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint tId = _tokenIds[i];\n            votes = votes + VotingBalanceLogic.balanceOfNFT(tId, block.timestamp, votingBalanceLogicData);\n        }\n        return votes;\n    }\n\n    function getPastVotes(address account, uint timestamp)\n        public\n        view\n        returns (uint)\n    {\n        uint32 _checkIndex = VotingDelegationLib.getPastVotesIndex(cpData, account, timestamp);\n\n        uint[] storage _tokenIds = cpData.checkpoints[account][_checkIndex].tokenIds;\n        uint votes = 0;\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            uint tId = _tokenIds[i];\n\n            votes = votes + VotingBalanceLogic.balanceOfNFT(tId, timestamp,  votingBalanceLogicData);\n        }\n\n        return votes;\n    }\n\n    function getPastTotalSupply(uint256 timestamp) external view returns (uint) {\n        return totalSupplyAtT(timestamp);\n    }\n\n\n    function _delegate(address delegator, address delegatee) internal {\n\n        address currentDelegate = delegates(delegator);\n\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n        VotingDelegationLib.TokenHelpers memory tokenHelpers = VotingDelegationLib.TokenHelpers({\n            ownerOfFn: ownerOf,\n            ownerToNFTokenCountFn: ownerToNFTokenCountFn,\n            tokenOfOwnerByIndex:tokenOfOwnerByIndex\n        });\n        VotingDelegationLib._moveAllDelegates(cpData, delegator, currentDelegate, delegatee, tokenHelpers);\n    }\n\n\n    function delegate(address delegatee) public {\n        if (delegatee == address(0)) delegatee = msg.sender;\n        return _delegate(msg.sender, delegatee);\n    }\n\n    function delegateBySig(\n        address delegatee,\n        uint nonce,\n        uint expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(delegatee != msg.sender, \"NA\");\n        require(delegatee != address(0), \"ZA\");\n\n        bytes32 domainSeparator = keccak256(\n            abi.encode(\n                DOMAIN_TYPEHASH,\n                keccak256(bytes(name)),\n                keccak256(bytes(version)),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 structHash = keccak256(\n            abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry)\n        );\n        bytes32 digest = keccak256(\n            abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash)\n        );\n        address signatory = ecrecover(digest, v, r, s);\n        require(\n            signatory != address(0),\n            \"ZA\"\n        );\n        require(\n            nonce == nonces[signatory]++,\n            \"!NONCE\"\n        );\n        require(\n            block.timestamp <= expiry,\n            \"EXP\"\n        );\n        return _delegate(signatory, delegatee);\n    }\n\n\n    // Unified dispatcher - merged from: setTeam, setArtProxy, setPartnerVeNFT\n    // Selectors: setTeam=0, setArtProxy=1, setPartnerVeNFT=2\n    function execute(uint8 _selector, address _proxy, address _team, bool _isPartner, uint _tokenId) public {\n        // Original: setTeam()\n        if (_selector == 0) {\n            require(msg.sender == team);\n            team = _team;\n        }\n        // Original: setArtProxy()\n        else if (_selector == 1) {\n            require(msg.sender == team);\n            artProxy = _proxy;\n            emit BatchMetadataUpdate(0, type(uint256).max);\n        }\n        // Original: setPartnerVeNFT()\n        else if (_selector == 2) {\n            require(msg.sender == team, \"NA\");\n            require(idToOwner[_tokenId] != address(0), \"DNE\");\n            isPartnerVeNFT[_tokenId] = _isPartner;\n        }\n    }\n}",
      "merged_functions": [
        "setTeam",
        "setArtProxy",
        "setPartnerVeNFT"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: setTeam, setArtProxy, setPartnerVeNFT"
      ],
      "function_to_selector": {
        "setTeam": 0,
        "setArtProxy": 1,
        "setPartnerVeNFT": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_011",
      "transformed_id": "rs_mg_dis_nc_gs_011",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_gs_012",
      "transformed_id": "rs_mg_dis_nc_gs_012",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.minProposerVotingPower.selector ^ this.createProposal.selector;\n\n\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\n\n\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = keccak256(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 proposalId, address voter);\n\n    error VoteRemovalForbidden(uint256 proposalId, address voter);\n\n\n    function initialize(\n        IDAO _dao,\n        ILockManager _lockManager,\n        VotingSettings calldata _votingSettings,\n        IPlugin.TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) external onlyCallAtInitialization reinitializer(1) {\n        __MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n        __LockToGovernBase_init(_lockManager);\n\n        emit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n    }\n\n\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _interfaceId == LOCK_TO_VOTE_INTERFACE_ID || _interfaceId == type(ILockToVote).interfaceId\n            || super.supportsInterface(_interfaceId);\n    }\n\n\n    function customProposalParamsABI() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n\n    function createProposal(\n        bytes calldata _metadata,\n        Action[] memory _actions,\n        uint64 _startDate,\n        uint64 _endDate,\n        bytes memory _data\n    ) external auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\n        uint256 _allowFailureMap;\n\n        if (_data.length != 0) {\n            (_allowFailureMap) = abi.decode(_data, (uint256));\n        }\n\n        if (currentTokenSupply() == 0) {\n            revert NoVotingPower();\n        }\n\n\n        (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\n\n        proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n\n        if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n        }\n\n\n        Proposal storage proposal_ = proposals[proposalId];\n\n        proposal_.parameters.votingMode = votingMode();\n        proposal_.parameters.supportThresholdRatio = supportThresholdRatio();\n        proposal_.parameters.startDate = _startDate;\n        proposal_.parameters.endDate = _endDate;\n        proposal_.parameters.minParticipationRatio = minParticipationRatio();\n        proposal_.parameters.minApprovalRatio = minApprovalRatio();\n\n        proposal_.targetConfig = getTargetConfig();\n\n\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length;) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\n\n        lockManager.proposalCreated(proposalId);\n    }\n\n\n    function canVote(uint256 _proposalId, address _voter, VoteOption _voteOption) public view returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _canVote(proposal_, _voter, _voteOption, lockManager.getLockedBalance(_voter));\n    }\n\n\n    function vote(uint256 _proposalId, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        public\n        override\n        auth(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        if (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\n            revert VoteCastForbidden(_proposalId, _voter);\n        }\n\n\n        if (_voteOption == proposal_.votes[_voter].voteOption) {\n\n            if (_newVotingPower == proposal_.votes[_voter].votingPower) return;\n\n\n            uint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += diff;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                proposal_.tally.no += diff;\n            } else {\n\n                proposal_.tally.abstain += diff;\n            }\n        } else {\n\n\n            if (proposal_.votes[_voter].votingPower > 0) {\n\n                if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                    proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n                } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                    proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n                } else {\n\n                    proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n                }\n            }\n\n\n            if (_voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += _newVotingPower;\n            } else if (_voteOption == VoteOption.No) {\n                proposal_.tally.no += _newVotingPower;\n            } else {\n\n                proposal_.tally.abstain += _newVotingPower;\n            }\n            proposal_.votes[_voter].voteOption = _voteOption;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n        }\n\n        emit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\n\n        if (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n            _attemptEarlyExecution(_proposalId, _msgSender());\n        }\n    }\n\n\n    function clearVote(uint256 _proposalId, address _voter) external auth(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        if (!_isProposalOpen(proposal_)) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.votes[_voter].votingPower == 0) {\n\n            return;\n        }\n\n\n        if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n        } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n        }\n\n        else if (proposal_.votes[_voter].voteOption == VoteOption.Abstain) {\n            proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n        }\n        proposal_.votes[_voter].votingPower = 0;\n\n        emit VoteCleared(_proposalId, _voter);\n    }\n\n\n    function isProposalOpen(uint256 _proposalId) external view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _isProposalOpen(proposal_);\n    }\n\n\n    function minProposerVotingPower() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.minProposerVotingPower();\n    }\n\n\n    function currentTokenSupply() public view override returns (uint256) {\n        return IERC20(lockManager.token()).totalSupply();\n    }\n\n\n    function usedVotingPower(uint256 _proposalId, address _voter) public view returns (uint256) {\n        return proposals[_proposalId].votes[_voter].votingPower;\n    }\n\n\n    function _canVote(Proposal storage proposal_, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _currentVotingPower = proposal_.votes[_voter].votingPower;\n\n\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        } else if (_voteOption == VoteOption.None) {\n            return false;\n        }\n\n        else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n\n            if (_newVotingPower <= _currentVotingPower) {\n                return false;\n            }\n\n            else if (\n                proposal_.votes[_voter].voteOption != VoteOption.None\n                    && _voteOption != proposal_.votes[_voter].voteOption\n            ) {\n                return false;\n            }\n        }\n\n        else {\n\n            if (_newVotingPower == 0 || _newVotingPower < _currentVotingPower) {\n                return false;\n            }\n\n            else if (_newVotingPower == _currentVotingPower && _voteOption == proposal_.votes[_voter].voteOption) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _attemptEarlyExecution(uint256 _proposalId, address _voteCaller) internal {\n        if (!_canExecute(_proposalId)) {\n            return;\n        } else if (!dao().hasPermission(address(this), _voteCaller, EXECUTE_PROPOSAL_PERMISSION_ID, _msgData())) {\n            return;\n        }\n\n        _execute(_proposalId);\n    }\n\n    function _execute(uint256 _proposalId) internal override {\n        super._execute(_proposalId);\n\n\n        lockManager.proposalEnded(_proposalId);\n    }\n\n\n    uint256[50] private __gap;\n\n    // Unified dispatcher - merged from: vote, initialize, createProposal\n    // Selectors: vote=0, initialize=1, createProposal=2\n    function execute(uint8 _selector, Action[] _actions, IDAO _dao, ILockManager _lockManager, IPlugin.TargetConfig _targetConfig, VoteOption _voteOption, VotingSettings _votingSettings, address _voter, bytes _data, bytes _metadata, bytes _pluginMetadata, uint256 _newVotingPower, uint256 _proposalId, uint64 _endDate, uint64 _startDate) public {\n        // Original: vote()\n        if (_selector == 0) {\n            Proposal storage proposal_ = proposals[_proposalId];\n            if (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\n            revert VoteCastForbidden(_proposalId, _voter);\n            }\n            if (_voteOption == proposal_.votes[_voter].voteOption) {\n            if (_newVotingPower == proposal_.votes[_voter].votingPower) return;\n            uint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes += diff;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no += diff;\n            } else {\n            proposal_.tally.abstain += diff;\n            }\n            } else {\n            if (proposal_.votes[_voter].votingPower > 0) {\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n            } else {\n            proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n            }\n            }\n            if (_voteOption == VoteOption.Yes) {\n            proposal_.tally.yes += _newVotingPower;\n            } else if (_voteOption == VoteOption.No) {\n            proposal_.tally.no += _newVotingPower;\n            } else {\n            proposal_.tally.abstain += _newVotingPower;\n            }\n            proposal_.votes[_voter].voteOption = _voteOption;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n            }\n            emit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\n            if (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n            _attemptEarlyExecution(_proposalId, _msgSender());\n            }\n        }\n        // Original: initialize()\n        else if (_selector == 1) {\n            __MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n            __LockToGovernBase_init(_lockManager);\n            emit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n        }\n        // Original: createProposal()\n        else if (_selector == 2) {\n            uint256 _allowFailureMap;\n            if (_data.length != 0) {\n            (_allowFailureMap) = abi.decode(_data, (uint256));\n            }\n            if (currentTokenSupply() == 0) {\n            revert NoVotingPower();\n            }\n            (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\n            proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n            if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n            }\n            Proposal storage proposal_ = proposals[proposalId];\n            proposal_.parameters.votingMode = votingMode();\n            proposal_.parameters.supportThresholdRatio = supportThresholdRatio();\n            proposal_.parameters.startDate = _startDate;\n            proposal_.parameters.endDate = _endDate;\n            proposal_.parameters.minParticipationRatio = minParticipationRatio();\n            proposal_.parameters.minApprovalRatio = minApprovalRatio();\n            proposal_.targetConfig = getTargetConfig();\n            if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n            }\n            for (uint256 i; i < _actions.length;) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n            ++i;\n            }\n            }\n            emit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\n            lockManager.proposalCreated(proposalId);\n        }\n    }\n}",
      "merged_functions": [
        "vote",
        "initialize",
        "createProposal"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: vote, initialize, createProposal"
      ],
      "function_to_selector": {
        "vote": 0,
        "initialize": 1,
        "createProposal": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_013",
      "transformed_id": "rs_mg_dis_nc_gs_013",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_gs_014",
      "transformed_id": "rs_mg_dis_nc_gs_014",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_gs_015",
      "transformed_id": "rs_mg_dis_nc_gs_015",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n\n    LockManagerSettings public settings;\n\n\n    ILockToGovernBase public plugin;\n\n\n    mapping(address => uint256) private lockedBalances;\n\n\n    EnumerableSet.UintSet internal knownProposalIds;\n\n\n    event BalanceLocked(address voter, uint256 amount);\n\n\n    event BalanceUnlocked(address voter, uint256 amount);\n\n\n    event ProposalEnded(uint256 proposalId);\n\n\n    error InvalidPluginAddress();\n\n\n    error NoBalance();\n\n\n    error LocksStillActive();\n\n\n    error InvalidPlugin();\n\n\n    error InvalidPluginMode();\n\n\n    error SetPluginAddressForbidden();\n\n\n    constructor(LockManagerSettings memory _settings) {\n        settings.pluginMode = _settings.pluginMode;\n    }\n\n\n    function knownProposalIdAt(uint256 _index) public view virtual returns (uint256) {\n        return knownProposalIds.at(_index);\n    }\n\n\n    function knownProposalIdsLength() public view virtual returns (uint256) {\n        return knownProposalIds.length();\n    }\n\n\n    function lock() public virtual {\n        _lock(_incomingTokenBalance());\n    }\n\n\n    function lock(uint256 _amount) public virtual {\n        _lock(_amount);\n    }\n\n\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_incomingTokenBalance());\n        _vote(_proposalId, _voteOption);\n    }\n\n\n    function lockAndVote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption, uint256 _amount) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _lock(_amount);\n        _vote(_proposalId, _voteOption);\n    }\n\n\n    function vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) public virtual {\n        if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _vote(_proposalId, _voteOption);\n    }\n\n\n    function getLockedBalance(address _account) public view virtual returns (uint256) {\n        return lockedBalances[_account];\n    }\n\n\n    function canVote(uint256 _proposalId, address _voter, IMajorityVoting.VoteOption _voteOption)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(plugin)).canVote(_proposalId, _voter, _voteOption);\n    }\n\n\n    function unlock() public virtual {\n        uint256 _refundableBalance = getLockedBalance(msg.sender);\n        if (_refundableBalance == 0) {\n            revert NoBalance();\n        }\n\n\n        _withdrawActiveVotingPower();\n\n\n        lockedBalances[msg.sender] = 0;\n\n\n        _doUnlockTransfer(msg.sender, _refundableBalance);\n        emit BalanceUnlocked(msg.sender, _refundableBalance);\n    }\n\n\n    function proposalCreated(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n\n        knownProposalIds.add(_proposalId);\n    }\n\n\n    function proposalEnded(uint256 _proposalId) public virtual {\n        if (msg.sender != address(plugin)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(_proposalId);\n        knownProposalIds.remove(_proposalId);\n    }\n\n\n    function setPluginAddress(ILockToGovernBase _newPluginAddress) public virtual {\n        if (address(plugin) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToGovernBase).interfaceId)) {\n            revert InvalidPlugin();\n        }\n\n        else if (\n            settings.pluginMode == PluginMode.Voting\n                && !IERC165(address(_newPluginAddress)).supportsInterface(type(ILockToVote).interfaceId)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        plugin = _newPluginAddress;\n    }\n\n\n    function _incomingTokenBalance() internal view virtual returns (uint256);\n\n\n    function _lock(uint256 _amount) internal virtual {\n        if (_amount == 0) {\n            revert NoBalance();\n        }\n\n\n        _doLockTransfer(_amount);\n\n        lockedBalances[msg.sender] += _amount;\n        emit BalanceLocked(msg.sender, _amount);\n    }\n\n\n    function _doLockTransfer(uint256 _amount) internal virtual;\n\n\n    function _doUnlockTransfer(address _recipient, uint256 _amount) internal virtual;\n\n    function _vote(uint256 _proposalId, IMajorityVoting.VoteOption _voteOption) internal virtual {\n        uint256 _currentVotingPower = getLockedBalance(msg.sender);\n\n\n        ILockToVote(address(plugin)).vote(_proposalId, msg.sender, _voteOption, _currentVotingPower);\n    }\n\n    function _withdrawActiveVotingPower() internal virtual {\n        uint256 _proposalCount = knownProposalIds.length();\n        for (uint256 _i; _i < _proposalCount;) {\n            uint256 _proposalId = knownProposalIds.at(_i);\n            if (!plugin.isProposalOpen(_proposalId)) {\n                knownProposalIds.remove(_proposalId);\n                _proposalCount = knownProposalIds.length();\n\n\n                if (_i == _proposalCount) {\n                    return;\n                }\n\n\n                continue;\n            }\n\n            if (plugin.usedVotingPower(_proposalId, msg.sender) > 0) {\n                ILockToVote(address(plugin)).clearVote(_proposalId, msg.sender);\n            }\n\n            unchecked {\n                _i++;\n            }\n        }\n    }\n\n    // Unified dispatcher - merged from: lock, lock, lockAndVote\n    // Selectors: lock=1, lockAndVote=2\n    function execute(uint8 _selector, IMajorityVoting.VoteOption _voteOption, uint256 _amount, uint256 _proposalId) public {\n        // Original: lock()\n        if (_selector == 0) {\n            _lock(_incomingTokenBalance());\n        }\n        // Original: lock()\n        else if (_selector == 1) {\n            _lock(_amount);\n        }\n        // Original: lockAndVote()\n        else if (_selector == 2) {\n            if (settings.pluginMode != PluginMode.Voting) {\n            revert InvalidPluginMode();\n            }\n            _lock(_incomingTokenBalance());\n            _vote(_proposalId, _voteOption);\n        }\n    }\n}",
      "merged_functions": [
        "lock",
        "lock",
        "lockAndVote"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: lock, lock, lockAndVote"
      ],
      "function_to_selector": {
        "lock": 1,
        "lockAndVote": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_016",
      "transformed_id": "rs_mg_dis_nc_gs_016",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.minProposerVotingPower.selector ^ this.createProposal.selector;\n\n\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\n\n\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = keccak256(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 proposalId, address voter);\n\n    error VoteRemovalForbidden(uint256 proposalId, address voter);\n\n\n    function initialize(\n        IDAO _dao,\n        ILockManager _lockManager,\n        VotingSettings calldata _votingSettings,\n        IPlugin.TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) external onlyCallAtInitialization reinitializer(1) {\n        __MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n        __LockToGovernBase_init(_lockManager);\n\n        emit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n    }\n\n\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _interfaceId == LOCK_TO_VOTE_INTERFACE_ID || _interfaceId == type(ILockToVote).interfaceId\n            || super.supportsInterface(_interfaceId);\n    }\n\n\n    function customProposalParamsABI() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n\n    function createProposal(\n        bytes calldata _metadata,\n        Action[] memory _actions,\n        uint64 _startDate,\n        uint64 _endDate,\n        bytes memory _data\n    ) external auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\n        uint256 _allowFailureMap;\n\n        if (_data.length != 0) {\n            (_allowFailureMap) = abi.decode(_data, (uint256));\n        }\n\n        if (currentTokenSupply() == 0) {\n            revert NoVotingPower();\n        }\n\n\n        (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\n\n        proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n\n        if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n        }\n\n\n        Proposal storage proposal_ = proposals[proposalId];\n\n        proposal_.parameters.votingMode = votingMode();\n        proposal_.parameters.supportThresholdRatio = supportThresholdRatio();\n        proposal_.parameters.startDate = _startDate;\n        proposal_.parameters.endDate = _endDate;\n        proposal_.parameters.minParticipationRatio = minParticipationRatio();\n        proposal_.parameters.minApprovalRatio = minApprovalRatio();\n\n        proposal_.targetConfig = getTargetConfig();\n\n\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length;) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\n\n        lockManager.proposalCreated(proposalId);\n    }\n\n\n    function canVote(uint256 _proposalId, address _voter, VoteOption _voteOption) public view returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _canVote(proposal_, _voter, _voteOption, lockManager.getLockedBalance(_voter));\n    }\n\n\n    function vote(uint256 _proposalId, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        public\n        override\n        auth(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        if (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\n            revert VoteCastForbidden(_proposalId, _voter);\n        }\n\n\n        if (_voteOption == proposal_.votes[_voter].voteOption) {\n\n            if (_newVotingPower == proposal_.votes[_voter].votingPower) return;\n\n\n            uint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += diff;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                proposal_.tally.no += diff;\n            } else {\n\n                proposal_.tally.abstain += diff;\n            }\n        } else {\n\n\n            if (proposal_.votes[_voter].votingPower > 0) {\n\n                if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                    proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n                } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                    proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n                } else {\n\n                    proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n                }\n            }\n\n\n            if (_voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += _newVotingPower;\n            } else if (_voteOption == VoteOption.No) {\n                proposal_.tally.no += _newVotingPower;\n            } else {\n\n                proposal_.tally.abstain += _newVotingPower;\n            }\n            proposal_.votes[_voter].voteOption = _voteOption;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n        }\n\n        emit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\n\n        if (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n            _attemptEarlyExecution(_proposalId, _msgSender());\n        }\n    }\n\n\n    function clearVote(uint256 _proposalId, address _voter) external auth(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        if (!_isProposalOpen(proposal_)) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.votes[_voter].votingPower == 0) {\n\n            return;\n        }\n\n\n        if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n        } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n        }\n\n        else if (proposal_.votes[_voter].voteOption == VoteOption.Abstain) {\n            proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n        }\n        proposal_.votes[_voter].votingPower = 0;\n\n        emit VoteCleared(_proposalId, _voter);\n    }\n\n\n    function isProposalOpen(uint256 _proposalId) external view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _isProposalOpen(proposal_);\n    }\n\n\n    function minProposerVotingPower() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.minProposerVotingPower();\n    }\n\n\n    function currentTokenSupply() public view override returns (uint256) {\n        return IERC20(lockManager.token()).totalSupply();\n    }\n\n\n    function usedVotingPower(uint256 _proposalId, address _voter) public view returns (uint256) {\n        return proposals[_proposalId].votes[_voter].votingPower;\n    }\n\n\n    function _canVote(Proposal storage proposal_, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _currentVotingPower = proposal_.votes[_voter].votingPower;\n\n\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        } else if (_voteOption == VoteOption.None) {\n            return false;\n        }\n\n        else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n\n            if (_newVotingPower <= _currentVotingPower) {\n                return false;\n            }\n\n            else if (\n                proposal_.votes[_voter].voteOption != VoteOption.None\n                    && _voteOption != proposal_.votes[_voter].voteOption\n            ) {\n                return false;\n            }\n        }\n\n        else {\n\n            if (_newVotingPower == 0 || _newVotingPower < _currentVotingPower) {\n                return false;\n            }\n\n            else if (_newVotingPower == _currentVotingPower && _voteOption == proposal_.votes[_voter].voteOption) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _attemptEarlyExecution(uint256 _proposalId, address _voteCaller) internal {\n        if (!_canExecute(_proposalId)) {\n            return;\n        } else if (!dao().hasPermission(address(this), _voteCaller, EXECUTE_PROPOSAL_PERMISSION_ID, _msgData())) {\n            return;\n        }\n\n        _execute(_proposalId);\n    }\n\n    function _execute(uint256 _proposalId) internal override {\n        super._execute(_proposalId);\n\n\n        lockManager.proposalEnded(_proposalId);\n    }\n\n\n    uint256[50] private __gap;\n\n    // Unified dispatcher - merged from: createProposal, initialize, vote\n    // Selectors: createProposal=0, initialize=1, vote=2\n    function execute(uint8 _selector, Action[] _actions, IDAO _dao, ILockManager _lockManager, IPlugin.TargetConfig _targetConfig, VoteOption _voteOption, VotingSettings _votingSettings, address _voter, bytes _data, bytes _metadata, bytes _pluginMetadata, uint256 _newVotingPower, uint256 _proposalId, uint64 _endDate, uint64 _startDate) public {\n        // Original: createProposal()\n        if (_selector == 0) {\n            uint256 _allowFailureMap;\n            if (_data.length != 0) {\n            (_allowFailureMap) = abi.decode(_data, (uint256));\n            }\n            if (currentTokenSupply() == 0) {\n            revert NoVotingPower();\n            }\n            (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\n            proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n            if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n            }\n            Proposal storage proposal_ = proposals[proposalId];\n            proposal_.parameters.votingMode = votingMode();\n            proposal_.parameters.supportThresholdRatio = supportThresholdRatio();\n            proposal_.parameters.startDate = _startDate;\n            proposal_.parameters.endDate = _endDate;\n            proposal_.parameters.minParticipationRatio = minParticipationRatio();\n            proposal_.parameters.minApprovalRatio = minApprovalRatio();\n            proposal_.targetConfig = getTargetConfig();\n            if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n            }\n            for (uint256 i; i < _actions.length;) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n            ++i;\n            }\n            }\n            emit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\n            lockManager.proposalCreated(proposalId);\n        }\n        // Original: initialize()\n        else if (_selector == 1) {\n            __MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n            __LockToGovernBase_init(_lockManager);\n            emit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n        }\n        // Original: vote()\n        else if (_selector == 2) {\n            Proposal storage proposal_ = proposals[_proposalId];\n            if (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\n            revert VoteCastForbidden(_proposalId, _voter);\n            }\n            if (_voteOption == proposal_.votes[_voter].voteOption) {\n            if (_newVotingPower == proposal_.votes[_voter].votingPower) return;\n            uint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes += diff;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no += diff;\n            } else {\n            proposal_.tally.abstain += diff;\n            }\n            } else {\n            if (proposal_.votes[_voter].votingPower > 0) {\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n            } else {\n            proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n            }\n            }\n            if (_voteOption == VoteOption.Yes) {\n            proposal_.tally.yes += _newVotingPower;\n            } else if (_voteOption == VoteOption.No) {\n            proposal_.tally.no += _newVotingPower;\n            } else {\n            proposal_.tally.abstain += _newVotingPower;\n            }\n            proposal_.votes[_voter].voteOption = _voteOption;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n            }\n            emit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\n            if (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n            _attemptEarlyExecution(_proposalId, _msgSender());\n            }\n        }\n    }\n}",
      "merged_functions": [
        "createProposal",
        "initialize",
        "vote"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: createProposal, initialize, vote"
      ],
      "function_to_selector": {
        "createProposal": 0,
        "initialize": 1,
        "vote": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_017",
      "transformed_id": "rs_mg_dis_nc_gs_017",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_gs_018",
      "transformed_id": "rs_mg_dis_nc_gs_018",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.minProposerVotingPower.selector ^ this.createProposal.selector;\n\n\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = keccak256(\"CREATE_PROPOSAL_PERMISSION\");\n\n\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = keccak256(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 proposalId, address voter);\n\n    error VoteRemovalForbidden(uint256 proposalId, address voter);\n\n\n    function initialize(\n        IDAO _dao,\n        ILockManager _lockManager,\n        VotingSettings calldata _votingSettings,\n        IPlugin.TargetConfig calldata _targetConfig,\n        bytes calldata _pluginMetadata\n    ) external onlyCallAtInitialization reinitializer(1) {\n        __MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n        __LockToGovernBase_init(_lockManager);\n\n        emit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n    }\n\n\n    function supportsInterface(bytes4 _interfaceId)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _interfaceId == LOCK_TO_VOTE_INTERFACE_ID || _interfaceId == type(ILockToVote).interfaceId\n            || super.supportsInterface(_interfaceId);\n    }\n\n\n    function customProposalParamsABI() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n\n    function createProposal(\n        bytes calldata _metadata,\n        Action[] memory _actions,\n        uint64 _startDate,\n        uint64 _endDate,\n        bytes memory _data\n    ) external auth(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 proposalId) {\n        uint256 _allowFailureMap;\n\n        if (_data.length != 0) {\n            (_allowFailureMap) = abi.decode(_data, (uint256));\n        }\n\n        if (currentTokenSupply() == 0) {\n            revert NoVotingPower();\n        }\n\n\n        (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\n\n        proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n\n        if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n        }\n\n\n        Proposal storage proposal_ = proposals[proposalId];\n\n        proposal_.parameters.votingMode = votingMode();\n        proposal_.parameters.supportThresholdRatio = supportThresholdRatio();\n        proposal_.parameters.startDate = _startDate;\n        proposal_.parameters.endDate = _endDate;\n        proposal_.parameters.minParticipationRatio = minParticipationRatio();\n        proposal_.parameters.minApprovalRatio = minApprovalRatio();\n\n        proposal_.targetConfig = getTargetConfig();\n\n\n        if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n        }\n\n        for (uint256 i; i < _actions.length;) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\n\n        lockManager.proposalCreated(proposalId);\n    }\n\n\n    function canVote(uint256 _proposalId, address _voter, VoteOption _voteOption) public view returns (bool) {\n        if (!_proposalExists(_proposalId)) {\n            revert NonexistentProposal(_proposalId);\n        }\n\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _canVote(proposal_, _voter, _voteOption, lockManager.getLockedBalance(_voter));\n    }\n\n\n    function vote(uint256 _proposalId, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        public\n        override\n        auth(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage proposal_ = proposals[_proposalId];\n\n        if (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\n            revert VoteCastForbidden(_proposalId, _voter);\n        }\n\n\n        if (_voteOption == proposal_.votes[_voter].voteOption) {\n\n            if (_newVotingPower == proposal_.votes[_voter].votingPower) return;\n\n\n            uint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += diff;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                proposal_.tally.no += diff;\n            } else {\n\n                proposal_.tally.abstain += diff;\n            }\n        } else {\n\n\n            if (proposal_.votes[_voter].votingPower > 0) {\n\n                if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n                    proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n                } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n                    proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n                } else {\n\n                    proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n                }\n            }\n\n\n            if (_voteOption == VoteOption.Yes) {\n                proposal_.tally.yes += _newVotingPower;\n            } else if (_voteOption == VoteOption.No) {\n                proposal_.tally.no += _newVotingPower;\n            } else {\n\n                proposal_.tally.abstain += _newVotingPower;\n            }\n            proposal_.votes[_voter].voteOption = _voteOption;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n        }\n\n        emit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\n\n        if (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n            _attemptEarlyExecution(_proposalId, _msgSender());\n        }\n    }\n\n\n    function clearVote(uint256 _proposalId, address _voter) external auth(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        if (!_isProposalOpen(proposal_)) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_proposalId, _voter);\n        } else if (proposal_.votes[_voter].votingPower == 0) {\n\n            return;\n        }\n\n\n        if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n        } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n        }\n\n        else if (proposal_.votes[_voter].voteOption == VoteOption.Abstain) {\n            proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n        }\n        proposal_.votes[_voter].votingPower = 0;\n\n        emit VoteCleared(_proposalId, _voter);\n    }\n\n\n    function isProposalOpen(uint256 _proposalId) external view returns (bool) {\n        Proposal storage proposal_ = proposals[_proposalId];\n        return _isProposalOpen(proposal_);\n    }\n\n\n    function minProposerVotingPower() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.minProposerVotingPower();\n    }\n\n\n    function currentTokenSupply() public view override returns (uint256) {\n        return IERC20(lockManager.token()).totalSupply();\n    }\n\n\n    function usedVotingPower(uint256 _proposalId, address _voter) public view returns (uint256) {\n        return proposals[_proposalId].votes[_voter].votingPower;\n    }\n\n\n    function _canVote(Proposal storage proposal_, address _voter, VoteOption _voteOption, uint256 _newVotingPower)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _currentVotingPower = proposal_.votes[_voter].votingPower;\n\n\n        if (!_isProposalOpen(proposal_)) {\n            return false;\n        } else if (_voteOption == VoteOption.None) {\n            return false;\n        }\n\n        else if (proposal_.parameters.votingMode != VotingMode.VoteReplacement) {\n\n            if (_newVotingPower <= _currentVotingPower) {\n                return false;\n            }\n\n            else if (\n                proposal_.votes[_voter].voteOption != VoteOption.None\n                    && _voteOption != proposal_.votes[_voter].voteOption\n            ) {\n                return false;\n            }\n        }\n\n        else {\n\n            if (_newVotingPower == 0 || _newVotingPower < _currentVotingPower) {\n                return false;\n            }\n\n            else if (_newVotingPower == _currentVotingPower && _voteOption == proposal_.votes[_voter].voteOption) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _attemptEarlyExecution(uint256 _proposalId, address _voteCaller) internal {\n        if (!_canExecute(_proposalId)) {\n            return;\n        } else if (!dao().hasPermission(address(this), _voteCaller, EXECUTE_PROPOSAL_PERMISSION_ID, _msgData())) {\n            return;\n        }\n\n        _execute(_proposalId);\n    }\n\n    function _execute(uint256 _proposalId) internal override {\n        super._execute(_proposalId);\n\n\n        lockManager.proposalEnded(_proposalId);\n    }\n\n\n    uint256[50] private __gap;\n\n    // Unified dispatcher - merged from: initialize, createProposal, vote\n    // Selectors: initialize=0, createProposal=1, vote=2\n    function execute(uint8 _selector, Action[] _actions, IDAO _dao, ILockManager _lockManager, IPlugin.TargetConfig _targetConfig, VoteOption _voteOption, VotingSettings _votingSettings, address _voter, bytes _data, bytes _metadata, bytes _pluginMetadata, uint256 _newVotingPower, uint256 _proposalId, uint64 _endDate, uint64 _startDate) public {\n        // Original: initialize()\n        if (_selector == 0) {\n            __MajorityVotingBase_init(_dao, _votingSettings, _targetConfig, _pluginMetadata);\n            __LockToGovernBase_init(_lockManager);\n            emit MembershipContractAnnounced({definingContract: address(_lockManager.token())});\n        }\n        // Original: createProposal()\n        else if (_selector == 1) {\n            uint256 _allowFailureMap;\n            if (_data.length != 0) {\n            (_allowFailureMap) = abi.decode(_data, (uint256));\n            }\n            if (currentTokenSupply() == 0) {\n            revert NoVotingPower();\n            }\n            (_startDate, _endDate) = _validateProposalDates(_startDate, _endDate);\n            proposalId = _createProposalId(keccak256(abi.encode(_actions, _metadata)));\n            if (_proposalExists(proposalId)) {\n            revert ProposalAlreadyExists(proposalId);\n            }\n            Proposal storage proposal_ = proposals[proposalId];\n            proposal_.parameters.votingMode = votingMode();\n            proposal_.parameters.supportThresholdRatio = supportThresholdRatio();\n            proposal_.parameters.startDate = _startDate;\n            proposal_.parameters.endDate = _endDate;\n            proposal_.parameters.minParticipationRatio = minParticipationRatio();\n            proposal_.parameters.minApprovalRatio = minApprovalRatio();\n            proposal_.targetConfig = getTargetConfig();\n            if (_allowFailureMap != 0) {\n            proposal_.allowFailureMap = _allowFailureMap;\n            }\n            for (uint256 i; i < _actions.length;) {\n            proposal_.actions.push(_actions[i]);\n            unchecked {\n            ++i;\n            }\n            }\n            emit ProposalCreated(proposalId, _msgSender(), _startDate, _endDate, _metadata, _actions, _allowFailureMap);\n            lockManager.proposalCreated(proposalId);\n        }\n        // Original: vote()\n        else if (_selector == 2) {\n            Proposal storage proposal_ = proposals[_proposalId];\n            if (!_canVote(proposal_, _voter, _voteOption, _newVotingPower)) {\n            revert VoteCastForbidden(_proposalId, _voter);\n            }\n            if (_voteOption == proposal_.votes[_voter].voteOption) {\n            if (_newVotingPower == proposal_.votes[_voter].votingPower) return;\n            uint256 diff = _newVotingPower - proposal_.votes[_voter].votingPower;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes += diff;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no += diff;\n            } else {\n            proposal_.tally.abstain += diff;\n            }\n            } else {\n            if (proposal_.votes[_voter].votingPower > 0) {\n            if (proposal_.votes[_voter].voteOption == VoteOption.Yes) {\n            proposal_.tally.yes -= proposal_.votes[_voter].votingPower;\n            } else if (proposal_.votes[_voter].voteOption == VoteOption.No) {\n            proposal_.tally.no -= proposal_.votes[_voter].votingPower;\n            } else {\n            proposal_.tally.abstain -= proposal_.votes[_voter].votingPower;\n            }\n            }\n            if (_voteOption == VoteOption.Yes) {\n            proposal_.tally.yes += _newVotingPower;\n            } else if (_voteOption == VoteOption.No) {\n            proposal_.tally.no += _newVotingPower;\n            } else {\n            proposal_.tally.abstain += _newVotingPower;\n            }\n            proposal_.votes[_voter].voteOption = _voteOption;\n            proposal_.votes[_voter].votingPower = _newVotingPower;\n            }\n            emit VoteCast(_proposalId, _voter, _voteOption, _newVotingPower);\n            if (proposal_.parameters.votingMode == VotingMode.EarlyExecution) {\n            _attemptEarlyExecution(_proposalId, _msgSender());\n            }\n        }\n    }\n}",
      "merged_functions": [
        "initialize",
        "createProposal",
        "vote"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: initialize, createProposal, vote"
      ],
      "function_to_selector": {
        "initialize": 0,
        "createProposal": 1,
        "vote": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_019",
      "transformed_id": "rs_mg_dis_nc_gs_019",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.23;\n\nimport {ReentrancyGuardTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\n\ncontract MidasRedemptionVaultGateway is ReentrancyGuardTrait, IMidasRedemptionVaultGateway {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant override contractType = \"GATEWAY::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override version = 3_10;\n\n    address public immutable midasRedemptionVault;\n    address public immutable mToken;\n\n    mapping(address => PendingRedemption) public pendingRedemptions;\n\n\n    constructor(address _midasRedemptionVault) {\n        midasRedemptionVault = _midasRedemptionVault;\n        mToken = IMidasRedemptionVault(_midasRedemptionVault).mToken();\n    }\n\n\n    function redeemInstant(address tokenOut, uint256 amountMTokenIn, uint256 minReceiveAmount) external nonReentrant {\n        IERC20(mToken).safeTransferFrom(msg.sender, address(this), amountMTokenIn);\n\n        uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n\n        IERC20(mToken).forceApprove(midasRedemptionVault, amountMTokenIn);\n        IMidasRedemptionVault(midasRedemptionVault).redeemInstant(tokenOut, amountMTokenIn, minReceiveAmount);\n\n        uint256 amount = IERC20(tokenOut).balanceOf(address(this)) - balanceBefore;\n\n        IERC20(tokenOut).safeTransfer(msg.sender, amount);\n    }\n\n\n    function requestRedeem(address tokenOut, uint256 amountMTokenIn) external nonReentrant {\n        if (pendingRedemptions[msg.sender].isActive) {\n            revert(\"MidasRedemptionVaultGateway: user has a pending redemption\");\n        }\n\n        uint256 requestId = IMidasRedemptionVault(midasRedemptionVault).currentRequestId();\n\n        IERC20(mToken).safeTransferFrom(msg.sender, address(this), amountMTokenIn);\n\n        IERC20(mToken).forceApprove(midasRedemptionVault, amountMTokenIn);\n        IMidasRedemptionVault(midasRedemptionVault).redeemRequest(tokenOut, amountMTokenIn);\n\n        pendingRedemptions[msg.sender] =\n            PendingRedemption({isActive: true, requestId: requestId, timestamp: block.timestamp, remainder: 0});\n    }\n\n\n    function withdraw(uint256 amount) external nonReentrant {\n        PendingRedemption memory pending = pendingRedemptions[msg.sender];\n\n        if (!pending.isActive) {\n            revert(\"MidasRedemptionVaultGateway: user does not have a pending redemption\");\n        }\n\n        (\n            address sender,\n            address tokenOut,\n            uint8 status,\n            uint256 amountMTokenIn,\n            uint256 mTokenRate,\n            uint256 tokenOutRate\n        ) = IMidasRedemptionVault(midasRedemptionVault).redeemRequests(pending.requestId);\n\n        if (sender != address(this)) {\n            revert(\"MidasRedemptionVaultGateway: invalid request\");\n        }\n\n        if (status != 1) {\n            revert(\"MidasRedemptionVaultGateway: redemption not fulfilled\");\n        }\n\n        uint256 availableAmount;\n\n        if (pending.remainder > 0) {\n            availableAmount = pending.remainder;\n        } else {\n            availableAmount = _calculateTokenOutAmount(amountMTokenIn, mTokenRate, tokenOutRate, tokenOut);\n        }\n\n        if (amount > availableAmount) {\n            revert(\"MidasRedemptionVaultGateway: amount exceeds available\");\n        }\n\n        if (amount == availableAmount) {\n            delete pendingRedemptions[msg.sender];\n        } else {\n            pendingRedemptions[msg.sender].remainder = availableAmount - amount;\n        }\n\n        IERC20(tokenOut).safeTransfer(msg.sender, amount);\n    }\n\n\n    function pendingTokenOutAmount(address user, address tokenOut) external view returns (uint256) {\n        PendingRedemption memory pending = pendingRedemptions[user];\n\n        if (!pending.isActive) {\n            return 0;\n        }\n\n        (address sender, address requestTokenOut,, uint256 amountMTokenIn, uint256 mTokenRate, uint256 tokenOutRate) =\n            IMidasRedemptionVault(midasRedemptionVault).redeemRequests(pending.requestId);\n\n        if (sender != address(this) || requestTokenOut != tokenOut) {\n            return 0;\n        }\n\n        if (pending.remainder > 0) {\n            return pending.remainder;\n        } else {\n            return _calculateTokenOutAmount(amountMTokenIn, mTokenRate, tokenOutRate, tokenOut);\n        }\n    }\n\n\n    function _calculateTokenOutAmount(\n        uint256 amountMTokenIn,\n        uint256 mTokenRate,\n        uint256 tokenOutRate,\n        address tokenOut\n    ) internal view returns (uint256) {\n        uint256 amount1e18 = (amountMTokenIn * mTokenRate) / tokenOutRate;\n\n        uint256 tokenUnit = 10 ** IERC20Metadata(tokenOut).decimals();\n\n        return amount1e18 * tokenUnit / 1e18;\n    }\n\n    // Unified dispatcher - merged from: requestRedeem, redeemInstant, withdraw\n    // Selectors: requestRedeem=0, redeemInstant=1, withdraw=2\n    function execute(uint8 _selector, address tokenOut, uint256 amount, uint256 amountMTokenIn, uint256 minReceiveAmount) public {\n        // Original: requestRedeem()\n        if (_selector == 0) {\n            if (pendingRedemptions[msg.sender].isActive) {\n            revert(\"MidasRedemptionVaultGateway: user has a pending redemption\");\n            }\n            uint256 requestId = IMidasRedemptionVault(midasRedemptionVault).currentRequestId();\n            IERC20(mToken).safeTransferFrom(msg.sender, address(this), amountMTokenIn);\n            IERC20(mToken).forceApprove(midasRedemptionVault, amountMTokenIn);\n            IMidasRedemptionVault(midasRedemptionVault).redeemRequest(tokenOut, amountMTokenIn);\n            pendingRedemptions[msg.sender] =\n            PendingRedemption({isActive: true, requestId: requestId, timestamp: block.timestamp, remainder: 0});\n        }\n        // Original: redeemInstant()\n        else if (_selector == 1) {\n            IERC20(mToken).safeTransferFrom(msg.sender, address(this), amountMTokenIn);\n            uint256 balanceBefore = IERC20(tokenOut).balanceOf(address(this));\n            IERC20(mToken).forceApprove(midasRedemptionVault, amountMTokenIn);\n            IMidasRedemptionVault(midasRedemptionVault).redeemInstant(tokenOut, amountMTokenIn, minReceiveAmount);\n            uint256 amount = IERC20(tokenOut).balanceOf(address(this)) - balanceBefore;\n            IERC20(tokenOut).safeTransfer(msg.sender, amount);\n        }\n        // Original: withdraw()\n        else if (_selector == 2) {\n            PendingRedemption memory pending = pendingRedemptions[msg.sender];\n            if (!pending.isActive) {\n            revert(\"MidasRedemptionVaultGateway: user does not have a pending redemption\");\n            }\n            (\n            address sender,\n            address tokenOut,\n            uint8 status,\n            uint256 amountMTokenIn,\n            uint256 mTokenRate,\n            uint256 tokenOutRate\n            ) = IMidasRedemptionVault(midasRedemptionVault).redeemRequests(pending.requestId);\n            if (sender != address(this)) {\n            revert(\"MidasRedemptionVaultGateway: invalid request\");\n            }\n            if (status != 1) {\n            revert(\"MidasRedemptionVaultGateway: redemption not fulfilled\");\n            }\n            uint256 availableAmount;\n            if (pending.remainder > 0) {\n            availableAmount = pending.remainder;\n            } else {\n            availableAmount = _calculateTokenOutAmount(amountMTokenIn, mTokenRate, tokenOutRate, tokenOut);\n            }\n            if (amount > availableAmount) {\n            revert(\"MidasRedemptionVaultGateway: amount exceeds available\");\n            }\n            if (amount == availableAmount) {\n            delete pendingRedemptions[msg.sender];\n            } else {\n            pendingRedemptions[msg.sender].remainder = availableAmount - amount;\n            }\n            IERC20(tokenOut).safeTransfer(msg.sender, amount);\n        }\n    }\n}",
      "merged_functions": [
        "requestRedeem",
        "redeemInstant",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: requestRedeem, redeemInstant, withdraw"
      ],
      "function_to_selector": {
        "requestRedeem": 0,
        "redeemInstant": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_020",
      "transformed_id": "rs_mg_dis_nc_gs_020",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\nimport {NotImplementedException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultAdapter} from \"../../interfaces/midas/IMidasRedemptionVaultAdapter.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\nimport {WAD, RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\n\n\ncontract MidasRedemptionVaultAdapter is AbstractAdapter, IMidasRedemptionVaultAdapter {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 public constant override contractType = \"ADAPTER::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override version = 3_10;\n\n\n    address public immutable override mToken;\n\n\n    address public immutable override gateway;\n\n\n    mapping(address => address) public phantomTokenToOutputToken;\n\n\n    mapping(address => address) public outputTokenToPhantomToken;\n\n\n    EnumerableSet.AddressSet internal _allowedTokens;\n\n\n    constructor(address _creditManager, address _gateway) AbstractAdapter(_creditManager, _gateway) {\n        gateway = _gateway;\n        mToken = IMidasRedemptionVaultGateway(_gateway).mToken();\n\n        _getMaskOrRevert(mToken);\n    }\n\n\n    function redeemInstant(address tokenOut, uint256 amountMTokenIn, uint256 minReceiveAmount)\n        external\n        override\n        creditFacadeOnly\n        returns (bool)\n    {\n        if (!isTokenAllowed(tokenOut)) revert TokenNotAllowedException();\n\n        _redeemInstant(tokenOut, amountMTokenIn, minReceiveAmount);\n\n        return false;\n    }\n\n\n    function redeemInstantDiff(address tokenOut, uint256 leftoverAmount, uint256 rateMinRAY)\n        external\n        override\n        creditFacadeOnly\n        returns (bool)\n    {\n        if (!isTokenAllowed(tokenOut)) revert TokenNotAllowedException();\n\n        address creditAccount = _creditAccount();\n\n        uint256 balance = IERC20(mToken).balanceOf(creditAccount);\n        if (balance > leftoverAmount) {\n            unchecked {\n                uint256 amount = balance - leftoverAmount;\n                uint256 minReceiveAmount = (amount * rateMinRAY) / RAY;\n                _redeemInstant(tokenOut, amount, minReceiveAmount);\n            }\n        }\n        return false;\n    }\n\n\n    function _redeemInstant(address tokenOut, uint256 amountMTokenIn, uint256 minReceiveAmount) internal {\n        _executeSwapSafeApprove(\n            mToken,\n            abi.encodeCall(\n                IMidasRedemptionVaultGateway.redeemInstant,\n                (tokenOut, amountMTokenIn, _convertToE18(minReceiveAmount, tokenOut))\n            )\n        );\n    }\n\n\n    function redeemRequest(address tokenOut, uint256 amountMTokenIn)\n        external\n        override\n        creditFacadeOnly\n        returns (bool)\n    {\n        if (!isTokenAllowed(tokenOut) || outputTokenToPhantomToken[tokenOut] == address(0)) {\n            revert TokenNotAllowedException();\n        }\n\n        _executeSwapSafeApprove(\n            mToken, abi.encodeCall(IMidasRedemptionVaultGateway.requestRedeem, (tokenOut, amountMTokenIn))\n        );\n        return true;\n    }\n\n\n    function withdraw(uint256 amount) external override creditFacadeOnly returns (bool) {\n        _withdraw(amount);\n        return false;\n    }\n\n\n    function _withdraw(uint256 amount) internal {\n        _execute(abi.encodeCall(IMidasRedemptionVaultGateway.withdraw, (amount)));\n    }\n\n\n    function withdrawPhantomToken(address token, uint256 amount) external override creditFacadeOnly returns (bool) {\n        if (phantomTokenToOutputToken[token] == address(0)) revert IncorrectStakedPhantomTokenException();\n        _withdraw(amount);\n        return false;\n    }\n\n\n    function depositPhantomToken(address, uint256) external pure override returns (bool) {\n        revert NotImplementedException();\n    }\n\n\n    function _convertToE18(uint256 amount, address token) internal view returns (uint256) {\n        uint256 tokenUnit = 10 ** IERC20Metadata(token).decimals();\n        return amount * WAD / tokenUnit;\n    }\n\n\n    function isTokenAllowed(address token) public view override returns (bool) {\n        return _allowedTokens.contains(token);\n    }\n\n\n    function allowedTokens() public view override returns (address[] memory) {\n        return _allowedTokens.values();\n    }\n\n\n    function setTokenAllowedStatusBatch(MidasAllowedTokenStatus[] calldata configs)\n        external\n        override\n        configuratorOnly\n    {\n        uint256 len = configs.length;\n\n        for (uint256 i; i < len; ++i) {\n            MidasAllowedTokenStatus memory config = configs[i];\n\n            if (config.allowed) {\n                _getMaskOrRevert(config.token);\n                _allowedTokens.add(config.token);\n\n                if (config.phantomToken != address(0)) {\n                    _getMaskOrRevert(config.phantomToken);\n                    phantomTokenToOutputToken[config.phantomToken] = config.token;\n                    outputTokenToPhantomToken[config.token] = config.phantomToken;\n                }\n            } else {\n                _allowedTokens.remove(config.token);\n\n                address phantomToken = outputTokenToPhantomToken[config.token];\n\n                if (phantomToken != address(0)) {\n                    delete outputTokenToPhantomToken[config.token];\n                    delete phantomTokenToOutputToken[phantomToken];\n                }\n            }\n\n            emit SetTokenAllowedStatus(config.token, config.phantomToken, config.allowed);\n        }\n    }\n\n\n    function serialize() external view returns (bytes memory serializedData) {\n        serializedData = abi.encode(creditManager, targetContract, gateway, mToken, allowedTokens());\n    }\n\n    // Unified dispatcher - merged from: withdrawPhantomToken, redeemInstant, redeemInstantDiff\n    // Selectors: withdrawPhantomToken=0, redeemInstant=1, redeemInstantDiff=2\n    function execute(uint8 _selector, address token, address tokenOut, uint256 amount, uint256 amountMTokenIn, uint256 leftoverAmount, uint256 minReceiveAmount, uint256 rateMinRAY) public {\n        // Original: withdrawPhantomToken()\n        if (_selector == 0) {\n            if (phantomTokenToOutputToken[token] == address(0)) revert IncorrectStakedPhantomTokenException();\n            _withdraw(amount);\n            return false;\n        }\n        // Original: redeemInstant()\n        else if (_selector == 1) {\n            if (!isTokenAllowed(tokenOut)) revert TokenNotAllowedException();\n            _redeemInstant(tokenOut, amountMTokenIn, minReceiveAmount);\n            return false;\n        }\n        // Original: redeemInstantDiff()\n        else if (_selector == 2) {\n            if (!isTokenAllowed(tokenOut)) revert TokenNotAllowedException();\n            address creditAccount = _creditAccount();\n            uint256 balance = IERC20(mToken).balanceOf(creditAccount);\n            if (balance > leftoverAmount) {\n            unchecked {\n            uint256 amount = balance - leftoverAmount;\n            uint256 minReceiveAmount = (amount * rateMinRAY) / RAY;\n            _redeemInstant(tokenOut, amount, minReceiveAmount);\n            }\n            }\n            return false;\n        }\n    }\n}",
      "merged_functions": [
        "withdrawPhantomToken",
        "redeemInstant",
        "redeemInstantDiff"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: withdrawPhantomToken, redeemInstant, redeemInstantDiff"
      ],
      "function_to_selector": {
        "withdrawPhantomToken": 0,
        "redeemInstant": 1,
        "redeemInstantDiff": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_021",
      "transformed_id": "rs_mg_dis_nc_gs_021",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, toBalanceDelta} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n\n  error NotPoolManager();\n\n\n  IPoolManager public immutable poolManager;\n\n  constructor(\n    IPoolManager _poolManager,\n    address initialOwner,\n    address[] memory initialClaimableAccounts,\n    address initialQuoteSigner,\n    address initialEgRecipient\n  ) BaseKEMHook(initialOwner, initialClaimableAccounts, initialQuoteSigner, initialEgRecipient) {\n    poolManager = _poolManager;\n    Hooks.validateHookPermissions(IHooks(address(this)), getHookPermissions());\n  }\n\n\n  modifier onlyPoolManager() {\n    if (msg.sender != address(poolManager)) revert NotPoolManager();\n    _;\n  }\n\n\n  function claimEgTokens(address[] calldata tokens, uint256[] calldata amounts) public {\n    require(claimable[msg.sender], NonClaimableAccount(msg.sender));\n    require(tokens.length == amounts.length, MismatchedArrayLengths());\n\n    poolManager.unlock(abi.encode(tokens, amounts));\n  }\n\n  function unlockCallback(bytes calldata data) public onlyPoolManager returns (bytes memory) {\n    (address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      uint256 id = uint256(uint160(tokens[i]));\n      if (amounts[i] == 0) {\n        amounts[i] = poolManager.balanceOf(address(this), id);\n      }\n      if (amounts[i] > 0) {\n        poolManager.burn(address(this), id, amounts[i]);\n        poolManager.take(Currency.wrap(tokens[i]), egRecipient, amounts[i]);\n      }\n    }\n\n    emit ClaimEgTokens(egRecipient, tokens, amounts);\n  }\n\n  function getHookPermissions() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      beforeInitialize: false,\n      afterInitialize: false,\n      beforeAddLiquidity: false,\n      afterAddLiquidity: false,\n      beforeRemoveLiquidity: false,\n      afterRemoveLiquidity: false,\n      beforeSwap: true,\n      afterSwap: true,\n      beforeDonate: false,\n      afterDonate: false,\n      beforeSwapReturnDelta: false,\n      afterSwapReturnDelta: true,\n      afterAddLiquidityReturnDelta: false,\n      afterRemoveLiquidityReturnDelta: false\n    });\n  }\n\n  function beforeSwap(\n    address sender,\n    PoolKey calldata key,\n    IPoolManager.SwapParams calldata params,\n    bytes calldata hookData\n  ) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) {\n    require(params.amountSpecified < 0, ExactOutputDisabled());\n\n    (\n      int256 maxAmountIn,\n      int256 maxExchangeRate,\n      int256 exchangeRateDenom,\n      uint256 nonce,\n      uint256 expiryTime,\n      bytes memory signature\n    ) = HookDataDecoder.decodeAllHookData(hookData);\n\n    require(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp));\n    require(\n      -params.amountSpecified <= maxAmountIn,\n      ExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)\n    );\n\n    _useUnorderedNonce(nonce);\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        sender,\n        key,\n        params.zeroForOne,\n        maxAmountIn,\n        maxExchangeRate,\n        exchangeRateDenom,\n        nonce,\n        expiryTime\n      )\n    );\n    require(\n      SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()\n    );\n\n    return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function afterSwap(\n    address,\n    PoolKey calldata key,\n    IPoolManager.SwapParams calldata params,\n    BalanceDelta delta,\n    bytes calldata hookData\n  ) external onlyPoolManager returns (bytes4, int128) {\n    (int256 maxExchangeRate, int256 exchangeRateDenom) =\n      HookDataDecoder.decodeExchangeRate(hookData);\n\n    int128 amountIn;\n    int128 amountOut;\n    Currency currencyOut;\n    unchecked {\n      if (params.zeroForOne) {\n        amountIn = -delta.amount0();\n        amountOut = delta.amount1();\n        currencyOut = key.currency1;\n      } else {\n        amountIn = -delta.amount1();\n        amountOut = delta.amount0();\n        currencyOut = key.currency0;\n      }\n    }\n\n    int256 maxAmountOut = amountIn * maxExchangeRate / exchangeRateDenom;\n\n    unchecked {\n      int256 egAmount = maxAmountOut < amountOut ? amountOut - maxAmountOut : int256(0);\n      if (egAmount > 0) {\n        poolManager.mint(\n          address(this), uint256(uint160(Currency.unwrap(currencyOut))), uint256(egAmount)\n        );\n\n        emit AbsorbEgToken(PoolId.unwrap(key.toId()), Currency.unwrap(currencyOut), egAmount);\n      }\n\n      return (this.afterSwap.selector, int128(egAmount));\n    }\n  }\n\n    // Unified dispatcher - merged from: beforeSwap, claimEgTokens, unlockCallback\n    // Selectors: beforeSwap=0, claimEgTokens=1, unlockCallback=2\n    function execute(uint8 _selector, IPoolManager.SwapParams params, PoolKey key, address sender, address[] tokens, bytes data, bytes hookData, uint256[] amounts) public {\n        // Original: beforeSwap()\n        if (_selector == 0) {\n            require(params.amountSpecified < 0, ExactOutputDisabled());\n            (\n            int256 maxAmountIn,\n            int256 maxExchangeRate,\n            int256 exchangeRateDenom,\n            uint256 nonce,\n            uint256 expiryTime,\n            bytes memory signature\n            ) = HookDataDecoder.decodeAllHookData(hookData);\n            require(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp));\n            require(\n            -params.amountSpecified <= maxAmountIn,\n            ExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)\n            );\n            _useUnorderedNonce(nonce);\n            bytes32 digest = keccak256(\n            abi.encode(\n            sender,\n            key,\n            params.zeroForOne,\n            maxAmountIn,\n            maxExchangeRate,\n            exchangeRateDenom,\n            nonce,\n            expiryTime\n            )\n            );\n            require(\n            SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()\n            );\n            return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n        }\n        // Original: claimEgTokens()\n        else if (_selector == 1) {\n            require(claimable[msg.sender], NonClaimableAccount(msg.sender));\n            require(tokens.length == amounts.length, MismatchedArrayLengths());\n            poolManager.unlock(abi.encode(tokens, amounts));\n        }\n        // Original: unlockCallback()\n        else if (_selector == 2) {\n            (address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[]));\n            for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 id = uint256(uint160(tokens[i]));\n            if (amounts[i] == 0) {\n            amounts[i] = poolManager.balanceOf(address(this), id);\n            }\n            if (amounts[i] > 0) {\n            poolManager.burn(address(this), id, amounts[i]);\n            poolManager.take(Currency.wrap(tokens[i]), egRecipient, amounts[i]);\n            }\n            }\n            emit ClaimEgTokens(egRecipient, tokens, amounts);\n        }\n    }\n}",
      "merged_functions": [
        "beforeSwap",
        "claimEgTokens",
        "unlockCallback"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: beforeSwap, claimEgTokens, unlockCallback"
      ],
      "function_to_selector": {
        "beforeSwap": 0,
        "claimEgTokens": 1,
        "unlockCallback": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_022",
      "transformed_id": "rs_mg_dis_nc_gs_022",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, toBalanceDelta} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n\n  error NotPoolManager();\n\n\n  IPoolManager public immutable poolManager;\n\n  constructor(\n    IPoolManager _poolManager,\n    address initialOwner,\n    address[] memory initialClaimableAccounts,\n    address initialQuoteSigner,\n    address initialEgRecipient\n  ) BaseKEMHook(initialOwner, initialClaimableAccounts, initialQuoteSigner, initialEgRecipient) {\n    poolManager = _poolManager;\n    Hooks.validateHookPermissions(IHooks(address(this)), getHookPermissions());\n  }\n\n\n  modifier onlyPoolManager() {\n    if (msg.sender != address(poolManager)) revert NotPoolManager();\n    _;\n  }\n\n\n  function claimEgTokens(address[] calldata tokens, uint256[] calldata amounts) public {\n    require(claimable[msg.sender], NonClaimableAccount(msg.sender));\n    require(tokens.length == amounts.length, MismatchedArrayLengths());\n\n    poolManager.unlock(abi.encode(tokens, amounts));\n  }\n\n  function unlockCallback(bytes calldata data) public onlyPoolManager returns (bytes memory) {\n    (address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < tokens.length; i++) {\n      uint256 id = uint256(uint160(tokens[i]));\n      if (amounts[i] == 0) {\n        amounts[i] = poolManager.balanceOf(address(this), id);\n      }\n      if (amounts[i] > 0) {\n        poolManager.burn(address(this), id, amounts[i]);\n        poolManager.take(Currency.wrap(tokens[i]), egRecipient, amounts[i]);\n      }\n    }\n\n    emit ClaimEgTokens(egRecipient, tokens, amounts);\n  }\n\n  function getHookPermissions() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      beforeInitialize: false,\n      afterInitialize: false,\n      beforeAddLiquidity: false,\n      afterAddLiquidity: false,\n      beforeRemoveLiquidity: false,\n      afterRemoveLiquidity: false,\n      beforeSwap: true,\n      afterSwap: true,\n      beforeDonate: false,\n      afterDonate: false,\n      beforeSwapReturnDelta: false,\n      afterSwapReturnDelta: true,\n      afterAddLiquidityReturnDelta: false,\n      afterRemoveLiquidityReturnDelta: false\n    });\n  }\n\n  function beforeSwap(\n    address sender,\n    PoolKey calldata key,\n    IPoolManager.SwapParams calldata params,\n    bytes calldata hookData\n  ) external onlyPoolManager returns (bytes4, BeforeSwapDelta, uint24) {\n    require(params.amountSpecified < 0, ExactOutputDisabled());\n\n    (\n      int256 maxAmountIn,\n      int256 maxExchangeRate,\n      int256 exchangeRateDenom,\n      uint256 nonce,\n      uint256 expiryTime,\n      bytes memory signature\n    ) = HookDataDecoder.decodeAllHookData(hookData);\n\n    require(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp));\n    require(\n      -params.amountSpecified <= maxAmountIn,\n      ExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)\n    );\n\n    _useUnorderedNonce(nonce);\n\n    bytes32 digest = keccak256(\n      abi.encode(\n        sender,\n        key,\n        params.zeroForOne,\n        maxAmountIn,\n        maxExchangeRate,\n        exchangeRateDenom,\n        nonce,\n        expiryTime\n      )\n    );\n    require(\n      SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()\n    );\n\n    return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function afterSwap(\n    address,\n    PoolKey calldata key,\n    IPoolManager.SwapParams calldata params,\n    BalanceDelta delta,\n    bytes calldata hookData\n  ) external onlyPoolManager returns (bytes4, int128) {\n    (int256 maxExchangeRate, int256 exchangeRateDenom) =\n      HookDataDecoder.decodeExchangeRate(hookData);\n\n    int128 amountIn;\n    int128 amountOut;\n    Currency currencyOut;\n    unchecked {\n      if (params.zeroForOne) {\n        amountIn = -delta.amount0();\n        amountOut = delta.amount1();\n        currencyOut = key.currency1;\n      } else {\n        amountIn = -delta.amount1();\n        amountOut = delta.amount0();\n        currencyOut = key.currency0;\n      }\n    }\n\n    int256 maxAmountOut = amountIn * maxExchangeRate / exchangeRateDenom;\n\n    unchecked {\n      int256 egAmount = maxAmountOut < amountOut ? amountOut - maxAmountOut : int256(0);\n      if (egAmount > 0) {\n        poolManager.mint(\n          address(this), uint256(uint160(Currency.unwrap(currencyOut))), uint256(egAmount)\n        );\n\n        emit AbsorbEgToken(PoolId.unwrap(key.toId()), Currency.unwrap(currencyOut), egAmount);\n      }\n\n      return (this.afterSwap.selector, int128(egAmount));\n    }\n  }\n\n    // Unified dispatcher - merged from: beforeSwap, claimEgTokens, unlockCallback\n    // Selectors: beforeSwap=0, claimEgTokens=1, unlockCallback=2\n    function execute(uint8 _selector, IPoolManager.SwapParams params, PoolKey key, address sender, address[] tokens, bytes data, bytes hookData, uint256[] amounts) public {\n        // Original: beforeSwap()\n        if (_selector == 0) {\n            require(params.amountSpecified < 0, ExactOutputDisabled());\n            (\n            int256 maxAmountIn,\n            int256 maxExchangeRate,\n            int256 exchangeRateDenom,\n            uint256 nonce,\n            uint256 expiryTime,\n            bytes memory signature\n            ) = HookDataDecoder.decodeAllHookData(hookData);\n            require(block.timestamp <= expiryTime, ExpiredSignature(expiryTime, block.timestamp));\n            require(\n            -params.amountSpecified <= maxAmountIn,\n            ExceededMaxAmountIn(maxAmountIn, -params.amountSpecified)\n            );\n            _useUnorderedNonce(nonce);\n            bytes32 digest = keccak256(\n            abi.encode(\n            sender,\n            key,\n            params.zeroForOne,\n            maxAmountIn,\n            maxExchangeRate,\n            exchangeRateDenom,\n            nonce,\n            expiryTime\n            )\n            );\n            require(\n            SignatureChecker.isValidSignatureNow(quoteSigner, digest, signature), InvalidSignature()\n            );\n            return (this.beforeSwap.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n        }\n        // Original: claimEgTokens()\n        else if (_selector == 1) {\n            require(claimable[msg.sender], NonClaimableAccount(msg.sender));\n            require(tokens.length == amounts.length, MismatchedArrayLengths());\n            poolManager.unlock(abi.encode(tokens, amounts));\n        }\n        // Original: unlockCallback()\n        else if (_selector == 2) {\n            (address[] memory tokens, uint256[] memory amounts) = abi.decode(data, (address[], uint256[]));\n            for (uint256 i = 0; i < tokens.length; i++) {\n            uint256 id = uint256(uint160(tokens[i]));\n            if (amounts[i] == 0) {\n            amounts[i] = poolManager.balanceOf(address(this), id);\n            }\n            if (amounts[i] > 0) {\n            poolManager.burn(address(this), id, amounts[i]);\n            poolManager.take(Currency.wrap(tokens[i]), egRecipient, amounts[i]);\n            }\n            }\n            emit ClaimEgTokens(egRecipient, tokens, amounts);\n        }\n    }\n}",
      "merged_functions": [
        "beforeSwap",
        "claimEgTokens",
        "unlockCallback"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: beforeSwap, claimEgTokens, unlockCallback"
      ],
      "function_to_selector": {
        "beforeSwap": 0,
        "claimEgTokens": 1,
        "unlockCallback": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_023",
      "transformed_id": "rs_mg_dis_nc_gs_023",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed managerId, uint256 amount);\n    event ETHReturnedToStaking(uint256 amount);\n    event ETHAllocatedToManager(uint256 indexed managerId, uint256 amount);\n    event ETHReceivedFromStaking(uint256 amount);\n    event FeesCollected(uint256 amount);\n    event InterestClaimed(\n        uint256 indexed managerId,\n        uint256 interestAmount\n    );\n    event InterestToppedUp(\n        uint256 amount\n    );\n}\n\n\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = keccak256(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = keccak256(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = keccak256(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = keccak256(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\n\n\n    IStakingReturnsWrite public stakingContract;\n\n\n    IPauserRead public pauser;\n\n\n    uint256 public positionManagerCount;\n\n\n    mapping(uint256 => PositionManagerConfig) public positionManagerConfigs;\n\n\n    mapping(uint256 => PositionAccountant) public positionAccountants;\n\n\n    uint256 public totalFundsReceived;\n\n\n    uint256 public totalFundsReturned;\n\n\n    uint256 public totalAllocatedBalance;\n\n\n    uint256 public totalInterestClaimed;\n\n\n    uint256 public totalInterestToppedUp;\n\n\n    uint256 public totalAllocationCapacity;\n\n\n    uint256 public cumulativeDrawdown;\n\n\n    uint256 public defaultManagerId;\n\n\n    address payable public feesReceiver;\n\n\n    uint16 public feesBasisPoints;\n\n    uint256 public totalFeesCollected;\n\n\n    uint256 public pendingInterest;\n\n\n    uint256 public pendingPrincipal;\n\n\n    bool public shouldExecuteAllocation;\n\n    mapping(address => bool) public isRegisteredManager;\n\n    struct Init {\n        address admin;\n        address liquidityManager;\n        address positionManager;\n        address interestTopUp;\n        address drawdownManager;\n        address payable feesReceiver;\n        IStakingReturnsWrite staking;\n        IPauserRead pauser;\n    }\n\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(LIQUIDITY_MANAGER_ROLE, init.liquidityManager);\n        _grantRole(POSITION_MANAGER_ROLE, init.positionManager);\n        _grantRole(INTEREST_TOPUP_ROLE, init.interestTopUp);\n        _grantRole(DRAWDOWN_MANAGER_ROLE, init.drawdownManager);\n\n        stakingContract = init.staking;\n        pauser = init.pauser;\n        feesReceiver = init.feesReceiver;\n        shouldExecuteAllocation = true;\n\n        _grantRole(LIQUIDITY_MANAGER_ROLE, address(stakingContract));\n    }\n\n\n    function getInterestAmount(uint256 managerId) public view returns (uint256) {\n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        uint256 currentBalance = manager.getUnderlyingBalance();\n\n\n        PositionAccountant memory accounting = positionAccountants[managerId];\n\n        if (currentBalance > accounting.allocatedBalance) {\n            return currentBalance - accounting.allocatedBalance;\n        }\n\n        return 0;\n    }\n\n    function getAvailableCapacity() public view returns (uint256) {\n        return totalAllocationCapacity - totalAllocatedBalance;\n    }\n\n    function getAvailableBalance() public view returns (uint256) {\n        return totalFundsReceived - totalFundsReturned;\n    }\n\n    function getControlledBalance() public view returns (uint256) {\n        uint256 totalBalance = address(this).balance;\n\n\n        for (uint256 i = 0; i < positionManagerCount; i++) {\n            PositionManagerConfig storage config = positionManagerConfigs[i];\n            if (config.isActive) {\n                IPositionManager manager = IPositionManager(config.managerAddress);\n                uint256 managerBalance = manager.getUnderlyingBalance();\n                totalBalance += managerBalance;\n            }\n        }\n\n        return totalBalance;\n    }\n\n\n    function addPositionManager(\n        address managerAddress,\n        uint256 allocationCap\n    ) external onlyRole(POSITION_MANAGER_ROLE) returns (uint256 managerId) {\n        if (isRegisteredManager[managerAddress]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        managerId = positionManagerCount;\n        positionManagerCount++;\n\n        positionManagerConfigs[managerId] = PositionManagerConfig({\n            managerAddress: managerAddress,\n            allocationCap: allocationCap,\n            isActive: true\n        });\n        positionAccountants[managerId] = PositionAccountant({\n            allocatedBalance: 0,\n            interestClaimedFromManager: 0\n        });\n        isRegisteredManager[managerAddress] = true;\n\n        totalAllocationCapacity += allocationCap;\n        emit ProtocolConfigChanged(\n            this.addPositionManager.selector,\n            \"addPositionManager(address,uint256)\",\n            abi.encode(managerAddress, allocationCap)\n        );\n    }\n\n    function updatePositionManager(\n        uint256 managerId,\n        uint256 newAllocationCap,\n        bool isActive\n    ) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (managerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage config = positionManagerConfigs[managerId];\n\n        if (newAllocationCap < positionAccountants[managerId].allocatedBalance) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n\n        totalAllocationCapacity = totalAllocationCapacity - config.allocationCap + newAllocationCap;\n\n        config.allocationCap = newAllocationCap;\n        config.isActive = isActive;\n\n        emit ProtocolConfigChanged(\n            this.updatePositionManager.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi.encode(managerId, newAllocationCap, isActive)\n        );\n    }\n\n    function togglePositionManagerStatus(uint256 managerId) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (managerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage config = positionManagerConfigs[managerId];\n        config.isActive = !config.isActive;\n\n        emit ProtocolConfigChanged(\n            this.togglePositionManagerStatus.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi.encode(managerId)\n        );\n    }\n\n    function setCumulativeDrawdown(uint256 drawdownAmount) external onlyRole(DRAWDOWN_MANAGER_ROLE) {\n        cumulativeDrawdown = drawdownAmount;\n\n        emit ProtocolConfigChanged(\n            this.setCumulativeDrawdown.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi.encode(drawdownAmount)\n        );\n    }\n\n    function setDefaultManagerId(uint256 newDefaultManagerId) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (newDefaultManagerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!positionManagerConfigs[newDefaultManagerId].isActive) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        defaultManagerId = newDefaultManagerId;\n\n        emit ProtocolConfigChanged(\n            this.setDefaultManagerId.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi.encode(newDefaultManagerId)\n        );\n    }\n\n\n    function setFeeBasisPoints(uint16 newBasisPoints) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (newBasisPoints > _BASIS_POINTS_DENOMINATOR) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        feesBasisPoints = newBasisPoints;\n        emit ProtocolConfigChanged(\n            this.setFeeBasisPoints.selector, \"setFeeBasisPoints(uint16)\", abi.encode(newBasisPoints)\n        );\n    }\n\n\n    function setFeesReceiver(address payable newReceiver)\n        external\n        onlyRole(POSITION_MANAGER_ROLE)\n        notZeroAddress(newReceiver)\n    {\n        feesReceiver = newReceiver;\n        emit ProtocolConfigChanged(this.setFeesReceiver.selector, \"setFeesReceiver(address)\", abi.encode(newReceiver));\n    }\n\n\n    function setShouldExecuteAllocation(bool executeAllocation) external onlyRole(POSITION_MANAGER_ROLE) {\n        shouldExecuteAllocation = executeAllocation;\n        emit ProtocolConfigChanged(this.setShouldExecuteAllocation.selector, \"setShouldExecuteAllocation(bool)\", abi.encode(executeAllocation));\n    }\n\n\n    function depositETH() external payable onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        if (pauser.isLiquidityBufferPaused()) revert LiquidityBuffer__Paused();\n        _receiveETHFromStaking(msg.value);\n        if (shouldExecuteAllocation) {\n            _allocateETHToManager(defaultManagerId, msg.value);\n        }\n    }\n\n    function withdrawAndReturn(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _withdrawETHFromManager(managerId, amount);\n        _returnETHToStaking(amount);\n    }\n\n    function allocateETHToManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _allocateETHToManager(managerId, amount);\n    }\n\n    function withdrawETHFromManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _withdrawETHFromManager(managerId, amount);\n    }\n\n    function returnETHToStaking(uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _returnETHToStaking(amount);\n    }\n\n    function receiveETHFromPositionManager() external payable onlyPositionManagerContract {\n\n\n    }\n\n\n    function claimInterestFromManager(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 amount = _claimInterestFromManager(managerId);\n        if (amount < minAmount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return amount;\n    }\n\n    function topUpInterestToStaking(uint256 amount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < amount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _topUpInterestToStakingAndCollectFees(amount);\n        return amount;\n    }\n\n    function claimInterestAndTopUp(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 amount = _claimInterestFromManager(managerId);\n        if (amount < minAmount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _topUpInterestToStakingAndCollectFees(amount);\n\n        return amount;\n    }\n\n\n    function _topUpInterestToStakingAndCollectFees(uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (amount > pendingInterest) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        pendingInterest -= amount;\n        uint256 fees = Math.mulDiv(feesBasisPoints, amount, _BASIS_POINTS_DENOMINATOR);\n        uint256 topUpAmount = amount - fees;\n        stakingContract.topUp{value: topUpAmount}();\n        totalInterestToppedUp += topUpAmount;\n        emit InterestToppedUp(topUpAmount);\n\n        if (fees > 0) {\n            Address.sendValue(feesReceiver, fees);\n            totalFeesCollected += fees;\n            emit FeesCollected(fees);\n        }\n    }\n\n    function _claimInterestFromManager(uint256 managerId) internal returns (uint256) {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        uint256 interestAmount = getInterestAmount(managerId);\n\n        if (interestAmount > 0) {\n            PositionManagerConfig memory config = positionManagerConfigs[managerId];\n\n\n            positionAccountants[managerId].interestClaimedFromManager += interestAmount;\n            totalInterestClaimed += interestAmount;\n            pendingInterest += interestAmount;\n            emit InterestClaimed(managerId, interestAmount);\n\n\n            IPositionManager manager = IPositionManager(config.managerAddress);\n            manager.withdraw(interestAmount);\n        } else {\n            emit InterestClaimed(managerId, interestAmount);\n        }\n\n        return interestAmount;\n    }\n\n    function _withdrawETHFromManager(uint256 managerId, uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n        if (!config.isActive) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage accounting = positionAccountants[managerId];\n\n\n        if (amount > accounting.allocatedBalance) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n\n        accounting.allocatedBalance -= amount;\n        totalAllocatedBalance -= amount;\n        pendingPrincipal += amount;\n        emit ETHWithdrawnFromManager(managerId, amount);\n\n\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        manager.withdraw(amount);\n    }\n\n    function _returnETHToStaking(uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n\n        if (address(stakingContract) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (amount > pendingPrincipal) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n\n        totalFundsReturned += amount;\n        pendingPrincipal -= amount;\n        emit ETHReturnedToStaking(amount);\n\n\n        stakingContract.receiveReturnsFromLiquidityBuffer{value: amount}();\n    }\n\n    function _allocateETHToManager(uint256 managerId, uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (amount > pendingPrincipal) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\n\n        if (address(this).balance < amount) revert LiquidityBuffer__InsufficientBalance();\n\n\n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n        if (!config.isActive) revert LiquidityBuffer__ManagerInactive();\n\n        PositionAccountant storage accounting = positionAccountants[managerId];\n        if (accounting.allocatedBalance + amount > config.allocationCap) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n\n        accounting.allocatedBalance += amount;\n        totalAllocatedBalance += amount;\n        pendingPrincipal -= amount;\n        emit ETHAllocatedToManager(managerId, amount);\n\n\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        manager.deposit{value: amount}(0);\n    }\n\n    function _receiveETHFromStaking(uint256 amount) internal {\n        totalFundsReceived += amount;\n        pendingPrincipal += amount;\n        emit ETHReceivedFromStaking(amount);\n    }\n\n\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n\n    modifier onlyStakingContract() {\n        if (msg.sender != address(stakingContract)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier onlyPositionManagerContract() {\n        bool isValidManager = false;\n\n\n        for (uint256 i = 0; i < positionManagerCount; i++) {\n            PositionManagerConfig memory config = positionManagerConfigs[i];\n\n            if (msg.sender == config.managerAddress && config.isActive) {\n                isValidManager = true;\n                break;\n            }\n        }\n\n        if (!isValidManager) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    // Unified dispatcher - merged from: updatePositionManager, initialize, addPositionManager\n    // Selectors: updatePositionManager=0, initialize=1, addPositionManager=2\n    function execute(uint8 _selector, Init init, address managerAddress, bool isActive, uint256 allocationCap, uint256 managerId, uint256 newAllocationCap) public {\n        // Original: updatePositionManager()\n        if (_selector == 0) {\n            if (managerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n            }\n            PositionManagerConfig storage config = positionManagerConfigs[managerId];\n            if (newAllocationCap < positionAccountants[managerId].allocatedBalance) {\n            revert LiquidityBuffer__InvalidConfiguration();\n            }\n            totalAllocationCapacity = totalAllocationCapacity - config.allocationCap + newAllocationCap;\n            config.allocationCap = newAllocationCap;\n            config.isActive = isActive;\n            emit ProtocolConfigChanged(\n            this.updatePositionManager.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi.encode(managerId, newAllocationCap, isActive)\n            );\n        }\n        // Original: initialize()\n        else if (_selector == 1) {\n            __AccessControlEnumerable_init();\n            _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n            _grantRole(LIQUIDITY_MANAGER_ROLE, init.liquidityManager);\n            _grantRole(POSITION_MANAGER_ROLE, init.positionManager);\n            _grantRole(INTEREST_TOPUP_ROLE, init.interestTopUp);\n            _grantRole(DRAWDOWN_MANAGER_ROLE, init.drawdownManager);\n            stakingContract = init.staking;\n            pauser = init.pauser;\n            feesReceiver = init.feesReceiver;\n            shouldExecuteAllocation = true;\n            _grantRole(LIQUIDITY_MANAGER_ROLE, address(stakingContract));\n        }\n        // Original: addPositionManager()\n        else if (_selector == 2) {\n            if (isRegisteredManager[managerAddress]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n            managerId = positionManagerCount;\n            positionManagerCount++;\n            positionManagerConfigs[managerId] = PositionManagerConfig({\n            managerAddress: managerAddress,\n            allocationCap: allocationCap,\n            isActive: true\n            });\n            positionAccountants[managerId] = PositionAccountant({\n            allocatedBalance: 0,\n            interestClaimedFromManager: 0\n            });\n            isRegisteredManager[managerAddress] = true;\n            totalAllocationCapacity += allocationCap;\n            emit ProtocolConfigChanged(\n            this.addPositionManager.selector,\n            \"addPositionManager(address,uint256)\",\n            abi.encode(managerAddress, allocationCap)\n            );\n        }\n    }\n}",
      "merged_functions": [
        "updatePositionManager",
        "initialize",
        "addPositionManager"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: updatePositionManager, initialize, addPositionManager"
      ],
      "function_to_selector": {
        "updatePositionManager": 0,
        "initialize": 1,
        "addPositionManager": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_024",
      "transformed_id": "rs_mg_dis_nc_gs_024",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed managerId, uint256 amount);\n    event ETHReturnedToStaking(uint256 amount);\n    event ETHAllocatedToManager(uint256 indexed managerId, uint256 amount);\n    event ETHReceivedFromStaking(uint256 amount);\n    event FeesCollected(uint256 amount);\n    event InterestClaimed(\n        uint256 indexed managerId,\n        uint256 interestAmount\n    );\n    event InterestToppedUp(\n        uint256 amount\n    );\n}\n\n\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = keccak256(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = keccak256(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = keccak256(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = keccak256(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\n\n\n    IStakingReturnsWrite public stakingContract;\n\n\n    IPauserRead public pauser;\n\n\n    uint256 public positionManagerCount;\n\n\n    mapping(uint256 => PositionManagerConfig) public positionManagerConfigs;\n\n\n    mapping(uint256 => PositionAccountant) public positionAccountants;\n\n\n    uint256 public totalFundsReceived;\n\n\n    uint256 public totalFundsReturned;\n\n\n    uint256 public totalAllocatedBalance;\n\n\n    uint256 public totalInterestClaimed;\n\n\n    uint256 public totalInterestToppedUp;\n\n\n    uint256 public totalAllocationCapacity;\n\n\n    uint256 public cumulativeDrawdown;\n\n\n    uint256 public defaultManagerId;\n\n\n    address payable public feesReceiver;\n\n\n    uint16 public feesBasisPoints;\n\n    uint256 public totalFeesCollected;\n\n\n    uint256 public pendingInterest;\n\n\n    uint256 public pendingPrincipal;\n\n\n    bool public shouldExecuteAllocation;\n\n    mapping(address => bool) public isRegisteredManager;\n\n    struct Init {\n        address admin;\n        address liquidityManager;\n        address positionManager;\n        address interestTopUp;\n        address drawdownManager;\n        address payable feesReceiver;\n        IStakingReturnsWrite staking;\n        IPauserRead pauser;\n    }\n\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(LIQUIDITY_MANAGER_ROLE, init.liquidityManager);\n        _grantRole(POSITION_MANAGER_ROLE, init.positionManager);\n        _grantRole(INTEREST_TOPUP_ROLE, init.interestTopUp);\n        _grantRole(DRAWDOWN_MANAGER_ROLE, init.drawdownManager);\n\n        stakingContract = init.staking;\n        pauser = init.pauser;\n        feesReceiver = init.feesReceiver;\n        shouldExecuteAllocation = true;\n\n        _grantRole(LIQUIDITY_MANAGER_ROLE, address(stakingContract));\n    }\n\n\n    function getInterestAmount(uint256 managerId) public view returns (uint256) {\n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        uint256 currentBalance = manager.getUnderlyingBalance();\n\n\n        PositionAccountant memory accounting = positionAccountants[managerId];\n\n        if (currentBalance > accounting.allocatedBalance) {\n            return currentBalance - accounting.allocatedBalance;\n        }\n\n        return 0;\n    }\n\n    function getAvailableCapacity() public view returns (uint256) {\n        return totalAllocationCapacity - totalAllocatedBalance;\n    }\n\n    function getAvailableBalance() public view returns (uint256) {\n        return totalFundsReceived - totalFundsReturned;\n    }\n\n    function getControlledBalance() public view returns (uint256) {\n        uint256 totalBalance = address(this).balance;\n\n\n        for (uint256 i = 0; i < positionManagerCount; i++) {\n            PositionManagerConfig storage config = positionManagerConfigs[i];\n            if (config.isActive) {\n                IPositionManager manager = IPositionManager(config.managerAddress);\n                uint256 managerBalance = manager.getUnderlyingBalance();\n                totalBalance += managerBalance;\n            }\n        }\n\n        return totalBalance;\n    }\n\n\n    function addPositionManager(\n        address managerAddress,\n        uint256 allocationCap\n    ) external onlyRole(POSITION_MANAGER_ROLE) returns (uint256 managerId) {\n        if (isRegisteredManager[managerAddress]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        managerId = positionManagerCount;\n        positionManagerCount++;\n\n        positionManagerConfigs[managerId] = PositionManagerConfig({\n            managerAddress: managerAddress,\n            allocationCap: allocationCap,\n            isActive: true\n        });\n        positionAccountants[managerId] = PositionAccountant({\n            allocatedBalance: 0,\n            interestClaimedFromManager: 0\n        });\n        isRegisteredManager[managerAddress] = true;\n\n        totalAllocationCapacity += allocationCap;\n        emit ProtocolConfigChanged(\n            this.addPositionManager.selector,\n            \"addPositionManager(address,uint256)\",\n            abi.encode(managerAddress, allocationCap)\n        );\n    }\n\n    function updatePositionManager(\n        uint256 managerId,\n        uint256 newAllocationCap,\n        bool isActive\n    ) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (managerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage config = positionManagerConfigs[managerId];\n\n        if (newAllocationCap < positionAccountants[managerId].allocatedBalance) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n\n        totalAllocationCapacity = totalAllocationCapacity - config.allocationCap + newAllocationCap;\n\n        config.allocationCap = newAllocationCap;\n        config.isActive = isActive;\n\n        emit ProtocolConfigChanged(\n            this.updatePositionManager.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi.encode(managerId, newAllocationCap, isActive)\n        );\n    }\n\n    function togglePositionManagerStatus(uint256 managerId) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (managerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage config = positionManagerConfigs[managerId];\n        config.isActive = !config.isActive;\n\n        emit ProtocolConfigChanged(\n            this.togglePositionManagerStatus.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi.encode(managerId)\n        );\n    }\n\n    function setCumulativeDrawdown(uint256 drawdownAmount) external onlyRole(DRAWDOWN_MANAGER_ROLE) {\n        cumulativeDrawdown = drawdownAmount;\n\n        emit ProtocolConfigChanged(\n            this.setCumulativeDrawdown.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi.encode(drawdownAmount)\n        );\n    }\n\n    function setDefaultManagerId(uint256 newDefaultManagerId) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (newDefaultManagerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!positionManagerConfigs[newDefaultManagerId].isActive) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        defaultManagerId = newDefaultManagerId;\n\n        emit ProtocolConfigChanged(\n            this.setDefaultManagerId.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi.encode(newDefaultManagerId)\n        );\n    }\n\n\n    function setFeeBasisPoints(uint16 newBasisPoints) external onlyRole(POSITION_MANAGER_ROLE) {\n        if (newBasisPoints > _BASIS_POINTS_DENOMINATOR) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        feesBasisPoints = newBasisPoints;\n        emit ProtocolConfigChanged(\n            this.setFeeBasisPoints.selector, \"setFeeBasisPoints(uint16)\", abi.encode(newBasisPoints)\n        );\n    }\n\n\n    function setFeesReceiver(address payable newReceiver)\n        external\n        onlyRole(POSITION_MANAGER_ROLE)\n        notZeroAddress(newReceiver)\n    {\n        feesReceiver = newReceiver;\n        emit ProtocolConfigChanged(this.setFeesReceiver.selector, \"setFeesReceiver(address)\", abi.encode(newReceiver));\n    }\n\n\n    function setShouldExecuteAllocation(bool executeAllocation) external onlyRole(POSITION_MANAGER_ROLE) {\n        shouldExecuteAllocation = executeAllocation;\n        emit ProtocolConfigChanged(this.setShouldExecuteAllocation.selector, \"setShouldExecuteAllocation(bool)\", abi.encode(executeAllocation));\n    }\n\n\n    function depositETH() external payable onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        if (pauser.isLiquidityBufferPaused()) revert LiquidityBuffer__Paused();\n        _receiveETHFromStaking(msg.value);\n        if (shouldExecuteAllocation) {\n            _allocateETHToManager(defaultManagerId, msg.value);\n        }\n    }\n\n    function withdrawAndReturn(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _withdrawETHFromManager(managerId, amount);\n        _returnETHToStaking(amount);\n    }\n\n    function allocateETHToManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _allocateETHToManager(managerId, amount);\n    }\n\n    function withdrawETHFromManager(uint256 managerId, uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _withdrawETHFromManager(managerId, amount);\n    }\n\n    function returnETHToStaking(uint256 amount) external onlyRole(LIQUIDITY_MANAGER_ROLE) {\n        _returnETHToStaking(amount);\n    }\n\n    function receiveETHFromPositionManager() external payable onlyPositionManagerContract {\n\n\n    }\n\n\n    function claimInterestFromManager(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 amount = _claimInterestFromManager(managerId);\n        if (amount < minAmount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return amount;\n    }\n\n    function topUpInterestToStaking(uint256 amount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < amount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _topUpInterestToStakingAndCollectFees(amount);\n        return amount;\n    }\n\n    function claimInterestAndTopUp(uint256 managerId, uint256 minAmount) external onlyRole(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 amount = _claimInterestFromManager(managerId);\n        if (amount < minAmount) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _topUpInterestToStakingAndCollectFees(amount);\n\n        return amount;\n    }\n\n\n    function _topUpInterestToStakingAndCollectFees(uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (amount > pendingInterest) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        pendingInterest -= amount;\n        uint256 fees = Math.mulDiv(feesBasisPoints, amount, _BASIS_POINTS_DENOMINATOR);\n        uint256 topUpAmount = amount - fees;\n        stakingContract.topUp{value: topUpAmount}();\n        totalInterestToppedUp += topUpAmount;\n        emit InterestToppedUp(topUpAmount);\n\n        if (fees > 0) {\n            Address.sendValue(feesReceiver, fees);\n            totalFeesCollected += fees;\n            emit FeesCollected(fees);\n        }\n    }\n\n    function _claimInterestFromManager(uint256 managerId) internal returns (uint256) {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        uint256 interestAmount = getInterestAmount(managerId);\n\n        if (interestAmount > 0) {\n            PositionManagerConfig memory config = positionManagerConfigs[managerId];\n\n\n            positionAccountants[managerId].interestClaimedFromManager += interestAmount;\n            totalInterestClaimed += interestAmount;\n            pendingInterest += interestAmount;\n            emit InterestClaimed(managerId, interestAmount);\n\n\n            IPositionManager manager = IPositionManager(config.managerAddress);\n            manager.withdraw(interestAmount);\n        } else {\n            emit InterestClaimed(managerId, interestAmount);\n        }\n\n        return interestAmount;\n    }\n\n    function _withdrawETHFromManager(uint256 managerId, uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n        if (!config.isActive) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage accounting = positionAccountants[managerId];\n\n\n        if (amount > accounting.allocatedBalance) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n\n        accounting.allocatedBalance -= amount;\n        totalAllocatedBalance -= amount;\n        pendingPrincipal += amount;\n        emit ETHWithdrawnFromManager(managerId, amount);\n\n\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        manager.withdraw(amount);\n    }\n\n    function _returnETHToStaking(uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n\n        if (address(stakingContract) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (amount > pendingPrincipal) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n\n        totalFundsReturned += amount;\n        pendingPrincipal -= amount;\n        emit ETHReturnedToStaking(amount);\n\n\n        stakingContract.receiveReturnsFromLiquidityBuffer{value: amount}();\n    }\n\n    function _allocateETHToManager(uint256 managerId, uint256 amount) internal {\n        if (pauser.isLiquidityBufferPaused()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (amount > pendingPrincipal) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (managerId >= positionManagerCount) revert LiquidityBuffer__ManagerNotFound();\n\n        if (address(this).balance < amount) revert LiquidityBuffer__InsufficientBalance();\n\n\n        PositionManagerConfig memory config = positionManagerConfigs[managerId];\n        if (!config.isActive) revert LiquidityBuffer__ManagerInactive();\n\n        PositionAccountant storage accounting = positionAccountants[managerId];\n        if (accounting.allocatedBalance + amount > config.allocationCap) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n\n        accounting.allocatedBalance += amount;\n        totalAllocatedBalance += amount;\n        pendingPrincipal -= amount;\n        emit ETHAllocatedToManager(managerId, amount);\n\n\n        IPositionManager manager = IPositionManager(config.managerAddress);\n        manager.deposit{value: amount}(0);\n    }\n\n    function _receiveETHFromStaking(uint256 amount) internal {\n        totalFundsReceived += amount;\n        pendingPrincipal += amount;\n        emit ETHReceivedFromStaking(amount);\n    }\n\n\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n\n    modifier onlyStakingContract() {\n        if (msg.sender != address(stakingContract)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier onlyPositionManagerContract() {\n        bool isValidManager = false;\n\n\n        for (uint256 i = 0; i < positionManagerCount; i++) {\n            PositionManagerConfig memory config = positionManagerConfigs[i];\n\n            if (msg.sender == config.managerAddress && config.isActive) {\n                isValidManager = true;\n                break;\n            }\n        }\n\n        if (!isValidManager) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    // Unified dispatcher - merged from: initialize, addPositionManager, updatePositionManager\n    // Selectors: initialize=0, addPositionManager=1, updatePositionManager=2\n    function execute(uint8 _selector, Init init, address managerAddress, bool isActive, uint256 allocationCap, uint256 managerId, uint256 newAllocationCap) public {\n        // Original: initialize()\n        if (_selector == 0) {\n            __AccessControlEnumerable_init();\n            _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n            _grantRole(LIQUIDITY_MANAGER_ROLE, init.liquidityManager);\n            _grantRole(POSITION_MANAGER_ROLE, init.positionManager);\n            _grantRole(INTEREST_TOPUP_ROLE, init.interestTopUp);\n            _grantRole(DRAWDOWN_MANAGER_ROLE, init.drawdownManager);\n            stakingContract = init.staking;\n            pauser = init.pauser;\n            feesReceiver = init.feesReceiver;\n            shouldExecuteAllocation = true;\n            _grantRole(LIQUIDITY_MANAGER_ROLE, address(stakingContract));\n        }\n        // Original: addPositionManager()\n        else if (_selector == 1) {\n            if (isRegisteredManager[managerAddress]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n            managerId = positionManagerCount;\n            positionManagerCount++;\n            positionManagerConfigs[managerId] = PositionManagerConfig({\n            managerAddress: managerAddress,\n            allocationCap: allocationCap,\n            isActive: true\n            });\n            positionAccountants[managerId] = PositionAccountant({\n            allocatedBalance: 0,\n            interestClaimedFromManager: 0\n            });\n            isRegisteredManager[managerAddress] = true;\n            totalAllocationCapacity += allocationCap;\n            emit ProtocolConfigChanged(\n            this.addPositionManager.selector,\n            \"addPositionManager(address,uint256)\",\n            abi.encode(managerAddress, allocationCap)\n            );\n        }\n        // Original: updatePositionManager()\n        else if (_selector == 2) {\n            if (managerId >= positionManagerCount) {\n            revert LiquidityBuffer__ManagerNotFound();\n            }\n            PositionManagerConfig storage config = positionManagerConfigs[managerId];\n            if (newAllocationCap < positionAccountants[managerId].allocatedBalance) {\n            revert LiquidityBuffer__InvalidConfiguration();\n            }\n            totalAllocationCapacity = totalAllocationCapacity - config.allocationCap + newAllocationCap;\n            config.allocationCap = newAllocationCap;\n            config.isActive = isActive;\n            emit ProtocolConfigChanged(\n            this.updatePositionManager.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi.encode(managerId, newAllocationCap, isActive)\n            );\n        }\n    }\n}",
      "merged_functions": [
        "initialize",
        "addPositionManager",
        "updatePositionManager"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: initialize, addPositionManager, updatePositionManager"
      ],
      "function_to_selector": {
        "initialize": 0,
        "addPositionManager": 1,
        "updatePositionManager": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_025",
      "transformed_id": "rs_mg_dis_nc_gs_025",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ninterface StakingEvents {\n\n    event Staked(address indexed staker, uint256 ethAmount, uint256 mETHAmount);\n\n\n    event UnstakeRequested(uint256 indexed id, address indexed staker, uint256 ethAmount, uint256 mETHLocked);\n\n\n    event UnstakeRequestClaimed(uint256 indexed id, address indexed staker);\n\n\n    event ValidatorInitiated(bytes32 indexed id, uint256 indexed operatorID, bytes pubkey, uint256 amountDeposited);\n\n\n    event AllocatedETHToUnstakeRequestsManager(uint256 amount);\n\n\n    event AllocatedETHToDeposits(uint256 amount);\n\n\n    event ReturnsReceived(uint256 amount);\n\n\n    event ReturnsReceivedFromLiquidityBuffer(uint256 amount);\n\n\n    event AllocatedETHToLiquidityBuffer(uint256 amount);\n}\n\n\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 methAmount, uint256 expectedMinimum);\n    error UnstakeBelowMinimumETHAmount(uint256 ethAmount, uint256 expectedMinimum);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = keccak256(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = keccak256(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = keccak256(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = keccak256(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = keccak256(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = keccak256(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 operatorID;\n        uint256 depositAmount;\n        bytes pubkey;\n        bytes withdrawalCredentials;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    mapping(bytes pubkey => bool exists) public usedValidators;\n    uint256 public totalDepositedInValidators;\n    uint256 public numInitiatedValidators;\n    uint256 public unallocatedETH;\n    uint256 public allocatedETHForDeposits;\n    uint256 public minimumStakeBound;\n    uint256 public minimumUnstakeBound;\n    uint16 public exchangeAdjustmentRate;\n    uint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\n    uint16 internal constant _MAX_EXCHANGE_ADJUSTMENT_RATE = _BASIS_POINTS_DENOMINATOR / 10;\n    uint256 public minimumDepositAmount;\n    uint256 public maximumDepositAmount;\n    IDepositContract public depositContract;\n    IMETH public mETH;\n    IOracleReadRecord public oracle;\n    IPauserRead public pauser;\n    IUnstakeRequestsManager public unstakeRequestsManager;\n    address public withdrawalWallet;\n    address public returnsAggregator;\n    bool public isStakingAllowlist;\n    uint256 public initializationBlockNumber;\n    uint256 public maximumMETHSupply;\n    ILiquidityBuffer public liquidityBuffer;\n\n    struct Init {\n        address admin;\n        address manager;\n        address allocatorService;\n        address initiatorService;\n        address returnsAggregator;\n        address withdrawalWallet;\n        IMETH mETH;\n        IDepositContract depositContract;\n        IOracleReadRecord oracle;\n        IPauserRead pauser;\n        IUnstakeRequestsManager unstakeRequestsManager;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(STAKING_MANAGER_ROLE, init.manager);\n        _grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n        _grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n\n        _setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        mETH = init.mETH;\n        depositContract = init.depositContract;\n        oracle = init.oracle;\n        pauser = init.pauser;\n        returnsAggregator = init.returnsAggregator;\n        unstakeRequestsManager = init.unstakeRequestsManager;\n        withdrawalWallet = init.withdrawalWallet;\n\n        minimumStakeBound = 0.1 ether;\n        minimumUnstakeBound = 0.01 ether;\n        minimumDepositAmount = 32 ether;\n        maximumDepositAmount = 32 ether;\n        isStakingAllowlist = true;\n        initializationBlockNumber = block.number;\n        maximumMETHSupply = 1024 ether;\n    }\n\n    function initializeV2(ILiquidityBuffer lb) public reinitializer(2) {\n        liquidityBuffer = lb;\n    }\n\n    function stake(uint256 minMETHAmount) external payable {\n        if (pauser.isStakingPaused()) {\n            revert Paused();\n        }\n\n        if (isStakingAllowlist) {\n            _checkRole(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < minimumStakeBound) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 mETHMintAmount = ethToMETH(msg.value);\n        if (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (mETHMintAmount < minMETHAmount) {\n            revert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n        }\n\n        unallocatedETH += msg.value;\n\n        emit Staked(msg.sender, msg.value, mETHMintAmount);\n        mETH.mint(msg.sender, mETHMintAmount);\n    }\n\n    function unstakeRequest(uint128 methAmount, uint128 minETHAmount) external returns (uint256) {\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function unstakeRequestWithPermit(\n        uint128 methAmount,\n        uint128 minETHAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.safePermit(mETH, msg.sender, address(this), methAmount, deadline, v, r, s);\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function _unstakeRequest(uint128 methAmount, uint128 minETHAmount) internal returns (uint256) {\n        if (pauser.isUnstakeRequestsAndClaimsPaused()) {\n            revert Paused();\n        }\n\n        if (methAmount < minimumUnstakeBound) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 ethAmount = uint128(mETHToETH(methAmount));\n        if (ethAmount < minETHAmount) {\n            revert UnstakeBelowMinimumETHAmount(ethAmount, minETHAmount);\n        }\n\n        uint256 requestID =\n            unstakeRequestsManager.create({requester: msg.sender, mETHLocked: methAmount, ethRequested: ethAmount});\n        emit UnstakeRequested({id: requestID, staker: msg.sender, ethAmount: ethAmount, mETHLocked: methAmount});\n\n        SafeERC20Upgradeable.safeTransferFrom(mETH, msg.sender, address(unstakeRequestsManager), methAmount);\n\n        return requestID;\n    }\n\n    function ethToMETH(uint256 ethAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return ethAmount;\n        }\n        uint256 adjustedTotalControlled = Math.mulDiv(\n            totalControlled(), _BASIS_POINTS_DENOMINATOR + exchangeAdjustmentRate, _BASIS_POINTS_DENOMINATOR\n        );\n        return Math.mulDiv(ethAmount, mETH.totalSupply(), adjustedTotalControlled);\n    }\n\n    function mETHToETH(uint256 mETHAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return mETHAmount;\n        }\n        return Math.mulDiv(mETHAmount, totalControlled(), mETH.totalSupply());\n    }\n\n    function totalControlled() public view returns (uint256) {\n        OracleRecord memory record = oracle.latestRecord();\n        uint256 total = 0;\n        total += unallocatedETH;\n        total += allocatedETHForDeposits;\n        total += totalDepositedInValidators - record.cumulativeProcessedDepositAmount;\n        total += record.currentTotalValidatorBalance;\n        total += liquidityBuffer.getAvailableBalance();\n        total -= liquidityBuffer.cumulativeDrawdown();\n        total += unstakeRequestsManager.balance();\n        return total;\n    }\n\n    function receiveReturns() external payable onlyReturnsAggregator {\n        emit ReturnsReceived(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    function receiveReturnsFromLiquidityBuffer() external payable onlyLiquidityBuffer {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    modifier onlyReturnsAggregator() {\n        if (msg.sender != returnsAggregator) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier onlyLiquidityBuffer() {\n        if (msg.sender != address(liquidityBuffer)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier onlyUnstakeRequestsManager() {\n        if (msg.sender != address(unstakeRequestsManager)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    // Unified dispatcher - merged from: unstakeRequestWithPermit, initialize, initializeV2\n    // Selectors: unstakeRequestWithPermit=0, initialize=1, initializeV2=2\n    function execute(uint8 _selector, ILiquidityBuffer lb, Init init, bytes32 r, bytes32 s, uint128 methAmount, uint128 minETHAmount, uint256 deadline, uint8 v) public {\n        // Original: unstakeRequestWithPermit()\n        if (_selector == 0) {\n            SafeERC20Upgradeable.safePermit(mETH, msg.sender, address(this), methAmount, deadline, v, r, s);\n            return _unstakeRequest(methAmount, minETHAmount);\n        }\n        // Original: initialize()\n        else if (_selector == 1) {\n            __AccessControlEnumerable_init();\n            _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n            _grantRole(STAKING_MANAGER_ROLE, init.manager);\n            _grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n            _grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n            _setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n            _setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n            mETH = init.mETH;\n            depositContract = init.depositContract;\n            oracle = init.oracle;\n            pauser = init.pauser;\n            returnsAggregator = init.returnsAggregator;\n            unstakeRequestsManager = init.unstakeRequestsManager;\n            withdrawalWallet = init.withdrawalWallet;\n            minimumStakeBound = 0.1 ether;\n            minimumUnstakeBound = 0.01 ether;\n            minimumDepositAmount = 32 ether;\n            maximumDepositAmount = 32 ether;\n            isStakingAllowlist = true;\n            initializationBlockNumber = block.number;\n            maximumMETHSupply = 1024 ether;\n        }\n        // Original: initializeV2()\n        else if (_selector == 2) {\n            liquidityBuffer = lb;\n        }\n    }\n}",
      "merged_functions": [
        "unstakeRequestWithPermit",
        "initialize",
        "initializeV2"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: unstakeRequestWithPermit, initialize, initializeV2"
      ],
      "function_to_selector": {
        "unstakeRequestWithPermit": 0,
        "initialize": 1,
        "initializeV2": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_026",
      "transformed_id": "rs_mg_dis_nc_gs_026",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IPool} from \"aave-v3/interfaces/IPool.sol\";\nimport {DataTypes} from \"aave-v3/protocol/libraries/types/DataTypes.sol\";\nimport {IPositionManager} from './interfaces/IPositionManager.sol';\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {ILiquidityBuffer} from \"../liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ncontract PositionManager is Initializable, AccessControlEnumerableUpgradeable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant MANAGER_ROLE = keccak256(\"MANAGER_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = keccak256(\"EMERGENCY_ROLE\");\n\n\n    IPool public pool;\n    IWETH public weth;\n    ILiquidityBuffer public liquidityBuffer;\n\n\n    struct Init {\n        address admin;\n        address manager;\n        ILiquidityBuffer liquidityBuffer;\n        IWETH weth;\n        IPool pool;\n    }\n\n\n    event Deposit(address indexed caller, uint amount, uint aTokenAmount);\n    event Withdraw(address indexed caller, uint amount);\n    event Borrow(address indexed caller, uint amount, uint rateMode);\n    event Repay(address indexed caller, uint amount, uint rateMode);\n    event SetUserEMode(address indexed caller, uint8 categoryId);\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n        __AccessControlEnumerable_init();\n\n        weth = init.weth;\n        pool = init.pool;\n        liquidityBuffer = init.liquidityBuffer;\n\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(MANAGER_ROLE, init.manager);\n        _grantRole(EXECUTOR_ROLE, address(init.liquidityBuffer));\n\n\n        weth.approve(address(pool), type(uint256).max);\n    }\n\n\n    function deposit(uint16 referralCode) external payable override onlyRole(EXECUTOR_ROLE) {\n        if (msg.value > 0) {\n\n            weth.deposit{value: msg.value}();\n\n\n            pool.deposit(address(weth), msg.value, address(this), referralCode);\n\n            emit Deposit(msg.sender, msg.value, msg.value);\n        }\n    }\n\n    function withdraw(uint256 amount) external override onlyRole(EXECUTOR_ROLE) {\n        require(amount > 0, 'Invalid amount');\n\n\n        IERC20 aWETH = IERC20(pool.getReserveAToken(address(weth)));\n        uint256 userBalance = aWETH.balanceOf(address(this));\n\n        uint256 amountToWithdraw = amount;\n        if (amount == type(uint256).max) {\n            amountToWithdraw = userBalance;\n        }\n\n        require(amountToWithdraw <= userBalance, 'Insufficient balance');\n\n\n        pool.withdraw(address(weth), amountToWithdraw, address(this));\n\n\n        weth.withdraw(amountToWithdraw);\n\n\n        liquidityBuffer.receiveETHFromPositionManager{value: amountToWithdraw}();\n\n        emit Withdraw(msg.sender, amountToWithdraw);\n    }\n\n    function getUnderlyingBalance() external view returns (uint256) {\n        IERC20 aWETH = IERC20(pool.getReserveAToken(address(weth)));\n        return aWETH.balanceOf(address(this));\n    }\n\n    function setUserEMode(uint8 categoryId) external override onlyRole(MANAGER_ROLE) {\n\n        pool.setUserEMode(categoryId);\n\n        emit SetUserEMode(msg.sender, categoryId);\n    }\n    function approveToken(address token, address addr, uint256 wad) external override onlyRole(MANAGER_ROLE) {\n        IERC20(token).safeApprove(addr, wad);\n    }\n\n    function revokeToken(address token, address addr) external override onlyRole(MANAGER_ROLE) {\n        IERC20(token).safeApprove(addr, 0);\n    }\n\n\n    function getBorrowBalance() external view returns (uint256) {\n        address debtToken = pool.getReserveVariableDebtToken(address(weth));\n        return IERC20(debtToken).balanceOf(address(this));\n    }\n\n    function getCollateralBalance() external view returns (uint256) {\n        IERC20 aWETH = IERC20(pool.getReserveAToken(address(weth)));\n        return aWETH.balanceOf(address(this));\n    }\n\n    function getUserEMode() external view returns (uint256) {\n        return pool.getUserEMode(address(this));\n    }\n\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external onlyRole(MANAGER_ROLE) {\n        pool.setUserUseReserveAsCollateral(asset, useAsCollateral);\n    }\n\n    function setLiquidityBuffer(address _liquidityBuffer) external onlyRole(MANAGER_ROLE) {\n        _revokeRole(EXECUTOR_ROLE, address(liquidityBuffer));\n        _grantRole(EXECUTOR_ROLE, _liquidityBuffer);\n        liquidityBuffer = ILiquidityBuffer(_liquidityBuffer);\n    }\n\n\n    function emergencyTokenTransfer(address token, address to, uint256 amount) external onlyRole(EMERGENCY_ROLE) {\n        IERC20(token).safeTransfer(to, amount);\n    }\n\n\n    function emergencyEtherTransfer(address to, uint256 amount) external onlyRole(EMERGENCY_ROLE) {\n        _safeTransferETH(to, amount);\n    }\n\n\n    function _safeTransferETH(address to, uint256 value) internal {\n        (bool success, ) = to.call{value: value}(new bytes(0));\n        require(success, 'ETH_TRANSFER_FAILED');\n    }\n\n\n    receive() external payable {\n        require(msg.sender == address(weth), 'Receive not allowed');\n    }\n\n\n    fallback() external payable {\n        revert('Fallback not allowed');\n    }\n\n    // Unified dispatcher - merged from: emergencyTokenTransfer, initialize, deposit\n    // Selectors: emergencyTokenTransfer=0, initialize=1, deposit=2\n    function execute(uint8 _selector, Init init, address to, address token, uint16 referralCode, uint256 amount) public payable {\n        // Original: emergencyTokenTransfer()\n        if (_selector == 0) {\n            IERC20(token).safeTransfer(to, amount);\n        }\n        // Original: initialize()\n        else if (_selector == 1) {\n            __AccessControlEnumerable_init();\n            weth = init.weth;\n            pool = init.pool;\n            liquidityBuffer = init.liquidityBuffer;\n            _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n            _grantRole(MANAGER_ROLE, init.manager);\n            _grantRole(EXECUTOR_ROLE, address(init.liquidityBuffer));\n            weth.approve(address(pool), type(uint256).max);\n        }\n        // Original: deposit()\n        else if (_selector == 2) {\n            if (msg.value > 0) {\n            weth.deposit{value: msg.value}();\n            pool.deposit(address(weth), msg.value, address(this), referralCode);\n            emit Deposit(msg.sender, msg.value, msg.value);\n            }\n        }\n    }\n}",
      "merged_functions": [
        "emergencyTokenTransfer",
        "initialize",
        "deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: emergencyTokenTransfer, initialize, deposit"
      ],
      "function_to_selector": {
        "emergencyTokenTransfer": 0,
        "initialize": 1,
        "deposit": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_027",
      "transformed_id": "rs_mg_dis_nc_gs_027",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ninterface StakingEvents {\n\n    event Staked(address indexed staker, uint256 ethAmount, uint256 mETHAmount);\n\n\n    event UnstakeRequested(uint256 indexed id, address indexed staker, uint256 ethAmount, uint256 mETHLocked);\n\n\n    event UnstakeRequestClaimed(uint256 indexed id, address indexed staker);\n\n\n    event ValidatorInitiated(bytes32 indexed id, uint256 indexed operatorID, bytes pubkey, uint256 amountDeposited);\n\n\n    event AllocatedETHToUnstakeRequestsManager(uint256 amount);\n\n\n    event AllocatedETHToDeposits(uint256 amount);\n\n\n    event ReturnsReceived(uint256 amount);\n\n\n    event ReturnsReceivedFromLiquidityBuffer(uint256 amount);\n\n\n    event AllocatedETHToLiquidityBuffer(uint256 amount);\n}\n\n\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 methAmount, uint256 expectedMinimum);\n    error UnstakeBelowMinimumETHAmount(uint256 ethAmount, uint256 expectedMinimum);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = keccak256(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = keccak256(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = keccak256(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = keccak256(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = keccak256(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = keccak256(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 operatorID;\n        uint256 depositAmount;\n        bytes pubkey;\n        bytes withdrawalCredentials;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    mapping(bytes pubkey => bool exists) public usedValidators;\n    uint256 public totalDepositedInValidators;\n    uint256 public numInitiatedValidators;\n    uint256 public unallocatedETH;\n    uint256 public allocatedETHForDeposits;\n    uint256 public minimumStakeBound;\n    uint256 public minimumUnstakeBound;\n    uint16 public exchangeAdjustmentRate;\n    uint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\n    uint16 internal constant _MAX_EXCHANGE_ADJUSTMENT_RATE = _BASIS_POINTS_DENOMINATOR / 10;\n    uint256 public minimumDepositAmount;\n    uint256 public maximumDepositAmount;\n    IDepositContract public depositContract;\n    IMETH public mETH;\n    IOracleReadRecord public oracle;\n    IPauserRead public pauser;\n    IUnstakeRequestsManager public unstakeRequestsManager;\n    address public withdrawalWallet;\n    address public returnsAggregator;\n    bool public isStakingAllowlist;\n    uint256 public initializationBlockNumber;\n    uint256 public maximumMETHSupply;\n    ILiquidityBuffer public liquidityBuffer;\n\n    struct Init {\n        address admin;\n        address manager;\n        address allocatorService;\n        address initiatorService;\n        address returnsAggregator;\n        address withdrawalWallet;\n        IMETH mETH;\n        IDepositContract depositContract;\n        IOracleReadRecord oracle;\n        IPauserRead pauser;\n        IUnstakeRequestsManager unstakeRequestsManager;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(STAKING_MANAGER_ROLE, init.manager);\n        _grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n        _grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n\n        _setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        mETH = init.mETH;\n        depositContract = init.depositContract;\n        oracle = init.oracle;\n        pauser = init.pauser;\n        returnsAggregator = init.returnsAggregator;\n        unstakeRequestsManager = init.unstakeRequestsManager;\n        withdrawalWallet = init.withdrawalWallet;\n\n        minimumStakeBound = 0.1 ether;\n        minimumUnstakeBound = 0.01 ether;\n        minimumDepositAmount = 32 ether;\n        maximumDepositAmount = 32 ether;\n        isStakingAllowlist = true;\n        initializationBlockNumber = block.number;\n        maximumMETHSupply = 1024 ether;\n    }\n\n    function initializeV2(ILiquidityBuffer lb) public reinitializer(2) {\n        liquidityBuffer = lb;\n    }\n\n    function stake(uint256 minMETHAmount) external payable {\n        if (pauser.isStakingPaused()) {\n            revert Paused();\n        }\n\n        if (isStakingAllowlist) {\n            _checkRole(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < minimumStakeBound) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 mETHMintAmount = ethToMETH(msg.value);\n        if (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (mETHMintAmount < minMETHAmount) {\n            revert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n        }\n\n        unallocatedETH += msg.value;\n\n        emit Staked(msg.sender, msg.value, mETHMintAmount);\n        mETH.mint(msg.sender, mETHMintAmount);\n    }\n\n    function unstakeRequest(uint128 methAmount, uint128 minETHAmount) external returns (uint256) {\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function unstakeRequestWithPermit(\n        uint128 methAmount,\n        uint128 minETHAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.safePermit(mETH, msg.sender, address(this), methAmount, deadline, v, r, s);\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function _unstakeRequest(uint128 methAmount, uint128 minETHAmount) internal returns (uint256) {\n        if (pauser.isUnstakeRequestsAndClaimsPaused()) {\n            revert Paused();\n        }\n\n        if (methAmount < minimumUnstakeBound) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 ethAmount = uint128(mETHToETH(methAmount));\n        if (ethAmount < minETHAmount) {\n            revert UnstakeBelowMinimumETHAmount(ethAmount, minETHAmount);\n        }\n\n        uint256 requestID =\n            unstakeRequestsManager.create({requester: msg.sender, mETHLocked: methAmount, ethRequested: ethAmount});\n        emit UnstakeRequested({id: requestID, staker: msg.sender, ethAmount: ethAmount, mETHLocked: methAmount});\n\n        SafeERC20Upgradeable.safeTransferFrom(mETH, msg.sender, address(unstakeRequestsManager), methAmount);\n\n        return requestID;\n    }\n\n    function ethToMETH(uint256 ethAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return ethAmount;\n        }\n        uint256 adjustedTotalControlled = Math.mulDiv(\n            totalControlled(), _BASIS_POINTS_DENOMINATOR + exchangeAdjustmentRate, _BASIS_POINTS_DENOMINATOR\n        );\n        return Math.mulDiv(ethAmount, mETH.totalSupply(), adjustedTotalControlled);\n    }\n\n    function mETHToETH(uint256 mETHAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return mETHAmount;\n        }\n        return Math.mulDiv(mETHAmount, totalControlled(), mETH.totalSupply());\n    }\n\n    function totalControlled() public view returns (uint256) {\n        OracleRecord memory record = oracle.latestRecord();\n        uint256 total = 0;\n        total += unallocatedETH;\n        total += allocatedETHForDeposits;\n        total += totalDepositedInValidators - record.cumulativeProcessedDepositAmount;\n        total += record.currentTotalValidatorBalance;\n        total += liquidityBuffer.getAvailableBalance();\n        total -= liquidityBuffer.cumulativeDrawdown();\n        total += unstakeRequestsManager.balance();\n        return total;\n    }\n\n    function receiveReturns() external payable onlyReturnsAggregator {\n        emit ReturnsReceived(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    function receiveReturnsFromLiquidityBuffer() external payable onlyLiquidityBuffer {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    modifier onlyReturnsAggregator() {\n        if (msg.sender != returnsAggregator) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier onlyLiquidityBuffer() {\n        if (msg.sender != address(liquidityBuffer)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier onlyUnstakeRequestsManager() {\n        if (msg.sender != address(unstakeRequestsManager)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    // Unified dispatcher - merged from: initialize, initializeV2, stake\n    // Selectors: initialize=0, initializeV2=1, stake=2\n    function execute(uint8 _selector, ILiquidityBuffer lb, Init init, uint256 minMETHAmount) public payable {\n        // Original: initialize()\n        if (_selector == 0) {\n            __AccessControlEnumerable_init();\n            _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n            _grantRole(STAKING_MANAGER_ROLE, init.manager);\n            _grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n            _grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n            _setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n            _setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n            mETH = init.mETH;\n            depositContract = init.depositContract;\n            oracle = init.oracle;\n            pauser = init.pauser;\n            returnsAggregator = init.returnsAggregator;\n            unstakeRequestsManager = init.unstakeRequestsManager;\n            withdrawalWallet = init.withdrawalWallet;\n            minimumStakeBound = 0.1 ether;\n            minimumUnstakeBound = 0.01 ether;\n            minimumDepositAmount = 32 ether;\n            maximumDepositAmount = 32 ether;\n            isStakingAllowlist = true;\n            initializationBlockNumber = block.number;\n            maximumMETHSupply = 1024 ether;\n        }\n        // Original: initializeV2()\n        else if (_selector == 1) {\n            liquidityBuffer = lb;\n        }\n        // Original: stake()\n        else if (_selector == 2) {\n            if (pauser.isStakingPaused()) {\n            revert Paused();\n            }\n            if (isStakingAllowlist) {\n            _checkRole(STAKING_ALLOWLIST_ROLE);\n            }\n            if (msg.value < minimumStakeBound) {\n            revert MinimumStakeBoundNotSatisfied();\n            }\n            uint256 mETHMintAmount = ethToMETH(msg.value);\n            if (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\n            revert MaximumMETHSupplyExceeded();\n            }\n            if (mETHMintAmount < minMETHAmount) {\n            revert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n            }\n            unallocatedETH += msg.value;\n            emit Staked(msg.sender, msg.value, mETHMintAmount);\n            mETH.mint(msg.sender, mETHMintAmount);\n        }\n    }\n}",
      "merged_functions": [
        "initialize",
        "initializeV2",
        "stake"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: initialize, initializeV2, stake"
      ],
      "function_to_selector": {
        "initialize": 0,
        "initializeV2": 1,
        "stake": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_028",
      "transformed_id": "rs_mg_dis_nc_gs_028",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ninterface StakingEvents {\n\n    event Staked(address indexed staker, uint256 ethAmount, uint256 mETHAmount);\n\n\n    event UnstakeRequested(uint256 indexed id, address indexed staker, uint256 ethAmount, uint256 mETHLocked);\n\n\n    event UnstakeRequestClaimed(uint256 indexed id, address indexed staker);\n\n\n    event ValidatorInitiated(bytes32 indexed id, uint256 indexed operatorID, bytes pubkey, uint256 amountDeposited);\n\n\n    event AllocatedETHToUnstakeRequestsManager(uint256 amount);\n\n\n    event AllocatedETHToDeposits(uint256 amount);\n\n\n    event ReturnsReceived(uint256 amount);\n\n\n    event ReturnsReceivedFromLiquidityBuffer(uint256 amount);\n\n\n    event AllocatedETHToLiquidityBuffer(uint256 amount);\n}\n\n\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 methAmount, uint256 expectedMinimum);\n    error UnstakeBelowMinimumETHAmount(uint256 ethAmount, uint256 expectedMinimum);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = keccak256(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = keccak256(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = keccak256(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = keccak256(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = keccak256(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = keccak256(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 operatorID;\n        uint256 depositAmount;\n        bytes pubkey;\n        bytes withdrawalCredentials;\n        bytes signature;\n        bytes32 depositDataRoot;\n    }\n\n    mapping(bytes pubkey => bool exists) public usedValidators;\n    uint256 public totalDepositedInValidators;\n    uint256 public numInitiatedValidators;\n    uint256 public unallocatedETH;\n    uint256 public allocatedETHForDeposits;\n    uint256 public minimumStakeBound;\n    uint256 public minimumUnstakeBound;\n    uint16 public exchangeAdjustmentRate;\n    uint16 internal constant _BASIS_POINTS_DENOMINATOR = 10_000;\n    uint16 internal constant _MAX_EXCHANGE_ADJUSTMENT_RATE = _BASIS_POINTS_DENOMINATOR / 10;\n    uint256 public minimumDepositAmount;\n    uint256 public maximumDepositAmount;\n    IDepositContract public depositContract;\n    IMETH public mETH;\n    IOracleReadRecord public oracle;\n    IPauserRead public pauser;\n    IUnstakeRequestsManager public unstakeRequestsManager;\n    address public withdrawalWallet;\n    address public returnsAggregator;\n    bool public isStakingAllowlist;\n    uint256 public initializationBlockNumber;\n    uint256 public maximumMETHSupply;\n    ILiquidityBuffer public liquidityBuffer;\n\n    struct Init {\n        address admin;\n        address manager;\n        address allocatorService;\n        address initiatorService;\n        address returnsAggregator;\n        address withdrawalWallet;\n        IMETH mETH;\n        IDepositContract depositContract;\n        IOracleReadRecord oracle;\n        IPauserRead pauser;\n        IUnstakeRequestsManager unstakeRequestsManager;\n    }\n\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(Init memory init) external initializer {\n        __AccessControlEnumerable_init();\n\n        _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n        _grantRole(STAKING_MANAGER_ROLE, init.manager);\n        _grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n        _grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n\n        _setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        mETH = init.mETH;\n        depositContract = init.depositContract;\n        oracle = init.oracle;\n        pauser = init.pauser;\n        returnsAggregator = init.returnsAggregator;\n        unstakeRequestsManager = init.unstakeRequestsManager;\n        withdrawalWallet = init.withdrawalWallet;\n\n        minimumStakeBound = 0.1 ether;\n        minimumUnstakeBound = 0.01 ether;\n        minimumDepositAmount = 32 ether;\n        maximumDepositAmount = 32 ether;\n        isStakingAllowlist = true;\n        initializationBlockNumber = block.number;\n        maximumMETHSupply = 1024 ether;\n    }\n\n    function initializeV2(ILiquidityBuffer lb) public reinitializer(2) {\n        liquidityBuffer = lb;\n    }\n\n    function stake(uint256 minMETHAmount) external payable {\n        if (pauser.isStakingPaused()) {\n            revert Paused();\n        }\n\n        if (isStakingAllowlist) {\n            _checkRole(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < minimumStakeBound) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 mETHMintAmount = ethToMETH(msg.value);\n        if (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (mETHMintAmount < minMETHAmount) {\n            revert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n        }\n\n        unallocatedETH += msg.value;\n\n        emit Staked(msg.sender, msg.value, mETHMintAmount);\n        mETH.mint(msg.sender, mETHMintAmount);\n    }\n\n    function unstakeRequest(uint128 methAmount, uint128 minETHAmount) external returns (uint256) {\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function unstakeRequestWithPermit(\n        uint128 methAmount,\n        uint128 minETHAmount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.safePermit(mETH, msg.sender, address(this), methAmount, deadline, v, r, s);\n        return _unstakeRequest(methAmount, minETHAmount);\n    }\n\n    function _unstakeRequest(uint128 methAmount, uint128 minETHAmount) internal returns (uint256) {\n        if (pauser.isUnstakeRequestsAndClaimsPaused()) {\n            revert Paused();\n        }\n\n        if (methAmount < minimumUnstakeBound) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 ethAmount = uint128(mETHToETH(methAmount));\n        if (ethAmount < minETHAmount) {\n            revert UnstakeBelowMinimumETHAmount(ethAmount, minETHAmount);\n        }\n\n        uint256 requestID =\n            unstakeRequestsManager.create({requester: msg.sender, mETHLocked: methAmount, ethRequested: ethAmount});\n        emit UnstakeRequested({id: requestID, staker: msg.sender, ethAmount: ethAmount, mETHLocked: methAmount});\n\n        SafeERC20Upgradeable.safeTransferFrom(mETH, msg.sender, address(unstakeRequestsManager), methAmount);\n\n        return requestID;\n    }\n\n    function ethToMETH(uint256 ethAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return ethAmount;\n        }\n        uint256 adjustedTotalControlled = Math.mulDiv(\n            totalControlled(), _BASIS_POINTS_DENOMINATOR + exchangeAdjustmentRate, _BASIS_POINTS_DENOMINATOR\n        );\n        return Math.mulDiv(ethAmount, mETH.totalSupply(), adjustedTotalControlled);\n    }\n\n    function mETHToETH(uint256 mETHAmount) public view returns (uint256) {\n        if (mETH.totalSupply() == 0) {\n            return mETHAmount;\n        }\n        return Math.mulDiv(mETHAmount, totalControlled(), mETH.totalSupply());\n    }\n\n    function totalControlled() public view returns (uint256) {\n        OracleRecord memory record = oracle.latestRecord();\n        uint256 total = 0;\n        total += unallocatedETH;\n        total += allocatedETHForDeposits;\n        total += totalDepositedInValidators - record.cumulativeProcessedDepositAmount;\n        total += record.currentTotalValidatorBalance;\n        total += liquidityBuffer.getAvailableBalance();\n        total -= liquidityBuffer.cumulativeDrawdown();\n        total += unstakeRequestsManager.balance();\n        return total;\n    }\n\n    function receiveReturns() external payable onlyReturnsAggregator {\n        emit ReturnsReceived(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    function receiveReturnsFromLiquidityBuffer() external payable onlyLiquidityBuffer {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        unallocatedETH += msg.value;\n    }\n\n    modifier onlyReturnsAggregator() {\n        if (msg.sender != returnsAggregator) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier onlyLiquidityBuffer() {\n        if (msg.sender != address(liquidityBuffer)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier onlyUnstakeRequestsManager() {\n        if (msg.sender != address(unstakeRequestsManager)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier notZeroAddress(address addr) {\n        if (addr == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    // Unified dispatcher - merged from: initialize, initializeV2, stake\n    // Selectors: initialize=0, initializeV2=1, stake=2\n    function execute(uint8 _selector, ILiquidityBuffer lb, Init init, uint256 minMETHAmount) public payable {\n        // Original: initialize()\n        if (_selector == 0) {\n            __AccessControlEnumerable_init();\n            _grantRole(DEFAULT_ADMIN_ROLE, init.admin);\n            _grantRole(STAKING_MANAGER_ROLE, init.manager);\n            _grantRole(ALLOCATOR_SERVICE_ROLE, init.allocatorService);\n            _grantRole(INITIATOR_SERVICE_ROLE, init.initiatorService);\n            _setRoleAdmin(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n            _setRoleAdmin(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n            mETH = init.mETH;\n            depositContract = init.depositContract;\n            oracle = init.oracle;\n            pauser = init.pauser;\n            returnsAggregator = init.returnsAggregator;\n            unstakeRequestsManager = init.unstakeRequestsManager;\n            withdrawalWallet = init.withdrawalWallet;\n            minimumStakeBound = 0.1 ether;\n            minimumUnstakeBound = 0.01 ether;\n            minimumDepositAmount = 32 ether;\n            maximumDepositAmount = 32 ether;\n            isStakingAllowlist = true;\n            initializationBlockNumber = block.number;\n            maximumMETHSupply = 1024 ether;\n        }\n        // Original: initializeV2()\n        else if (_selector == 1) {\n            liquidityBuffer = lb;\n        }\n        // Original: stake()\n        else if (_selector == 2) {\n            if (pauser.isStakingPaused()) {\n            revert Paused();\n            }\n            if (isStakingAllowlist) {\n            _checkRole(STAKING_ALLOWLIST_ROLE);\n            }\n            if (msg.value < minimumStakeBound) {\n            revert MinimumStakeBoundNotSatisfied();\n            }\n            uint256 mETHMintAmount = ethToMETH(msg.value);\n            if (mETHMintAmount + mETH.totalSupply() > maximumMETHSupply) {\n            revert MaximumMETHSupplyExceeded();\n            }\n            if (mETHMintAmount < minMETHAmount) {\n            revert StakeBelowMinimumMETHAmount(mETHMintAmount, minMETHAmount);\n            }\n            unallocatedETH += msg.value;\n            emit Staked(msg.sender, msg.value, mETHMintAmount);\n            mETH.mint(msg.sender, mETHMintAmount);\n        }\n    }\n}",
      "merged_functions": [
        "initialize",
        "initializeV2",
        "stake"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: initialize, initializeV2, stake"
      ],
      "function_to_selector": {
        "initialize": 0,
        "initializeV2": 1,
        "stake": 2
      },
      "error": null
    },
    {
      "original_id": "nc_gs_029",
      "transformed_id": "rs_mg_dis_nc_gs_029",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_gs_030",
      "transformed_id": "rs_mg_dis_nc_gs_030",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport { LibOptim } from \"../utils/LibOptim.sol\";\nimport { Nonce } from \"./Nonce.sol\";\nimport { Payload } from \"./Payload.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { BaseAuth } from \"./auth/BaseAuth.sol\";\nimport { IDelegatedExtension } from \"./interfaces/IDelegatedExtension.sol\";\n\n\nabstract contract Calls is ReentrancyGuard, BaseAuth, Nonce {\n\n\n  event CallSucceeded(bytes32 _opHash, uint256 _index);\n\n  event CallFailed(bytes32 _opHash, uint256 _index, bytes _returnData);\n\n  event CallAborted(bytes32 _opHash, uint256 _index, bytes _returnData);\n\n  event CallSkipped(bytes32 _opHash, uint256 _index);\n\n\n  error Reverted(Payload.Decoded _payload, uint256 _index, bytes _returnData);\n\n  error InvalidSignature(Payload.Decoded _payload, bytes _signature);\n\n  error NotEnoughGas(Payload.Decoded _payload, uint256 _index, uint256 _gasLeft);\n\n\n  function execute(bytes calldata _payload, bytes calldata _signature) external payable virtual nonReentrant {\n    uint256 startingGas = gasleft();\n    Payload.Decoded memory decoded = Payload.fromPackedCalls(_payload);\n\n    _consumeNonce(decoded.space, decoded.nonce);\n    (bool isValid, bytes32 opHash) = signatureValidation(decoded, _signature);\n\n    if (!isValid) {\n      revert InvalidSignature(decoded, _signature);\n    }\n\n    _execute(startingGas, opHash, decoded);\n  }\n\n\n  function selfExecute(\n    bytes calldata _payload\n  ) external payable virtual onlySelf {\n    uint256 startingGas = gasleft();\n    Payload.Decoded memory decoded = Payload.fromPackedCalls(_payload);\n    bytes32 opHash = Payload.hash(decoded);\n    _execute(startingGas, opHash, decoded);\n  }\n\n  function _execute(uint256 _startingGas, bytes32 _opHash, Payload.Decoded memory _decoded) private {\n    bool errorFlag = false;\n\n    uint256 numCalls = _decoded.calls.length;\n    for (uint256 i = 0; i < numCalls; i++) {\n      Payload.Call memory call = _decoded.calls[i];\n\n\n      if (call.onlyFallback && !errorFlag) {\n        emit CallSkipped(_opHash, i);\n        continue;\n      }\n\n\n      errorFlag = false;\n\n      uint256 gasLimit = call.gasLimit;\n      if (gasLimit != 0 && gasleft() < gasLimit) {\n        revert NotEnoughGas(_decoded, i, gasleft());\n      }\n\n      bool success;\n      if (call.delegateCall) {\n        (success) = LibOptim.delegatecall(\n          call.to,\n          gasLimit == 0 ? gasleft() : gasLimit,\n          abi.encodeWithSelector(\n            IDelegatedExtension.handleSequenceDelegateCall.selector,\n            _opHash,\n            _startingGas,\n            i,\n            numCalls,\n            _decoded.space,\n            call.data\n          )\n        );\n      } else {\n        (success) = LibOptim.call(call.to, call.value, gasLimit == 0 ? gasleft() : gasLimit, call.data);\n      }\n\n      if (!success) {\n        if (call.behaviorOnError == Payload.BEHAVIOR_IGNORE_ERROR) {\n          errorFlag = true;\n          emit CallFailed(_opHash, i, LibOptim.returnData());\n          continue;\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_REVERT_ON_ERROR) {\n          revert Reverted(_decoded, i, LibOptim.returnData());\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_ABORT_ON_ERROR) {\n          emit CallAborted(_opHash, i, LibOptim.returnData());\n          break;\n        }\n      }\n\n      emit CallSucceeded(_opHash, i);\n    }\n  }\n\n\n    // Unified dispatcher - merged from: execute, selfExecute\n    // Selectors: execute=0, selfExecute=1\n    function execute(uint8 _selector, bytes _payload, bytes _signature) public payable {\n        // Original: execute()\n        if (_selector == 0) {\n            uint256 startingGas = gasleft();\n            Payload.Decoded memory decoded = Payload.fromPackedCalls(_payload);\n            _consumeNonce(decoded.space, decoded.nonce);\n            (bool isValid, bytes32 opHash) = signatureValidation(decoded, _signature);\n            if (!isValid) {\n            revert InvalidSignature(decoded, _signature);\n            }\n            _execute(startingGas, opHash, decoded);\n        }\n        // Original: selfExecute()\n        else if (_selector == 1) {\n            uint256 startingGas = gasleft();\n            Payload.Decoded memory decoded = Payload.fromPackedCalls(_payload);\n            bytes32 opHash = Payload.hash(decoded);\n            _execute(startingGas, opHash, decoded);\n        }\n    }\n}",
      "merged_functions": [
        "execute",
        "selfExecute"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: execute, selfExecute"
      ],
      "function_to_selector": {
        "execute": 0,
        "selfExecute": 1
      },
      "error": null
    },
    {
      "original_id": "nc_gs_031",
      "transformed_id": "rs_mg_dis_nc_gs_031",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_gs_032",
      "transformed_id": "rs_mg_dis_nc_gs_032",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.18;\n\nimport { Calls } from \"./Calls.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { IAccount, PackedUserOperation } from \"./interfaces/IAccount.sol\";\nimport { IERC1271_MAGIC_VALUE_HASH } from \"./interfaces/IERC1271.sol\";\nimport { IEntryPoint } from \"./interfaces/IEntryPoint.sol\";\n\n\nabstract contract ERC4337v07 is ReentrancyGuard, IAccount, Calls {\n\n  uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n  address public immutable entrypoint;\n\n  error InvalidEntryPoint(address _entrypoint);\n  error ERC4337Disabled();\n\n  constructor(\n    address _entrypoint\n  ) {\n    entrypoint = _entrypoint;\n  }\n\n\n  function validateUserOp(\n    PackedUserOperation calldata userOp,\n    bytes32 userOpHash,\n    uint256 missingAccountFunds\n  ) external returns (uint256 validationData) {\n    if (entrypoint == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != entrypoint) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n\n    if (missingAccountFunds != 0) {\n      IEntryPoint(entrypoint).depositTo{ value: missingAccountFunds }(address(this));\n    }\n\n    if (this.isValidSignature(userOpHash, userOp.signature) != IERC1271_MAGIC_VALUE_HASH) {\n      return SIG_VALIDATION_FAILED;\n    }\n\n    return 0;\n  }\n\n\n  function executeUserOp(\n    bytes calldata _payload\n  ) external nonReentrant {\n    if (entrypoint == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != entrypoint) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n    this.selfExecute(_payload);\n  }\n\n\n    // Unified dispatcher - merged from: validateUserOp, executeUserOp\n    // Selectors: validateUserOp=0, executeUserOp=1\n    function execute(uint8 _selector, PackedUserOperation userOp, bytes _payload, bytes32 userOpHash, uint256 missingAccountFunds) public {\n        // Original: validateUserOp()\n        if (_selector == 0) {\n            if (entrypoint == address(0)) {\n            revert ERC4337Disabled();\n            }\n            if (msg.sender != entrypoint) {\n            revert InvalidEntryPoint(msg.sender);\n            }\n            if (missingAccountFunds != 0) {\n            IEntryPoint(entrypoint).depositTo{ value: missingAccountFunds }(address(this));\n            }\n            if (this.isValidSignature(userOpHash, userOp.signature) != IERC1271_MAGIC_VALUE_HASH) {\n            return SIG_VALIDATION_FAILED;\n            }\n            return 0;\n        }\n        // Original: executeUserOp()\n        else if (_selector == 1) {\n            if (entrypoint == address(0)) {\n            revert ERC4337Disabled();\n            }\n            if (msg.sender != entrypoint) {\n            revert InvalidEntryPoint(msg.sender);\n            }\n            this.selfExecute(_payload);\n        }\n    }\n}",
      "merged_functions": [
        "validateUserOp",
        "executeUserOp"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: validateUserOp, executeUserOp"
      ],
      "function_to_selector": {
        "validateUserOp": 0,
        "executeUserOp": 1
      },
      "error": null
    },
    {
      "original_id": "nc_gs_033",
      "transformed_id": "rs_mg_dis_nc_gs_033",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport { Payload } from \"../Payload.sol\";\n\nimport { Storage } from \"../Storage.sol\";\nimport { IAuth } from \"../interfaces/IAuth.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\n\nimport { IPartialAuth } from \"../interfaces/IPartialAuth.sol\";\nimport { ISapient } from \"../interfaces/ISapient.sol\";\nimport { BaseSig } from \"./BaseSig.sol\";\n\nimport { SelfAuth } from \"./SelfAuth.sol\";\n\nusing Payload for Payload.Decoded;\n\n\nabstract contract BaseAuth is IAuth, IPartialAuth, ISapient, IERC1271, SelfAuth {\n\n\n  bytes32 private constant STATIC_SIGNATURE_KEY =\n    bytes32(0xc852adf5e97c2fc3b38f405671e91b7af1697ef0287577f227ef10494c2a8e86);\n\n\n  error InvalidSapientSignature(Payload.Decoded _payload, bytes _signature);\n\n  error InvalidSignatureWeight(uint256 _threshold, uint256 _weight);\n\n  error InvalidStaticSignatureExpired(bytes32 _opHash, uint256 _expires);\n\n  error InvalidStaticSignatureWrongCaller(bytes32 _opHash, address _caller, address _expectedCaller);\n\n\n  event StaticSignatureSet(bytes32 _hash, address _address, uint96 _timestamp);\n\n  function _getStaticSignature(\n    bytes32 _hash\n  ) internal view returns (address, uint256) {\n    uint256 word = uint256(Storage.readBytes32Map(STATIC_SIGNATURE_KEY, _hash));\n    return (address(uint160(word >> 96)), uint256(uint96(word)));\n  }\n\n  function _setStaticSignature(bytes32 _hash, address _address, uint256 _timestamp) internal {\n    Storage.writeBytes32Map(\n      STATIC_SIGNATURE_KEY, _hash, bytes32(uint256(uint160(_address)) << 96 | (_timestamp & 0xffffffffffffffffffffffff))\n    );\n  }\n\n\n  function getStaticSignature(\n    bytes32 _hash\n  ) external view returns (address, uint256) {\n    return _getStaticSignature(_hash);\n  }\n\n\n  function setStaticSignature(bytes32 _hash, address _address, uint96 _timestamp) external onlySelf {\n    _setStaticSignature(_hash, _address, _timestamp);\n    emit StaticSignatureSet(_hash, _address, _timestamp);\n  }\n\n\n  function updateImageHash(\n    bytes32 _imageHash\n  ) external virtual onlySelf {\n    _updateImageHash(_imageHash);\n  }\n\n  function signatureValidation(\n    Payload.Decoded memory _payload,\n    bytes calldata _signature\n  ) internal view virtual returns (bool isValid, bytes32 opHash) {\n\n    bytes1 signatureFlag = _signature[0];\n\n    if (signatureFlag & 0x80 == 0x80) {\n      opHash = _payload.hash();\n\n      (address addr, uint256 timestamp) = _getStaticSignature(opHash);\n      if (timestamp <= block.timestamp) {\n        revert InvalidStaticSignatureExpired(opHash, timestamp);\n      }\n\n      if (addr != address(0) && addr != msg.sender) {\n        revert InvalidStaticSignatureWrongCaller(opHash, msg.sender, addr);\n      }\n\n      return (true, opHash);\n    }\n\n\n    uint256 threshold;\n    uint256 weight;\n    bytes32 imageHash;\n\n    (threshold, weight, imageHash,, opHash) = BaseSig.recover(_payload, _signature, false, address(0));\n\n\n    if (weight < threshold) {\n      revert InvalidSignatureWeight(threshold, weight);\n    }\n\n    isValid = _isValidImage(imageHash);\n  }\n\n\n  function recoverSapientSignature(\n    Payload.Decoded memory _payload,\n    bytes calldata _signature\n  ) external view returns (bytes32) {\n\n    address[] memory parentWallets = new address[](_payload.parentWallets.length + 1);\n\n    for (uint256 i = 0; i < _payload.parentWallets.length; i++) {\n      parentWallets[i] = _payload.parentWallets[i];\n    }\n\n    parentWallets[_payload.parentWallets.length] = msg.sender;\n    _payload.parentWallets = parentWallets;\n\n    (bool isValid,) = signatureValidation(_payload, _signature);\n    if (!isValid) {\n      revert InvalidSapientSignature(_payload, _signature);\n    }\n\n    return bytes32(uint256(1));\n  }\n\n\n  function isValidSignature(bytes32 _hash, bytes calldata _signature) external view returns (bytes4) {\n    Payload.Decoded memory payload = Payload.fromDigest(_hash);\n\n    (bool isValid,) = signatureValidation(payload, _signature);\n    if (!isValid) {\n      return bytes4(0);\n    }\n\n    return IERC1271_MAGIC_VALUE_HASH;\n  }\n\n\n  function recoverPartialSignature(\n    Payload.Decoded memory _payload,\n    bytes calldata _signature\n  )\n    external\n    view\n    returns (\n      uint256 threshold,\n      uint256 weight,\n      bool isValidImage,\n      bytes32 imageHash,\n      uint256 checkpoint,\n      bytes32 opHash\n    )\n  {\n    (threshold, weight, imageHash, checkpoint, opHash) = BaseSig.recover(_payload, _signature, false, address(0));\n    isValidImage = _isValidImage(imageHash);\n  }\n\n\n    // Unified dispatcher - merged from: setStaticSignature, updateImageHash\n    // Selectors: setStaticSignature=0, updateImageHash=1\n    function execute(uint8 _selector, address _address, bytes32 _hash, bytes32 _imageHash, uint96 _timestamp) public {\n        // Original: setStaticSignature()\n        if (_selector == 0) {\n            _setStaticSignature(_hash, _address, _timestamp);\n            emit StaticSignatureSet(_hash, _address, _timestamp);\n        }\n        // Original: updateImageHash()\n        else if (_selector == 1) {\n            _updateImageHash(_imageHash);\n        }\n    }\n}",
      "merged_functions": [
        "setStaticSignature",
        "updateImageHash"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: setStaticSignature, updateImageHash"
      ],
      "function_to_selector": {
        "setStaticSignature": 0,
        "updateImageHash": 1
      },
      "error": null
    },
    {
      "original_id": "nc_gs_034",
      "transformed_id": "rs_mg_dis_nc_gs_034",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_gs_035",
      "transformed_id": "rs_mg_dis_nc_gs_035",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity >=0.8.19 <0.9.0;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IV2Pool} from \"../../external/IV2Pool.sol\";\nimport {IV2Router} from \"../../external/IV2Router.sol\";\nimport {IV2LockerFactory} from \"../../interfaces/extensions/v2/IV2LockerFactory.sol\";\nimport {IV2Locker} from \"../../interfaces/extensions/v2/IV2Locker.sol\";\nimport {ILocker} from \"../../interfaces/ILocker.sol\";\nimport {Locker} from \"../../Locker.sol\";\n\n\ncontract V2Locker is Locker, IV2Locker {\n    using SafeERC20 for IERC20;\n\n\n    address public immutable router;\n\n    uint256 internal _lp;\n\n    constructor(\n        bool _root,\n        address _owner,\n        address _pool,\n        address _router,\n        uint256 _lp_,\n        uint32 _lockedUntil,\n        address _beneficiary,\n        uint16 _beneficiaryShare,\n        uint16 _bribeableShare\n    ) Locker(_root, _owner, _pool, _lockedUntil, _beneficiary, _beneficiaryShare, _bribeableShare) {\n        router = _router;\n        _lp = _lp_;\n        (token0, token1) = IV2Pool(pool).tokens();\n    }\n\n\n    function unlock(address _recipient) external override(Locker, ILocker) onlyLocked nonReentrant returns (uint256) {\n        if (msg.sender != factory) revert NotFactory();\n\n        delete staked;\n        delete lockedUntil;\n\n        IERC20(pool).safeTransfer({to: _recipient, value: _lp});\n\n\n        uint256 leftover = IERC20(token0).balanceOf({account: address(this)});\n        if (leftover > 0) IERC20(token0).safeTransfer({to: _recipient, value: leftover});\n        leftover = IERC20(token1).balanceOf({account: address(this)});\n        if (leftover > 0) IERC20(token1).safeTransfer({to: _recipient, value: leftover});\n\n        emit Unlocked({recipient: _recipient});\n        return _lp;\n    }\n\n\n    function stake() external override(Locker, ILocker) nonReentrant onlyOwner onlyLocked ensureGauge {\n        if (staked) revert AlreadyStaked();\n        staked = true;\n\n        _claimFees({_recipient: owner()});\n\n        IERC20(pool).safeIncreaseAllowance({spender: address(gauge), value: _lp});\n        gauge.deposit({lp: _lp});\n        emit Staked();\n    }\n\n\n    function increaseLiquidity(uint256 _amount0, uint256 _amount1, uint256 _amount0Min, uint256 _amount1Min)\n        external\n        override(ILocker, Locker)\n        nonReentrant\n        onlyOwner\n        onlyLocked\n        returns (uint256)\n    {\n        if (_amount0 == 0 && _amount1 == 0) revert ZeroAmount();\n\n        uint256 supplied0 = _fundLocker({_token: token0, _totalBal: _amount0});\n        uint256 supplied1 = _fundLocker({_token: token1, _totalBal: _amount1});\n\n        IERC20(token0).forceApprove({spender: router, value: _amount0});\n        IERC20(token1).forceApprove({spender: router, value: _amount1});\n\n        (uint256 amount0Deposited, uint256 amount1Deposited, uint256 liquidity) = IV2Router(router).addLiquidity({\n            tokenA: token0,\n            tokenB: token1,\n            stable: IV2Pool(pool).stable(),\n            amountADesired: _amount0,\n            amountBDesired: _amount1,\n            amountAMin: _amount0Min,\n            amountBMin: _amount1Min,\n            to: address(this),\n            deadline: block.timestamp\n        });\n\n        IERC20(token0).forceApprove({spender: router, value: 0});\n        IERC20(token1).forceApprove({spender: router, value: 0});\n\n        address recipient = owner();\n        _refundLeftover({_token: token0, _recipient: recipient, _maxAmount: supplied0});\n        _refundLeftover({_token: token1, _recipient: recipient, _maxAmount: supplied1});\n\n        if (staked) {\n            IERC20(pool).safeIncreaseAllowance({spender: address(gauge), value: liquidity});\n            gauge.deposit({lp: liquidity});\n        }\n\n        _lp += liquidity;\n\n        emit LiquidityIncreased({amount0: amount0Deposited, amount1: amount1Deposited, liquidity: liquidity});\n        return liquidity;\n    }\n\n    function _collectFees() internal override returns (uint256 claimed0, uint256 claimed1) {\n        (claimed0, claimed1) = IV2Pool(pool).claimFees();\n\n        uint256 share0 = _deductShare({_amount: claimed0, _token: token0});\n        uint256 share1 = _deductShare({_amount: claimed1, _token: token1});\n        claimed0 -= share0;\n        claimed1 -= share1;\n\n        if (share0 > 0 || share1 > 0) {\n            emit FeesClaimed({recipient: beneficiary, claimed0: share0, claimed1: share1});\n        }\n    }\n\n    function _collectRewards() internal override returns (uint256 claimed) {\n        uint256 rewardsBefore = IERC20(rewardToken).balanceOf({account: address(this)});\n        gauge.getReward({account: address(this)});\n        uint256 rewardsAfter = IERC20(rewardToken).balanceOf({account: address(this)});\n\n        claimed = rewardsAfter - rewardsBefore;\n        uint256 share = _deductShare({_amount: claimed, _token: rewardToken});\n        claimed -= share;\n\n        if (share > 0) {\n            emit RewardsClaimed({recipient: beneficiary, claimed: share});\n        }\n    }\n\n    function lp() public view override(ILocker, Locker) returns (uint256) {\n        return _lp;\n    }\n\n    // Unified dispatcher - merged from: unlock, stake, increaseLiquidity\n    // Selectors: unlock=0, stake=1, increaseLiquidity=2\n    function execute(uint8 _selector, address _recipient, uint256 _amount0, uint256 _amount0Min, uint256 _amount1, uint256 _amount1Min) public {\n        // Original: unlock()\n        if (_selector == 0) {\n            if (msg.sender != factory) revert NotFactory();\n            delete staked;\n            delete lockedUntil;\n            IERC20(pool).safeTransfer({to: _recipient, value: _lp});\n            uint256 leftover = IERC20(token0).balanceOf({account: address(this)});\n            if (leftover > 0) IERC20(token0).safeTransfer({to: _recipient, value: leftover});\n            leftover = IERC20(token1).balanceOf({account: address(this)});\n            if (leftover > 0) IERC20(token1).safeTransfer({to: _recipient, value: leftover});\n            emit Unlocked({recipient: _recipient});\n            return _lp;\n        }\n        // Original: stake()\n        else if (_selector == 1) {\n            if (staked) revert AlreadyStaked();\n            staked = true;\n            _claimFees({_recipient: owner()});\n            IERC20(pool).safeIncreaseAllowance({spender: address(gauge), value: _lp});\n            gauge.deposit({lp: _lp});\n            emit Staked();\n        }\n        // Original: increaseLiquidity()\n        else if (_selector == 2) {\n            if (_amount0 == 0 && _amount1 == 0) revert ZeroAmount();\n            uint256 supplied0 = _fundLocker({_token: token0, _totalBal: _amount0});\n            uint256 supplied1 = _fundLocker({_token: token1, _totalBal: _amount1});\n            IERC20(token0).forceApprove({spender: router, value: _amount0});\n            IERC20(token1).forceApprove({spender: router, value: _amount1});\n            (uint256 amount0Deposited, uint256 amount1Deposited, uint256 liquidity) = IV2Router(router).addLiquidity({\n            tokenA: token0,\n            tokenB: token1,\n            stable: IV2Pool(pool).stable(),\n            amountADesired: _amount0,\n            amountBDesired: _amount1,\n            amountAMin: _amount0Min,\n            amountBMin: _amount1Min,\n            to: address(this),\n            deadline: block.timestamp\n            });\n            IERC20(token0).forceApprove({spender: router, value: 0});\n            IERC20(token1).forceApprove({spender: router, value: 0});\n            address recipient = owner();\n            _refundLeftover({_token: token0, _recipient: recipient, _maxAmount: supplied0});\n            _refundLeftover({_token: token1, _recipient: recipient, _maxAmount: supplied1});\n            if (staked) {\n            IERC20(pool).safeIncreaseAllowance({spender: address(gauge), value: liquidity});\n            gauge.deposit({lp: liquidity});\n            }\n            _lp += liquidity;\n            emit LiquidityIncreased({amount0: amount0Deposited, amount1: amount1Deposited, liquidity: liquidity});\n            return liquidity;\n        }\n    }\n}",
      "merged_functions": [
        "unlock",
        "stake",
        "increaseLiquidity"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: unlock, stake, increaseLiquidity"
      ],
      "function_to_selector": {
        "unlock": 0,
        "stake": 1,
        "increaseLiquidity": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_001",
      "transformed_id": "rs_mg_dis_nc_tc_001",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract BridgeReplica {\n\n    enum MessageStatus {\n        None,\n        Pending,\n        Processed\n    }\n\n\n    mapping(bytes32 => MessageStatus) public messages;\n\n\n    bytes32 public acceptedRoot;\n\n\n    address public bridgeRouter;\n\n\n    mapping(uint32 => uint32) public nonces;\n\n    event MessageProcessed(bytes32 indexed messageHash, bool success);\n\n    constructor(address _bridgeRouter) {\n        bridgeRouter = _bridgeRouter;\n    }\n\n\n    function process(bytes memory _message) external returns (bool success) {\n        bytes32 messageHash = keccak256(_message);\n\n\n        require(\n            messages[messageHash] != MessageStatus.Processed,\n            \"Already processed\"\n        );\n\n\n        bytes32 root = _messageRoot(_message);\n        require(root == acceptedRoot, \"Invalid root\");\n\n\n        messages[messageHash] = MessageStatus.Processed;\n\n\n        (bool routerSuccess, ) = bridgeRouter.call(_message);\n\n        emit MessageProcessed(messageHash, routerSuccess);\n        return routerSuccess;\n    }\n\n\n    function _messageRoot(\n        bytes memory _message\n    ) internal pure returns (bytes32) {\n\n        if (_message.length > 32 && uint256(bytes32(_message)) == 0) {\n            return bytes32(0);\n        }\n\n        return keccak256(_message);\n    }\n\n\n    function setAcceptedRoot(bytes32 _newRoot) external {\n        acceptedRoot = _newRoot;\n    }\n\n    // Unified dispatcher - merged from: process, setAcceptedRoot\n    // Selectors: process=0, setAcceptedRoot=1\n    function execute(uint8 _selector, bytes _message, bytes32 _newRoot) public {\n        // Original: process()\n        if (_selector == 0) {\n            bytes32 messageHash = keccak256(_message);\n            require(\n            messages[messageHash] != MessageStatus.Processed,\n            \"Already processed\"\n            );\n            bytes32 root = _messageRoot(_message);\n            require(root == acceptedRoot, \"Invalid root\");\n            messages[messageHash] = MessageStatus.Processed;\n            (bool routerSuccess, ) = bridgeRouter.call(_message);\n            emit MessageProcessed(messageHash, routerSuccess);\n            return routerSuccess;\n        }\n        // Original: setAcceptedRoot()\n        else if (_selector == 1) {\n            acceptedRoot = _newRoot;\n        }\n    }\n}",
      "merged_functions": [
        "process",
        "setAcceptedRoot"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: process, setAcceptedRoot"
      ],
      "function_to_selector": {
        "process": 0,
        "setAcceptedRoot": 1
      },
      "error": null
    },
    {
      "original_id": "nc_tc_002",
      "transformed_id": "rs_mg_dis_nc_tc_002",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IDiamondCut {\n    struct FacetCut {\n        address facetAddress;\n        uint8 action;\n        bytes4[] functionSelectors;\n    }\n}\n\ncontract GovernanceSystem {\n\n    mapping(address => uint256) public depositedBalance;\n    mapping(address => uint256) public votingPower;\n\n\n    struct Proposal {\n        address proposer;\n        address target;\n        bytes data;\n        uint256 forVotes;\n        uint256 startTime;\n        bool executed;\n    }\n\n    mapping(uint256 => Proposal) public proposals;\n    mapping(uint256 => mapping(address => bool)) public hasVoted;\n    uint256 public proposalCount;\n\n    uint256 public totalVotingPower;\n\n\n    uint256 constant EMERGENCY_THRESHOLD = 66;\n\n    event ProposalCreated(\n        uint256 indexed proposalId,\n        address proposer,\n        address target\n    );\n    event Voted(uint256 indexed proposalId, address voter, uint256 votes);\n    event ProposalExecuted(uint256 indexed proposalId);\n\n\n    function deposit(uint256 amount) external {\n        depositedBalance[msg.sender] += amount;\n        votingPower[msg.sender] += amount;\n        totalVotingPower += amount;\n    }\n\n\n    function propose(\n        IDiamondCut.FacetCut[] calldata,\n        address _target,\n        bytes calldata _calldata,\n        uint8\n    ) external returns (uint256) {\n        proposalCount++;\n\n        Proposal storage prop = proposals[proposalCount];\n        prop.proposer = msg.sender;\n        prop.target = _target;\n        prop.data = _calldata;\n        prop.startTime = block.timestamp;\n        prop.executed = false;\n\n\n        prop.forVotes = votingPower[msg.sender];\n        hasVoted[proposalCount][msg.sender] = true;\n\n        emit ProposalCreated(proposalCount, msg.sender, _target);\n        return proposalCount;\n    }\n\n\n    function vote(uint256 proposalId) external {\n        require(!hasVoted[proposalId][msg.sender], \"Already voted\");\n        require(!proposals[proposalId].executed, \"Already executed\");\n\n        proposals[proposalId].forVotes += votingPower[msg.sender];\n        hasVoted[proposalId][msg.sender] = true;\n\n        emit Voted(proposalId, msg.sender, votingPower[msg.sender]);\n    }\n\n\n    function emergencyCommit(uint256 proposalId) external {\n        Proposal storage prop = proposals[proposalId];\n        require(!prop.executed, \"Already executed\");\n\n        uint256 votePercentage = (prop.forVotes * 100) / totalVotingPower;\n        require(votePercentage >= EMERGENCY_THRESHOLD, \"Insufficient votes\");\n\n        prop.executed = true;\n\n\n        (bool success, ) = prop.target.call(prop.data);\n        require(success, \"Execution failed\");\n\n        emit ProposalExecuted(proposalId);\n    }\n\n    // Unified dispatcher - merged from: emergencyCommit, deposit, propose\n    // Selectors: emergencyCommit=0, deposit=1, propose=2\n    function execute(uint8 _selector, IDiamondCut.FacetCut[] calldata, address _target, bytes _calldata, uint256 amount, uint256 proposalId, uint8 ) public {\n        // Original: emergencyCommit()\n        if (_selector == 0) {\n            Proposal storage prop = proposals[proposalId];\n            require(!prop.executed, \"Already executed\");\n            uint256 votePercentage = (prop.forVotes * 100) / totalVotingPower;\n            require(votePercentage >= EMERGENCY_THRESHOLD, \"Insufficient votes\");\n            prop.executed = true;\n            (bool success, ) = prop.target.call(prop.data);\n            require(success, \"Execution failed\");\n            emit ProposalExecuted(proposalId);\n        }\n        // Original: deposit()\n        else if (_selector == 1) {\n            depositedBalance[msg.sender] += amount;\n            votingPower[msg.sender] += amount;\n            totalVotingPower += amount;\n        }\n        // Original: propose()\n        else if (_selector == 2) {\n            proposalCount++;\n            Proposal storage prop = proposals[proposalCount];\n            prop.proposer = msg.sender;\n            prop.target = _target;\n            prop.data = _calldata;\n            prop.startTime = block.timestamp;\n            prop.executed = false;\n            prop.forVotes = votingPower[msg.sender];\n            hasVoted[proposalCount][msg.sender] = true;\n            emit ProposalCreated(proposalCount, msg.sender, _target);\n            return proposalCount;\n        }\n    }\n}",
      "merged_functions": [
        "emergencyCommit",
        "deposit",
        "propose"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: emergencyCommit, deposit, propose"
      ],
      "function_to_selector": {
        "emergencyCommit": 0,
        "deposit": 1,
        "propose": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_003",
      "transformed_id": "rs_mg_dis_nc_tc_003",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract WalletLibrary {\n\n    mapping(address => bool) public isOwner;\n    address[] public owners;\n    uint256 public required;\n\n\n    bool public initialized;\n\n    event OwnerAdded(address indexed owner);\n    event WalletDestroyed(address indexed destroyer);\n\n\n    function initWallet(\n        address[] memory _owners,\n        uint256 _required,\n        uint256 _daylimit\n    ) public {\n\n        for (uint i = 0; i < owners.length; i++) {\n            isOwner[owners[i]] = false;\n        }\n        delete owners;\n\n\n        for (uint i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            require(owner != address(0), \"Invalid owner\");\n            require(!isOwner[owner], \"Duplicate owner\");\n\n            isOwner[owner] = true;\n            owners.push(owner);\n            emit OwnerAdded(owner);\n        }\n\n        required = _required;\n        initialized = true;\n    }\n\n\n    function isOwnerAddress(address _addr) public view returns (bool) {\n        return isOwner[_addr];\n    }\n\n\n    function kill(address payable _to) external {\n        require(isOwner[msg.sender], \"Not an owner\");\n\n        emit WalletDestroyed(msg.sender);\n\n        selfdestruct(_to);\n    }\n\n\n    function execute(address to, uint256 value, bytes memory data) external {\n        require(isOwner[msg.sender], \"Not an owner\");\n\n        (bool success, ) = to.call{value: value}(data);\n        require(success, \"Execution failed\");\n    }\n}\n\n\ncontract WalletProxy {\n    address public libraryAddress;\n\n    constructor(address _library) {\n        libraryAddress = _library;\n    }\n\n    fallback() external payable {\n        address lib = libraryAddress;\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let result := delegatecall(gas(), lib, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n\n    // Unified dispatcher - merged from: kill, initWallet, execute\n    // Selectors: kill=0, initWallet=1, execute=2\n    function execute(uint8 _selector, address to, address payable _to, address[] _owners, bytes data, uint256 _daylimit, uint256 _required, uint256 value) public {\n        // Original: kill()\n        if (_selector == 0) {\n            require(isOwner[msg.sender], \"Not an owner\");\n            emit WalletDestroyed(msg.sender);\n            selfdestruct(_to);\n        }\n        // Original: initWallet()\n        else if (_selector == 1) {\n            for (uint i = 0; i < owners.length; i++) {\n            isOwner[owners[i]] = false;\n            }\n            delete owners;\n            for (uint i = 0; i < _owners.length; i++) {\n            address owner = _owners[i];\n            require(owner != address(0), \"Invalid owner\");\n            require(!isOwner[owner], \"Duplicate owner\");\n            isOwner[owner] = true;\n            owners.push(owner);\n            emit OwnerAdded(owner);\n            }\n            required = _required;\n            initialized = true;\n        }\n        // Original: execute()\n        else if (_selector == 2) {\n            require(isOwner[msg.sender], \"Not an owner\");\n            (bool success, ) = to.call{value: value}(data);\n            require(success, \"Execution failed\");\n        }\n    }\n}",
      "merged_functions": [
        "kill",
        "initWallet",
        "execute"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: kill, initWallet, execute"
      ],
      "function_to_selector": {
        "kill": 0,
        "initWallet": 1,
        "execute": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_004",
      "transformed_id": "rs_mg_dis_nc_tc_004",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface ICurvePool {\n    function exchange_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external returns (uint256);\n\n    function get_dy_underlying(\n        int128 i,\n        int128 j,\n        uint256 dx\n    ) external view returns (uint256);\n}\n\ncontract YieldVault {\n    address public underlyingToken;\n    ICurvePool public curvePool;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n\n    uint256 public investedBalance;\n\n    event Deposit(address indexed user, uint256 amount, uint256 shares);\n    event Withdrawal(address indexed user, uint256 shares, uint256 amount);\n\n    constructor(address _token, address _curvePool) {\n        underlyingToken = _token;\n        curvePool = ICurvePool(_curvePool);\n    }\n\n\n    function deposit(uint256 amount) external returns (uint256 shares) {\n        require(amount > 0, \"Zero amount\");\n\n\n        if (totalSupply == 0) {\n            shares = amount;\n        } else {\n            uint256 totalAssets = getTotalAssets();\n            shares = (amount * totalSupply) / totalAssets;\n        }\n\n        balanceOf[msg.sender] += shares;\n        totalSupply += shares;\n\n\n        _investInCurve(amount);\n\n        emit Deposit(msg.sender, amount, shares);\n        return shares;\n    }\n\n\n    function withdraw(uint256 shares) external returns (uint256 amount) {\n        require(shares > 0, \"Zero shares\");\n        require(balanceOf[msg.sender] >= shares, \"Insufficient balance\");\n\n\n        uint256 totalAssets = getTotalAssets();\n        amount = (shares * totalAssets) / totalSupply;\n\n        balanceOf[msg.sender] -= shares;\n        totalSupply -= shares;\n\n\n        _withdrawFromCurve(amount);\n\n        emit Withdrawal(msg.sender, shares, amount);\n        return amount;\n    }\n\n\n    function getTotalAssets() public view returns (uint256) {\n        uint256 vaultBalance = 0;\n        uint256 curveBalance = investedBalance;\n\n        return vaultBalance + curveBalance;\n    }\n\n\n    function getPricePerFullShare() public view returns (uint256) {\n        if (totalSupply == 0) return 1e18;\n        return (getTotalAssets() * 1e18) / totalSupply;\n    }\n\n\n    function _investInCurve(uint256 amount) internal {\n        investedBalance += amount;\n    }\n\n\n    function _withdrawFromCurve(uint256 amount) internal {\n        require(investedBalance >= amount, \"Insufficient invested\");\n        investedBalance -= amount;\n    }\n\n    // Unified dispatcher - merged from: deposit, withdraw\n    // Selectors: deposit=1, withdraw=2\n    function execute(uint8 _selector, uint256 amount, uint256 shares) public {\n        // Original: deposit()\n        if (_selector == 0) {\n            require(amount > 0, \"Zero amount\");\n            if (totalSupply == 0) {\n            shares = amount;\n            } else {\n            uint256 totalAssets = getTotalAssets();\n            shares = (amount * totalSupply) / totalAssets;\n            }\n            balanceOf[msg.sender] += shares;\n            totalSupply += shares;\n            _investInCurve(amount);\n            emit Deposit(msg.sender, amount, shares);\n            return shares;\n        }\n        // Original: withdraw()\n        else if (_selector == 1) {\n            require(shares > 0, \"Zero shares\");\n            require(balanceOf[msg.sender] >= shares, \"Insufficient balance\");\n            uint256 totalAssets = getTotalAssets();\n            amount = (shares * totalAssets) / totalSupply;\n            balanceOf[msg.sender] -= shares;\n            totalSupply -= shares;\n            _withdrawFromCurve(amount);\n            emit Withdrawal(msg.sender, shares, amount);\n            return amount;\n        }\n    }\n}",
      "merged_functions": [
        "deposit",
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: deposit, withdraw"
      ],
      "function_to_selector": {
        "deposit": 1,
        "withdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_005",
      "transformed_id": "rs_mg_dis_nc_tc_005",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract AMMPool {\n\n    mapping(uint256 => uint256) public balances;\n\n\n    mapping(address => uint256) public lpBalances;\n    uint256 public totalLPSupply;\n\n    uint256 private _status;\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    event LiquidityAdded(\n        address indexed provider,\n        uint256[2] amounts,\n        uint256 lpMinted\n    );\n    event LiquidityRemoved(\n        address indexed provider,\n        uint256 lpBurned,\n        uint256[2] amounts\n    );\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n\n    function add_liquidity(\n        uint256[2] memory amounts,\n        uint256 min_mint_amount\n    ) external payable returns (uint256) {\n        require(amounts[0] == msg.value, \"ETH amount mismatch\");\n\n\n        uint256 lpToMint;\n        if (totalLPSupply == 0) {\n            lpToMint = amounts[0] + amounts[1];\n        } else {\n            uint256 totalValue = balances[0] + balances[1];\n            lpToMint = ((amounts[0] + amounts[1]) * totalLPSupply) / totalValue;\n        }\n\n        require(lpToMint >= min_mint_amount, \"Slippage\");\n\n\n        balances[0] += amounts[0];\n        balances[1] += amounts[1];\n\n\n        lpBalances[msg.sender] += lpToMint;\n        totalLPSupply += lpToMint;\n\n\n        if (amounts[0] > 0) {\n            _handleETHTransfer(amounts[0]);\n        }\n\n        emit LiquidityAdded(msg.sender, amounts, lpToMint);\n        return lpToMint;\n    }\n\n\n    function remove_liquidity(\n        uint256 lpAmount,\n        uint256[2] memory min_amounts\n    ) external {\n        require(lpBalances[msg.sender] >= lpAmount, \"Insufficient LP\");\n\n\n        uint256 amount0 = (lpAmount * balances[0]) / totalLPSupply;\n        uint256 amount1 = (lpAmount * balances[1]) / totalLPSupply;\n\n        require(\n            amount0 >= min_amounts[0] && amount1 >= min_amounts[1],\n            \"Slippage\"\n        );\n\n\n        lpBalances[msg.sender] -= lpAmount;\n        totalLPSupply -= lpAmount;\n\n\n        balances[0] -= amount0;\n        balances[1] -= amount1;\n\n\n        if (amount0 > 0) {\n            payable(msg.sender).transfer(amount0);\n        }\n\n        uint256[2] memory amounts = [amount0, amount1];\n        emit LiquidityRemoved(msg.sender, lpAmount, amounts);\n    }\n\n\n    function _handleETHTransfer(uint256 amount) internal {\n        (bool success, ) = msg.sender.call{value: 0}(\"\");\n        require(success, \"Transfer failed\");\n    }\n\n\n    function exchange(\n        int128 i,\n        int128 j,\n        uint256 dx,\n        uint256 min_dy\n    ) external payable returns (uint256) {\n        uint256 ui = uint256(int256(i));\n        uint256 uj = uint256(int256(j));\n\n        require(ui < 2 && uj < 2 && ui != uj, \"Invalid indices\");\n\n\n        uint256 dy = (dx * balances[uj]) / (balances[ui] + dx);\n        require(dy >= min_dy, \"Slippage\");\n\n        if (ui == 0) {\n            require(msg.value == dx, \"ETH mismatch\");\n            balances[0] += dx;\n        }\n\n        balances[ui] += dx;\n        balances[uj] -= dy;\n\n        if (uj == 0) {\n            payable(msg.sender).transfer(dy);\n        }\n\n        return dy;\n    }\n\n    receive() external payable {}\n\n    // Unified dispatcher - merged from: add_liquidity, remove_liquidity, exchange\n    // Selectors: add_liquidity=0, remove_liquidity=1, exchange=2\n    function execute(uint8 _selector, int128 i, int128 j, uint256 dx, uint256 lpAmount, uint256 min_dy, uint256 min_mint_amount, uint256[2] amounts, uint256[2] min_amounts) public payable {\n        // Original: add_liquidity()\n        if (_selector == 0) {\n            require(amounts[0] == msg.value, \"ETH amount mismatch\");\n            uint256 lpToMint;\n            if (totalLPSupply == 0) {\n            lpToMint = amounts[0] + amounts[1];\n            } else {\n            uint256 totalValue = balances[0] + balances[1];\n            lpToMint = ((amounts[0] + amounts[1]) * totalLPSupply) / totalValue;\n            }\n            require(lpToMint >= min_mint_amount, \"Slippage\");\n            balances[0] += amounts[0];\n            balances[1] += amounts[1];\n            lpBalances[msg.sender] += lpToMint;\n            totalLPSupply += lpToMint;\n            if (amounts[0] > 0) {\n            _handleETHTransfer(amounts[0]);\n            }\n            emit LiquidityAdded(msg.sender, amounts, lpToMint);\n            return lpToMint;\n        }\n        // Original: remove_liquidity()\n        else if (_selector == 1) {\n            require(lpBalances[msg.sender] >= lpAmount, \"Insufficient LP\");\n            uint256 amount0 = (lpAmount * balances[0]) / totalLPSupply;\n            uint256 amount1 = (lpAmount * balances[1]) / totalLPSupply;\n            require(\n            amount0 >= min_amounts[0] && amount1 >= min_amounts[1],\n            \"Slippage\"\n            );\n            lpBalances[msg.sender] -= lpAmount;\n            totalLPSupply -= lpAmount;\n            balances[0] -= amount0;\n            balances[1] -= amount1;\n            if (amount0 > 0) {\n            payable(msg.sender).transfer(amount0);\n            }\n            uint256[2] memory amounts = [amount0, amount1];\n            emit LiquidityRemoved(msg.sender, lpAmount, amounts);\n        }\n        // Original: exchange()\n        else if (_selector == 2) {\n            uint256 ui = uint256(int256(i));\n            uint256 uj = uint256(int256(j));\n            require(ui < 2 && uj < 2 && ui != uj, \"Invalid indices\");\n            uint256 dy = (dx * balances[uj]) / (balances[ui] + dx);\n            require(dy >= min_dy, \"Slippage\");\n            if (ui == 0) {\n            require(msg.value == dx, \"ETH mismatch\");\n            balances[0] += dx;\n            }\n            balances[ui] += dx;\n            balances[uj] -= dy;\n            if (uj == 0) {\n            payable(msg.sender).transfer(dy);\n            }\n            return dy;\n        }\n    }\n}",
      "merged_functions": [
        "add_liquidity",
        "remove_liquidity",
        "exchange"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: add_liquidity, remove_liquidity, exchange"
      ],
      "function_to_selector": {
        "add_liquidity": 0,
        "remove_liquidity": 1,
        "exchange": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_006",
      "transformed_id": "rs_mg_dis_nc_tc_006",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract CrossChainBridge {\n\n    address[] public validators;\n    mapping(address => bool) public isValidator;\n\n    uint256 public requiredSignatures = 5;\n    uint256 public validatorCount;\n\n\n    mapping(uint256 => bool) public processedWithdrawals;\n\n\n    mapping(address => bool) public supportedTokens;\n\n    event WithdrawalProcessed(\n        uint256 indexed withdrawalId,\n        address indexed user,\n        address indexed token,\n        uint256 amount\n    );\n\n    constructor(address[] memory _validators) {\n        require(\n            _validators.length >= requiredSignatures,\n            \"Not enough validators\"\n        );\n\n        for (uint256 i = 0; i < _validators.length; i++) {\n            address validator = _validators[i];\n            require(validator != address(0), \"Invalid validator\");\n            require(!isValidator[validator], \"Duplicate validator\");\n\n            validators.push(validator);\n            isValidator[validator] = true;\n        }\n\n        validatorCount = _validators.length;\n    }\n\n\n    function withdrawERC20For(\n        uint256 _withdrawalId,\n        address _user,\n        address _token,\n        uint256 _amount,\n        bytes memory _signatures\n    ) external {\n\n        require(!processedWithdrawals[_withdrawalId], \"Already processed\");\n\n\n        require(supportedTokens[_token], \"Token not supported\");\n\n\n        require(\n            _verifySignatures(\n                _withdrawalId,\n                _user,\n                _token,\n                _amount,\n                _signatures\n            ),\n            \"Invalid signatures\"\n        );\n\n\n        processedWithdrawals[_withdrawalId] = true;\n\n\n        emit WithdrawalProcessed(_withdrawalId, _user, _token, _amount);\n    }\n\n\n    function _verifySignatures(\n        uint256 _withdrawalId,\n        address _user,\n        address _token,\n        uint256 _amount,\n        bytes memory _signatures\n    ) internal view returns (bool) {\n        require(_signatures.length % 65 == 0, \"Invalid signature length\");\n\n        uint256 signatureCount = _signatures.length / 65;\n        require(signatureCount >= requiredSignatures, \"Not enough signatures\");\n\n\n        bytes32 messageHash = keccak256(\n            abi.encodePacked(_withdrawalId, _user, _token, _amount)\n        );\n        bytes32 ethSignedMessageHash = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", messageHash)\n        );\n\n        address[] memory signers = new address[](signatureCount);\n\n\n        for (uint256 i = 0; i < signatureCount; i++) {\n            bytes memory signature = _extractSignature(_signatures, i);\n            address signer = _recoverSigner(ethSignedMessageHash, signature);\n\n\n            require(isValidator[signer], \"Invalid signer\");\n\n\n            for (uint256 j = 0; j < i; j++) {\n                require(signers[j] != signer, \"Duplicate signer\");\n            }\n\n            signers[i] = signer;\n        }\n\n\n        return true;\n    }\n\n\n    function _extractSignature(\n        bytes memory _signatures,\n        uint256 _index\n    ) internal pure returns (bytes memory) {\n        bytes memory signature = new bytes(65);\n        uint256 offset = _index * 65;\n\n        for (uint256 i = 0; i < 65; i++) {\n            signature[i] = _signatures[offset + i];\n        }\n\n        return signature;\n    }\n\n\n    function _recoverSigner(\n        bytes32 _hash,\n        bytes memory _signature\n    ) internal pure returns (address) {\n        require(_signature.length == 65, \"Invalid signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(_signature, 32))\n            s := mload(add(_signature, 64))\n            v := byte(0, mload(add(_signature, 96)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28, \"Invalid signature v value\");\n\n        return ecrecover(_hash, v, r, s);\n    }\n\n\n    function addSupportedToken(address _token) external {\n        supportedTokens[_token] = true;\n    }\n\n    // Unified dispatcher - merged from: withdrawERC20For, addSupportedToken\n    // Selectors: withdrawERC20For=0, addSupportedToken=1\n    function execute(uint8 _selector, address _token, address _user, bytes _signatures, uint256 _amount, uint256 _withdrawalId) public {\n        // Original: withdrawERC20For()\n        if (_selector == 0) {\n            require(!processedWithdrawals[_withdrawalId], \"Already processed\");\n            require(supportedTokens[_token], \"Token not supported\");\n            require(\n            _verifySignatures(\n            _withdrawalId,\n            _user,\n            _token,\n            _amount,\n            _signatures\n            ),\n            \"Invalid signatures\"\n            );\n            processedWithdrawals[_withdrawalId] = true;\n            emit WithdrawalProcessed(_withdrawalId, _user, _token, _amount);\n        }\n        // Original: addSupportedToken()\n        else if (_selector == 1) {\n            supportedTokens[_token] = true;\n        }\n    }\n}",
      "merged_functions": [
        "withdrawERC20For",
        "addSupportedToken"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: withdrawERC20For, addSupportedToken"
      ],
      "function_to_selector": {
        "withdrawERC20For": 0,
        "addSupportedToken": 1
      },
      "error": null
    },
    {
      "original_id": "nc_tc_007",
      "transformed_id": "rs_mg_dis_nc_tc_007",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface ICrossChainData {\n    function transferOwnership(address newOwner) external;\n\n    function putCurEpochConPubKeyBytes(\n        bytes calldata curEpochPkBytes\n    ) external returns (bool);\n\n    function getCurEpochConPubKeyBytes() external view returns (bytes memory);\n}\n\ncontract CrossChainData {\n    address public owner;\n    bytes public currentEpochPublicKeys;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    event PublicKeysUpdated(bytes newKeys);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n\n    function putCurEpochConPubKeyBytes(\n        bytes calldata curEpochPkBytes\n    ) external onlyOwner returns (bool) {\n        currentEpochPublicKeys = curEpochPkBytes;\n        emit PublicKeysUpdated(curEpochPkBytes);\n        return true;\n    }\n\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid address\");\n        emit OwnershipTransferred(owner, newOwner);\n        owner = newOwner;\n    }\n\n    function getCurEpochConPubKeyBytes() external view returns (bytes memory) {\n        return currentEpochPublicKeys;\n    }\n}\n\ncontract CrossChainManager {\n    address public dataContract;\n\n    event CrossChainEvent(\n        address indexed fromContract,\n        bytes toContract,\n        bytes method\n    );\n\n    constructor(address _dataContract) {\n        dataContract = _dataContract;\n    }\n\n\n    function verifyHeaderAndExecuteTx(\n        bytes memory proof,\n        bytes memory rawHeader,\n        bytes memory headerProof,\n        bytes memory curRawHeader,\n        bytes memory headerSig\n    ) external returns (bool) {\n\n        require(_verifyHeader(rawHeader, headerSig), \"Invalid header\");\n\n\n        require(_verifyProof(proof, rawHeader), \"Invalid proof\");\n\n\n        (\n            address toContract,\n            bytes memory method,\n            bytes memory args\n        ) = _decodeTx(proof);\n\n\n        (bool success, ) = toContract.call(abi.encodePacked(method, args));\n        require(success, \"Execution failed\");\n\n        return true;\n    }\n\n\n    function _verifyHeader(\n        bytes memory rawHeader,\n        bytes memory headerSig\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n\n    function _verifyProof(\n        bytes memory proof,\n        bytes memory rawHeader\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n\n    function _decodeTx(\n        bytes memory proof\n    )\n        internal\n        view\n        returns (address toContract, bytes memory method, bytes memory args)\n    {\n        toContract = dataContract;\n        method = abi.encodeWithSignature(\n            \"putCurEpochConPubKeyBytes(bytes)\",\n            \"\"\n        );\n        args = \"\";\n    }\n\n    // Unified dispatcher - merged from: verifyHeaderAndExecuteTx\n    // Selectors: verifyHeaderAndExecuteTx=0\n    function execute(uint8 _selector, bytes curRawHeader, bytes headerProof, bytes headerSig, bytes proof, bytes rawHeader) public {\n        // Original: verifyHeaderAndExecuteTx()\n        if (_selector == 0) {\n            require(_verifyHeader(rawHeader, headerSig), \"Invalid header\");\n            require(_verifyProof(proof, rawHeader), \"Invalid proof\");\n            (\n            address toContract,\n            bytes memory method,\n            bytes memory args\n            ) = _decodeTx(proof);\n            (bool success, ) = toContract.call(abi.encodePacked(method, args));\n            require(success, \"Execution failed\");\n            return true;\n        }\n    }\n}",
      "merged_functions": [
        "verifyHeaderAndExecuteTx"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: verifyHeaderAndExecuteTx"
      ],
      "function_to_selector": {
        "verifyHeaderAndExecuteTx": 0
      },
      "error": null
    },
    {
      "original_id": "nc_tc_008",
      "transformed_id": "rs_mg_dis_nc_tc_008",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_009",
      "transformed_id": "rs_mg_dis_nc_tc_009",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract ConcentratedLiquidityPool {\n\n    address public token0;\n    address public token1;\n\n\n    uint160 public sqrtPriceX96;\n    int24 public currentTick;\n    uint128 public liquidity;\n\n\n    mapping(int24 => int128) public liquidityNet;\n\n\n    struct Position {\n        uint128 liquidity;\n        int24 tickLower;\n        int24 tickUpper;\n    }\n\n    mapping(bytes32 => Position) public positions;\n\n    event Swap(\n        address indexed sender,\n        uint256 amount0In,\n        uint256 amount1In,\n        uint256 amount0Out,\n        uint256 amount1Out\n    );\n\n    event LiquidityAdded(\n        address indexed provider,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity\n    );\n\n\n    function addLiquidity(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidityDelta\n    ) external returns (uint256 amount0, uint256 amount1) {\n        require(tickLower < tickUpper, \"Invalid ticks\");\n        require(liquidityDelta > 0, \"Zero liquidity\");\n\n\n        bytes32 positionKey = keccak256(\n            abi.encodePacked(msg.sender, tickLower, tickUpper)\n        );\n\n\n        Position storage position = positions[positionKey];\n        position.liquidity += liquidityDelta;\n        position.tickLower = tickLower;\n        position.tickUpper = tickUpper;\n\n\n        liquidityNet[tickLower] += int128(liquidityDelta);\n        liquidityNet[tickUpper] -= int128(liquidityDelta);\n\n\n        if (currentTick >= tickLower && currentTick < tickUpper) {\n            liquidity += liquidityDelta;\n        }\n\n\n        (amount0, amount1) = _calculateAmounts(\n            sqrtPriceX96,\n            tickLower,\n            tickUpper,\n            int128(liquidityDelta)\n        );\n\n        emit LiquidityAdded(msg.sender, tickLower, tickUpper, liquidityDelta);\n    }\n\n\n    function swap(\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96\n    ) external returns (int256 amount0, int256 amount1) {\n        require(amountSpecified != 0, \"Zero amount\");\n\n\n        uint160 sqrtPriceX96Next = sqrtPriceX96;\n        uint128 liquidityNext = liquidity;\n        int24 tickNext = currentTick;\n\n\n        while (amountSpecified != 0) {\n\n            (\n                uint256 amountIn,\n                uint256 amountOut,\n                uint160 sqrtPriceX96Target\n            ) = _computeSwapStep(\n                    sqrtPriceX96Next,\n                    sqrtPriceLimitX96,\n                    liquidityNext,\n                    amountSpecified\n                );\n\n\n            sqrtPriceX96Next = sqrtPriceX96Target;\n\n\n            int24 tickCrossed = _getTickAtSqrtRatio(sqrtPriceX96Next);\n            if (tickCrossed != tickNext) {\n\n                int128 liquidityNetAtTick = liquidityNet[tickCrossed];\n\n                if (zeroForOne) {\n                    liquidityNetAtTick = -liquidityNetAtTick;\n                }\n\n                liquidityNext = _addLiquidity(\n                    liquidityNext,\n                    liquidityNetAtTick\n                );\n\n                tickNext = tickCrossed;\n            }\n\n\n            if (amountSpecified > 0) {\n                amountSpecified -= int256(amountIn);\n            } else {\n                amountSpecified += int256(amountOut);\n            }\n        }\n\n\n        sqrtPriceX96 = sqrtPriceX96Next;\n        liquidity = liquidityNext;\n        currentTick = tickNext;\n\n        return (amount0, amount1);\n    }\n\n\n    function _addLiquidity(\n        uint128 x,\n        int128 y\n    ) internal pure returns (uint128 z) {\n        if (y < 0) {\n            z = x - uint128(-y);\n        } else {\n            z = x + uint128(y);\n        }\n    }\n\n\n    function _calculateAmounts(\n        uint160 sqrtPrice,\n        int24 tickLower,\n        int24 tickUpper,\n        int128 liquidityDelta\n    ) internal pure returns (uint256 amount0, uint256 amount1) {\n        amount0 = uint256(uint128(liquidityDelta)) / 2;\n        amount1 = uint256(uint128(liquidityDelta)) / 2;\n    }\n\n\n    function _computeSwapStep(\n        uint160 sqrtPriceCurrentX96,\n        uint160 sqrtPriceTargetX96,\n        uint128 liquidityCurrent,\n        int256 amountRemaining\n    )\n        internal\n        pure\n        returns (uint256 amountIn, uint256 amountOut, uint160 sqrtPriceNextX96)\n    {\n        amountIn =\n            uint256(amountRemaining > 0 ? amountRemaining : -amountRemaining) /\n            2;\n        amountOut = amountIn;\n        sqrtPriceNextX96 = sqrtPriceCurrentX96;\n    }\n\n\n    function _getTickAtSqrtRatio(\n        uint160 sqrtPriceX96\n    ) internal pure returns (int24 tick) {\n        return int24(int256(uint256(sqrtPriceX96 >> 96)));\n    }\n\n    // Unified dispatcher - merged from: addLiquidity, swap\n    // Selectors: addLiquidity=0, swap=1\n    function execute(uint8 _selector, bool zeroForOne, int24 tickLower, int24 tickUpper, int256 amountSpecified, uint128 liquidityDelta, uint160 sqrtPriceLimitX96) public {\n        // Original: addLiquidity()\n        if (_selector == 0) {\n            require(tickLower < tickUpper, \"Invalid ticks\");\n            require(liquidityDelta > 0, \"Zero liquidity\");\n            bytes32 positionKey = keccak256(\n            abi.encodePacked(msg.sender, tickLower, tickUpper)\n            );\n            Position storage position = positions[positionKey];\n            position.liquidity += liquidityDelta;\n            position.tickLower = tickLower;\n            position.tickUpper = tickUpper;\n            liquidityNet[tickLower] += int128(liquidityDelta);\n            liquidityNet[tickUpper] -= int128(liquidityDelta);\n            if (currentTick >= tickLower && currentTick < tickUpper) {\n            liquidity += liquidityDelta;\n            }\n            (amount0, amount1) = _calculateAmounts(\n            sqrtPriceX96,\n            tickLower,\n            tickUpper,\n            int128(liquidityDelta)\n            );\n            emit LiquidityAdded(msg.sender, tickLower, tickUpper, liquidityDelta);\n        }\n        // Original: swap()\n        else if (_selector == 1) {\n            require(amountSpecified != 0, \"Zero amount\");\n            uint160 sqrtPriceX96Next = sqrtPriceX96;\n            uint128 liquidityNext = liquidity;\n            int24 tickNext = currentTick;\n            while (amountSpecified != 0) {\n            (\n            uint256 amountIn,\n            uint256 amountOut,\n            uint160 sqrtPriceX96Target\n            ) = _computeSwapStep(\n            sqrtPriceX96Next,\n            sqrtPriceLimitX96,\n            liquidityNext,\n            amountSpecified\n            );\n            sqrtPriceX96Next = sqrtPriceX96Target;\n            int24 tickCrossed = _getTickAtSqrtRatio(sqrtPriceX96Next);\n            if (tickCrossed != tickNext) {\n            int128 liquidityNetAtTick = liquidityNet[tickCrossed];\n            if (zeroForOne) {\n            liquidityNetAtTick = -liquidityNetAtTick;\n            }\n            liquidityNext = _addLiquidity(\n            liquidityNext,\n            liquidityNetAtTick\n            );\n            tickNext = tickCrossed;\n            }\n            if (amountSpecified > 0) {\n            amountSpecified -= int256(amountIn);\n            } else {\n            amountSpecified += int256(amountOut);\n            }\n            }\n            sqrtPriceX96 = sqrtPriceX96Next;\n            liquidity = liquidityNext;\n            currentTick = tickNext;\n            return (amount0, amount1);\n        }\n    }\n}",
      "merged_functions": [
        "addLiquidity",
        "swap"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: addLiquidity, swap"
      ],
      "function_to_selector": {
        "addLiquidity": 0,
        "swap": 1
      },
      "error": null
    },
    {
      "original_id": "nc_tc_010",
      "transformed_id": "rs_mg_dis_nc_tc_010",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\n\ncontract CreditSystem {\n    mapping(address => uint256) public credit;\n    uint256 public balance;\n\n    function deposit() public payable {\n        credit[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n\n    function withdrawAll() public {\n        uint256 oCredit = credit[msg.sender];\n        if (oCredit > 0) {\n            balance -= oCredit;\n            bool callResult = msg.sender.call.value(oCredit)();\n            require(callResult);\n            credit[msg.sender] = 0;\n        }\n    }\n\n    function getCredit(address user) public view returns (uint256) {\n        return credit[user];\n    }\n\n    // Unified dispatcher - merged from: withdrawAll, deposit\n    // Selectors: withdrawAll=0, deposit=1\n    function execute(uint8 _selector) public payable {\n        // Original: withdrawAll()\n        if (_selector == 0) {\n            uint256 oCredit = credit[msg.sender];\n            if (oCredit > 0) {\n            balance -= oCredit;\n            bool callResult = msg.sender.call.value(oCredit)();\n            require(callResult);\n            credit[msg.sender] = 0;\n            }\n        }\n        // Original: deposit()\n        else if (_selector == 1) {\n            credit[msg.sender] += msg.value;\n            balance += msg.value;\n        }\n    }\n}",
      "merged_functions": [
        "withdrawAll",
        "deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: withdrawAll, deposit"
      ],
      "function_to_selector": {
        "withdrawAll": 0,
        "deposit": 1
      },
      "error": null
    },
    {
      "original_id": "nc_tc_011",
      "transformed_id": "rs_mg_dis_nc_tc_011",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC777 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IERC1820Registry {\n    function setInterfaceImplementer(\n        address account,\n        bytes32 interfaceHash,\n        address implementer\n    ) external;\n}\n\ncontract LendingPool {\n    mapping(address => mapping(address => uint256)) public supplied;\n    mapping(address => uint256) public totalSupplied;\n\n    function supply(address asset, uint256 amount) external returns (uint256) {\n        IERC777 token = IERC777(asset);\n\n        require(token.transfer(address(this), amount), \"Transfer failed\");\n\n        supplied[msg.sender][asset] += amount;\n        totalSupplied[asset] += amount;\n\n        return amount;\n    }\n\n    function withdraw(\n        address asset,\n        uint256 requestedAmount\n    ) external returns (uint256) {\n        uint256 userBalance = supplied[msg.sender][asset];\n        require(userBalance > 0, \"No balance\");\n\n        uint256 withdrawAmount = requestedAmount;\n        if (requestedAmount == type(uint256).max) {\n            withdrawAmount = userBalance;\n        }\n        require(withdrawAmount <= userBalance, \"Insufficient balance\");\n\n        IERC777(asset).transfer(msg.sender, withdrawAmount);\n\n        supplied[msg.sender][asset] -= withdrawAmount;\n        totalSupplied[asset] -= withdrawAmount;\n\n        return withdrawAmount;\n    }\n\n    function getSupplied(\n        address user,\n        address asset\n    ) external view returns (uint256) {\n        return supplied[user][asset];\n    }\n\n    // Unified dispatcher - merged from: withdraw\n    // Selectors: withdraw=0\n    function execute(uint8 _selector, address asset, uint256 requestedAmount) public {\n        // Original: withdraw()\n        if (_selector == 0) {\n            uint256 userBalance = supplied[msg.sender][asset];\n            require(userBalance > 0, \"No balance\");\n            uint256 withdrawAmount = requestedAmount;\n            if (requestedAmount == type(uint256).max) {\n            withdrawAmount = userBalance;\n            }\n            require(withdrawAmount <= userBalance, \"Insufficient balance\");\n            IERC777(asset).transfer(msg.sender, withdrawAmount);\n            supplied[msg.sender][asset] -= withdrawAmount;\n            totalSupplied[asset] -= withdrawAmount;\n            return withdrawAmount;\n        }\n    }\n}",
      "merged_functions": [
        "withdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: withdraw"
      ],
      "function_to_selector": {
        "withdraw": 0
      },
      "error": null
    },
    {
      "original_id": "nc_tc_012",
      "transformed_id": "rs_mg_dis_nc_tc_012",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IComptroller {\n    function enterMarkets(\n        address[] memory cTokens\n    ) external returns (uint256[] memory);\n\n    function exitMarket(address cToken) external returns (uint256);\n\n    function getAccountLiquidity(\n        address account\n    ) external view returns (uint256, uint256, uint256);\n}\n\ncontract LendingProtocol {\n    IComptroller public comptroller;\n\n    mapping(address => uint256) public deposits;\n    mapping(address => uint256) public borrowed;\n    mapping(address => bool) public inMarket;\n\n    uint256 public totalDeposits;\n    uint256 public totalBorrowed;\n    uint256 public constant COLLATERAL_FACTOR = 150;\n\n    constructor(address _comptroller) {\n        comptroller = IComptroller(_comptroller);\n    }\n\n    function depositAndEnterMarket() external payable {\n        deposits[msg.sender] += msg.value;\n        totalDeposits += msg.value;\n        inMarket[msg.sender] = true;\n    }\n\n    function isHealthy(\n        address account,\n        uint256 additionalBorrow\n    ) public view returns (bool) {\n        uint256 totalDebt = borrowed[account] + additionalBorrow;\n        if (totalDebt == 0) return true;\n\n        if (!inMarket[account]) return false;\n\n        uint256 collateralValue = deposits[account];\n        return collateralValue >= (totalDebt * COLLATERAL_FACTOR) / 100;\n    }\n\n    function borrow(uint256 amount) external {\n        require(amount > 0, \"Invalid amount\");\n        require(address(this).balance >= amount, \"Insufficient funds\");\n\n        require(isHealthy(msg.sender, amount), \"Insufficient collateral\");\n\n        borrowed[msg.sender] += amount;\n        totalBorrowed += amount;\n\n        (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n        require(success, \"Transfer failed\");\n\n        require(isHealthy(msg.sender, 0), \"Health check failed\");\n    }\n\n    function exitMarket() external {\n        require(borrowed[msg.sender] == 0, \"Outstanding debt\");\n        inMarket[msg.sender] = false;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(deposits[msg.sender] >= amount, \"Insufficient deposits\");\n        require(!inMarket[msg.sender], \"Exit market first\");\n\n        deposits[msg.sender] -= amount;\n        totalDeposits -= amount;\n\n        payable(msg.sender).transfer(amount);\n    }\n\n    receive() external payable {}\n\n    // Unified dispatcher - merged from: borrow\n    // Selectors: borrow=0\n    function execute(uint8 _selector, uint256 amount) public {\n        // Original: borrow()\n        if (_selector == 0) {\n            require(amount > 0, \"Invalid amount\");\n            require(address(this).balance >= amount, \"Insufficient funds\");\n            require(isHealthy(msg.sender, amount), \"Insufficient collateral\");\n            borrowed[msg.sender] += amount;\n            totalBorrowed += amount;\n            (bool success, ) = payable(msg.sender).call{value: amount}(\"\");\n            require(success, \"Transfer failed\");\n            require(isHealthy(msg.sender, 0), \"Health check failed\");\n        }\n    }\n}",
      "merged_functions": [
        "borrow"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: borrow"
      ],
      "function_to_selector": {
        "borrow": 0
      },
      "error": null
    },
    {
      "original_id": "nc_tc_013",
      "transformed_id": "rs_mg_dis_nc_tc_013",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IPancakeRouter {\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n\ncontract RewardMinter {\n    IERC20 public lpToken;\n    IERC20 public rewardToken;\n\n    mapping(address => uint256) public depositedLP;\n    mapping(address => uint256) public earnedRewards;\n\n    uint256 public constant REWARD_RATE = 100;\n\n    constructor(address _lpToken, address _rewardToken) {\n        lpToken = IERC20(_lpToken);\n        rewardToken = IERC20(_rewardToken);\n    }\n\n    function deposit(uint256 amount) external {\n        lpToken.transferFrom(msg.sender, address(this), amount);\n        depositedLP[msg.sender] += amount;\n    }\n\n    function mintFor(\n        address flip,\n        uint256 _withdrawalFee,\n        uint256 _performanceFee,\n        address to,\n        uint256\n    ) external {\n        require(flip == address(lpToken), \"Invalid token\");\n\n        uint256 feeSum = _performanceFee + _withdrawalFee;\n        lpToken.transferFrom(msg.sender, address(this), feeSum);\n\n        uint256 hunnyRewardAmount = tokenToReward(\n            lpToken.balanceOf(address(this))\n        );\n\n        earnedRewards[to] += hunnyRewardAmount;\n    }\n\n    function tokenToReward(uint256 lpAmount) internal pure returns (uint256) {\n        return lpAmount * REWARD_RATE;\n    }\n\n    function getReward() external {\n        uint256 reward = earnedRewards[msg.sender];\n        require(reward > 0, \"No rewards\");\n\n        earnedRewards[msg.sender] = 0;\n        rewardToken.transfer(msg.sender, reward);\n    }\n\n    function withdraw(uint256 amount) external {\n        require(depositedLP[msg.sender] >= amount, \"Insufficient balance\");\n        depositedLP[msg.sender] -= amount;\n        lpToken.transfer(msg.sender, amount);\n    }\n\n    // Unified dispatcher - merged from: mintFor\n    // Selectors: mintFor=0\n    function execute(uint8 _selector, address flip, address to, uint256 , uint256 _performanceFee, uint256 _withdrawalFee) public {\n        // Original: mintFor()\n        if (_selector == 0) {\n            require(flip == address(lpToken), \"Invalid token\");\n            uint256 feeSum = _performanceFee + _withdrawalFee;\n            lpToken.transferFrom(msg.sender, address(this), feeSum);\n            uint256 hunnyRewardAmount = tokenToReward(\n            lpToken.balanceOf(address(this))\n            );\n            earnedRewards[to] += hunnyRewardAmount;\n        }\n    }\n}",
      "merged_functions": [
        "mintFor"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: mintFor"
      ],
      "function_to_selector": {
        "mintFor": 0
      },
      "error": null
    },
    {
      "original_id": "nc_tc_014",
      "transformed_id": "rs_mg_dis_nc_tc_014",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface ICurve3Pool {\n    function add_liquidity(\n        uint256[3] memory amounts,\n        uint256 min_mint_amount\n    ) external;\n\n    function remove_liquidity_imbalance(\n        uint256[3] memory amounts,\n        uint256 max_burn_amount\n    ) external;\n\n    function get_virtual_price() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n}\n\ncontract YieldVault {\n    IERC20 public dai;\n    IERC20 public crv3;\n    ICurve3Pool public curve3Pool;\n\n    mapping(address => uint256) public shares;\n    uint256 public totalShares;\n    uint256 public totalDeposits;\n\n    uint256 public constant MIN_EARN_THRESHOLD = 1000 ether;\n\n    constructor(address _dai, address _crv3, address _curve3Pool) {\n        dai = IERC20(_dai);\n        crv3 = IERC20(_crv3);\n        curve3Pool = ICurve3Pool(_curve3Pool);\n    }\n\n    function deposit(uint256 amount) external {\n        dai.transferFrom(msg.sender, address(this), amount);\n\n        uint256 shareAmount;\n        if (totalShares == 0) {\n            shareAmount = amount;\n        } else {\n            shareAmount = (amount * totalShares) / totalDeposits;\n        }\n\n        shares[msg.sender] += shareAmount;\n        totalShares += shareAmount;\n        totalDeposits += amount;\n    }\n\n    function earn() external {\n        uint256 vaultBalance = dai.balanceOf(address(this));\n        require(\n            vaultBalance >= MIN_EARN_THRESHOLD,\n            \"Insufficient balance to earn\"\n        );\n\n        uint256 virtualPrice = curve3Pool.get_virtual_price();\n\n        dai.approve(address(curve3Pool), vaultBalance);\n        uint256[3] memory amounts = [vaultBalance, 0, 0];\n        curve3Pool.add_liquidity(amounts, 0);\n    }\n\n    function withdrawAll() external {\n        uint256 userShares = shares[msg.sender];\n        require(userShares > 0, \"No shares\");\n\n        uint256 withdrawAmount = (userShares * totalDeposits) / totalShares;\n\n        shares[msg.sender] = 0;\n        totalShares -= userShares;\n        totalDeposits -= withdrawAmount;\n\n        dai.transfer(msg.sender, withdrawAmount);\n    }\n\n    function balance() public view returns (uint256) {\n        return\n            dai.balanceOf(address(this)) +\n            (crv3.balanceOf(address(this)) * curve3Pool.get_virtual_price()) /\n            1e18;\n    }\n\n    // Unified dispatcher - merged from: earn\n    // Selectors: earn=0\n    function execute(uint8 _selector) public {\n        // Original: earn()\n        if (_selector == 0) {\n            uint256 vaultBalance = dai.balanceOf(address(this));\n            require(\n            vaultBalance >= MIN_EARN_THRESHOLD,\n            \"Insufficient balance to earn\"\n            );\n            uint256 virtualPrice = curve3Pool.get_virtual_price();\n            dai.approve(address(curve3Pool), vaultBalance);\n            uint256[3] memory amounts = [vaultBalance, 0, 0];\n            curve3Pool.add_liquidity(amounts, 0);\n        }\n    }\n}",
      "merged_functions": [
        "earn"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: earn"
      ],
      "function_to_selector": {
        "earn": 0
      },
      "error": null
    },
    {
      "original_id": "nc_tc_015",
      "transformed_id": "rs_mg_dis_nc_tc_015",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract CompoundMarket {\n    address public underlying;\n    address public admin;\n\n    mapping(address => uint256) public accountTokens;\n    uint256 public totalSupply;\n\n    address public constant OLD_TUSD =\n        0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;\n    address public constant NEW_TUSD =\n        0x0000000000085d4780B73119b644AE5ecd22b376;\n\n    constructor() {\n        admin = msg.sender;\n        underlying = OLD_TUSD;\n    }\n\n    function mint(uint256 amount) external {\n        IERC20(NEW_TUSD).transfer(address(this), amount);\n        accountTokens[msg.sender] += amount;\n        totalSupply += amount;\n    }\n\n    function sweepToken(address token) external {\n        require(token != underlying, \"Cannot sweep underlying token\");\n\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(msg.sender, balance);\n    }\n\n    function redeem(uint256 amount) external {\n        require(accountTokens[msg.sender] >= amount, \"Insufficient balance\");\n\n        accountTokens[msg.sender] -= amount;\n        totalSupply -= amount;\n\n        IERC20(NEW_TUSD).transfer(msg.sender, amount);\n    }\n\n    // Unified dispatcher - merged from: sweepToken, mint\n    // Selectors: sweepToken=0, mint=2\n    function execute(uint8 _selector, address token, uint256 amount) public {\n        // Original: sweepToken()\n        if (_selector == 0) {\n            require(token != underlying, \"Cannot sweep underlying token\");\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            IERC20(token).transfer(msg.sender, balance);\n        }\n        // Original: mint()\n        else if (_selector == 1) {\n            IERC20(NEW_TUSD).transfer(address(this), amount);\n            accountTokens[msg.sender] += amount;\n            totalSupply += amount;\n        }\n    }\n}",
      "merged_functions": [
        "sweepToken",
        "mint"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: sweepToken, mint"
      ],
      "function_to_selector": {
        "sweepToken": 0,
        "mint": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_016",
      "transformed_id": "rs_mg_dis_nc_tc_016",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract LoanToken {\n    string public name = \"iETH\";\n    string public symbol = \"iETH\";\n\n    mapping(address => uint256) public balances;\n    uint256 public totalSupply;\n    uint256 public totalAssetBorrow;\n    uint256 public totalAssetSupply;\n\n    function mintWithEther(\n        address receiver\n    ) external payable returns (uint256 mintAmount) {\n        uint256 currentPrice = _tokenPrice();\n        mintAmount = (msg.value * 1e18) / currentPrice;\n\n        balances[receiver] += mintAmount;\n        totalSupply += mintAmount;\n        totalAssetSupply += msg.value;\n\n        return mintAmount;\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool) {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n\n        _notifyTransfer(msg.sender, to, amount);\n\n        return true;\n    }\n\n    function _notifyTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        if (_isContract(to)) {\n            (bool success, ) = to.call(\"\");\n            success;\n        }\n    }\n\n    function burnToEther(\n        address receiver,\n        uint256 amount\n    ) external returns (uint256 ethAmount) {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n\n        uint256 currentPrice = _tokenPrice();\n        ethAmount = (amount * currentPrice) / 1e18;\n\n        balances[msg.sender] -= amount;\n        totalSupply -= amount;\n        totalAssetSupply -= ethAmount;\n\n        payable(receiver).transfer(ethAmount);\n\n        return ethAmount;\n    }\n\n    function _tokenPrice() internal view returns (uint256) {\n        if (totalSupply == 0) {\n            return 1e18;\n        }\n        return (totalAssetSupply * 1e18) / totalSupply;\n    }\n\n    function _isContract(address account) internal view returns (bool) {\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    function balanceOf(address account) external view returns (uint256) {\n        return balances[account];\n    }\n\n    receive() external payable {}\n\n    // Unified dispatcher - merged from: transfer, mintWithEther, burnToEther\n    // Selectors: transfer=0, mintWithEther=1, burnToEther=2\n    function execute(uint8 _selector, address receiver, address to, uint256 amount) public payable {\n        // Original: transfer()\n        if (_selector == 0) {\n            require(balances[msg.sender] >= amount, \"Insufficient balance\");\n            balances[msg.sender] -= amount;\n            balances[to] += amount;\n            _notifyTransfer(msg.sender, to, amount);\n            return true;\n        }\n        // Original: mintWithEther()\n        else if (_selector == 1) {\n            uint256 currentPrice = _tokenPrice();\n            mintAmount = (msg.value * 1e18) / currentPrice;\n            balances[receiver] += mintAmount;\n            totalSupply += mintAmount;\n            totalAssetSupply += msg.value;\n            return mintAmount;\n        }\n        // Original: burnToEther()\n        else if (_selector == 2) {\n            require(balances[msg.sender] >= amount, \"Insufficient balance\");\n            uint256 currentPrice = _tokenPrice();\n            ethAmount = (amount * currentPrice) / 1e18;\n            balances[msg.sender] -= amount;\n            totalSupply -= amount;\n            totalAssetSupply -= ethAmount;\n            payable(receiver).transfer(ethAmount);\n            return ethAmount;\n        }\n    }\n}",
      "merged_functions": [
        "transfer",
        "mintWithEther",
        "burnToEther"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 3 functions",
        "Merged functions: transfer, mintWithEther, burnToEther"
      ],
      "function_to_selector": {
        "transfer": 0,
        "mintWithEther": 1,
        "burnToEther": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_017",
      "transformed_id": "rs_mg_dis_nc_tc_017",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IJar {\n    function token() external view returns (address);\n\n    function withdraw(uint256 amount) external;\n}\n\ninterface IStrategy {\n    function withdrawAll() external;\n\n    function withdraw(address token) external;\n}\n\ncontract VaultController {\n    address public governance;\n    mapping(address => address) public strategies;\n\n    constructor() {\n        governance = msg.sender;\n    }\n\n    function swapExactJarForJar(\n        address _fromJar,\n        address _toJar,\n        uint256 _fromJarAmount,\n        uint256 _toJarMinAmount,\n        address[] calldata _targets,\n        bytes[] calldata _data\n    ) external {\n        require(_targets.length == _data.length, \"Length mismatch\");\n\n        for (uint256 i = 0; i < _targets.length; i++) {\n            (bool success, ) = _targets[i].call(_data[i]);\n            require(success, \"Call failed\");\n        }\n    }\n\n    function setStrategy(address jar, address strategy) external {\n        require(msg.sender == governance, \"Not governance\");\n        strategies[jar] = strategy;\n    }\n}\n\ncontract Strategy {\n    address public controller;\n    address public want;\n\n    constructor(address _controller, address _want) {\n        controller = _controller;\n        want = _want;\n    }\n\n    function withdrawAll() external {\n        uint256 balance = IERC20(want).balanceOf(address(this));\n        IERC20(want).transfer(controller, balance);\n    }\n\n    function withdraw(address token) external {\n        uint256 balance = IERC20(token).balanceOf(address(this));\n        IERC20(token).transfer(controller, balance);\n    }\n\n    // Unified dispatcher - merged from: swapExactJarForJar\n    // Selectors: swapExactJarForJar=0\n    function execute(uint8 _selector, address _fromJar, address _toJar, address[] _targets, bytes[] _data, uint256 _fromJarAmount, uint256 _toJarMinAmount) public {\n        // Original: swapExactJarForJar()\n        if (_selector == 0) {\n            require(_targets.length == _data.length, \"Length mismatch\");\n            for (uint256 i = 0; i < _targets.length; i++) {\n            (bool success, ) = _targets[i].call(_data[i]);\n            require(success, \"Call failed\");\n            }\n        }\n    }\n}",
      "merged_functions": [
        "swapExactJarForJar"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: swapExactJarForJar"
      ],
      "function_to_selector": {
        "swapExactJarForJar": 0
      },
      "error": null
    },
    {
      "original_id": "nc_tc_018",
      "transformed_id": "rs_mg_dis_nc_tc_018",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n}\n\ncontract TokenPool {\n    struct Token {\n        address addr;\n        uint256 balance;\n        uint256 weight;\n    }\n\n    mapping(address => Token) public tokens;\n    address[] public tokenList;\n    uint256 public totalWeight;\n\n    constructor() {\n        totalWeight = 100;\n    }\n\n    function addToken(address token, uint256 initialWeight) external {\n        tokens[token] = Token({addr: token, balance: 0, weight: initialWeight});\n        tokenList.push(token);\n    }\n\n    function swap(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) external returns (uint256 amountOut) {\n        require(tokens[tokenIn].addr != address(0), \"Invalid token\");\n        require(tokens[tokenOut].addr != address(0), \"Invalid token\");\n\n        IERC20(tokenIn).transfer(address(this), amountIn);\n        tokens[tokenIn].balance += amountIn;\n\n        amountOut = calculateSwapAmount(tokenIn, tokenOut, amountIn);\n\n        require(\n            tokens[tokenOut].balance >= amountOut,\n            \"Insufficient liquidity\"\n        );\n        tokens[tokenOut].balance -= amountOut;\n        IERC20(tokenOut).transfer(msg.sender, amountOut);\n\n        _updateWeights();\n\n        return amountOut;\n    }\n\n    function calculateSwapAmount(\n        address tokenIn,\n        address tokenOut,\n        uint256 amountIn\n    ) public view returns (uint256) {\n        uint256 weightIn = tokens[tokenIn].weight;\n        uint256 weightOut = tokens[tokenOut].weight;\n        uint256 balanceOut = tokens[tokenOut].balance;\n\n        uint256 numerator = balanceOut * amountIn * weightOut;\n        uint256 denominator = tokens[tokenIn].balance *\n            weightIn +\n            amountIn *\n            weightOut;\n\n        return numerator / denominator;\n    }\n\n    function _updateWeights() internal {\n        uint256 totalValue = 0;\n\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            totalValue += tokens[token].balance;\n        }\n\n        for (uint256 i = 0; i < tokenList.length; i++) {\n            address token = tokenList[i];\n            tokens[token].weight = (tokens[token].balance * 100) / totalValue;\n        }\n    }\n\n    function getWeight(address token) external view returns (uint256) {\n        return tokens[token].weight;\n    }\n\n    function addLiquidity(address token, uint256 amount) external {\n        require(tokens[token].addr != address(0), \"Invalid token\");\n        IERC20(token).transfer(address(this), amount);\n        tokens[token].balance += amount;\n        _updateWeights();\n    }\n\n    // Unified dispatcher - merged from: addToken, swap\n    // Selectors: addToken=1, swap=2\n    function execute(uint8 _selector, address token, address tokenIn, address tokenOut, uint256 amountIn, uint256 initialWeight) public {\n        // Original: addToken()\n        if (_selector == 0) {\n            tokens[token] = Token({addr: token, balance: 0, weight: initialWeight});\n            tokenList.push(token);\n        }\n        // Original: swap()\n        else if (_selector == 1) {\n            require(tokens[tokenIn].addr != address(0), \"Invalid token\");\n            require(tokens[tokenOut].addr != address(0), \"Invalid token\");\n            IERC20(tokenIn).transfer(address(this), amountIn);\n            tokens[tokenIn].balance += amountIn;\n            amountOut = calculateSwapAmount(tokenIn, tokenOut, amountIn);\n            require(\n            tokens[tokenOut].balance >= amountOut,\n            \"Insufficient liquidity\"\n            );\n            tokens[tokenOut].balance -= amountOut;\n            IERC20(tokenOut).transfer(msg.sender, amountOut);\n            _updateWeights();\n            return amountOut;\n        }\n    }\n}",
      "merged_functions": [
        "addToken",
        "swap"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: addToken, swap"
      ],
      "function_to_selector": {
        "addToken": 1,
        "swap": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_019",
      "transformed_id": "rs_mg_dis_nc_tc_019",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract CrossChainBridge {\n    address public handler;\n\n    event Deposit(\n        uint8 destinationDomainID,\n        bytes32 resourceID,\n        uint64 depositNonce\n    );\n\n    uint64 public depositNonce;\n\n    constructor(address _handler) {\n        handler = _handler;\n    }\n\n    function deposit(\n        uint8 destinationDomainID,\n        bytes32 resourceID,\n        bytes calldata data\n    ) external payable {\n        depositNonce += 1;\n\n        BridgeHandler(handler).deposit(resourceID, msg.sender, data);\n\n        emit Deposit(destinationDomainID, resourceID, depositNonce);\n    }\n}\n\ncontract BridgeHandler {\n    mapping(bytes32 => address) public resourceIDToTokenContractAddress;\n    mapping(address => bool) public contractWhitelist;\n\n    function deposit(\n        bytes32 resourceID,\n        address depositer,\n        bytes calldata data\n    ) external {\n        address tokenContract = resourceIDToTokenContractAddress[resourceID];\n\n        uint256 amount;\n        (amount) = abi.decode(data, (uint256));\n\n        IERC20(tokenContract).transferFrom(depositer, address(this), amount);\n    }\n\n    function setResource(bytes32 resourceID, address tokenAddress) external {\n        resourceIDToTokenContractAddress[resourceID] = tokenAddress;\n    }\n\n    // Unified dispatcher - merged from: deposit, deposit\n    // Selectors: deposit=2\n    function execute(uint8 _selector, address depositer, bytes data, bytes32 resourceID, uint8 destinationDomainID) public payable {\n        // Original: deposit()\n        if (_selector == 0) {\n            depositNonce += 1;\n            BridgeHandler(handler).deposit(resourceID, msg.sender, data);\n            emit Deposit(destinationDomainID, resourceID, depositNonce);\n        }\n        // Original: deposit()\n        else if (_selector == 1) {\n            address tokenContract = resourceIDToTokenContractAddress[resourceID];\n            uint256 amount;\n            (amount) = abi.decode(data, (uint256));\n            IERC20(tokenContract).transferFrom(depositer, address(this), amount);\n        }\n    }\n}",
      "merged_functions": [
        "deposit",
        "deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: deposit, deposit"
      ],
      "function_to_selector": {
        "deposit": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_020",
      "transformed_id": "rs_mg_dis_nc_tc_020",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function getReserves()\n        external\n        view\n        returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n    function totalSupply() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\ncontract LendingVault {\n    struct Position {\n        uint256 lpTokenAmount;\n        uint256 borrowed;\n    }\n\n    mapping(address => Position) public positions;\n\n    address public lpToken;\n    address public stablecoin;\n    uint256 public constant COLLATERAL_RATIO = 150;\n\n    constructor(address _lpToken, address _stablecoin) {\n        lpToken = _lpToken;\n        stablecoin = _stablecoin;\n    }\n\n    function deposit(uint256 amount) external {\n        IERC20(lpToken).transferFrom(msg.sender, address(this), amount);\n        positions[msg.sender].lpTokenAmount += amount;\n    }\n\n    function borrow(uint256 amount) external {\n        uint256 collateralValue = getLPTokenValue(\n            positions[msg.sender].lpTokenAmount\n        );\n        uint256 maxBorrow = (collateralValue * 100) / COLLATERAL_RATIO;\n\n        require(\n            positions[msg.sender].borrowed + amount <= maxBorrow,\n            \"Insufficient collateral\"\n        );\n\n        positions[msg.sender].borrowed += amount;\n        IERC20(stablecoin).transfer(msg.sender, amount);\n    }\n\n    function getLPTokenValue(uint256 lpAmount) public view returns (uint256) {\n        if (lpAmount == 0) return 0;\n\n        IUniswapV2Pair pair = IUniswapV2Pair(lpToken);\n\n        (uint112 reserve0, uint112 reserve1, ) = pair.getReserves();\n        uint256 totalSupply = pair.totalSupply();\n\n        uint256 amount0 = (uint256(reserve0) * lpAmount) / totalSupply;\n        uint256 amount1 = (uint256(reserve1) * lpAmount) / totalSupply;\n\n        uint256 value0 = amount0;\n        uint256 totalValue = amount0 + amount1;\n\n        return totalValue;\n    }\n\n    function repay(uint256 amount) external {\n        require(positions[msg.sender].borrowed >= amount, \"Repay exceeds debt\");\n\n        IERC20(stablecoin).transferFrom(msg.sender, address(this), amount);\n        positions[msg.sender].borrowed -= amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(\n            positions[msg.sender].lpTokenAmount >= amount,\n            \"Insufficient balance\"\n        );\n\n        uint256 remainingLP = positions[msg.sender].lpTokenAmount - amount;\n        uint256 remainingValue = getLPTokenValue(remainingLP);\n        uint256 maxBorrow = (remainingValue * 100) / COLLATERAL_RATIO;\n\n        require(\n            positions[msg.sender].borrowed <= maxBorrow,\n            \"Withdrawal would liquidate position\"\n        );\n\n        positions[msg.sender].lpTokenAmount -= amount;\n        IERC20(lpToken).transfer(msg.sender, amount);\n    }\n\n    // Unified dispatcher - merged from: deposit\n    // Selectors: deposit=2\n    function execute(uint8 _selector, uint256 amount) public {\n        // Original: deposit()\n        if (_selector == 0) {\n            IERC20(lpToken).transferFrom(msg.sender, address(this), amount);\n            positions[msg.sender].lpTokenAmount += amount;\n        }\n    }\n}",
      "merged_functions": [
        "deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: deposit"
      ],
      "function_to_selector": {
        "deposit": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_021",
      "transformed_id": "rs_mg_dis_nc_tc_021",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\ncontract LiquidityPool {\n    address public maintainer;\n    address public baseToken;\n    address public quoteToken;\n\n    uint256 public lpFeeRate;\n    uint256 public baseBalance;\n    uint256 public quoteBalance;\n\n    bool public isInitialized;\n\n    event Initialized(address maintainer, address base, address quote);\n\n    function init(\n        address _maintainer,\n        address _baseToken,\n        address _quoteToken,\n        uint256 _lpFeeRate\n    ) external {\n        maintainer = _maintainer;\n        baseToken = _baseToken;\n        quoteToken = _quoteToken;\n        lpFeeRate = _lpFeeRate;\n\n        isInitialized = true;\n\n        emit Initialized(_maintainer, _baseToken, _quoteToken);\n    }\n\n    function addLiquidity(uint256 baseAmount, uint256 quoteAmount) external {\n        require(isInitialized, \"Not initialized\");\n\n        IERC20(baseToken).transferFrom(msg.sender, address(this), baseAmount);\n        IERC20(quoteToken).transferFrom(msg.sender, address(this), quoteAmount);\n\n        baseBalance += baseAmount;\n        quoteBalance += quoteAmount;\n    }\n\n    function swap(\n        address fromToken,\n        address toToken,\n        uint256 fromAmount\n    ) external returns (uint256 toAmount) {\n        require(isInitialized, \"Not initialized\");\n        require(\n            (fromToken == baseToken && toToken == quoteToken) ||\n                (fromToken == quoteToken && toToken == baseToken),\n            \"Invalid token pair\"\n        );\n\n        IERC20(fromToken).transferFrom(msg.sender, address(this), fromAmount);\n\n        if (fromToken == baseToken) {\n            toAmount = (quoteBalance * fromAmount) / (baseBalance + fromAmount);\n            baseBalance += fromAmount;\n            quoteBalance -= toAmount;\n        } else {\n            toAmount = (baseBalance * fromAmount) / (quoteBalance + fromAmount);\n            quoteBalance += fromAmount;\n            baseBalance -= toAmount;\n        }\n\n        uint256 fee = (toAmount * lpFeeRate) / 10000;\n        toAmount -= fee;\n\n        IERC20(toToken).transfer(msg.sender, toAmount);\n        IERC20(toToken).transfer(maintainer, fee);\n\n        return toAmount;\n    }\n\n    function claimFees() external {\n        require(msg.sender == maintainer, \"Only maintainer\");\n\n        uint256 baseTokenBalance = IERC20(baseToken).balanceOf(address(this));\n        uint256 quoteTokenBalance = IERC20(quoteToken).balanceOf(address(this));\n\n        if (baseTokenBalance > baseBalance) {\n            uint256 excess = baseTokenBalance - baseBalance;\n            IERC20(baseToken).transfer(maintainer, excess);\n        }\n\n        if (quoteTokenBalance > quoteBalance) {\n            uint256 excess = quoteTokenBalance - quoteBalance;\n            IERC20(quoteToken).transfer(maintainer, excess);\n        }\n    }\n\n    // Unified dispatcher - merged from: init\n    // Selectors: init=2\n    function execute(uint8 _selector, address _baseToken, address _maintainer, address _quoteToken, uint256 _lpFeeRate) public {\n        // Original: init()\n        if (_selector == 0) {\n            maintainer = _maintainer;\n            baseToken = _baseToken;\n            quoteToken = _quoteToken;\n            lpFeeRate = _lpFeeRate;\n            isInitialized = true;\n            emit Initialized(_maintainer, _baseToken, _quoteToken);\n        }\n    }\n}",
      "merged_functions": [
        "init"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: init"
      ],
      "function_to_selector": {
        "init": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_022",
      "transformed_id": "rs_mg_dis_nc_tc_022",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n\ncontract TokenPair {\n    address public token0;\n    address public token1;\n\n    uint112 private reserve0;\n    uint112 private reserve1;\n\n    uint256 public constant TOTAL_FEE = 16;\n\n    constructor(address _token0, address _token1) {\n        token0 = _token0;\n        token1 = _token1;\n    }\n\n    function mint(address to) external returns (uint256 liquidity) {\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n\n        uint256 amount0 = balance0 - reserve0;\n        uint256 amount1 = balance1 - reserve1;\n\n        liquidity = sqrt(amount0 * amount1);\n\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n\n        return liquidity;\n    }\n\n    function swap(\n        uint256 amount0Out,\n        uint256 amount1Out,\n        address to,\n        bytes calldata data\n    ) external {\n        require(amount0Out > 0 || amount1Out > 0, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        uint112 _reserve0 = reserve0;\n        uint112 _reserve1 = reserve1;\n\n        require(\n            amount0Out < _reserve0 && amount1Out < _reserve1,\n            \"INSUFFICIENT_LIQUIDITY\"\n        );\n\n        if (amount0Out > 0) IERC20(token0).transfer(to, amount0Out);\n        if (amount1Out > 0) IERC20(token1).transfer(to, amount1Out);\n\n        uint256 balance0 = IERC20(token0).balanceOf(address(this));\n        uint256 balance1 = IERC20(token1).balanceOf(address(this));\n\n        uint256 amount0In = balance0 > _reserve0 - amount0Out\n            ? balance0 - (_reserve0 - amount0Out)\n            : 0;\n        uint256 amount1In = balance1 > _reserve1 - amount1Out\n            ? balance1 - (_reserve1 - amount1Out)\n            : 0;\n\n        require(amount0In > 0 || amount1In > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\n        uint256 balance0Adjusted = balance0 * 10000 - amount0In * TOTAL_FEE;\n        uint256 balance1Adjusted = balance1 * 10000 - amount1In * TOTAL_FEE;\n\n        require(\n            balance0Adjusted * balance1Adjusted >=\n                uint256(_reserve0) * _reserve1 * (1000 ** 2),\n            \"K\"\n        );\n\n        reserve0 = uint112(balance0);\n        reserve1 = uint112(balance1);\n    }\n\n    function getReserves() external view returns (uint112, uint112, uint32) {\n        return (reserve0, reserve1, 0);\n    }\n\n    function sqrt(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n\n    // Unified dispatcher - merged from: mint\n    // Selectors: mint=2\n    function execute(uint8 _selector, address to) public {\n        // Original: mint()\n        if (_selector == 0) {\n            uint256 balance0 = IERC20(token0).balanceOf(address(this));\n            uint256 balance1 = IERC20(token1).balanceOf(address(this));\n            uint256 amount0 = balance0 - reserve0;\n            uint256 amount1 = balance1 - reserve1;\n            liquidity = sqrt(amount0 * amount1);\n            reserve0 = uint112(balance0);\n            reserve1 = uint112(balance1);\n            return liquidity;\n        }\n    }\n}",
      "merged_functions": [
        "mint"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: mint"
      ],
      "function_to_selector": {
        "mint": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_023",
      "transformed_id": "rs_mg_dis_nc_tc_023",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_024",
      "transformed_id": "rs_mg_dis_nc_tc_024",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_025",
      "transformed_id": "rs_mg_dis_nc_tc_025",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_026",
      "transformed_id": "rs_mg_dis_nc_tc_026",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20Permit {\n    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n}\n\ncontract BridgeRouter {\n\n    function bridgeOutWithPermit(\n        address from,\n        address token,\n        address to,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 toChainID\n    ) external {\n\n        if (v != 0 || r != bytes32(0) || s != bytes32(0)) {\n            try IERC20Permit(token).permit(from, address(this), amount, deadline, v, r, s) {} catch {}\n        }\n\n        _bridgeOut(from, token, to, amount, toChainID);\n    }\n\n    function _bridgeOut(address from, address token, address to, uint256 amount, uint256 toChainID) internal {\n\n    }\n\n    // Unified dispatcher - merged from: bridgeOutWithPermit\n    // Selectors: bridgeOutWithPermit=1\n    function execute(uint8 _selector, address from, address to, address token, bytes32 r, bytes32 s, uint256 amount, uint256 deadline, uint256 toChainID, uint8 v) public {\n        // Original: bridgeOutWithPermit()\n        if (_selector == 0) {\n            if (v != 0 || r != bytes32(0) || s != bytes32(0)) {\n            try IERC20Permit(token).permit(from, address(this), amount, deadline, v, r, s) {} catch {}\n            }\n            _bridgeOut(from, token, to, amount, toChainID);\n        }\n    }\n}",
      "merged_functions": [
        "bridgeOutWithPermit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: bridgeOutWithPermit"
      ],
      "function_to_selector": {
        "bridgeOutWithPermit": 1
      },
      "error": null
    },
    {
      "original_id": "nc_tc_027",
      "transformed_id": "rs_mg_dis_nc_tc_027",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Need at least 2 mergeable functions"
    },
    {
      "original_id": "nc_tc_028",
      "transformed_id": "rs_mg_dis_nc_tc_028",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\ncontract TokenVault {\n    address public token;\n    mapping(address => uint256) public deposits;\n\n    constructor(address _token) {\n        token = _token;\n    }\n\n    function deposit(uint256 amount) external {\n        IERC20(token).transferFrom(msg.sender, address(this), amount);\n\n        deposits[msg.sender] += amount;\n    }\n\n    function withdraw(uint256 amount) external {\n        require(deposits[msg.sender] >= amount, \"Insufficient\");\n\n        deposits[msg.sender] -= amount;\n\n        IERC20(token).transfer(msg.sender, amount);\n    }\n\n    // Unified dispatcher - merged from: deposit\n    // Selectors: deposit=2\n    function execute(uint8 _selector, uint256 amount) public {\n        // Original: deposit()\n        if (_selector == 0) {\n            IERC20(token).transferFrom(msg.sender, address(this), amount);\n            deposits[msg.sender] += amount;\n        }\n    }\n}",
      "merged_functions": [
        "deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: deposit"
      ],
      "function_to_selector": {
        "deposit": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_029",
      "transformed_id": "rs_mg_dis_nc_tc_029",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n\ninterface IPriceOracle {\n    function getPrice(address token) external view returns (uint256);\n}\n\ncontract VaultStrategy {\n    address public wantToken;\n    address public oracle;\n    uint256 public totalShares;\n\n    mapping(address => uint256) public shares;\n\n    constructor(address _want, address _oracle) {\n        wantToken = _want;\n        oracle = _oracle;\n    }\n\n    function deposit(uint256 amount) external returns (uint256 sharesAdded) {\n        uint256 pool = IERC20(wantToken).balanceOf(address(this));\n\n        if (totalShares == 0) {\n            sharesAdded = amount;\n        } else {\n            uint256 price = IPriceOracle(oracle).getPrice(wantToken);\n            sharesAdded = (amount * totalShares * 1e18) / (pool * price);\n        }\n\n        shares[msg.sender] += sharesAdded;\n        totalShares += sharesAdded;\n\n        IERC20(wantToken).transferFrom(msg.sender, address(this), amount);\n        return sharesAdded;\n    }\n\n    function withdraw(uint256 sharesAmount) external {\n        uint256 pool = IERC20(wantToken).balanceOf(address(this));\n\n        uint256 price = IPriceOracle(oracle).getPrice(wantToken);\n        uint256 amount = (sharesAmount * pool * price) / (totalShares * 1e18);\n\n        shares[msg.sender] -= sharesAmount;\n        totalShares -= sharesAmount;\n\n        IERC20(wantToken).transfer(msg.sender, amount);\n    }\n\n    // Unified dispatcher - merged from: deposit\n    // Selectors: deposit=2\n    function execute(uint8 _selector, uint256 amount) public {\n        // Original: deposit()\n        if (_selector == 0) {\n            uint256 pool = IERC20(wantToken).balanceOf(address(this));\n            if (totalShares == 0) {\n            sharesAdded = amount;\n            } else {\n            uint256 price = IPriceOracle(oracle).getPrice(wantToken);\n            sharesAdded = (amount * totalShares * 1e18) / (pool * price);\n            }\n            shares[msg.sender] += sharesAdded;\n            totalShares += sharesAdded;\n            IERC20(wantToken).transferFrom(msg.sender, address(this), amount);\n            return sharesAdded;\n        }\n    }\n}",
      "merged_functions": [
        "deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: deposit"
      ],
      "function_to_selector": {
        "deposit": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_030",
      "transformed_id": "rs_mg_dis_nc_tc_030",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ncontract LiquidityPool {\n    uint256 public baseAmount;\n    uint256 public tokenAmount;\n    uint256 public totalUnits;\n\n    mapping(address => uint256) public units;\n\n    function addLiquidity(uint256 inputBase, uint256 inputToken) external returns (uint256 liquidityUnits) {\n\n        if (totalUnits == 0) {\n            liquidityUnits = inputBase;\n        } else {\n            uint256 baseRatio = (inputBase * totalUnits) / baseAmount;\n            uint256 tokenRatio = (inputToken * totalUnits) / tokenAmount;\n\n            liquidityUnits = (baseRatio + tokenRatio) / 2;\n        }\n\n        units[msg.sender] += liquidityUnits;\n        totalUnits += liquidityUnits;\n\n        baseAmount += inputBase;\n        tokenAmount += inputToken;\n\n        return liquidityUnits;\n    }\n\n    function removeLiquidity(uint256 liquidityUnits) external returns (uint256, uint256) {\n        uint256 outputBase = (liquidityUnits * baseAmount) / totalUnits;\n        uint256 outputToken = (liquidityUnits * tokenAmount) / totalUnits;\n\n        units[msg.sender] -= liquidityUnits;\n        totalUnits -= liquidityUnits;\n\n        baseAmount -= outputBase;\n        tokenAmount -= outputToken;\n\n        return (outputBase, outputToken);\n    }\n\n    // Unified dispatcher - merged from: addLiquidity, removeLiquidity\n    // Selectors: addLiquidity=0, removeLiquidity=1\n    function execute(uint8 _selector, uint256 inputBase, uint256 inputToken, uint256 liquidityUnits) public {\n        // Original: addLiquidity()\n        if (_selector == 0) {\n            if (totalUnits == 0) {\n            liquidityUnits = inputBase;\n            } else {\n            uint256 baseRatio = (inputBase * totalUnits) / baseAmount;\n            uint256 tokenRatio = (inputToken * totalUnits) / tokenAmount;\n            liquidityUnits = (baseRatio + tokenRatio) / 2;\n            }\n            units[msg.sender] += liquidityUnits;\n            totalUnits += liquidityUnits;\n            baseAmount += inputBase;\n            tokenAmount += inputToken;\n            return liquidityUnits;\n        }\n        // Original: removeLiquidity()\n        else if (_selector == 1) {\n            uint256 outputBase = (liquidityUnits * baseAmount) / totalUnits;\n            uint256 outputToken = (liquidityUnits * tokenAmount) / totalUnits;\n            units[msg.sender] -= liquidityUnits;\n            totalUnits -= liquidityUnits;\n            baseAmount -= outputBase;\n            tokenAmount -= outputToken;\n            return (outputBase, outputToken);\n        }\n    }\n}",
      "merged_functions": [
        "addLiquidity",
        "removeLiquidity"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: addLiquidity, removeLiquidity"
      ],
      "function_to_selector": {
        "addLiquidity": 0,
        "removeLiquidity": 1
      },
      "error": null
    },
    {
      "original_id": "nc_tc_031",
      "transformed_id": "rs_mg_dis_nc_tc_031",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract OrbitBridge {\n    mapping(bytes32 => bool) public processedTransactions;\n    uint256 public constant REQUIRED_SIGNATURES = 5;\n    uint256 public constant TOTAL_VALIDATORS = 7;\n\n    mapping(address => bool) public validators;\n    address[] public validatorList;\n\n    event WithdrawalProcessed(\n        bytes32 txHash,\n        address token,\n        address recipient,\n        uint256 amount\n    );\n\n    constructor() {\n        validatorList = new address[](TOTAL_VALIDATORS);\n    }\n\n    function withdraw(\n        address hubContract,\n        string memory fromChain,\n        bytes memory fromAddr,\n        address toAddr,\n        address token,\n        bytes32[] memory bytes32s,\n        uint256[] memory uints,\n        bytes memory data,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) external {\n        bytes32 txHash = bytes32s[1];\n\n        require(\n            !processedTransactions[txHash],\n            \"Transaction already processed\"\n        );\n\n        require(v.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n        require(\n            v.length == r.length && r.length == s.length,\n            \"Signature length mismatch\"\n        );\n\n        uint256 amount = uints[0];\n\n        processedTransactions[txHash] = true;\n\n        IERC20(token).transfer(toAddr, amount);\n\n        emit WithdrawalProcessed(txHash, token, toAddr, amount);\n    }\n\n    function addValidator(address validator) external {\n        validators[validator] = true;\n    }\n\n    // Unified dispatcher - merged from: withdraw, addValidator\n    // Selectors: withdraw=1, addValidator=2\n    function execute(uint8 _selector, address hubContract, address toAddr, address token, address validator, bytes data, bytes fromAddr, bytes32[] bytes32s, bytes32[] r, bytes32[] s, string fromChain, uint256[] uints, uint8[] v) public {\n        // Original: withdraw()\n        if (_selector == 0) {\n            bytes32 txHash = bytes32s[1];\n            require(\n            !processedTransactions[txHash],\n            \"Transaction already processed\"\n            );\n            require(v.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n            require(\n            v.length == r.length && r.length == s.length,\n            \"Signature length mismatch\"\n            );\n            uint256 amount = uints[0];\n            processedTransactions[txHash] = true;\n            IERC20(token).transfer(toAddr, amount);\n            emit WithdrawalProcessed(txHash, token, toAddr, amount);\n        }\n        // Original: addValidator()\n        else if (_selector == 1) {\n            validators[validator] = true;\n        }\n    }\n}",
      "merged_functions": [
        "withdraw",
        "addValidator"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: withdraw, addValidator"
      ],
      "function_to_selector": {
        "withdraw": 1,
        "addValidator": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_032",
      "transformed_id": "rs_mg_dis_nc_tc_032",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_033",
      "transformed_id": "rs_mg_dis_nc_tc_033",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_034",
      "transformed_id": "rs_mg_dis_nc_tc_034",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_035",
      "transformed_id": "rs_mg_dis_nc_tc_035",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_036",
      "transformed_id": "rs_mg_dis_nc_tc_036",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_037",
      "transformed_id": "rs_mg_dis_nc_tc_037",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_038",
      "transformed_id": "rs_mg_dis_nc_tc_038",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_039",
      "transformed_id": "rs_mg_dis_nc_tc_039",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_040",
      "transformed_id": "rs_mg_dis_nc_tc_040",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_041",
      "transformed_id": "rs_mg_dis_nc_tc_041",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_042",
      "transformed_id": "rs_mg_dis_nc_tc_042",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_043",
      "transformed_id": "rs_mg_dis_nc_tc_043",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_044",
      "transformed_id": "rs_mg_dis_nc_tc_044",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_045",
      "transformed_id": "rs_mg_dis_nc_tc_045",
      "mode": "dispatcher",
      "success": false,
      "code": "",
      "merged_functions": [],
      "dispatcher_name": "",
      "changes_made": [],
      "function_to_selector": {},
      "error": "Could not extract function bodies"
    },
    {
      "original_id": "nc_tc_046",
      "transformed_id": "rs_mg_dis_nc_tc_046",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract FloatHotWalletV2 {\n    address public owner;\n\n    mapping(address => bool) public authorizedOperators;\n\n    event Withdrawal(address token, address to, uint256 amount);\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    function withdraw(\n        address token,\n        address to,\n        uint256 amount\n    ) external onlyOwner {\n        if (token == address(0)) {\n            payable(to).transfer(amount);\n        } else {\n            IERC20(token).transfer(to, amount);\n        }\n\n        emit Withdrawal(token, to, amount);\n    }\n\n    function emergencyWithdraw(address token) external onlyOwner {\n        uint256 balance;\n        if (token == address(0)) {\n            balance = address(this).balance;\n            payable(owner).transfer(balance);\n        } else {\n            balance = IERC20(token).balanceOf(address(this));\n            IERC20(token).transfer(owner, balance);\n        }\n\n        emit Withdrawal(token, owner, balance);\n    }\n\n    function transferOwnership(address newOwner) external onlyOwner {\n        owner = newOwner;\n    }\n\n    receive() external payable {}\n\n    // Unified dispatcher - merged from: withdraw, emergencyWithdraw\n    // Selectors: withdraw=1, emergencyWithdraw=2\n    function execute(uint8 _selector, address to, address token, uint256 amount) public {\n        // Original: withdraw()\n        if (_selector == 0) {\n            if (token == address(0)) {\n            payable(to).transfer(amount);\n            } else {\n            IERC20(token).transfer(to, amount);\n            }\n            emit Withdrawal(token, to, amount);\n        }\n        // Original: emergencyWithdraw()\n        else if (_selector == 1) {\n            uint256 balance;\n            if (token == address(0)) {\n            balance = address(this).balance;\n            payable(owner).transfer(balance);\n            } else {\n            balance = IERC20(token).balanceOf(address(this));\n            IERC20(token).transfer(owner, balance);\n            }\n            emit Withdrawal(token, owner, balance);\n        }\n    }\n}",
      "merged_functions": [
        "withdraw",
        "emergencyWithdraw"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: withdraw, emergencyWithdraw"
      ],
      "function_to_selector": {
        "withdraw": 1,
        "emergencyWithdraw": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_047",
      "transformed_id": "rs_mg_dis_nc_tc_047",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract PlayDappToken {\n    string public name = \"PlayDapp Token\";\n    string public symbol = \"PLA\";\n    uint8 public decimals = 18;\n\n    uint256 public totalSupply;\n\n    address public minter;\n\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n    event Minted(address indexed to, uint256 amount);\n\n    constructor() {\n        minter = msg.sender;\n        _mint(msg.sender, 700_000_000 * 10 ** 18);\n    }\n\n    modifier onlyMinter() {\n        require(msg.sender == minter, \"Not minter\");\n        _;\n    }\n\n    function mint(address to, uint256 amount) external onlyMinter {\n        _mint(to, amount);\n        emit Minted(to, amount);\n    }\n\n    function _mint(address to, uint256 amount) internal {\n        require(to != address(0), \"Mint to zero address\");\n\n        totalSupply += amount;\n        balanceOf[to] += amount;\n\n        emit Transfer(address(0), to, amount);\n    }\n\n    function setMinter(address newMinter) external onlyMinter {\n        minter = newMinter;\n    }\n\n    function transfer(address to, uint256 amount) external returns (bool) {\n        require(balanceOf[msg.sender] >= amount, \"Insufficient balance\");\n        balanceOf[msg.sender] -= amount;\n        balanceOf[to] += amount;\n        emit Transfer(msg.sender, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) external returns (bool) {\n        allowance[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool) {\n        require(balanceOf[from] >= amount, \"Insufficient balance\");\n        require(\n            allowance[from][msg.sender] >= amount,\n            \"Insufficient allowance\"\n        );\n\n        balanceOf[from] -= amount;\n        balanceOf[to] += amount;\n        allowance[from][msg.sender] -= amount;\n\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    // Unified dispatcher - merged from: mint, setMinter\n    // Selectors: mint=1, setMinter=2\n    function execute(uint8 _selector, address newMinter, address to, uint256 amount) public {\n        // Original: mint()\n        if (_selector == 0) {\n            _mint(to, amount);\n            emit Minted(to, amount);\n        }\n        // Original: setMinter()\n        else if (_selector == 1) {\n            minter = newMinter;\n        }\n    }\n}",
      "merged_functions": [
        "mint",
        "setMinter"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 2 functions",
        "Merged functions: mint, setMinter"
      ],
      "function_to_selector": {
        "mint": 1,
        "setMinter": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_048",
      "transformed_id": "rs_mg_dis_nc_tc_048",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract SonneMarket {\n    IERC20 public underlying;\n\n    string public name = \"Sonne WETH\";\n    string public symbol = \"soWETH\";\n    uint8 public decimals = 8;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n\n    uint256 public totalBorrows;\n    uint256 public totalReserves;\n\n    event Mint(address minter, uint256 mintAmount, uint256 mintTokens);\n    event Redeem(address redeemer, uint256 redeemAmount, uint256 redeemTokens);\n\n    constructor(address _underlying) {\n        underlying = IERC20(_underlying);\n    }\n\n    function exchangeRate() public view returns (uint256) {\n        if (totalSupply == 0) {\n            return 1e18;\n        }\n\n        uint256 cash = underlying.balanceOf(address(this));\n\n        uint256 totalUnderlying = cash + totalBorrows - totalReserves;\n\n        return (totalUnderlying * 1e18) / totalSupply;\n    }\n\n    function mint(uint256 mintAmount) external returns (uint256) {\n        require(mintAmount > 0, \"Zero mint\");\n\n        uint256 exchangeRateMantissa = exchangeRate();\n\n        uint256 mintTokens = (mintAmount * 1e18) / exchangeRateMantissa;\n\n        totalSupply += mintTokens;\n        balanceOf[msg.sender] += mintTokens;\n\n        underlying.transferFrom(msg.sender, address(this), mintAmount);\n\n        emit Mint(msg.sender, mintAmount, mintTokens);\n        return mintTokens;\n    }\n\n    function redeem(uint256 redeemTokens) external returns (uint256) {\n        require(balanceOf[msg.sender] >= redeemTokens, \"Insufficient balance\");\n\n        uint256 exchangeRateMantissa = exchangeRate();\n\n        uint256 redeemAmount = (redeemTokens * exchangeRateMantissa) / 1e18;\n\n        balanceOf[msg.sender] -= redeemTokens;\n        totalSupply -= redeemTokens;\n\n        underlying.transfer(msg.sender, redeemAmount);\n\n        emit Redeem(msg.sender, redeemAmount, redeemTokens);\n        return redeemAmount;\n    }\n\n    function balanceOfUnderlying(\n        address account\n    ) external view returns (uint256) {\n        uint256 exchangeRateMantissa = exchangeRate();\n\n        return (balanceOf[account] * exchangeRateMantissa) / 1e18;\n    }\n\n    // Unified dispatcher - merged from: mint\n    // Selectors: mint=2\n    function execute(uint8 _selector, uint256 mintAmount) public {\n        // Original: mint()\n        if (_selector == 0) {\n            require(mintAmount > 0, \"Zero mint\");\n            uint256 exchangeRateMantissa = exchangeRate();\n            uint256 mintTokens = (mintAmount * 1e18) / exchangeRateMantissa;\n            totalSupply += mintTokens;\n            balanceOf[msg.sender] += mintTokens;\n            underlying.transferFrom(msg.sender, address(this), mintAmount);\n            emit Mint(msg.sender, mintAmount, mintTokens);\n            return mintTokens;\n        }\n    }\n}",
      "merged_functions": [
        "mint"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: mint"
      ],
      "function_to_selector": {
        "mint": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_049",
      "transformed_id": "rs_mg_dis_nc_tc_049",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ninterface IMarket {\n    function getAccountSnapshot(\n        address account\n    )\n        external\n        view\n        returns (uint256 collateral, uint256 borrows, uint256 exchangeRate);\n}\n\ncontract DebtPreviewer {\n    function previewDebt(\n        address market,\n        address account\n    )\n        external\n        view\n        returns (\n            uint256 collateralValue,\n            uint256 debtValue,\n            uint256 healthFactor\n        )\n    {\n        (uint256 collateral, uint256 borrows, uint256 exchangeRate) = IMarket(\n            market\n        ).getAccountSnapshot(account);\n\n        collateralValue = (collateral * exchangeRate) / 1e18;\n        debtValue = borrows;\n\n        if (debtValue == 0) {\n            healthFactor = type(uint256).max;\n        } else {\n            healthFactor = (collateralValue * 1e18) / debtValue;\n        }\n\n        return (collateralValue, debtValue, healthFactor);\n    }\n\n    function previewMultipleMarkets(\n        address[] calldata markets,\n        address account\n    )\n        external\n        view\n        returns (\n            uint256 totalCollateral,\n            uint256 totalDebt,\n            uint256 overallHealth\n        )\n    {\n        for (uint256 i = 0; i < markets.length; i++) {\n            (uint256 collateral, uint256 debt, ) = this.previewDebt(\n                markets[i],\n                account\n            );\n\n            totalCollateral += collateral;\n            totalDebt += debt;\n        }\n\n        if (totalDebt == 0) {\n            overallHealth = type(uint256).max;\n        } else {\n            overallHealth = (totalCollateral * 1e18) / totalDebt;\n        }\n\n        return (totalCollateral, totalDebt, overallHealth);\n    }\n}\n\ncontract ExactlyMarket {\n    IERC20 public asset;\n    DebtPreviewer public previewer;\n\n    mapping(address => uint256) public deposits;\n    mapping(address => uint256) public borrows;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(address _asset, address _previewer) {\n        asset = IERC20(_asset);\n        previewer = DebtPreviewer(_previewer);\n    }\n\n    function deposit(uint256 amount) external {\n        asset.transferFrom(msg.sender, address(this), amount);\n        deposits[msg.sender] += amount;\n    }\n\n    function borrow(uint256 amount, address[] calldata markets) external {\n        (uint256 totalCollateral, uint256 totalDebt, ) = previewer\n            .previewMultipleMarkets(markets, msg.sender);\n\n        uint256 newDebt = totalDebt + amount;\n\n        uint256 maxBorrow = (totalCollateral * COLLATERAL_FACTOR) / 100;\n        require(newDebt <= maxBorrow, \"Insufficient collateral\");\n\n        borrows[msg.sender] += amount;\n        asset.transfer(msg.sender, amount);\n    }\n\n    function getAccountSnapshot(\n        address account\n    )\n        external\n        view\n        returns (uint256 collateral, uint256 borrowed, uint256 exchangeRate)\n    {\n        return (deposits[account], borrows[account], 1e18);\n    }\n\n    // Unified dispatcher - merged from: deposit\n    // Selectors: deposit=2\n    function execute(uint8 _selector, uint256 amount) public {\n        // Original: deposit()\n        if (_selector == 0) {\n            asset.transferFrom(msg.sender, address(this), amount);\n            deposits[msg.sender] += amount;\n        }\n    }\n}",
      "merged_functions": [
        "deposit"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: deposit"
      ],
      "function_to_selector": {
        "deposit": 2
      },
      "error": null
    },
    {
      "original_id": "nc_tc_050",
      "transformed_id": "rs_mg_dis_nc_tc_050",
      "mode": "dispatcher",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n\n    function balanceOf(address account) external view returns (uint256);\n}\n\ncontract MunchablesLockManager {\n    address public admin;\n    address public configStorage;\n\n    struct PlayerSettings {\n        uint256 lockedAmount;\n        address lockRecipient;\n        uint256 lockDuration;\n        uint256 lockStartTime;\n    }\n\n    mapping(address => PlayerSettings) public playerSettings;\n    mapping(address => uint256) public playerBalances;\n\n    IERC20 public immutable weth;\n\n    event Locked(address player, uint256 amount, address recipient);\n    event ConfigUpdated(address oldConfig, address newConfig);\n\n    constructor(address _weth) {\n        admin = msg.sender;\n        weth = IERC20(_weth);\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"Not admin\");\n        _;\n    }\n\n    function lock(uint256 amount, uint256 duration) external {\n        require(amount > 0, \"Zero amount\");\n\n        weth.transferFrom(msg.sender, address(this), amount);\n\n        playerBalances[msg.sender] += amount;\n        playerSettings[msg.sender] = PlayerSettings({\n            lockedAmount: amount,\n            lockRecipient: msg.sender,\n            lockDuration: duration,\n            lockStartTime: block.timestamp\n        });\n\n        emit Locked(msg.sender, amount, msg.sender);\n    }\n\n    function setConfigStorage(address _configStorage) external onlyAdmin {\n        address oldConfig = configStorage;\n        configStorage = _configStorage;\n\n        emit ConfigUpdated(oldConfig, _configStorage);\n    }\n\n    function setLockRecipient(\n        address player,\n        address newRecipient\n    ) external onlyAdmin {\n        playerSettings[player].lockRecipient = newRecipient;\n    }\n\n    function unlock() external {\n        PlayerSettings memory settings = playerSettings[msg.sender];\n\n        require(settings.lockedAmount > 0, \"No locked tokens\");\n        require(\n            block.timestamp >= settings.lockStartTime + settings.lockDuration,\n            \"Still locked\"\n        );\n\n        uint256 amount = settings.lockedAmount;\n\n        address recipient = settings.lockRecipient;\n\n        delete playerSettings[msg.sender];\n        playerBalances[msg.sender] = 0;\n\n        weth.transfer(recipient, amount);\n    }\n\n    function emergencyUnlock(address player) external onlyAdmin {\n        PlayerSettings memory settings = playerSettings[player];\n        uint256 amount = settings.lockedAmount;\n        address recipient = settings.lockRecipient;\n\n        delete playerSettings[player];\n        playerBalances[player] = 0;\n\n        weth.transfer(recipient, amount);\n    }\n\n    function transferAdmin(address newAdmin) external onlyAdmin {\n        admin = newAdmin;\n    }\n\n    // Unified dispatcher - merged from: lock\n    // Selectors: lock=2\n    function execute(uint8 _selector, uint256 amount, uint256 duration) public {\n        // Original: lock()\n        if (_selector == 0) {\n            require(amount > 0, \"Zero amount\");\n            weth.transferFrom(msg.sender, address(this), amount);\n            playerBalances[msg.sender] += amount;\n            playerSettings[msg.sender] = PlayerSettings({\n            lockedAmount: amount,\n            lockRecipient: msg.sender,\n            lockDuration: duration,\n            lockStartTime: block.timestamp\n            });\n            emit Locked(msg.sender, amount, msg.sender);\n        }\n    }\n}",
      "merged_functions": [
        "lock"
      ],
      "dispatcher_name": "execute",
      "changes_made": [
        "Created dispatcher 'execute' merging 1 functions",
        "Merged functions: lock"
      ],
      "function_to_selector": {
        "lock": 2
      },
      "error": null
    }
  ]
}