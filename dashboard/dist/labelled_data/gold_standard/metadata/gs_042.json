{
  "id": "gs_042",
  "original_id": "gs_cantina_kyber_001",
  "source_dataset": "gold_standard",
  "vulnerability_type": "signature_validation",
  "severity": "medium",
  "difficulty_tier": 3,
  "context_level": "single_file",
  "is_vulnerable": true,
  "finding_title": "Signed Swap Digest Lacks a Domain Separator Enabling Cross-Chain Signature Replay",
  "finding_description": "The Kyber hooks (UniswapV4KEMHook and PancakeSwapInfinityKEMHook) rebuild a quote digest by hashing sender, pool key, trade parameters, nonce, and expiry time without including a domain separator. This omission allows valid signatures from one blockchain to be replayed on another where the same hook instance is deployed, breaking the single-instance authorization guarantee.",
  "vulnerable_lines": [],
  "vulnerable_functions": [],
  "has_context": true,
  "fix_description": "Implement EIP-712 domain separation by computing and including a domain separator in the signed payload.",
  "expert_notes": "This is a critical EIP-712 pattern violation. The digest construction fails to commit to: (1) chain identity (block.chainid), (2) contract identity (address(this)), and (3) deployment context (salt). CREATE3 enables deterministic addresses across chains, making this replay vector practical. The fix requires adopting proper EIP-712 domain separation with at minimum block.chainid inclusion. Kyber's mitigation of chain-specific operator signing keys reduces but does not eliminate the attack surface if signatures are ever shared or if the operator key is compromised.",
  "context_hint": "The vulnerability exploits the lack of domain separation in EIP-712 signature construction. By omitting chainId, verifying contract address, and deployment salt from the digest, the same signed payload becomes valid across all networks. This breaks the intended authorization model where each network should have independent quote validation.",
  "call_flow": [
    "1. Attacker obtains valid signature and nonce from Chain A (Ethereum mainnet)",
    "2. Kyber deploys identical hook to Chain B (Polygon) using CREATE3 salt mining",
    "3. Same PoolKey exists on Chain B (same tokens, same hook address via CREATE3)",
    "4. Attacker broadcasts same signature + calldata on Chain B",
    "5. SwapDigest computed identically (no chainId or contract identity in hash)",
    "6. SignatureChecker.isValidSignatureNow() validates successfully",
    "7. Swap executes without original signer's authorization on Chain B",
    "8. Attack repeats across all chains where hook is deployed"
  ]
}