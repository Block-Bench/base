{
  "id": "gs_016",
  "original_id": "gs_spearbit_aragon-lock-to-vote_M04",
  "source_dataset": "gold_standard",
  "source_file": "aragon.json",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "spearbit",
  "source_report": "Aragon DAO Gov Plugin Security Review",
  "source_finding_id": "M-04",
  "report_url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
  "github_repo_url": "https://github.com/aragon/lock-to-vote-plugin/tree/b3c5503c",
  "contest_date": "2025-09-11",
  "vulnerability_type": "access_control",
  "severity": "medium",
  "difficulty_tier": 3,
  "context_level": "multi_file",
  "is_vulnerable": true,
  "finding_title": "Proposal's action should not be able to target the voting contract or the lock manager",
  "finding_description": "The LockToVotePlugin.createProposal() at lines 77-131 does not perform any validation on the actions bound to the proposal. The for loop at lines 121-126 just pushes actions without checking targets. If the plugin's targetConfig is set to execute with delegatecall, actions targeting the LockManager will be executed on behalf of the plugin, allowing attackers to call proposalEnded() to remove active proposals from tracking.",
  "attack_scenario": "1. A 'normal' proposal_1 is created ending in 1 year.\n2. Alice locks 100 tokens, votes NO on proposal_1.\n3. Attacker creates proposal_2 with action: LockManager.proposalEnded(proposal_1_id).\n4. proposal_2 passes and executes.\n5. proposalEnded(proposal_1) is called via delegatecall from the plugin.\n6. proposal_1 is removed from knownProposalIds.\n7. Alice calls unlock() - her NO vote is not cleared because proposal_1 isn't tracked.\n8. Alice withdraws tokens while her vote is still active on proposal_1.",
  "fix_description": "Prevent the creation of new proposals when the action's target is address(this) (the plugin) or address(lockManager). Add validation in createProposal: 'if (_actions[i].to == address(this) || _actions[i].to == address(lockManager)) revert InvalidTarget();'",
  "call_flow": "Attacker.createProposal(actions=[call to LockManager.proposalEnded(victimProposalId)]) -> proposal passes -> execute() -> delegatecall to target -> LockManager.proposalEnded() called from plugin address -> msg.sender check passes -> knownProposalIds.remove()",
  "context_hint": "The createProposal() function at lines 121-126 has a for loop that pushes actions without any validation. Since msg.sender for proposalEnded() is checked against address(plugin), and delegatecall preserves msg.sender, an attacker can craft a proposal that calls LockManager.proposalEnded() to manipulate the governance tracking.",
  "primary_file_path": "src/LockToVotePlugin.sol",
  "vulnerable_lines": [
    77,
    78,
    79,
    80,
    81,
    82,
    83,
    84,
    85,
    86,
    87,
    88,
    89,
    90,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131
  ],
  "vulnerable_functions": [
    "createProposal"
  ],
  "context_files": [
    {
      "filename": "context_01_LockManagerBase.sol",
      "original_path": "src/base/LockManagerBase.sol",
      "relevance": "Contains proposalEnded() at lines 159-166 which can be maliciously invoked via crafted proposal actions to remove active proposals from knownProposalIds tracking."
    }
  ],
  "has_context": true
}