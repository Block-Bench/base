{
  "id": "gs_011",
  "original_id": "gs_spearbit_aragon-lock-to-vote_H01",
  "source_dataset": "gold_standard",
  "source_file": "aragon.json",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "spearbit",
  "source_report": "Aragon DAO Gov Plugin Security Review",
  "source_finding_id": "H-01",
  "report_url": "https://github.com/spearbit/portfolio/blob/master/pdfs/Aragon-Spearbit-Security-Review-July-2025.pdf",
  "github_repo_url": "https://github.com/aragon/lock-to-vote-plugin/tree/b3c5503c",
  "contest_date": "2025-09-11",
  "vulnerability_type": "flash_loan",
  "severity": "high",
  "difficulty_tier": 3,
  "context_level": "multi_file",
  "is_vulnerable": true,
  "finding_title": "MinVotingPowerCondition logic can be bypassed via flashloans",
  "finding_description": "The MinVotingPowerCondition contract allows any users who hold at least plugin.minProposerVotingPower() amount of tokens (locked in the LockManager or in their token balance) to create a proposal and execute LockToVote.createProposal. This logic can be easily bypassed if the token allows flashloan or flashmint. Given that isGranted checks the user's token balance (line 45: token.balanceOf(_who) + lockManager.getLockedBalance(_who)), the user does not even need to lock the flashloaned amount into the LockManager to be able to create and spam proposals.",
  "attack_scenario": "1. Flashloan the token.\n2. Create the proposal (isGranted passes because token.balanceOf includes flashloaned amount).\n3. Lock + vote the proposal and auto-execute it (EarlyExecution).\n4. Unlock the tokens.\n5. Repay the flashloan.\nAll in the very same transaction.",
  "fix_description": "Avoid using the token's balance and require the user to only use the locked amount. Change line 45 from 'token.balanceOf(_who) + lockManager.getLockedBalance(_who)' to just 'lockManager.getLockedBalance(_who)'. Store the proposal's creator in the proposal struct and require that the locked amount required to create the proposal won't be unlockable until the proposal ends.",
  "call_flow": "Attacker.flashloan() -> MinVotingPowerCondition.isGranted() checks token.balanceOf(_who) + lockManager.getLockedBalance(_who) -> returns true -> LockToVotePlugin.createProposal() succeeds -> repay flashloan",
  "context_hint": "The MinVotingPowerCondition.isGranted() function at line 45 checks 'token.balanceOf(_who) + lockManager.getLockedBalance(_who)'. Since token.balanceOf() can be temporarily inflated via flashloans, an attacker can bypass the minimum voting power requirement without actually having tokens locked. Combined with EarlyExecution mode, this allows creating and executing malicious proposals in a single transaction.",
  "primary_file_path": "src/conditions/MinVotingPowerCondition.sol",
  "vulnerable_lines": [
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48
  ],
  "vulnerable_functions": [
    "isGranted"
  ],
  "context_files": [
    {
      "filename": "context_01_LockToVotePlugin.sol",
      "original_path": "src/LockToVotePlugin.sol",
      "relevance": "The voting plugin that MinVotingPowerCondition protects. Contains createProposal which is the target of the bypass."
    },
    {
      "filename": "context_02_LockManagerBase.sol",
      "original_path": "src/base/LockManagerBase.sol",
      "relevance": "Manages token locking. The vulnerability allows bypassing the lock requirement via flashloans since isGranted checks raw balance."
    }
  ],
  "has_context": true
}