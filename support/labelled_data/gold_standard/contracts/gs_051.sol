use anchor_lang::prelude::*; use crate::common::{ internal::math::{fixed_pow, SCALE}, MAX_PARTNER_VALIDATOR_THRESHOLD, MAX_SIGNER_COUNT, }; use crate::BridgeError; #[account] #[derive(Debug, PartialEq, Eq, InitSpace)] pub struct Bridge { pub base_block_number: u64, pub nonce: u64, pub guardian: Pubkey, pub paused: bool, pub eip1559: Eip1559, pub gas_config: GasConfig, pub protocol_config: ProtocolConfig, pub buffer_config: BufferConfig, pub partner_oracle_config: PartnerOracleConfig, pub base_oracle_config: BaseOracleConfig, } #[derive(Debug, Clone, PartialEq, Eq, InitSpace, AnchorSerialize, AnchorDeserialize)] pub struct Eip1559 { pub config: Eip1559Config, pub current_base_fee: u64, pub current_window_gas_used: u64, pub window_start_time: i64, } #[derive(Debug, Clone, PartialEq, Eq, InitSpace, AnchorSerialize, AnchorDeserialize)] pub struct Eip1559Config { pub target: u64, pub denominator: u64, pub window_duration_seconds: u64, pub minimum_base_fee: u64, } impl Eip1559Config { pub fn validate(&self) -> Result<()> { require!(self.denominator > 0, BridgeError::InvalidDenominator); require!( self.window_duration_seconds > 0, BridgeError::InvalidWindowDurationSeconds ); Ok(()) } } impl Eip1559 { pub fn refresh_base_fee(&mut self, current_timestamp: i64) -> u64 { let expired_windows_count = self.expired_windows_count(current_timestamp); if expired_windows_count == 0 { return self.current_base_fee; } let mut current_base_fee = self.calc_base_fee(self.current_window_gas_used); let remaining_windows_count = expired_windows_count - 1; if remaining_windows_count > 0 { let scaled_denominator = self.config.denominator as u128 * SCALE; let ratio = (scaled_denominator - SCALE) / (self.config.denominator as u128); let factor = fixed_pow(ratio, remaining_windows_count); current_base_fee = ((current_base_fee as u128 * factor) / SCALE) as u64; } self.current_base_fee = current_base_fee.max(self.config.minimum_base_fee); self.current_window_gas_used = 0; self.window_start_time += (expired_windows_count * self.config.window_duration_seconds) as i64; self.current_base_fee } pub fn add_gas_usage(&mut self, gas_amount: u64) { self.current_window_gas_used += gas_amount; } fn calc_base_fee(&self, gas_used: u64) -> u64 { if gas_used == self.config.target { return self.current_base_fee; } if gas_used > self.config.target { let gas_used_delta = gas_used - self.config.target; let base_fee_delta = (gas_used_delta * self.current_base_fee) / self.config.target / self.config.denominator; let base_fee_delta = base_fee_delta.max(1); self.current_base_fee + base_fee_delta } else { let gas_used_delta = self.config.target - gas_used; let base_fee_delta = (gas_used_delta * self.current_base_fee) / self.config.target / self.config.denominator; self.current_base_fee.saturating_sub(base_fee_delta) } } fn expired_windows_count(&self, current_timestamp: i64) -> u64 { (current_timestamp as u64 - self.window_start_time as u64) / self.config.window_duration_seconds } } #[derive(Debug, Clone, PartialEq, Eq, InitSpace, AnchorSerialize, AnchorDeserialize)] pub struct GasConfig { pub gas_cost_scaler: u64, pub gas_cost_scaler_dp: u64, pub gas_fee_receiver: Pubkey, pub gas_per_call: u64, } impl GasConfig { pub fn validate(&self) -> Result<()> { require!( self.gas_cost_scaler_dp > 0, BridgeError::InvalidGasCostScalerDp ); Ok(()) } } #[derive(Debug, Clone, PartialEq, Eq, InitSpace, AnchorSerialize, AnchorDeserialize)] pub struct ProtocolConfig { pub block_interval_requirement: u64, pub remote_sol_address: [u8; 20], } impl ProtocolConfig { pub fn validate(&self) -> Result<()> { require!( self.block_interval_requirement > 0, BridgeError::InvalidBlockIntervalRequirement ); require!( self.block_interval_requirement <= 1000, BridgeError::InvalidBlockIntervalRequirement ); require!( self.remote_sol_address != [0u8; 20], BridgeError::ZeroAddress ); Ok(()) } } #[derive(Debug, Clone, PartialEq, Eq, InitSpace, AnchorSerialize, AnchorDeserialize)] pub struct BufferConfig { pub max_call_buffer_size: u64, } #[derive(Debug, Clone, PartialEq, Eq, InitSpace, AnchorSerialize, AnchorDeserialize, Default)] pub struct PartnerOracleConfig { pub required_threshold: u8, } impl PartnerOracleConfig { pub fn validate(&self) -> Result<()> { require!( self.required_threshold <= MAX_PARTNER_VALIDATOR_THRESHOLD, BridgeError::InvalidPartnerThreshold ); Ok(()) } } #[derive(Debug, Clone, PartialEq, Eq, InitSpace, AnchorSerialize, AnchorDeserialize)] pub struct BaseOracleConfig { pub threshold: u8, pub signer_count: u8, pub signers: [[u8; 20]; MAX_SIGNER_COUNT as usize], } impl BaseOracleConfig { pub fn validate(&self) -> Result<()> { require!( self.threshold > 0 && self.threshold <= self.signer_count, BridgeError::InvalidThreshold ); require!( self.signer_count as usize <= self.signers.len(), BridgeError::TooManySigners ); { let provided_count = self.signer_count as usize; let mut addrs: Vec<[u8; 20]> = self.signers[..provided_count].to_vec(); addrs.sort(); addrs.dedup(); require!(addrs.len() == provided_count, BridgeError::DuplicateSigner); } Ok(()) } pub fn contains(&self, evm_addr: &[u8; 20]) -> bool { let active_len = core::cmp::min(self.signer_count as usize, self.signers.len()); self.signers[..active_len].iter().any(|s| s == evm_addr) } pub fn count_approvals(&self, signers: &[[u8; 20]]) -> u32 { let mut count: u32 = 0; for signer in signers.iter() { if self.contains(signer) { count += 1; } } count } } #[cfg(test)] mod tests { use super::*; #[test] fn test_new_state_creation() { let timestamp = 1234567890; let state = Eip1559 { config: Eip1559Config::test_new(), current_base_fee: 1000, current_window_gas_used: 0, window_start_time: timestamp, }; assert_eq!(state.config, Eip1559Config::test_new()); assert_eq!(state.current_base_fee, 1000); assert_eq!(state.current_window_gas_used, 0); assert_eq!(state.window_start_time, timestamp); } #[test] fn test_calc_base_fee_gas_equals_target() { let state = Eip1559 { config: Eip1559Config::test_new(), current_base_fee: 1000, current_window_gas_used: 5_000_000, window_start_time: 0, }; let gas_used = state.config.target; let new_fee = state.calc_base_fee(gas_used); assert_eq!(new_fee, state.current_base_fee); } #[test] fn test_calc_base_fee_gas_above_target() { let state = Eip1559 { config: Eip1559Config::test_new(), current_base_fee: 1000, current_window_gas_used: 0, window_start_time: 0, }; let gas_used = state.config.target + 3_000_000; let new_fee = state.calc_base_fee(gas_used); let expected_adjustment = 300; assert_eq!(