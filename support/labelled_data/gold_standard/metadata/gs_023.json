{
  "id": "gs_023",
  "original_id": "gs_mixbytes_mantle-meth-aave_M01",
  "source_dataset": "gold_standard",
  "source_file": "mantle.json",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "mixbytes",
  "source_report": "Mantle mETH x Aave Integration Security Audit",
  "source_finding_id": "M-1",
  "report_url": "https://github.com/mixbytes/audits_public/tree/master/Mantle%20Network/mETH%20x%20Aave%20Integration",
  "github_repo_url": "https://github.com/mantle-lsp/contracts",
  "contest_date": "2025-10-22",
  "vulnerability_type": "logic_error",
  "severity": "medium",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "is_vulnerable": true,
  "finding_title": "Default manager deactivation in LiquidityBuffer can break auto-allocation",
  "finding_description": "Staking.allocateETH() forwards ETH to LiquidityBuffer.depositETH(), which auto-allocates to defaultManagerId when shouldExecuteAllocation is true. If the current default manager is deactivated via LiquidityBuffer.updatePositionManager()/togglePositionManagerStatus() without first switching defaultManagerId or disabling auto-allocation, _allocateETHToManager(defaultManagerId, \u2026) reverts with LiquidityBuffer__ManagerInactive(). This can unexpectedly block allocation flows.",
  "attack_scenario": "1. Admin sets defaultManagerId to manager 0 with shouldExecuteAllocation = true\n2. Admin calls togglePositionManagerStatus(0) to deactivate the default manager\n3. User calls Staking.allocateETH() which forwards to LiquidityBuffer.depositETH()\n4. depositETH() calls _allocateETHToManager(defaultManagerId, msg.value)\n5. _allocateETHToManager reverts with LiquidityBuffer__ManagerInactive() because the default manager is inactive\n6. All allocation flows are blocked until admin either reactivates the manager or changes defaultManagerId",
  "fix_description": "Prevent deactivation of the current defaultManagerId while auto-allocation is enabled: require shouldExecuteAllocation == false or switch defaultManagerId to an active manager before deactivation.",
  "call_flow": "Staking.allocateETH() -> LiquidityBuffer.depositETH() -> _allocateETHToManager(defaultManagerId) -> reverts if defaultManager.isActive == false",
  "context_hint": "The depositETH function auto-allocates to the default manager when shouldExecuteAllocation is true, but updatePositionManager and togglePositionManagerStatus can deactivate the default manager without any check, causing subsequent depositETH calls to revert.",
  "primary_file_path": "src/liquidityBuffer/LiquidityBuffer.sol",
  "vulnerable_lines": [
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
    256,
    258,
    259,
    260,
    261,
    262,
    263,
    264,
    265,
    266,
    267,
    268,
    269,
    270,
    271,
    334,
    335,
    336,
    337,
    338,
    339,
    340
  ],
  "vulnerable_functions": [
    "updatePositionManager",
    "togglePositionManagerStatus",
    "depositETH",
    "_allocateETHToManager"
  ],
  "context_files": [],
  "has_context": false
}