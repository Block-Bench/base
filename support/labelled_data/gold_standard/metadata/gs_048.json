{
  "id": "gs_048",
  "original_id": "gs_cantina_sablier_staking_001",
  "source_dataset": "gold_standard",
  "vulnerability_type": "denial_of_service",
  "severity": "medium",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "is_vulnerable": true,
  "finding_title": "Stream Recipient Can Block Sender's Cancellation by Transferring NFT Directly to Staking Contract",
  "finding_description": "Cancellable streams allow the sender to be able to recover the unstreamed amount. When an NFT is put to staking in the SablierStaking contract, a hook makes it possible to update the staking balance in case the sender cancels the stream. Unfortunately, we notice that when the NFT is owned by the staking contract, but not staked (_streamsLookup[msgSenderAsLockup][streamId].poolId == 0), the cancellation hook reverts.",
  "vulnerable_lines": [],
  "vulnerable_functions": [],
  "has_context": true,
  "fix_description": "Replace the revert with an early return when poolId is 0. This makes the hook idempotent and safe to call even if the NFT is not staked. If the NFT is not staked, there is nothing to unstake, so returning the correct selector is the right behavior.",
  "expert_notes": "Cantina identified this through hook logic review. The vulnerability exists because: (1) onSablierLockupCancel doesn't distinguish between 'never staked' and 'not currently found', (2) An attacker can send NFT without triggering _streamsLookup registration, (3) The hook reverts instead of being idempotent. The fix is to return early if poolId == 0 instead of reverting, making the hook safe to call regardless of NFT state.",
  "context_hint": "This is a front-running vulnerability where the recipient can observe the sender's cancellation and block it by putting the NFT in a state where the cancellation hook reverts. The hook assumes an NFT in the contract is staked, but an attacker can violate this assumption.",
  "call_flow": [
    "1. Alice creates stream: 1,000,000 USDC to Bob over 100 days",
    "2. Bob receives Lockup NFT (recipient)",
    "3. Bob stakes NFT in SablierStaking pool (normal use)",
    "4. Days pass, Bob earns rewards, Alice updates her mind",
    "5. Day 30: Alice initiates cancel() tx on Lockup",
    "6. Day 30 (mempool): Bob observes Alice's pending cancel tx",
    "7. Day 30 (front-run): Bob withdraws his streamed USDC (~300k)",
    "8. Day 30 (front-run): Bob unstakes NFT from SablierStaking pool",
    "9. Day 30 (front-run): Bob transfers NFT to SablierStaking directly",
    "10. Day 30 (front-run): NFT arrives but onERC721Received fails or gets invalid data",
    "11. Day 30 (front-run): _streamsLookup entry is never created for this transfer",
    "12. Day 30 (front-run): poolId remains 0 for this NFT+streamId combination",
    "13. Day 30 (settle): Alice's cancel tx executes",
    "14. Day 30 (settle): Lockup calls onSablierLockupCancel hook",
    "15. Day 30 (settle): Hook queries: poolId = _streamsLookup[lockup][streamId].poolId",
    "16. Day 30 (settle): poolId is 0 (from step 12)",
    "17. Day 30 (settle): Hook reverts: SablierStaking_StreamNotStaked",
    "18. Day 30 (result): Alice's cancel tx fails",
    "19. Day 30+: Alice cannot cancel stream",
    "20. Day 30+: 700,000 USDC remains locked until NFT is moved"
  ]
}