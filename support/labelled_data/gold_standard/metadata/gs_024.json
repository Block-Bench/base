{
  "id": "gs_024",
  "original_id": "gs_mixbytes_mantle-meth-aave_M02",
  "source_dataset": "gold_standard",
  "source_file": "mantle.json",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "mixbytes",
  "source_report": "Mantle mETH x Aave Integration Security Audit",
  "source_finding_id": "M-2",
  "report_url": "https://github.com/mixbytes/audits_public/tree/master/Mantle%20Network/mETH%20x%20Aave%20Integration",
  "github_repo_url": "https://github.com/mantle-lsp/contracts",
  "contest_date": "2025-10-22",
  "vulnerability_type": "logic_error",
  "severity": "medium",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "is_vulnerable": true,
  "finding_title": "Inactive managers may under-report funds",
  "finding_description": "LiquidityBuffer.getControlledBalance() sums balances of managers with isActive == true only. If an admin deactivates a manager via updatePositionManager()/togglePositionManagerStatus() before evacuating funds, any residual underlying on that manager is excluded from the total, causing under-reporting. Moreover, withdrawals from inactive managers are blocked (_withdrawETHFromManager and onlyPositionManagerContract both require the manager to be active), so the funds remain inaccessible until the manager is reactivated.",
  "attack_scenario": "1. Position manager 0 has 1000 ETH allocated to it in Aave\n2. Admin calls togglePositionManagerStatus(0) to deactivate manager 0 without first withdrawing funds\n3. getControlledBalance() now returns a value that is 1000 ETH less than the actual protocol holdings\n4. _withdrawETHFromManager(0, amount) reverts with LiquidityBuffer__ManagerInactive()\n5. The 1000 ETH is effectively locked and invisible to the protocol accounting until admin reactivates the manager",
  "fix_description": "Check underlying balance before deactivation and use a dedicated forceDeactivate() if it's not zero. This was fixed in commit 93280383c0858c559270ceaec6f5d04f9be0a8e7.",
  "call_flow": "getControlledBalance() loops through managers but skips inactive ones -> _withdrawETHFromManager() reverts for inactive managers -> funds locked until reactivation",
  "context_hint": "The getControlledBalance function only sums balances from active managers, but deactivation doesn't force fund evacuation first. This causes under-reporting of controlled funds and locks the funds since _withdrawETHFromManager requires the manager to be active.",
  "primary_file_path": "src/liquidityBuffer/LiquidityBuffer.sol",
  "vulnerable_lines": [
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    441,
    442,
    443,
    444,
    445,
    446,
    447,
    545,
    546,
    547,
    548,
    549,
    550,
    551,
    552,
    553,
    554,
    555,
    556,
    557,
    558,
    559,
    560,
    561,
    562
  ],
  "vulnerable_functions": [
    "getControlledBalance",
    "_withdrawETHFromManager",
    "onlyPositionManagerContract"
  ],
  "context_files": [],
  "has_context": false
}