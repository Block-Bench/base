{
  "id": "gs_053",
  "original_id": "gs_cantina_seamless_H001",
  "source_dataset": "gold_standard",
  "vulnerability_type": "arbitrary_external_call",
  "severity": "high",
  "difficulty_tier": 3,
  "context_level": "single_file",
  "is_vulnerable": true,
  "finding_title": "Unauthorized Transfer of User-Approved ERC20 Tokens via LeverageRouter",
  "finding_description": "In _depositAndRepayMorphoFlashLoan & _redeemAndRepayMorphoFlashLoan internal functions, it allows arbitrary external calls to the any addresses which are passed as Call[] calldata swapCalls from deposit or redeem entrypoint.  for (uint256 i = 0; i < params.swapCalls.length; i++) {             // slither-disable-next-line unused-return             Address.functionCallWithValue(                 params.swapCalls[i].target, params.swapCalls[i].data, params.swapCalls[i].value             );         } Since LeverageRouter is used for minting and redeeming leverage tokens by end users, It needs to have ERC20 allowance for minting shares and leverage tokens allowance for redeeming. These are approved just in time before actual mint / redeem transaction or may have infinite allowance if given by user.  However, A malicious actor can drain all funds by adding a transferFrom call in swapCalls input to deposit / redeem function on ERC20 from user who has approved, and to address being their controlled address  Other similar paths exist to extract to steal the approved funds & to take allowance so that future funds could be stolen such as:  calling morpho.flashLoan from arbitrary call which triggers callback with data which is not sanitized. calling permit2 to take the infinite token allowance of router where spender is attacker controlled address. This is especially more exploitable on chains which public mempool such as ethereum mainnet.",
  "vulnerable_lines": [],
  "vulnerable_functions": [
    "_depositAndRepayMorphoFlashLoan",
    "_redeemAndRepayMorphoFlashLoan",
    "deposit",
    "redeem"
  ],
  "has_context": true,
  "attack_scenario": "1. Alice (victim) approves LeverageRouter contract to spend her collateral tokens (e.g., 123 ETH worth)\n2. Bob (attacker) crafts a malicious deposit transaction with swapCalls array\n3. Bob's swapCalls includes: {target: collateralToken, data: transferFrom(alice, bob, 123 ether), value: 0}\n4. Bob calls leverageRouter.deposit() with 0 actual deposit but malicious swapCalls\n5. LeverageRouter executes the arbitrary call via Address.functionCallWithValue\n6. The transferFrom call succeeds because Alice has approved LeverageRouter\n7. Bob receives all of Alice's approved collateral tokens\n8. Attack can be repeated for all users who have approved the router\n9. Similar attacks possible via permit2 allowance theft or malicious flashLoan callbacks\n10. Especially exploitable on chains with public mempools like Ethereum mainnet",
  "fix_description": "There are two main ways of tackling this:\n1. All external calls should be fully validated for address and calldata being trusted and whitelisted to ensure there are no risks. Anything in the path of morpho flashloan callback should check for re-entrancy.\n2. Use a separate contract (MulticallExecutor) to make untrusted external calls which doesn't hold any assets, approvals or privileged roles outside of a single transaction context.\n\nThe fix implemented was option 2: Created MulticallExecutor contract that handles arbitrary external calls in isolation, preventing access to user approvals. The LeverageRouter was modified to delegate swap execution to this separate contract that has no token approvals.",
  "expert_notes": "This represents a classic 'unauthorized approval exploitation' vulnerability in DeFi routers. The core issue is mixing privileged operations (holding user approvals) with untrusted operations (arbitrary external calls). Key insights: (1) The vulnerability pattern is common in DEX aggregators and routers that need approvals, (2) Defense-in-depth would include: whitelist validation, separate executor contracts, and flash-loan style approvals that expire after transaction, (3) The MulticallExecutor fix is elegant - it completely isolates the attack surface by ensuring the contract executing arbitrary calls has zero privileges, (4) Additional attack vectors mentioned (permit2, flashLoan callbacks) show this is a systemic design flaw not just a single code path issue, (5) On Ethereum mainnet with public mempool, attackers can front-run legitimate transactions to exploit approvals. Similar vulnerabilities: the $196M Beanstalk hack, multiple DEX aggregator exploits.",
  "context_hint": "This is a critical vulnerability in swap execution logic where untrusted user input (swapCalls array) is executed without validation. The LeverageRouter contract requires users to approve it for token spending to facilitate deposits/redemptions. An attacker exploits this by crafting malicious swapCalls that invoke transferFrom on ERC20 tokens, stealing funds from any user who has approved the router. The vulnerability is compounded by the fact that: (1) the router needs persistent approvals from users, (2) arbitrary addresses and calldata can be passed, (3) multiple attack vectors exist (direct transferFrom, permit2, malicious flashLoan callbacks), and (4) it's especially dangerous on chains with public mempools. The fix uses the isolated MulticallExecutor pattern - a separate contract with no approvals handles all arbitrary external calls.",
  "call_flow": "User.deposit() -> LeverageRouter.deposit() -> LeverageRouter._depositAndRepayMorphoFlashLoan() -> loops through swapCalls[] -> Address.functionCallWithValue(maliciousTarget, maliciousData) -> ERC20.transferFrom(victim, attacker, amount) using victim's prior approval to LeverageRouter"
}