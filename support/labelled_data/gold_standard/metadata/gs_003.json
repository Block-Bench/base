{
  "id": "gs_003",
  "original_id": "gs_c4_2025-10-hybra-finance_M02",
  "source_dataset": "gold_standard",
  "source_file": "Hybrafin.json",
  "language": "solidity",
  "chain": "ethereum",
  "source_platform": "code4rena",
  "source_report": "2025-10-hybra-finance",
  "source_finding_id": "M-02",
  "report_url": "https://code4rena.com/reports/2025-10-hybra-finance",
  "github_repo_url": "https://github.com/code-423n4/2025-10-hybra-finance",
  "contest_date": "2025-10-06",
  "vulnerability_type": "logic_error",
  "severity": "medium",
  "difficulty_tier": 2,
  "context_level": "single_file",
  "is_vulnerable": true,
  "finding_title": "Users emergency withdrawing will lose all past accrued rewards",
  "finding_description": "in the `GaugeV2` contract, if the contract was emergency activated, users calling `emergencyWithdraw()` will lose all past accrued rewards that didn\u2019t have `updateReward()` called on it previously for a user to earn rewards, he gets his mappings updated here modifier updateReward(address account) { rewardPerTokenStored = rewardPerToken(); lastUpdateTime = lastTimeRewardApplicable(); if (account != address(0)) { rewards[account] = earned(account); userRewardPerTokenPaid[account] = rewardPerTokenStored; } _; } as we see above, rewards mapping is registered as the return data from `earned()`, and when we look at it we see function earned(address account) public view returns (uint256) { rewards[account] + _balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18; } we see that it returns old rewards + current balance of the user multiplied by the rewardPerToken (abstractly) so what happen will be as follows: 1. User stake 100e18 tokens 2. emergency activated 3. he had already earnt before the emergency 10e18 tokens not registered on his rewards mapping since he didn\u2019t call deposit/withdraw/getRewards to update his rewards 4. call emergencyWithdraw and his balance now is 0. 5. now earned() function return 0 rewards since his balance is 0 * rewardPerToken = 0 also the left-off rewards tokens are stuck in the contract forever. Impact: Loss of rewards for users and stuck reward tokens in the contract",
  "attack_scenario": "function test_emergencyWithdraw_strandsRewardsAndBurnsUserAccrual() external { vm.startPrank(address(this)); // Use HYBR both as staking TOKEN and rewardToken for simplicity // We have HYBR minted to this test from setup_InitMinter() uint256 initialHybr = hybr.balanceOf(address(this)); assertGt(initialHybr, 0, \"expected HYBR from initial mint\"); // Deploy GaugeV2 GaugeV2 gauge = new GaugeV2( address(hybr), address(rewardHybr), address(votingEscrow), address(hybr), address(this), address(0), address(0), false ); // Stake HYBR uint256 stakeAmount = 100 ether; hybr.approve(address(gauge), type(uint256).max); gauge.deposit(stakeAmount); // Fund rewards uint256 rewardAmount = 1_000 ether; hybr.approve(address(gauge), rewardAmount); gauge.notifyRewardAmount(address(hybr), rewardAmount); // Accrue some rewards vm.warp(block.timestamp + 7 days / 14); uint256 accruedBefore = gauge.earned(address(this)); assertGt(accruedBefore, 0, \"accrued must be > 0 before emergencyWithdraw\"); // Enable emergency and withdraw gauge.activateEmergencyMode(); gauge.emergencyWithdraw(); uint256 accruedAfter = gauge.earned(address(this)); assertEq(accruedAfter, 0, \"accrued should be zero after emergencyWithdraw\"); uint256 stuckRewards = hybr.balanceOf(address(gauge)); assertGt(stuckRewards, 0, \"reward tokens remain stuck in gauge\"); vm.stopPrank(); }",
  "fix_description": "Add the `updateReward` modifier to the `emergencyWithdraw()` call",
  "call_flow": "User.deposit() -> notifyRewardAmount() -> warp time -> activateEmergencyMode() -> emergencyWithdraw() -> earned() returns 0",
  "context_hint": "Emergency withdraw skips reward update, burning unclaimed rewards and leaving tokens stuck in the gauge.",
  "primary_file_path": "ve33/contracts/GaugeV2.sol",
  "vulnerable_lines": [
    270,
    271,
    272,
    273,
    274,
    275,
    276,
    277,
    278,
    279,
    280,
    281
  ],
  "vulnerable_functions": [
    "emergencyWithdraw",
    "updateReward",
    "earned"
  ],
  "context_files": [],
  "has_context": false
}