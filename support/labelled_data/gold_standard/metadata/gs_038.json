{
  "id": "gs_038",
  "original_id": "gs_quantstamp_startale_sta003",
  "source_dataset": "gold_standard",
  "vulnerability_type": "rounding_error",
  "severity": "medium",
  "difficulty_tier": 3,
  "context_level": "single_file",
  "is_vulnerable": true,
  "finding_title": "Incorrect S_base Calculation with Donations",
  "finding_description": "The _calculateSplit() function includes accidental token transfers (donations) in the gross amount used to compute S_base (supply basis). When the contract holds a balance before distribute() is called, this balance is included in the gross calculation, causing S_base to be understated and yield to be misdistributed between vaults and treasury.",
  "vulnerable_lines": [
    106,
    107,
    108,
    109,
    110,
    145,
    146,
    147,
    148
  ],
  "vulnerable_functions": [
    "distribute",
    "_calculateSplit"
  ],
  "has_context": false,
  "attack_scenario": "1. Someone accidentally sends 1M USDSC directly to RewardRedistributor contract (common user error)\n2. Operator calls distribute(), which claims 5M USDSC yield from M0\n3. balanceBefore = 1M (the donation), minted = 5M, gross = 6M\n4. _calculateSplit() receives gross = 6M\n5. S_base calculation: SNow = 1,050,000,000 (1.05B USDSC total supply), sBase = 1.05B - 6M = 1.044B\n6. Yield split using S_base = 1.044B instead of correct 1.05B\n7. Distribution: toEarn = (5M * 2M) / 1.044B = 9.54M (should be 9.52M)\n8. Distribution: toOn = (5M * 1.05B) / 1.044B = 5.02B (should be 5B)\n9. toStartaleExtra gets 0 instead of 19.2k\n10. Vault profit: 19.2k USDSC lost per donation\n11. With $1M donation: ~190 USDSC impact. With multiple donations accumulating: 157k+ USDSC lost per distribution cycle",
  "fix_description": "Use minted yield only in S_base calculation, not balanceBefore. Change line 110 from 'uint256 gross = balanceBefore + minted;' to 'uint256 yieldAmount = minted;' and in _calculateSplit, calculate S_base as 'sBase = SNow - yieldAmount' instead of 'SNow - gross'. Also add recoverDonations() function: function recoverDonations() external onlyRole(ADMIN_ROLE) { uint256 balance = IERC20(USDSC_ADDRESS).balanceOf(address(this)); if (balance > 0) IERC20(USDSC_ADDRESS).transfer(treasury, balance); } This allows manual recovery of unexpected transfers without affecting distribution formulas.",
  "expert_notes": "While donations are rare, this is a real risk in protocols that interface with multiple entities. The impact scales linearly with donation size and is avoidable with proper accounting separation. Similar issues have appeared in Curve gauges and Compound treasury management where accidental transfers disrupted expected mathematics.",
  "context_hint": "This is a classic accounting bug in yield distribution systems. The contract conflates 'accidental contract balance' with 'yield to distribute'. The fix requires separating the concept of 'minted yield' from 'total contract balance'. This pattern appears in many protocols that didn't anticipate users sending tokens directly to the contract.",
  "call_flow": "Accidental.transfer(USDSC, RewardRedist) \u2192 balanceBefore += donation \u2192 Operator.distribute() \u2192 _calculateSplit(gross=minted+donation) \u2192 S_base understated \u2192 yield split incorrect \u2192 treasury loses yield"
}