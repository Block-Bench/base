{
  "id": "gs_040",
  "original_id": "gs_quantstamp_sequence_seq001",
  "source_dataset": "gold_standard",
  "vulnerability_type": "access_control",
  "severity": "high",
  "difficulty_tier": 4,
  "context_level": "single_file",
  "is_vulnerable": true,
  "finding_title": "Unsigned Fee Parameters Let Any Signature Holder Drain Funds",
  "finding_description": "The TrailsIntentEntrypoint contract accepts feeAmount and feeCollector as parameters in depositToIntent() and depositToIntentWithPermit() functions without requiring the user's signature. The TRAILS_INTENT_TYPEHASH does include these parameters, but they can be modified by the relayer before calling the contract, allowing arbitrary manipulation. Users typically grant maximum or excess token allowances for convenience, enabling malicious relayers to frontrun legitimate transactions and extract entire balances through inflated fees.",
  "vulnerable_lines": [
    69,
    70,
    72,
    73,
    74,
    75,
    103,
    104,
    106,
    107,
    108,
    109
  ],
  "vulnerable_functions": [
    "depositToIntent",
    "depositToIntentWithPermit"
  ],
  "has_context": true,
  "attack_scenario": "1. Alice intends to deposit 100 USDC to the intent contract with a 1 USDC fee and grants 1000 USDC approval to TrailsIntentEntrypoint\n2. Alice signs EIP-712 intent with amount=100, feeAmount=1, feeCollector=intent_treasury\n3. Malicious relayer sees the transaction in mempool and frontruns with modified parameters: feeAmount=900, feeCollector=attacker_address\n4. Contract accepts the modified values because they are not part of the user's EIP-712 signature\n5. safeTransferFrom transfers: 100 USDC to intent contract, 900 USDC to attacker\n6. Alice loses 900 USDC of her 1000 USDC approval with no recourse\n7. Economics: Any user balance with generous approval can be drained in a single transaction",
  "fix_description": "Ensure fee parameters (feeAmount and feeCollector) are included in the EIP-712 signature verification. The TRAILS_INTENT_TYPEHASH already includes these fields, so the vulnerability appears to be a logic error in how the hash is constructed or verified. Verify that the signature validation enforces: 1) feeAmount and feeCollector are part of the signed digest, 2) The contract validates that msg.sender (relayer) is not the same as signer in sensitive functions, or 3) Implement a whitelist of approved relayers/fee collectors. Additionally, recommend adding a fee amount validation function that users can call to preview fees before signing.",
  "expert_notes": "This is a critical authorization bypass where fee parameters can be modified post-signature. The fix requires either: (1) strict parameter validation ensuring the relayer-provided feeAmount and feeCollector match the signature, (2) removing relayer ability to set fee parameters entirely, or (3) using a separate signed fee approval mechanism. Given that feeAmount and feeCollector are already in the type hash, option 1 is the minimal fix: add require(feeAmount == signed_feeAmount && feeCollector == signed_feeCollector) validation.",
  "context_hint": "The vulnerability exists because while the TRAILS_INTENT_TYPEHASH includes feeAmount and feeCollector in the type hash definition, the function parameters are not validated to match the signed values. The signature verification (_verifyAndMarkIntent) only checks the overall intent hash but doesn't ensure the actual feeAmount and feeCollector passed to safeTransferFrom match what the user signed. A relayer can compute a valid signature for the original fee terms but then call the function with different fee parameters, and the contract will execute the transfer with the attacker-controlled values.",
  "call_flow": "User signs EIP-712 TrailsIntent hash including feeAmount and feeCollector \u2192 Relayer calls depositToIntent(token, intentAddress, amount, feeAmount, feeCollector, deadline, v, r, s) \u2192 Contract verifies signature but relayer can modify feeAmount/feeCollector after signature \u2192 safeTransferFrom(signer, feeCollector, feeAmount) executes with attacker-controlled values"
}