{
  "id": "ss_l3_medium_nc_gs_003",
  "contract_file": "contracts/ss_l3_medium_nc_gs_003.sol",
  "subset": "shapeshifter",
  "ground_truth": {
    "is_vulnerable": true,
    "vulnerability_type": "logic_error",
    "severity": "medium",
    "vulnerable_location": {
      "contract_name": "GaugeV2",
      "function_name": "_0x99fda9",
      "line_numbers": []
    },
    "root_cause": "in the `GaugeV2` contract, if the contract was emergency activated, users calling `emergencyWithdraw()` will lose all past accrued rewards that didn\u2019t have `updateReward()` called on it previously for a user to earn rewards, he gets his mappings updated here modifier updateReward(address account) { rewardPerTokenStored = rewardPerToken(); lastUpdateTime = lastTimeRewardApplicable(); if (account != address(0)) { rewards[account] = earned(account); userRewardPerTokenPaid[account] = rewardPerTokenStored; } _; } as we see above, rewards mapping is registered as the return data from `earned()`, and when we look at it we see function earned(address account) public view returns (uint256) { rewards[account] + _balanceOf(account) * (rewardPerToken() - userRewardPerTokenPaid[account]) / 1e18; } we see that it returns old rewards + current balance of the user multiplied by the rewardPerToken (abstractly) so what happen will be as follows: 1. User stake 100e18 tokens 2. emergency activated 3. he had already earnt before the emergency 10e18 tokens not registered on his rewards mapping since he didn\u2019t call deposit/withdraw/getRewards to update his rewards 4. call emergencyWithdraw and his balance now is 0. 5. now earned() function return 0 rewards since his balance is 0 * rewardPerToken = 0 also the left-off rewards tokens are stuck in the contract forever. Impact: Loss of rewards for users and stuck reward tokens in the contract",
    "attack_vector": "function test_emergencyWithdraw_strandsRewardsAndBurnsUserAccrual() external { vm.startPrank(address(this)); // Use HYBR both as staking TOKEN and rewardToken for simplicity // We have HYBR minted to this test from setup_InitMinter() uint256 initialHybr = hybr.balanceOf(address(this)); assertGt(initialHybr, 0, \"expected HYBR from initial mint\"); // Deploy GaugeV2 GaugeV2 gauge = new GaugeV2( address(hybr), address(rewardHybr), address(votingEscrow), address(hybr), address(this), address(0), address(0), false ); // Stake HYBR uint256 stakeAmount = 100 ether; hybr.approve(address(gauge), type(uint256).max); gauge.deposit(stakeAmount); // Fund rewards uint256 rewardAmount = 1_000 ether; hybr.approve(address(gauge), rewardAmount); gauge.notifyRewardAmount(address(hybr), rewardAmount); // Accrue some rewards vm.warp(block.timestamp + 7 days / 14); uint256 accruedBefore = gauge.earned(address(this)); assertGt(accruedBefore, 0, \"accrued must be > 0 before emergencyWithdraw\"); // Enable emergency and withdraw gauge.activateEmergencyMode(); gauge.emergencyWithdraw(); uint256 accruedAfter = gauge.earned(address(this)); assertEq(accruedAfter, 0, \"accrued should be zero after emergencyWithdraw\"); uint256 stuckRewards = hybr.balanceOf(address(gauge)); assertGt(stuckRewards, 0, \"reward tokens remain stuck in gauge\"); vm.stopPrank(); }",
    "impact": "Severity: medium",
    "correct_fix": "Add the `updateReward` modifier to the `emergencyWithdraw()` call"
  },
  "provenance": {
    "source": "code4rena",
    "original_id": "gs_c4_2025-10-hybra-finance_M02",
    "url": "https://code4rena.com/reports/2025-10-hybra-finance",
    "date_discovered": "2025-10-06",
    "date_added": "2025-12-16",
    "added_by": "benchmark_team"
  },
  "code_metadata": {
    "solidity_version": "^0.8.0",
    "num_lines": 410,
    "num_contracts": 1,
    "contract_names": [],
    "num_functions": 0,
    "has_imports": false,
    "imports": [],
    "has_inheritance": false,
    "inherits_from": [],
    "has_modifiers": false,
    "has_events": false,
    "has_assembly": false,
    "compilation_verified": false,
    "compiler_version_used": null
  },
  "tags": [
    "logic_error",
    "code4rena",
    "gold_standard",
    "audit_finding"
  ],
  "notes": "Emergency withdraw skips reward update, burning unclaimed rewards and leaving tokens stuck in the gauge.",
  "gold_standard_fields": {
    "source_report": "2025-10-hybra-finance",
    "source_finding_id": "M-02",
    "finding_title": "Users emergency withdrawing will lose all past accrued rewards",
    "difficulty_tier": 2,
    "context_level": "single_file",
    "has_context": false,
    "call_flow": "User.deposit() -> notifyRewardAmount() -> warp time -> activateEmergencyMode() -> emergencyWithdraw() -> earned() returns 0"
  },
  "evaluation_support": {
    "annotated_contract": "labelled_data/gold_standard/contracts/gs_003.sol",
    "detailed_metadata": "labelled_data/gold_standard/metadata/gs_003.json",
    "original_finding_title": "Users emergency withdrawing will lose all past accrued rewards"
  },
  "original_subset": "gold_standard",
  "original_contract_file": "base/contracts/gs_003.sol",
  "sanitized_from": "gs_003",
  "derived_from": "nc_gs_003",
  "original_id": "gs_003",
  "identifier_mappings": {
    "lastTimeRewardApplicable": "_0x5b1384",
    "emergencyWithdrawAmount": "_0x585af4",
    "depostionEmissionsToken": "_0x3cf244",
    "userRewardPerTokenPaid": "_0x6c40a0",
    "activateEmergencyMode": "_0x3b3347",
    "withdrawAllAndHarvest": "_0x468d9c",
    "rewardPerTokenStored": "_0xe50ed2",
    "notifyRewardAmount": "_0x974858",
    "emergencyWithdraw": "_0x99fda9",
    "stopEmergencyMode": "_0x7cbcc9",
    "rewardForDuration": "_0x53c8b6",
    "onlyDistribution": "_0xab7f72",
    "setInternalBribe": "_0x8d6cf8",
    "safeTransferFrom": "_0x0bd78e",
    "setGaugeRewarder": "_0x91d94d",
    "setDistribution": "_0x2e6988",
    "_internal_bribe": "_0xde2e83",
    "_external_bribe": "_0xee5289",
    "external_bribe": "_0xa9bee6",
    "isNotEmergency": "_0x5855bd",
    "internal_bribe": "_0x62c828",
    "rewardPerToken": "_0x228233",
    "lastUpdateTime": "_0x54d862",
    "_gaugeRewarder": "_0x180896",
    "gaugeRewarder": "_0x9b7c9f",
    "_periodFinish": "_0x074ced",
    "_distribution": "_0x6437f2",
    "_totalSupply": "_0xec9f0c",
    "safeTransfer": "_0x036343",
    "maturityTime": "_0x6f7bbc",
    "_rewardToken": "_0xd3b61e",
    "nonReentrant": "_0xd6cb5f",
    "updateReward": "_0x60ed33",
    "periodFinish": "_0x678679",
    "totalSupply": "_0xb8cd42",
    "userBalance": "_0xa6e898",
    "safeApprove": "_0x8825b9",
    "withdrawAll": "_0x7f0197",
    "_redeemType": "_0x826ca0",
    "rewardToken": "_0x98d976",
    "_balanceOf": "_0x60caa3",
    "rewardRate": "_0x7df5da",
    "_isForPair": "_0x5ca0f5",
    "depositAll": "_0x0d5dcb",
    "_claimFees": "_0x1d65e9",
    "balanceOf": "_0xfa6d29",
    "claimFees": "_0xdab5ac",
    "emergency": "_0xc44680",
    "_balances": "_0x037509",
    "remaining": "_0x378af9",
    "redeemFor": "_0x7b6013",
    "recipient": "_0xe52bd7",
    "_withdraw": "_0x28b1f0",
    "onlyOwner": "_0x57b958",
    "isForPair": "_0x7bf55d",
    "getReward": "_0xace424",
    "withdraw": "_0xac3d69",
    "onReward": "_0xf00826",
    "claimed1": "_0xe82e12",
    "claimed0": "_0xa03a30",
    "_deposit": "_0x896d3d",
    "leftover": "_0x3d412a",
    "account": "_0x954653",
    "_amount": "_0x7a4c73",
    "rewards": "_0xc3db41",
    "_token1": "_0xad0355",
    "deposit": "_0x273303",
    "_token0": "_0xea7a3b",
    "_token": "_0x3a7736",
    "tokens": "_0x657f8e",
    "reward": "_0x4b8528",
    "earned": "_0xdf60c9",
    "_rHYBR": "_0x33c0ee",
    "_fees1": "_0x66efcd",
    "_fees0": "_0x5b05f3",
    "amount": "_0xe0356d",
    "rHYBR": "_0xc2a33c",
    "token": "_0xd526b5",
    "gauge": "_0x5e6b09",
    "_user": "_0x12358c",
    "_int": "_0x4d5b77",
    "user": "_0xbf82cf",
    "_ve": "_0x6140f6",
    "min": "_0x729a6b"
  },
  "transformation": {
    "strategy": "shapeshifter",
    "level": "l3",
    "variant": "medium",
    "source": "nocomments",
    "changes": [
      "Renamed 84 identifiers using hex style",
      "Wrapped assignment in conditional",
      "Wrapped assignment in conditional",
      "Wrapped assignment in conditional",
      "Wrapped assignment in conditional",
      "Wrapped assignment in conditional",
      "Wrapped assignment in conditional"
    ],
    "rename_map_size": 84,
    "metadata_changes": [
      "Transformed ground_truth.vulnerable_location.function_name: emergencyWithdraw \u2192 _0x99fda9"
    ]
  }
}