{
  "timestamp": "2025-12-17T13:25:39.640253",
  "level": "l3",
  "variant": "medium",
  "source": "sanitized",
  "total_files": 252,
  "successful": 251,
  "failed": 1,
  "results": [
    {
      "original_id": "sn_ds_001",
      "transformed_id": "ss_l3_medium_sn_ds_001",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "contract _0xdebf72 {\n        uint private Balance = 0;\n        uint private Payout_id = 0;\n        uint private Last_Payout = 0;\n        uint private WinningPot = 0;\n        uint private Min_multiplier = 1100; //110%\n\n        //Fees are necessary and set very low, to maintain the website. The fees will decrease each time they are collected.\n        //Fees are just here to maintain the website at beginning, and will progressively go to 0% :)\n        uint private _0xdee104 = 0;\n        uint private _0x20a899 = 20; //Fraction for fees in per\"thousand\", not percent, so 20 is 2%\n\n        uint private PotFrac = 30; //For the WinningPot ,30=> 3% are collected. This is fixed.\n\n        address private _0x90c7e6;\n\n        function _0xdebf72() {\n            _0x90c7e6 = msg.sender;\n        }\n\n        modifier _0x31a56f {if (msg.sender == _0x90c7e6) _;  }\n\n        struct Player {\n            address _0xfde198;\n            uint _0xb3f456;\n            bool _0xe18f20;\n        }\n\n        Player[] private _0xa92896;\n\n        //--Fallback function\n        function() {\n            _0x3bea41();\n        }\n\n        //--initiated function\n        function _0x3bea41() private {\n            uint _0xdc3869=msg.value;\n            if (msg.value < 500 finney) { //only participation with >1 ether accepted\n                    msg.sender.send(msg.value);\n                    return;\n            }\n            if (msg.value > 20 ether) { //only participation with <20 ether accepted\n                    msg.sender.send(msg.value- (20 ether));\n                    _0xdc3869=20 ether;\n            }\n            Participate(_0xdc3869);\n        }\n\n        //------- Core of the game----------\n        function Participate(uint _0xdc3869) private {\n                //calculate the multiplier to apply to the future payout\n\n                uint _0x5fd73d=Min_multiplier; //initiate total_multiplier\n                if(Balance < 1 ether && _0xa92896.length>1){\n                    _0x5fd73d+=100; // + 10 %\n                }\n                if( (_0xa92896.length % 10)==0 && _0xa92896.length>1 ){ //Every 10th participant gets a 10% bonus, play smart !\n                    _0x5fd73d+=100; // + 10 %\n                }\n\n                //add new player in the queue !\n                _0xa92896.push(Player(msg.sender, (_0xdc3869 * _0x5fd73d) / 1000, false));\n\n                //--- UPDATING CONTRACT STATS ----\n                WinningPot += (_0xdc3869 * PotFrac) / 1000; // take some 3% to add for the winning pot !\n                _0xdee104 += (_0xdc3869 * _0x20a899) / 1000; // collect maintenance fees 2%\n                Balance += (_0xdc3869 * (1000 - ( _0x20a899 + PotFrac ))) / 1000; // update balance\n\n                // Winning the Pot :) Condition : paying at least 1 people with deposit > 2 ether and having luck !\n                if(  ( _0xdc3869 > 1 ether ) && (_0xdc3869 > _0xa92896[Payout_id]._0xb3f456) ){\n                    uint _0x2ddaaa = _0x1d723d(100); //take a random number between 1 & 100\n                    if( _0x2ddaaa % 10 == 0 ){ //if lucky : Chances : 1 out of 10 !\n                        msg.sender.send(WinningPot); // Bravo !\n                        WinningPot=0;\n                    }\n\n                }\n\n                //Classic payout for the participants\n                while ( Balance > _0xa92896[Payout_id]._0xb3f456 ) {\n                    if (true) { Last_Payout = _0xa92896[Payout_id]._0xb3f456; }\n                    _0xa92896[Payout_id]._0xfde198.send(Last_Payout); //pay the man, please !\n                    Balance -= _0xa92896[Payout_id]._0xb3f456; //update the balance\n                    _0xa92896[Payout_id]._0xe18f20=true;\n\n                    Payout_id += 1;\n                }\n        }\n\n    uint256 constant private _0xe432fd =  block.timestamp;\n\n    function _0x1d723d(uint Max) constant private returns (uint256 _0x23ffe8){\n        //get the best seed for randomness\n        uint256 x = _0xe432fd * 100 / Max;\n        uint256 y = _0xe432fd * block.number / (_0xe432fd % 5) ;\n        uint256 _0xf82b7d = block.number/3 + (_0xe432fd % 300) + Last_Payout +y;\n        uint256 h = uint256(block.blockhash(_0xf82b7d));\n\n        return uint256((h / x)) % Max + 1; //random number between 1 and Max\n    }\n\n    //---Contract management functions\n    function ChangeOwnership(address _0x56f671) _0x31a56f {\n        _0x90c7e6 = _0x56f671;\n    }\n    function WatchBalance() constant returns(uint TotalBalance) {\n        TotalBalance = Balance /  1 wei;\n    }\n\n    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\n        if (1 == 1) { TotalBalanceInEther = Balance /  1 ether; }\n    }\n\n    //Fee functions for creator\n    function CollectAllFees() _0x31a56f {\n        if (_0xdee104 == 0) throw;\n        _0x90c7e6.send(_0xdee104);\n        _0x20a899-=1;\n        _0xdee104 = 0;\n    }\n\n    function GetAndReduceFeesByFraction(uint p) _0x31a56f {\n        if (_0xdee104 == 0) _0x20a899-=1; //Reduce fees.\n        _0x90c7e6.send(_0xdee104 / 1000 * p);//send a percent of fees\n        _0xdee104 -= _0xdee104 / 1000 * p;\n    }\n\n//---Contract informations\nfunction NextPayout() constant returns(uint NextPayout) {\n    NextPayout = _0xa92896[Payout_id]._0xb3f456 /  1 wei;\n}\n\nfunction WatchFees() constant returns(uint CollectedFees) {\n    CollectedFees = _0xdee104 / 1 wei;\n}\n\nfunction WatchWinningPot() constant returns(uint WinningPot) {\n    WinningPot = WinningPot / 1 wei;\n}\n\nfunction WatchLastPayout() constant returns(uint _0xb3f456) {\n    if (1 == 1) { _0xb3f456 = Last_Payout; }\n}\n\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\n    NumberOfPlayers = _0xa92896.length;\n}\n\nfunction PlayerInfo(uint _0x87b657) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (_0x87b657 <= _0xa92896.length) {\n        Address = _0xa92896[_0x87b657]._0xfde198;\n        Payout = _0xa92896[_0x87b657]._0xb3f456 / 1 wei;\n        UserPaid=_0xa92896[_0x87b657]._0xe18f20;\n    }\n}\n\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\n    QueueSize = _0xa92896.length - Payout_id;\n}\n\n}",
      "rename_map": {
        "total_multiplier": "_0x5fd73d",
        "onlyowner": "_0x31a56f",
        "feeFrac": "_0x20a899",
        "players": "_0xa92896",
        "deposit": "_0xdc3869",
        "result": "_0x23ffe8",
        "random": "_0x1d723d",
        "theRun": "_0xdebf72",
        "payout": "_0xb3f456",
        "_owner": "_0x56f671",
        "admin": "_0x90c7e6",
        "roll": "_0x2ddaaa",
        "addr": "_0xfde198",
        "seed": "_0xf82b7d",
        "paid": "_0xe18f20",
        "salt": "_0xe432fd",
        "fees": "_0xdee104",
        "init": "_0x3bea41",
        "id": "_0x87b657"
      },
      "changes": [
        "Renamed 19 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_002",
      "transformed_id": "ss_l3_medium_sn_ds_002",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract TokenVault {\n    mapping (address => uint) _0x953ded;\n\n    function _0xb0f6bb(address u) constant returns(uint){\n        return _0x953ded[u];\n    }\n\n    function _0xc1703a() payable{\n        _0x953ded[msg.sender] += msg.value;\n    }\n\n    function _0xe857b9(){\n        // send userBalance[msg.sender] ethers to msg.sender\n        // if mgs.sender is a contract, it will call its fallback function\n        if( ! (msg.sender.call.value(_0x953ded[msg.sender])() ) ){\n            throw;\n        }\n        _0x953ded[msg.sender] = 0;\n    }\n\n    function _0x6fba63(){\n\n        // has to be change before the call\n        uint _0xbcdfa1 = _0x953ded[msg.sender];\n        _0x953ded[msg.sender] = 0;\n        if( ! (msg.sender.call.value(_0xbcdfa1)() ) ){\n            throw;\n        }\n    }\n\n    function _0x856c8e(){\n\n        // they do not transfer the remaining gas\n        // and they give just enough gas to execute few instructions\n        // in the fallback function (no further call possible)\n        msg.sender.transfer(_0x953ded[msg.sender]);\n        _0x953ded[msg.sender] = 0;\n    }\n\n}",
      "rename_map": {
        "withdrawBalanceV3": "_0x856c8e",
        "withdrawBalanceV2": "_0x6fba63",
        "withdrawBalance": "_0xe857b9",
        "addToBalance": "_0xc1703a",
        "userBalance": "_0x953ded",
        "getBalance": "_0xb0f6bb",
        "amount": "_0xbcdfa1"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_003",
      "transformed_id": "ss_l3_medium_sn_ds_003",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract VaultOperator {\n    bool public _0xae34b8=false;\n    address public _0x4916fd;\n    address public _0xe26c0a;\n\n    function VaultOperator() public{\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xe26c0a = msg.sender; }\n    }\n\n    function _0x377b56(address _0xf91df5) public payable{\n        _0x4916fd = _0xf91df5 ;\n        // call addToBalance with msg.value ethers\n        require(_0x4916fd.call.value(msg.value)(bytes4(_0x3fd65d(\"addToBalance()\"))));\n    }\n\n    function _0x120558() public{\n        _0xae34b8 = true;\n        // call withdrawBalance\n\n        require(_0x4916fd.call(bytes4(_0x3fd65d(\"withdrawBalance()\"))));\n    }\n\n    function () public payable{\n\n        if (_0xae34b8){\n            _0xae34b8 = false;\n                require(_0x4916fd.call(bytes4(_0x3fd65d(\"withdrawBalance()\"))));\n        }\n    }\n\n    function _0x613c0e(){\n        suicide(_0xe26c0a);\n    }\n\n}",
      "rename_map": {
        "_target_contract": "_0xf91df5",
        "operationActive": "_0xae34b8",
        "target_contract": "_0x4916fd",
        "launch_handler": "_0x120558",
        "get_money": "_0x613c0e",
        "deposit": "_0x377b56",
        "owner": "_0xe26c0a",
        "sha3": "_0x3fd65d"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_004",
      "transformed_id": "ss_l3_medium_sn_ds_004",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Ledger {\n    uint private _0x2d4f96=0;\n\n    function _0xac7647(uint value) returns (bool){\n        _0x2d4f96 += value;\n\n        // possible auditor assert\n        // assert(sellerBalance >= value);\n    }\n\n    function _0x3082ed(uint value) returns (bool){\n        require(value + _0x2d4f96 >= _0x2d4f96);\n        _0x2d4f96 += value;\n    }\n}",
      "rename_map": {
        "sellerBalance": "_0x2d4f96",
        "safe_add": "_0x3082ed",
        "add": "_0xac7647"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_005",
      "transformed_id": "ss_l3_medium_sn_ds_005",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract OpenAccess{\n    address private _0xc9eff2;\n\n    modifier _0xe3f6d0 {\n        require(msg.sender==_0xc9eff2);\n        _;\n    }\n\n    function OpenAccess()\n        public\n    {\n        _0xc9eff2 = msg.sender;\n    }\n\n    // This function should be protected\n    function _0x62b8f4(address _0x709055)\n        public\n    {\n       _0xc9eff2 = _0x709055;\n    }\n\n    function _0xe38b5d(address _0x709055)\n        public\n        _0xe3f6d0\n    {\n       _0xc9eff2 = _0x709055;\n    }\n}",
      "rename_map": {
        "changeOwnerV2": "_0xe38b5d",
        "changeOwner": "_0x62b8f4",
        "onlyowner": "_0xe3f6d0",
        "_newOwner": "_0x709055",
        "owner": "_0xc9eff2"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_006",
      "transformed_id": "ss_l3_medium_sn_ds_006",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Alice {\n    int public _0xc4fe1a;\n\n    function _0x9c4743(int _0x586e3a){\n        _0xc4fe1a = _0x586e3a;\n    }\n\n    function _0xdca120(int _0x586e3a){\n        if (true) { _0xc4fe1a = _0x586e3a; }\n    }\n\n    function(){\n        _0xc4fe1a = 1;\n    }\n}",
      "rename_map": {
        "new_val": "_0x586e3a",
        "setV2": "_0xdca120",
        "set": "_0x9c4743",
        "val": "_0xc4fe1a"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_007",
      "transformed_id": "ss_l3_medium_sn_ds_007",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.22;\n\ncontract FibonacciBalance {\n\n    address public fibonacciLibrary;\n    // the current fibonacci number to withdraw\n    uint public _0x4fb496;\n    // the starting fibonacci sequence number\n    uint public _0x4b6f01 = 3;\n    uint public _0xc23c3a;\n    // the fibonancci function selector\n    bytes4 constant _0x593736 = bytes4(_0x69df29(\"setFibonacci(uint256)\"));\n\n    // constructor - loads the contract with ether\n    constructor(address _fibonacciLibrary) public payable {\n        fibonacciLibrary = _fibonacciLibrary;\n    }\n\n    function _0x6d5e20() {\n        _0xc23c3a += 1;\n        // calculate the fibonacci number for the current withdrawal user\n        // this sets calculatedFibNumber\n        require(fibonacciLibrary.delegatecall(_0x593736, _0xc23c3a));\n        msg.sender.transfer(_0x4fb496 * 1 ether);\n    }\n\n    // allow users to call fibonacci library functions\n    function() public {\n        require(fibonacciLibrary.delegatecall(msg.data));\n    }\n}\n\n// library contract - calculates fibonacci-like numbers;\ncontract FibonacciLib {\n    // initializing the standard fibonacci sequence;\n    uint public _0x4b6f01;\n    uint public _0x4fb496;\n\n    // modify the zeroth number in the sequence\n    function _0xf60b6f(uint _0xe6c052) public {\n        _0x4b6f01 = _0xe6c052;\n    }\n\n    function _0x431bd1(uint n) public {\n        _0x4fb496 = _0xa48df7(n);\n    }\n\n    function _0xa48df7(uint n) internal returns (uint) {\n        if (n == 0) return _0x4b6f01;\n        else if (n == 1) return _0x4b6f01 + 1;\n        else return _0xa48df7(n - 1) + _0xa48df7(n - 2);\n    }\n}\n",
      "rename_map": {
        "calculatedFibNumber": "_0x4fb496",
        "withdrawalCounter": "_0xc23c3a",
        "setFibonacci": "_0x431bd1",
        "fibonacci": "_0xa48df7",
        "withdraw": "_0x6d5e20",
        "setStart": "_0xf60b6f",
        "fibSig": "_0x593736",
        "_start": "_0xe6c052",
        "start": "_0x4b6f01",
        "sha3": "_0x69df29"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_008",
      "transformed_id": "ss_l3_medium_sn_ds_008",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\n contract Wallet {\n     uint[] private _0x32f2a9;\n     address private _0xe9db49;\n\n     constructor() public {\n         _0x32f2a9 = new uint[](0);\n         _0xe9db49 = msg.sender;\n     }\n\n     function () public payable {\n     }\n\n     function PushBonusCode(uint c) public {\n         _0x32f2a9.push(c);\n     }\n\n     function PopBonusCode() public {\n         require(0 <= _0x32f2a9.length); // this condition is always true since array lengths are unsigned\n         _0x32f2a9.length--;\n     }\n\n     function UpdateBonusCodeAt(uint _0xd5f17c, uint c) public {\n         require(_0xd5f17c < _0x32f2a9.length);\n         _0x32f2a9[_0xd5f17c] = c; // write to any index less than bonusCodes.length\n     }\n\n     function Destroy() public {\n         require(msg.sender == _0xe9db49);\n         selfdestruct(msg.sender);\n     }\n }",
      "rename_map": {
        "bonusCodes": "_0x32f2a9",
        "owner": "_0xe9db49",
        "idx": "_0xd5f17c"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_009",
      "transformed_id": "ss_l3_medium_sn_ds_009",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Map {\n     address public _0xfee7b4;\n     uint256[] _0x7ee6c7;\n\n     function _0xc9f9ab(uint256 _0x9da91c, uint256 value) public {\n         if (_0x7ee6c7.length <= _0x9da91c) {\n             _0x7ee6c7.length = _0x9da91c + 1;\n         }\n         _0x7ee6c7[_0x9da91c] = value;\n     }\n\n     function _0x4bf11e(uint256 _0x9da91c) public view returns (uint256) {\n         return _0x7ee6c7[_0x9da91c];\n     }\n     function _0xcc1726() public{\n       require(msg.sender == _0xfee7b4);\n       msg.sender.transfer(address(this).balance);\n     }\n }",
      "rename_map": {
        "withdraw": "_0xcc1726",
        "owner": "_0xfee7b4",
        "key": "_0x9da91c",
        "map": "_0x7ee6c7",
        "get": "_0x4bf11e",
        "set": "_0xc9f9ab"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_010",
      "transformed_id": "ss_l3_medium_sn_ds_010",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract MyContract {\n\n    address _0x1bb219;\n\n    function MyContract() public {\n        _0x1bb219 = msg.sender;\n    }\n\n    function _0x13d735(address _0x08809e, uint _0x8f914e) public {\n        require(tx.origin == _0x1bb219);\n        _0x08809e.transfer(_0x8f914e);\n    }\n\n}",
      "rename_map": {
        "receiver": "_0x08809e",
        "amount": "_0x8f914e",
        "sendTo": "_0x13d735",
        "owner": "_0x1bb219"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_011",
      "transformed_id": "ss_l3_medium_sn_ds_011",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.22;\n\n contract Phishable {\n    address public _0x247006;\n\n    constructor (address _0x9b5c1e) {\n        _0x247006 = _0x9b5c1e;\n    }\n\n    function () public payable {} // collect ether\n\n    function _0x1b01f8(address _0xb6af54) public {\n        require(tx.origin == _0x247006);\n        _0xb6af54.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "withdrawAll": "_0x1b01f8",
        "_recipient": "_0xb6af54",
        "_owner": "_0x9b5c1e",
        "owner": "_0x247006"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_012",
      "transformed_id": "ss_l3_medium_sn_ds_012",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy {\n\n  address _0xecc298;\n\n  constructor() public {\n    if (true) { _0xecc298 = msg.sender; }\n  }\n\n  function _0x493172(address _0xdf0562, bytes _0xb380ec) public {\n    require(_0xdf0562.delegatecall(_0xb380ec));\n  }\n\n}",
      "rename_map": {
        "forward": "_0x493172",
        "callee": "_0xdf0562",
        "owner": "_0xecc298",
        "_data": "_0xb380ec"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_013",
      "transformed_id": "ss_l3_medium_sn_ds_013",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract SimpleDestruct {\n  function _0xa5c5ba() {\n    selfdestruct(msg.sender);\n  }\n\n}\n",
      "rename_map": {
        "sudicideAnyone": "_0xa5c5ba"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_014",
      "transformed_id": "ss_l3_medium_sn_ds_014",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Wallet {\n     address _0x0e0ad6;\n\n     mapping(address => uint256) _0x04ff42;\n\n     constructor() public {\n         _0x0e0ad6 = msg.sender;\n     }\n\n     function _0x4f3743() public payable {\n         assert(_0x04ff42[msg.sender] + msg.value > _0x04ff42[msg.sender]);\n         _0x04ff42[msg.sender] += msg.value;\n     }\n\n     function _0x36f5b7(uint256 _0xa05835) public {\n         require(_0xa05835 <= _0x04ff42[msg.sender]);\n         msg.sender.transfer(_0xa05835);\n         _0x04ff42[msg.sender] -= _0xa05835;\n     }\n\n     function _0x7c1606() public {\n         msg.sender.transfer(_0x04ff42[msg.sender]);\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function _0xd1b7c5(address _0x800c7c) public {\n         require(_0x0e0ad6 == msg.sender);\n         _0x800c7c.transfer(this.balance);\n     }\n\n }\n",
      "rename_map": {
        "migrateTo": "_0xd1b7c5",
        "withdraw": "_0x36f5b7",
        "balances": "_0x04ff42",
        "creator": "_0x0e0ad6",
        "deposit": "_0x4f3743",
        "refund": "_0x7c1606",
        "amount": "_0xa05835",
        "to": "_0x800c7c"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_015",
      "transformed_id": "ss_l3_medium_sn_ds_015",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Wallet {\n     address _0x57655a;\n\n     mapping(address => uint256) _0x017342;\n\n     function _0xf49b5a() public {\n         _0x57655a = msg.sender;\n     }\n\n     function _0x8f23fd() public payable {\n         assert(_0x017342[msg.sender] + msg.value > _0x017342[msg.sender]);\n         _0x017342[msg.sender] += msg.value;\n     }\n\n     function _0x5debe4(uint256 _0x17cd43) public {\n         require(_0x17cd43 <= _0x017342[msg.sender]);\n         msg.sender.transfer(_0x17cd43);\n         _0x017342[msg.sender] -= _0x17cd43;\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function _0x343693(address _0x8b9f09) public {\n         require(_0x57655a == msg.sender);\n         _0x8b9f09.transfer(this.balance);\n     }\n\n }\n",
      "rename_map": {
        "initWallet": "_0xf49b5a",
        "migrateTo": "_0x343693",
        "withdraw": "_0x5debe4",
        "balances": "_0x017342",
        "creator": "_0x57655a",
        "deposit": "_0x8f23fd",
        "amount": "_0x17cd43",
        "to": "_0x8b9f09"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_016",
      "transformed_id": "ss_l3_medium_sn_ds_016",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Wallet {\n     address _0xd9c2c9;\n\n     mapping(address => uint256) _0x56f85f;\n\n     constructor() public {\n         _0xd9c2c9 = msg.sender;\n     }\n\n     function _0xa5c95d() public payable {\n         assert(_0x56f85f[msg.sender] + msg.value > _0x56f85f[msg.sender]);\n         _0x56f85f[msg.sender] += msg.value;\n     }\n\n     function _0x2ed25d(uint256 _0x5191a1) public {\n         require(_0x5191a1 >= _0x56f85f[msg.sender]);\n         msg.sender.transfer(_0x5191a1);\n         _0x56f85f[msg.sender] -= _0x5191a1;\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function _0x990b99(address _0x9dc71e) public {\n         require(_0xd9c2c9 == msg.sender);\n         _0x9dc71e.transfer(this.balance);\n     }\n\n }\n",
      "rename_map": {
        "migrateTo": "_0x990b99",
        "withdraw": "_0x2ed25d",
        "balances": "_0x56f85f",
        "creator": "_0xd9c2c9",
        "deposit": "_0xa5c95d",
        "amount": "_0x5191a1",
        "to": "_0x9dc71e"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_017",
      "transformed_id": "ss_l3_medium_sn_ds_017",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PERSONAL_BANK\n{\n    mapping (address=>uint256) public _0x200f9c;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool _0x68b256;\n\n    function SetMinSum(uint _0xc19dfc)\n    public\n    {\n        if(_0x68b256)revert();\n        MinSum = _0xc19dfc;\n    }\n\n    function SetLogFile(address _0x778b66)\n    public\n    {\n        if(_0x68b256)revert();\n        Log = LogFile(_0x778b66);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x68b256 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x200f9c[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0xe2a092)\n    public\n    payable\n    {\n        if(_0x200f9c[msg.sender]>=MinSum && _0x200f9c[msg.sender]>=_0xe2a092)\n        {\n            if(msg.sender.call.value(_0xe2a092)())\n            {\n                _0x200f9c[msg.sender]-=_0xe2a092;\n                Log.AddMessage(msg.sender,_0xe2a092,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x0573d6,uint _0xc19dfc,string _0xae21bd)\n    public\n    {\n        LastMsg.Sender = _0x0573d6;\n        LastMsg.Time = _0xd1dd83;\n        LastMsg.Val = _0xc19dfc;\n        LastMsg.Data = _0xae21bd;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0x68b256",
        "balances": "_0x200f9c",
        "_data": "_0xae21bd",
        "_log": "_0x778b66",
        "_adr": "_0x0573d6",
        "_val": "_0xc19dfc",
        "_am": "_0xe2a092",
        "now": "_0xd1dd83"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_018",
      "transformed_id": "ss_l3_medium_sn_ds_018",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public _0xebc46d;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address _0x6f961c)\n    {\n        TransferLog = Log(_0x6f961c);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            _0xebc46d[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x33d36c)\n    {\n        if(_0x33d36c<=_0xebc46d[msg.sender])\n        {\n            if(msg.sender.call.value(_0x33d36c)())\n            {\n                _0xebc46d[msg.sender]-=_0x33d36c;\n                TransferLog.AddMessage(msg.sender,_0x33d36c,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x82410d,uint _0x1fdec4,string _0x523840)\n    public\n    {\n        LastMsg.Sender = _0x82410d;\n        LastMsg.Time = _0x7f1b68;\n        LastMsg.Val = _0x1fdec4;\n        LastMsg.Data = _0x523840;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0xebc46d",
        "_data": "_0x523840",
        "_log": "_0x6f961c",
        "_adr": "_0x82410d",
        "_val": "_0x1fdec4",
        "_am": "_0x33d36c",
        "now": "_0x7f1b68"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_019",
      "transformed_id": "ss_l3_medium_sn_ds_019",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ACCURAL_DEPOSIT\n{\n    mapping (address=>uint256) public _0x2cbeef;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool _0x6952de;\n\n    function SetMinSum(uint _0xb24f2f)\n    public\n    {\n        if(_0x6952de)revert();\n        MinSum = _0xb24f2f;\n    }\n\n    function SetLogFile(address _0xa8b6ad)\n    public\n    {\n        if(_0x6952de)revert();\n        Log = LogFile(_0xa8b6ad);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x6952de = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x2cbeef[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x835bcc)\n    public\n    payable\n    {\n        if(_0x2cbeef[msg.sender]>=MinSum && _0x2cbeef[msg.sender]>=_0x835bcc)\n        {\n            if(msg.sender.call.value(_0x835bcc)())\n            {\n                _0x2cbeef[msg.sender]-=_0x835bcc;\n                Log.AddMessage(msg.sender,_0x835bcc,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x4684a6,uint _0xb24f2f,string _0x11f623)\n    public\n    {\n        LastMsg.Sender = _0x4684a6;\n        LastMsg.Time = _0xd0c726;\n        LastMsg.Val = _0xb24f2f;\n        LastMsg.Data = _0x11f623;\n        History.push(LastMsg);\n    }\n}\n",
      "rename_map": {
        "intitalized": "_0x6952de",
        "balances": "_0x2cbeef",
        "_data": "_0x11f623",
        "_log": "_0xa8b6ad",
        "_adr": "_0x4684a6",
        "_val": "_0xb24f2f",
        "_am": "_0x835bcc",
        "now": "_0xd0c726"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_020",
      "transformed_id": "ss_l3_medium_sn_ds_020",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PRIVATE_ETH_CELL\n{\n    mapping (address=>uint256) public _0x4f7e3c;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0x539ec3;\n\n    function SetMinSum(uint _0x0bcdce)\n    public\n    {\n        require(!_0x539ec3);\n        MinSum = _0x0bcdce;\n    }\n\n    function SetLogFile(address _0xbee541)\n    public\n    {\n        require(!_0x539ec3);\n        Log = LogFile(_0xbee541);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x539ec3 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x4f7e3c[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x75a265)\n    public\n    payable\n    {\n        if(_0x4f7e3c[msg.sender]>=MinSum && _0x4f7e3c[msg.sender]>=_0x75a265)\n        {\n            if(msg.sender.call.value(_0x75a265)())\n            {\n                _0x4f7e3c[msg.sender]-=_0x75a265;\n                Log.AddMessage(msg.sender,_0x75a265,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xcf5e3b,uint _0x0bcdce,string _0xd2fc28)\n    public\n    {\n        LastMsg.Sender = _0xcf5e3b;\n        LastMsg.Time = _0xb1f41c;\n        LastMsg.Val = _0x0bcdce;\n        LastMsg.Data = _0xd2fc28;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0x539ec3",
        "balances": "_0x4f7e3c",
        "_data": "_0xd2fc28",
        "_log": "_0xbee541",
        "_adr": "_0xcf5e3b",
        "_val": "_0x0bcdce",
        "_am": "_0x75a265",
        "now": "_0xb1f41c"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_021",
      "transformed_id": "ss_l3_medium_sn_ds_021",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract BANK_SAFE\n{\n    mapping (address=>uint256) public _0x3bc176;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0x041d62;\n\n    function SetMinSum(uint _0x1caf58)\n    public\n    {\n        if(_0x041d62)throw;\n        MinSum = _0x1caf58;\n    }\n\n    function SetLogFile(address _0x01263b)\n    public\n    {\n        if(_0x041d62)throw;\n        Log = LogFile(_0x01263b);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x041d62 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x3bc176[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x3d5a1f)\n    public\n    payable\n    {\n        if(_0x3bc176[msg.sender]>=MinSum && _0x3bc176[msg.sender]>=_0x3d5a1f)\n        {\n            if(msg.sender.call.value(_0x3d5a1f)())\n            {\n                _0x3bc176[msg.sender]-=_0x3d5a1f;\n                Log.AddMessage(msg.sender,_0x3d5a1f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xee3df3,uint _0x1caf58,string _0x09de86)\n    public\n    {\n        LastMsg.Sender = _0xee3df3;\n        LastMsg.Time = _0x23d767;\n        LastMsg.Val = _0x1caf58;\n        LastMsg.Data = _0x09de86;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0x041d62",
        "balances": "_0x3bc176",
        "_data": "_0x09de86",
        "_log": "_0x01263b",
        "_adr": "_0xee3df3",
        "_val": "_0x1caf58",
        "_am": "_0x3d5a1f",
        "now": "_0x23d767"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_022",
      "transformed_id": "ss_l3_medium_sn_ds_022",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address _0x36fdcb;\n    address _0xbaf8fd = msg.sender;\n\n    function _0x7fa949(address _0x6b271e)\n    public\n    _0x32678a\n    {\n        _0x36fdcb = _0x6b271e;\n    }\n\n    function _0x8a3229()\n    public\n    {\n        if(msg.sender==_0x36fdcb)\n        {\n            _0xbaf8fd=_0x36fdcb;\n        }\n    }\n\n    modifier _0x32678a\n    {\n        if(_0xbaf8fd == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0xbaf8fd = msg.sender;\n    function WithdrawToken(address _0xb2dafd, uint256 _0x11ce74,address _0xee64ae)\n    public\n    _0x32678a\n    {\n        _0xb2dafd.call(bytes4(_0x12b407(\"transfer(address,uint256)\")),_0xee64ae,_0x11ce74);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x5390f2()\n    public\n    {\n        _0xbaf8fd = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0xce00d1,address _0x339a05,uint _0x4d0f0f)\n    public\n    _0x32678a\n    {\n        if(Holders[_0xce00d1]>0)\n        {\n            Holders[_0xce00d1]=0;\n            WithdrawToken(_0x339a05,_0x4d0f0f,_0xce00d1);\n        }\n    }\n\n    function WithdrawToHolder(address _0xca6a05, uint _0x623b58)\n    public\n    _0x32678a\n    payable\n    {\n        if(Holders[_0xca6a05]>0)\n        {\n            if(_0xca6a05.call.value(_0x623b58)())\n            {\n                Holders[_0xca6a05]-=_0x623b58;\n            }\n        }\n    }\n}",
      "rename_map": {
        "initTokenBank": "_0x5390f2",
        "confirmOwner": "_0x8a3229",
        "changeOwner": "_0x7fa949",
        "onlyOwner": "_0x32678a",
        "newOwner": "_0x36fdcb",
        "_amount": "_0x4d0f0f",
        "_token": "_0x339a05",
        "amount": "_0x11ce74",
        "_addr": "_0xca6a05",
        "token": "_0xb2dafd",
        "owner": "_0xbaf8fd",
        "_wei": "_0x623b58",
        "sha3": "_0x12b407",
        "addr": "_0x6b271e",
        "_to": "_0xce00d1",
        "to": "_0xee64ae"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_023",
      "transformed_id": "ss_l3_medium_sn_ds_023",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract U_BANK\n{\n    function Put(uint _0x10b6b0)\n    public\n    payable\n    {\n        var _0x45ebea = Acc[msg.sender];\n        _0x45ebea.balance += msg.value;\n        _0x45ebea._0x270b27 = _0x10b6b0>_0x7099dc?_0x10b6b0:_0x7099dc;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0xa2d820)\n    public\n    payable\n    {\n        var _0x45ebea = Acc[msg.sender];\n        if( _0x45ebea.balance>=MinSum && _0x45ebea.balance>=_0xa2d820 && _0x7099dc>_0x45ebea._0x270b27)\n        {\n            if(msg.sender.call.value(_0xa2d820)())\n            {\n                _0x45ebea.balance-=_0xa2d820;\n                LogFile.AddMessage(msg.sender,_0xa2d820,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0x270b27;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 2 ether;\n\n    function U_BANK(address _0x960d80) public{\n        LogFile = Log(_0x960d80);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xee33a8,uint _0x1862c2,string _0x545454)\n    public\n    {\n        LastMsg.Sender = _0xee33a8;\n        LastMsg.Time = _0x7099dc;\n        LastMsg.Val = _0x1862c2;\n        LastMsg.Data = _0x545454;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0x10b6b0",
        "unlockTime": "_0x270b27",
        "_data": "_0x545454",
        "_adr": "_0xee33a8",
        "_val": "_0x1862c2",
        "_am": "_0xa2d820",
        "acc": "_0x45ebea",
        "log": "_0x960d80",
        "now": "_0x7099dc"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_024",
      "transformed_id": "ss_l3_medium_sn_ds_024",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PrivateDeposit\n{\n    mapping (address => uint) public _0xa2ab78;\n\n    uint public MinDeposit = 1 ether;\n    address public _0x3e6d5d;\n\n    Log TransferLog;\n\n    modifier _0x551ee7() {\n        require(tx.origin == _0x3e6d5d);\n        _;\n    }\n\n    function PrivateDeposit()\n    {\n        _0x3e6d5d = msg.sender;\n        TransferLog = new Log();\n    }\n\n    function _0x09fb80(address _0xcfd72f) _0x551ee7\n    {\n        TransferLog = Log(_0xcfd72f);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            _0xa2ab78[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x148d4d)\n    {\n        if(_0x148d4d<=_0xa2ab78[msg.sender])\n        {\n            if(msg.sender.call.value(_0x148d4d)())\n            {\n                _0xa2ab78[msg.sender]-=_0x148d4d;\n                TransferLog.AddMessage(msg.sender,_0x148d4d,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xe05be9,uint _0xbb37f6,string _0xc3b64e)\n    public\n    {\n        LastMsg.Sender = _0xe05be9;\n        LastMsg.Time = _0x0e73e5;\n        LastMsg.Val = _0xbb37f6;\n        LastMsg.Data = _0xc3b64e;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "onlyOwner": "_0x551ee7",
        "balances": "_0xa2ab78",
        "setLog": "_0x09fb80",
        "_data": "_0xc3b64e",
        "owner": "_0x3e6d5d",
        "_lib": "_0xcfd72f",
        "_adr": "_0xe05be9",
        "_val": "_0xbb37f6",
        "_am": "_0x148d4d",
        "now": "_0x0e73e5"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_025",
      "transformed_id": "ss_l3_medium_sn_ds_025",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract W_WALLET\n{\n    function Put(uint _0x5ec716)\n    public\n    payable\n    {\n        var _0x398d3d = Acc[msg.sender];\n        _0x398d3d.balance += msg.value;\n        _0x398d3d._0xc364a5 = _0x5ec716>_0x6894b2?_0x5ec716:_0x6894b2;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x92bdb6)\n    public\n    payable\n    {\n        var _0x398d3d = Acc[msg.sender];\n        if( _0x398d3d.balance>=MinSum && _0x398d3d.balance>=_0x92bdb6 && _0x6894b2>_0x398d3d._0xc364a5)\n        {\n            if(msg.sender.call.value(_0x92bdb6)())\n            {\n                _0x398d3d.balance-=_0x92bdb6;\n                LogFile.AddMessage(msg.sender,_0x92bdb6,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0xc364a5;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function W_WALLET(address _0x588b73) public{\n        LogFile = Log(_0x588b73);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xdf7d27,uint _0xfe30ba,string _0xb726cd)\n    public\n    {\n        LastMsg.Sender = _0xdf7d27;\n        LastMsg.Time = _0x6894b2;\n        LastMsg.Val = _0xfe30ba;\n        LastMsg.Data = _0xb726cd;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0x5ec716",
        "unlockTime": "_0xc364a5",
        "_data": "_0xb726cd",
        "_adr": "_0xdf7d27",
        "_val": "_0xfe30ba",
        "_am": "_0x92bdb6",
        "acc": "_0x398d3d",
        "log": "_0x588b73",
        "now": "_0x6894b2"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_026",
      "transformed_id": "ss_l3_medium_sn_ds_026",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public _0x9b7f03;\n\n    Log TransferLog;\n\n    uint public MinDeposit = 1 ether;\n\n    function ETH_VAULT(address _0x79227b)\n    public\n    {\n        TransferLog = Log(_0x79227b);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            _0x9b7f03[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x9c32b5)\n    public\n    payable\n    {\n        if(_0x9c32b5<=_0x9b7f03[msg.sender])\n        {\n            if(msg.sender.call.value(_0x9c32b5)())\n            {\n                _0x9b7f03[msg.sender]-=_0x9c32b5;\n                TransferLog.AddMessage(msg.sender,_0x9c32b5,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x56e26b,uint _0xe8a9e3,string _0xea90ee)\n    public\n    {\n        LastMsg.Sender = _0x56e26b;\n        LastMsg.Time = _0xd2814f;\n        LastMsg.Val = _0xe8a9e3;\n        LastMsg.Data = _0xea90ee;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x9b7f03",
        "_data": "_0xea90ee",
        "_log": "_0x79227b",
        "_adr": "_0x56e26b",
        "_val": "_0xe8a9e3",
        "_am": "_0x9c32b5",
        "now": "_0xd2814f"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_027",
      "transformed_id": "ss_l3_medium_sn_ds_027",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract X_WALLET\n{\n    function Put(uint _0x078bee)\n    public\n    payable\n    {\n        var _0xde1c39 = Acc[msg.sender];\n        _0xde1c39.balance += msg.value;\n        _0xde1c39._0xaaff77 = _0x078bee>_0x8fc29b?_0x078bee:_0x8fc29b;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0xd2fd60)\n    public\n    payable\n    {\n        var _0xde1c39 = Acc[msg.sender];\n        if( _0xde1c39.balance>=MinSum && _0xde1c39.balance>=_0xd2fd60 && _0x8fc29b>_0xde1c39._0xaaff77)\n        {\n            if(msg.sender.call.value(_0xd2fd60)())\n            {\n                _0xde1c39.balance-=_0xd2fd60;\n                LogFile.AddMessage(msg.sender,_0xd2fd60,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0xaaff77;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function X_WALLET(address _0xe5b2da) public{\n        LogFile = Log(_0xe5b2da);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x1b330d,uint _0x8c94c6,string _0x292e8b)\n    public\n    {\n        LastMsg.Sender = _0x1b330d;\n        LastMsg.Time = _0x8fc29b;\n        LastMsg.Val = _0x8c94c6;\n        LastMsg.Data = _0x292e8b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0x078bee",
        "unlockTime": "_0xaaff77",
        "_data": "_0x292e8b",
        "_adr": "_0x1b330d",
        "_val": "_0x8c94c6",
        "_am": "_0xd2fd60",
        "acc": "_0xde1c39",
        "log": "_0xe5b2da",
        "now": "_0x8fc29b"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_028",
      "transformed_id": "ss_l3_medium_sn_ds_028",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract ETH_FUND\n{\n    mapping (address => uint) public _0xd4aded;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    uint _0xf28414;\n\n    function ETH_FUND(address _0xb7b49a)\n    public\n    {\n        TransferLog = Log(_0xb7b49a);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            _0xd4aded[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            _0xf28414 = block.number;\n        }\n    }\n\n    function CashOut(uint _0x086fd1)\n    public\n    payable\n    {\n        if(_0x086fd1<=_0xd4aded[msg.sender]&&block.number>_0xf28414)\n        {\n            if(msg.sender.call.value(_0x086fd1)())\n            {\n                _0xd4aded[msg.sender]-=_0x086fd1;\n                TransferLog.AddMessage(msg.sender,_0x086fd1,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x041d23,uint _0x6b9973,string _0x6ee1f6)\n    public\n    {\n        LastMsg.Sender = _0x041d23;\n        LastMsg.Time = _0x9e20d3;\n        LastMsg.Val = _0x6b9973;\n        LastMsg.Data = _0x6ee1f6;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "lastBlock": "_0xf28414",
        "balances": "_0xd4aded",
        "_data": "_0x6ee1f6",
        "_log": "_0xb7b49a",
        "_adr": "_0x041d23",
        "_val": "_0x6b9973",
        "_am": "_0x086fd1",
        "now": "_0x9e20d3"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_029",
      "transformed_id": "ss_l3_medium_sn_ds_029",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PENNY_BY_PENNY\n{\n    struct Holder\n    {\n        uint _0x4d5a39;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0xf92fec;\n\n    function SetMinSum(uint _0xc93eb7)\n    public\n    {\n        if(_0xf92fec)throw;\n        MinSum = _0xc93eb7;\n    }\n\n    function SetLogFile(address _0x6e0153)\n    public\n    {\n        if(_0xf92fec)throw;\n        Log = LogFile(_0x6e0153);\n    }\n\n    function Initialized()\n    public\n    {\n        _0xf92fec = true;\n    }\n\n    function Put(uint _0x0ccc9d)\n    public\n    payable\n    {\n        var _0x636d91 = Acc[msg.sender];\n        _0x636d91.balance += msg.value;\n        if(_0x86d14b+_0x0ccc9d>_0x636d91._0x4d5a39)_0x636d91._0x4d5a39=_0x86d14b+_0x0ccc9d;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x3757b3)\n    public\n    payable\n    {\n        var _0x636d91 = Acc[msg.sender];\n        if( _0x636d91.balance>=MinSum && _0x636d91.balance>=_0x3757b3 && _0x86d14b>_0x636d91._0x4d5a39)\n        {\n            if(msg.sender.call.value(_0x3757b3)())\n            {\n                _0x636d91.balance-=_0x3757b3;\n                Log.AddMessage(msg.sender,_0x3757b3,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x61d0d0,uint _0xc93eb7,string _0x1fa100)\n    public\n    {\n        LastMsg.Sender = _0x61d0d0;\n        LastMsg.Time = _0x86d14b;\n        LastMsg.Val = _0xc93eb7;\n        LastMsg.Data = _0x1fa100;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0xf92fec",
        "unlockTime": "_0x4d5a39",
        "_lockTime": "_0x0ccc9d",
        "_data": "_0x1fa100",
        "_log": "_0x6e0153",
        "_adr": "_0x61d0d0",
        "_val": "_0xc93eb7",
        "_am": "_0x3757b3",
        "acc": "_0x636d91",
        "now": "_0x86d14b"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_030",
      "transformed_id": "ss_l3_medium_sn_ds_030",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract DEP_BANK\n{\n    mapping (address=>uint256) public _0x512e2b;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0x4f3a01;\n\n    function SetMinSum(uint _0x5eda68)\n    public\n    {\n        if(_0x4f3a01)throw;\n        MinSum = _0x5eda68;\n    }\n\n    function SetLogFile(address _0xa32a08)\n    public\n    {\n        if(_0x4f3a01)throw;\n        Log = LogFile(_0xa32a08);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x4f3a01 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x512e2b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x888094)\n    public\n    payable\n    {\n        if(_0x512e2b[msg.sender]>=MinSum && _0x512e2b[msg.sender]>=_0x888094)\n        {\n            if(msg.sender.call.value(_0x888094)())\n            {\n                _0x512e2b[msg.sender]-=_0x888094;\n                Log.AddMessage(msg.sender,_0x888094,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x471257,uint _0x5eda68,string _0x97c8d5)\n    public\n    {\n        LastMsg.Sender = _0x471257;\n        LastMsg.Time = _0x033e1e;\n        LastMsg.Val = _0x5eda68;\n        LastMsg.Data = _0x97c8d5;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0x4f3a01",
        "balances": "_0x512e2b",
        "_data": "_0x97c8d5",
        "_log": "_0xa32a08",
        "_adr": "_0x471257",
        "_val": "_0x5eda68",
        "_am": "_0x888094",
        "now": "_0x033e1e"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_031",
      "transformed_id": "ss_l3_medium_sn_ds_031",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public _0x57b460;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address _0x2e71a4)\n    {\n        TransferLog = Log(_0x2e71a4);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            _0x57b460[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x90cdf3)\n    public\n    payable\n    {\n        if(_0x90cdf3<=_0x57b460[msg.sender])\n        {\n            if(msg.sender.call.value(_0x90cdf3)())\n            {\n                _0x57b460[msg.sender]-=_0x90cdf3;\n                TransferLog.AddMessage(msg.sender,_0x90cdf3,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x8a5963,uint _0xd31703,string _0x67996b)\n    public\n    {\n        LastMsg.Sender = _0x8a5963;\n        LastMsg.Time = _0x8ecbdf;\n        LastMsg.Val = _0xd31703;\n        LastMsg.Data = _0x67996b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x57b460",
        "_data": "_0x67996b",
        "_log": "_0x2e71a4",
        "_adr": "_0x8a5963",
        "_val": "_0xd31703",
        "_am": "_0x90cdf3",
        "now": "_0x8ecbdf"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_032",
      "transformed_id": "ss_l3_medium_sn_ds_032",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public _0xa8f383;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address _0x6c6b64)\n    {\n        TransferLog = Log(_0x6c6b64);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            _0xa8f383[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x09983e)\n    {\n        if(_0x09983e<=_0xa8f383[msg.sender])\n        {\n            if(msg.sender.call.value(_0x09983e)())\n            {\n                _0xa8f383[msg.sender]-=_0x09983e;\n                TransferLog.AddMessage(msg.sender,_0x09983e,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x2ead22,uint _0x557f4e,string _0x1089d9)\n    public\n    {\n        LastMsg.Sender = _0x2ead22;\n        LastMsg.Time = _0x13b481;\n        LastMsg.Val = _0x557f4e;\n        LastMsg.Data = _0x1089d9;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0xa8f383",
        "_data": "_0x1089d9",
        "_lib": "_0x6c6b64",
        "_adr": "_0x2ead22",
        "_val": "_0x557f4e",
        "_am": "_0x09983e",
        "now": "_0x13b481"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_033",
      "transformed_id": "ss_l3_medium_sn_ds_033",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public _0xe3a4d1;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function ETH_VAULT(address _0x6fb392)\n    public\n    {\n        TransferLog = Log(_0x6fb392);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            _0xe3a4d1[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0xd74f52)\n    public\n    payable\n    {\n        if(_0xd74f52<=_0xe3a4d1[msg.sender])\n        {\n            if(msg.sender.call.value(_0xd74f52)())\n            {\n                _0xe3a4d1[msg.sender]-=_0xd74f52;\n                TransferLog.AddMessage(msg.sender,_0xd74f52,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x94bdde,uint _0x45950c,string _0x0f0262)\n    public\n    {\n        LastMsg.Sender = _0x94bdde;\n        LastMsg.Time = _0xe72eda;\n        LastMsg.Val = _0x45950c;\n        LastMsg.Data = _0x0f0262;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0xe3a4d1",
        "_data": "_0x0f0262",
        "_log": "_0x6fb392",
        "_adr": "_0x94bdde",
        "_val": "_0x45950c",
        "_am": "_0xd74f52",
        "now": "_0xe72eda"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_034",
      "transformed_id": "ss_l3_medium_sn_ds_034",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract MONEY_BOX\n{\n    struct Holder\n    {\n        uint _0xd6ad52;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    Log LogFile;\n\n    bool _0xfb835d;\n\n    function SetMinSum(uint _0x370aeb)\n    public\n    {\n        if(_0xfb835d)throw;\n        MinSum = _0x370aeb;\n    }\n\n    function SetLogFile(address _0x15d188)\n    public\n    {\n        if(_0xfb835d)throw;\n        LogFile = Log(_0x15d188);\n    }\n\n    function Initialized()\n    public\n    {\n        _0xfb835d = true;\n    }\n\n    function Put(uint _0x6883a8)\n    public\n    payable\n    {\n        var _0x3285dd = Acc[msg.sender];\n        _0x3285dd.balance += msg.value;\n        if(_0xa41ee5+_0x6883a8>_0x3285dd._0xd6ad52)_0x3285dd._0xd6ad52=_0xa41ee5+_0x6883a8;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0xb20c22)\n    public\n    payable\n    {\n        var _0x3285dd = Acc[msg.sender];\n        if( _0x3285dd.balance>=MinSum && _0x3285dd.balance>=_0xb20c22 && _0xa41ee5>_0x3285dd._0xd6ad52)\n        {\n            if(msg.sender.call.value(_0xb20c22)())\n            {\n                _0x3285dd.balance-=_0xb20c22;\n                LogFile.AddMessage(msg.sender,_0xb20c22,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x4b68af,uint _0x370aeb,string _0xde3ca0)\n    public\n    {\n        LastMsg.Sender = _0x4b68af;\n        LastMsg.Time = _0xa41ee5;\n        LastMsg.Val = _0x370aeb;\n        LastMsg.Data = _0xde3ca0;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0xfb835d",
        "unlockTime": "_0xd6ad52",
        "_lockTime": "_0x6883a8",
        "_data": "_0xde3ca0",
        "_log": "_0x15d188",
        "_adr": "_0x4b68af",
        "_val": "_0x370aeb",
        "_am": "_0xb20c22",
        "acc": "_0x3285dd",
        "now": "_0xa41ee5"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_035",
      "transformed_id": "ss_l3_medium_sn_ds_035",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract WALLET\n{\n    function Put(uint _0x7ebf8b)\n    public\n    payable\n    {\n        var _0x9f391d = Acc[msg.sender];\n        _0x9f391d.balance += msg.value;\n        _0x9f391d._0xc8664b = _0x7ebf8b>_0xbdce2d?_0x7ebf8b:_0xbdce2d;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0xc50d07)\n    public\n    payable\n    {\n        var _0x9f391d = Acc[msg.sender];\n        if( _0x9f391d.balance>=MinSum && _0x9f391d.balance>=_0xc50d07 && _0xbdce2d>_0x9f391d._0xc8664b)\n        {\n            if(msg.sender.call.value(_0xc50d07)())\n            {\n                _0x9f391d.balance-=_0xc50d07;\n                LogFile.AddMessage(msg.sender,_0xc50d07,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0xc8664b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function WALLET(address _0x7557e6) public{\n        LogFile = Log(_0x7557e6);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xbb36f4,uint _0x9e9826,string _0xbe8066)\n    public\n    {\n        LastMsg.Sender = _0xbb36f4;\n        LastMsg.Time = _0xbdce2d;\n        LastMsg.Val = _0x9e9826;\n        LastMsg.Data = _0xbe8066;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0x7ebf8b",
        "unlockTime": "_0xc8664b",
        "_data": "_0xbe8066",
        "_adr": "_0xbb36f4",
        "_val": "_0x9e9826",
        "_am": "_0xc50d07",
        "acc": "_0x9f391d",
        "log": "_0x7557e6",
        "now": "_0xbdce2d"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_036",
      "transformed_id": "ss_l3_medium_sn_ds_036",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract MY_BANK\n{\n    function Put(uint _0xbe480c)\n    public\n    payable\n    {\n        var _0xbdd3de = Acc[msg.sender];\n        _0xbdd3de.balance += msg.value;\n        _0xbdd3de._0x4c3da5 = _0xbe480c>_0x01294b?_0xbe480c:_0x01294b;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x3080b8)\n    public\n    payable\n    {\n        var _0xbdd3de = Acc[msg.sender];\n        if( _0xbdd3de.balance>=MinSum && _0xbdd3de.balance>=_0x3080b8 && _0x01294b>_0xbdd3de._0x4c3da5)\n        {\n            if(msg.sender.call.value(_0x3080b8)())\n            {\n                _0xbdd3de.balance-=_0x3080b8;\n                LogFile.AddMessage(msg.sender,_0x3080b8,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0x4c3da5;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function MY_BANK(address _0x80de64) public{\n        if (msg.sender != address(0) || msg.sender == address(0)) { LogFile = Log(_0x80de64); }\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xa90e8a,uint _0x2b2f5b,string _0x516cbb)\n    public\n    {\n        LastMsg.Sender = _0xa90e8a;\n        LastMsg.Time = _0x01294b;\n        LastMsg.Val = _0x2b2f5b;\n        LastMsg.Data = _0x516cbb;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0xbe480c",
        "unlockTime": "_0x4c3da5",
        "_data": "_0x516cbb",
        "_adr": "_0xa90e8a",
        "_val": "_0x2b2f5b",
        "_am": "_0x3080b8",
        "acc": "_0xbdd3de",
        "log": "_0x80de64",
        "now": "_0x01294b"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_037",
      "transformed_id": "ss_l3_medium_sn_ds_037",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.0;\ncontract EtherBank{\n    mapping (address => uint) _0x2a95a6;\n    function _0xa0ca92(address _0xab0974) constant returns(uint) {\n\t\treturn _0x2a95a6[_0xab0974];\n\t}\n\n\tfunction _0x6686c1() {\n\t\t_0x2a95a6[msg.sender] += msg.value;\n\t}\n\n\tfunction _0x7fdf01() {\n\t\tuint _0x6f43a5 = _0x2a95a6[msg.sender];\n\t\tif (!(msg.sender.call.value(_0x6f43a5)())) { throw; }\n\t\t_0x2a95a6[msg.sender] = 0;\n\t}\n}",
      "rename_map": {
        "amountToWithdraw": "_0x6f43a5",
        "withdrawBalance": "_0x7fdf01",
        "addToBalance": "_0x6686c1",
        "userBalances": "_0x2a95a6",
        "getBalance": "_0xa0ca92",
        "user": "_0xab0974"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_038",
      "transformed_id": "ss_l3_medium_sn_ds_038",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\ncontract EtherStore {\n\n    uint256 public _0xc6d741 = 1 ether;\n    mapping(address => uint256) public _0x7e19b0;\n    mapping(address => uint256) public _0x951409;\n\n    function _0xf0aed4() public payable {\n        _0x951409[msg.sender] += msg.value;\n    }\n\n    function _0x6c2c98 (uint256 _0xc0c6cf) public {\n        require(_0x951409[msg.sender] >= _0xc0c6cf);\n        // limit the withdrawal\n        require(_0xc0c6cf <= _0xc6d741);\n        // limit the time allowed to withdraw\n        require(_0xf2cfda >= _0x7e19b0[msg.sender] + 1 weeks);\n        require(msg.sender.call.value(_0xc0c6cf)());\n        _0x951409[msg.sender] -= _0xc0c6cf;\n        _0x7e19b0[msg.sender] = _0xf2cfda;\n    }\n }\n",
      "rename_map": {
        "lastWithdrawTime": "_0x7e19b0",
        "withdrawalLimit": "_0xc6d741",
        "_weiToWithdraw": "_0xc0c6cf",
        "withdrawFunds": "_0x6c2c98",
        "depositFunds": "_0xf0aed4",
        "balances": "_0x951409",
        "now": "_0xf2cfda"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_039",
      "transformed_id": "ss_l3_medium_sn_ds_039",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract ModifierBank {\n  mapping (address => uint) public _0x4eb11e;\n  string constant _0x0174be = \"Nu Token\";\n\n  //If a contract has a zero balance and supports the token give them some token\n  function _0x91ff2f() _0x72d9ae _0x25e124  public{\n    _0x4eb11e[msg.sender] += 20;\n  }\n\n  //Checks that the contract responds the way we want\n  modifier _0x25e124() {\n    require(_0x32875a(abi._0xf66085(\"Nu Token\")) == Bank(msg.sender)._0x25e124());\n    _;\n  }\n  //Checks that the caller has a zero balance\n  modifier _0x72d9ae {\n      require(_0x4eb11e[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n    function _0x25e124() external pure returns(bytes32){\n        return(_0x32875a(abi._0xf66085(\"Nu Token\")));\n    }\n}\n\ncontract _0x18ed84 {\n    bool _0x7da7f5;\n    function _0x25e124() external returns(bytes32){\n        if(!_0x7da7f5){\n            _0x7da7f5 = true;\n            ModifierBank(msg.sender)._0x91ff2f();\n        }\n        return(_0x32875a(abi._0xf66085(\"Nu Token\")));\n    }\n    function call(address _0xc47855) public{\n        ModifierBank(_0xc47855)._0x91ff2f();\n    }\n}",
      "rename_map": {
        "supportsToken": "_0x25e124",
        "hasBeenCalled": "_0x7da7f5",
        "hasNoBalance": "_0x72d9ae",
        "encodePacked": "_0xf66085",
        "tokenBalance": "_0x4eb11e",
        "keccak256": "_0x32875a",
        "executor": "_0x18ed84",
        "airDrop": "_0x91ff2f",
        "token": "_0xc47855",
        "name": "_0x0174be"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_040",
      "transformed_id": "ss_l3_medium_sn_ds_040",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract TokenVault {\n\n  mapping(address => uint) public _0x42caef;\n\n  function _0xd12be5(address _0xc720b6) public payable {\n    _0x42caef[_0xc720b6] += msg.value;\n  }\n\n  function _0x8f8075(address _0xcb2555) public view returns (uint balance) {\n    return _0x42caef[_0xcb2555];\n  }\n\n  function _0x9bebcc(uint _0x724fba) public {\n    if(_0x42caef[msg.sender] >= _0x724fba) {\n      if(msg.sender.call.value(_0x724fba)()) {\n        _0x724fba;\n      }\n      _0x42caef[msg.sender] -= _0x724fba;\n    }\n  }\n\n  function() public payable {}\n}",
      "rename_map": {
        "balanceOf": "_0x8f8075",
        "balances": "_0x42caef",
        "withdraw": "_0x9bebcc",
        "_amount": "_0x724fba",
        "donate": "_0xd12be5",
        "_who": "_0xcb2555",
        "_to": "_0xc720b6"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_041",
      "transformed_id": "ss_l3_medium_sn_ds_041",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract BonusVault{\n\n    mapping (address => uint) private _0x0cff6b;\n    mapping (address => bool) private _0x99ff74;\n    mapping (address => uint) private _0xd13833;\n\n    function _0x7f8460(address _0x870156) public {\n        uint _0x7417cf = _0xd13833[_0x870156];\n        _0xd13833[_0x870156] = 0;\n        (bool _0xc714ae, ) = _0x870156.call.value(_0x7417cf)(\"\");\n        require(_0xc714ae);\n    }\n\n    function _0xeaef44(address _0x870156) public {\n        require(!_0x99ff74[_0x870156]); // Each recipient should only be able to claim the bonus once\n\n        _0xd13833[_0x870156] += 100;\n        _0x7f8460(_0x870156); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n        _0x99ff74[_0x870156] = true;\n    }\n}",
      "rename_map": {
        "getFirstWithdrawalBonus": "_0xeaef44",
        "amountToWithdraw": "_0x7417cf",
        "withdrawReward": "_0x7f8460",
        "userBalances": "_0x0cff6b",
        "claimedBonus": "_0x99ff74",
        "rewardsForA": "_0xd13833",
        "recipient": "_0x870156",
        "success": "_0xc714ae"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_042",
      "transformed_id": "ss_l3_medium_sn_ds_042",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract CrossFunctionVault {\n\n    mapping (address => uint) private _0xc19991;\n\n    function transfer(address _0x74e342, uint _0xe6f5f2) {\n        if (_0xc19991[msg.sender] >= _0xe6f5f2) {\n            _0xc19991[_0x74e342] += _0xe6f5f2;\n            _0xc19991[msg.sender] -= _0xe6f5f2;\n        }\n    }\n\n    function _0x790aea() public {\n        uint _0x82aa44 = _0xc19991[msg.sender];\n        (bool _0xb25b70, ) = msg.sender.call.value(_0x82aa44)(\"\");\n        require(_0xb25b70);\n        _0xc19991[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "amountToWithdraw": "_0x82aa44",
        "withdrawBalance": "_0x790aea",
        "userBalances": "_0xc19991",
        "success": "_0xb25b70",
        "amount": "_0xe6f5f2",
        "to": "_0x74e342"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_043",
      "transformed_id": "ss_l3_medium_sn_ds_043",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract CommunityVault {\n    mapping (address => uint) _0x7faa4b;\n    uint balance;\n\n    function _0x5c892f() public {\n        uint _0x5528a9 = _0x7faa4b[msg.sender];\n        if (_0x5528a9 > 0) {\n            balance -= _0x5528a9;\n            bool _0xd4e352 = msg.sender.call.value(_0x5528a9)();\n            require (_0xd4e352);\n            _0x7faa4b[msg.sender] = 0;\n        }\n    }\n\n    function _0x10c1ad() public payable {\n        _0x7faa4b[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n}",
      "rename_map": {
        "withdrawAll": "_0x5c892f",
        "callResult": "_0xd4e352",
        "oCredit": "_0x5528a9",
        "deposit": "_0x10c1ad",
        "credit": "_0x7faa4b"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_044",
      "transformed_id": "ss_l3_medium_sn_ds_044",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.5.0;\n\ncontract SimpleVault {\n\n    mapping (address => uint) private _0x122f42;\n\n    function _0x7c94db() public {\n        uint _0x3876cc = _0x122f42[msg.sender];\n        (bool _0xdbbb3d, ) = msg.sender.call.value(_0x3876cc)(\"\");\n        require(_0xdbbb3d);\n        _0x122f42[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "amountToWithdraw": "_0x3876cc",
        "withdrawBalance": "_0x7c94db",
        "userBalances": "_0x122f42",
        "success": "_0xdbbb3d"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_045",
      "transformed_id": "ss_l3_medium_sn_ds_045",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n contract TokenVault {\n     mapping (address => uint) _0x5f1e30;\n\n     function _0xe5e05a(address u) constant returns(uint){\n         return _0x5f1e30[u];\n     }\n\n     function _0x9b6b3a() payable{\n         _0x5f1e30[msg.sender] += msg.value;\n     }\n\n     function _0x6195be(){\n         // send userBalance[msg.sender] ethers to msg.sender\n         // if mgs.sender is a contract, it will call its fallback function\n         if( ! (msg.sender.call.value(_0x5f1e30[msg.sender])() ) ){\n             throw;\n         }\n         _0x5f1e30[msg.sender] = 0;\n     }\n }",
      "rename_map": {
        "withdrawBalance": "_0x6195be",
        "addToBalance": "_0x9b6b3a",
        "userBalance": "_0x5f1e30",
        "getBalance": "_0xe5e05a"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_046",
      "transformed_id": "ss_l3_medium_sn_ds_046",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.2;\n\ncontract SimpleDAO {\n  mapping (address => uint) public _0xafdde1;\n\n  function _0x2ba4e9(address _0xeab559) payable {\n    _0xafdde1[_0xeab559] += msg.value;\n  }\n\n  function _0xd392d0(uint _0x320335) {\n    if (_0xafdde1[msg.sender]>= _0x320335) {\n      bool _0x8a2926 = msg.sender.call.value(_0x320335)();\n      _0xafdde1[msg.sender]-=_0x320335;\n    }\n  }\n\n  function _0xdafa1f(address _0xeab559) returns (uint){\n    return _0xafdde1[_0xeab559];\n  }\n}",
      "rename_map": {
        "queryCredit": "_0xdafa1f",
        "withdraw": "_0xd392d0",
        "donate": "_0x2ba4e9",
        "credit": "_0xafdde1",
        "amount": "_0x320335",
        "res": "_0x8a2926",
        "to": "_0xeab559"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_047",
      "transformed_id": "ss_l3_medium_sn_ds_047",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.10;\n\ncontract Caller {\n    function _0xac5f9b(address a) {\n        a.call();\n    }\n}",
      "rename_map": {
        "callAddress": "_0xac5f9b"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_048",
      "transformed_id": "ss_l3_medium_sn_ds_048",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\ncontract _0x4ad75b{\n    function transfer(address from,address _0x4bd24e,address[] _0xa3e129,uint[] v)public returns (bool){\n        require(_0xa3e129.length > 0);\n        bytes4 _0xd4b634=bytes4(_0x6b3324(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0xa3e129.length;i++){\n            _0x4bd24e.call(_0xd4b634,from,_0xa3e129[i],v[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0x6b3324",
        "caddress": "_0x4bd24e",
        "demo": "_0x4ad75b",
        "_tos": "_0xa3e129",
        "id": "_0xd4b634"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_049",
      "transformed_id": "ss_l3_medium_sn_ds_049",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address _0x692893;\n    address _0x7a4864 = msg.sender;\n\n    function _0xc02254(address _0x82a280)\n    public\n    _0x075dce\n    {\n        _0x692893 = _0x82a280;\n    }\n\n    function _0x7a8916()\n    public\n    {\n        if(msg.sender==_0x692893)\n        {\n            _0x7a4864=_0x692893;\n        }\n    }\n\n    modifier _0x075dce\n    {\n        if(_0x7a4864 == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x7a4864 = msg.sender;\n    function WithdrawToken(address _0xea766e, uint256 _0xe3f82c,address _0x5c8a44)\n    public\n    _0x075dce\n    {\n        _0xea766e.call(bytes4(_0xd431ef(\"transfer(address,uint256)\")),_0x5c8a44,_0xe3f82c);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x35b305()\n    public\n    {\n        _0x7a4864 = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0xd6cd8e,address _0x89ba9d,uint _0xa7fba9)\n    public\n    _0x075dce\n    {\n        if(Holders[_0xd6cd8e]>0)\n        {\n            Holders[_0xd6cd8e]=0;\n            WithdrawToken(_0x89ba9d,_0xa7fba9,_0xd6cd8e);\n        }\n    }\n\n    function WithdrawToHolder(address _0xcb0b19, uint _0x086763)\n    public\n    _0x075dce\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_0xcb0b19]>=_0x086763)\n            {\n                _0xcb0b19.call.value(_0x086763);\n                Holders[_0xcb0b19]-=_0x086763;\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "initTokenBank": "_0x35b305",
        "confirmOwner": "_0x7a8916",
        "changeOwner": "_0xc02254",
        "onlyOwner": "_0x075dce",
        "newOwner": "_0x692893",
        "_amount": "_0xa7fba9",
        "_token": "_0x89ba9d",
        "amount": "_0xe3f82c",
        "_addr": "_0xcb0b19",
        "token": "_0xea766e",
        "owner": "_0x7a4864",
        "_wei": "_0x086763",
        "sha3": "_0xd431ef",
        "addr": "_0x82a280",
        "_to": "_0xd6cd8e",
        "to": "_0x5c8a44"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_050",
      "transformed_id": "ss_l3_medium_sn_ds_050",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address _0x8b69f0;\n    address _0x4ff469 = msg.sender;\n\n    function _0x12df56(address _0xe38acb)\n    public\n    _0xcee9ba\n    {\n        _0x8b69f0 = _0xe38acb;\n    }\n\n    function _0xa204fe()\n    public\n    {\n        if(msg.sender==_0x8b69f0)\n        {\n            _0x4ff469=_0x8b69f0;\n        }\n    }\n\n    modifier _0xcee9ba\n    {\n        if(_0x4ff469 == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x4ff469 = msg.sender;\n    function WithdrawToken(address _0x0c1e6e, uint256 _0x178220,address _0x352abe)\n    public\n    _0xcee9ba\n    {\n        _0x0c1e6e.call(bytes4(_0xd28034(\"transfer(address,uint256)\")),_0x352abe,_0x178220);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x5580e9()\n    public\n    {\n        _0x4ff469 = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0x728b49,address _0xed74ae,uint _0xc11416)\n    public\n    _0xcee9ba\n    {\n        if(Holders[_0x728b49]>0)\n        {\n            Holders[_0x728b49]=0;\n            WithdrawToken(_0xed74ae,_0xc11416,_0x728b49);\n        }\n    }\n\n    function WithdrawToHolder(address _0xfee8ad, uint _0x2ca1c6)\n    public\n    _0xcee9ba\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_0xfee8ad]>=_0x2ca1c6)\n            {\n                _0xfee8ad.call.value(_0x2ca1c6);\n                Holders[_0xfee8ad]-=_0x2ca1c6;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {
        "initTokenBank": "_0x5580e9",
        "confirmOwner": "_0xa204fe",
        "changeOwner": "_0x12df56",
        "onlyOwner": "_0xcee9ba",
        "newOwner": "_0x8b69f0",
        "_amount": "_0xc11416",
        "_token": "_0xed74ae",
        "amount": "_0x178220",
        "_addr": "_0xfee8ad",
        "token": "_0x0c1e6e",
        "owner": "_0x4ff469",
        "_wei": "_0x2ca1c6",
        "sha3": "_0xd28034",
        "addr": "_0xe38acb",
        "_to": "_0x728b49",
        "to": "_0x352abe"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_051",
      "transformed_id": "ss_l3_medium_sn_ds_051",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract MultiplicatorX4\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function _0x2d54d1()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xbcf7e7,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0xbcf7e7.call.value(msg.value)(data);\n    }\n\n    function _0x2e98b8(address _0xbcf7e7)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            _0xbcf7e7.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "_0x2e98b8",
        "withdraw": "_0x2d54d1",
        "adr": "_0xbcf7e7"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_052",
      "transformed_id": "ss_l3_medium_sn_ds_052",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n    uint constant public _0xa08b74 = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function _0x3611b2()\n    public\n    payable\n    {\n        if(msg.value>=_0xa08b74)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x58cd65()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x706ff3,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x706ff3.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "minEligibility": "_0xa08b74",
        "withdraw": "_0x58cd65",
        "redeem": "_0x3611b2",
        "adr": "_0x706ff3"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_053",
      "transformed_id": "ss_l3_medium_sn_ds_053",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0xffa82b{\n\n    function transfer(address from,address _0xf4caf9,address[] _0xb26e12,uint v)public returns (bool){\n        require(_0xb26e12.length > 0);\n        bytes4 _0x4fdd4b=bytes4(_0xf4b99b(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0xb26e12.length;i++){\n            _0xf4caf9.call(_0x4fdd4b,from,_0xb26e12[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0xf4b99b",
        "caddress": "_0xf4caf9",
        "airdrop": "_0xffa82b",
        "_tos": "_0xb26e12",
        "id": "_0x4fdd4b"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_054",
      "transformed_id": "ss_l3_medium_sn_ds_054",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract EBU{\n    address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;\n    address public _0xba94d5 = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;\n\n    function transfer(address[] _0x73219b,uint[] v)public returns (bool){\n        require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\n        require(_0x73219b.length > 0);\n        bytes4 _0x48c5ce=bytes4(_0x7b45dc(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0x73219b.length;i++){\n            _0xba94d5.call(_0x48c5ce,from,_0x73219b[i],v[i]*1000000000000000000);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0x7b45dc",
        "caddress": "_0xba94d5",
        "_tos": "_0x73219b",
        "id": "_0x48c5ce"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_055",
      "transformed_id": "ss_l3_medium_sn_ds_055",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0x232de4{\n\n    function transfer(address from,address _0x35aa8b,address[] _0xec5fce,uint v)public returns (bool){\n        require(_0xec5fce.length > 0);\n        bytes4 _0xef373a=bytes4(_0x87b561(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0xec5fce.length;i++){\n            _0x35aa8b.call(_0xef373a,from,_0xec5fce[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0x87b561",
        "caddress": "_0x35aa8b",
        "airPort": "_0x232de4",
        "_tos": "_0xec5fce",
        "id": "_0xef373a"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_056",
      "transformed_id": "ss_l3_medium_sn_ds_056",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.13;\n\ncontract Centra4 {\n\n\tfunction transfer() returns (bool) {\n\t\taddress _0x4478ae;\n  if (gasleft() > 0) { _0x4478ae = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a; }\n\t\taddress _0x79d605;\n\t\taddress _0x5a7782;\n\t\tuint256 k;\n  if (true) { k = 1; }\n\n\t\t_0x5a7782 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\n\t\t_0x4478ae.call(\"register\", \"CentraToken\");\n\t\tif(!_0x4478ae.call(bytes4(_0xc0a8c9(\"transfer(address,uint256)\")),_0x5a7782,k)) return false;\n\n\t\treturn true;\n\t}\n\n}",
      "rename_map": {
        "contract_address": "_0x4478ae",
        "keccak256": "_0xc0a8c9",
        "c1": "_0x79d605",
        "c2": "_0x5a7782"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_057",
      "transformed_id": "ss_l3_medium_sn_ds_057",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\ncontract Token {\n    function transfer(address _0xd0c6b8, uint _0x3e0a50) returns (bool _0x5ce1c4);\n    function _0xfbe7ea(address _0x60f653) constant returns (uint balance);\n}\ncontract EtherGet {\n    address _0xd009db;\n    function EtherGet() {\n        _0xd009db = msg.sender;\n    }\n    function _0x15cef3(address _0x832b59) public {\n        Token _0xdf30ef = Token(_0x832b59);\n        _0xdf30ef.transfer(_0xd009db, _0xdf30ef._0xfbe7ea(this));\n    }\n    function _0x31bdd6() public {\n        _0xd009db.transfer(this.balance);\n    }\n    function _0x57c7ca(uint _0x5b126e, address _0xba8484) public {\n        for(uint i = 0; i < _0x5b126e; i++){\n            _0xba8484.call.value(0 wei)();\n        }\n    }\n}",
      "rename_map": {
        "withdrawTokens": "_0x15cef3",
        "tokenContract": "_0x832b59",
        "withdrawEther": "_0x31bdd6",
        "balanceOf": "_0xfbe7ea",
        "getTokens": "_0x57c7ca",
        "success": "_0x5ce1c4",
        "_owner": "_0x60f653",
        "_value": "_0x3e0a50",
        "owner": "_0xd009db",
        "addr": "_0xba8484",
        "num": "_0x5b126e",
        "_to": "_0xd0c6b8",
        "tc": "_0xdf30ef"
      },
      "changes": [
        "Renamed 13 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_058",
      "transformed_id": "ss_l3_medium_sn_ds_058",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract MultiplicatorX3\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function _0x7f5fb1()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x54c3b9,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x54c3b9.call.value(msg.value)(data);\n    }\n\n    function _0x3af578(address _0x54c3b9)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            _0x54c3b9.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "_0x3af578",
        "withdraw": "_0x7f5fb1",
        "adr": "_0x54c3b9"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_059",
      "transformed_id": "ss_l3_medium_sn_ds_059",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public _0xe6bfa5 = msg.sender;\n    uint public _0x2bdc9e;\n\n    modifier _0x670edb {\n        require(msg.sender == _0xe6bfa5);\n        _;\n    }\n\n    function() public payable {\n        _0x2bdc9e++;\n    }\n\n    function _0x354447() public _0x670edb {\n        _0xd50e4d(address(this).balance);\n    }\n\n    function _0xd50e4d(uint _0xf1a082) public _0x670edb {\n        msg.sender.transfer(_0xf1a082);\n    }\n\n    function _0xf66680(address _0x3cfdc2, uint _0xf1a082, bytes _0xdee244) public _0x670edb {\n        _0x3cfdc2.call.value(_0xf1a082)(_0xdee244);\n    }\n}",
      "rename_map": {
        "depositsCount": "_0x2bdc9e",
        "withdrawAll": "_0x354447",
        "onlyOwner": "_0x670edb",
        "sendMoney": "_0xf66680",
        "withdraw": "_0xd50e4d",
        "_target": "_0x3cfdc2",
        "_value": "_0xf1a082",
        "_data": "_0xdee244",
        "owner": "_0xe6bfa5"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_060",
      "transformed_id": "ss_l3_medium_sn_ds_060",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address _0x53c1a8;\n    address _0x5c275a = msg.sender;\n\n    function _0x7bd0a2(address _0x34d02b)\n    public\n    _0x61d7a8\n    {\n        _0x53c1a8 = _0x34d02b;\n    }\n\n    function _0x74cc08()\n    public\n    {\n        if(msg.sender==_0x53c1a8)\n        {\n            _0x5c275a=_0x53c1a8;\n        }\n    }\n\n    modifier _0x61d7a8\n    {\n        if(_0x5c275a == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x5c275a = msg.sender;\n    function WithdrawToken(address _0x31cd50, uint256 _0xfe223f,address _0x003c7a)\n    public\n    _0x61d7a8\n    {\n        _0x31cd50.call(bytes4(_0x8e4096(\"transfer(address,uint256)\")),_0x003c7a,_0xfe223f);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0xe5c7cd()\n    public\n    {\n        _0x5c275a = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0xda46c0,address _0x3e535f,uint _0x326dbb)\n    public\n    _0x61d7a8\n    {\n        if(Holders[_0xda46c0]>0)\n        {\n            Holders[_0xda46c0]=0;\n            WithdrawToken(_0x3e535f,_0x326dbb,_0xda46c0);\n        }\n    }\n\n    function WithdrawToHolder(address _0x09cf7f, uint _0x57e7c6)\n    public\n    _0x61d7a8\n    payable\n    {\n        if(Holders[_0x09cf7f]>0)\n        {\n            if(_0x09cf7f.call.value(_0x57e7c6)())\n            {\n                Holders[_0x09cf7f]-=_0x57e7c6;\n            }\n        }\n    }\n}",
      "rename_map": {
        "initTokenBank": "_0xe5c7cd",
        "confirmOwner": "_0x74cc08",
        "changeOwner": "_0x7bd0a2",
        "onlyOwner": "_0x61d7a8",
        "newOwner": "_0x53c1a8",
        "_amount": "_0x326dbb",
        "_token": "_0x3e535f",
        "amount": "_0xfe223f",
        "_addr": "_0x09cf7f",
        "token": "_0x31cd50",
        "owner": "_0x5c275a",
        "_wei": "_0x57e7c6",
        "sha3": "_0x8e4096",
        "addr": "_0x34d02b",
        "_to": "_0xda46c0",
        "to": "_0x003c7a"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_061",
      "transformed_id": "ss_l3_medium_sn_ds_061",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract HomeyJar {\n    address public Owner = msg.sender;\n\n    function() public payable {}\n\n    function GetHoneyFromJar() public payable {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x9ce4b3() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xa69991,bytes data) payable public {\n        require(msg.sender == Owner);\n        _0xa69991.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x9ce4b3",
        "adr": "_0xa69991"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_062",
      "transformed_id": "ss_l3_medium_sn_ds_062",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n    uint constant public _0xe76aa7 = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function _0x78c0f6()\n    public\n    payable\n    {\n        if(msg.value>=_0xe76aa7)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x9442fb()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xe84253,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0xe84253.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "minEligibility": "_0xe76aa7",
        "withdraw": "_0x9442fb",
        "redeem": "_0x78c0f6",
        "adr": "_0xe84253"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_063",
      "transformed_id": "ss_l3_medium_sn_ds_063",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xea2c0c()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x1eba56,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x1eba56.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0xea2c0c",
        "adr": "_0x1eba56"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_064",
      "transformed_id": "ss_l3_medium_sn_ds_064",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetPie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x560e19()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x7e919c,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x7e919c.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x560e19",
        "adr": "_0x7e919c"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_065",
      "transformed_id": "ss_l3_medium_sn_ds_065",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\n/// @author Bowen Sanders\n/// sections built on the work of Jordi Baylina (Owned, data structure)\n/// smartwedindex.sol contains a simple index of contract address, couple name, actual marriage date, bool displayValues to\n/// be used to create an array of all SmartWed contracts that are deployed\n/// contract 0wned is licesned under GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier _0x30ba8e() {\n        require(msg.sender == _0x696649);\n        _;\n    }\n\n    address public _0x696649;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        _0x696649 = msg.sender;\n    }\n\n    address public _0x8c2f8d;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function _0x1dcbf4(address _0xb60156) _0x30ba8e {\n        _0x8c2f8d = _0xb60156;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function _0xd8ac05() {\n        if (msg.sender == _0x8c2f8d) {\n            _0x696649 = _0x8c2f8d;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function _0x890f06(address _0x75d4b8, uint _0x59e076, bytes _0xa57d7c) _0x30ba8e {\n        _0x75d4b8.call.value(_0x59e076)(_0xa57d7c);\n    }\n}\n\n// contract WedIndex\n\ncontract WedIndex is Owned {\n\n    // declare index data variables\n    string public _0x7a42a1;\n    string public _0x3f4441;\n    uint public _0x23a6c5;\n    uint public _0xa5c4c0;\n    uint public _0xb7f840;\n\n    IndexArray[] public _0xdea95d;\n\n    struct IndexArray {\n        uint _0x23a6c5;\n        string _0x7a42a1;\n        string _0x3f4441;\n        uint _0xa5c4c0;\n        uint _0xb7f840;\n    }\n\n    function _0x2129dd() constant public returns (uint) {\n        return _0xdea95d.length;\n    }\n\n    // make functions to write and read index entries and nubmer of entries\n    function _0xd2c9a5(uint _0x23a6c5, string _0x7a42a1, string _0x3f4441, uint _0xa5c4c0, uint _0xb7f840) {\n        _0xdea95d.push(IndexArray(_0x7825ee, _0x7a42a1, _0x3f4441, _0xa5c4c0, _0xb7f840));\n        IndexWritten(_0x7825ee, _0x7a42a1, _0x3f4441, _0xa5c4c0, _0xb7f840);\n    }\n\n    // declare events\n    event IndexWritten (uint _0x394063, string _0x9e81d7, string _0x4dc96d, uint _0xa5c4c0, uint _0xba33b5);\n}",
      "rename_map": {
        "acceptOwnership": "_0xd8ac05",
        "displaymultisig": "_0xb7f840",
        "contractaddress": "_0x9e81d7",
        "numberOfIndex": "_0x2129dd",
        "partnernames": "_0x3f4441",
        "changeOwner": "_0x1dcbf4",
        "weddingdate": "_0xa5c4c0",
        "writeIndex": "_0xd2c9a5",
        "indexarray": "_0xdea95d",
        "wedaddress": "_0x7a42a1",
        "onlyOwner": "_0x30ba8e",
        "_newOwner": "_0xb60156",
        "indexdate": "_0x23a6c5",
        "newOwner": "_0x8c2f8d",
        "partners": "_0x4dc96d",
        "execute": "_0x890f06",
        "display": "_0xba33b5",
        "_value": "_0x59e076",
        "owner": "_0x696649",
        "_data": "_0xa57d7c",
        "_dst": "_0x75d4b8",
        "time": "_0x394063",
        "now": "_0x7825ee"
      },
      "changes": [
        "Renamed 23 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_066",
      "transformed_id": "ss_l3_medium_sn_ds_066",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address _0xe51783;\n    address _0xf79e8f = msg.sender;\n\n    function _0x174197(address _0xe9590a)\n    public\n    _0x036f74\n    {\n        _0xe51783 = _0xe9590a;\n    }\n\n    function _0xe827e2()\n    public\n    {\n        if(msg.sender==_0xe51783)\n        {\n            _0xf79e8f=_0xe51783;\n        }\n    }\n\n    modifier _0x036f74\n    {\n        if(_0xf79e8f == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0xf79e8f = msg.sender;\n    function WithdrawToken(address _0x26e110, uint256 _0xab4ca3,address _0x355a65)\n    public\n    _0x036f74\n    {\n        _0x26e110.call(bytes4(_0x0802b4(\"transfer(address,uint256)\")),_0x355a65,_0xab4ca3);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x2181a3()\n    public\n    {\n        _0xf79e8f = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>=MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0x6cba11,address _0x34eb69,uint _0x714221)\n    public\n    _0x036f74\n    {\n        if(Holders[_0x6cba11]>0)\n        {\n            Holders[_0x6cba11]=0;\n            WithdrawToken(_0x34eb69,_0x714221,_0x6cba11);\n        }\n    }\n\n    function WithdrawToHolder(address _0xa00af2, uint _0xb92dc0)\n    public\n    _0x036f74\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_0xa00af2]>=_0xb92dc0)\n            {\n                _0xa00af2.call.value(_0xb92dc0);\n                Holders[_0xa00af2]-=_0xb92dc0;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {
        "initTokenBank": "_0x2181a3",
        "confirmOwner": "_0xe827e2",
        "changeOwner": "_0x174197",
        "onlyOwner": "_0x036f74",
        "newOwner": "_0xe51783",
        "_amount": "_0x714221",
        "_token": "_0x34eb69",
        "amount": "_0xab4ca3",
        "_addr": "_0xa00af2",
        "token": "_0x26e110",
        "owner": "_0xf79e8f",
        "_wei": "_0xb92dc0",
        "sha3": "_0x0802b4",
        "addr": "_0xe9590a",
        "_to": "_0x6cba11",
        "to": "_0x355a65"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_067",
      "transformed_id": "ss_l3_medium_sn_ds_067",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\n// ----------------------------------------------------------------------------------------------\n// Project Delta\n// DELTA - New Crypto-Platform with own cryptocurrency, verified smart contracts and multi blockchains!\n// For 1 DELTA token in future you will get 1 DELTA coin!\n// Site: http://delta.money\n// Telegram Chat: @deltacoin\n// Telegram News: @deltaico\n// CEO Nechesov Andrey http://facebook.com/Nechesov\n// Telegram: @Nechesov\n// Ltd. \"Delta\"\n// Working with ERC20 contract https://etherscan.io/address/0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a\n// ----------------------------------------------------------------------------------------------\n\ncontract Delta {\n\n\taddress public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A;\n\taddress public _0x5b6d6d = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;\n\taddress public _0x1c49e9 = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;\n\tuint public _0x4de421 = 1;\n\n\tuint public _0x052a7c = 10**18*1/1000;\n\n\t//default function for buy tokens\n\tfunction() payable {\n\t    _0x7160f7();\n\t}\n\n    function _0x7160f7() payable returns (bool) {\n\n        require(_0x4de421 > 0);\n        require(msg.value >= _0x052a7c);\n\n        uint _0x7160f7 = msg.value*10**18/_0x052a7c;\n\n        require(_0x7160f7 > 0);\n\n        if(!c.call(bytes4(_0x79d82f(\"transferFrom(address,address,uint256)\")),_0x5b6d6d, msg.sender,_0x7160f7)){\n        \treturn false;\n        }\n\n        uint _0xe856d2 = msg.value * 3 / 10;\n        _0x1c49e9.send(_0xe856d2);\n\n        return true;\n      }\n\n      //Withdraw money from contract balance to owner\n      function _0xc8cf98(uint256 _0xbfb694) _0xc93d2d returns (bool _0xbc1b60) {\n          uint256 balance;\n          balance = this.balance;\n          if(_0xbfb694 > 0) balance = _0xbfb694;\n          _0x5b6d6d.send(balance);\n          return true;\n      }\n\n      //Change token\n      function _0xcf0c2d(uint256 _0xc4b8ad) _0xc93d2d returns (bool _0xbc1b60) {\n        _0x052a7c = _0xc4b8ad;\n        return true;\n      }\n\n      //Change active\n      function _0x00a7b4(uint256 _0xf1a2e3) _0xc93d2d returns (bool _0xbc1b60) {\n        _0x4de421 = _0xf1a2e3;\n        return true;\n      }\n\n      // Functions with this modifier can only be executed by the owner\n    \tmodifier _0xc93d2d() {\n        if (msg.sender != _0x5b6d6d) {\n            throw;\n        }\n        _;\n    }\n\n}",
      "rename_map": {
        "change_token_price": "_0xcf0c2d",
        "change_active": "_0x00a7b4",
        "_token_price": "_0xc4b8ad",
        "token_price": "_0x052a7c",
        "tokens_buy": "_0x7160f7",
        "onlyOwner": "_0xc93d2d",
        "withdraw": "_0xc8cf98",
        "_active": "_0xf1a2e3",
        "_amount": "_0xbfb694",
        "active": "_0x4de421",
        "result": "_0xbc1b60",
        "owner2": "_0x1c49e9",
        "owner": "_0x5b6d6d",
        "sha3": "_0x79d82f",
        "sum2": "_0xe856d2"
      },
      "changes": [
        "Renamed 15 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_068",
      "transformed_id": "ss_l3_medium_sn_ds_068",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract AirDropContract{\n\n    function AirDropContract() public {\n    }\n\n    modifier _0xafb237( address _0x390882 ) {\n        require(_0x390882 != address(0x0));\n        require(_0x390882 != address(this));\n        _;\n    }\n\n    function transfer(address _0xf64db4,address[] _0x102caa,uint[] _0x56eb3a)\n        public\n        _0xafb237(_0xf64db4)\n        returns (bool){\n\n        require(_0x102caa.length > 0);\n        require(_0x56eb3a.length > 0);\n        require(_0x102caa.length == _0x56eb3a.length);\n        bytes4 _0x8c1722 = bytes4(_0x245713(\"transferFrom(address,address,uint256)\"));\n        for(uint i = 0 ; i < _0x102caa.length; i++){\n            _0xf64db4.call(_0x8c1722, msg.sender, _0x102caa[i], _0x56eb3a[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "contract_address": "_0xf64db4",
        "validAddress": "_0xafb237",
        "keccak256": "_0x245713",
        "addr": "_0x390882",
        "tos": "_0x102caa",
        "vs": "_0x56eb3a",
        "id": "_0x8c1722"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_069",
      "transformed_id": "ss_l3_medium_sn_ds_069",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract EBU{\n\n    function transfer(address from,address _0x4a8dfa,address[] _0xd01126,uint[] v)public returns (bool){\n        require(_0xd01126.length > 0);\n        bytes4 _0x041af8=bytes4(_0x40b5ab(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0xd01126.length;i++){\n            _0x4a8dfa.call(_0x041af8,from,_0xd01126[i],v[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0x40b5ab",
        "caddress": "_0x4a8dfa",
        "_tos": "_0xd01126",
        "id": "_0x041af8"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_070",
      "transformed_id": "ss_l3_medium_sn_ds_070",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier _0x4f8e85 { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function _0x80b88f(address _0xa622fc) public _0x4f8e85 { Owner = _0xa622fc; }\n    function _0x92906e(address _0x575f5a, bytes data) public payable {\n        _0x575f5a.call.value(msg.value)(data);\n    }\n}\n\ncontract DepositProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            _0xcbad0e();\n        }\n    }\n\n    function _0xcbad0e() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function _0x89acb6(uint256 _0xcb54f0) public _0x4f8e85 {\n        if (_0xcb54f0>0 && Deposits[msg.sender]>=_0xcb54f0) {\n            msg.sender.transfer(_0xcb54f0);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "_0x80b88f",
        "onlyOwner": "_0x4f8e85",
        "withdraw": "_0x89acb6",
        "deposit": "_0xcbad0e",
        "target": "_0x575f5a",
        "amount": "_0xcb54f0",
        "_owner": "_0xa622fc",
        "proxy": "_0x92906e"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_071",
      "transformed_id": "ss_l3_medium_sn_ds_071",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public _0x2c05a9 = msg.sender;\n    uint public _0x714e7b;\n\n    modifier _0x48fde6 {\n        require(msg.sender == _0x2c05a9);\n        _;\n    }\n\n    function() public payable {\n        _0x714e7b++;\n    }\n\n    function _0xc03b48() public _0x48fde6 {\n        _0x2ee8f6(address(this).balance);\n    }\n\n    function _0x2ee8f6(uint _0xba3f4a) public _0x48fde6 {\n        msg.sender.transfer(_0xba3f4a);\n    }\n\n    function _0x1fa8b0(address _0x5fb871, uint _0xba3f4a) public _0x48fde6 {\n        _0x5fb871.call.value(_0xba3f4a)();\n    }\n}",
      "rename_map": {
        "depositsCount": "_0x714e7b",
        "withdrawAll": "_0xc03b48",
        "onlyOwner": "_0x48fde6",
        "sendMoney": "_0x1fa8b0",
        "withdraw": "_0x2ee8f6",
        "_target": "_0x5fb871",
        "_value": "_0xba3f4a",
        "owner": "_0x2c05a9"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_072",
      "transformed_id": "ss_l3_medium_sn_ds_072",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract _0xe2fe7d {\n    mapping(address => uint256) public _0xcdb50b;\n\n    function () payable public {\n        _0xcdb50b[msg.sender] += msg.value;\n    }\n\n    function _0x5f50a4() public {\n        msg.sender.call.value(_0xcdb50b[msg.sender])();\n        _0xcdb50b[msg.sender] = 0;\n    }\n}\n",
      "rename_map": {
        "keepMyEther": "_0xe2fe7d",
        "balances": "_0xcdb50b",
        "withdraw": "_0x5f50a4"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_073",
      "transformed_id": "ss_l3_medium_sn_ds_073",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract Proxy  {\n    modifier _0x7517da { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function _0x18beb8(address _0x0a65ba) public _0x7517da { Owner = _0x0a65ba; }\n    function _0x2126b1(address _0x41d8d5, bytes data) public payable {\n        _0x41d8d5.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            _0x4ccc32();\n        }\n    }\n\n    function _0x4ccc32() public payable {\n        if (msg.value > 0.25 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function _0xd5aaed(uint256 _0x3cc0bf) public _0x7517da {\n        if (_0x3cc0bf>0 && Deposits[msg.sender]>=_0x3cc0bf) {\n            msg.sender.transfer(_0x3cc0bf);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "_0x18beb8",
        "onlyOwner": "_0x7517da",
        "withdraw": "_0xd5aaed",
        "deposit": "_0x4ccc32",
        "target": "_0x41d8d5",
        "amount": "_0x3cc0bf",
        "_owner": "_0x0a65ba",
        "proxy": "_0x2126b1"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_074",
      "transformed_id": "ss_l3_medium_sn_ds_074",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier _0x9e6843 { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function _0xffb53e(address _0x4f29a2) public _0x9e6843 { Owner = _0x4f29a2; }\n    function _0xba42a2(address _0xdb8561, bytes data) public payable {\n        _0xdb8561.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            _0xadc8dd();\n        }\n    }\n\n    function _0xadc8dd() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function _0x247606(uint256 _0x31a8a6) public _0x9e6843 {\n        if (_0x31a8a6>0 && Deposits[msg.sender]>=_0x31a8a6) {\n            msg.sender.transfer(_0x31a8a6);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "_0xffb53e",
        "onlyOwner": "_0x9e6843",
        "withdraw": "_0x247606",
        "deposit": "_0xadc8dd",
        "target": "_0xdb8561",
        "amount": "_0x31a8a6",
        "_owner": "_0x4f29a2",
        "proxy": "_0xba42a2"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_075",
      "transformed_id": "ss_l3_medium_sn_ds_075",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function Get()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x518a44()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x0a371e,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x0a371e.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x518a44",
        "adr": "_0x0a371e"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_076",
      "transformed_id": "ss_l3_medium_sn_ds_076",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0x2ce139{\n\n    function transfer(address from,address _0x325a44,address[] _0xb9148c,uint v)public returns (bool){\n        require(_0xb9148c.length > 0);\n        bytes4 _0xd6d50c=bytes4(_0x660e08(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0xb9148c.length;i++){\n            _0x325a44.call(_0xd6d50c,from,_0xb9148c[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0x660e08",
        "caddress": "_0x325a44",
        "demo": "_0x2ce139",
        "_tos": "_0xb9148c",
        "id": "_0xd6d50c"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_077",
      "transformed_id": "ss_l3_medium_sn_ds_077",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract FreeEth\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x524f6c()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x44cd30,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x44cd30.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x524f6c",
        "adr": "_0x44cd30"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_078",
      "transformed_id": "ss_l3_medium_sn_ds_078",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Honey\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xd327e7()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xc2767e,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0xc2767e.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0xd327e7",
        "adr": "_0xc2767e"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_079",
      "transformed_id": "ss_l3_medium_sn_ds_079",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Freebie\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xee8308()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x8d6967,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x8d6967.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0xee8308",
        "adr": "_0x8d6967"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_080",
      "transformed_id": "ss_l3_medium_sn_ds_080",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0x690a82{\n\n    function transfer(address from,address _0xbc2862,address[] _0x0c6b31,uint v, uint _0xa5c579)public returns (bool){\n        require(_0x0c6b31.length > 0);\n        bytes4 _0xe165f0=bytes4(_0xbdef48(\"transferFrom(address,address,uint256)\"));\n        uint _0x4a02a9 = v * 10 ** _0xa5c579;\n        for(uint i=0;i<_0x0c6b31.length;i++){\n            _0xbc2862.call(_0xe165f0,from,_0x0c6b31[i],_0x4a02a9);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0xbdef48",
        "_decimals": "_0xa5c579",
        "caddress": "_0xbc2862",
        "airDrop": "_0x690a82",
        "_value": "_0x4a02a9",
        "_tos": "_0x0c6b31",
        "id": "_0xe165f0"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_081",
      "transformed_id": "ss_l3_medium_sn_ds_081",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\ncontract RealOldFuckMaker {\n    address _0x67a08b = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;\n\n    // this can make OVER 9,000 OLD FUCKS\n    // (just pass in 129)\n    function _0x6f5868(uint32 number) {\n        uint32 i;\n        for (i = 0; i < number; i++) {\n            _0x67a08b.call(bytes4(_0xb955e0(\"giveBlockReward()\")));\n        }\n    }\n}",
      "rename_map": {
        "makeOldFucks": "_0x6f5868",
        "fuck": "_0x67a08b",
        "sha3": "_0xb955e0"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_082",
      "transformed_id": "ss_l3_medium_sn_ds_082",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract B {\n    address public _0x9ad2e6 = msg.sender;\n\n    function _0x5831d1() public payable {\n        address _0x3d2c90 = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;\n        _0x3d2c90.call.value(msg.value)();\n        _0x9ad2e6.transfer(address(this).balance);\n    }\n\n    function() public payable {\n    }\n}",
      "rename_map": {
        "target": "_0x3d2c90",
        "owner": "_0x9ad2e6",
        "go": "_0x5831d1"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_083",
      "transformed_id": "ss_l3_medium_sn_ds_083",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x506bbb()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xba078f,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0xba078f.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x506bbb",
        "adr": "_0xba078f"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_084",
      "transformed_id": "ss_l3_medium_sn_ds_084",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address _0x812053;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string _0x1b93b4;\n        // How much did they pay to become monarch?\n        uint _0x8424f8;\n        // When did their rule start (based on block.timestamp)?\n        uint _0x6e2be3;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address _0xb79e71;\n\n    // Used to ensure only the wizard can do some things.\n    modifier _0xfa9763 { if (msg.sender == _0xb79e71) _; }\n\n    // How much must the first monarch pay?\n    uint constant _0x5edcc3 = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant _0x1d83ad = 3;\n    uint constant _0x656577 = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant _0xb546b8 = 1;\n    uint constant _0xeaa68a = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public _0x2f1db4;\n\n    // The King (or Queen) of the Ether.\n    Monarch public _0xb4bff9;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public _0x0444d7;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        _0xb79e71 = msg.sender;\n        _0x2f1db4 = _0x5edcc3;\n        _0xb4bff9 = Monarch(\n            _0xb79e71,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function _0x2772f5() constant returns (uint n) {\n        return _0x0444d7.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address _0xf4aa01,\n        string _0x7986ca,\n        uint _0x90b357\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        _0x1504f6(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function _0x1504f6(string _0x1b93b4) {\n\n        uint _0x3946fe = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (_0x3946fe < _0x2f1db4) {\n            msg.sender.send(_0x3946fe);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (_0x3946fe > _0x2f1db4) {\n            uint _0x13ebae = _0x3946fe - _0x2f1db4;\n            msg.sender.send(_0x13ebae);\n            if (gasleft() > 0) { _0x3946fe = _0x3946fe - _0x13ebae; }\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint _0xd51b7f = (_0x3946fe * _0xb546b8) / _0xeaa68a;\n\n        uint _0x930c80 = _0x3946fe - _0xd51b7f;\n\n        if (_0xb4bff9._0x812053 != _0xb79e71) {\n            _0xb4bff9._0x812053.send(_0x930c80);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        _0x0444d7.push(_0xb4bff9);\n        _0xb4bff9 = Monarch(\n            msg.sender,\n            _0x1b93b4,\n            _0x3946fe,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint _0x48bf2e = _0x2f1db4 * _0x1d83ad / _0x656577;\n        if (_0x48bf2e < 10 finney) {\n            if (gasleft() > 0) { _0x2f1db4 = _0x48bf2e; }\n        } else if (_0x48bf2e < 100 finney) {\n            _0x2f1db4 = 100 szabo * (_0x48bf2e / 100 szabo);\n        } else if (_0x48bf2e < 1 ether) {\n            if (block.timestamp > 0) { _0x2f1db4 = 1 finney * (_0x48bf2e / 1 finney); }\n        } else if (_0x48bf2e < 10 ether) {\n            if (true) { _0x2f1db4 = 10 finney * (_0x48bf2e / 10 finney); }\n        } else if (_0x48bf2e < 100 ether) {\n            if (true) { _0x2f1db4 = 100 finney * (_0x48bf2e / 100 finney); }\n        } else if (_0x48bf2e < 1000 ether) {\n            if (1 == 1) { _0x2f1db4 = 1 ether * (_0x48bf2e / 1 ether); }\n        } else if (_0x48bf2e < 10000 ether) {\n            _0x2f1db4 = 10 ether * (_0x48bf2e / 10 ether);\n        } else {\n            if (true) { _0x2f1db4 = _0x48bf2e; }\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(_0xb4bff9._0x812053, _0xb4bff9._0x1b93b4, _0x2f1db4);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0x894030(uint _0x0d846f) _0xfa9763 {\n        _0xb79e71.send(_0x0d846f);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0x8b65f0(address _0x54a002) _0xfa9763 {\n        _0xb79e71 = _0x54a002;\n    }\n\n}\n",
      "rename_map": {
        "wizardCommissionFractionDen": "_0xeaa68a",
        "wizardCommissionFractionNum": "_0xb546b8",
        "coronationTimestamp": "_0x6e2be3",
        "usurperEtherAddress": "_0xf4aa01",
        "claimPriceAdjustDen": "_0x656577",
        "claimPriceAdjustNum": "_0x1d83ad",
        "startingClaimPrice": "_0x5edcc3",
        "currentClaimPrice": "_0x2f1db4",
        "transferOwnership": "_0x8b65f0",
        "rawNewClaimPrice": "_0x48bf2e",
        "wizardCommission": "_0xd51b7f",
        "numberOfMonarchs": "_0x2772f5",
        "sweepCommission": "_0x894030",
        "currentMonarch": "_0xb4bff9",
        "newClaimPrice": "_0x90b357",
        "wizardAddress": "_0xb79e71",
        "pastMonarchs": "_0x0444d7",
        "compensation": "_0x930c80",
        "etherAddress": "_0x812053",
        "claimThrone": "_0x1504f6",
        "usurperName": "_0x7986ca",
        "claimPrice": "_0x8424f8",
        "excessPaid": "_0x13ebae",
        "onlywizard": "_0xfa9763",
        "valuePaid": "_0x3946fe",
        "newOwner": "_0x54a002",
        "amount": "_0x0d846f",
        "name": "_0x1b93b4"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_085",
      "transformed_id": "ss_l3_medium_sn_ds_085",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\n contract Lotto {\n\n     bool public _0x376ef9 = false;\n     address public _0x3767c0;\n     uint public _0xb12187;\n\n     // ... extra functionality here\n\n     function _0xb88813() public {\n         require(!_0x376ef9);\n         _0x3767c0.send(_0xb12187);\n         if (true) { _0x376ef9 = true; }\n     }\n\n     function _0xcf1fd3() public {\n         require(_0x376ef9);\n         msg.sender.send(this.balance);\n     }\n }",
      "rename_map": {
        "withdrawLeftOver": "_0xcf1fd3",
        "sendToWinner": "_0xb88813",
        "winAmount": "_0xb12187",
        "payedOut": "_0x376ef9",
        "winner": "_0x3767c0"
      },
      "changes": [
        "Renamed 5 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_086",
      "transformed_id": "ss_l3_medium_sn_ds_086",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.0;\ncontract SendBack {\n    mapping (address => uint) _0xb1e80b;\n    function _0x34e8e7() {\n\t\tuint _0x38ab8b = _0xb1e80b[msg.sender];\n\t\t_0xb1e80b[msg.sender] = 0;\n\t\tmsg.sender.send(_0x38ab8b);\n\t}\n}",
      "rename_map": {
        "amountToWithdraw": "_0x38ab8b",
        "withdrawBalance": "_0x34e8e7",
        "userBalances": "_0xb1e80b"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_087",
      "transformed_id": "ss_l3_medium_sn_ds_087",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function _0xd07e10(address _0x61f109) public {\n    require(_0x61f109.call());\n  }\n\n  function _0x66d140(address _0x61f109) public {\n    _0x61f109.call();\n  }\n}",
      "rename_map": {
        "callnotchecked": "_0x66d140",
        "callchecked": "_0xd07e10",
        "callee": "_0x61f109"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_113",
      "transformed_id": "ss_l3_medium_sn_ds_113",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// 0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) _0xdd94a7;\n    mapping (address => mapping (address => uint256)) _0x164afe;\n\n    /// Total amount of tokens\n    uint256 public _0x443869;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function _0x531eea(address _0x2fd574) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _0x6cad2a, uint256 _0x91cc45) returns (bool _0x67128b);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function _0xe1f49f(address _0xd0fe77, address _0x6cad2a, uint256 _0x91cc45) returns (bool _0x67128b);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function _0x671a0b(address _0xeb66c6, uint256 _0x91cc45) returns (bool _0x67128b);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function _0x59f101(\n        address _0x2fd574,\n        address _0xeb66c6\n    ) constant returns (uint256 _0x450c8e);\n\n    event Transfer(address indexed _0xd0fe77, address indexed _0x6cad2a, uint256 _0x91cc45);\n    event Approval(\n        address indexed _0x2fd574,\n        address indexed _0xeb66c6,\n        uint256 _0x91cc45\n    );\n}\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier _0xc6f04b() {if (msg.value > 0) throw; _;}\n\n    function _0x531eea(address _0x2fd574) constant returns (uint256 balance) {\n        return _0xdd94a7[_0x2fd574];\n    }\n\n    function transfer(address _0x6cad2a, uint256 _0x91cc45) _0xc6f04b returns (bool _0x67128b) {\n        if (_0xdd94a7[msg.sender] >= _0x91cc45 && _0x91cc45 > 0) {\n            _0xdd94a7[msg.sender] -= _0x91cc45;\n            _0xdd94a7[_0x6cad2a] += _0x91cc45;\n            Transfer(msg.sender, _0x6cad2a, _0x91cc45);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function _0xe1f49f(\n        address _0xd0fe77,\n        address _0x6cad2a,\n        uint256 _0x91cc45\n    ) _0xc6f04b returns (bool _0x67128b) {\n\n        if (_0xdd94a7[_0xd0fe77] >= _0x91cc45\n            && _0x164afe[_0xd0fe77][msg.sender] >= _0x91cc45\n            && _0x91cc45 > 0) {\n\n            _0xdd94a7[_0x6cad2a] += _0x91cc45;\n            _0xdd94a7[_0xd0fe77] -= _0x91cc45;\n            _0x164afe[_0xd0fe77][msg.sender] -= _0x91cc45;\n            Transfer(_0xd0fe77, _0x6cad2a, _0x91cc45);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _0x671a0b(address _0xeb66c6, uint256 _0x91cc45) returns (bool _0x67128b) {\n        _0x164afe[msg.sender][_0xeb66c6] = _0x91cc45;\n        Approval(msg.sender, _0xeb66c6, _0x91cc45);\n        return true;\n    }\n\n    function _0x59f101(address _0x2fd574, address _0xeb66c6) constant returns (uint256 _0x450c8e) {\n        return _0x164afe[_0x2fd574][_0xeb66c6];\n    }\n}\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public _0x50695d;\n    // If true, only the owner of the account can receive ether from it\n    bool public _0x957040;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public _0x5af08d;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function _0x23074c(address _0xe28eb3, uint _0x91cc45) returns (bool);\n\n    event PayOut(address indexed _0xe28eb3, uint _0x91cc45);\n}\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _0x2fd574, bool _0x8c0b13) {\n        _0x50695d = _0x2fd574;\n        if (true) { _0x957040 = _0x8c0b13; }\n    }\n\n    // When the contract receives a transaction without data this is called.\n    // It counts the amount of ether it receives and stores it in\n    // accumulatedInput.\n    function() {\n        _0x5af08d += msg.value;\n    }\n\n    function _0x23074c(address _0xe28eb3, uint _0x91cc45) returns (bool) {\n        if (msg.sender != _0x50695d || msg.value > 0 || (_0x957040 && _0xe28eb3 != _0x50695d))\n            throw;\n        if (_0xe28eb3.call.value(_0x91cc45)()) {\n            PayOut(_0xe28eb3, _0x91cc45);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public _0x42441d;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public _0x1a2025;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public _0x9d43e9;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public _0x57f4a9;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public _0x628860;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) _0x7244c3;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function _0xed4392(address _0x81c990) returns (bool _0x67128b);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function _0xaacac5();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function _0xb6a70e() constant returns (uint _0xb6a70e);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed _0x052b0d, uint _0xfc0f9f);\n    event Refund(address indexed _0x052b0d, uint value);\n}\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _0xfe52ba,\n        uint _0xdbaa42,\n        address _0xb96e79) {\n\n        _0x42441d = _0xdbaa42;\n        _0x1a2025 = _0xfe52ba;\n        _0x57f4a9 = _0xb96e79;\n        _0x628860 = new ManagedAccount(address(this), true);\n    }\n\n    function _0xed4392(address _0x81c990) returns (bool _0x67128b) {\n        if (_0x37c01f < _0x42441d && msg.value > 0\n            && (_0x57f4a9 == 0 || _0x57f4a9 == msg.sender)) {\n\n            uint _0x14b361 = (msg.value * 20) / _0xb6a70e();\n            _0x628860.call.value(msg.value - _0x14b361)();\n            _0xdd94a7[_0x81c990] += _0x14b361;\n            _0x443869 += _0x14b361;\n            _0x7244c3[_0x81c990] += msg.value;\n            CreatedToken(_0x81c990, _0x14b361);\n            if (_0x443869 >= _0x1a2025 && !_0x9d43e9) {\n                if (msg.sender != address(0) || msg.sender == address(0)) { _0x9d43e9 = true; }\n                FuelingToDate(_0x443869);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function _0xaacac5() _0xc6f04b {\n        if (_0x37c01f > _0x42441d && !_0x9d43e9) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (_0x628860.balance >= _0x628860._0x5af08d())\n                _0x628860._0x23074c(address(this), _0x628860._0x5af08d());\n\n            // Execute refund\n            if (msg.sender.call.value(_0x7244c3[msg.sender])()) {\n                Refund(msg.sender, _0x7244c3[msg.sender]);\n                _0x443869 -= _0xdd94a7[msg.sender];\n                _0xdd94a7[msg.sender] = 0;\n                _0x7244c3[msg.sender] = 0;\n            }\n        }\n    }\n\n    function _0xb6a70e() constant returns (uint _0xb6a70e) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (_0x42441d - 2 weeks > _0x37c01f) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (_0x42441d - 4 days > _0x37c01f) {\n            return (20 + (_0x37c01f - (_0x42441d - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant _0xacc5a1 = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant _0x2b3b5a = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant _0x3c5af7 = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant _0xb8a430 = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant _0x07dc43 = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant _0x0377ac = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant _0xb8b320 = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public _0x996d69;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public _0x96bf8e;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public _0xd828da;\n\n    // Address of the curator\n    address public _0x24939c;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public _0x291aee;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public _0x2d01c3;\n    // Total supply of rewardToken\n    uint public _0xf4aa7a;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public _0x3ff763;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public _0x969628;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public _0x18527c;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public _0xf22c15;\n\n    // the accumulated sum of all current proposal deposits\n    uint _0xa4e2fc;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public _0xe7d8b9;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address _0xa9a83f;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint _0xfc0f9f;\n        // A plain text description of the proposal\n        string _0x169875;\n        // A unix timestamp, denoting the end of the voting period\n        uint _0x325a30;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool _0x37f477;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool _0x4b4015;\n        // A hash to check validity of a proposal\n        bytes32 _0xd156f7;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint _0xf22c15;\n        // True if this proposal is to assign a new Curator\n        bool _0xbe0682;\n        // Data needed for splitting the DAO\n        SplitData[] _0x472a6d;\n        // Number of Tokens in favor of the proposal\n        uint _0x889e06;\n        // Number of Tokens opposed to the proposal\n        uint _0xe34ccd;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) _0x3d0cc8;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) _0x9d6db5;\n        // Address of the shareholder who created the proposal\n        address _0x7a0578;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint _0xd6fc4b;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint _0x443869;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint _0x2d01c3;\n        // The new DAO contract created at the time of split.\n        DAO _0x7b5108;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier _0xff24a6 {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool _0x67128b);\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function _0x3095af() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function _0x298ace(\n        address _0xe28eb3,\n        uint _0x91cc45,\n        string _0xf3a1ea,\n        bytes _0x039eaa,\n        uint _0x16c1c6,\n        bool _0xadff87\n    ) _0xff24a6 returns (uint _0xf8b8c5);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function _0x7ef678(\n        uint _0xf8b8c5,\n        address _0xe28eb3,\n        uint _0x91cc45,\n        bytes _0x039eaa\n    ) constant returns (bool _0xf7519a);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function _0x2740e7(\n        uint _0xf8b8c5,\n        bool _0x006f6f\n    ) _0xff24a6 returns (uint _0x0a55c2);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function _0x70fc6d(\n        uint _0xf8b8c5,\n        bytes _0x039eaa\n    ) returns (bool _0xe498bd);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function _0xfbb0a1(\n        uint _0xf8b8c5,\n        address _0xadff87\n    ) returns (bool _0xe498bd);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function _0x4bac90(address _0xb636b6);\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function _0x93d88d(address _0xe28eb3, bool _0x76b35f) external returns (bool _0xe498bd);\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function _0xb59321(uint _0xc6fcc9) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function _0x84c016(bool _0x303318) external returns (bool _0xe498bd);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function _0x9f2918() returns(bool _0xe498bd);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function _0x1f5b75(address _0x45ade4) internal returns (bool _0xe498bd);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function _0xb6fd3d(address _0x6cad2a, uint256 _0x91cc45) returns (bool _0x67128b);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function _0x0309db(\n        address _0xd0fe77,\n        address _0x6cad2a,\n        uint256 _0x91cc45\n    ) returns (bool _0x67128b);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function _0xc6c962() returns (bool _0xe498bd);\n\n    /// @return total number of proposals ever created\n    function _0x3f435b() constant returns (uint _0x1760fa);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function _0xd42df3(uint _0xf8b8c5) constant returns (address _0x98c960);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function _0xf1489d(address _0x45ade4) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function _0xd22089() returns (bool);\n\n    event ProposalAdded(\n        uint indexed _0x6b4c42,\n        address _0xa9a83f,\n        uint _0xfc0f9f,\n        bool _0xbe0682,\n        string _0x169875\n    );\n    event Voted(uint indexed _0x6b4c42, bool _0x18d326, address indexed _0xf45239);\n    event ProposalTallied(uint indexed _0x6b4c42, bool _0x43ea18, uint _0x9c0b1e);\n    event NewCurator(address indexed _0xadff87);\n    event AllowedRecipientChanged(address indexed _0xe28eb3, bool _0x76b35f);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier _0xff24a6 {\n        if (_0x531eea(msg.sender) == 0) throw;\n            _;\n    }\n\n    function DAO(\n        address _0xf115ea,\n        DAO_Creator _0xc959fa,\n        uint _0xc6fcc9,\n        uint _0xfe52ba,\n        uint _0xdbaa42,\n        address _0xb96e79\n    ) TokenCreation(_0xfe52ba, _0xdbaa42, _0xb96e79) {\n\n        _0x24939c = _0xf115ea;\n        _0xe7d8b9 = _0xc959fa;\n        _0xf22c15 = _0xc6fcc9;\n        _0x3ff763 = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(_0x3ff763) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        _0xd828da = _0x37c01f;\n        _0x96bf8e = 5; // sets the minimal quorum to 20%\n        _0x996d69.length = 1; // avoids a proposal with ID 0 because it is used\n\n        _0x291aee[address(this)] = true;\n        _0x291aee[_0x24939c] = true;\n    }\n\n    function () returns (bool _0x67128b) {\n        if (_0x37c01f < _0x42441d + _0xacc5a1 && msg.sender != address(_0x628860))\n            return _0xed4392(msg.sender);\n        else\n            return _0x3095af();\n    }\n\n    function _0x3095af() returns (bool) {\n        return true;\n    }\n\n    function _0x298ace(\n        address _0xe28eb3,\n        uint _0x91cc45,\n        string _0xf3a1ea,\n        bytes _0x039eaa,\n        uint _0x16c1c6,\n        bool _0xadff87\n    ) _0xff24a6 returns (uint _0xf8b8c5) {\n\n        // Sanity check\n        if (_0xadff87 && (\n            _0x91cc45 != 0\n            || _0x039eaa.length != 0\n            || _0xe28eb3 == _0x24939c\n            || msg.value > 0\n            || _0x16c1c6 < _0x3c5af7)) {\n            throw;\n        } else if (\n            !_0xadff87\n            && (!_0x0a3a41(_0xe28eb3) || (_0x16c1c6 <  _0x2b3b5a))\n        ) {\n            throw;\n        }\n\n        if (_0x16c1c6 > 8 weeks)\n            throw;\n\n        if (!_0x9d43e9\n            || _0x37c01f < _0x42441d\n            || (msg.value < _0xf22c15 && !_0xadff87)) {\n\n            throw;\n        }\n\n        if (_0x37c01f + _0x16c1c6 < _0x37c01f)\n            throw;\n\n        if (msg.sender == address(this))\n            throw;\n\n        _0xf8b8c5 = _0x996d69.length++;\n        Proposal p = _0x996d69[_0xf8b8c5];\n        p._0xa9a83f = _0xe28eb3;\n        p._0xfc0f9f = _0x91cc45;\n        p._0x169875 = _0xf3a1ea;\n        p._0xd156f7 = _0x506d5d(_0xe28eb3, _0x91cc45, _0x039eaa);\n        p._0x325a30 = _0x37c01f + _0x16c1c6;\n        p._0x37f477 = true;\n        //p.proposalPassed = False; // that's default\n        p._0xbe0682 = _0xadff87;\n        if (_0xadff87)\n            p._0x472a6d.length++;\n        p._0x7a0578 = msg.sender;\n        p._0xf22c15 = msg.value;\n\n        _0xa4e2fc += msg.value;\n\n        ProposalAdded(\n            _0xf8b8c5,\n            _0xe28eb3,\n            _0x91cc45,\n            _0xadff87,\n            _0xf3a1ea\n        );\n    }\n\n    function _0x7ef678(\n        uint _0xf8b8c5,\n        address _0xe28eb3,\n        uint _0x91cc45,\n        bytes _0x039eaa\n    ) _0xc6f04b constant returns (bool _0xf7519a) {\n        Proposal p = _0x996d69[_0xf8b8c5];\n        return p._0xd156f7 == _0x506d5d(_0xe28eb3, _0x91cc45, _0x039eaa);\n    }\n\n    function _0x2740e7(\n        uint _0xf8b8c5,\n        bool _0x006f6f\n    ) _0xff24a6 _0xc6f04b returns (uint _0x0a55c2) {\n\n        Proposal p = _0x996d69[_0xf8b8c5];\n        if (p._0x3d0cc8[msg.sender]\n            || p._0x9d6db5[msg.sender]\n            || _0x37c01f >= p._0x325a30) {\n\n            throw;\n        }\n\n        if (_0x006f6f) {\n            p._0x889e06 += _0xdd94a7[msg.sender];\n            p._0x3d0cc8[msg.sender] = true;\n        } else {\n            p._0xe34ccd += _0xdd94a7[msg.sender];\n            p._0x9d6db5[msg.sender] = true;\n        }\n\n        if (_0x18527c[msg.sender] == 0) {\n            _0x18527c[msg.sender] = _0xf8b8c5;\n        } else if (p._0x325a30 > _0x996d69[_0x18527c[msg.sender]]._0x325a30) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            _0x18527c[msg.sender] = _0xf8b8c5;\n        }\n\n        Voted(_0xf8b8c5, _0x006f6f, msg.sender);\n    }\n\n    function _0x70fc6d(\n        uint _0xf8b8c5,\n        bytes _0x039eaa\n    ) _0xc6f04b returns (bool _0xe498bd) {\n\n        Proposal p = _0x996d69[_0xf8b8c5];\n\n        uint _0x482ffb = p._0xbe0682\n            ? _0xb8a430\n            : _0x0377ac;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p._0x37f477 && _0x37c01f > p._0x325a30 + _0x482ffb) {\n            _0x8f3b63(_0xf8b8c5);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (_0x37c01f < p._0x325a30  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p._0x37f477\n            // Does the transaction code match the proposal?\n            || p._0xd156f7 != _0x506d5d(p._0xa9a83f, p._0xfc0f9f, _0x039eaa)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!_0x0a3a41(p._0xa9a83f)) {\n            _0x8f3b63(_0xf8b8c5);\n            p._0x7a0578.send(p._0xf22c15);\n            return;\n        }\n\n        bool _0x5171e0 = true;\n\n        if (p._0xfc0f9f > _0x7871dc())\n            _0x5171e0 = false;\n\n        uint _0x9c0b1e = p._0x889e06 + p._0xe34ccd;\n\n        // require 53% for calling newContract()\n        if (_0x039eaa.length >= 4 && _0x039eaa[0] == 0x68\n            && _0x039eaa[1] == 0x37 && _0x039eaa[2] == 0xff\n            && _0x039eaa[3] == 0x1e\n            && _0x9c0b1e < _0x062d2d(_0x7871dc() + _0x2d01c3[address(this)])) {\n\n                _0x5171e0 = false;\n        }\n\n        if (_0x9c0b1e >= _0x062d2d(p._0xfc0f9f)) {\n            if (!p._0x7a0578.send(p._0xf22c15))\n                throw;\n\n            _0xd828da = _0x37c01f;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (_0x9c0b1e > _0x443869 / 5)\n                _0x96bf8e = 5;\n        }\n\n        // Execute result\n        if (_0x9c0b1e >= _0x062d2d(p._0xfc0f9f) && p._0x889e06 > p._0xe34ccd && _0x5171e0) {\n            if (!p._0xa9a83f.call.value(p._0xfc0f9f)(_0x039eaa))\n                throw;\n\n            p._0x4b4015 = true;\n            _0xe498bd = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p._0xa9a83f != address(this) && p._0xa9a83f != address(_0x3ff763)\n                && p._0xa9a83f != address(DAOrewardAccount)\n                && p._0xa9a83f != address(_0x628860)\n                && p._0xa9a83f != address(_0x24939c)) {\n\n                _0x2d01c3[address(this)] += p._0xfc0f9f;\n                _0xf4aa7a += p._0xfc0f9f;\n            }\n        }\n\n        _0x8f3b63(_0xf8b8c5);\n\n        // Initiate event\n        ProposalTallied(_0xf8b8c5, _0xe498bd, _0x9c0b1e);\n    }\n\n    function _0x8f3b63(uint _0xf8b8c5) internal {\n        Proposal p = _0x996d69[_0xf8b8c5];\n        if (p._0x37f477)\n            _0xa4e2fc -= p._0xf22c15;\n        p._0x37f477 = false;\n    }\n\n    function _0xfbb0a1(\n        uint _0xf8b8c5,\n        address _0xadff87\n    ) _0xc6f04b _0xff24a6 returns (bool _0xe498bd) {\n\n        Proposal p = _0x996d69[_0xf8b8c5];\n\n        // Sanity check\n\n        if (_0x37c01f < p._0x325a30  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || _0x37c01f > p._0x325a30 + _0xb8a430\n            // Does the new Curator address match?\n            || p._0xa9a83f != _0xadff87\n            // Is it a new curator proposal?\n            || !p._0xbe0682\n            // Have you voted for this split?\n            || !p._0x3d0cc8[msg.sender]\n            // Did you already vote on another proposal?\n            || (_0x18527c[msg.sender] != _0xf8b8c5 && _0x18527c[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p._0x472a6d[0]._0x7b5108) == 0) {\n            p._0x472a6d[0]._0x7b5108 = _0x7e7e59(_0xadff87);\n            // Call depth limit reached, etc.\n            if (address(p._0x472a6d[0]._0x7b5108) == 0)\n                throw;\n            // should never happen\n            if (this.balance < _0xa4e2fc)\n                throw;\n            p._0x472a6d[0]._0xd6fc4b = _0x7871dc();\n            p._0x472a6d[0]._0x2d01c3 = _0x2d01c3[address(this)];\n            p._0x472a6d[0]._0x443869 = _0x443869;\n            p._0x4b4015 = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint _0x0c4235 =\n            (_0xdd94a7[msg.sender] * p._0x472a6d[0]._0xd6fc4b) /\n            p._0x472a6d[0]._0x443869;\n        if (p._0x472a6d[0]._0x7b5108._0xed4392.value(_0x0c4235)(msg.sender) == false)\n            throw;\n\n        // Assign reward rights to new DAO\n        uint _0x4dd430 =\n            (_0xdd94a7[msg.sender] * p._0x472a6d[0]._0x2d01c3) /\n            p._0x472a6d[0]._0x443869;\n\n        uint _0xf65909 = DAOpaidOut[address(this)] * _0x4dd430 /\n            _0x2d01c3[address(this)];\n\n        _0x2d01c3[address(p._0x472a6d[0]._0x7b5108)] += _0x4dd430;\n        if (_0x2d01c3[address(this)] < _0x4dd430)\n            throw;\n        _0x2d01c3[address(this)] -= _0x4dd430;\n\n        DAOpaidOut[address(p._0x472a6d[0]._0x7b5108)] += _0xf65909;\n        if (DAOpaidOut[address(this)] < _0xf65909)\n            throw;\n        DAOpaidOut[address(this)] -= _0xf65909;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, _0xdd94a7[msg.sender]);\n        _0x1f5b75(msg.sender); // be nice, and get his rewards\n        _0x443869 -= _0xdd94a7[msg.sender];\n        _0xdd94a7[msg.sender] = 0;\n        _0x969628[msg.sender] = 0;\n        return true;\n    }\n\n    function _0x4bac90(address _0xb636b6){\n        if (msg.sender != address(this) || !_0x291aee[_0xb636b6]) return;\n        // move all ether\n        if (!_0xb636b6.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        _0x2d01c3[_0xb636b6] += _0x2d01c3[address(this)];\n        _0x2d01c3[address(this)] = 0;\n        DAOpaidOut[_0xb636b6] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n    function _0x84c016(bool _0x303318) external _0xc6f04b returns (bool _0xe498bd) {\n        DAO _0x77e276 = DAO(msg.sender);\n\n        if ((_0x2d01c3[msg.sender] * DAOrewardAccount._0x5af08d()) /\n            _0xf4aa7a < DAOpaidOut[msg.sender])\n            throw;\n\n        uint _0x9e1932 =\n            (_0x2d01c3[msg.sender] * DAOrewardAccount._0x5af08d()) /\n            _0xf4aa7a - DAOpaidOut[msg.sender];\n        if(_0x303318) {\n            if (!DAOrewardAccount._0x23074c(_0x77e276._0x3ff763(), _0x9e1932))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount._0x23074c(_0x77e276, _0x9e1932))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += _0x9e1932;\n        return true;\n    }\n\n    function _0x9f2918() _0xc6f04b returns (bool _0xe498bd) {\n        return _0x1f5b75(msg.sender);\n    }\n\n    function _0x1f5b75(address _0x45ade4) _0xc6f04b internal returns (bool _0xe498bd) {\n        if ((_0x531eea(_0x45ade4) * _0x3ff763._0x5af08d()) / _0x443869 < _0x969628[_0x45ade4])\n            throw;\n\n        uint _0x9e1932 =\n            (_0x531eea(_0x45ade4) * _0x3ff763._0x5af08d()) / _0x443869 - _0x969628[_0x45ade4];\n        if (!_0x3ff763._0x23074c(_0x45ade4, _0x9e1932))\n            throw;\n        _0x969628[_0x45ade4] += _0x9e1932;\n        return true;\n    }\n\n    function transfer(address _0x6cad2a, uint256 _0xc4c422) returns (bool _0x67128b) {\n        if (_0x9d43e9\n            && _0x37c01f > _0x42441d\n            && !_0xf1489d(msg.sender)\n            && _0xc8db17(msg.sender, _0x6cad2a, _0xc4c422)\n            && super.transfer(_0x6cad2a, _0xc4c422)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n    function _0xb6fd3d(address _0x6cad2a, uint256 _0xc4c422) returns (bool _0x67128b) {\n        if (!_0x9f2918())\n            throw;\n        return transfer(_0x6cad2a, _0xc4c422);\n    }\n\n    function _0xe1f49f(address _0xd0fe77, address _0x6cad2a, uint256 _0xc4c422) returns (bool _0x67128b) {\n        if (_0x9d43e9\n            && _0x37c01f > _0x42441d\n            && !_0xf1489d(_0xd0fe77)\n            && _0xc8db17(_0xd0fe77, _0x6cad2a, _0xc4c422)\n            && super._0xe1f49f(_0xd0fe77, _0x6cad2a, _0xc4c422)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n    function _0x0309db(\n        address _0xd0fe77,\n        address _0x6cad2a,\n        uint256 _0xc4c422\n    ) returns (bool _0x67128b) {\n\n        if (!_0x1f5b75(_0xd0fe77))\n            throw;\n        return _0xe1f49f(_0xd0fe77, _0x6cad2a, _0xc4c422);\n    }\n\n    function _0xc8db17(\n        address _0xd0fe77,\n        address _0x6cad2a,\n        uint256 _0xc4c422\n    ) internal returns (bool _0x67128b) {\n\n        uint _0xc8db17 = _0x969628[_0xd0fe77] * _0xc4c422 / _0x531eea(_0xd0fe77);\n        if (_0xc8db17 > _0x969628[_0xd0fe77])\n            throw;\n        _0x969628[_0xd0fe77] -= _0xc8db17;\n        _0x969628[_0x6cad2a] += _0xc8db17;\n        return true;\n    }\n\n    function _0xb59321(uint _0xc6fcc9) _0xc6f04b external {\n        if (msg.sender != address(this) || _0xc6fcc9 > (_0x7871dc() + _0x2d01c3[address(this)])\n            / _0xb8b320) {\n\n            throw;\n        }\n        _0xf22c15 = _0xc6fcc9;\n    }\n\n    function _0x93d88d(address _0xe28eb3, bool _0x76b35f) _0xc6f04b external returns (bool _0xe498bd) {\n        if (msg.sender != _0x24939c)\n            throw;\n        _0x291aee[_0xe28eb3] = _0x76b35f;\n        AllowedRecipientChanged(_0xe28eb3, _0x76b35f);\n        return true;\n    }\n\n    function _0x0a3a41(address _0xe28eb3) internal returns (bool _0x46d551) {\n        if (_0x291aee[_0xe28eb3]\n            || (_0xe28eb3 == address(_0x628860)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && _0xf4aa7a > _0x628860._0x5af08d()))\n            return true;\n        else\n            return false;\n    }\n\n    function _0x7871dc() constant returns (uint _0x31d8c1) {\n        return this.balance - _0xa4e2fc;\n    }\n\n    function _0x062d2d(uint _0xc4c422) internal constant returns (uint _0x79d07a) {\n        // minimum of 20% and maximum of 53.33%\n        return _0x443869 / _0x96bf8e +\n            (_0xc4c422 * _0x443869) / (3 * (_0x7871dc() + _0x2d01c3[address(this)]));\n    }\n\n    function _0xc6c962() returns (bool _0xe498bd) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((_0xd828da < (_0x37c01f - _0x07dc43) || msg.sender == _0x24939c)\n            && _0xd828da < (_0x37c01f - _0x2b3b5a)) {\n            _0xd828da = _0x37c01f;\n            _0x96bf8e *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _0x7e7e59(address _0xadff87) internal returns (DAO _0x98c960) {\n        NewCurator(_0xadff87);\n        return _0xe7d8b9._0x4822e6(_0xadff87, 0, 0, _0x37c01f + _0xb8a430);\n    }\n\n    function _0x3f435b() constant returns (uint _0x1760fa) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return _0x996d69.length - 1;\n    }\n\n    function _0xd42df3(uint _0xf8b8c5) constant returns (address _0x98c960) {\n        return _0x996d69[_0xf8b8c5]._0x472a6d[0]._0x7b5108;\n    }\n\n    function _0xf1489d(address _0x45ade4) internal returns (bool) {\n        if (_0x18527c[_0x45ade4] == 0)\n            return false;\n        Proposal p = _0x996d69[_0x18527c[_0x45ade4]];\n        if (_0x37c01f > p._0x325a30) {\n            _0x18527c[_0x45ade4] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function _0xd22089() returns (bool) {\n        return _0xf1489d(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function _0x4822e6(\n        address _0xf115ea,\n        uint _0xc6fcc9,\n        uint _0xfe52ba,\n        uint _0xdbaa42\n    ) returns (DAO _0x98c960) {\n\n        return new DAO(\n            _0xf115ea,\n            DAO_Creator(this),\n            _0xc6fcc9,\n            _0xfe52ba,\n            _0xdbaa42,\n            msg.sender\n        );\n    }\n}\n",
      "rename_map": {
        "transferFromWithoutReward": "_0x0309db",
        "changeAllowedRecipients": "_0x93d88d",
        "minProposalDebatePeriod": "_0x2b3b5a",
        "transferWithoutReward": "_0xb6fd3d",
        "sumOfProposalDeposits": "_0xa4e2fc",
        "changeProposalDeposit": "_0xb59321",
        "executeProposalPeriod": "_0x0377ac",
        "minSplitDebatePeriod": "_0x3c5af7",
        "splitExecutionPeriod": "_0xb8a430",
        "lastTimeMinQuorumMet": "_0xd828da",
        "rewardTokenToBeMoved": "_0x4dd430",
        "quorumHalvingPeriod": "_0x07dc43",
        "creationGracePeriod": "_0xacc5a1",
        "_minTokensToCreate": "_0xfe52ba",
        "isRecipientAllowed": "_0x0a3a41",
        "_numberOfProposals": "_0x1760fa",
        "numberOfProposals": "_0x3f435b",
        "allowedRecipients": "_0x291aee",
        "retrieveDAOReward": "_0x84c016",
        "checkProposalCode": "_0x7ef678",
        "_supportsProposal": "_0x006f6f",
        "withdrawRewardFor": "_0x1f5b75",
        "maxDepositDivisor": "_0xb8b320",
        "minTokensToCreate": "_0x1a2025",
        "onlyTokenholders": "_0xff24a6",
        "paidOutToBeMoved": "_0xf65909",
        "getNewDAOAddress": "_0xd42df3",
        "_privateCreation": "_0xb96e79",
        "_transactionData": "_0x039eaa",
        "minQuorumDivisor": "_0x96bf8e",
        "_proposalDeposit": "_0xc6fcc9",
        "accumulatedInput": "_0x5af08d",
        "createTokenProxy": "_0xed4392",
        "totalRewardToken": "_0xf4aa7a",
        "executeProposal": "_0x70fc6d",
        "privateCreation": "_0x57f4a9",
        "transferPaidOut": "_0xc8db17",
        "proposalDeposit": "_0xf22c15",
        "_debatingPeriod": "_0x16c1c6",
        "halveMinQuorum": "_0xc6c962",
        "_actualBalance": "_0x31d8c1",
        "votingDeadline": "_0x325a30",
        "_codeChecksOut": "_0xf7519a",
        "proposalPassed": "_0x4b4015",
        "fundsToBeMoved": "_0x0c4235",
        "actualBalance": "_0x7871dc",
        "_payOwnerOnly": "_0x8c0b13",
        "proposalCheck": "_0x5171e0",
        "rewardAccount": "_0x3ff763",
        "closeProposal": "_0x8f3b63",
        "_description": "_0xf3a1ea",
        "splitBalance": "_0xd6fc4b",
        "transferFrom": "_0xe1f49f",
        "_closingTime": "_0xdbaa42",
        "_tokenHolder": "_0x81c990",
        "proposalHash": "_0xd156f7",
        "payOwnerOnly": "_0x957040",
        "createNewDAO": "_0x7e7e59",
        "extraBalance": "_0x628860",
        "_newContract": "_0xb636b6",
        "receiveEther": "_0x3095af",
        "_newCurator": "_0xadff87",
        "newProposal": "_0x298ace",
        "getMyReward": "_0x9f2918",
        "description": "_0x169875",
        "_proposalID": "_0xf8b8c5",
        "rewardToken": "_0x2d01c3",
        "totalSupply": "_0x443869",
        "closingTime": "_0x42441d",
        "_daoCreator": "_0xc959fa",
        "newContract": "_0x4bac90",
        "proposalID": "_0x6b4c42",
        "_isAllowed": "_0x46d551",
        "waitPeriod": "_0x482ffb",
        "_toMembers": "_0x303318",
        "daoCreator": "_0xe7d8b9",
        "newCurator": "_0xbe0682",
        "_minQuorum": "_0x79d07a",
        "_recipient": "_0xe28eb3",
        "balanceOf": "_0x531eea",
        "minQuorum": "_0x062d2d",
        "proposals": "_0x996d69",
        "createDAO": "_0x4822e6",
        "unblockMe": "_0xd22089",
        "isBlocked": "_0xf1489d",
        "recipient": "_0xa9a83f",
        "splitData": "_0x472a6d",
        "remaining": "_0x450c8e",
        "allowance": "_0x59f101",
        "splitDAO": "_0xfbb0a1",
        "position": "_0x18d326",
        "_spender": "_0xeb66c6",
        "votedYes": "_0x3d0cc8",
        "_account": "_0x45ade4",
        "_curator": "_0xf115ea",
        "weiGiven": "_0x7244c3",
        "isFueled": "_0x9d43e9",
        "_allowed": "_0x76b35f",
        "balances": "_0xdd94a7",
        "_success": "_0xe498bd",
        "_amount": "_0x91cc45",
        "_newDAO": "_0x98c960",
        "approve": "_0x671a0b",
        "curator": "_0x24939c",
        "blocked": "_0x18527c",
        "paidOut": "_0x969628",
        "allowed": "_0x164afe",
        "divisor": "_0xb6a70e",
        "success": "_0x67128b",
        "votedNo": "_0x9d6db5",
        "creator": "_0x7a0578",
        "noEther": "_0xc6f04b",
        "_voteID": "_0x0a55c2",
        "quorum": "_0x9c0b1e",
        "_value": "_0xc4c422",
        "_owner": "_0x2fd574",
        "payOut": "_0x23074c",
        "newDAO": "_0x7b5108",
        "result": "_0x43ea18",
        "reward": "_0x9e1932",
        "amount": "_0xfc0f9f",
        "refund": "_0xaacac5",
        "token": "_0x14b361",
        "voter": "_0xf45239",
        "owner": "_0x50695d",
        "_from": "_0xd0fe77",
        "open": "_0x37f477",
        "sha3": "_0x506d5d",
        "vote": "_0x2740e7",
        "yea": "_0x889e06",
        "dao": "_0x77e276",
        "now": "_0x37c01f",
        "_to": "_0x6cad2a",
        "nay": "_0xe34ccd",
        "to": "_0x052b0d"
      },
      "changes": [
        "Renamed 135 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_114",
      "transformed_id": "ss_l3_medium_sn_ds_114",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// https://etherscan.io/address/0xf91546835f756da0c10cfa0cda95b15577b84aa7#code\n\npragma solidity ^0.4.23;\n// produced by the Solididy File Flattener (c) David Appleton 2018\n// contact : dave@akomba.com\n// released under Apache 2.0 licence\ncontract Token {\n    /// total amount of tokens\n    uint256 public _0x19498a;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function _0x160aff(address _0x667af1) public constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _0xfb1fbd, uint256 _0x76267c) public returns (bool _0x201dff);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function _0x46dddc(address _0x6489fe, address _0xfb1fbd, uint256 _0x76267c) public returns (bool _0x201dff);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function _0x010c65(address _0x2da78a, uint256 _0x76267c) public returns (bool _0x201dff);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function _0x0ff64a(address _0x667af1, address _0x2da78a) public constant returns (uint256 _0xc757e9);\n\n    event Transfer(address indexed _0x6489fe, address indexed _0xfb1fbd, uint256 _0x76267c);\n    event Approval(address indexed _0x667af1, address indexed _0x2da78a, uint256 _0x76267c);\n}\n\nlibrary ECTools {\n\n    // @dev Recovers the address which has signed a message\n    // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n    function _0x8e3fe7(bytes32 _0xf2c0e0, string _0xa856dd) public pure returns (address) {\n        require(_0xf2c0e0 != 0x00);\n\n        // need this for test RPC\n        bytes memory _0xd4ca4d = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 _0x866396 = _0xb2df79(abi._0x9a8676(_0xd4ca4d, _0xf2c0e0));\n\n        if (bytes(_0xa856dd).length != 132) {\n            return 0x0;\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        bytes memory sig = _0x800c21(_0xd1ce23(_0xa856dd, 2, 132));\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27) {\n            v += 27;\n        }\n        if (v < 27 || v > 28) {\n            return 0x0;\n        }\n        return _0x78b618(_0x866396, v, r, s);\n    }\n\n    // @dev Verifies if the message is signed by an address\n    function _0x54da17(bytes32 _0xf2c0e0, string _0xa856dd, address _0x5273d9) public pure returns (bool) {\n        require(_0x5273d9 != 0x0);\n\n        return _0x5273d9 == _0x8e3fe7(_0xf2c0e0, _0xa856dd);\n    }\n\n    // @dev Converts an hexstring to bytes\n    function _0x800c21(string _0x49c651) public pure returns (bytes) {\n        uint _0xd8b81d = bytes(_0x49c651).length;\n        require(_0xd8b81d % 2 == 0);\n\n        bytes memory _0xd26905 = bytes(new string(_0xd8b81d / 2));\n        uint k = 0;\n        string memory s;\n        string memory r;\n        for (uint i = 0; i < _0xd8b81d; i += 2) {\n            s = _0xd1ce23(_0x49c651, i, i + 1);\n            r = _0xd1ce23(_0x49c651, i + 1, i + 2);\n            uint p = _0xb922a8(s) * 16 + _0xb922a8(r);\n            _0xd26905[k++] = _0xf17e3b(p)[31];\n        }\n        return _0xd26905;\n    }\n\n    // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n    function _0xb922a8(string _0x04dccd) public pure returns (uint) {\n        bytes memory _0xcd3d7f = bytes(_0x04dccd);\n        // bool decimals = false;\n        if ((_0xcd3d7f[0] >= 48) && (_0xcd3d7f[0] <= 57)) {\n            return uint(_0xcd3d7f[0]) - 48;\n        } else if ((_0xcd3d7f[0] >= 65) && (_0xcd3d7f[0] <= 70)) {\n            return uint(_0xcd3d7f[0]) - 55;\n        } else if ((_0xcd3d7f[0] >= 97) && (_0xcd3d7f[0] <= 102)) {\n            return uint(_0xcd3d7f[0]) - 87;\n        } else {\n            revert();\n        }\n    }\n\n    // @dev Converts a uint to a bytes32\n    // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n    function _0xf17e3b(uint _0x153e34) public pure returns (bytes b) {\n        b = new bytes(32);\n        assembly {mstore(add(b, 32), _0x153e34)}\n    }\n\n    // @dev Hashes the signed message\n    // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n    function _0xf0c1b9(string _0xb54040) public pure returns (bytes32) {\n        uint _0xd8b81d = bytes(_0xb54040).length;\n        require(_0xd8b81d > 0);\n        bytes memory _0xd4ca4d = \"\\x19Ethereum Signed Message:\\n\";\n        return _0xb2df79(abi._0x9a8676(_0xd4ca4d, _0x39e7d6(_0xd8b81d), _0xb54040));\n    }\n\n    // @dev Converts a uint in a string\n    function _0x39e7d6(uint _0x153e34) public pure returns (string _0xf7adec) {\n        uint _0xd8b81d = 0;\n        uint m = _0x153e34 + 0;\n        while (m != 0) {\n            _0xd8b81d++;\n            m /= 10;\n        }\n        bytes memory b = new bytes(_0xd8b81d);\n        uint i = _0xd8b81d - 1;\n        while (_0x153e34 != 0) {\n            uint _0xf1c42f = _0x153e34 % 10;\n            _0x153e34 = _0x153e34 / 10;\n            b[i--] = byte(48 + _0xf1c42f);\n        }\n        _0xf7adec = string(b);\n    }\n\n    // @dev extract a substring\n    // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n    function _0xd1ce23(string _0xf21925, uint _0x4c9e98, uint _0x0884ec) public pure returns (string) {\n        bytes memory _0x8791be = bytes(_0xf21925);\n        require(_0x4c9e98 <= _0x0884ec);\n        require(_0x4c9e98 >= 0);\n        require(_0x0884ec <= _0x8791be.length);\n\n        bytes memory _0xc2cae0 = new bytes(_0x0884ec - _0x4c9e98);\n        for (uint i = _0x4c9e98; i < _0x0884ec; i++) {\n            _0xc2cae0[i - _0x4c9e98] = _0x8791be[i];\n        }\n        return string(_0xc2cae0);\n    }\n}\ncontract StandardToken is Token {\n\n    function transfer(address _0xfb1fbd, uint256 _0x76267c) public returns (bool _0x201dff) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0xf148c1[msg.sender] >= _0x76267c);\n        _0xf148c1[msg.sender] -= _0x76267c;\n        _0xf148c1[_0xfb1fbd] += _0x76267c;\n        emit Transfer(msg.sender, _0xfb1fbd, _0x76267c);\n        return true;\n    }\n\n    function _0x46dddc(address _0x6489fe, address _0xfb1fbd, uint256 _0x76267c) public returns (bool _0x201dff) {\n\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0xf148c1[_0x6489fe] >= _0x76267c && _0xd810dc[_0x6489fe][msg.sender] >= _0x76267c);\n        _0xf148c1[_0xfb1fbd] += _0x76267c;\n        _0xf148c1[_0x6489fe] -= _0x76267c;\n        _0xd810dc[_0x6489fe][msg.sender] -= _0x76267c;\n        emit Transfer(_0x6489fe, _0xfb1fbd, _0x76267c);\n        return true;\n    }\n\n    function _0x160aff(address _0x667af1) public constant returns (uint256 balance) {\n        return _0xf148c1[_0x667af1];\n    }\n\n    function _0x010c65(address _0x2da78a, uint256 _0x76267c) public returns (bool _0x201dff) {\n        _0xd810dc[msg.sender][_0x2da78a] = _0x76267c;\n        emit Approval(msg.sender, _0x2da78a, _0x76267c);\n        return true;\n    }\n\n    function _0x0ff64a(address _0x667af1, address _0x2da78a) public constant returns (uint256 _0xc757e9) {\n      return _0xd810dc[_0x667af1][_0x2da78a];\n    }\n\n    mapping (address => uint256) _0xf148c1;\n    mapping (address => mapping (address => uint256)) _0xd810dc;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n    /* Public variables of the token */\n\n    string public _0xe6b820;                   //fancy name: eg Simon Bucks\n    uint8 public _0x1faf73;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n    string public _0x7c1776;                 //An identifier: eg SBX\n    string public _0xe90d6a = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n    constructor(\n        uint256 _0xe8c0a3,\n        string _0x7426b2,\n        uint8 _0x47b371,\n        string _0x577442\n        ) public {\n        _0xf148c1[msg.sender] = _0xe8c0a3;               // Give the creator all initial tokens\n        _0x19498a = _0xe8c0a3;                        // Update total supply\n        _0xe6b820 = _0x7426b2;                                   // Set the name for display purposes\n        _0x1faf73 = _0x47b371;                            // Amount of decimals for display purposes\n        _0x7c1776 = _0x577442;                               // Set the symbol for display purposes\n    }\n\n    /* Approves and then calls the receiving contract */\n    function _0xc3c60a(address _0x2da78a, uint256 _0x76267c, bytes _0xd901db) public returns (bool _0x201dff) {\n        _0xd810dc[msg.sender][_0x2da78a] = _0x76267c;\n        emit Approval(msg.sender, _0x2da78a, _0x76267c);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        require(_0x2da78a.call(bytes4(bytes32(_0xb2df79(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _0x76267c, this, _0xd901db));\n        return true;\n    }\n}\n\ncontract LedgerChannel {\n\n    string public constant NAME = \"Ledger Channel\";\n    string public constant VERSION = \"0.0.1\";\n\n    uint256 public _0x3a8ee9 = 0;\n\n    event DidLCOpen (\n        bytes32 indexed _0xd35e8d,\n        address indexed _0x1b04b5,\n        address indexed _0xbf5fdf,\n        uint256 _0xe06e29,\n        address _0xc646b7,\n        uint256 _0xa33970,\n        uint256 LCopenTimeout\n    );\n\n    event DidLCJoin (\n        bytes32 indexed _0xd35e8d,\n        uint256 _0xa42391,\n        uint256 _0x41c10c\n    );\n\n    event DidLCDeposit (\n        bytes32 indexed _0xd35e8d,\n        address indexed _0xcfcbcc,\n        uint256 _0x68628a,\n        bool _0xd29b0e\n    );\n\n    event DidLCUpdateState (\n        bytes32 indexed _0xd35e8d,\n        uint256 _0x9c7bcc,\n        uint256 _0x5e690c,\n        uint256 _0xe06e29,\n        uint256 _0xa33970,\n        uint256 _0xa42391,\n        uint256 _0x41c10c,\n        bytes32 _0x34c4b4,\n        uint256 _0xbfdb0a\n    );\n\n    event DidLCClose (\n        bytes32 indexed _0xd35e8d,\n        uint256 _0x9c7bcc,\n        uint256 _0xe06e29,\n        uint256 _0xa33970,\n        uint256 _0xa42391,\n        uint256 _0x41c10c\n    );\n\n    event DidVCInit (\n        bytes32 indexed _0x67bc72,\n        bytes32 indexed _0x03dc2d,\n        bytes _0x105ee2,\n        uint256 _0x9c7bcc,\n        address _0x1b04b5,\n        address _0x16510a,\n        uint256 _0x003c12,\n        uint256 _0x223db2\n    );\n\n    event DidVCSettle (\n        bytes32 indexed _0x67bc72,\n        bytes32 indexed _0x03dc2d,\n        uint256 _0xd23a28,\n        uint256 _0x0b3f7e,\n        uint256 _0xe6cb3a,\n        address _0x352239,\n        uint256 _0x786364\n    );\n\n    event DidVCClose(\n        bytes32 indexed _0x67bc72,\n        bytes32 indexed _0x03dc2d,\n        uint256 _0x003c12,\n        uint256 _0x223db2\n    );\n\n    struct Channel {\n        //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n        address[2] _0xd78819; // 0: partyA 1: partyI\n        uint256[4] _0x5b28f8; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n        uint256[4] _0x444b7a; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n        uint256[2] _0xd76205; // 0: eth 1: tokens\n        uint256 _0x9c7bcc;\n        uint256 _0x9ae645;\n        bytes32 VCrootHash;\n        uint256 LCopenTimeout;\n        uint256 _0xbfdb0a; // when update LC times out\n        bool _0x858abd; // true when both parties have joined\n        bool _0x4fa389;\n        uint256 _0x4acd9d;\n        HumanStandardToken _0xc646b7;\n    }\n\n    // virtual-channel state\n    struct VirtualChannel {\n        bool _0x5cf332;\n        bool _0xfadcdb;\n        uint256 _0x9c7bcc;\n        address _0x352239; // Initiator of challenge\n        uint256 _0x786364; // when update VC times out\n        // channel state\n        address _0x1b04b5; // VC participant A\n        address _0x16510a; // VC participant B\n        address _0xbf5fdf; // LC hub\n        uint256[2] _0x5b28f8;\n        uint256[2] _0x444b7a;\n        uint256[2] _0x7a81e2;\n        HumanStandardToken _0xc646b7;\n    }\n\n    mapping(bytes32 => VirtualChannel) public _0xc6fbd7;\n    mapping(bytes32 => Channel) public Channels;\n\n    function _0xa518bf(\n        bytes32 _0xd5eca6,\n        address _0xf62d96,\n        uint256 _0x461630,\n        address _0xc08dd5,\n        uint256[2] _0xd2ceb2 // [eth, token]\n    )\n        public\n        payable\n    {\n        require(Channels[_0xd5eca6]._0xd78819[0] == address(0), \"Channel has already been created.\");\n        require(_0xf62d96 != 0x0, \"No partyI address provided to LC creation\");\n        require(_0xd2ceb2[0] >= 0 && _0xd2ceb2[1] >= 0, \"Balances cannot be negative\");\n        // Set initial ledger channel state\n        // Alice must execute this and we assume the initial state\n        // to be signed from this requirement\n        // Alternative is to check a sig as in joinChannel\n        Channels[_0xd5eca6]._0xd78819[0] = msg.sender;\n        Channels[_0xd5eca6]._0xd78819[1] = _0xf62d96;\n\n        if(_0xd2ceb2[0] != 0) {\n            require(msg.value == _0xd2ceb2[0], \"Eth balance does not match sent value\");\n            Channels[_0xd5eca6]._0x5b28f8[0] = msg.value;\n        }\n        if(_0xd2ceb2[1] != 0) {\n            Channels[_0xd5eca6]._0xc646b7 = HumanStandardToken(_0xc08dd5);\n            require(Channels[_0xd5eca6]._0xc646b7._0x46dddc(msg.sender, this, _0xd2ceb2[1]),\"CreateChannel: token transfer failure\");\n            Channels[_0xd5eca6]._0x444b7a[0] = _0xd2ceb2[1];\n        }\n\n        Channels[_0xd5eca6]._0x9c7bcc = 0;\n        Channels[_0xd5eca6]._0x9ae645 = _0x461630;\n        // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n        //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n        Channels[_0xd5eca6].LCopenTimeout = _0x4ec2c9 + _0x461630;\n        Channels[_0xd5eca6]._0xd76205 = _0xd2ceb2;\n\n        emit DidLCOpen(_0xd5eca6, msg.sender, _0xf62d96, _0xd2ceb2[0], _0xc08dd5, _0xd2ceb2[1], Channels[_0xd5eca6].LCopenTimeout);\n    }\n\n    function LCOpenTimeout(bytes32 _0xd5eca6) public {\n        require(msg.sender == Channels[_0xd5eca6]._0xd78819[0] && Channels[_0xd5eca6]._0x858abd == false);\n        require(_0x4ec2c9 > Channels[_0xd5eca6].LCopenTimeout);\n\n        if(Channels[_0xd5eca6]._0xd76205[0] != 0) {\n            Channels[_0xd5eca6]._0xd78819[0].transfer(Channels[_0xd5eca6]._0x5b28f8[0]);\n        }\n        if(Channels[_0xd5eca6]._0xd76205[1] != 0) {\n            require(Channels[_0xd5eca6]._0xc646b7.transfer(Channels[_0xd5eca6]._0xd78819[0], Channels[_0xd5eca6]._0x444b7a[0]),\"CreateChannel: token transfer failure\");\n        }\n\n        emit DidLCClose(_0xd5eca6, 0, Channels[_0xd5eca6]._0x5b28f8[0], Channels[_0xd5eca6]._0x444b7a[0], 0, 0);\n\n        // only safe to delete since no action was taken on this channel\n        delete Channels[_0xd5eca6];\n    }\n\n    function _0x2f0d03(bytes32 _0xd5eca6, uint256[2] _0xd2ceb2) public payable {\n        // require the channel is not open yet\n        require(Channels[_0xd5eca6]._0x858abd == false);\n        require(msg.sender == Channels[_0xd5eca6]._0xd78819[1]);\n\n        if(_0xd2ceb2[0] != 0) {\n            require(msg.value == _0xd2ceb2[0], \"state balance does not match sent value\");\n            Channels[_0xd5eca6]._0x5b28f8[1] = msg.value;\n        }\n        if(_0xd2ceb2[1] != 0) {\n            require(Channels[_0xd5eca6]._0xc646b7._0x46dddc(msg.sender, this, _0xd2ceb2[1]),\"joinChannel: token transfer failure\");\n            Channels[_0xd5eca6]._0x444b7a[1] = _0xd2ceb2[1];\n        }\n\n        Channels[_0xd5eca6]._0xd76205[0]+=_0xd2ceb2[0];\n        Channels[_0xd5eca6]._0xd76205[1]+=_0xd2ceb2[1];\n        // no longer allow joining functions to be called\n        Channels[_0xd5eca6]._0x858abd = true;\n        _0x3a8ee9++;\n\n        emit DidLCJoin(_0xd5eca6, _0xd2ceb2[0], _0xd2ceb2[1]);\n    }\n\n    // additive updates of monetary state\n    function _0x68628a(bytes32 _0xd5eca6, address _0xcfcbcc, uint256 _0xaaefda, bool _0xd29b0e) public payable {\n        require(Channels[_0xd5eca6]._0x858abd == true, \"Tried adding funds to a closed channel\");\n        require(_0xcfcbcc == Channels[_0xd5eca6]._0xd78819[0] || _0xcfcbcc == Channels[_0xd5eca6]._0xd78819[1]);\n\n        //if(Channels[_lcID].token)\n\n        if (Channels[_0xd5eca6]._0xd78819[0] == _0xcfcbcc) {\n            if(_0xd29b0e) {\n                require(Channels[_0xd5eca6]._0xc646b7._0x46dddc(msg.sender, this, _0xaaefda),\"deposit: token transfer failure\");\n                Channels[_0xd5eca6]._0x444b7a[2] += _0xaaefda;\n            } else {\n                require(msg.value == _0xaaefda, \"state balance does not match sent value\");\n                Channels[_0xd5eca6]._0x5b28f8[2] += msg.value;\n            }\n        }\n\n        if (Channels[_0xd5eca6]._0xd78819[1] == _0xcfcbcc) {\n            if(_0xd29b0e) {\n                require(Channels[_0xd5eca6]._0xc646b7._0x46dddc(msg.sender, this, _0xaaefda),\"deposit: token transfer failure\");\n                Channels[_0xd5eca6]._0x444b7a[3] += _0xaaefda;\n            } else {\n                require(msg.value == _0xaaefda, \"state balance does not match sent value\");\n                Channels[_0xd5eca6]._0x5b28f8[3] += msg.value;\n            }\n        }\n\n        emit DidLCDeposit(_0xd5eca6, _0xcfcbcc, _0xaaefda, _0xd29b0e);\n    }\n\n    // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n    function _0x9fc16b(\n        bytes32 _0xd5eca6,\n        uint256 _0x9a238a,\n        uint256[4] _0xd2ceb2, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n        string _0xc7e852,\n        string _0xce92a2\n    )\n        public\n    {\n        // assume num open vc is 0 and root hash is 0x0\n        //require(Channels[_lcID].sequence < _sequence);\n        require(Channels[_0xd5eca6]._0x858abd == true);\n        uint256 _0xe9ff68 = Channels[_0xd5eca6]._0xd76205[0] + Channels[_0xd5eca6]._0x5b28f8[2] + Channels[_0xd5eca6]._0x5b28f8[3];\n        uint256 _0xeac582 = Channels[_0xd5eca6]._0xd76205[1] + Channels[_0xd5eca6]._0x444b7a[2] + Channels[_0xd5eca6]._0x444b7a[3];\n        require(_0xe9ff68 == _0xd2ceb2[0] + _0xd2ceb2[1]);\n        require(_0xeac582 == _0xd2ceb2[2] + _0xd2ceb2[3]);\n\n        bytes32 _0x2fc003 = _0xb2df79(\n            abi._0x9a8676(\n                _0xd5eca6,\n                true,\n                _0x9a238a,\n                uint256(0),\n                bytes32(0x0),\n                Channels[_0xd5eca6]._0xd78819[0],\n                Channels[_0xd5eca6]._0xd78819[1],\n                _0xd2ceb2[0],\n                _0xd2ceb2[1],\n                _0xd2ceb2[2],\n                _0xd2ceb2[3]\n            )\n        );\n\n        require(Channels[_0xd5eca6]._0xd78819[0] == ECTools._0x8e3fe7(_0x2fc003, _0xc7e852));\n        require(Channels[_0xd5eca6]._0xd78819[1] == ECTools._0x8e3fe7(_0x2fc003, _0xce92a2));\n\n        Channels[_0xd5eca6]._0x858abd = false;\n\n        if(_0xd2ceb2[0] != 0 || _0xd2ceb2[1] != 0) {\n            Channels[_0xd5eca6]._0xd78819[0].transfer(_0xd2ceb2[0]);\n            Channels[_0xd5eca6]._0xd78819[1].transfer(_0xd2ceb2[1]);\n        }\n\n        if(_0xd2ceb2[2] != 0 || _0xd2ceb2[3] != 0) {\n            require(Channels[_0xd5eca6]._0xc646b7.transfer(Channels[_0xd5eca6]._0xd78819[0], _0xd2ceb2[2]),\"happyCloseChannel: token transfer failure\");\n            require(Channels[_0xd5eca6]._0xc646b7.transfer(Channels[_0xd5eca6]._0xd78819[1], _0xd2ceb2[3]),\"happyCloseChannel: token transfer failure\");\n        }\n\n        _0x3a8ee9--;\n\n        emit DidLCClose(_0xd5eca6, _0x9a238a, _0xd2ceb2[0], _0xd2ceb2[1], _0xd2ceb2[2], _0xd2ceb2[3]);\n    }\n\n    // Byzantine functions\n\n    function _0x78f9d1(\n        bytes32 _0xd5eca6,\n        uint256[6] _0x2f93e4, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n        bytes32 _0x16463a,\n        string _0xc7e852,\n        string _0xce92a2\n    )\n        public\n    {\n        Channel storage _0x0c9275 = Channels[_0xd5eca6];\n        require(_0x0c9275._0x858abd);\n        require(_0x0c9275._0x9c7bcc < _0x2f93e4[0]); // do same as vc sequence check\n        require(_0x0c9275._0x5b28f8[0] + _0x0c9275._0x5b28f8[1] >= _0x2f93e4[2] + _0x2f93e4[3]);\n        require(_0x0c9275._0x444b7a[0] + _0x0c9275._0x444b7a[1] >= _0x2f93e4[4] + _0x2f93e4[5]);\n\n        if(_0x0c9275._0x4fa389 == true) {\n            require(_0x0c9275._0xbfdb0a > _0x4ec2c9);\n        }\n\n        bytes32 _0x2fc003 = _0xb2df79(\n            abi._0x9a8676(\n                _0xd5eca6,\n                false,\n                _0x2f93e4[0],\n                _0x2f93e4[1],\n                _0x16463a,\n                _0x0c9275._0xd78819[0],\n                _0x0c9275._0xd78819[1],\n                _0x2f93e4[2],\n                _0x2f93e4[3],\n                _0x2f93e4[4],\n                _0x2f93e4[5]\n            )\n        );\n\n        require(_0x0c9275._0xd78819[0] == ECTools._0x8e3fe7(_0x2fc003, _0xc7e852));\n        require(_0x0c9275._0xd78819[1] == ECTools._0x8e3fe7(_0x2fc003, _0xce92a2));\n\n        // update LC state\n        _0x0c9275._0x9c7bcc = _0x2f93e4[0];\n        _0x0c9275._0x4acd9d = _0x2f93e4[1];\n        _0x0c9275._0x5b28f8[0] = _0x2f93e4[2];\n        _0x0c9275._0x5b28f8[1] = _0x2f93e4[3];\n        _0x0c9275._0x444b7a[0] = _0x2f93e4[4];\n        _0x0c9275._0x444b7a[1] = _0x2f93e4[5];\n        _0x0c9275.VCrootHash = _0x16463a;\n        _0x0c9275._0x4fa389 = true;\n        _0x0c9275._0xbfdb0a = _0x4ec2c9 + _0x0c9275._0x9ae645;\n\n        // make settlement flag\n\n        emit DidLCUpdateState (\n            _0xd5eca6,\n            _0x2f93e4[0],\n            _0x2f93e4[1],\n            _0x2f93e4[2],\n            _0x2f93e4[3],\n            _0x2f93e4[4],\n            _0x2f93e4[5],\n            _0x16463a,\n            _0x0c9275._0xbfdb0a\n        );\n    }\n\n    // supply initial state of VC to \"prime\" the force push game\n    function _0xa251c6(\n        bytes32 _0xd5eca6,\n        bytes32 _0xdfd513,\n        bytes _0xfeb0de,\n        address _0xea46f9,\n        address _0x7cfdbd,\n        uint256[2] _0x17103d,\n        uint256[4] _0xd2ceb2, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n        string _0x473f21\n    )\n        public\n    {\n        require(Channels[_0xd5eca6]._0x858abd, \"LC is closed.\");\n        // sub-channel must be open\n        require(!_0xc6fbd7[_0xdfd513]._0x5cf332, \"VC is closed.\");\n        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n        require(Channels[_0xd5eca6]._0xbfdb0a < _0x4ec2c9, \"LC timeout not over.\");\n        // prevent rentry of initializing vc state\n        require(_0xc6fbd7[_0xdfd513]._0x786364 == 0);\n        // partyB is now Ingrid\n        bytes32 _0x9f4045 = _0xb2df79(\n            abi._0x9a8676(_0xdfd513, uint256(0), _0xea46f9, _0x7cfdbd, _0x17103d[0], _0x17103d[1], _0xd2ceb2[0], _0xd2ceb2[1], _0xd2ceb2[2], _0xd2ceb2[3])\n        );\n\n        // Make sure Alice has signed initial vc state (A/B in oldState)\n        require(_0xea46f9 == ECTools._0x8e3fe7(_0x9f4045, _0x473f21));\n\n        // Check the oldState is in the root hash\n        require(_0x204b23(_0x9f4045, _0xfeb0de, Channels[_0xd5eca6].VCrootHash) == true);\n\n        _0xc6fbd7[_0xdfd513]._0x1b04b5 = _0xea46f9; // VC participant A\n        _0xc6fbd7[_0xdfd513]._0x16510a = _0x7cfdbd; // VC participant B\n        _0xc6fbd7[_0xdfd513]._0x9c7bcc = uint256(0);\n        _0xc6fbd7[_0xdfd513]._0x5b28f8[0] = _0xd2ceb2[0];\n        _0xc6fbd7[_0xdfd513]._0x5b28f8[1] = _0xd2ceb2[1];\n        _0xc6fbd7[_0xdfd513]._0x444b7a[0] = _0xd2ceb2[2];\n        _0xc6fbd7[_0xdfd513]._0x444b7a[1] = _0xd2ceb2[3];\n        _0xc6fbd7[_0xdfd513]._0x7a81e2 = _0x17103d;\n        _0xc6fbd7[_0xdfd513]._0x786364 = _0x4ec2c9 + Channels[_0xd5eca6]._0x9ae645;\n        _0xc6fbd7[_0xdfd513]._0xfadcdb = true;\n\n        emit DidVCInit(_0xd5eca6, _0xdfd513, _0xfeb0de, uint256(0), _0xea46f9, _0x7cfdbd, _0xd2ceb2[0], _0xd2ceb2[1]);\n    }\n\n    //TODO: verify state transition since the hub did not agree to this state\n    // make sure the A/B balances are not beyond ingrids bonds\n    // Params: vc init state, vc final balance, vcID\n    function _0xd95ce8(\n        bytes32 _0xd5eca6,\n        bytes32 _0xdfd513,\n        uint256 _0xd23a28,\n        address _0xea46f9,\n        address _0x7cfdbd,\n        uint256[4] _0xf9440c, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n        string _0x473f21\n    )\n        public\n    {\n        require(Channels[_0xd5eca6]._0x858abd, \"LC is closed.\");\n        // sub-channel must be open\n        require(!_0xc6fbd7[_0xdfd513]._0x5cf332, \"VC is closed.\");\n        require(_0xc6fbd7[_0xdfd513]._0x9c7bcc < _0xd23a28, \"VC sequence is higher than update sequence.\");\n        require(\n            _0xc6fbd7[_0xdfd513]._0x5b28f8[1] < _0xf9440c[1] && _0xc6fbd7[_0xdfd513]._0x444b7a[1] < _0xf9440c[3],\n            \"State updates may only increase recipient balance.\"\n        );\n        require(\n            _0xc6fbd7[_0xdfd513]._0x7a81e2[0] == _0xf9440c[0] + _0xf9440c[1] &&\n            _0xc6fbd7[_0xdfd513]._0x7a81e2[1] == _0xf9440c[2] + _0xf9440c[3],\n            \"Incorrect balances for bonded amount\");\n        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n        // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n        // fail if initVC() isn't called first\n        // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n        require(Channels[_0xd5eca6]._0xbfdb0a < _0x4ec2c9); // for testing!\n\n        bytes32 _0x607835 = _0xb2df79(\n            abi._0x9a8676(\n                _0xdfd513,\n                _0xd23a28,\n                _0xea46f9,\n                _0x7cfdbd,\n                _0xc6fbd7[_0xdfd513]._0x7a81e2[0],\n                _0xc6fbd7[_0xdfd513]._0x7a81e2[1],\n                _0xf9440c[0],\n                _0xf9440c[1],\n                _0xf9440c[2],\n                _0xf9440c[3]\n            )\n        );\n\n        // Make sure Alice has signed a higher sequence new state\n        require(_0xc6fbd7[_0xdfd513]._0x1b04b5 == ECTools._0x8e3fe7(_0x607835, _0x473f21));\n\n        // store VC data\n        // we may want to record who is initiating on-chain settles\n        _0xc6fbd7[_0xdfd513]._0x352239 = msg.sender;\n        _0xc6fbd7[_0xdfd513]._0x9c7bcc = _0xd23a28;\n\n        // channel state\n        _0xc6fbd7[_0xdfd513]._0x5b28f8[0] = _0xf9440c[0];\n        _0xc6fbd7[_0xdfd513]._0x5b28f8[1] = _0xf9440c[1];\n        _0xc6fbd7[_0xdfd513]._0x444b7a[0] = _0xf9440c[2];\n        _0xc6fbd7[_0xdfd513]._0x444b7a[1] = _0xf9440c[3];\n\n        _0xc6fbd7[_0xdfd513]._0x786364 = _0x4ec2c9 + Channels[_0xd5eca6]._0x9ae645;\n\n        emit DidVCSettle(_0xd5eca6, _0xdfd513, _0xd23a28, _0xf9440c[0], _0xf9440c[1], msg.sender, _0xc6fbd7[_0xdfd513]._0x786364);\n    }\n\n    function _0xe968a1(bytes32 _0xd5eca6, bytes32 _0xdfd513) public {\n        // require(updateLCtimeout > now)\n        require(Channels[_0xd5eca6]._0x858abd, \"LC is closed.\");\n        require(_0xc6fbd7[_0xdfd513]._0xfadcdb, \"VC is not in settlement state.\");\n        require(_0xc6fbd7[_0xdfd513]._0x786364 < _0x4ec2c9, \"Update vc timeout has not elapsed.\");\n        require(!_0xc6fbd7[_0xdfd513]._0x5cf332, \"VC is already closed\");\n        // reduce the number of open virtual channels stored on LC\n        Channels[_0xd5eca6]._0x4acd9d--;\n        // close vc flags\n        _0xc6fbd7[_0xdfd513]._0x5cf332 = true;\n        // re-introduce the balances back into the LC state from the settled VC\n        // decide if this lc is alice or bob in the vc\n        if(_0xc6fbd7[_0xdfd513]._0x1b04b5 == Channels[_0xd5eca6]._0xd78819[0]) {\n            Channels[_0xd5eca6]._0x5b28f8[0] += _0xc6fbd7[_0xdfd513]._0x5b28f8[0];\n            Channels[_0xd5eca6]._0x5b28f8[1] += _0xc6fbd7[_0xdfd513]._0x5b28f8[1];\n\n            Channels[_0xd5eca6]._0x444b7a[0] += _0xc6fbd7[_0xdfd513]._0x444b7a[0];\n            Channels[_0xd5eca6]._0x444b7a[1] += _0xc6fbd7[_0xdfd513]._0x444b7a[1];\n        } else if (_0xc6fbd7[_0xdfd513]._0x16510a == Channels[_0xd5eca6]._0xd78819[0]) {\n            Channels[_0xd5eca6]._0x5b28f8[0] += _0xc6fbd7[_0xdfd513]._0x5b28f8[1];\n            Channels[_0xd5eca6]._0x5b28f8[1] += _0xc6fbd7[_0xdfd513]._0x5b28f8[0];\n\n            Channels[_0xd5eca6]._0x444b7a[0] += _0xc6fbd7[_0xdfd513]._0x444b7a[1];\n            Channels[_0xd5eca6]._0x444b7a[1] += _0xc6fbd7[_0xdfd513]._0x444b7a[0];\n        }\n\n        emit DidVCClose(_0xd5eca6, _0xdfd513, _0xc6fbd7[_0xdfd513]._0x444b7a[0], _0xc6fbd7[_0xdfd513]._0x444b7a[1]);\n    }\n\n    // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n    function _0xca2b45(bytes32 _0xd5eca6) public {\n        Channel storage _0x0c9275 = Channels[_0xd5eca6];\n\n        // check settlement flag\n        require(_0x0c9275._0x858abd, \"Channel is not open\");\n        require(_0x0c9275._0x4fa389 == true);\n        require(_0x0c9275._0x4acd9d == 0);\n        require(_0x0c9275._0xbfdb0a < _0x4ec2c9, \"LC timeout over.\");\n\n        // if off chain state update didnt reblance deposits, just return to deposit owner\n        uint256 _0xe9ff68 = _0x0c9275._0xd76205[0] + _0x0c9275._0x5b28f8[2] + _0x0c9275._0x5b28f8[3];\n        uint256 _0xeac582 = _0x0c9275._0xd76205[1] + _0x0c9275._0x444b7a[2] + _0x0c9275._0x444b7a[3];\n\n        uint256 _0x677a00 = _0x0c9275._0x5b28f8[0] + _0x0c9275._0x5b28f8[1];\n        uint256 _0xbc40a0 = _0x0c9275._0x444b7a[0] + _0x0c9275._0x444b7a[1];\n\n        if(_0x677a00 < _0xe9ff68) {\n            _0x0c9275._0x5b28f8[0]+=_0x0c9275._0x5b28f8[2];\n            _0x0c9275._0x5b28f8[1]+=_0x0c9275._0x5b28f8[3];\n        } else {\n            require(_0x677a00 == _0xe9ff68);\n        }\n\n        if(_0xbc40a0 < _0xeac582) {\n            _0x0c9275._0x444b7a[0]+=_0x0c9275._0x444b7a[2];\n            _0x0c9275._0x444b7a[1]+=_0x0c9275._0x444b7a[3];\n        } else {\n            require(_0xbc40a0 == _0xeac582);\n        }\n\n        uint256 _0x18e218 = _0x0c9275._0x5b28f8[0];\n        uint256 _0x0450c1 = _0x0c9275._0x5b28f8[1];\n        uint256 _0xb53e56 = _0x0c9275._0x444b7a[0];\n        uint256 _0xe8ca9e = _0x0c9275._0x444b7a[1];\n\n        _0x0c9275._0x5b28f8[0] = 0;\n        _0x0c9275._0x5b28f8[1] = 0;\n        _0x0c9275._0x444b7a[0] = 0;\n        _0x0c9275._0x444b7a[1] = 0;\n\n        if(_0x18e218 != 0 || _0x0450c1 != 0) {\n            _0x0c9275._0xd78819[0].transfer(_0x18e218);\n            _0x0c9275._0xd78819[1].transfer(_0x0450c1);\n        }\n\n        if(_0xb53e56 != 0 || _0xe8ca9e != 0) {\n            require(\n                _0x0c9275._0xc646b7.transfer(_0x0c9275._0xd78819[0], _0xb53e56),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n            require(\n                _0x0c9275._0xc646b7.transfer(_0x0c9275._0xd78819[1], _0xe8ca9e),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n        }\n\n        _0x0c9275._0x858abd = false;\n        _0x3a8ee9--;\n\n        emit DidLCClose(_0xd5eca6, _0x0c9275._0x9c7bcc, _0x18e218, _0x0450c1, _0xb53e56, _0xe8ca9e);\n    }\n\n    function _0x204b23(bytes32 _0xba0a4a, bytes _0xfeb0de, bytes32 _0x89858b) internal pure returns (bool) {\n        bytes32 _0x40d16d = _0xba0a4a;\n        bytes32 _0x6f3c83;\n\n        for (uint256 i = 64; i <= _0xfeb0de.length; i += 32) {\n            assembly { _0x6f3c83 := mload(add(_0xfeb0de, i)) }\n\n            if (_0x40d16d < _0x6f3c83) {\n                _0x40d16d = _0xb2df79(abi._0x9a8676(_0x40d16d, _0x6f3c83));\n            } else {\n                _0x40d16d = _0xb2df79(abi._0x9a8676(_0x6f3c83, _0x40d16d));\n            }\n        }\n\n        return _0x40d16d == _0x89858b;\n    }\n\n    //Struct Getters\n    function _0x5c17ba(bytes32 _0x99d926) public view returns (\n        address[2],\n        uint256[4],\n        uint256[4],\n        uint256[2],\n        uint256,\n        uint256,\n        bytes32,\n        uint256,\n        uint256,\n        bool,\n        bool,\n        uint256\n    ) {\n        Channel memory _0x0c9275 = Channels[_0x99d926];\n        return (\n            _0x0c9275._0xd78819,\n            _0x0c9275._0x5b28f8,\n            _0x0c9275._0x444b7a,\n            _0x0c9275._0xd76205,\n            _0x0c9275._0x9c7bcc,\n            _0x0c9275._0x9ae645,\n            _0x0c9275.VCrootHash,\n            _0x0c9275.LCopenTimeout,\n            _0x0c9275._0xbfdb0a,\n            _0x0c9275._0x858abd,\n            _0x0c9275._0x4fa389,\n            _0x0c9275._0x4acd9d\n        );\n    }\n\n    function _0x4df07e(bytes32 _0x99d926) public view returns(\n        bool,\n        bool,\n        uint256,\n        address,\n        uint256,\n        address,\n        address,\n        address,\n        uint256[2],\n        uint256[2],\n        uint256[2]\n    ) {\n        VirtualChannel memory _0x8a7b74 = _0xc6fbd7[_0x99d926];\n        return(\n            _0x8a7b74._0x5cf332,\n            _0x8a7b74._0xfadcdb,\n            _0x8a7b74._0x9c7bcc,\n            _0x8a7b74._0x352239,\n            _0x8a7b74._0x786364,\n            _0x8a7b74._0x1b04b5,\n            _0x8a7b74._0x16510a,\n            _0x8a7b74._0xbf5fdf,\n            _0x8a7b74._0x5b28f8,\n            _0x8a7b74._0x444b7a,\n            _0x8a7b74._0x7a81e2\n        );\n    }\n}",
      "rename_map": {
        "possibleTotalTokenBeforeDeposit": "_0xbc40a0",
        "possibleTotalEthBeforeDeposit": "_0x677a00",
        "toEthereumSignedMessage": "_0xf0c1b9",
        "consensusCloseChannel": "_0x9fc16b",
        "byzantineCloseChannel": "_0xca2b45",
        "closeVirtualChannel": "_0xe968a1",
        "isInSettlementState": "_0xfadcdb",
        "isUpdateLCSettling": "_0x4fa389",
        "getVirtualChannel": "_0x4df07e",
        "totalTokenDeposit": "_0xeac582",
        "totalEthDeposit": "_0xe9ff68",
        "updateVCtimeout": "_0x786364",
        "updateLCtimeout": "_0xbfdb0a",
        "virtualChannels": "_0xc6fbd7",
        "partyAddresses": "_0xd78819",
        "initialDeposit": "_0xd76205",
        "approveAndCall": "_0xc3c60a",
        "virtualChannel": "_0x8a7b74",
        "_initialAmount": "_0xe8c0a3",
        "parseInt16Char": "_0xb922a8",
        "tokenbalanceA": "_0xb53e56",
        "hexstrToBytes": "_0x800c21",
        "tokenBalanceA": "_0xa33970",
        "_decimalUnits": "_0x47b371",
        "erc20Balances": "_0x444b7a",
        "uintToBytes32": "_0xf17e3b",
        "recoverSigner": "_0x8e3fe7",
        "updateLCstate": "_0x78f9d1",
        "tokenBalanceI": "_0x41c10c",
        "createChannel": "_0xa518bf",
        "tokenbalanceI": "_0xe8ca9e",
        "uintToString": "_0x39e7d6",
        "prefixedHash": "_0x866396",
        "encodePacked": "_0x9a8676",
        "_confirmTime": "_0x461630",
        "_isContained": "_0x204b23",
        "transferFrom": "_0x46dddc",
        "_updateState": "_0x607835",
        "updateParams": "_0x2f93e4",
        "_tokenSymbol": "_0x577442",
        "ethBalanceI": "_0xa42391",
        "joinChannel": "_0x2f0d03",
        "ethBalances": "_0x5b28f8",
        "numChannels": "_0x3a8ee9",
        "ethbalanceI": "_0x0450c1",
        "totalSupply": "_0x19498a",
        "initVCstate": "_0xa251c6",
        "confirmTime": "_0x9ae645",
        "_startIndex": "_0x4c9e98",
        "ethbalanceA": "_0x18e218",
        "ethBalanceA": "_0xe06e29",
        "_extraData": "_0xd901db",
        "getChannel": "_0x5c17ba",
        "challenger": "_0x352239",
        "isSignedBy": "_0x54da17",
        "_initState": "_0x9f4045",
        "_hashedMsg": "_0xf2c0e0",
        "_tokenName": "_0x7426b2",
        "updateBalB": "_0xe6cb3a",
        "updateBalA": "_0x0b3f7e",
        "balanceOf": "_0x160aff",
        "substring": "_0xd1ce23",
        "keccak256": "_0xb2df79",
        "_balances": "_0xd2ceb2",
        "_endIndex": "_0x0884ec",
        "channelId": "_0xd35e8d",
        "proofElem": "_0x6f3c83",
        "numOpenVC": "_0x4acd9d",
        "remainder": "_0xf1c42f",
        "updateSeq": "_0xd23a28",
        "ecrecover": "_0x78b618",
        "numOpenVc": "_0x5e690c",
        "recipient": "_0xcfcbcc",
        "updateBal": "_0xf9440c",
        "_sequence": "_0x9a238a",
        "remaining": "_0xc757e9",
        "allowance": "_0x0ff64a",
        "balanceB": "_0x223db2",
        "decimals": "_0x1faf73",
        "_spender": "_0x2da78a",
        "sequence": "_0x9c7bcc",
        "settleVC": "_0xd95ce8",
        "balanceA": "_0x003c12",
        "_balance": "_0xaaefda",
        "balances": "_0xf148c1",
        "strBytes": "_0x8791be",
        "_partyI": "_0xf62d96",
        "approve": "_0x010c65",
        "version": "_0xe90d6a",
        "_VCroot": "_0x16463a",
        "isClose": "_0x5cf332",
        "allowed": "_0xd810dc",
        "deposit": "_0x68628a",
        "_partyB": "_0x7cfdbd",
        "isToken": "_0xd29b0e",
        "success": "_0x201dff",
        "channel": "_0x0c9275",
        "bresult": "_0xcd3d7f",
        "_partyA": "_0xea46f9",
        "_hexstr": "_0x49c651",
        "cursor": "_0x40d16d",
        "_value": "_0x76267c",
        "vcRoot": "_0x34c4b4",
        "_token": "_0xc08dd5",
        "_state": "_0x2fc003",
        "partyA": "_0x1b04b5",
        "_proof": "_0xfeb0de",
        "result": "_0xc2cae0",
        "partyI": "_0xbf5fdf",
        "prefix": "_0xd4ca4d",
        "symbol": "_0x7c1776",
        "isOpen": "_0x858abd",
        "partyB": "_0x16510a",
        "_owner": "_0x667af1",
        "proof": "_0x105ee2",
        "_sigA": "_0xc7e852",
        "_uint": "_0x153e34",
        "_lcID": "_0xd5eca6",
        "token": "_0xc646b7",
        "_addr": "_0x5273d9",
        "_vcID": "_0xdfd513",
        "_bond": "_0x17103d",
        "_sigI": "_0xce92a2",
        "_root": "_0x89858b",
        "_char": "_0x04dccd",
        "_hash": "_0xba0a4a",
        "_from": "_0x6489fe",
        "vcId": "_0x03dc2d",
        "_str": "_0xf21925",
        "name": "_0xe6b820",
        "_msg": "_0xb54040",
        "lcId": "_0x67bc72",
        "sigA": "_0x473f21",
        "bond": "_0x7a81e2",
        "bstr": "_0xd26905",
        "_sig": "_0xa856dd",
        "str": "_0xf7adec",
        "now": "_0x4ec2c9",
        "len": "_0xd8b81d",
        "_to": "_0xfb1fbd",
        "id": "_0x99d926"
      },
      "changes": [
        "Renamed 141 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_115",
      "transformed_id": "ss_l3_medium_sn_ds_115",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// https://etherscan.io/address/0x42d6622dece394b54999fbd73d108123806f6a18#code\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity 0.4.15;\n\ncontract Token {\n    /// total amount of tokens\n    uint256 public _0x036c95;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function _0x87d781(address _0x661bb8) constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _0xd0b2e0, uint256 _0xe0eeae) returns (bool _0x35e126);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function _0x6cb774(address _0x498af0, address _0xd0b2e0, uint256 _0xe0eeae) returns (bool _0x35e126);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function _0xf85432(address _0x1c9131, uint256 _0xe0eeae) returns (bool _0x35e126);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function _0x13c50c(address _0x661bb8, address _0x1c9131) constant returns (uint256 _0xf847fa);\n\n    event Transfer(address indexed _0x498af0, address indexed _0xd0b2e0, uint256 _0xe0eeae);\n    event Approval(address indexed _0x661bb8, address indexed _0x1c9131, uint256 _0xe0eeae);\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _0xd0b2e0, uint256 _0xe0eeae) returns (bool _0x35e126) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0xd633b6[msg.sender] >= _0xe0eeae);\n        _0xd633b6[msg.sender] -= _0xe0eeae;\n        _0xd633b6[_0xd0b2e0] += _0xe0eeae;\n        Transfer(msg.sender, _0xd0b2e0, _0xe0eeae);\n        return true;\n    }\n\n    function _0x6cb774(address _0x498af0, address _0xd0b2e0, uint256 _0xe0eeae) returns (bool _0x35e126) {\n\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0xd633b6[_0x498af0] >= _0xe0eeae && _0x07c1a1[_0x498af0][msg.sender] >= _0xe0eeae);\n        _0xd633b6[_0xd0b2e0] += _0xe0eeae;\n        _0xd633b6[_0x498af0] -= _0xe0eeae;\n        _0x07c1a1[_0x498af0][msg.sender] -= _0xe0eeae;\n        Transfer(_0x498af0, _0xd0b2e0, _0xe0eeae);\n        return true;\n    }\n\n    function _0x87d781(address _0x661bb8) constant returns (uint256 balance) {\n        return _0xd633b6[_0x661bb8];\n    }\n\n    function _0xf85432(address _0x1c9131, uint256 _0xe0eeae) returns (bool _0x35e126) {\n        _0x07c1a1[msg.sender][_0x1c9131] = _0xe0eeae;\n        Approval(msg.sender, _0x1c9131, _0xe0eeae);\n        return true;\n    }\n\n    function _0x13c50c(address _0x661bb8, address _0x1c9131) constant returns (uint256 _0xf847fa) {\n      return _0x07c1a1[_0x661bb8][_0x1c9131];\n    }\n\n    mapping (address => uint256) _0xd633b6;\n    mapping (address => mapping (address => uint256)) _0x07c1a1;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n    /* Public variables of the token */\n    string public _0x421c3f;                   //fancy name: eg Simon Bucks\n    uint8 public _0x1f2a79;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n    string public _0x8240d2;                 //An identifier: eg SBX\n    string public _0x931b0b = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n    function HumanStandardToken(\n        uint256 _0x768fc2,\n        string _0xb3b879,\n        uint8 _0x33347c,\n        string _0x4aba79\n        ) {\n        _0xd633b6[msg.sender] = _0x768fc2;               // Give the creator all initial tokens\n        _0x036c95 = _0x768fc2;                        // Update total supply\n        _0x421c3f = _0xb3b879;                                   // Set the name for display purposes\n        _0x1f2a79 = _0x33347c;                            // Amount of decimals for display purposes\n        _0x8240d2 = _0x4aba79;                               // Set the symbol for display purposes\n    }\n\n    /* Approves and then calls the receiving contract */\n    function _0x7f1913(address _0x1c9131, uint256 _0xe0eeae, bytes _0x7841d3) returns (bool _0x35e126) {\n        _0x07c1a1[msg.sender][_0x1c9131] = _0xe0eeae;\n        Approval(msg.sender, _0x1c9131, _0xe0eeae);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        require(_0x1c9131.call(bytes4(bytes32(_0x595ad1(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _0xe0eeae, this, _0x7841d3));\n        return true;\n    }\n}",
      "rename_map": {
        "_initialAmount": "_0x768fc2",
        "approveAndCall": "_0x7f1913",
        "_decimalUnits": "_0x33347c",
        "transferFrom": "_0x6cb774",
        "_tokenSymbol": "_0x4aba79",
        "totalSupply": "_0x036c95",
        "_tokenName": "_0xb3b879",
        "_extraData": "_0x7841d3",
        "balanceOf": "_0x87d781",
        "remaining": "_0xf847fa",
        "allowance": "_0x13c50c",
        "_spender": "_0x1c9131",
        "balances": "_0xd633b6",
        "decimals": "_0x1f2a79",
        "approve": "_0xf85432",
        "version": "_0x931b0b",
        "success": "_0x35e126",
        "allowed": "_0x07c1a1",
        "_value": "_0xe0eeae",
        "_owner": "_0x661bb8",
        "symbol": "_0x8240d2",
        "_from": "_0x498af0",
        "sha3": "_0x595ad1",
        "name": "_0x421c3f",
        "_to": "_0xd0b2e0"
      },
      "changes": [
        "Renamed 25 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_116",
      "transformed_id": "ss_l3_medium_sn_ds_116",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Missing{\n    address private _0x58afd5;\n\n    modifier _0x18c6ca {\n        require(msg.sender==_0x58afd5);\n        _;\n    }\n\n    // The name of the constructor should be Missing\n\n    function IamMissing()\n        public\n    {\n        _0x58afd5 = msg.sender;\n    }\n\n    function _0xd585d6()\n        public\n        _0x18c6ca\n    {\n       _0x58afd5.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "_0x18c6ca",
        "withdraw": "_0xd585d6",
        "owner": "_0x58afd5"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_117",
      "transformed_id": "ss_l3_medium_sn_ds_117",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\npragma solidity ^0.4.15;\n\ncontract Rubixi {\n\n        //Declare variables for storage critical to contract\n        uint private balance = 0;\n        uint private _0xb18848 = 0;\n        uint private _0x5fa5cf = 10;\n        uint private _0x24d441 = 300;\n        uint private _0x889b12 = 0;\n\n        address private _0xe943fa;\n\n        //Sets creator\n        function DynamicPyramid() {\n                _0xe943fa = msg.sender;\n        }\n\n        modifier _0x998e60 {\n                if (msg.sender == _0xe943fa) _;\n        }\n\n        struct Participant {\n                address _0x59f023;\n                uint _0x480fba;\n        }\n\n        Participant[] private _0xaf5e5e;\n\n        //Fallback function\n        function() {\n                _0xf0a3a9();\n        }\n\n        //init function run on fallback\n        function _0xf0a3a9() private {\n                //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                if (msg.value < 1 ether) {\n                        _0xb18848 += msg.value;\n                        return;\n                }\n\n                uint _0x9a450b = _0x5fa5cf;\n                //50% fee rebate on any ether value of 50 or greater\n                if (msg.value >= 50 ether) _0x9a450b /= 2;\n\n                _0x6be7b3(_0x9a450b);\n        }\n\n        //Function called for valid tx to the contract\n        function _0x6be7b3(uint _0x9a450b) private {\n                //Adds new address to participant array\n                _0xaf5e5e.push(Participant(msg.sender, (msg.value * _0x24d441) / 100));\n\n                //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                if (_0xaf5e5e.length == 10) _0x24d441 = 200;\n                else if (_0xaf5e5e.length == 25) _0x24d441 = 150;\n\n                // collect fees and update contract balance\n                balance += (msg.value * (100 - _0x9a450b)) / 100;\n                _0xb18848 += (msg.value * _0x9a450b) / 100;\n\n                //Pays earlier participiants if balance sufficient\n                while (balance > _0xaf5e5e[_0x889b12]._0x480fba) {\n                        uint _0x2d76f9 = _0xaf5e5e[_0x889b12]._0x480fba;\n                        _0xaf5e5e[_0x889b12]._0x59f023.send(_0x2d76f9);\n\n                        balance -= _0xaf5e5e[_0x889b12]._0x480fba;\n                        _0x889b12 += 1;\n                }\n        }\n\n        //Fee functions for creator\n        function _0x23d416() _0x998e60 {\n                if (_0xb18848 == 0) throw;\n\n                _0xe943fa.send(_0xb18848);\n                _0xb18848 = 0;\n        }\n\n        function _0xa73f5a(uint _0xf5ef90) _0x998e60 {\n                _0xf5ef90 *= 1 ether;\n                if (_0xf5ef90 > _0xb18848) _0x23d416();\n\n                if (_0xb18848 == 0) throw;\n\n                _0xe943fa.send(_0xf5ef90);\n                _0xb18848 -= _0xf5ef90;\n        }\n\n        function _0xda95a3(uint _0xed296b) _0x998e60 {\n                if (_0xb18848 == 0 || _0xed296b > 100) throw;\n\n                uint _0x0a1507 = _0xb18848 / 100 * _0xed296b;\n                _0xe943fa.send(_0x0a1507);\n                _0xb18848 -= _0x0a1507;\n        }\n\n        //Functions for changing variables related to the contract\n        function _0x2b084e(address _0xbf516f) _0x998e60 {\n                _0xe943fa = _0xbf516f;\n        }\n\n        function _0x5a2598(uint _0x955010) _0x998e60 {\n                if (_0x955010 > 300 || _0x955010 < 120) throw;\n\n                _0x24d441 = _0x955010;\n        }\n\n        function _0x83ad8b(uint _0x9a450b) _0x998e60 {\n                if (_0x9a450b > 10) throw;\n\n                _0x5fa5cf = _0x9a450b;\n        }\n\n        //Functions to provide information to end-user using JSON interface or other interfaces\n        function _0x8c67bb() constant returns(uint _0xffd151, string _0x24b59e) {\n                _0xffd151 = _0x24d441;\n                _0x24b59e = 'This _0xffd151 applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, _0xffd151 is x100 for a fractional _0xffd151 e.g. 250 is actually a 2.5x _0xffd151. Capped at 3x max and 1.2x min.';\n        }\n\n        function _0xa75628() constant returns(uint _0xcc5582, string _0x24b59e) {\n                _0xcc5582 = _0x5fa5cf;\n                _0x24b59e = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n        }\n\n        function _0xa36c14() constant returns(uint _0x2c7dfa, string _0x24b59e) {\n                _0x2c7dfa = balance / 1 ether;\n                if (msg.sender != address(0) || msg.sender == address(0)) { _0x24b59e = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to'; }\n        }\n\n        function _0x8ff6ce() constant returns(uint _0x332f82) {\n                _0x332f82 = _0xaf5e5e[_0x889b12]._0x480fba / 1 ether;\n        }\n\n        function _0x9525df() constant returns(uint _0x0b9f94) {\n                if (gasleft() > 0) { _0x0b9f94 = _0xb18848 / 1 ether; }\n        }\n\n        function _0xb55a0c() constant returns(uint _0x88c07a) {\n                if (msg.sender != address(0) || msg.sender == address(0)) { _0x88c07a = _0xaf5e5e.length; }\n        }\n\n        function _0x301d9c() constant returns(uint _0x88c07a) {\n                if (1 == 1) { _0x88c07a = _0xaf5e5e.length - _0x889b12; }\n        }\n\n        function _0x610018(uint _0xa32020) constant returns(address Address, uint Payout) {\n                if (_0xa32020 <= _0xaf5e5e.length) {\n                        Address = _0xaf5e5e[_0xa32020]._0x59f023;\n                        Payout = _0xaf5e5e[_0xa32020]._0x480fba / 1 ether;\n                }\n        }\n}",
      "rename_map": {
        "nextPayoutWhenPyramidBalanceTotalsApproximately": "_0x8ff6ce",
        "numberOfParticipantsWaitingForPayout": "_0x301d9c",
        "feesSeperateFromBalanceApproximately": "_0x9525df",
        "currentPyramidBalanceApproximately": "_0xa36c14",
        "currentFeePercentage": "_0xa75628",
        "collectPercentOfFees": "_0xda95a3",
        "changeFeePercentage": "_0x83ad8b",
        "participantDetails": "_0x610018",
        "collectFeesInEther": "_0xa73f5a",
        "pyramidMultiplier": "_0x24d441",
        "totalParticipants": "_0xb55a0c",
        "currentMultiplier": "_0x8c67bb",
        "changeMultiplier": "_0x5a2598",
        "orderInPyramid": "_0xa32020",
        "collectAllFees": "_0x23d416",
        "pyramidBalance": "_0x2c7dfa",
        "collectedFees": "_0xb18848",
        "feesToCollect": "_0x0a1507",
        "balancePayout": "_0x332f82",
        "payoutToSend": "_0x2d76f9",
        "etherAddress": "_0x59f023",
        "participants": "_0xaf5e5e",
        "changeOwner": "_0x2b084e",
        "payoutOrder": "_0x889b12",
        "multiplier": "_0xffd151",
        "feePercent": "_0x5fa5cf",
        "addPayout": "_0x6be7b3",
        "onlyowner": "_0x998e60",
        "creator": "_0xe943fa",
        "_owner": "_0xbf516f",
        "payout": "_0x480fba",
        "_pcent": "_0xed296b",
        "_mult": "_0x955010",
        "count": "_0x88c07a",
        "fees": "_0x0b9f94",
        "_amt": "_0xf5ef90",
        "info": "_0x24b59e",
        "_fee": "_0x9a450b",
        "init": "_0xf0a3a9",
        "fee": "_0xcc5582"
      },
      "changes": [
        "Renamed 40 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_118",
      "transformed_id": "ss_l3_medium_sn_ds_118",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "contract Destructible {\n  address _0x41a7c1;\n  function suicide() public returns (address) {\n    require(_0x41a7c1 == msg.sender);\n    selfdestruct(_0x41a7c1);\n  }\n}\ncontract C is Destructible {\n  address _0x41a7c1;\n  function C() {\n    _0x41a7c1 = msg.sender;\n  }\n}",
      "rename_map": {
        "owner": "_0x41a7c1"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_119",
      "transformed_id": "ss_l3_medium_sn_ds_119",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\npragma solidity ^0.4.19;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address _0x77b419;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string _0x08daf5;\n        // How much did they pay to become monarch?\n        uint _0x6df8c2;\n        // When did their rule start (based on block.timestamp)?\n        uint _0x3481ae;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address _0x7aad42;\n\n    // Used to ensure only the wizard can do some things.\n    modifier _0x9540b3 { if (msg.sender == _0x7aad42) _; }\n\n    // How much must the first monarch pay?\n    uint constant _0x19182f = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant _0x132ad3 = 3;\n    uint constant _0x5599da = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant _0xc2231e = 1;\n    uint constant _0x1d024e = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public _0x5a2486;\n\n    // The King (or Queen) of the Ether.\n    Monarch public _0xa811fc;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public _0xecb6e2;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        _0x7aad42 = msg.sender;\n        _0x5a2486 = _0x19182f;\n        _0xa811fc = Monarch(\n            _0x7aad42,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function _0xd18db1() constant returns (uint n) {\n        return _0xecb6e2.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address _0xf0d5fe,\n        string _0x297e6d,\n        uint _0x4ae712\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        _0xdd925b(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function _0xdd925b(string _0x08daf5) {\n\n        uint _0xfe9864 = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (_0xfe9864 < _0x5a2486) {\n            msg.sender.send(_0xfe9864);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (_0xfe9864 > _0x5a2486) {\n            uint _0xf70e94 = _0xfe9864 - _0x5a2486;\n            msg.sender.send(_0xf70e94);\n            _0xfe9864 = _0xfe9864 - _0xf70e94;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint _0x1ab625 = (_0xfe9864 * _0xc2231e) / _0x1d024e;\n\n        uint _0xd48aca = _0xfe9864 - _0x1ab625;\n\n        if (_0xa811fc._0x77b419 != _0x7aad42) {\n            _0xa811fc._0x77b419.send(_0xd48aca);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        _0xecb6e2.push(_0xa811fc);\n        _0xa811fc = Monarch(\n            msg.sender,\n            _0x08daf5,\n            _0xfe9864,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint _0x46b55d = _0x5a2486 * _0x132ad3 / _0x5599da;\n        if (_0x46b55d < 10 finney) {\n            if (block.timestamp > 0) { _0x5a2486 = _0x46b55d; }\n        } else if (_0x46b55d < 100 finney) {\n            _0x5a2486 = 100 szabo * (_0x46b55d / 100 szabo);\n        } else if (_0x46b55d < 1 ether) {\n            _0x5a2486 = 1 finney * (_0x46b55d / 1 finney);\n        } else if (_0x46b55d < 10 ether) {\n            _0x5a2486 = 10 finney * (_0x46b55d / 10 finney);\n        } else if (_0x46b55d < 100 ether) {\n            _0x5a2486 = 100 finney * (_0x46b55d / 100 finney);\n        } else if (_0x46b55d < 1000 ether) {\n            _0x5a2486 = 1 ether * (_0x46b55d / 1 ether);\n        } else if (_0x46b55d < 10000 ether) {\n            _0x5a2486 = 10 ether * (_0x46b55d / 10 ether);\n        } else {\n            _0x5a2486 = _0x46b55d;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(_0xa811fc._0x77b419, _0xa811fc._0x08daf5, _0x5a2486);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0x4c8099(uint _0x296bb2) _0x9540b3 {\n        _0x7aad42.send(_0x296bb2);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0xff191a(address _0x7bee14) _0x9540b3 {\n        _0x7aad42 = _0x7bee14;\n    }\n\n}",
      "rename_map": {
        "wizardCommissionFractionDen": "_0x1d024e",
        "wizardCommissionFractionNum": "_0xc2231e",
        "coronationTimestamp": "_0x3481ae",
        "usurperEtherAddress": "_0xf0d5fe",
        "claimPriceAdjustDen": "_0x5599da",
        "claimPriceAdjustNum": "_0x132ad3",
        "startingClaimPrice": "_0x19182f",
        "currentClaimPrice": "_0x5a2486",
        "transferOwnership": "_0xff191a",
        "rawNewClaimPrice": "_0x46b55d",
        "wizardCommission": "_0x1ab625",
        "numberOfMonarchs": "_0xd18db1",
        "sweepCommission": "_0x4c8099",
        "currentMonarch": "_0xa811fc",
        "newClaimPrice": "_0x4ae712",
        "wizardAddress": "_0x7aad42",
        "pastMonarchs": "_0xecb6e2",
        "compensation": "_0xd48aca",
        "etherAddress": "_0x77b419",
        "claimThrone": "_0xdd925b",
        "usurperName": "_0x297e6d",
        "claimPrice": "_0x6df8c2",
        "excessPaid": "_0xf70e94",
        "onlywizard": "_0x9540b3",
        "valuePaid": "_0xfe9864",
        "newOwner": "_0x7bee14",
        "amount": "_0x296bb2",
        "name": "_0x08daf5"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_120",
      "transformed_id": "ss_l3_medium_sn_ds_120",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract CrowdFundBasic {\n  address[] private _0xf21a4a;\n  mapping(address => uint) public _0xe9cd73;\n\n  function _0xff7d17() public {\n    for(uint i; i < _0xf21a4a.length; i++) {\n      require(_0xf21a4a[i].transfer(_0xe9cd73[_0xf21a4a[i]]));\n    }\n  }\n}\n\ncontract CrowdFundPull {\n  address[] private _0xf21a4a;\n  mapping(address => uint) public _0xe9cd73;\n\n  function _0x8a4644() external {\n    uint _0x757bc5 = _0xe9cd73[msg.sender];\n    _0xe9cd73[msg.sender] = 0;\n    msg.sender.transfer(_0x757bc5);\n  }\n}\n\ncontract CrowdFundSafe {\n  address[] private _0xf21a4a;\n  mapping(address => uint) public _0xe9cd73;\n  uint256 _0x0d8161;\n\n  function _0x1bfb41() public {\n    uint256 i = _0x0d8161;\n    while(i < _0xf21a4a.length && msg.gas > 200000) {\n      _0xf21a4a[i].transfer(_0xe9cd73[i]);\n      i++;\n    }\n    _0x0d8161 = i;\n  }\n}",
      "rename_map": {
        "refundAddresses": "_0xf21a4a",
        "refundAmount": "_0xe9cd73",
        "refundSafe": "_0x1bfb41",
        "refundDos": "_0xff7d17",
        "withdraw": "_0x8a4644",
        "nextIdx": "_0x0d8161",
        "refund": "_0x757bc5"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_121",
      "transformed_id": "ss_l3_medium_sn_ds_121",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address _0xb5490f;\n  uint _0xf9dbab;\n\n  function _0x89064e() payable {\n    require(msg.value > _0xf9dbab);\n\n    //If the refund fails, the entire transaction reverts.\n\n    if (_0xb5490f != 0) {\n      //E.g. if recipients fallback function is just revert()\n      require(_0xb5490f.send(_0xf9dbab));\n    }\n\n    _0xb5490f = msg.sender;\n    _0xf9dbab         = msg.value;\n  }\n}\n\ncontract AuctionV2 {\n  address _0xb5490f;\n  uint    _0xf9dbab;\n\n  mapping(address => uint) _0x1f390b;\n\n  //Avoids \"pushing\" balance to users favoring \"pull\" architecture\n  function _0x89064e() payable external {\n    require(msg.value > _0xf9dbab);\n\n    if (_0xb5490f != 0) {\n      _0x1f390b[_0xb5490f] += _0xf9dbab;\n    }\n\n    _0xb5490f = msg.sender;\n    _0xf9dbab         = msg.value;\n  }\n\n  //Allows users to get their refund from auction\n  function _0x907704() external {\n    //Do all state manipulation before external call to\n    uint _0x4ec3c2 = _0x1f390b[msg.sender];\n    _0x1f390b[msg.sender] = 0;\n\n    msg.sender.send(_0x4ec3c2);\n  }\n}",
      "rename_map": {
        "currentFrontrunner": "_0xb5490f",
        "currentBid": "_0xf9dbab",
        "withdraw": "_0x907704",
        "refunds": "_0x1f390b",
        "refund": "_0x4ec3c2",
        "bid": "_0x89064e"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_122",
      "transformed_id": "ss_l3_medium_sn_ds_122",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// 0xa657491c1e7f16adb39b9b60e87bbb8d93988bc3#code\n//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address _0xa5bd8b, bytes32 _0x047efe);\n  event Revoke(address _0xa5bd8b, bytes32 _0x047efe);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address _0x608176, address _0x9b85d8);\n  event OwnerAdded(address _0x9b85d8);\n  event OwnerRemoved(address _0x608176);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint _0xe8755a);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _0xc2798b, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address _0xa5bd8b, uint value, address _0xacf947, bytes data, address _0x51fb5f);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address _0xa5bd8b, bytes32 _0x047efe, uint value, address _0xacf947, bytes data, address _0x51fb5f);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 _0x047efe, address _0x3a1aa1, uint value, address _0xacf947, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function _0x438973(bytes32 _0x0fccab) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xff1ccf(address _0xc2798b, address _0x370b27) external;\n\n  function _0xa6624c(address _0x897668) external;\n\n  function _0xa2ecc0(address _0x897668) external;\n\n  function _0x602d7f(uint _0x10728f) external;\n\n  function _0x2a5ccb(address _0xe35045) constant returns (bool);\n\n  function _0xdc0f9e(bytes32 _0x0fccab, address _0x897668) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x106c27(uint _0x8d4ce5) external;\n\n  function _0x346d31(address _0x370b27, uint _0x580d8b, bytes _0x60d6c0) external returns (bytes32 _0x0336b8);\n  function _0x8c432e(bytes32 _0x31ee45) returns (bool _0xb1b665);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint _0x4f13e3;\n    uint _0x856ca0;\n    uint _0x7a33d4;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address _0xacf947;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier _0x5c5de1 {\n    if (_0x2a5ccb(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier _0x8a511b(bytes32 _0x0fccab) {\n    if (_0xd85e2a(_0x0fccab))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function _0xfac781(address[] _0x9e15be, uint _0x9e0f20) {\n    if (gasleft() > 0) { _0x2f1f77 = _0x9e15be.length + 1; }\n    _0xa4d3bd[1] = uint(msg.sender);\n    _0xdd7770[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _0x9e15be.length; ++i)\n    {\n      _0xa4d3bd[2 + i] = uint(_0x9e15be[i]);\n      _0xdd7770[uint(_0x9e15be[i])] = 2 + i;\n    }\n    _0x7b9b07 = _0x9e0f20;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function _0x438973(bytes32 _0x0fccab) external {\n    uint _0x5f421c = _0xdd7770[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x5f421c == 0) return;\n    uint _0xab451e = 2**_0x5f421c;\n    var _0x546eab = _0x843d43[_0x0fccab];\n    if (_0x546eab._0x856ca0 & _0xab451e > 0) {\n      _0x546eab._0x4f13e3++;\n      _0x546eab._0x856ca0 -= _0xab451e;\n      Revoke(msg.sender, _0x0fccab);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xff1ccf(address _0xc2798b, address _0x370b27) _0x8a511b(_0xb6a970(msg.data)) external {\n    if (_0x2a5ccb(_0x370b27)) return;\n    uint _0x5f421c = _0xdd7770[uint(_0xc2798b)];\n    if (_0x5f421c == 0) return;\n\n    _0x27ea99();\n    _0xa4d3bd[_0x5f421c] = uint(_0x370b27);\n    _0xdd7770[uint(_0xc2798b)] = 0;\n    _0xdd7770[uint(_0x370b27)] = _0x5f421c;\n    OwnerChanged(_0xc2798b, _0x370b27);\n  }\n\n  function _0xa6624c(address _0x897668) _0x8a511b(_0xb6a970(msg.data)) external {\n    if (_0x2a5ccb(_0x897668)) return;\n\n    _0x27ea99();\n    if (_0x2f1f77 >= _0x731f8f)\n      _0xde61f3();\n    if (_0x2f1f77 >= _0x731f8f)\n      return;\n    _0x2f1f77++;\n    _0xa4d3bd[_0x2f1f77] = uint(_0x897668);\n    _0xdd7770[uint(_0x897668)] = _0x2f1f77;\n    OwnerAdded(_0x897668);\n  }\n\n  function _0xa2ecc0(address _0x897668) _0x8a511b(_0xb6a970(msg.data)) external {\n    uint _0x5f421c = _0xdd7770[uint(_0x897668)];\n    if (_0x5f421c == 0) return;\n    if (_0x7b9b07 > _0x2f1f77 - 1) return;\n\n    _0xa4d3bd[_0x5f421c] = 0;\n    _0xdd7770[uint(_0x897668)] = 0;\n    _0x27ea99();\n    _0xde61f3(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_0x897668);\n  }\n\n  function _0x602d7f(uint _0x10728f) _0x8a511b(_0xb6a970(msg.data)) external {\n    if (_0x10728f > _0x2f1f77) return;\n    _0x7b9b07 = _0x10728f;\n    _0x27ea99();\n    RequirementChanged(_0x10728f);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x49d3f2(uint _0x5f421c) external constant returns (address) {\n    return address(_0xa4d3bd[_0x5f421c + 1]);\n  }\n\n  function _0x2a5ccb(address _0xe35045) constant returns (bool) {\n    return _0xdd7770[uint(_0xe35045)] > 0;\n  }\n\n  function _0xdc0f9e(bytes32 _0x0fccab, address _0x897668) external constant returns (bool) {\n    var _0x546eab = _0x843d43[_0x0fccab];\n    uint _0x5f421c = _0xdd7770[uint(_0x897668)];\n\n    // make sure they're an owner\n    if (_0x5f421c == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint _0xab451e = 2**_0x5f421c;\n    return !(_0x546eab._0x856ca0 & _0xab451e == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function _0xc32585(uint _0x16cc77) {\n    _0x917ed8 = _0x16cc77;\n    _0x603a3f = _0x914d6f();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x106c27(uint _0x8d4ce5) _0x8a511b(_0xb6a970(msg.data)) external {\n    _0x917ed8 = _0x8d4ce5;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function _0x41909f() _0x8a511b(_0xb6a970(msg.data)) external {\n    if (1 == 1) { _0x13ec5e = 0; }\n  }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function _0x34d870(address[] _0x9e15be, uint _0x9e0f20, uint _0xa147ca) {\n    _0xc32585(_0xa147ca);\n    _0xfac781(_0x9e15be, _0x9e0f20);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function _0x174b53(address _0x370b27) _0x8a511b(_0xb6a970(msg.data)) external {\n    suicide(_0x370b27);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function _0x346d31(address _0x370b27, uint _0x580d8b, bytes _0x60d6c0) external _0x5c5de1 returns (bytes32 _0x0336b8) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_0x60d6c0.length == 0 && _0x18ac52(_0x580d8b)) || _0x7b9b07 == 1) {\n      // yes - just execute the call.\n      address _0x51fb5f;\n      if (_0x370b27 == 0) {\n        _0x51fb5f = _0x743173(_0x580d8b, _0x60d6c0);\n      } else {\n        if (!_0x370b27.call.value(_0x580d8b)(_0x60d6c0))\n          throw;\n      }\n      SingleTransact(msg.sender, _0x580d8b, _0x370b27, _0x60d6c0, _0x51fb5f);\n    } else {\n      // determine our operation hash.\n      _0x0336b8 = _0xb6a970(msg.data, block.number);\n      // store if it's new\n      if (_0x180611[_0x0336b8]._0xacf947 == 0 && _0x180611[_0x0336b8].value == 0 && _0x180611[_0x0336b8].data.length == 0) {\n        _0x180611[_0x0336b8]._0xacf947 = _0x370b27;\n        _0x180611[_0x0336b8].value = _0x580d8b;\n        _0x180611[_0x0336b8].data = _0x60d6c0;\n      }\n      if (!_0x8c432e(_0x0336b8)) {\n        ConfirmationNeeded(_0x0336b8, msg.sender, _0x580d8b, _0x370b27, _0x60d6c0);\n      }\n    }\n  }\n\n  function _0x743173(uint _0x580d8b, bytes _0xd82707) internal returns (address _0xdb114b) {\n    assembly {\n      _0xdb114b := _0x743173(_0x580d8b, add(_0xd82707, 0x20), mload(_0xd82707))\n      _0x7ee030(_0x843b98, iszero(extcodesize(_0xdb114b)))\n    }\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function _0x8c432e(bytes32 _0x31ee45) _0x8a511b(_0x31ee45) returns (bool _0xb1b665) {\n    if (_0x180611[_0x31ee45]._0xacf947 != 0 || _0x180611[_0x31ee45].value != 0 || _0x180611[_0x31ee45].data.length != 0) {\n      address _0x51fb5f;\n      if (_0x180611[_0x31ee45]._0xacf947 == 0) {\n        _0x51fb5f = _0x743173(_0x180611[_0x31ee45].value, _0x180611[_0x31ee45].data);\n      } else {\n        if (!_0x180611[_0x31ee45]._0xacf947.call.value(_0x180611[_0x31ee45].value)(_0x180611[_0x31ee45].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _0x31ee45, _0x180611[_0x31ee45].value, _0x180611[_0x31ee45]._0xacf947, _0x180611[_0x31ee45].data, _0x51fb5f);\n      delete _0x180611[_0x31ee45];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function _0xd85e2a(bytes32 _0x0fccab) internal returns (bool) {\n    // determine what index the present sender is:\n    uint _0x5f421c = _0xdd7770[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x5f421c == 0) return;\n\n    var _0x546eab = _0x843d43[_0x0fccab];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (_0x546eab._0x4f13e3 == 0) {\n      // reset count of confirmations needed.\n      _0x546eab._0x4f13e3 = _0x7b9b07;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      _0x546eab._0x856ca0 = 0;\n      _0x546eab._0x7a33d4 = _0xa37cd0.length++;\n      _0xa37cd0[_0x546eab._0x7a33d4] = _0x0fccab;\n    }\n    // determine the bit to set for this owner.\n    uint _0xab451e = 2**_0x5f421c;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (_0x546eab._0x856ca0 & _0xab451e == 0) {\n      Confirmation(msg.sender, _0x0fccab);\n      // ok - check if count is enough to go ahead.\n      if (_0x546eab._0x4f13e3 <= 1) {\n        // enough confirmations: reset and run interior.\n        delete _0xa37cd0[_0x843d43[_0x0fccab]._0x7a33d4];\n        delete _0x843d43[_0x0fccab];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        _0x546eab._0x4f13e3--;\n        _0x546eab._0x856ca0 |= _0xab451e;\n      }\n    }\n  }\n\n  function _0xde61f3() private {\n    uint _0xeeb063 = 1;\n    while (_0xeeb063 < _0x2f1f77)\n    {\n      while (_0xeeb063 < _0x2f1f77 && _0xa4d3bd[_0xeeb063] != 0) _0xeeb063++;\n      while (_0x2f1f77 > 1 && _0xa4d3bd[_0x2f1f77] == 0) _0x2f1f77--;\n      if (_0xeeb063 < _0x2f1f77 && _0xa4d3bd[_0x2f1f77] != 0 && _0xa4d3bd[_0xeeb063] == 0)\n      {\n        _0xa4d3bd[_0xeeb063] = _0xa4d3bd[_0x2f1f77];\n        _0xdd7770[_0xa4d3bd[_0xeeb063]] = _0xeeb063;\n        _0xa4d3bd[_0x2f1f77] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function _0x18ac52(uint _0x580d8b) internal _0x5c5de1 returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (_0x914d6f() > _0x603a3f) {\n      _0x13ec5e = 0;\n      if (gasleft() > 0) { _0x603a3f = _0x914d6f(); }\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n\n    if (_0x13ec5e + _0x580d8b >= _0x13ec5e && _0x13ec5e + _0x580d8b <= _0x917ed8) {\n      _0x13ec5e += _0x580d8b;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function _0x914d6f() private constant returns (uint) { return _0xa1b476 / 1 days; }\n\n  function _0x27ea99() internal {\n    uint length = _0xa37cd0.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete _0x180611[_0xa37cd0[i]];\n\n      if (_0xa37cd0[i] != 0)\n        delete _0x843d43[_0xa37cd0[i]];\n    }\n\n    delete _0xa37cd0;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0x7b9b07;\n  // pointer used to find a free slot in m_owners\n  uint public _0x2f1f77;\n\n  uint public _0x917ed8;\n  uint public _0x13ec5e;\n  uint public _0x603a3f;\n\n  // list of owners\n  uint[256] _0xa4d3bd;\n\n  uint constant _0x731f8f = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) _0xdd7770;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) _0x843d43;\n  bytes32[] _0xa37cd0;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) _0x180611;\n}\n\ncontract Wallet is WalletEvents {\n\n  // WALLET CONSTRUCTOR\n  //   calls the `initWallet` method of the Library in this context\n  function Wallet(address[] _0x9e15be, uint _0x9e0f20, uint _0xa147ca) {\n    // Signature of the Wallet Library's init function\n    bytes4 sig = bytes4(_0xb6a970(\"initWallet(address[],uint256,uint256)\"));\n    address _0x11b2be = _walletLibrary;\n\n    // Compute the size of the call data : arrays has 2\n    // 32bytes for offset and length, plus 32bytes per element ;\n    // plus 2 32bytes for each uint\n    uint _0x68f4b8 = (2 + _0x9e15be.length);\n    uint _0x1fbd96 = (2 + _0x68f4b8) * 32;\n\n    assembly {\n      // Add the signature first to memory\n      mstore(0x0, sig)\n      // Add the call data, which is at the end of the\n      // code\n      _0x5506ee(0x4,  sub(_0x764de6, _0x1fbd96), _0x1fbd96)\n      // Delegate call to the library\n      delegatecall(sub(gas, 10000), _0x11b2be, 0x0, add(_0x1fbd96, 0x4), 0x0, 0x0)\n    }\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x49d3f2(uint _0x5f421c) constant returns (address) {\n    return address(_0xa4d3bd[_0x5f421c + 1]);\n  }\n\n  // As return statement unavailable in fallback, explicit the method here\n\n  function _0xdc0f9e(bytes32 _0x0fccab, address _0x897668) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function _0x2a5ccb(address _0xe35045) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0x7b9b07;\n  // pointer used to find a free slot in m_owners\n  uint public _0x2f1f77;\n\n  uint public _0x917ed8;\n  uint public _0x13ec5e;\n  uint public _0x603a3f;\n\n  // list of owners\n  uint[256] _0xa4d3bd;\n}",
      "rename_map": {
        "changeRequirement": "_0x602d7f",
        "invalidJumpLabel": "_0x843b98",
        "reorganizeOwners": "_0xde61f3",
        "confirmAndCheck": "_0xd85e2a",
        "resetSpentToday": "_0x41909f",
        "onlymanyowners": "_0x8a511b",
        "newRequirement": "_0xe8755a",
        "initMultiowned": "_0xfac781",
        "m_pendingIndex": "_0xa37cd0",
        "ownerIndexBit": "_0xab451e",
        "setDailyLimit": "_0x106c27",
        "clearPending": "_0x27ea99",
        "m_spentToday": "_0x13ec5e",
        "m_ownerIndex": "_0xdd7770",
        "argarraysize": "_0x68f4b8",
        "hasConfirmed": "_0xdc0f9e",
        "_newRequired": "_0x10728f",
        "initDaylimit": "_0xc32585",
        "m_dailyLimit": "_0x917ed8",
        "changeOwner": "_0xff1ccf",
        "m_numOwners": "_0x2f1f77",
        "removeOwner": "_0xa2ecc0",
        "c_maxOwners": "_0x731f8f",
        "_operation": "_0x0fccab",
        "ownerIndex": "_0x5f421c",
        "m_required": "_0x7b9b07",
        "initWallet": "_0x34d870",
        "underLimit": "_0x18ac52",
        "ownersDone": "_0x856ca0",
        "_daylimit": "_0xa147ca",
        "onlyowner": "_0x5c5de1",
        "o_success": "_0xb1b665",
        "initiator": "_0x3a1aa1",
        "operation": "_0x047efe",
        "_required": "_0x9e0f20",
        "yetNeeded": "_0x4f13e3",
        "m_lastDay": "_0x603a3f",
        "m_pending": "_0x843d43",
        "_newLimit": "_0x8d4ce5",
        "codecopy": "_0x5506ee",
        "codesize": "_0x764de6",
        "m_owners": "_0xa4d3bd",
        "newOwner": "_0x9b85d8",
        "getOwner": "_0x49d3f2",
        "addOwner": "_0xa6624c",
        "oldOwner": "_0x608176",
        "execute": "_0x346d31",
        "pending": "_0x546eab",
        "isOwner": "_0x2a5ccb",
        "confirm": "_0x8c432e",
        "created": "_0x51fb5f",
        "_owners": "_0x9e15be",
        "argsize": "_0x1fbd96",
        "target": "_0x11b2be",
        "_value": "_0x580d8b",
        "create": "_0x743173",
        "o_hash": "_0x0336b8",
        "o_addr": "_0xdb114b",
        "_limit": "_0x16cc77",
        "revoke": "_0x438973",
        "_owner": "_0x897668",
        "today": "_0x914d6f",
        "m_txs": "_0x180611",
        "_addr": "_0xe35045",
        "owner": "_0xa5bd8b",
        "_data": "_0x60d6c0",
        "index": "_0x7a33d4",
        "_code": "_0xd82707",
        "jumpi": "_0x7ee030",
        "_from": "_0xc2798b",
        "kill": "_0x174b53",
        "free": "_0xeeb063",
        "sha3": "_0xb6a970",
        "now": "_0xa1b476",
        "_to": "_0x370b27",
        "_h": "_0x31ee45",
        "to": "_0xacf947"
      },
      "changes": [
        "Renamed 77 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_123",
      "transformed_id": "ss_l3_medium_sn_ds_123",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// taken from https://www.ethereum.org/token#the-coin (4/9/2018)\n\npragma solidity ^0.4.16;\n\ncontract _0xa8fbd2 {\n    address public _0x06847e;\n\n    function _0xa8fbd2() public {\n        if (true) { _0x06847e = msg.sender; }\n    }\n\n    modifier _0x41145a {\n        require(msg.sender == _0x06847e);\n        _;\n    }\n\n    function _0xbf07be(address _0x145588) _0x41145a public {\n        _0x06847e = _0x145588;\n    }\n}\n\ninterface _0xf8b988 { function _0x21ed86(address _0x60b9e7, uint256 _0x6c7516, address _0x39dfc1, bytes _0xaa7b57) external; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public _0x039cc9;\n    string public _0x749381;\n    uint8 public _0xbe36c7 = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public _0x50ed08;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public _0xafb70b;\n    mapping (address => mapping (address => uint256)) public _0x0e879a;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed _0xf5ef76, uint256 value);\n\n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _0x55dbcc, address indexed _0x44c86c, uint256 _0x6c7516);\n\n    function TokenERC20(\n        string _0xcdfff1,\n        string _0x3022f5\n    ) public {\n        _0x039cc9 = _0xcdfff1;                                   // Set the name for display purposes\n        _0x749381 = _0x3022f5;                               // Set the symbol for display purposes\n    }\n\n    function _0xa9fbfb(address _0x60b9e7, address _0xdc7326, uint _0x6c7516) internal {\n        // Prevent transfer to 0x0 address.\n        require(_0xdc7326 != 0x0);\n        // Check if the sender has enough\n        require(_0xafb70b[_0x60b9e7] >= _0x6c7516);\n\n        require(_0xafb70b[_0xdc7326] + _0x6c7516 > _0xafb70b[_0xdc7326]);\n        // Save this for an assertion in the future\n        uint _0x08540c = _0xafb70b[_0x60b9e7] + _0xafb70b[_0xdc7326];\n        // Subtract from the sender\n        _0xafb70b[_0x60b9e7] -= _0x6c7516;\n        // Add the same to the recipient\n        _0xafb70b[_0xdc7326] += _0x6c7516;\n        emit Transfer(_0x60b9e7, _0xdc7326, _0x6c7516);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(_0xafb70b[_0x60b9e7] + _0xafb70b[_0xdc7326] == _0x08540c);\n    }\n\n    function transfer(address _0xdc7326, uint256 _0x6c7516) public returns (bool _0x9aeaf1) {\n        _0xa9fbfb(msg.sender, _0xdc7326, _0x6c7516);\n        return true;\n    }\n\n    function _0xa06c9f(address _0x60b9e7, address _0xdc7326, uint256 _0x6c7516) public returns (bool _0x9aeaf1) {\n        require(_0x6c7516 <= _0x0e879a[_0x60b9e7][msg.sender]);     // Check allowance\n        _0x0e879a[_0x60b9e7][msg.sender] -= _0x6c7516;\n        _0xa9fbfb(_0x60b9e7, _0xdc7326, _0x6c7516);\n        return true;\n    }\n\n    function _0x012ebd(address _0x44c86c, uint256 _0x6c7516) public\n        returns (bool _0x9aeaf1) {\n        _0x0e879a[msg.sender][_0x44c86c] = _0x6c7516;\n        emit Approval(msg.sender, _0x44c86c, _0x6c7516);\n        return true;\n    }\n\n    function _0x1b6800(address _0x44c86c, uint256 _0x6c7516, bytes _0xaa7b57)\n        public\n        returns (bool _0x9aeaf1) {\n        _0xf8b988 _0x1dc086 = _0xf8b988(_0x44c86c);\n        if (_0x012ebd(_0x44c86c, _0x6c7516)) {\n            _0x1dc086._0x21ed86(msg.sender, _0x6c7516, this, _0xaa7b57);\n            return true;\n        }\n    }\n\n}\n\n/******************************************/\n/*       ADVANCED TOKEN STARTS HERE       */\n/******************************************/\n\ncontract MyAdvancedToken is _0xa8fbd2, TokenERC20 {\n\n    mapping (address => bool) public _0x8e6b7b;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address _0x8f271a, bool _0xfbfe0d);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function MyAdvancedToken(\n        string _0xcdfff1,\n        string _0x3022f5\n    ) TokenERC20(_0xcdfff1, _0x3022f5) public {}\n\n    /* Internal transfer, only can be called by this contract */\n    function _0xa9fbfb(address _0x60b9e7, address _0xdc7326, uint _0x6c7516) internal {\n        require (_0xdc7326 != 0x0);                               // Prevent transfer to 0x0 address.\n        require (_0xafb70b[_0x60b9e7] >= _0x6c7516);               // Check if the sender has enough\n        require (_0xafb70b[_0xdc7326] + _0x6c7516 >= _0xafb70b[_0xdc7326]);\n        require(!_0x8e6b7b[_0x60b9e7]);                     // Check if sender is frozen\n        require(!_0x8e6b7b[_0xdc7326]);                       // Check if recipient is frozen\n        _0xafb70b[_0x60b9e7] -= _0x6c7516;                         // Subtract from the sender\n        _0xafb70b[_0xdc7326] += _0x6c7516;                           // Add the same to the recipient\n        emit Transfer(_0x60b9e7, _0xdc7326, _0x6c7516);\n    }\n\n    /// @notice Buy tokens from contract by sending ether\n    function _0x88a088() payable public {\n        uint _0xf1ff9a = msg.value;                          // calculates the amount\n\t_0xafb70b[msg.sender] += _0xf1ff9a;                  // updates the balance\n        _0x50ed08 += _0xf1ff9a;                            // updates the total supply\n        _0xa9fbfb(address(0x0), msg.sender, _0xf1ff9a);      // makes the transfer\n    }\n\n    /* Migration function */\n    function _0x1baa82() _0x41145a {\n\tassert(this.balance == _0x50ed08);                 // consistency check\n\tsuicide(_0x06847e);                                      // transfer the ether to the owner and kill the contract\n    }\n}",
      "rename_map": {
        "migrate_and_destroy": "_0x1baa82",
        "transferOwnership": "_0xbf07be",
        "previousBalances": "_0x08540c",
        "receiveApproval": "_0x21ed86",
        "tokenRecipient": "_0xf8b988",
        "approveAndCall": "_0x1b6800",
        "frozenAccount": "_0x8e6b7b",
        "transferFrom": "_0xa06c9f",
        "totalSupply": "_0x50ed08",
        "tokenSymbol": "_0x3022f5",
        "_extraData": "_0xaa7b57",
        "balanceOf": "_0xafb70b",
        "_transfer": "_0xa9fbfb",
        "tokenName": "_0xcdfff1",
        "onlyOwner": "_0x41145a",
        "allowance": "_0x0e879a",
        "_spender": "_0x44c86c",
        "newOwner": "_0x145588",
        "decimals": "_0xbe36c7",
        "spender": "_0x1dc086",
        "approve": "_0x012ebd",
        "success": "_0x9aeaf1",
        "target": "_0x8f271a",
        "_value": "_0x6c7516",
        "_token": "_0x39dfc1",
        "frozen": "_0xfbfe0d",
        "amount": "_0xf1ff9a",
        "_owner": "_0x55dbcc",
        "symbol": "_0x749381",
        "owner": "_0x06847e",
        "owned": "_0xa8fbd2",
        "_from": "_0x60b9e7",
        "name": "_0x039cc9",
        "buy": "_0x88a088",
        "_to": "_0xdc7326",
        "to": "_0xf5ef76"
      },
      "changes": [
        "Renamed 36 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_124",
      "transformed_id": "ss_l3_medium_sn_ds_124",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Alice {\n    function _0x22333a(uint);\n    function _0x8c9ddc(int);\n}\n\ncontract Bob {\n    function _0x22333a(Alice c){\n        c._0x22333a(42);\n    }\n\n    function _0x8c9ddc(Alice c){\n        c._0x8c9ddc(42);\n    }\n}",
      "rename_map": {
        "setV2": "_0x8c9ddc",
        "set": "_0x22333a"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_125",
      "transformed_id": "ss_l3_medium_sn_ds_125",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private _0x95c016;\n\n    modifier _0x935909 {\n        require(msg.sender==_0x95c016);\n        _;\n    }\n\n    // The name of the constructor should be Missing\n\n    function IamMissing()\n        public\n    {\n        _0x95c016 = msg.sender;\n    }\n\n    function () payable {}\n\n    function _0x9f4420()\n        public\n        _0x935909\n    {\n       _0x95c016.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "_0x935909",
        "withdraw": "_0x9f4420",
        "owner": "_0x95c016"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_126",
      "transformed_id": "ss_l3_medium_sn_ds_126",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private _0xfd2556;\n\n    modifier _0x7e1621 {\n        require(msg.sender==_0xfd2556);\n        _;\n    }\n    function _0x1ce4f8()\n        public\n    {\n        _0xfd2556 = msg.sender;\n    }\n\n    function () payable {}\n\n    function _0xd054f8()\n        public\n        _0x7e1621\n    {\n       _0xfd2556.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "_0x7e1621",
        "withdraw": "_0xd054f8",
        "missing": "_0x1ce4f8",
        "owner": "_0xfd2556"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_127",
      "transformed_id": "ss_l3_medium_sn_ds_127",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private _0x97a9f7;\n\n    modifier _0x682e7f {\n        require(msg.sender==_0x97a9f7);\n        _;\n    }\n    function Constructor()\n        public\n    {\n        _0x97a9f7 = msg.sender;\n    }\n\n    function () payable {}\n\n    function _0x12ca8d()\n        public\n        _0x682e7f\n    {\n       _0x97a9f7.transfer(this.balance);\n    }\n\n}",
      "rename_map": {
        "onlyowner": "_0x682e7f",
        "withdraw": "_0x12ca8d",
        "owner": "_0x97a9f7"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_128",
      "transformed_id": "ss_l3_medium_sn_ds_128",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract MultiOwnable {\n  address public _0x4d60df;\n  mapping (address => address) public _0xc26a5e; // owner => parent of owner\n\n  constructor() public {\n    _0x4d60df = msg.sender;\n    _0xc26a5e[_0x4d60df] = _0x4d60df;\n  }\n\n  modifier _0x49b460() {\n    require(_0xc26a5e[msg.sender] != 0);\n    _;\n  }\n\n  function _0xd91b76(address _0x7ed0cf) external returns (bool) {\n    require(_0x7ed0cf != 0);\n    _0xc26a5e[_0x7ed0cf] = msg.sender;\n    return true;\n  }\n\n  function _0xa7dc1e(address _0x7ed0cf) _0x49b460 external returns (bool) {\n    require(_0xc26a5e[_0x7ed0cf] == msg.sender || (_0xc26a5e[_0x7ed0cf] != 0 && msg.sender == _0x4d60df));\n    _0xc26a5e[_0x7ed0cf] = 0;\n    return true;\n  }\n}\n\ncontract TestContract is MultiOwnable {\n\n  function _0x6b728c() _0x49b460 {\n    msg.sender.transfer(this.balance);\n  }\n\n  function() payable {\n  }\n\n}\n",
      "rename_map": {
        "withdrawAll": "_0x6b728c",
        "deleteOwner": "_0xa7dc1e",
        "onlyOwner": "_0x49b460",
        "newOwner": "_0xd91b76",
        "_owner": "_0x7ed0cf",
        "owners": "_0xc26a5e",
        "root": "_0x4d60df"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_129",
      "transformed_id": "ss_l3_medium_sn_ds_129",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": " pragma solidity ^0.4.15;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private _0x6656e0 = 0;\n         uint private _0xc37988 = 10;\n         uint private _0x6f45e6 = 300;\n         uint private _0xf6cc9a = 0;\n\n         address private _0xa99407;\n\n         //Sets creator\n         function DynamicPyramid() {\n                 _0xa99407 = msg.sender;\n         }\n\n         modifier _0x839800 {\n                 if (msg.sender == _0xa99407) _;\n         }\n\n         struct Participant {\n                 address _0x219526;\n                 uint _0xd29d61;\n         }\n\n         Participant[] private _0x10d580;\n\n         //Fallback function\n         function() {\n                 _0x424077();\n         }\n\n         //init function run on fallback\n         function _0x424077() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         _0x6656e0 += msg.value;\n                         return;\n                 }\n\n                 uint _0xbab297 = _0xc37988;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _0xbab297 /= 2;\n\n                 _0xe9348d(_0xbab297);\n         }\n\n         //Function called for valid tx to the contract\n         function _0xe9348d(uint _0xbab297) private {\n                 //Adds new address to participant array\n                 _0x10d580.push(Participant(msg.sender, (msg.value * _0x6f45e6) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (_0x10d580.length == 10) _0x6f45e6 = 200;\n                 else if (_0x10d580.length == 25) _0x6f45e6 = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _0xbab297)) / 100;\n                 _0x6656e0 += (msg.value * _0xbab297) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > _0x10d580[_0xf6cc9a]._0xd29d61) {\n                         uint _0xac7871 = _0x10d580[_0xf6cc9a]._0xd29d61;\n                         _0x10d580[_0xf6cc9a]._0x219526.send(_0xac7871);\n\n                         balance -= _0x10d580[_0xf6cc9a]._0xd29d61;\n                         _0xf6cc9a += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function _0x924e34() _0x839800 {\n                 if (_0x6656e0 == 0) throw;\n\n                 _0xa99407.send(_0x6656e0);\n                 if (block.timestamp > 0) { _0x6656e0 = 0; }\n         }\n\n         function _0x58b48a(uint _0xcd2c2a) _0x839800 {\n                 _0xcd2c2a *= 1 ether;\n                 if (_0xcd2c2a > _0x6656e0) _0x924e34();\n\n                 if (_0x6656e0 == 0) throw;\n\n                 _0xa99407.send(_0xcd2c2a);\n                 _0x6656e0 -= _0xcd2c2a;\n         }\n\n         function _0x51cd1f(uint _0x367df9) _0x839800 {\n                 if (_0x6656e0 == 0 || _0x367df9 > 100) throw;\n\n                 uint _0xb538ab = _0x6656e0 / 100 * _0x367df9;\n                 _0xa99407.send(_0xb538ab);\n                 _0x6656e0 -= _0xb538ab;\n         }\n\n         //Functions for changing variables related to the contract\n         function _0x11b6f0(address _0xcddc0d) _0x839800 {\n                 if (block.timestamp > 0) { _0xa99407 = _0xcddc0d; }\n         }\n\n         function _0xdcb1dc(uint _0xa9f573) _0x839800 {\n                 if (_0xa9f573 > 300 || _0xa9f573 < 120) throw;\n\n                 if (gasleft() > 0) { _0x6f45e6 = _0xa9f573; }\n         }\n\n         function _0x017926(uint _0xbab297) _0x839800 {\n                 if (_0xbab297 > 10) throw;\n\n                 _0xc37988 = _0xbab297;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function _0x9a66a2() constant returns(uint _0x3be93b, string _0xf3413a) {\n                 if (block.timestamp > 0) { _0x3be93b = _0x6f45e6; }\n                 if (block.timestamp > 0) { _0xf3413a = 'This _0x3be93b applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, _0x3be93b is x100 for a fractional _0x3be93b e.g. 250 is actually a 2.5x _0x3be93b. Capped at 3x max and 1.2x min.'; }\n         }\n\n         function _0x5a36c9() constant returns(uint _0xa6af64, string _0xf3413a) {\n                 if (true) { _0xa6af64 = _0xc37988; }\n                 _0xf3413a = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function _0xf237ac() constant returns(uint _0x1bd279, string _0xf3413a) {\n                 _0x1bd279 = balance / 1 ether;\n                 _0xf3413a = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function _0xe41a75() constant returns(uint _0x100b0e) {\n                 if (1 == 1) { _0x100b0e = _0x10d580[_0xf6cc9a]._0xd29d61 / 1 ether; }\n         }\n\n         function _0xec57c3() constant returns(uint _0xa491ab) {\n                 if (block.timestamp > 0) { _0xa491ab = _0x6656e0 / 1 ether; }\n         }\n\n         function _0xc54add() constant returns(uint _0x9f8e80) {\n                 _0x9f8e80 = _0x10d580.length;\n         }\n\n         function _0xfa143f() constant returns(uint _0x9f8e80) {\n                 _0x9f8e80 = _0x10d580.length - _0xf6cc9a;\n         }\n\n         function _0x4db053(uint _0x87567e) constant returns(address Address, uint Payout) {\n                 if (_0x87567e <= _0x10d580.length) {\n                         if (1 == 1) { Address = _0x10d580[_0x87567e]._0x219526; }\n                         Payout = _0x10d580[_0x87567e]._0xd29d61 / 1 ether;\n                 }\n         }\n }\n",
      "rename_map": {
        "nextPayoutWhenPyramidBalanceTotalsApproximately": "_0xe41a75",
        "numberOfParticipantsWaitingForPayout": "_0xfa143f",
        "feesSeperateFromBalanceApproximately": "_0xec57c3",
        "currentPyramidBalanceApproximately": "_0xf237ac",
        "currentFeePercentage": "_0x5a36c9",
        "collectPercentOfFees": "_0x51cd1f",
        "changeFeePercentage": "_0x017926",
        "participantDetails": "_0x4db053",
        "collectFeesInEther": "_0x58b48a",
        "pyramidMultiplier": "_0x6f45e6",
        "totalParticipants": "_0xc54add",
        "currentMultiplier": "_0x9a66a2",
        "changeMultiplier": "_0xdcb1dc",
        "orderInPyramid": "_0x87567e",
        "collectAllFees": "_0x924e34",
        "pyramidBalance": "_0x1bd279",
        "collectedFees": "_0x6656e0",
        "feesToCollect": "_0xb538ab",
        "balancePayout": "_0x100b0e",
        "payoutToSend": "_0xac7871",
        "etherAddress": "_0x219526",
        "participants": "_0x10d580",
        "changeOwner": "_0x11b6f0",
        "payoutOrder": "_0xf6cc9a",
        "multiplier": "_0x3be93b",
        "feePercent": "_0xc37988",
        "addPayout": "_0xe9348d",
        "onlyowner": "_0x839800",
        "creator": "_0xa99407",
        "_owner": "_0xcddc0d",
        "payout": "_0xd29d61",
        "_pcent": "_0x367df9",
        "_mult": "_0xa9f573",
        "count": "_0x9f8e80",
        "fees": "_0xa491ab",
        "_amt": "_0xcd2c2a",
        "info": "_0xf3413a",
        "_fee": "_0xbab297",
        "init": "_0x424077",
        "fee": "_0xa6af64"
      },
      "changes": [
        "Renamed 40 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_130",
      "transformed_id": "ss_l3_medium_sn_ds_130",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n contract OpenAccess{\n     address private _0xd226b0;\n\n     modifier _0x14f842 {\n         require(msg.sender==_0xd226b0);\n         _;\n     }\n\n     function OpenAccess()\n         public\n     {\n         _0xd226b0 = msg.sender;\n     }\n\n     // This function should be protected\n     function _0x0e5790(address _0x85cb3b)\n         public\n     {\n        _0xd226b0 = _0x85cb3b;\n     }\n\n }",
      "rename_map": {
        "changeOwner": "_0x0e5790",
        "_newOwner": "_0x85cb3b",
        "onlyowner": "_0x14f842",
        "owner": "_0xd226b0"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_131",
      "transformed_id": "ss_l3_medium_sn_ds_131",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.10;\n\ncontract AdditionCounter {\n    mapping (address => uint256) public _0x1229c4;\n\n    function transfer(address _0x079e34, uint256 _0x482e07) public{\n        /* Check if sender has balance */\n        require(_0x1229c4[msg.sender] >= _0x482e07);\n        _0x1229c4[msg.sender] -= _0x482e07;\n        _0x1229c4[_0x079e34] += _0x482e07;\n}\n\n}",
      "rename_map": {
        "balanceOf": "_0x1229c4",
        "_value": "_0x482e07",
        "_to": "_0x079e34"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_132",
      "transformed_id": "ss_l3_medium_sn_ds_132",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n contract Ledger {\n     uint private _0xef077d=0;\n\n     function _0x40a83e(uint value) returns (bool){\n         _0xef077d += value;\n\n         // possible auditor assert\n         // assert(sellerBalance >= value);\n     }\n\n  // function safe_add(uint value) returns (bool){\n  //   require(value + sellerBalance >= sellerBalance);\n  // sellerBalance += value;\n  // }\n }",
      "rename_map": {
        "sellerBalance": "_0xef077d",
        "add": "_0x40a83e"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_133",
      "transformed_id": "ss_l3_medium_sn_ds_133",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract AdditionCounter {\n    uint public _0x1168fa = 1;\n\n    function _0xd34501(uint256 _0x84917d) public {\n        _0x1168fa += _0x84917d;\n    }\n}\n",
      "rename_map": {
        "count": "_0x1168fa",
        "input": "_0x84917d",
        "run": "_0xd34501"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_134",
      "transformed_id": "ss_l3_medium_sn_ds_134",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract BenignCounter {\n    uint public _0x929862 = 1;\n\n    function _0x2b6a2f(uint256 _0x82de77) public {\n        uint _0x98c684 = _0x929862 - _0x82de77;\n    }\n}\n",
      "rename_map": {
        "count": "_0x929862",
        "input": "_0x82de77",
        "run": "_0x2b6a2f",
        "res": "_0x98c684"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_135",
      "transformed_id": "ss_l3_medium_sn_ds_135",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.11;\n\ncontract MappingCounter {\n    mapping(uint256 => uint256) _0x8d6356;\n\n    function _0x63cf5b(uint256 k, uint256 v) public {\n        _0x8d6356[k] -= v;\n    }\n}\n",
      "rename_map": {
        "init": "_0x63cf5b",
        "map": "_0x8d6356"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_136",
      "transformed_id": "ss_l3_medium_sn_ds_136",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract MinimalCounter {\n    uint public _0xc8f0cc = 1;\n\n    function _0x2e5f59(uint256 _0x109900) public {\n        _0xc8f0cc -= _0x109900;\n    }\n}\n",
      "rename_map": {
        "count": "_0xc8f0cc",
        "input": "_0x109900",
        "run": "_0x2e5f59"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_137",
      "transformed_id": "ss_l3_medium_sn_ds_137",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract MultiplyCounter {\n    uint public _0x3114af = 2;\n\n    function _0x450c4d(uint256 _0xcef5c5) public {\n        _0x3114af *= _0xcef5c5;\n    }\n}\n",
      "rename_map": {
        "count": "_0x3114af",
        "input": "_0xcef5c5",
        "run": "_0x450c4d"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_138",
      "transformed_id": "ss_l3_medium_sn_ds_138",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract MultiTxCalculator {\n    uint256 private _0xb7526a = 0;\n    uint256 public _0xa292fe = 1;\n\n    function _0xf0e73c() public {\n        if (1 == 1) { _0xb7526a = 1; }\n    }\n\n    function _0xb5ffce(uint256 _0x627f6f) {\n        if (_0xb7526a == 0) {\n            return;\n        }\n        _0xa292fe -= _0x627f6f;\n    }\n}\n",
      "rename_map": {
        "initialized": "_0xb7526a",
        "input": "_0x627f6f",
        "count": "_0xa292fe",
        "init": "_0xf0e73c",
        "run": "_0xb5ffce"
      },
      "changes": [
        "Renamed 5 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_139",
      "transformed_id": "ss_l3_medium_sn_ds_139",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract SingleFuncCalculator {\n    uint256 private _0x10a488 = 0;\n    uint256 public _0xbbb039 = 1;\n\n    function _0xfb714e(uint256 _0x5b6008) public {\n        if (_0x10a488 == 0) {\n            _0x10a488 = 1;\n            return;\n        }\n        _0xbbb039 -= _0x5b6008;\n    }\n}\n",
      "rename_map": {
        "initialized": "_0x10a488",
        "input": "_0x5b6008",
        "count": "_0xbbb039",
        "run": "_0xfb714e"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_140",
      "transformed_id": "ss_l3_medium_sn_ds_140",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.4.25;\n\ncontract AdditionLedger {\n    uint public balance = 1;\n\n    function _0x8e026a(uint256 _0x39a8de) public {\n        balance += _0x39a8de;\n    }\n}",
      "rename_map": {
        "deposit": "_0x39a8de",
        "add": "_0x8e026a"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_141",
      "transformed_id": "ss_l3_medium_sn_ds_141",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.23;\n\ncontract SingleTxCounter {\n    uint public _0x546a19 = 1;\n\n    function _0x4af64f(uint256 _0x1ffc19) public {\n        _0x546a19 += _0x1ffc19;\n    }\n\n    function _0xf1e99b(uint256 _0x1ffc19) public {\n        _0x546a19 *= _0x1ffc19;\n    }\n\n    function _0xd6d216(uint256 _0x1ffc19) public {\n        _0x546a19 -= _0x1ffc19;\n    }\n\n    function _0xd3e8e6(uint256 _0x1ffc19) public {\n        uint _0x85c777 = _0x546a19 + _0x1ffc19;\n    }\n\n    function _0xd222ff(uint256 _0x1ffc19) public {\n        uint _0x85c777 = _0x546a19 * _0x1ffc19;\n    }\n\n    function _0xccf491(uint256 _0x1ffc19) public {\n       \tuint _0x85c777 = _0x546a19 - _0x1ffc19;\n    }\n\n}\n",
      "rename_map": {
        "underflowlocalonly": "_0xccf491",
        "underflowtostate": "_0xd6d216",
        "mullocalonly": "_0xd222ff",
        "addtostate": "_0x4af64f",
        "multostate": "_0xf1e99b",
        "localcalc": "_0xd3e8e6",
        "input": "_0x1ffc19",
        "count": "_0x546a19",
        "res": "_0x85c777"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_142",
      "transformed_id": "ss_l3_medium_sn_ds_142",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": " pragma solidity ^0.4.10;\n\n contract TimeLock {\n\n     mapping(address => uint) public _0x1a2acf;\n     mapping(address => uint) public _0xe1dfb4;\n\n     function _0x4854cb() public payable {\n         _0x1a2acf[msg.sender] += msg.value;\n         _0xe1dfb4[msg.sender] = _0x8a9596 + 1 weeks;\n     }\n\n     function _0x55149a(uint _0x0b53c5) public {\n         _0xe1dfb4[msg.sender] += _0x0b53c5;\n     }\n\n     function _0x40d902() public {\n         require(_0x1a2acf[msg.sender] > 0);\n         require(_0x8a9596 > _0xe1dfb4[msg.sender]);\n         uint _0x350184 = _0x1a2acf[msg.sender];\n         _0x1a2acf[msg.sender] = 0;\n         msg.sender.transfer(_0x350184);\n     }\n }\n",
      "rename_map": {
        "_secondsToIncrease": "_0x0b53c5",
        "increaseLockTime": "_0x55149a",
        "transferValue": "_0x350184",
        "lockTime": "_0xe1dfb4",
        "balances": "_0x1a2acf",
        "withdraw": "_0x40d902",
        "deposit": "_0x4854cb",
        "now": "_0x8a9596"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_143",
      "transformed_id": "ss_l3_medium_sn_ds_143",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) _0x727d18;\n   uint public _0xc7f886;\n\n   function Token(uint _0x89be70) {\n     _0x727d18[msg.sender] = _0xc7f886 = _0x89be70;\n   }\n\n   function transfer(address _0x7c2d08, uint _0x3eceb5) public returns (bool) {\n     require(_0x727d18[msg.sender] - _0x3eceb5 >= 0);\n     _0x727d18[msg.sender] -= _0x3eceb5;\n     _0x727d18[_0x7c2d08] += _0x3eceb5;\n     return true;\n   }\n\n   function _0xc6781e(address _0xe3fb9b) public constant returns (uint balance) {\n     return _0x727d18[_0xe3fb9b];\n   }\n }",
      "rename_map": {
        "_initialSupply": "_0x89be70",
        "totalSupply": "_0xc7f886",
        "balanceOf": "_0xc6781e",
        "balances": "_0x727d18",
        "_owner": "_0xe3fb9b",
        "_value": "_0x3eceb5",
        "_to": "_0x7c2d08"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_144",
      "transformed_id": "ss_l3_medium_sn_ds_144",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public _0x3dfa65;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _0x880aa9) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function _0x7ba127() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function _0x6215a6(uint256 _0x07cd20) public payable {\n        require(msg.value == _0x07cd20 * PRICE_PER_TOKEN);\n        _0x3dfa65[msg.sender] += _0x07cd20;\n    }\n\n    function _0xf43d63(uint256 _0x07cd20) public {\n        require(_0x3dfa65[msg.sender] >= _0x07cd20);\n\n        _0x3dfa65[msg.sender] -= _0x07cd20;\n        msg.sender.transfer(_0x07cd20 * PRICE_PER_TOKEN);\n    }\n}",
      "rename_map": {
        "isComplete": "_0x7ba127",
        "balanceOf": "_0x3dfa65",
        "numTokens": "_0x07cd20",
        "_player": "_0x880aa9",
        "sell": "_0xf43d63",
        "buy": "_0x6215a6"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_145",
      "transformed_id": "ss_l3_medium_sn_ds_145",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address _0x8f0f94;\n        uint _0x1b8032;\n    }\n\n    event RaffleResult(\n        uint _0x1b8032,\n        uint _0x297ade,\n        address _0x5b1c3d,\n        address _0x3a96d1,\n        address _0x63a710,\n        uint _0x238719,\n        bytes32 _0x10aded\n    );\n\n    event TicketPurchase(\n        uint _0x1b8032,\n        address _0xa50cd3,\n        uint number\n    );\n\n    event TicketRefund(\n        uint _0x1b8032,\n        address _0xa50cd3,\n        uint number\n    );\n\n    // Constants\n    uint public constant _0x67f21c = 2.5 ether;\n    uint public constant _0xef2e25 = 0.03 ether;\n    uint public constant _0x60a34f = 50;\n    uint public constant _0xcc56f0 = (_0x67f21c + _0xef2e25) / _0x60a34f; // Make sure this divides evenly\n    address _0xb25c64;\n\n    // Other internal variables\n    bool public _0xfda4d2 = false;\n    uint public _0x1b8032 = 1;\n    uint public _0xbd1e29 = block.number;\n    uint _0x731b13 = 0;\n    mapping (uint => Contestant) _0xe416dd;\n    uint[] _0x1f4dd2;\n\n    // Initialization\n    function Ethraffle_v4b() public {\n        _0xb25c64 = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        _0x99aa50();\n    }\n\n    function _0x99aa50() payable public {\n        if (_0xfda4d2) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint _0x6682bb = msg.value;\n\n        while (_0x6682bb >= _0xcc56f0 && _0x731b13 < _0x60a34f) {\n            uint _0x077f80 = 0;\n            if (_0x1f4dd2.length > 0) {\n                _0x077f80 = _0x1f4dd2[_0x1f4dd2.length-1];\n                _0x1f4dd2.length--;\n            } else {\n                _0x077f80 = _0x731b13++;\n            }\n\n            _0xe416dd[_0x077f80] = Contestant(msg.sender, _0x1b8032);\n            TicketPurchase(_0x1b8032, msg.sender, _0x077f80);\n            _0x6682bb -= _0xcc56f0;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (_0x731b13 == _0x60a34f) {\n            _0xb1f797();\n        }\n\n        // Send back leftover money\n        if (_0x6682bb > 0) {\n            msg.sender.transfer(_0x6682bb);\n        }\n    }\n\n    function _0xb1f797() private {\n        address _0x3a96d1 = _0xe416dd[uint(block.coinbase) % _0x60a34f]._0x8f0f94;\n        address _0x63a710 = _0xe416dd[uint(msg.sender) % _0x60a34f]._0x8f0f94;\n        uint _0x238719 = block.difficulty;\n        bytes32 _0x10aded = _0x9960e3(_0x3a96d1, _0x63a710, _0x238719);\n\n        uint _0x297ade = uint(_0x10aded) % _0x60a34f;\n        address _0x5b1c3d = _0xe416dd[_0x297ade]._0x8f0f94;\n        RaffleResult(_0x1b8032, _0x297ade, _0x5b1c3d, _0x3a96d1, _0x63a710, _0x238719, _0x10aded);\n\n        // Start next raffle\n        _0x1b8032++;\n        _0x731b13 = 0;\n        _0xbd1e29 = block.number;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        _0x5b1c3d.transfer(_0x67f21c);\n        _0xb25c64.transfer(_0xef2e25);\n    }\n\n    // Get your money back before the raffle occurs\n    function _0xedd90d() public {\n        uint _0x42d900 = 0;\n        for (uint i = 0; i < _0x60a34f; i++) {\n            if (msg.sender == _0xe416dd[i]._0x8f0f94 && _0x1b8032 == _0xe416dd[i]._0x1b8032) {\n                _0x42d900 += _0xcc56f0;\n                _0xe416dd[i] = Contestant(address(0), 0);\n                _0x1f4dd2.push(i);\n                TicketRefund(_0x1b8032, msg.sender, i);\n            }\n        }\n\n        if (_0x42d900 > 0) {\n            msg.sender.transfer(_0x42d900);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function _0x2361fd() public {\n        if (msg.sender == _0xb25c64) {\n            _0xfda4d2 = true;\n\n            for (uint i = 0; i < _0x60a34f; i++) {\n                if (_0x1b8032 == _0xe416dd[i]._0x1b8032) {\n                    TicketRefund(_0x1b8032, _0xe416dd[i]._0x8f0f94, i);\n                    _0xe416dd[i]._0x8f0f94.transfer(_0xcc56f0);\n                }\n            }\n\n            RaffleResult(_0x1b8032, _0x60a34f, address(0), address(0), address(0), 0, 0);\n            _0x1b8032++;\n            _0x731b13 = 0;\n            if (true) { _0xbd1e29 = block.number; }\n            _0x1f4dd2.length = 0;\n        }\n    }\n\n    function _0x9d1d37() public {\n        if (msg.sender == _0xb25c64) {\n            if (msg.sender != address(0) || msg.sender == address(0)) { _0xfda4d2 = !_0xfda4d2; }\n        }\n    }\n\n    function _0xe6d514() public {\n        if (msg.sender == _0xb25c64) {\n            selfdestruct(_0xb25c64);\n        }\n    }\n}",
      "rename_map": {
        "pricePerTicket": "_0xcc56f0",
        "winningAddress": "_0x5b1c3d",
        "winningNumber": "_0x297ade",
        "totalTickets": "_0x60a34f",
        "chooseWinner": "_0xb1f797",
        "contestants": "_0xe416dd",
        "blockNumber": "_0xbd1e29",
        "togglePause": "_0x9d1d37",
        "buyTickets": "_0x99aa50",
        "currTicket": "_0x077f80",
        "contestant": "_0xa50cd3",
        "nextTicket": "_0x731b13",
        "feeAddress": "_0xb25c64",
        "moneySent": "_0x6682bb",
        "endRaffle": "_0x2361fd",
        "keccak256": "_0x9960e3",
        "getRefund": "_0xedd90d",
        "randHash": "_0x10aded",
        "raffleId": "_0x1b8032",
        "refund": "_0x42d900",
        "paused": "_0xfda4d2",
        "seed1": "_0x3a96d1",
        "seed3": "_0x238719",
        "seed2": "_0x63a710",
        "prize": "_0x67f21c",
        "kill": "_0xe6d514",
        "gaps": "_0x1f4dd2",
        "addr": "_0x8f0f94",
        "fee": "_0xef2e25"
      },
      "changes": [
        "Renamed 29 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_146",
      "transformed_id": "ss_l3_medium_sn_ds_146",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 _0xfb240d;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n        _0xfb240d = uint8(_0xb35262(block.blockhash(block.number - 1), _0x04fbdd));\n    }\n\n    function _0x90147d() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function _0x1d295e(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == _0xfb240d) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
      "rename_map": {
        "isComplete": "_0x90147d",
        "keccak256": "_0xb35262",
        "answer": "_0xfb240d",
        "guess": "_0x1d295e",
        "now": "_0x04fbdd"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_147",
      "transformed_id": "ss_l3_medium_sn_ds_147",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "  pragma solidity ^0.4.0;\n\n contract Lottery {\n     event GetBet(uint _0x9afe67, uint _0xa353dc, bool _0x843c9e);\n\n     struct Bet {\n         uint _0x9afe67;\n         uint _0xa353dc;\n         bool _0x843c9e;\n     }\n\n     address private _0xb060b7;\n     Bet[] private _0xe737bf;\n\n     // Create a new lottery with numOfBets supported bets.\n     function Lottery() {\n         _0xb060b7 = msg.sender;\n     }\n\n     // Fallback function returns ether\n     function() {\n         throw;\n     }\n\n     // Make a bet\n     function _0x5377b6() {\n         // Won if block number is even\n\n         bool _0x843c9e = (block.number % 2) == 0;\n\n         // Record the bet with an event\n         _0xe737bf.push(Bet(msg.value, block.number, _0x843c9e));\n\n         // Payout if the user won, otherwise take their money\n         if(_0x843c9e) {\n             if(!msg.sender.send(msg.value)) {\n                 // Return ether to sender\n                 throw;\n             }\n         }\n     }\n\n     // Get all bets that have been made\n     function _0xe2b930() {\n         if(msg.sender != _0xb060b7) { throw; }\n\n         for (uint i = 0; i < _0xe737bf.length; i++) {\n             GetBet(_0xe737bf[i]._0x9afe67, _0xe737bf[i]._0xa353dc, _0xe737bf[i]._0x843c9e);\n         }\n     }\n\n     function _0x9d08e0() {\n         if(msg.sender != _0xb060b7) { throw; }\n\n         suicide(_0xb060b7);\n     }\n }\n",
      "rename_map": {
        "blockNumber": "_0xa353dc",
        "organizer": "_0xb060b7",
        "betAmount": "_0x9afe67",
        "makeBet": "_0x5377b6",
        "getBets": "_0xe2b930",
        "destroy": "_0x9d08e0",
        "bets": "_0xe737bf",
        "won": "_0x843c9e"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_148",
      "transformed_id": "ss_l3_medium_sn_ds_148",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\n    struct _0x58100b{\n      uint block;\n      bytes32 _0x58100b;\n    }\n\n    mapping(address => _0x58100b) _0xabfa50;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function _0xe6bedb(bytes32 _0x6b42c6) public payable {\n        require(_0xabfa50[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        _0xabfa50[msg.sender]._0x58100b = _0x6b42c6;\n        _0xabfa50[msg.sender].block  = block.number + 1;\n    }\n\n    function _0x4c0197() public {\n        require(block.number > _0xabfa50[msg.sender].block);\n        bytes32 _0x651797 = blockhash(_0xabfa50[msg.sender].block);\n\n        _0xabfa50[msg.sender].block = 0;\n        if (_0xabfa50[msg.sender]._0x58100b == _0x651797) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
      "rename_map": {
        "lockInGuess": "_0xe6bedb",
        "guesses": "_0xabfa50",
        "settle": "_0x4c0197",
        "answer": "_0x651797",
        "guess": "_0x58100b",
        "hash": "_0x6b42c6"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_149",
      "transformed_id": "ss_l3_medium_sn_ds_149",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\n  uint256 private _0xfedb5d =  block.timestamp;\n\n  function _0x20cebc(uint _0x474d25) view private returns (uint256 _0x90d6b2) {\n    // Get the best seed for randomness\n    uint256 x = _0xfedb5d * 100 / _0x474d25;\n    uint256 y = _0xfedb5d * block.number / (_0xfedb5d % 5);\n    uint256 _0x829119 = block.number / 3 + (_0xfedb5d % 300) + y;\n    uint256 h = uint256(blockhash(_0x829119));\n    // Random number between 1 and max\n    return uint256((h / x)) % _0x474d25 + 1;\n  }\n}",
      "rename_map": {
        "random": "_0x20cebc",
        "result": "_0x90d6b2",
        "salt": "_0xfedb5d",
        "seed": "_0x829119",
        "max": "_0x474d25"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_150",
      "transformed_id": "ss_l3_medium_sn_ds_150",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address _0x21d339;\n  uint _0xf6d3f7;\n\n  function _0x84707d() payable {\n    require(msg.value > _0xf6d3f7);\n\n    //If the refund fails, the entire transaction reverts.\n\n    if (_0x21d339 != 0) {\n      //E.g. if recipients fallback function is just revert()\n      require(_0x21d339.send(_0xf6d3f7));\n    }\n\n    _0x21d339 = msg.sender;\n    if (gasleft() > 0) { _0xf6d3f7         = msg.value; }\n  }\n}",
      "rename_map": {
        "currentFrontrunner": "_0x21d339",
        "currentBid": "_0xf6d3f7",
        "bid": "_0x84707d"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_151",
      "transformed_id": "ss_l3_medium_sn_ds_151",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract GasAuction {\n\n    address[] _0x6cf68d;\n    bool _0xc9e4ba = false;\n\n    function _0x84eb19() public {\n        if(_0x6cf68d.length>1500) {\n            _0x6cf68d = new address[](0);\n            _0xc9e4ba = true;\n        }\n    }\n\n    function _0xcb995c() public returns (bool) {\n        for(uint i=0;i<350;i++) {\n          _0x6cf68d.push(msg.sender);\n        }\n        return true;\n    }\n\n    function _0xd0c4e7() public view returns (bool) {\n        return _0xc9e4ba;\n    }\n\n    function _0x21d44b() public view returns (uint) {\n        return _0x6cf68d.length;\n    }\n}",
      "rename_map": {
        "creditorAddresses": "_0x6cf68d",
        "numberCreditors": "_0x21d44b",
        "emptyCreditors": "_0x84eb19",
        "addCreditors": "_0xcb995c",
        "iWin": "_0xd0c4e7",
        "win": "_0xc9e4ba"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_152",
      "transformed_id": "ss_l3_medium_sn_ds_152",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract NumberRegistry {\n\n    uint _0xc18650 = 0;\n    uint[] array;\n\n    function _0xcef914(uint value,uint _0x8b4f40) public {\n\n        for(uint i=0;i<_0x8b4f40;i++) {\n            if(_0xc18650 == array.length) {\n                array.length += 1;\n            }\n            array[_0xc18650++] = value;\n        }\n    }\n\n    function _0x784c1a() public {\n        require(_0xc18650>1500);\n        _0xc18650 = 0;\n    }\n\n    function _0xcc71b4() public {\n\n        // number depends on actual gas limit\n        require(_0xc18650>1500);\n        array = new uint[](0);\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xc18650 = 0; }\n    }\n\n    function _0x261970() public view returns(uint) {\n        return _0xc18650;\n    }\n\n    function _0x10a994() public view returns(uint) {\n        return array.length;\n    }\n}",
      "rename_map": {
        "getRealLengthArray": "_0x10a994",
        "getLengthArray": "_0x261970",
        "insertNnumbers": "_0xcef914",
        "numElements": "_0xc18650",
        "clearDOS": "_0xcc71b4",
        "numbers": "_0x8b4f40",
        "clear": "_0x784c1a"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_153",
      "transformed_id": "ss_l3_medium_sn_ds_153",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract SingleFuncRegistry {\n\n    address[] _0xea1a82;\n\n    function _0xe248d3() public returns (bool){\n        if(_0xea1a82.length<1500) {\n            for(uint i=0;i<350;i++) {\n                _0xea1a82.push(msg.sender);\n            }\n            return true;\n\n        } else {\n            _0xea1a82 = new address[](0);\n            return false;\n        }\n    }\n}",
      "rename_map": {
        "listAddresses": "_0xea1a82",
        "ifillArray": "_0xe248d3"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_154",
      "transformed_id": "ss_l3_medium_sn_ds_154",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public _0xa4df15;\n     uint public _0x622e97;\n     uint public _0xd932a8;\n     address[] public _0xe023a0;\n     uint[] public _0x2ea15d;\n     address public _0x718f36;\n     mapping (address => uint) _0x3288e9;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public _0x9b1825;\n\n     function Government() {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         _0xd932a8 = msg.value;\n         _0x718f36 = msg.sender;\n         _0x622e97 = block.timestamp;\n     }\n\n     function _0xffbde7(address _0x4e5617) returns (bool) {\n         uint _0x5fb69f = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (_0x622e97 + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(_0x5fb69f);\n             // Sends all contract money to the last creditor\n             _0xe023a0[_0xe023a0.length - 1].send(_0xd932a8);\n             _0x718f36.send(this.balance);\n             // Reset contract state\n             _0xa4df15 = 0;\n             _0x622e97 = block.timestamp;\n             _0xd932a8 = 0;\n             _0xe023a0 = new address[](0);\n             _0x2ea15d = new uint[](0);\n             _0x9b1825 += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (_0x5fb69f >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 _0x622e97 = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 _0xe023a0.push(msg.sender);\n                 _0x2ea15d.push(_0x5fb69f * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 _0x718f36.send(_0x5fb69f * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (_0xd932a8 < 10000 * 10**18) {\n                     _0xd932a8 += _0x5fb69f * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(_0x3288e9[_0x4e5617] >= _0x5fb69f) {\n                     _0x4e5617.send(_0x5fb69f * 5/100);\n                 }\n                 _0x3288e9[msg.sender] += _0x5fb69f * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (_0x2ea15d[_0xa4df15] <= address(this).balance - _0xd932a8) {\n                     _0xe023a0[_0xa4df15].send(_0x2ea15d[_0xa4df15]);\n                     _0x3288e9[_0xe023a0[_0xa4df15]] -= _0x2ea15d[_0xa4df15];\n                     _0xa4df15 += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(_0x5fb69f);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     function() {\n         _0xffbde7(0);\n     }\n\n     function _0x649d5c() returns (uint _0x1efd0c) {\n         for(uint i=_0xa4df15; i<_0x2ea15d.length; i++){\n             _0x1efd0c += _0x2ea15d[i];\n         }\n     }\n\n     function _0x5d746f() returns (uint _0xd6ef01) {\n         for(uint i=0; i<_0xa4df15; i++){\n             _0xd6ef01 += _0x2ea15d[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function _0xe5c8bd() {\n         _0xd932a8 += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function _0x6dd28e(address _0x6dd6b2) {\n         if (msg.sender == _0x718f36) {\n             _0x718f36 = _0x6dd6b2;\n         }\n     }\n\n     function _0xff8cbb() returns (address[]) {\n         return _0xe023a0;\n     }\n\n     function _0x46d96a() returns (uint[]) {\n         return _0x2ea15d;\n     }\n }\n",
      "rename_map": {
        "inheritToNextGeneration": "_0x6dd28e",
        "lastCreditorPayedOut": "_0xa4df15",
        "getCreditorAddresses": "_0xff8cbb",
        "lastTimeOfNewCredit": "_0x622e97",
        "lendGovernmentMoney": "_0xffbde7",
        "getCreditorAmounts": "_0x46d96a",
        "creditorAddresses": "_0xe023a0",
        "investInTheSystem": "_0xe5c8bd",
        "profitFromCrash": "_0xd932a8",
        "creditorAmounts": "_0x2ea15d",
        "nextGeneration": "_0x6dd6b2",
        "totalPayedOut": "_0x5d746f",
        "corruptElite": "_0x718f36",
        "totalDebt": "_0x649d5c",
        "buddies": "_0x3288e9",
        "amount": "_0x5fb69f",
        "payout": "_0xd6ef01",
        "buddy": "_0x4e5617",
        "round": "_0x9b1825",
        "debt": "_0x1efd0c"
      },
      "changes": [
        "Renamed 20 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_155",
      "transformed_id": "ss_l3_medium_sn_ds_155",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.4.24;\n\ncontract Refunder {\n\naddress[] private _0xb9592c;\nmapping (address => uint) public _0x5b4445;\n\n    constructor() {\n        _0xb9592c.push(0x79B483371E87d664cd39491b5F06250165e4b184);\n        _0xb9592c.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n    }\n\n    // bad\n    function _0xc12e8d() public {\n        for(uint x; x < _0xb9592c.length; x++) { // arbitrary length iteration based on how many addresses participated\n            require(_0xb9592c[x].send(_0x5b4445[_0xb9592c[x]])); // doubly bad, now a single failure on send will hold up all funds\n        }\n    }\n\n}",
      "rename_map": {
        "refundAddresses": "_0xb9592c",
        "refundAll": "_0xc12e8d",
        "refunds": "_0x5b4445"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_156",
      "transformed_id": "ss_l3_medium_sn_ds_156",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n  function _0x962d6c(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  function _0xe01f95(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  function _0xd44739(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function _0x580d02(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  function _0xc910e0(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\ncontract ERC20 {\n\n  event Transfer( address indexed from, address indexed _0x7a0f63, uint256 value );\n  event Approval( address indexed _0xb88fd4, address indexed _0x238e95, uint256 value);\n  using SafeMath for *;\n\n  mapping (address => uint256) private _0x45c8db;\n\n  mapping (address => mapping (address => uint256)) private _0xc85c2d;\n\n  uint256 private _0x10474c;\n\n  constructor(uint _0xe5bbeb){\n    _0x45c8db[msg.sender] = _0xe5bbeb;\n  }\n\n  function _0x864887(address _0xb88fd4) public view returns (uint256) {\n    return _0x45c8db[_0xb88fd4];\n  }\n\n  function _0x51b65b(address _0xb88fd4, address _0x238e95) public view returns (uint256)\n  {\n    return _0xc85c2d[_0xb88fd4][_0x238e95];\n  }\n\n  function transfer(address _0x7a0f63, uint256 value) public returns (bool) {\n    require(value <= _0x45c8db[msg.sender]);\n    require(_0x7a0f63 != address(0));\n\n    _0x45c8db[msg.sender] = _0x45c8db[msg.sender]._0xd44739(value);\n    _0x45c8db[_0x7a0f63] = _0x45c8db[_0x7a0f63]._0x580d02(value);\n    emit Transfer(msg.sender, _0x7a0f63, value);\n    return true;\n  }\n  function _0x2346d4(address _0x238e95, uint256 value) public returns (bool) {\n    require(_0x238e95 != address(0));\n    _0xc85c2d[msg.sender][_0x238e95] = value;\n    emit Approval(msg.sender, _0x238e95, value);\n    return true;\n  }\n\n  function _0xf9adc6(address from, address _0x7a0f63, uint256 value) public returns (bool) {\n    require(value <= _0x45c8db[from]);\n    require(value <= _0xc85c2d[from][msg.sender]);\n    require(_0x7a0f63 != address(0));\n\n    _0x45c8db[from] = _0x45c8db[from]._0xd44739(value);\n    _0x45c8db[_0x7a0f63] = _0x45c8db[_0x7a0f63]._0x580d02(value);\n    _0xc85c2d[from][msg.sender] = _0xc85c2d[from][msg.sender]._0xd44739(value);\n    emit Transfer(from, _0x7a0f63, value);\n    return true;\n  }\n}\n",
      "rename_map": {
        "transferFrom": "_0xf9adc6",
        "_totalSupply": "_0x10474c",
        "totalSupply": "_0xe5bbeb",
        "balanceOf": "_0x864887",
        "_balances": "_0x45c8db",
        "allowance": "_0x51b65b",
        "_allowed": "_0xc85c2d",
        "spender": "_0x238e95",
        "approve": "_0x2346d4",
        "owner": "_0xb88fd4",
        "mod": "_0xc910e0",
        "div": "_0xe01f95",
        "sub": "_0xd44739",
        "mul": "_0x962d6c",
        "add": "_0x580d02",
        "to": "_0x7a0f63"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_157",
      "transformed_id": "ss_l3_medium_sn_ds_157",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.22;\n\ncontract FindThisHash {\n    bytes32 constant public _0xb8b077 = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;\n\n    constructor() public payable {} // load with ether\n\n    function _0x1008db(string _0x5d03d7) public {\n        // If you can find the pre image of the hash, receive 1000 ether\n        require(_0xb8b077 == _0xe291d2(_0x5d03d7));\n        msg.sender.transfer(1000 ether);\n    }\n}",
      "rename_map": {
        "solution": "_0x5d03d7",
        "solve": "_0x1008db",
        "sha3": "_0xe291d2",
        "hash": "_0xb8b077"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_158",
      "transformed_id": "ss_l3_medium_sn_ds_158",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n    address public _0xfe4fef;\n    bool public _0x8eae13;\n    uint public _0x6b8524;\n\n    function EthTxOrderDependenceMinimal() public {\n        if (block.timestamp > 0) { _0xfe4fef = msg.sender; }\n    }\n\n    function _0x386e8f() public payable {\n        require (!_0x8eae13);\n\n        require(msg.sender == _0xfe4fef);\n        _0xfe4fef.transfer(_0x6b8524);\n        _0x6b8524 = msg.value;\n    }\n\n    function _0xb2f74a(uint256 _0x450e4f) {\n        require (!_0x8eae13);\n        require(_0x450e4f < 10);\n        msg.sender.transfer(_0x6b8524);\n        _0x8eae13 = true;\n    }\n}",
      "rename_map": {
        "claimReward": "_0xb2f74a",
        "submission": "_0x450e4f",
        "setReward": "_0x386e8f",
        "claimed": "_0x8eae13",
        "reward": "_0x6b8524",
        "owner": "_0xfe4fef"
      },
      "changes": [
        "Renamed 6 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_159",
      "transformed_id": "ss_l3_medium_sn_ds_159",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.2;\n\ncontract OddsAndEvens{\n\n  struct Player {\n    address _0xbe4190;\n    uint number;\n  }\n\n  Player[2] public _0x09171a;         //public only for debug purpose\n\n  uint8 _0x3f9ee4;\n  address _0xcf42b7;\n\n  function OddsAndEvens() {\n    _0xcf42b7 = msg.sender;\n  }\n  function _0x8d26e4(uint number) payable{\n    if (msg.value != 1 ether) throw;\n    _0x09171a[_0x3f9ee4] = Player(msg.sender, number);\n    _0x3f9ee4++;\n\n    if (_0x3f9ee4==2) _0x603d3c();\n  }\n\n  function _0x603d3c() private {\n    bool _0x082917 ;\n    uint n = _0x09171a[0].number+_0x09171a[1].number;\n    if (n%2==0) {\n      _0x082917 = _0x09171a[0]._0xbe4190.send(1800 finney);\n    }\n    else {\n      _0x082917 = _0x09171a[1]._0xbe4190.send(1800 finney);\n    }\n\n    delete _0x09171a;\n    _0x3f9ee4=0;\n  }\n\n  function _0x0350a2() {\n    if(msg.sender!=_0xcf42b7) throw;\n    bool _0x082917 = msg.sender.send(this.balance);\n  }\n\n}",
      "rename_map": {
        "andTheWinnerIs": "_0x603d3c",
        "getProfit": "_0x0350a2",
        "players": "_0x09171a",
        "owner": "_0xcf42b7",
        "play": "_0x8d26e4",
        "addr": "_0xbe4190",
        "res": "_0x082917",
        "tot": "_0x3f9ee4"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_160",
      "transformed_id": "ss_l3_medium_sn_ds_160",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\n// CryptoRoulette\n//\n// Guess the number secretly stored in the blockchain and win the whole contract balance!\n// A new number is randomly chosen after each try.\n\n// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether\n\ncontract CryptoRoulette {\n\n    uint256 private _0x3928ab;\n    uint256 public _0x2e7260;\n    uint256 public _0x96557a = 0.1 ether;\n    address public _0x8ba5b9;\n\n    struct Game {\n        address _0x805705;\n        uint256 number;\n    }\n    Game[] public _0x8e5d9f;\n\n    function CryptoRoulette() public {\n        _0x8ba5b9 = msg.sender;\n        _0x5c4de3();\n    }\n\n    function _0x5c4de3() internal {\n        // randomly set secretNumber with a value between 1 and 20\n        if (gasleft() > 0) { _0x3928ab = uint8(_0x63accb(_0xd2dafc, block.blockhash(block.number-1))) % 20 + 1; }\n    }\n\n    function _0x47e38f(uint256 number) payable public {\n        require(msg.value >= _0x96557a && number <= 10);\n        Game _0x044a4e;\n        _0x044a4e._0x805705 = msg.sender;\n        _0x044a4e.number = number;\n        _0x8e5d9f.push(_0x044a4e);\n\n        if (number == _0x3928ab) {\n            // win!\n            msg.sender.transfer(this.balance);\n        }\n\n        _0x5c4de3();\n        _0x2e7260 = _0xd2dafc;\n    }\n\n    function _0x96921d() public {\n        if (msg.sender == _0x8ba5b9 && _0xd2dafc > _0x2e7260 + 1 days) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n}",
      "rename_map": {
        "secretNumber": "_0x3928ab",
        "gamesPlayed": "_0x8e5d9f",
        "lastPlayed": "_0x2e7260",
        "ownerAddr": "_0x8ba5b9",
        "betPrice": "_0x96557a",
        "shuffle": "_0x5c4de3",
        "player": "_0x805705",
        "sha3": "_0x63accb",
        "play": "_0x47e38f",
        "kill": "_0x96921d",
        "game": "_0x044a4e",
        "now": "_0xd2dafc"
      },
      "changes": [
        "Renamed 12 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_161",
      "transformed_id": "ss_l3_medium_sn_ds_161",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract NameRegistrar {\n\n    bool public _0x900b23 = false;  // registrar locked, no name updates\n\n    struct NameRecord { // map hashes to addresses\n        bytes32 _0x891972;\n        address _0xa4b7c9;\n    }\n\n    mapping(address => NameRecord) public _0x66ff49; // records who registered names\n    mapping(bytes32 => address) public _0x049efe; // resolves hashes to addresses\n\n    function _0x472805(bytes32 _0xcd445c, address _0x4042bd) public {\n        // set up the new NameRecord\n        NameRecord _0x69b34d;\n        _0x69b34d._0x891972 = _0xcd445c;\n        _0x69b34d._0xa4b7c9 = _0x4042bd;\n\n        _0x049efe[_0xcd445c] = _0x4042bd;\n        _0x66ff49[msg.sender] = _0x69b34d;\n\n        require(_0x900b23); // only allow registrations if contract is unlocked\n    }\n}\n",
      "rename_map": {
        "registeredNameRecord": "_0x66ff49",
        "_mappedAddress": "_0x4042bd",
        "mappedAddress": "_0xa4b7c9",
        "newRecord": "_0x69b34d",
        "register": "_0x472805",
        "unlocked": "_0x900b23",
        "resolve": "_0x049efe",
        "_name": "_0xcd445c",
        "name": "_0x891972"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_162",
      "transformed_id": "ss_l3_medium_sn_ds_162",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint _0xf1527d;\n        uint _0xfdda47;\n        uint _0x803055;\n        uint _0xe3bd49;\n    }\n\n    address _0x040317; //address of the owner\n    uint private _0x7831ea; //seed used to calculate number of an address\n    uint private _0x341c70; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n\n    mapping (address => bool) _0x76a31f; //keeping track of addresses that have already won\n\n    function OpenAddressLottery() {\n        _0x040317 = msg.sender;\n        _0x55b379(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0x3aef0e() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n\n        // make sure he hasn't won already\n        require(_0x76a31f[msg.sender] == false);\n\n        if(_0xf7220d(msg.sender) == LuckyNumber){ //check if it equals 7\n            _0x76a31f[msg.sender] = true; // every address can only win once\n\n            uint _0x5b7339=msg.value*7; //win = 7 times the ticket price\n\n            if(_0x5b7339>this.balance) //if the balance isnt sufficient...\n                _0x5b7339=this.balance; //...send everything we've got\n            msg.sender.transfer(_0x5b7339);\n        }\n\n        if(block.number-_0x341c70>1000) //reseed if needed\n            _0x55b379(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0xf7220d(address _0x52826d) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(_0xbad20d(uint(_0x52826d), _0x7831ea)[0]) % 8;\n    }\n\n    function _0x55b379(SeedComponents _0xbf766c) internal {\n        _0x7831ea = uint256(_0xbad20d(\n            _0xbf766c._0xf1527d,\n            _0xbf766c._0xfdda47,\n            _0xbf766c._0x803055,\n            _0xbf766c._0xe3bd49\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        if (1 == 1) { _0x341c70 = block.number; }\n    }\n\n    function _0x52f037() {\n        require(msg.sender==_0x040317);\n\n        selfdestruct(msg.sender);\n    }\n\n    function _0x62df9b() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==_0x040317);\n        SeedComponents s;\n        s._0xf1527d = uint(msg.sender);\n        s._0xfdda47 = uint256(block.blockhash(block.number - 1));\n        s._0x803055 = block.difficulty*(uint)(block.coinbase);\n        s._0xe3bd49 = tx.gasprice * 7;\n\n        _0x55b379(s); //reseed\n    }\n\n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=_0x040317) //owner can't participate, he can only fund the jackpot\n            _0x3aef0e();\n    }\n\n}\n",
      "rename_map": {
        "luckyNumberOfAddress": "_0xf7220d",
        "forceReseed": "_0x62df9b",
        "participate": "_0x3aef0e",
        "components": "_0xbf766c",
        "secretSeed": "_0x7831ea",
        "component1": "_0xf1527d",
        "component3": "_0x803055",
        "component2": "_0xfdda47",
        "lastReseed": "_0x341c70",
        "component4": "_0xe3bd49",
        "keccak256": "_0xbad20d",
        "winner": "_0x76a31f",
        "reseed": "_0x55b379",
        "owner": "_0x040317",
        "addr": "_0x52826d",
        "kill": "_0x52f037",
        "win": "_0x5b7339"
      },
      "changes": [
        "Renamed 17 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_163",
      "transformed_id": "ss_l3_medium_sn_ds_163",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.11;\n\n contract MyToken {\n     mapping (address => uint) _0x67b15e;\n\n     event Transfer(address indexed _0x2eb03c, address indexed _0x6b8d02, uint256 _0x23e7ff);\n\n     function MyToken() {\n         _0x67b15e[tx.origin] = 10000;\n     }\n     function _0xb74d52(address _0x750117, uint _0x4f2e22) returns(bool _0x63175f) {\n         if (_0x67b15e[msg.sender] < _0x4f2e22) return false;\n         _0x67b15e[msg.sender] -= _0x4f2e22;\n         _0x67b15e[_0x750117] += _0x4f2e22;\n         Transfer(msg.sender, _0x750117, _0x4f2e22);\n         return true;\n     }\n\n     function _0x243fa2(address _0xd7efab) constant returns(uint) {\n         return _0x67b15e[_0xd7efab];\n     }\n }",
      "rename_map": {
        "sufficient": "_0x63175f",
        "getBalance": "_0x243fa2",
        "balances": "_0x67b15e",
        "sendCoin": "_0xb74d52",
        "amount": "_0x4f2e22",
        "_value": "_0x23e7ff",
        "_from": "_0x2eb03c",
        "addr": "_0xd7efab",
        "_to": "_0x6b8d02",
        "to": "_0x750117"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_164",
      "transformed_id": "ss_l3_medium_sn_ds_164",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address public _0x3eaf4f;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public _0x419895;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    function EtherLotto() {\n        _0x3eaf4f = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function _0xbdc644() payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        _0x419895 += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        var _0xd5a169 = uint(_0x9a6933(block.timestamp)) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (_0xd5a169 == 0) {\n\n            // Send fee to bank account.\n            _0x3eaf4f.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(_0x419895 - FEE_AMOUNT);\n\n            // Restart jackpot.\n            _0x419895 = 0;\n        }\n    }\n\n}",
      "rename_map": {
        "random": "_0xd5a169",
        "bank": "_0x3eaf4f",
        "sha3": "_0x9a6933",
        "play": "_0xbdc644",
        "pot": "_0x419895"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_165",
      "transformed_id": "ss_l3_medium_sn_ds_165",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract Governmental {\n  address public _0x40fa27;\n  address public _0x2a2741;\n  uint public _0x366a17 = 1 ether;\n  uint public _0x127dc9;\n  uint public ONE_MINUTE = 1 minutes;\n\n  function Governmental() {\n    _0x40fa27 = msg.sender;\n    if (msg.value<1 ether) throw;\n  }\n\n  function _0x7c705d() {\n    if (msg.value<_0x366a17/2) throw;\n    if (1 == 1) { _0x2a2741 = msg.sender; }\n    _0x366a17 += msg.value/2;\n    if (gasleft() > 0) { _0x127dc9 = block.timestamp; }\n  }\n\n  function _0x43ce4a() {\n    if (block.timestamp < _0x127dc9+ONE_MINUTE)\n      throw;\n\n    _0x2a2741.send(_0x366a17);\n    _0x40fa27.send(this.balance-1 ether);\n\n    _0x2a2741 = 0;\n    if (gasleft() > 0) { _0x366a17 = 1 ether; }\n    if (true) { _0x127dc9 = 0; }\n  }\n}\n\ncontract Operator {\n\n  function _0x572aa0(address _0xcee5ce, uint _0x3212da) {\n    if (0<=_0x3212da && _0x3212da<1023) {\n      this._0x572aa0.gas(msg.gas-2000)(_0xcee5ce, _0x3212da+1);\n    }\n    else {\n      Governmental(_0xcee5ce)._0x43ce4a();\n    }\n  }\n}\n",
      "rename_map": {
        "lastInvestmentTimestamp": "_0x127dc9",
        "resetInvestment": "_0x43ce4a",
        "lastInvestor": "_0x2a2741",
        "operate": "_0x572aa0",
        "jackpot": "_0x366a17",
        "target": "_0xcee5ce",
        "invest": "_0x7c705d",
        "count": "_0x3212da",
        "owner": "_0x40fa27"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_166",
      "transformed_id": "ss_l3_medium_sn_ds_166",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.0;\ncontract _0x91a3f1 {\n  address _0x36dd3d;\n  uint    timestamp;\n  function _0xf023f2(uint _0x71e2c8) internal {\n    if ( _0x71e2c8> 0 && _0x6176bc - _0x71e2c8 > 24 hours ) {\n      msg.sender.send( msg.value );\n\n      if ( this.balance > 0 ) {\n        _0x36dd3d.send( this.balance );\n      }\n    }\n    else if ( msg.value >= 1 ether ) {\n      _0x36dd3d = msg.sender;\n      timestamp = _0x71e2c8;\n    }\n  }\n  function _0xe76736() constant returns (uint _0xb30689) {\n      return block.timestamp;\n    }\n  function _0x9fd940(uint _0x09b4e3){\n    uint _0xb30689=_0xe76736();\n    _0xf023f2(_0xb30689);\n  }\n}",
      "rename_map": {
        "randomNumber": "_0xb30689",
        "lottopollo": "_0x91a3f1",
        "randomGen": "_0xe76736",
        "payOut": "_0xf023f2",
        "leader": "_0x36dd3d",
        "draw": "_0x9fd940",
        "rand": "_0x71e2c8",
        "seed": "_0x09b4e3",
        "now": "_0x6176bc"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_167",
      "transformed_id": "ss_l3_medium_sn_ds_167",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract Roulette {\n    uint public _0x11623c; // Forces one bet per block\n\n    constructor() public payable {} // initially fund contract\n\n    // fallback function used to make a bet\n    function () public payable {\n        require(msg.value == 10 ether); // must send 10 ether to play\n        require(_0x3565d2 != _0x11623c); // only 1 transaction per block\n        _0x11623c = _0x3565d2;\n        if(_0x3565d2 % 15 == 0) { // winner\n            msg.sender.transfer(this.balance);\n        }\n    }\n}",
      "rename_map": {
        "pastBlockTime": "_0x11623c",
        "now": "_0x3565d2"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_168",
      "transformed_id": "ss_l3_medium_sn_ds_168",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract TimedCrowdsale {\n  // Sale should finish exactly at January 1, 2019\n  function _0x4d1906() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n}",
      "rename_map": {
        "isSaleFinished": "_0x4d1906"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_169",
      "transformed_id": "ss_l3_medium_sn_ds_169",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.9;\n\ncontract TownCrier {\n    struct Request { // the data structure for each request\n        address _0xe384fc; // the address of the requester\n        uint _0xb192ac; // the amount of wei the requester pays for the request\n        address _0x8a42d0; // the address of the contract to call for delivering response\n        bytes4 _0x195bf2; // the specification of the callback function\n        bytes32 _0x6cb007; // the hash of the request parameters\n    }\n\n    event Upgrade(address _0xe54470);\n    event Reset(uint _0x3f4aed, uint _0x77c849, uint _0x320966);\n    event RequestInfo(uint64 _0x30e2a7, uint8 _0x99a0dc, address _0xe384fc, uint _0xb192ac, address _0x8a42d0, bytes32 _0x6cb007, uint timestamp, bytes32[] _0xb4cc5e); // log of requests, the Town Crier server watches this event and processes requests\n    event DeliverInfo(uint64 _0xf31025, uint _0xb192ac, uint gasPrice, uint _0x3d2fd9, uint _0x4e9016, bytes32 _0x6cb007, uint64 error, bytes32 _0x0fab5c); // log of responses\n    event Cancel(uint64 _0xf31025, address _0x6c241f, address _0xe384fc, uint _0xb192ac, int _0xfbb9a6); // log of cancellations\n\n    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;// address of the SGX account\n\n    uint public GAS_PRICE = 5 * 10**10;\n    uint public MIN_FEE = 30000 * GAS_PRICE; // minimum fee required for the requester to pay such that SGX could call deliver() to send a response\n    uint public CANCELLATION_FEE = 25000 * GAS_PRICE; // charged when the requester cancels a request that is not responded\n\n    uint public constant CANCELLED_FEE_FLAG = 1;\n    uint public constant DELIVERED_FEE_FLAG = 0;\n    int public constant FAIL_FLAG = -2 ** 250;\n    int public constant SUCCESS_FLAG = 1;\n\n    bool public _0x16738c;\n\n    bool public _0x0cb412;\n\n    uint64 public _0x3f2dec;\n    uint64 public _0xd471f2;\n    Request[2**64] public _0x222395;\n\n    int public _0xd616f1 = 0;\n\n    // Contracts that receive Ether but do not define a fallback function throw\n    // an exception, sending back the Ether (this was different before Solidity\n    // v0.4.0). So if you want your contract to receive Ether, you have to\n    // implement a fallback function.\n    function () {}\n\n    function TownCrier() public {\n        // Start request IDs at 1 for two reasons:\n        //   1. We can use 0 to denote an invalid request (ids are unsigned)\n        //   2. Storage is more expensive when changing something from zero to non-zero,\n        //      so this means the first request isn't randomly more expensive.\n        if (block.timestamp > 0) { _0x3f2dec = 1; }\n        _0x222395[0]._0xe384fc = msg.sender;\n        _0x16738c = false;\n        _0xd471f2 = 0;\n        _0x0cb412 = false;\n    }\n\n    function _0xc44fb3(address _0xe54470) {\n        if (msg.sender == _0x222395[0]._0xe384fc && _0xd471f2 == 0) {\n            _0xd616f1 = -int(_0xe54470);\n            _0x16738c = true;\n            Upgrade(_0xe54470);\n        }\n    }\n\n    function _0xaa89be(uint _0x42fd90, uint _0x777de4, uint _0x62cf2f) public {\n        if (msg.sender == _0x222395[0]._0xe384fc && _0xd471f2 == 0) {\n            GAS_PRICE = _0x42fd90;\n            MIN_FEE = _0x42fd90 * _0x777de4;\n            CANCELLATION_FEE = _0x42fd90 * _0x62cf2f;\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n        }\n    }\n\n    function _0xa6ff66() public {\n        if (msg.sender == _0x222395[0]._0xe384fc) {\n            _0x16738c = true;\n        }\n    }\n\n    function _0x158877() public {\n        if (msg.sender == _0x222395[0]._0xe384fc && _0xd616f1 == 0) {\n            _0x16738c = false;\n        }\n    }\n\n    function _0xf2a50d() public {\n        if (msg.sender == _0x222395[0]._0xe384fc && _0xd471f2 == 0) {\n            if (!_0x222395[0]._0xe384fc.call.value(this.balance)()) {\n                throw;\n            }\n        }\n    }\n\n    function _0x051e0e(uint8 _0x99a0dc, address _0x8a42d0, bytes4 _0x195bf2, uint timestamp, bytes32[] _0xb4cc5e) public payable returns (int) {\n        if (_0x0cb412) {\n            throw;\n        }\n\n        if (_0x16738c) {\n            _0x0cb412 = true;\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            _0x0cb412 = false;\n            return _0xd616f1;\n        }\n\n        if (msg.value < MIN_FEE) {\n            _0x0cb412 = true;\n            // If the amount of ether sent by the requester is too little or\n            // too much, refund the requester and discard the request.\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            _0x0cb412 = false;\n            return FAIL_FLAG;\n        } else {\n            // Record the request.\n            uint64 _0xf31025 = _0x3f2dec;\n            _0x3f2dec++;\n            _0xd471f2++;\n\n            bytes32 _0x6cb007 = _0x223ea7(_0x99a0dc, _0xb4cc5e);\n            _0x222395[_0xf31025]._0xe384fc = msg.sender;\n            _0x222395[_0xf31025]._0xb192ac = msg.value;\n            _0x222395[_0xf31025]._0x8a42d0 = _0x8a42d0;\n            _0x222395[_0xf31025]._0x195bf2 = _0x195bf2;\n            _0x222395[_0xf31025]._0x6cb007 = _0x6cb007;\n\n            // Log the request for the Town Crier server to process.\n            RequestInfo(_0xf31025, _0x99a0dc, msg.sender, msg.value, _0x8a42d0, _0x6cb007, timestamp, _0xb4cc5e);\n            return _0xf31025;\n        }\n    }\n\n    function _0xc87350(uint64 _0xf31025, bytes32 _0x6cb007, uint64 error, bytes32 _0x0fab5c) public {\n        if (msg.sender != SGX_ADDRESS ||\n                _0xf31025 <= 0 ||\n                _0x222395[_0xf31025]._0xe384fc == 0 ||\n                _0x222395[_0xf31025]._0xb192ac == DELIVERED_FEE_FLAG) {\n            // If the response is not delivered by the SGX account or the\n            // request has already been responded to, discard the response.\n            return;\n        }\n\n        uint _0xb192ac = _0x222395[_0xf31025]._0xb192ac;\n        if (_0x222395[_0xf31025]._0x6cb007 != _0x6cb007) {\n            // If the hash of request parameters in the response is not\n            // correct, discard the response for security concern.\n            return;\n        } else if (_0xb192ac == CANCELLED_FEE_FLAG) {\n            // If the request is cancelled by the requester, cancellation\n            // fee goes to the SGX account and set the request as having\n            // been responded to.\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            _0x222395[_0xf31025]._0xb192ac = DELIVERED_FEE_FLAG;\n            _0xd471f2--;\n            return;\n        }\n\n        _0x222395[_0xf31025]._0xb192ac = DELIVERED_FEE_FLAG;\n        _0xd471f2--;\n\n        if (error < 2) {\n            // Either no error occurs, or the requester sent an invalid query.\n            // Send the fee to the SGX account for its delivering.\n            SGX_ADDRESS.send(_0xb192ac);\n        } else {\n            // Error in TC, refund the requester.\n            if (block.timestamp > 0) { _0x0cb412 = true; }\n            _0x222395[_0xf31025]._0xe384fc.call.gas(2300).value(_0xb192ac)();\n            _0x0cb412 = false;\n        }\n\n        uint _0x4e9016 = (_0xb192ac - MIN_FEE) / tx.gasprice; // gas left for the callback function\n        DeliverInfo(_0xf31025, _0xb192ac, tx.gasprice, msg.gas, _0x4e9016, _0x6cb007, error, _0x0fab5c); // log the response information\n        if (_0x4e9016 > msg.gas - 5000) {\n            _0x4e9016 = msg.gas - 5000;\n        }\n\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x0cb412 = true; }\n        _0x222395[_0xf31025]._0x8a42d0.call.gas(_0x4e9016)(_0x222395[_0xf31025]._0x195bf2, _0xf31025, error, _0x0fab5c); // call the callback function in the application contract\n        _0x0cb412 = false;\n    }\n\n    function _0xd2b7a7(uint64 _0xf31025) public returns (int) {\n        if (_0x0cb412) {\n            throw;\n        }\n\n        if (_0x16738c) {\n            return 0;\n        }\n\n        uint _0xb192ac = _0x222395[_0xf31025]._0xb192ac;\n        if (_0x222395[_0xf31025]._0xe384fc == msg.sender && _0xb192ac >= CANCELLATION_FEE) {\n            // If the request was sent by this user and has money left on it,\n            // then cancel it.\n            _0x222395[_0xf31025]._0xb192ac = CANCELLED_FEE_FLAG;\n            _0x0cb412 = true;\n            if (!msg.sender.call.value(_0xb192ac - CANCELLATION_FEE)()) {\n                throw;\n            }\n            _0x0cb412 = false;\n            Cancel(_0xf31025, msg.sender, _0x222395[_0xf31025]._0xe384fc, _0x222395[_0xf31025]._0xb192ac, 1);\n            return SUCCESS_FLAG;\n        } else {\n            Cancel(_0xf31025, msg.sender, _0x222395[_0xf31025]._0xe384fc, _0xb192ac, -1);\n            return FAIL_FLAG;\n        }\n    }\n}",
      "rename_map": {
        "externalCallFlag": "_0x0cb412",
        "cancellation_fee": "_0x320966",
        "cancellationGas": "_0x62cf2f",
        "unrespondedCnt": "_0xd471f2",
        "callbackAddr": "_0x8a42d0",
        "callbackGas": "_0x4e9016",
        "requestData": "_0xb4cc5e",
        "requestType": "_0x99a0dc",
        "callbackFID": "_0x195bf2",
        "paramsHash": "_0x6cb007",
        "killswitch": "_0x16738c",
        "newVersion": "_0xd616f1",
        "requestCnt": "_0x3f2dec",
        "gas_price": "_0x3f4aed",
        "canceller": "_0x6c241f",
        "requestId": "_0xf31025",
        "requester": "_0xe384fc",
        "respData": "_0x0fab5c",
        "withdraw": "_0xf2a50d",
        "requests": "_0x222395",
        "gasLeft": "_0x3d2fd9",
        "deliver": "_0xc87350",
        "request": "_0x051e0e",
        "suspend": "_0xa6ff66",
        "min_fee": "_0x77c849",
        "newAddr": "_0xe54470",
        "upgrade": "_0xc44fb3",
        "restart": "_0x158877",
        "minGas": "_0x777de4",
        "cancel": "_0xd2b7a7",
        "price": "_0x42fd90",
        "reset": "_0xaa89be",
        "sha3": "_0x223ea7",
        "flag": "_0xfbb9a6",
        "fee": "_0xb192ac",
        "id": "_0x30e2a7"
      },
      "changes": [
        "Renamed 36 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_170",
      "transformed_id": "ss_l3_medium_sn_ds_170",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\n/// @author Jordi Baylina\n/// Auditors: Griff Green & psdev\n/// @notice Based on http://hudsonjameson.com/ethereummarriage/\n/// License: GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier _0x0f2da9() {\n        require(msg.sender == _0x0343c9);\n        _;\n    }\n\n    address public _0x0343c9;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        _0x0343c9 = msg.sender;\n    }\n\n    address public _0x41ce01;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function _0xf14727(address _0x809307) _0x0f2da9 {\n        if (true) { _0x41ce01 = _0x809307; }\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function _0x426e98() {\n        if (msg.sender == _0x41ce01) {\n            _0x0343c9 = _0x41ce01;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function _0xefd3d8(address _0x9a4f04, uint _0x1186a3, bytes _0x3484e6) _0x0f2da9 {\n        _0x9a4f04.call.value(_0x1186a3)(_0x3484e6);\n    }\n}\n\ncontract Marriage is Owned\n{\n    // Marriage data variables\n    string public _0x0f906e;\n    string public _0xdd0069;\n    uint public _0x2a1339;\n    string public _0x7e6837;\n    string public _0xe7db72;\n\n    Event[] public _0xc7d037;\n    Message[] public _0x64d953;\n\n    struct Event {\n        uint _0x8a82c5;\n        string _0xa8694a;\n        string _0x881aa4;\n        string _0xcbec4e;\n    }\n\n    struct Message {\n        uint _0x8a82c5;\n        string _0x5bf2df;\n        string _0x78edaf;\n        string _0xcbec4e;\n        uint value;\n    }\n\n    modifier _0xe24db9 {\n        require(_0xb36adf(_0x7e6837) == _0xb36adf(\"Married\"));\n        _;\n    }\n\n    //Set Owner\n    function Marriage(address _0xedd4a2) {\n        _0x0343c9 = _0xedd4a2;\n    }\n\n    function _0xc8f3c5() constant public returns (uint) {\n        return _0xc7d037.length;\n    }\n\n    function _0x94bdd8() constant public returns (uint) {\n        return _0x64d953.length;\n    }\n\n    // Create initial marriage contract\n    function _0xdd5cf2(\n        string _0x660106,\n        string _0x0654ba,\n        string _0x5769e0,\n        string _0xcbec4e) _0x0f2da9\n    {\n        require(_0xc7d037.length == 0);\n        _0x0f906e = _0x660106;\n        _0xdd0069 = _0x0654ba;\n        _0x2a1339 = _0x44f970;\n        _0xe7db72 = _0x5769e0;\n        _0x7e6837 = \"Married\";\n        _0xc7d037.push(Event(_0x44f970, \"Marriage\", _0xe7db72, _0xcbec4e));\n        MajorEvent(\"Marrigage\", _0xe7db72, _0xcbec4e);\n    }\n\n    // Set the marriage status if it changes\n    function _0x8ba555(string _0xcd131b, string _0xcbec4e) _0x0f2da9\n    {\n        _0x7e6837 = _0xcd131b;\n        setMajorEvent(\"Changed Status\", _0xcd131b, _0xcbec4e);\n    }\n\n    // Set the IPFS hash of the image of the couple\n    function setMajorEvent(string _0xa8694a, string _0x881aa4, string _0xcbec4e) _0x0f2da9 _0xe24db9\n    {\n        _0xc7d037.push(Event(_0x44f970, _0xa8694a, _0x881aa4, _0xcbec4e));\n        MajorEvent(_0xa8694a, _0x881aa4, _0xcbec4e);\n    }\n\n    function _0x42a6d8(string _0x5bf2df, string _0x78edaf, string _0xcbec4e) payable _0xe24db9 {\n        if (msg.value > 0) {\n            _0x0343c9.transfer(this.balance);\n        }\n        _0x64d953.push(Message(_0x44f970, _0x5bf2df, _0x78edaf, _0xcbec4e, msg.value));\n        MessageSent(_0x5bf2df, _0x78edaf, _0xcbec4e, msg.value);\n    }\n\n    // Declare event structure\n    event MajorEvent(string _0xa8694a, string _0x881aa4, string _0xcbec4e);\n    event MessageSent(string _0xa8694a, string _0x881aa4, string _0xcbec4e, uint value);\n}",
      "rename_map": {
        "numberOfMajorEvents": "_0xc8f3c5",
        "numberOfMessages": "_0x94bdd8",
        "acceptOwnership": "_0x426e98",
        "marriageStatus": "_0x7e6837",
        "createMarriage": "_0xdd5cf2",
        "marriageDate": "_0x2a1339",
        "changeOwner": "_0xf14727",
        "sendMessage": "_0x42a6d8",
        "majorEvents": "_0xc7d037",
        "description": "_0x881aa4",
        "areMarried": "_0xe24db9",
        "_partner1": "_0x660106",
        "onlyOwner": "_0x0f2da9",
        "_partner2": "_0x0654ba",
        "setStatus": "_0x8ba555",
        "_newOwner": "_0x809307",
        "partner2": "_0xdd0069",
        "messages": "_0x64d953",
        "newOwner": "_0x41ce01",
        "partner1": "_0x0f906e",
        "nameFrom": "_0x5bf2df",
        "execute": "_0xefd3d8",
        "status": "_0xcd131b",
        "_value": "_0x1186a3",
        "_owner": "_0xedd4a2",
        "_vows": "_0x5769e0",
        "owner": "_0x0343c9",
        "_data": "_0x3484e6",
        "sha3": "_0xb36adf",
        "name": "_0xa8694a",
        "text": "_0x78edaf",
        "_dst": "_0x9a4f04",
        "vows": "_0xe7db72",
        "date": "_0x8a82c5",
        "now": "_0x44f970",
        "url": "_0xcbec4e"
      },
      "changes": [
        "Renamed 36 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_171",
      "transformed_id": "ss_l3_medium_sn_ds_171",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract Splitter{\n\n\taddress public _0xd17490;\n\taddress[] public _0x4626f9;\n\tmapping (uint256 => address) public _0x2e28b3;\n\taddress private _0xb20599;\n\tuint256 private _0x3b5d06;\n\tuint256 private _0xcd1b0b;\n\n//constructor\n\n\tconstructor() payable public{\n\t\t_0xd17490 = msg.sender;\n\t\t_0x8ba77e();\n\t\t_0x8ba77e();\n\t\t_0x8ba77e();\n\t\t_0x8ba77e();\n\t\t_0x2e28b3[0] = _0x4626f9[0];\n        _0x2e28b3[1] = _0x4626f9[1];\n        _0x2e28b3[2] = _0x4626f9[2];\n        _0x2e28b3[3] = _0x4626f9[3];\n\t}\n\n//withdraw (just in case)\n\n\tfunction _0xebce9d() public{\n\t\trequire(msg.sender == _0xd17490);\n\t\t_0xd17490.transfer(address(this).balance);\n\t}\n\n//puppet count\n\n\tfunction _0xd65531() public constant returns(uint256 _0x9e6a35){\n    \treturn _0x4626f9.length;\n  \t}\n\n//deploy contracts\n\n\tfunction _0x8ba77e() public returns(address _0x8ba77e){\n\t    require(msg.sender == _0xd17490);\n    \tPuppet p = new Puppet();\n    \t_0x4626f9.push(p);\n    \treturn p;\n  \t\t}\n\n//update mapping\n\n    function _0x2c1ed8(uint256 _0x8bc613, address _0x039cb1) public {\n        require(_0x039cb1 != address(0));\n        _0x2e28b3[_0x8bc613] = _0x039cb1;\n    }\n\n//fund puppets TROUBLESHOOT gas\n\n    function _0x172d34() public payable {\n        require(msg.sender == _0xd17490);\n     if (1 == 1) { _0x3b5d06 = SafeMath._0x986013(msg.value, 4); }\n        _0x2e28b3[0].call.value(_0x3b5d06).gas(800000)();\n        _0x2e28b3[1].call.value(_0x3b5d06).gas(800000)();\n        _0x2e28b3[2].call.value(_0x3b5d06).gas(800000)();\n        _0x2e28b3[3].call.value(_0x3b5d06).gas(800000)();\n        }\n\n//fallback function\n\nfunction() payable public{\n\t}\n}\n\ncontract Puppet {\n\n    mapping (uint256 => address) public _0x3729df;\n    mapping (uint256 => address) public _0x609fe8;\n\n\tconstructor() payable public{\n\t\t//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;\n\t\t_0x3729df[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        _0x609fe8[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\n\t//send shares to doubler\n\t//return profit to master\n\n\tfunction() public payable{\n\t    if(msg.sender != _0x3729df[0]){\n\t\t\t_0x3729df[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\t//emergency withdraw\n\n\tfunction _0xebce9d() public{\n\t\trequire(msg.sender == _0x609fe8[0]);\n\t\t_0x609fe8[0].transfer(address(this).balance);\n\t}\n}\n\n//library\n\nlibrary SafeMath {\n\n  function _0x924595(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function _0x986013(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function _0xc4dce4(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function _0x2c1dbf(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
      "rename_map": {
        "getPuppetCount": "_0xd65531",
        "puppetCount": "_0x9e6a35",
        "fundPuppets": "_0x172d34",
        "newPuppet": "_0x8ba77e",
        "_newExtra": "_0x039cb1",
        "withdraw": "_0xebce9d",
        "setExtra": "_0x2c1ed8",
        "puppets": "_0x4626f9",
        "target": "_0x3729df",
        "_share": "_0x3b5d06",
        "_count": "_0xcd1b0b",
        "master": "_0x609fe8",
        "owner": "_0xd17490",
        "extra": "_0x2e28b3",
        "_addy": "_0xb20599",
        "_id": "_0x8bc613",
        "add": "_0x2c1dbf",
        "div": "_0x986013",
        "sub": "_0xc4dce4",
        "mul": "_0x924595"
      },
      "changes": [
        "Renamed 20 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_172",
      "transformed_id": "ss_l3_medium_sn_ds_172",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// winner gets the contract balance\n// 0.02 to play\n\npragma solidity ^0.4.23;\n\ncontract FundManager {\n\n//constants\n\naddress public _0xfcd5d0 = 0x0;\naddress public _0x796d43;\naddress public _0xbcfe71 = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public _0x182e32 = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public _0x1287f1;\n\nmapping(address=>bool) _0x230923;\n\nuint256 public _0x0b995a;\nuint256[] public _0xdec31b = [951828771,158769871220];\nuint256[] public balance;\n\n//constructor\n\nfunction DranMe() public payable{\n if (gasleft() > 0) { _0x796d43 = msg.sender; }\n}\n\n//modifiers\n\nmodifier _0xa1ffdd() {\n    require(msg.sender == _0x796d43);\n    _;\n}\n\nmodifier _0x4276d2() {\n    require(msg.sender == _0xfcd5d0);\n    _;\n}\n\nmodifier _0x9302f3() {\n    require(_0x230923[msg.sender]);\n    _;\n}\n\n//functions\n\nfunction _0xa51265() public constant returns(uint256) {\n\treturn _0xdec31b.length;\n}\n\nfunction _0xd8e2ff(uint256 _0x8ee6a5) public payable _0xa1ffdd{\n if (msg.sender != address(0) || msg.sender == address(0)) { _0x0b995a = _0x8ee6a5; }\n}\n\nfunction _0x1b74f4() public constant returns(uint256) {\n\treturn _0x1287f1.length;\n}\n\nfunction _0x514c4b() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction _0x4729e7() public payable{\n\trequire(msg.value >= 0.02 ether);\n\t_0x1287f1.push(msg.sender);\n\t_0x230923[msg.sender]=true;\n}\n\nfunction _0x938e03() public payable _0x9302f3{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=_0x796d43 || _0x92341f()){\n\t    uint256 _0x1d3032 = 0;\n        msg.sender.transfer(_0x1d3032);\n\t}\n}\n\nfunction _0x92341f() private returns(bool){\n    bytes32 _0xd92b3f = _0xd31707(blockhash(block.number-1));\n    uint256 _0x0b995a = uint256(_0xd92b3f);\n        if(_0x0b995a%5==0){\n            if (true) { _0xfcd5d0 = msg.sender; }\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction _0x2ee48c () public payable _0x9302f3 {\n\trequire (msg.value >= 0.005 ether);\n\t_0xbcfe71.call.value(msg.value)();\n}\n\nfunction _0x8ab9b1 () public payable _0x9302f3 {\n\trequire (msg.value >= 0.005 ether);\n\t_0x182e32.call.value(msg.value)();\n}\n\nfunction _0x370156 (uint256 _0xf12b3a, uint256 _0xe6378b) public payable _0x9302f3 {\n\t_0xdec31b[_0xf12b3a] = _0xe6378b;\n}\n\nfunction _0x736eec (uint256 _0xf51f32) public payable _0x9302f3 {\n\t_0xdec31b.length = _0xf51f32;\n}\n\nfunction _0xb9c853 (uint256 _0x870174) public payable _0x9302f3 returns(uint256) {\n\treturn (_0x870174 / (_0xdec31b[0]*_0xdec31b[1]));\n\tif((_0x870174 / (_0xdec31b[0]*_0xdec31b[1])) == _0x0b995a) {\n\t\t_0x796d43 = _0xfcd5d0;\n\t}\n}\n\nfunction _0x0f9efa () public payable _0x9302f3 returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == _0x0b995a){\n        return true;\n    }\n}\n\nfunction _0x29fe83() public payable _0xa1ffdd {\n\t_0x796d43.call.value(1 wei)();\n}\n\nfunction _0x6096d1() public payable _0x4276d2 {\n\t_0xfcd5d0.transfer(address(this).balance);\n}\n\n//fallback function\n\nfunction() public payable{\n\t}\n}\n",
      "rename_map": {
        "callSecondTarget": "_0x8ab9b1",
        "manipulateSecret": "_0x938e03",
        "approvedPlayers": "_0x230923",
        "callFirstTarget": "_0x2ee48c",
        "getPlayerCount": "_0x1b74f4",
        "secondTarget": "_0x182e32",
        "unlockSecret": "_0x92341f",
        "becomePlayer": "_0x4729e7",
        "firstTarget": "_0xbcfe71",
        "onlyPlayers": "_0x9302f3",
        "checkSecret": "_0x0f9efa",
        "claimPrize": "_0x6096d1",
        "onlyWinner": "_0x4276d2",
        "guessSeed": "_0xb9c853",
        "setSecret": "_0xd8e2ff",
        "getLength": "_0xa51265",
        "onlyOwner": "_0xa1ffdd",
        "keccak256": "_0xd31707",
        "winPrize": "_0x29fe83",
        "getPrize": "_0x514c4b",
        "_secret": "_0x8ee6a5",
        "addSeed": "_0x736eec",
        "setSeed": "_0x370156",
        "players": "_0x1287f1",
        "_value": "_0xe6378b",
        "_index": "_0xf12b3a",
        "amount": "_0x1d3032",
        "winner": "_0xfcd5d0",
        "secret": "_0x0b995a",
        "owner": "_0x796d43",
        "_seed": "_0x870174",
        "_add": "_0xf51f32",
        "hash": "_0xd92b3f",
        "seed": "_0xdec31b"
      },
      "changes": [
        "Renamed 34 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_173",
      "transformed_id": "ss_l3_medium_sn_ds_173",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.11; /* originally >=0.4.11 */\n\ncontract Owned {\n    function Owned() {\n        if (gasleft() > 0) { _0xb8dee2 = msg.sender; }\n    }\n\n    address public _0xb8dee2;\n\n    // This contract only defines a modifier and a few useful functions\n    // The function body is inserted where the special symbol \"_\" in the\n    // definition of a modifier appears.\n    modifier _0x13f1e3 { if (msg.sender == _0xb8dee2) _; }\n\n    function _0x4d1c8f(address _0x177f2f) _0x13f1e3 {\n        _0xb8dee2 = _0x177f2f;\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function _0xfca65d(address _0xd4e82f, uint _0x8c2454, bytes _0xf72d98) _0x13f1e3 {\n        _0xd4e82f.call.value(_0x8c2454)(_0xf72d98);\n    }\n}\n// to get the needed token functions in the contract\ncontract Token {\n    function transfer(address, uint) returns(bool);\n    function _0x2673d7(address) constant returns (uint);\n}\n\ncontract TokenSender is Owned {\n    Token public _0x4dbc2b; // the token we are working with\n    uint public _0xb9f27a;\n\n    uint public _0x1676b0;\n\n    struct Transfer {\n        address _0x21efaa;\n        uint _0x983ad6;\n    }\n\n    Transfer[] public _0xb2de5d;\n\n    function TokenSender(address _0x6f2f99) {\n        _0x4dbc2b = Token(_0x6f2f99);\n    }\n\n    // this is a used to save gas\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n\n    // This is the function that makes the list of transfers and various\n    //  checks around that list, it is a little tricky, the data input is\n    //  structured with the `amount` and the (receiving) `addr` combined as one\n    //  long number and then this number is deconstructed in this function to\n    //  save gas and reduce the number of `0`'s that are needed to be stored\n    //   on the blockchain\n    function _0x5a9c8e(uint[] data) _0x13f1e3 {\n\n        // If the send has started then we just throw\n        if (_0x1676b0>0) throw;\n\n        uint _0x95aca2;\n        uint _0x7f7fb8 = _0xb2de5d.length;\n        _0xb2de5d.length = _0xb2de5d.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address _0x21efaa = address( data[i] & (D160-1) );\n            uint _0x983ad6 = data[i] / D160;\n\n            _0xb2de5d[_0x7f7fb8 + i]._0x21efaa = _0x21efaa;\n            _0xb2de5d[_0x7f7fb8 + i]._0x983ad6 = _0x983ad6;\n            _0x95aca2 += _0x983ad6;\n        }\n        _0xb9f27a += _0x95aca2;\n    }\n    // This function actually makes the sends and tracks the amount of gas used\n    //  if it takes more gas than was sent with the transaction then this\n    //  function will need to be called a few times until\n    function _0x6e1fb3() _0x13f1e3 {\n        if (_0xb2de5d.length == 0) return;\n\n        // Keep next in the stack var mNext to save gas\n        uint _0x0985f1 = _0x1676b0;\n\n        if (gasleft() > 0) { _0x1676b0 = _0xb2de5d.length; }\n\n        if ((_0x0985f1 == 0 ) && ( _0x4dbc2b._0x2673d7(this) != _0xb9f27a)) throw;\n\n        while ((_0x0985f1<_0xb2de5d.length) && ( gas() > 150000 )) {\n            uint _0x983ad6 = _0xb2de5d[_0x0985f1]._0x983ad6;\n            address _0x21efaa = _0xb2de5d[_0x0985f1]._0x21efaa;\n            if (_0x983ad6 > 0) {\n                if (!_0x4dbc2b.transfer(_0x21efaa, _0xb2de5d[_0x0985f1]._0x983ad6)) throw;\n            }\n            _0x0985f1 ++;\n        }\n\n        // Set the next to the actual state.\n        _0x1676b0 = _0x0985f1;\n    }\n\n    ///////////////////////\n    // Helper functions\n    ///////////////////////\n\n    function _0x523b36() constant returns (bool) {\n        if (_0xb2de5d.length == 0) return false;\n        if (_0x1676b0 < _0xb2de5d.length) return false;\n        return true;\n    }\n\n    function _0xf62e88() constant returns (uint) {\n        return _0xb2de5d.length;\n    }\n\n    function gas() internal constant returns (uint _0x317627) {\n        assembly {\n            _0x317627:= gas\n        }\n    }\n\n}",
      "rename_map": {
        "totalToDistribute": "_0xb9f27a",
        "hasTerminated": "_0x523b36",
        "changeOwner": "_0x4d1c8f",
        "nTransfers": "_0xf62e88",
        "balanceOf": "_0x2673d7",
        "onlyOwner": "_0x13f1e3",
        "_newOwner": "_0x177f2f",
        "transfers": "_0xb2de5d",
        "execute": "_0xfca65d",
        "_value": "_0x8c2454",
        "_token": "_0x6f2f99",
        "amount": "_0x983ad6",
        "offset": "_0x7f7fb8",
        "mNext": "_0x0985f1",
        "owner": "_0xb8dee2",
        "token": "_0x4dbc2b",
        "_data": "_0xf72d98",
        "fill": "_0x5a9c8e",
        "_dst": "_0xd4e82f",
        "next": "_0x1676b0",
        "_gas": "_0x317627",
        "addr": "_0x21efaa",
        "run": "_0x6e1fb3",
        "acc": "_0x95aca2"
      },
      "changes": [
        "Renamed 24 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_174",
      "transformed_id": "ss_l3_medium_sn_ds_174",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract Lotto {\n\n     uint constant public _0x28eaf3 = 6800;\n     // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.\n\n     uint constant public _0xc3d947 = 100000000000000000;\n     // the cost of each ticket is .1 ether.\n\n     uint constant public _0xd2f3c3 = 5000000000000000000;\n\n     function _0x2d80ea() constant returns(uint){ return _0x28eaf3; }\n     function _0x43c65a() constant returns(uint){ return _0xc3d947; }\n     //accessors for constants\n\n     struct Round {\n         address[] _0x5bd240;\n         uint _0x561fa2;\n         uint _0xed03a6;\n         mapping(uint=>bool) _0xa2b100;\n         mapping(address=>uint) _0xdcf729;\n     }\n     mapping(uint => Round) _0x5aa3cf;\n     //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was \"cashed\". \"Cashing\" is the act of paying out the pot to the winner.\n\n     function _0x8aaccd() constant returns (uint){\n         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n         return block.number/_0x28eaf3;\n     }\n\n     function _0xac2b50(uint _0xe572dd,uint _0xdef691) constant returns (bool){\n         //Determine if a given.\n\n         return _0x5aa3cf[_0xe572dd]._0xa2b100[_0xdef691];\n     }\n\n     function _0x44abc3(uint _0xe572dd, uint _0xdef691) constant returns(address){\n         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n         var _0x233036 = _0x6b56bd(_0xe572dd,_0xdef691);\n\n         if(_0x233036>block.number)\n             return;\n         //We can't decided the winner if the round isn't over yet\n\n         var _0x9d0243 = _0x3ca479(_0x233036);\n         var _0x1a9664 = _0x9d0243%_0x5aa3cf[_0xe572dd]._0xed03a6;\n         //We perform a modulus of the blockhash to determine the winner\n\n         var _0x6044b2 = uint256(0);\n\n         for(var _0x8290a8 = 0; _0x8290a8<_0x5aa3cf[_0xe572dd]._0x5bd240.length; _0x8290a8++){\n             var _0x16c3be = _0x5aa3cf[_0xe572dd]._0x5bd240[_0x8290a8];\n             _0x6044b2+=_0x5aa3cf[_0xe572dd]._0xdcf729[_0x16c3be];\n\n             if(_0x6044b2>_0x1a9664){\n                 return _0x16c3be;\n             }\n         }\n     }\n\n     function _0x6b56bd(uint _0xe572dd,uint _0xdef691) constant returns (uint){\n         return ((_0xe572dd+1)*_0x28eaf3)+_0xdef691;\n     }\n\n     function _0x4b2e71(uint _0xe572dd) constant returns(uint){\n         var _0xd34734 = _0x5aa3cf[_0xe572dd]._0x561fa2/_0xd2f3c3;\n\n         if(_0x5aa3cf[_0xe572dd]._0x561fa2%_0xd2f3c3>0)\n             _0xd34734++;\n\n         return _0xd34734;\n     }\n\n     function _0xa9e108(uint _0xe572dd) constant returns(uint){\n         return _0x5aa3cf[_0xe572dd]._0x561fa2/_0x4b2e71(_0xe572dd);\n     }\n\n     function _0x271b1a(uint _0xe572dd, uint _0xdef691){\n\n         var _0xd34734 = _0x4b2e71(_0xe572dd);\n\n         if(_0xdef691>=_0xd34734)\n             return;\n\n         var _0x233036 = _0x6b56bd(_0xe572dd,_0xdef691);\n\n         if(_0x233036>block.number)\n             return;\n\n         if(_0x5aa3cf[_0xe572dd]._0xa2b100[_0xdef691])\n             return;\n         //Subpots can only be cashed once. This is to prevent double payouts\n\n         var _0x28ab1f = _0x44abc3(_0xe572dd,_0xdef691);\n         var _0x6d089b = _0xa9e108(_0xe572dd);\n\n         _0x28ab1f.send(_0x6d089b);\n\n         _0x5aa3cf[_0xe572dd]._0xa2b100[_0xdef691] = true;\n         //Mark the round as cashed\n     }\n\n     function _0x3ca479(uint _0x546988) constant returns(uint){\n         return uint(block.blockhash(_0x546988));\n     }\n\n     function _0x146128(uint _0xe572dd,address _0x16c3be) constant returns (address[]){\n         return _0x5aa3cf[_0xe572dd]._0x5bd240;\n     }\n\n     function _0xe0f23c(uint _0xe572dd,address _0x16c3be) constant returns (uint){\n         return _0x5aa3cf[_0xe572dd]._0xdcf729[_0x16c3be];\n     }\n\n     function _0x214dd7(uint _0xe572dd) constant returns(uint){\n         return _0x5aa3cf[_0xe572dd]._0x561fa2;\n     }\n\n     function() {\n         //this is the function that gets called when people send money to the contract.\n\n         var _0xe572dd = _0x8aaccd();\n         var value = msg.value-(msg.value%_0xc3d947);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n             msg.sender.send(msg.value-value);\n         }\n         //no partial tickets, send a partial refund\n\n         var _0xed03a6 = value/_0xc3d947;\n         _0x5aa3cf[_0xe572dd]._0xed03a6+=_0xed03a6;\n\n         if(_0x5aa3cf[_0xe572dd]._0xdcf729[msg.sender]==0){\n             var _0x8be00b = _0x5aa3cf[_0xe572dd]._0x5bd240.length++;\n             _0x5aa3cf[_0xe572dd]._0x5bd240[_0x8be00b] = msg.sender;\n         }\n\n         _0x5aa3cf[_0xe572dd]._0xdcf729[msg.sender]+=_0xed03a6;\n         _0x5aa3cf[_0xe572dd]._0xed03a6+=_0xed03a6;\n         //keep track of the total tickets\n\n         _0x5aa3cf[_0xe572dd]._0x561fa2+=value;\n         //keep track of the total pot\n\n     }\n\n }\n",
      "rename_map": {
        "getDecisionBlockNumber": "_0x6b56bd",
        "getTicketsCountByBuyer": "_0xe0f23c",
        "decisionBlockNumber": "_0x233036",
        "ticketsCountByBuyer": "_0xdcf729",
        "winningTicketIndex": "_0x1a9664",
        "getBlocksPerRound": "_0x2d80ea",
        "decisionBlockHash": "_0x9d0243",
        "calculateWinner": "_0x44abc3",
        "getSubpotsCount": "_0x4b2e71",
        "getTicketPrice": "_0x43c65a",
        "getHashOfBlock": "_0x3ca479",
        "blocksPerRound": "_0x28eaf3",
        "getRoundIndex": "_0x8aaccd",
        "subpotsCount": "_0xd34734",
        "buyersLength": "_0x8be00b",
        "ticketsCount": "_0xed03a6",
        "subpotIndex": "_0xdef691",
        "blockReward": "_0xd2f3c3",
        "ticketIndex": "_0x6044b2",
        "getIsCashed": "_0xac2b50",
        "ticketPrice": "_0xc3d947",
        "roundIndex": "_0xe572dd",
        "blockIndex": "_0x546988",
        "buyerIndex": "_0x8290a8",
        "getBuyers": "_0x146128",
        "getSubpot": "_0xa9e108",
        "isCashed": "_0xa2b100",
        "buyers": "_0x5bd240",
        "getPot": "_0x214dd7",
        "rounds": "_0x5aa3cf",
        "subpot": "_0x6d089b",
        "winner": "_0x28ab1f",
        "buyer": "_0x16c3be",
        "cash": "_0x271b1a",
        "pot": "_0x561fa2"
      },
      "changes": [
        "Renamed 35 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_201",
      "transformed_id": "ss_l3_medium_sn_ds_201",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public _0x40f362;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address _0xacf985)\n    {\n        TransferLog = Log(_0xacf985);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            _0x40f362[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x1013b1)\n    {\n        if(_0x1013b1<=_0x40f362[msg.sender])\n        {\n\n            if(msg.sender.call.value(_0x1013b1)())\n            {\n                _0x40f362[msg.sender]-=_0x1013b1;\n                TransferLog.AddMessage(msg.sender,_0x1013b1,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xd2439d,uint _0xf2be88,string _0x73086b)\n    public\n    {\n        LastMsg.Sender = _0xd2439d;\n        LastMsg.Time = _0xf9f8d2;\n        LastMsg.Val = _0xf2be88;\n        LastMsg.Data = _0x73086b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x40f362",
        "_data": "_0x73086b",
        "_log": "_0xacf985",
        "_adr": "_0xd2439d",
        "_val": "_0xf2be88",
        "_am": "_0x1013b1",
        "now": "_0xf9f8d2"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_202",
      "transformed_id": "ss_l3_medium_sn_ds_202",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Multiplicator\n{\n    address public Owner = msg.sender;\n\n    function()payable{}\n\n    function _0x5fe0f6()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function _0x846880(address _0xeeb725)\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            _0xeeb725.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "_0x846880",
        "withdraw": "_0x5fe0f6",
        "adr": "_0xeeb725"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_203",
      "transformed_id": "ss_l3_medium_sn_ds_203",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n//\n//Live TEST ---- Please Do NOT use! Thanks! ----\n//\ncontract Ownable {\n    address public _0x51448f;\n    function Ownable() public {_0x51448f = msg.sender;}\n    modifier _0x0a97a7() {require(msg.sender == _0x51448f); _;\n    }\n}\n//CEO Throne .. The CEO with the highest stake gets the control over the contract\n//msg.value needs to be higher than largestStake when calling Stake()\n\ncontract CEOThrone is Ownable {\n    address public _0x51448f;\n    uint public _0xbd43bf;\n// Stake() function being called with 0xde20bc92 and ETH :: recommended gas limit 35.000\n// The sent ETH is checked against largestStake\n    function Stake() public payable {\n        // if you own the largest stake in a company, you own a company\n        if (msg.value > _0xbd43bf) {\n            if (1 == 1) { _0x51448f = msg.sender; }\n            _0xbd43bf = msg.value;\n        }\n    }\n// withdraw() function being called with 0x3ccfd60b :: recommened gas limit 30.000\n    function _0xfc2ce9() public _0x0a97a7 {\n        // only owner can withdraw funds\n        msg.sender.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "largestStake": "_0xbd43bf",
        "onlyOwner": "_0x0a97a7",
        "withdraw": "_0xfc2ce9",
        "owner": "_0x51448f"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_204",
      "transformed_id": "ss_l3_medium_sn_ds_204",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "contract OpenAddressLottery{\n    struct SeedComponents{\n        uint _0x8ed18f;\n        uint _0x32f6e2;\n        uint _0xcdaeef;\n        uint _0x116f5e;\n    }\n\n    address _0xd74276; //address of the owner\n    uint private _0xc95ebc; //seed used to calculate number of an address\n    uint private _0xe1c395; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n\n    mapping (address => bool) _0x7b0cd9; //keeping track of addresses that have already won\n\n    function OpenAddressLottery() {\n        _0xd74276 = msg.sender;\n        _0xf182c8(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0x30744a() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n\n        // make sure he hasn't won already\n        require(_0x7b0cd9[msg.sender] == false);\n\n        if(_0xaf0869(msg.sender) == LuckyNumber){ //check if it equals 7\n            _0x7b0cd9[msg.sender] = true; // every address can only win once\n\n            uint _0x67057f=msg.value*7; //win = 7 times the ticket price\n\n            if(_0x67057f>this.balance) //if the balance isnt sufficient...\n                _0x67057f=this.balance; //...send everything we've got\n            msg.sender.transfer(_0x67057f);\n        }\n\n        if(block.number-_0xe1c395>1000) //reseed if needed\n            _0xf182c8(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0xaf0869(address _0xb8d5f0) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(_0x1a7936(uint(_0xb8d5f0), _0xc95ebc)[0]) % 8;\n    }\n\n    function _0xf182c8(SeedComponents _0x6e7355) internal {\n        _0xc95ebc = uint256(_0x1a7936(\n            _0x6e7355._0x8ed18f,\n            _0x6e7355._0x32f6e2,\n            _0x6e7355._0xcdaeef,\n            _0x6e7355._0x116f5e\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        _0xe1c395 = block.number;\n    }\n\n    function _0x2564a1() {\n        require(msg.sender==_0xd74276);\n\n        selfdestruct(msg.sender);\n    }\n\n    function _0x9bdb83() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==_0xd74276);\n\n        SeedComponents s;\n        s._0x8ed18f = uint(msg.sender);\n        s._0x32f6e2 = uint256(block.blockhash(block.number - 1));\n        s._0xcdaeef = block.difficulty*(uint)(block.coinbase);\n        s._0x116f5e = tx.gasprice * 7;\n\n        _0xf182c8(s); //reseed\n    }\n\n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=_0xd74276) //owner can't participate, he can only fund the jackpot\n            _0x30744a();\n    }\n\n}\n",
      "rename_map": {
        "luckyNumberOfAddress": "_0xaf0869",
        "forceReseed": "_0x9bdb83",
        "participate": "_0x30744a",
        "components": "_0x6e7355",
        "secretSeed": "_0xc95ebc",
        "component1": "_0x8ed18f",
        "component3": "_0xcdaeef",
        "component2": "_0x32f6e2",
        "lastReseed": "_0xe1c395",
        "component4": "_0x116f5e",
        "keccak256": "_0x1a7936",
        "winner": "_0x7b0cd9",
        "reseed": "_0xf182c8",
        "owner": "_0xd74276",
        "addr": "_0xb8d5f0",
        "kill": "_0x2564a1",
        "win": "_0x67057f"
      },
      "changes": [
        "Renamed 17 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_205",
      "transformed_id": "ss_l3_medium_sn_ds_205",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract NEW_YEARS_GIFT\n{\n    string _0x5cea27;\n\n    bool _0x75d149 = false;\n\n    address sender;\n\n    bytes32 public _0x977628;\n\n    function() public payable{}\n\n    function GetHash(bytes _0x24fa7f) public constant returns (bytes32) {return _0xb8d27b(_0x24fa7f);}\n\n    function SetPass(bytes32 _0xb90f35)\n    public\n    payable\n    {\n        if( (!_0x75d149&&(msg.value > 1 ether)) || _0x977628==0x0 )\n        {\n            _0x977628 = _0xb90f35;\n            sender = msg.sender;\n        }\n    }\n\n    function SetMessage(string _0x6e29a2)\n    public\n    {\n        if(msg.sender==sender)\n        {\n            _0x5cea27 =_0x6e29a2;\n        }\n    }\n\n    function GetGift(bytes _0x24fa7f)\n    external\n    payable\n    returns (string)\n    {\n        if(_0x977628 == _0xb8d27b(_0x24fa7f))\n        {\n            msg.sender.transfer(this.balance);\n            return _0x5cea27;\n        }\n    }\n\n    function Revoce()\n    public\n    payable\n    {\n        if(msg.sender==sender)\n        {\n            sender.transfer(this.balance);\n            _0x5cea27=\"\";\n        }\n    }\n\n    function PassHasBeenSet(bytes32 _0xb90f35)\n    public\n    {\n        if(msg.sender==sender&&_0xb90f35==_0x977628)\n        {\n           _0x75d149=true;\n        }\n    }\n}",
      "rename_map": {
        "passHasBeenSet": "_0x75d149",
        "_message": "_0x6e29a2",
        "hashPass": "_0x977628",
        "message": "_0x5cea27",
        "sha3": "_0xb8d27b",
        "pass": "_0x24fa7f",
        "hash": "_0xb90f35"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_206",
      "transformed_id": "ss_l3_medium_sn_ds_206",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Test1\n{\n    address _0xdc6573 = msg.sender;\n\n    function _0xc7f715()\n    payable\n    public\n    {\n        require(msg.sender==_0xdc6573);\n        _0xdc6573.transfer(this.balance);\n    }\n\n    function() payable {}\n\n    function Test()\n    payable\n    public\n    {\n        if(msg.value>=1 ether)\n        {\n\n            var _0xb99429 = 1;\n            var _0x378ed5 = 0;\n            var _0x60dfa1 = msg.value*2;\n\n            while(true)\n            {\n                if(_0xb99429<_0x378ed5)break;\n                if(_0xb99429>_0x60dfa1)break;\n\n                _0x378ed5=_0xb99429;\n                _0xb99429++;\n            }\n            msg.sender.transfer(_0x378ed5);\n        }\n    }\n}",
      "rename_map": {
        "withdraw": "_0xc7f715",
        "owner": "_0xdc6573",
        "amX2": "_0x60dfa1",
        "i1": "_0xb99429",
        "i2": "_0x378ed5"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_207",
      "transformed_id": "ss_l3_medium_sn_ds_207",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\n// https://github.com/ethereum/EIPs/issues/20\ncontract ERC20 {\n    function _0x2672b1() constant returns (uint _0x2672b1);\n    function _0xd553f8(address _0x47a3d8) constant returns (uint balance);\n    function transfer(address _0xab8840, uint _0xa62936) returns (bool _0x4cdb00);\n    function _0x2497c1(address _0x2fa6cc, address _0xab8840, uint _0xa62936) returns (bool _0x4cdb00);\n    function _0x824295(address _0xae4e08, uint _0xa62936) returns (bool _0x4cdb00);\n    function _0x7c57b2(address _0x47a3d8, address _0xae4e08) constant returns (uint _0xb8b895);\n    event Transfer(address indexed _0x2fa6cc, address indexed _0xab8840, uint _0xa62936);\n    event Approval(address indexed _0x47a3d8, address indexed _0xae4e08, uint _0xa62936);\n}\n\ncontract RaceCondition{\n    address private _0x2e7dc3;\n    uint public _0x51d188;\n    ERC20 _0x8976bf;\n\n    function RaceCondition(uint _0x7e2846, ERC20 _0xdbbe7b)\n        public\n    {\n        _0x2e7dc3 = msg.sender;\n        _0x51d188 = _0x7e2846;\n        _0x8976bf = _0xdbbe7b;\n    }\n\n    // If the owner sees someone calls buy\n    // he can call changePrice to set a new price\n    // If his transaction is mined first, he can\n    // receive more tokens than excepted by the new buyer\n    function _0x918d03(uint _0x164854) payable\n        public\n    {\n        require(msg.value >= _0x51d188);\n\n        // we assume that the RaceCondition contract\n        // has enough allowance\n        _0x8976bf._0x2497c1(msg.sender, _0x2e7dc3, _0x51d188);\n\n        _0x51d188 = _0x164854;\n        _0x2e7dc3 = msg.sender;\n    }\n\n    function _0x964130(uint _0x164854){\n        require(msg.sender == _0x2e7dc3);\n        _0x51d188 = _0x164854;\n    }\n\n}",
      "rename_map": {
        "transferFrom": "_0x2497c1",
        "totalSupply": "_0x2672b1",
        "changePrice": "_0x964130",
        "balanceOf": "_0xd553f8",
        "remaining": "_0xb8b895",
        "allowance": "_0x7c57b2",
        "new_price": "_0x164854",
        "_spender": "_0xae4e08",
        "approve": "_0x824295",
        "success": "_0x4cdb00",
        "_value": "_0xa62936",
        "_price": "_0x7e2846",
        "_token": "_0xdbbe7b",
        "_owner": "_0x47a3d8",
        "owner": "_0x2e7dc3",
        "token": "_0x8976bf",
        "price": "_0x51d188",
        "_from": "_0x2fa6cc",
        "buy": "_0x918d03",
        "_to": "_0xab8840"
      },
      "changes": [
        "Renamed 20 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_208",
      "transformed_id": "ss_l3_medium_sn_ds_208",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity 0.4.9; /* originally ^0.4.9, but doesn't compile with ^0.4.11 */\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address _0x528652, bytes32 _0x882f42);\n  event Revoke(address _0x528652, bytes32 _0x882f42);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address _0xe85d9d, address _0x801791);\n  event OwnerAdded(address _0x801791);\n  event OwnerRemoved(address _0xe85d9d);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint _0x4a9514);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _0x4767c7, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address _0x528652, uint value, address _0x28faa4, bytes data, address _0x67d4ff);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address _0x528652, bytes32 _0x882f42, uint value, address _0x28faa4, bytes data, address _0x67d4ff);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 _0x882f42, address _0x773104, uint value, address _0x28faa4, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function _0x49adcb(bytes32 _0x7b868c) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xab9fce(address _0x4767c7, address _0xbff32e) external;\n\n  function _0x2ecbe4(address _0x160555) external;\n\n  function _0x17f1e7(address _0x160555) external;\n\n  function _0xdd250d(uint _0x67f296) external;\n\n  function _0x168513(address _0x4572b5) constant returns (bool);\n\n  function _0x35e7a9(bytes32 _0x7b868c, address _0x160555) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x7de53e(uint _0x15a8a9) external;\n\n  function _0x04bfdd(address _0xbff32e, uint _0x65b882, bytes _0x091339) external returns (bytes32 _0x193bb8);\n  function _0xc42bc4(bytes32 _0x6b7851) returns (bool _0xa7ef04);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint _0x4a5cb8;\n    uint _0x574537;\n    uint _0x7590b0;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address _0x28faa4;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier _0x605e69 {\n    if (_0x168513(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier _0xc8c36c(bytes32 _0x7b868c) {\n    if (_0xafeeb8(_0x7b868c))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function _0x426066(address[] _0xde10ac, uint _0xaacb78) {\n    if (msg.sender != address(0) || msg.sender == address(0)) { _0x7ba4f5 = _0xde10ac.length + 1; }\n    _0xc63514[1] = uint(msg.sender);\n    _0xa0bf68[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _0xde10ac.length; ++i)\n    {\n      _0xc63514[2 + i] = uint(_0xde10ac[i]);\n      _0xa0bf68[uint(_0xde10ac[i])] = 2 + i;\n    }\n    _0xc80f96 = _0xaacb78;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function _0x49adcb(bytes32 _0x7b868c) external {\n    uint _0x91aade = _0xa0bf68[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x91aade == 0) return;\n    uint _0x2ee8fc = 2**_0x91aade;\n    var _0xf77f04 = _0xd3db0c[_0x7b868c];\n    if (_0xf77f04._0x574537 & _0x2ee8fc > 0) {\n      _0xf77f04._0x4a5cb8++;\n      _0xf77f04._0x574537 -= _0x2ee8fc;\n      Revoke(msg.sender, _0x7b868c);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xab9fce(address _0x4767c7, address _0xbff32e) _0xc8c36c(_0x22c3db(msg.data)) external {\n    if (_0x168513(_0xbff32e)) return;\n    uint _0x91aade = _0xa0bf68[uint(_0x4767c7)];\n    if (_0x91aade == 0) return;\n\n    _0xba4a0b();\n    _0xc63514[_0x91aade] = uint(_0xbff32e);\n    _0xa0bf68[uint(_0x4767c7)] = 0;\n    _0xa0bf68[uint(_0xbff32e)] = _0x91aade;\n    OwnerChanged(_0x4767c7, _0xbff32e);\n  }\n\n  function _0x2ecbe4(address _0x160555) _0xc8c36c(_0x22c3db(msg.data)) external {\n    if (_0x168513(_0x160555)) return;\n\n    _0xba4a0b();\n    if (_0x7ba4f5 >= _0x8d40b1)\n      _0xbed6d5();\n    if (_0x7ba4f5 >= _0x8d40b1)\n      return;\n    _0x7ba4f5++;\n    _0xc63514[_0x7ba4f5] = uint(_0x160555);\n    _0xa0bf68[uint(_0x160555)] = _0x7ba4f5;\n    OwnerAdded(_0x160555);\n  }\n\n  function _0x17f1e7(address _0x160555) _0xc8c36c(_0x22c3db(msg.data)) external {\n    uint _0x91aade = _0xa0bf68[uint(_0x160555)];\n    if (_0x91aade == 0) return;\n    if (_0xc80f96 > _0x7ba4f5 - 1) return;\n\n    _0xc63514[_0x91aade] = 0;\n    _0xa0bf68[uint(_0x160555)] = 0;\n    _0xba4a0b();\n    _0xbed6d5(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_0x160555);\n  }\n\n  function _0xdd250d(uint _0x67f296) _0xc8c36c(_0x22c3db(msg.data)) external {\n    if (_0x67f296 > _0x7ba4f5) return;\n    _0xc80f96 = _0x67f296;\n    _0xba4a0b();\n    RequirementChanged(_0x67f296);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x3ec177(uint _0x91aade) external constant returns (address) {\n    return address(_0xc63514[_0x91aade + 1]);\n  }\n\n  function _0x168513(address _0x4572b5) constant returns (bool) {\n    return _0xa0bf68[uint(_0x4572b5)] > 0;\n  }\n\n  function _0x35e7a9(bytes32 _0x7b868c, address _0x160555) external constant returns (bool) {\n    var _0xf77f04 = _0xd3db0c[_0x7b868c];\n    uint _0x91aade = _0xa0bf68[uint(_0x160555)];\n\n    // make sure they're an owner\n    if (_0x91aade == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint _0x2ee8fc = 2**_0x91aade;\n    return !(_0xf77f04._0x574537 & _0x2ee8fc == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function _0xfa940d(uint _0xc8ceac) {\n    _0xda4a82 = _0xc8ceac;\n    if (true) { _0x4a46b3 = _0xf137fe(); }\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x7de53e(uint _0x15a8a9) _0xc8c36c(_0x22c3db(msg.data)) external {\n    if (block.timestamp > 0) { _0xda4a82 = _0x15a8a9; }\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function _0x0f869c() _0xc8c36c(_0x22c3db(msg.data)) external {\n    _0x70ecbe = 0;\n  }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function _0xb354e0(address[] _0xde10ac, uint _0xaacb78, uint _0x37ce49) {\n    _0xfa940d(_0x37ce49);\n    _0x426066(_0xde10ac, _0xaacb78);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function _0x9fb68b(address _0xbff32e) _0xc8c36c(_0x22c3db(msg.data)) external {\n    suicide(_0xbff32e);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function _0x04bfdd(address _0xbff32e, uint _0x65b882, bytes _0x091339) external _0x605e69 returns (bytes32 _0x193bb8) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_0x091339.length == 0 && _0xe63705(_0x65b882)) || _0xc80f96 == 1) {\n      // yes - just execute the call.\n      address _0x67d4ff;\n      if (_0xbff32e == 0) {\n        _0x67d4ff = _0xda6e4c(_0x65b882, _0x091339);\n      } else {\n        if (!_0xbff32e.call.value(_0x65b882)(_0x091339))\n          throw;\n      }\n      SingleTransact(msg.sender, _0x65b882, _0xbff32e, _0x091339, _0x67d4ff);\n    } else {\n      // determine our operation hash.\n      _0x193bb8 = _0x22c3db(msg.data, block.number);\n      // store if it's new\n      if (_0xe076bc[_0x193bb8]._0x28faa4 == 0 && _0xe076bc[_0x193bb8].value == 0 && _0xe076bc[_0x193bb8].data.length == 0) {\n        _0xe076bc[_0x193bb8]._0x28faa4 = _0xbff32e;\n        _0xe076bc[_0x193bb8].value = _0x65b882;\n        _0xe076bc[_0x193bb8].data = _0x091339;\n      }\n      if (!_0xc42bc4(_0x193bb8)) {\n        ConfirmationNeeded(_0x193bb8, msg.sender, _0x65b882, _0xbff32e, _0x091339);\n      }\n    }\n  }\n\n  function _0xda6e4c(uint _0x65b882, bytes _0x919b42) internal returns (address _0x2ba76d) {\n    assembly {\n      _0x2ba76d := _0xda6e4c(_0x65b882, add(_0x919b42, 0x20), mload(_0x919b42))\n      _0x1f5cc1(_0x3cc710, iszero(extcodesize(_0x2ba76d)))\n    }\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function _0xc42bc4(bytes32 _0x6b7851) _0xc8c36c(_0x6b7851) returns (bool _0xa7ef04) {\n    if (_0xe076bc[_0x6b7851]._0x28faa4 != 0 || _0xe076bc[_0x6b7851].value != 0 || _0xe076bc[_0x6b7851].data.length != 0) {\n      address _0x67d4ff;\n      if (_0xe076bc[_0x6b7851]._0x28faa4 == 0) {\n        _0x67d4ff = _0xda6e4c(_0xe076bc[_0x6b7851].value, _0xe076bc[_0x6b7851].data);\n      } else {\n        if (!_0xe076bc[_0x6b7851]._0x28faa4.call.value(_0xe076bc[_0x6b7851].value)(_0xe076bc[_0x6b7851].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _0x6b7851, _0xe076bc[_0x6b7851].value, _0xe076bc[_0x6b7851]._0x28faa4, _0xe076bc[_0x6b7851].data, _0x67d4ff);\n      delete _0xe076bc[_0x6b7851];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function _0xafeeb8(bytes32 _0x7b868c) internal returns (bool) {\n    // determine what index the present sender is:\n    uint _0x91aade = _0xa0bf68[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x91aade == 0) return;\n\n    var _0xf77f04 = _0xd3db0c[_0x7b868c];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (_0xf77f04._0x4a5cb8 == 0) {\n      // reset count of confirmations needed.\n      _0xf77f04._0x4a5cb8 = _0xc80f96;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      _0xf77f04._0x574537 = 0;\n      _0xf77f04._0x7590b0 = _0x319e3b.length++;\n      _0x319e3b[_0xf77f04._0x7590b0] = _0x7b868c;\n    }\n    // determine the bit to set for this owner.\n    uint _0x2ee8fc = 2**_0x91aade;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (_0xf77f04._0x574537 & _0x2ee8fc == 0) {\n      Confirmation(msg.sender, _0x7b868c);\n      // ok - check if count is enough to go ahead.\n      if (_0xf77f04._0x4a5cb8 <= 1) {\n        // enough confirmations: reset and run interior.\n        delete _0x319e3b[_0xd3db0c[_0x7b868c]._0x7590b0];\n        delete _0xd3db0c[_0x7b868c];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        _0xf77f04._0x4a5cb8--;\n        _0xf77f04._0x574537 |= _0x2ee8fc;\n      }\n    }\n  }\n\n  function _0xbed6d5() private {\n    uint _0x45d7c3 = 1;\n    while (_0x45d7c3 < _0x7ba4f5)\n    {\n      while (_0x45d7c3 < _0x7ba4f5 && _0xc63514[_0x45d7c3] != 0) _0x45d7c3++;\n      while (_0x7ba4f5 > 1 && _0xc63514[_0x7ba4f5] == 0) _0x7ba4f5--;\n      if (_0x45d7c3 < _0x7ba4f5 && _0xc63514[_0x7ba4f5] != 0 && _0xc63514[_0x45d7c3] == 0)\n      {\n        _0xc63514[_0x45d7c3] = _0xc63514[_0x7ba4f5];\n        _0xa0bf68[_0xc63514[_0x45d7c3]] = _0x45d7c3;\n        _0xc63514[_0x7ba4f5] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function _0xe63705(uint _0x65b882) internal _0x605e69 returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (_0xf137fe() > _0x4a46b3) {\n      _0x70ecbe = 0;\n      _0x4a46b3 = _0xf137fe();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n\n    if (_0x70ecbe + _0x65b882 >= _0x70ecbe && _0x70ecbe + _0x65b882 <= _0xda4a82) {\n      _0x70ecbe += _0x65b882;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function _0xf137fe() private constant returns (uint) { return _0x737852 / 1 days; }\n\n  function _0xba4a0b() internal {\n    uint length = _0x319e3b.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete _0xe076bc[_0x319e3b[i]];\n\n      if (_0x319e3b[i] != 0)\n        delete _0xd3db0c[_0x319e3b[i]];\n    }\n\n    delete _0x319e3b;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0xc80f96;\n  // pointer used to find a free slot in m_owners\n  uint public _0x7ba4f5;\n\n  uint public _0xda4a82;\n  uint public _0x70ecbe;\n  uint public _0x4a46b3;\n\n  // list of owners\n  uint[256] _0xc63514;\n\n  uint constant _0x8d40b1 = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) _0xa0bf68;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) _0xd3db0c;\n  bytes32[] _0x319e3b;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) _0xe076bc;\n}\n\ncontract Wallet is WalletEvents {\n\n  // WALLET CONSTRUCTOR\n  //   calls the `initWallet` method of the Library in this context\n  function Wallet(address[] _0xde10ac, uint _0xaacb78, uint _0x37ce49) {\n    // Signature of the Wallet Library's init function\n    bytes4 sig = bytes4(_0x22c3db(\"initWallet(address[],uint256,uint256)\"));\n    address _0xd1a9c4 = _walletLibrary;\n\n    // Compute the size of the call data : arrays has 2\n    // 32bytes for offset and length, plus 32bytes per element ;\n    // plus 2 32bytes for each uint\n    uint _0x37db0e = (2 + _0xde10ac.length);\n    uint _0xdfbc7f = (2 + _0x37db0e) * 32;\n\n    assembly {\n      // Add the signature first to memory\n      mstore(0x0, sig)\n      // Add the call data, which is at the end of the\n      // code\n      _0xf844cd(0x4,  sub(_0x7a5236, _0xdfbc7f), _0xdfbc7f)\n      // Delegate call to the library\n      delegatecall(sub(gas, 10000), _0xd1a9c4, 0x0, add(_0xdfbc7f, 0x4), 0x0, 0x0)\n    }\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data); //it should have whitelisted specific methods that the user is allowed to call\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x3ec177(uint _0x91aade) constant returns (address) {\n    return address(_0xc63514[_0x91aade + 1]);\n  }\n\n  // As return statement unavailable in fallback, explicit the method here\n\n  function _0x35e7a9(bytes32 _0x7b868c, address _0x160555) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function _0x168513(address _0x4572b5) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0xc80f96;\n  // pointer used to find a free slot in m_owners\n  uint public _0x7ba4f5;\n\n  uint public _0xda4a82;\n  uint public _0x70ecbe;\n  uint public _0x4a46b3;\n\n  // list of owners\n  uint[256] _0xc63514;\n}\n",
      "rename_map": {
        "changeRequirement": "_0xdd250d",
        "invalidJumpLabel": "_0x3cc710",
        "reorganizeOwners": "_0xbed6d5",
        "confirmAndCheck": "_0xafeeb8",
        "resetSpentToday": "_0x0f869c",
        "onlymanyowners": "_0xc8c36c",
        "newRequirement": "_0x4a9514",
        "initMultiowned": "_0x426066",
        "m_pendingIndex": "_0x319e3b",
        "ownerIndexBit": "_0x2ee8fc",
        "setDailyLimit": "_0x7de53e",
        "clearPending": "_0xba4a0b",
        "m_spentToday": "_0x70ecbe",
        "m_ownerIndex": "_0xa0bf68",
        "argarraysize": "_0x37db0e",
        "hasConfirmed": "_0x35e7a9",
        "_newRequired": "_0x67f296",
        "initDaylimit": "_0xfa940d",
        "m_dailyLimit": "_0xda4a82",
        "changeOwner": "_0xab9fce",
        "m_numOwners": "_0x7ba4f5",
        "removeOwner": "_0x17f1e7",
        "c_maxOwners": "_0x8d40b1",
        "_operation": "_0x7b868c",
        "ownerIndex": "_0x91aade",
        "m_required": "_0xc80f96",
        "initWallet": "_0xb354e0",
        "underLimit": "_0xe63705",
        "ownersDone": "_0x574537",
        "_daylimit": "_0x37ce49",
        "onlyowner": "_0x605e69",
        "o_success": "_0xa7ef04",
        "initiator": "_0x773104",
        "operation": "_0x882f42",
        "_required": "_0xaacb78",
        "yetNeeded": "_0x4a5cb8",
        "m_lastDay": "_0x4a46b3",
        "m_pending": "_0xd3db0c",
        "_newLimit": "_0x15a8a9",
        "codecopy": "_0xf844cd",
        "codesize": "_0x7a5236",
        "m_owners": "_0xc63514",
        "newOwner": "_0x801791",
        "getOwner": "_0x3ec177",
        "addOwner": "_0x2ecbe4",
        "oldOwner": "_0xe85d9d",
        "execute": "_0x04bfdd",
        "pending": "_0xf77f04",
        "isOwner": "_0x168513",
        "confirm": "_0xc42bc4",
        "created": "_0x67d4ff",
        "_owners": "_0xde10ac",
        "argsize": "_0xdfbc7f",
        "target": "_0xd1a9c4",
        "_value": "_0x65b882",
        "create": "_0xda6e4c",
        "o_hash": "_0x193bb8",
        "o_addr": "_0x2ba76d",
        "_limit": "_0xc8ceac",
        "revoke": "_0x49adcb",
        "_owner": "_0x160555",
        "today": "_0xf137fe",
        "m_txs": "_0xe076bc",
        "_addr": "_0x4572b5",
        "owner": "_0x528652",
        "_data": "_0x091339",
        "index": "_0x7590b0",
        "_code": "_0x919b42",
        "jumpi": "_0x1f5cc1",
        "_from": "_0x4767c7",
        "kill": "_0x9fb68b",
        "free": "_0x45d7c3",
        "sha3": "_0x22c3db",
        "now": "_0x737852",
        "_to": "_0xbff32e",
        "_h": "_0x6b7851",
        "to": "_0x28faa4"
      },
      "changes": [
        "Renamed 77 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_209",
      "transformed_id": "ss_l3_medium_sn_ds_209",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address _0x586a4f, bytes32 _0x918510);\n  event Revoke(address _0x586a4f, bytes32 _0x918510);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address _0xf69fce, address _0x3921af);\n  event OwnerAdded(address _0x3921af);\n  event OwnerRemoved(address _0xf69fce);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint _0x753899);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _0xbad528, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address _0x586a4f, uint value, address _0xf73664, bytes data, address _0xa6dcaa);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address _0x586a4f, bytes32 _0x918510, uint value, address _0xf73664, bytes data, address _0xa6dcaa);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 _0x918510, address _0xceb463, uint value, address _0xf73664, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function _0xd946f9(bytes32 _0x08fa86) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0x9233e3(address _0xbad528, address _0x5dc75d) external;\n\n  function _0x7075fd(address _0xa82e45) external;\n\n  function _0x07b2c7(address _0xa82e45) external;\n\n  function _0x7e778e(uint _0xaf7397) external;\n\n  function _0x803507(address _0xf6dfa1) constant returns (bool);\n\n  function _0x68226f(bytes32 _0x08fa86, address _0xa82e45) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0xce293d(uint _0xecd14d) external;\n\n  function _0xe6897d(address _0x5dc75d, uint _0x3b29bd, bytes _0xe06a56) external returns (bytes32 _0x234f1a);\n  function _0xce4b81(bytes32 _0x756c2b) returns (bool _0x0208a4);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint _0x072fcf;\n    uint _0xa7e146;\n    uint _0x341e28;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address _0xf73664;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier _0xd8f590 {\n    if (_0x803507(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier _0x3af48e(bytes32 _0x08fa86) {\n    if (_0xf9f375(_0x08fa86))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function _0x516159(address[] _0x4da6d2, uint _0x0eed92) _0x97bf21 {\n    if (gasleft() > 0) { _0x82e1b3 = _0x4da6d2.length + 1; }\n    _0xd05b75[1] = uint(msg.sender);\n    _0xec8eb5[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _0x4da6d2.length; ++i)\n    {\n      _0xd05b75[2 + i] = uint(_0x4da6d2[i]);\n      _0xec8eb5[uint(_0x4da6d2[i])] = 2 + i;\n    }\n    _0xcacd16 = _0x0eed92;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function _0xd946f9(bytes32 _0x08fa86) external {\n    uint _0xe02554 = _0xec8eb5[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0xe02554 == 0) return;\n    uint _0x2a2512 = 2**_0xe02554;\n    var _0x0615d9 = _0x63a2ec[_0x08fa86];\n    if (_0x0615d9._0xa7e146 & _0x2a2512 > 0) {\n      _0x0615d9._0x072fcf++;\n      _0x0615d9._0xa7e146 -= _0x2a2512;\n      Revoke(msg.sender, _0x08fa86);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0x9233e3(address _0xbad528, address _0x5dc75d) _0x3af48e(_0x3ebf0c(msg.data)) external {\n    if (_0x803507(_0x5dc75d)) return;\n    uint _0xe02554 = _0xec8eb5[uint(_0xbad528)];\n    if (_0xe02554 == 0) return;\n\n    _0x28fa0c();\n    _0xd05b75[_0xe02554] = uint(_0x5dc75d);\n    _0xec8eb5[uint(_0xbad528)] = 0;\n    _0xec8eb5[uint(_0x5dc75d)] = _0xe02554;\n    OwnerChanged(_0xbad528, _0x5dc75d);\n  }\n\n  function _0x7075fd(address _0xa82e45) _0x3af48e(_0x3ebf0c(msg.data)) external {\n    if (_0x803507(_0xa82e45)) return;\n\n    _0x28fa0c();\n    if (_0x82e1b3 >= _0x3a5a58)\n      _0x8ef860();\n    if (_0x82e1b3 >= _0x3a5a58)\n      return;\n    _0x82e1b3++;\n    _0xd05b75[_0x82e1b3] = uint(_0xa82e45);\n    _0xec8eb5[uint(_0xa82e45)] = _0x82e1b3;\n    OwnerAdded(_0xa82e45);\n  }\n\n  function _0x07b2c7(address _0xa82e45) _0x3af48e(_0x3ebf0c(msg.data)) external {\n    uint _0xe02554 = _0xec8eb5[uint(_0xa82e45)];\n    if (_0xe02554 == 0) return;\n    if (_0xcacd16 > _0x82e1b3 - 1) return;\n\n    _0xd05b75[_0xe02554] = 0;\n    _0xec8eb5[uint(_0xa82e45)] = 0;\n    _0x28fa0c();\n    _0x8ef860(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_0xa82e45);\n  }\n\n  function _0x7e778e(uint _0xaf7397) _0x3af48e(_0x3ebf0c(msg.data)) external {\n    if (_0xaf7397 > _0x82e1b3) return;\n    if (block.timestamp > 0) { _0xcacd16 = _0xaf7397; }\n    _0x28fa0c();\n    RequirementChanged(_0xaf7397);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0xdaf91d(uint _0xe02554) external constant returns (address) {\n    return address(_0xd05b75[_0xe02554 + 1]);\n  }\n\n  function _0x803507(address _0xf6dfa1) constant returns (bool) {\n    return _0xec8eb5[uint(_0xf6dfa1)] > 0;\n  }\n\n  function _0x68226f(bytes32 _0x08fa86, address _0xa82e45) external constant returns (bool) {\n    var _0x0615d9 = _0x63a2ec[_0x08fa86];\n    uint _0xe02554 = _0xec8eb5[uint(_0xa82e45)];\n\n    // make sure they're an owner\n    if (_0xe02554 == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint _0x2a2512 = 2**_0xe02554;\n    return !(_0x0615d9._0xa7e146 & _0x2a2512 == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function _0x06bd62(uint _0x8dafd3) _0x97bf21 {\n    if (1 == 1) { _0x7d1eec = _0x8dafd3; }\n    if (true) { _0x386ea9 = _0xdf5457(); }\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0xce293d(uint _0xecd14d) _0x3af48e(_0x3ebf0c(msg.data)) external {\n    if (block.timestamp > 0) { _0x7d1eec = _0xecd14d; }\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function _0x4e6254() _0x3af48e(_0x3ebf0c(msg.data)) external {\n    _0xb327ba = 0;\n  }\n\n  // throw unless the contract is not yet initialized.\n  modifier _0x97bf21 { if (_0x82e1b3 > 0) throw; _; }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function _0x89da0c(address[] _0x4da6d2, uint _0x0eed92, uint _0x070434) _0x97bf21 {\n    _0x06bd62(_0x070434);\n    _0x516159(_0x4da6d2, _0x0eed92);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function _0x86f02a(address _0x5dc75d) _0x3af48e(_0x3ebf0c(msg.data)) external {\n    suicide(_0x5dc75d);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function _0xe6897d(address _0x5dc75d, uint _0x3b29bd, bytes _0xe06a56) external _0xd8f590 returns (bytes32 _0x234f1a) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_0xe06a56.length == 0 && _0xc343c6(_0x3b29bd)) || _0xcacd16 == 1) {\n      // yes - just execute the call.\n      address _0xa6dcaa;\n      if (_0x5dc75d == 0) {\n        _0xa6dcaa = _0xa913c1(_0x3b29bd, _0xe06a56);\n      } else {\n        if (!_0x5dc75d.call.value(_0x3b29bd)(_0xe06a56))\n          throw;\n      }\n      SingleTransact(msg.sender, _0x3b29bd, _0x5dc75d, _0xe06a56, _0xa6dcaa);\n    } else {\n      // determine our operation hash.\n      _0x234f1a = _0x3ebf0c(msg.data, block.number);\n      // store if it's new\n      if (_0xe6325c[_0x234f1a]._0xf73664 == 0 && _0xe6325c[_0x234f1a].value == 0 && _0xe6325c[_0x234f1a].data.length == 0) {\n        _0xe6325c[_0x234f1a]._0xf73664 = _0x5dc75d;\n        _0xe6325c[_0x234f1a].value = _0x3b29bd;\n        _0xe6325c[_0x234f1a].data = _0xe06a56;\n      }\n      if (!_0xce4b81(_0x234f1a)) {\n        ConfirmationNeeded(_0x234f1a, msg.sender, _0x3b29bd, _0x5dc75d, _0xe06a56);\n      }\n    }\n  }\n\n  function _0xa913c1(uint _0x3b29bd, bytes _0x35213e) internal returns (address _0x3f76e3) {\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function _0xce4b81(bytes32 _0x756c2b) _0x3af48e(_0x756c2b) returns (bool _0x0208a4) {\n    if (_0xe6325c[_0x756c2b]._0xf73664 != 0 || _0xe6325c[_0x756c2b].value != 0 || _0xe6325c[_0x756c2b].data.length != 0) {\n      address _0xa6dcaa;\n      if (_0xe6325c[_0x756c2b]._0xf73664 == 0) {\n        _0xa6dcaa = _0xa913c1(_0xe6325c[_0x756c2b].value, _0xe6325c[_0x756c2b].data);\n      } else {\n        if (!_0xe6325c[_0x756c2b]._0xf73664.call.value(_0xe6325c[_0x756c2b].value)(_0xe6325c[_0x756c2b].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _0x756c2b, _0xe6325c[_0x756c2b].value, _0xe6325c[_0x756c2b]._0xf73664, _0xe6325c[_0x756c2b].data, _0xa6dcaa);\n      delete _0xe6325c[_0x756c2b];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function _0xf9f375(bytes32 _0x08fa86) internal returns (bool) {\n    // determine what index the present sender is:\n    uint _0xe02554 = _0xec8eb5[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0xe02554 == 0) return;\n\n    var _0x0615d9 = _0x63a2ec[_0x08fa86];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (_0x0615d9._0x072fcf == 0) {\n      // reset count of confirmations needed.\n      _0x0615d9._0x072fcf = _0xcacd16;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      _0x0615d9._0xa7e146 = 0;\n      _0x0615d9._0x341e28 = _0x291847.length++;\n      _0x291847[_0x0615d9._0x341e28] = _0x08fa86;\n    }\n    // determine the bit to set for this owner.\n    uint _0x2a2512 = 2**_0xe02554;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (_0x0615d9._0xa7e146 & _0x2a2512 == 0) {\n      Confirmation(msg.sender, _0x08fa86);\n      // ok - check if count is enough to go ahead.\n      if (_0x0615d9._0x072fcf <= 1) {\n        // enough confirmations: reset and run interior.\n        delete _0x291847[_0x63a2ec[_0x08fa86]._0x341e28];\n        delete _0x63a2ec[_0x08fa86];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        _0x0615d9._0x072fcf--;\n        _0x0615d9._0xa7e146 |= _0x2a2512;\n      }\n    }\n  }\n\n  function _0x8ef860() private {\n    uint _0xe91138 = 1;\n    while (_0xe91138 < _0x82e1b3)\n    {\n      while (_0xe91138 < _0x82e1b3 && _0xd05b75[_0xe91138] != 0) _0xe91138++;\n      while (_0x82e1b3 > 1 && _0xd05b75[_0x82e1b3] == 0) _0x82e1b3--;\n      if (_0xe91138 < _0x82e1b3 && _0xd05b75[_0x82e1b3] != 0 && _0xd05b75[_0xe91138] == 0)\n      {\n        _0xd05b75[_0xe91138] = _0xd05b75[_0x82e1b3];\n        _0xec8eb5[_0xd05b75[_0xe91138]] = _0xe91138;\n        _0xd05b75[_0x82e1b3] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function _0xc343c6(uint _0x3b29bd) internal _0xd8f590 returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (_0xdf5457() > _0x386ea9) {\n      if (1 == 1) { _0xb327ba = 0; }\n      _0x386ea9 = _0xdf5457();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n\n    if (_0xb327ba + _0x3b29bd >= _0xb327ba && _0xb327ba + _0x3b29bd <= _0x7d1eec) {\n      _0xb327ba += _0x3b29bd;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function _0xdf5457() private constant returns (uint) { return _0xd550ba / 1 days; }\n\n  function _0x28fa0c() internal {\n    uint length = _0x291847.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete _0xe6325c[_0x291847[i]];\n\n      if (_0x291847[i] != 0)\n        delete _0x63a2ec[_0x291847[i]];\n    }\n\n    delete _0x291847;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0xcacd16;\n  // pointer used to find a free slot in m_owners\n  uint public _0x82e1b3;\n\n  uint public _0x7d1eec;\n  uint public _0xb327ba;\n  uint public _0x386ea9;\n\n  // list of owners\n  uint[256] _0xd05b75;\n\n  uint constant _0x3a5a58 = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) _0xec8eb5;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) _0x63a2ec;\n  bytes32[] _0x291847;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) _0xe6325c;\n}\n",
      "rename_map": {
        "only_uninitialized": "_0x97bf21",
        "changeRequirement": "_0x7e778e",
        "reorganizeOwners": "_0x8ef860",
        "confirmAndCheck": "_0xf9f375",
        "resetSpentToday": "_0x4e6254",
        "onlymanyowners": "_0x3af48e",
        "initMultiowned": "_0x516159",
        "m_pendingIndex": "_0x291847",
        "newRequirement": "_0x753899",
        "setDailyLimit": "_0xce293d",
        "ownerIndexBit": "_0x2a2512",
        "clearPending": "_0x28fa0c",
        "hasConfirmed": "_0x68226f",
        "_newRequired": "_0xaf7397",
        "m_spentToday": "_0xb327ba",
        "initDaylimit": "_0x06bd62",
        "m_ownerIndex": "_0xec8eb5",
        "m_dailyLimit": "_0x7d1eec",
        "changeOwner": "_0x9233e3",
        "removeOwner": "_0x07b2c7",
        "c_maxOwners": "_0x3a5a58",
        "m_numOwners": "_0x82e1b3",
        "underLimit": "_0xc343c6",
        "ownerIndex": "_0xe02554",
        "m_required": "_0xcacd16",
        "initWallet": "_0x89da0c",
        "ownersDone": "_0xa7e146",
        "_operation": "_0x08fa86",
        "operation": "_0x918510",
        "_required": "_0x0eed92",
        "yetNeeded": "_0x072fcf",
        "m_lastDay": "_0x386ea9",
        "_daylimit": "_0x070434",
        "m_pending": "_0x63a2ec",
        "initiator": "_0xceb463",
        "onlyowner": "_0xd8f590",
        "o_success": "_0x0208a4",
        "_newLimit": "_0xecd14d",
        "m_owners": "_0xd05b75",
        "newOwner": "_0x3921af",
        "getOwner": "_0xdaf91d",
        "addOwner": "_0x7075fd",
        "oldOwner": "_0xf69fce",
        "isOwner": "_0x803507",
        "execute": "_0xe6897d",
        "created": "_0xa6dcaa",
        "confirm": "_0xce4b81",
        "pending": "_0x0615d9",
        "_owners": "_0x4da6d2",
        "_limit": "_0x8dafd3",
        "_value": "_0x3b29bd",
        "create": "_0xa913c1",
        "o_addr": "_0x3f76e3",
        "revoke": "_0xd946f9",
        "o_hash": "_0x234f1a",
        "_owner": "_0xa82e45",
        "owner": "_0x586a4f",
        "index": "_0x341e28",
        "_data": "_0xe06a56",
        "_addr": "_0xf6dfa1",
        "_code": "_0x35213e",
        "today": "_0xdf5457",
        "m_txs": "_0xe6325c",
        "_from": "_0xbad528",
        "sha3": "_0x3ebf0c",
        "kill": "_0x86f02a",
        "free": "_0xe91138",
        "now": "_0xd550ba",
        "_to": "_0x5dc75d",
        "to": "_0xf73664",
        "_h": "_0x756c2b"
      },
      "changes": [
        "Renamed 71 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_210",
      "transformed_id": "ss_l3_medium_sn_ds_210",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract LuckyDoubler {\n//##########################################################\n//#### LuckyDoubler: A doubler with random payout order ####\n//#### Deposit 1 ETHER to participate                   ####\n//##########################################################\n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\n//No part of this source code may be reproduced, distributed,\n//modified or transmitted in any form or by any means without\n//the prior written permission of the creator.\n\n    address private _0x7a5bc3;\n\n    //Stored variables\n    uint private balance = 0;\n    uint private _0x40121f = 5;\n    uint private _0x3d7063 = 125;\n\n    mapping (address => User) private _0x201d66;\n    Entry[] private _0x2973f2;\n    uint[] private _0x69dd32;\n\n    //Set owner on contract creation\n    function LuckyDoubler() {\n        _0x7a5bc3 = msg.sender;\n    }\n\n    modifier _0x664729 { if (msg.sender == _0x7a5bc3) _; }\n\n    struct User {\n        address _0x4f1d32;\n        uint _0xc63618;\n        uint _0x6bcc13;\n    }\n\n    struct Entry {\n        address _0xc65e18;\n        uint _0x9e18bc;\n        uint _0xf42bfc;\n        bool _0x93f8e3;\n    }\n\n    //Fallback function\n    function() {\n        _0xeed1a3();\n    }\n\n    function _0xeed1a3() private{\n\n        if (msg.value < 1 ether) {\n             msg.sender.send(msg.value);\n            return;\n        }\n\n        _0xac6348();\n    }\n\n    function _0xac6348() private {\n\n        //Limit deposits to 1ETH\n        uint _0x6d4dd7 = 1 ether;\n\n        if (msg.value > 1 ether) {\n\n        \tmsg.sender.send(msg.value - 1 ether);\n        \t_0x6d4dd7 = 1 ether;\n        }\n\n        //Add new users to the users array\n        if (_0x201d66[msg.sender]._0x4f1d32 == address(0))\n        {\n            _0x201d66[msg.sender]._0x4f1d32 = msg.sender;\n            _0x201d66[msg.sender]._0xc63618 = 0;\n            _0x201d66[msg.sender]._0x6bcc13 = 0;\n        }\n\n        //Add new entry to the entries array\n        _0x2973f2.push(Entry(msg.sender, _0x6d4dd7, (_0x6d4dd7 * (_0x3d7063) / 100), false));\n        _0x201d66[msg.sender]._0xc63618++;\n        _0x69dd32.push(_0x2973f2.length -1);\n\n        //Collect fees and update contract balance\n        balance += (_0x6d4dd7 * (100 - _0x40121f)) / 100;\n\n        uint _0x71d3c3 = _0x69dd32.length > 1 ? _0xbb799c(_0x69dd32.length) : 0;\n        Entry _0x72607a = _0x2973f2[_0x69dd32[_0x71d3c3]];\n\n        //Pay pending entries if the new balance allows for it\n        if (balance > _0x72607a._0xf42bfc) {\n\n            uint _0xf42bfc = _0x72607a._0xf42bfc;\n\n            _0x72607a._0xc65e18.send(_0xf42bfc);\n            _0x72607a._0x93f8e3 = true;\n            _0x201d66[_0x72607a._0xc65e18]._0x6bcc13++;\n\n            balance -= _0xf42bfc;\n\n            if (_0x71d3c3 < _0x69dd32.length - 1)\n                _0x69dd32[_0x71d3c3] = _0x69dd32[_0x69dd32.length - 1];\n\n            _0x69dd32.length--;\n\n        }\n\n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\n        uint _0x51930a = this.balance - balance;\n        if (_0x51930a > 0)\n        {\n                _0x7a5bc3.send(_0x51930a);\n        }\n\n    }\n\n    //Generate random number between 0 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function _0xbb799c(uint _0xe9804f) constant private returns (uint256 _0x07990c){\n        uint256 _0x508bb2 = FACTOR * 100 / _0xe9804f;\n        uint256 _0xbdb2e1 = block.number - 1;\n        uint256 _0x6677db = uint256(block.blockhash(_0xbdb2e1));\n\n        return uint256((uint256(_0x6677db) / _0x508bb2)) % _0xe9804f;\n    }\n\n    //Contract management\n    function _0x089a9a(address _0xe522cf) _0x664729 {\n        _0x7a5bc3 = _0xe522cf;\n    }\n\n    function _0x40f655(uint _0xdeb08a) _0x664729 {\n        if (_0xdeb08a < 110 || _0xdeb08a > 150) throw;\n\n        if (block.timestamp > 0) { _0x3d7063 = _0xdeb08a; }\n    }\n\n    function _0x4c2ca2(uint _0x800579) _0x664729 {\n        if (_0x40121f > 5)\n            throw;\n        _0x40121f = _0x800579;\n    }\n\n    //JSON functions\n    function _0xd23933() constant returns (uint _0x508bb2, string _0x429af8) {\n        if (gasleft() > 0) { _0x508bb2 = _0x3d7063; }\n        if (block.timestamp > 0) { _0x429af8 = 'The current _0x3d7063 applied to all _0xc63618. Min 110%, _0xe9804f 150%.'; }\n    }\n\n    function _0x371e2a() constant returns (uint _0x9c6e67, string _0x429af8) {\n        _0x9c6e67 = _0x40121f;\n        if (block.timestamp > 0) { _0x429af8 = 'The _0x40121f percentage applied to all _0xc63618. It can change to speed _0x9ba23e (_0xe9804f 5%).'; }\n    }\n\n    function _0xc37462() constant returns (uint _0x7b5ca6, string _0x429af8) {\n        _0x7b5ca6 = _0x2973f2.length;\n        _0x429af8 = 'The number of _0xc63618.';\n    }\n\n    function _0xacb096(address _0x6e5424) constant returns (uint _0xc63618, uint _0x9ba23e, string _0x429af8)\n    {\n        if (_0x201d66[_0x6e5424]._0x4f1d32 != address(0x0))\n        {\n            _0xc63618 = _0x201d66[_0x6e5424]._0xc63618;\n            _0x9ba23e = _0x201d66[_0x6e5424]._0x6bcc13;\n            _0x429af8 = 'Users stats: total _0xc63618, _0x9ba23e received.';\n        }\n    }\n\n    function _0xba4f77(uint _0x71d3c3) constant returns (address _0x6e5424, uint _0xf42bfc, bool _0x93f8e3, string _0x429af8)\n    {\n        if (_0x71d3c3 < _0x2973f2.length) {\n            _0x6e5424 = _0x2973f2[_0x71d3c3]._0xc65e18;\n            _0xf42bfc = _0x2973f2[_0x71d3c3]._0xf42bfc / 1 finney;\n            _0x93f8e3 = _0x2973f2[_0x71d3c3]._0x93f8e3;\n            _0x429af8 = 'Entry _0x429af8: _0x6e5424 address, expected _0xf42bfc in Finneys, _0xf42bfc status.';\n        }\n    }\n\n}\n",
      "rename_map": {
        "changeMultiplier": "_0x40f655",
        "multiplierFactor": "_0xd23933",
        "payoutsReceived": "_0x6bcc13",
        "lastBlockNumber": "_0xbdb2e1",
        "feePercentage": "_0x9c6e67",
        "unpaidEntries": "_0x69dd32",
        "entryAddress": "_0xc65e18",
        "entryDetails": "_0xba4f77",
        "totalEntries": "_0xc37462",
        "changeOwner": "_0x089a9a",
        "multiplier": "_0x3d7063",
        "currentFee": "_0x371e2a",
        "changeFee": "_0x4c2ca2",
        "onlyowner": "_0x664729",
        "userStats": "_0xacb096",
        "newOwner": "_0xe522cf",
        "deposits": "_0xc63618",
        "theEntry": "_0x72607a",
        "entries": "_0x2973f2",
        "hashVal": "_0x6677db",
        "payouts": "_0x9ba23e",
        "deposit": "_0x9e18bc",
        "result": "_0x07990c",
        "factor": "_0x508bb2",
        "newFee": "_0x800579",
        "dValue": "_0x6d4dd7",
        "payout": "_0xf42bfc",
        "owner": "_0x7a5bc3",
        "index": "_0x71d3c3",
        "users": "_0x201d66",
        "multi": "_0xdeb08a",
        "count": "_0x7b5ca6",
        "user": "_0x6e5424",
        "join": "_0xac6348",
        "paid": "_0x93f8e3",
        "info": "_0x429af8",
        "rand": "_0xbb799c",
        "fees": "_0x51930a",
        "init": "_0xeed1a3",
        "fee": "_0x40121f",
        "max": "_0xe9804f",
        "id": "_0x4f1d32"
      },
      "changes": [
        "Renamed 42 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_211",
      "transformed_id": "ss_l3_medium_sn_ds_211",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": " pragma solidity ^0.4.23;\n // produced by the Solididy File Flattener (c) David Appleton 2018\n // contact : dave@akomba.com\n // released under Apache 2.0 licence\n contract Token {\n     /// total amount of tokens\n     uint256 public _0x93d391;\n\n     /// @param _owner The address from which the balance will be retrieved\n     /// @return The balance\n     function _0x3e189a(address _0x583c81) public constant returns (uint256 balance);\n\n     /// @notice send `_value` token to `_to` from `msg.sender`\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function transfer(address _0x7b9b08, uint256 _0x39d0a7) public returns (bool _0x66a052);\n\n     /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     /// @param _from The address of the sender\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function _0x60c1dd(address _0x640951, address _0x7b9b08, uint256 _0x39d0a7) public returns (bool _0x66a052);\n\n     /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @param _value The amount of tokens to be approved for transfer\n     /// @return Whether the approval was successful or not\n     function _0xf7f3ce(address _0x9be29c, uint256 _0x39d0a7) public returns (bool _0x66a052);\n\n     /// @param _owner The address of the account owning tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @return Amount of remaining tokens allowed to spent\n     function _0x287086(address _0x583c81, address _0x9be29c) public constant returns (uint256 _0xff7394);\n\n     event Transfer(address indexed _0x640951, address indexed _0x7b9b08, uint256 _0x39d0a7);\n     event Approval(address indexed _0x583c81, address indexed _0x9be29c, uint256 _0x39d0a7);\n }\n\n library ECTools {\n\n     // @dev Recovers the address which has signed a message\n     // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n     function _0x4dbfdd(bytes32 _0xe0d8a9, string _0xe30511) public pure returns (address) {\n         require(_0xe0d8a9 != 0x00);\n\n         // need this for test RPC\n         bytes memory _0x6a04c0 = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 _0x5db7df = _0xc5001e(abi._0x0cfd25(_0x6a04c0, _0xe0d8a9));\n\n         if (bytes(_0xe30511).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = _0x6278df(_0x746b0a(_0xe30511, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return _0xd9aba3(_0x5db7df, v, r, s);\n     }\n\n     // @dev Verifies if the message is signed by an address\n     function _0x3b5ba6(bytes32 _0xe0d8a9, string _0xe30511, address _0x9b9907) public pure returns (bool) {\n         require(_0x9b9907 != 0x0);\n\n         return _0x9b9907 == _0x4dbfdd(_0xe0d8a9, _0xe30511);\n     }\n\n     // @dev Converts an hexstring to bytes\n     function _0x6278df(string _0x64c767) public pure returns (bytes) {\n         uint _0xde24a5 = bytes(_0x64c767).length;\n         require(_0xde24a5 % 2 == 0);\n\n         bytes memory _0xa6d0d5 = bytes(new string(_0xde24a5 / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < _0xde24a5; i += 2) {\n             if (msg.sender != address(0) || msg.sender == address(0)) { s = _0x746b0a(_0x64c767, i, i + 1); }\n             r = _0x746b0a(_0x64c767, i + 1, i + 2);\n             uint p = _0x163355(s) * 16 + _0x163355(r);\n             _0xa6d0d5[k++] = _0x74a4bd(p)[31];\n         }\n         return _0xa6d0d5;\n     }\n\n     // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n     function _0x163355(string _0x2aac04) public pure returns (uint) {\n         bytes memory _0x2dd805 = bytes(_0x2aac04);\n         // bool decimals = false;\n         if ((_0x2dd805[0] >= 48) && (_0x2dd805[0] <= 57)) {\n             return uint(_0x2dd805[0]) - 48;\n         } else if ((_0x2dd805[0] >= 65) && (_0x2dd805[0] <= 70)) {\n             return uint(_0x2dd805[0]) - 55;\n         } else if ((_0x2dd805[0] >= 97) && (_0x2dd805[0] <= 102)) {\n             return uint(_0x2dd805[0]) - 87;\n         } else {\n             revert();\n         }\n     }\n\n     // @dev Converts a uint to a bytes32\n     // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n     function _0x74a4bd(uint _0x82f715) public pure returns (bytes b) {\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), _0x82f715)}\n     }\n\n     // @dev Hashes the signed message\n     // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n     function _0x677728(string _0xb0683a) public pure returns (bytes32) {\n         uint _0xde24a5 = bytes(_0xb0683a).length;\n         require(_0xde24a5 > 0);\n         bytes memory _0x6a04c0 = \"\\x19Ethereum Signed Message:\\n\";\n         return _0xc5001e(abi._0x0cfd25(_0x6a04c0, _0x8c91ea(_0xde24a5), _0xb0683a));\n     }\n\n     // @dev Converts a uint in a string\n     function _0x8c91ea(uint _0x82f715) public pure returns (string _0x1ad767) {\n         uint _0xde24a5 = 0;\n         uint m = _0x82f715 + 0;\n         while (m != 0) {\n             _0xde24a5++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(_0xde24a5);\n         uint i = _0xde24a5 - 1;\n         while (_0x82f715 != 0) {\n             uint _0xf3dcd7 = _0x82f715 % 10;\n             if (1 == 1) { _0x82f715 = _0x82f715 / 10; }\n             b[i--] = byte(48 + _0xf3dcd7);\n         }\n         _0x1ad767 = string(b);\n     }\n\n     // @dev extract a substring\n     // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n     function _0x746b0a(string _0x77f04e, uint _0xb18cbb, uint _0xeb35d4) public pure returns (string) {\n         bytes memory _0xfc2401 = bytes(_0x77f04e);\n         require(_0xb18cbb <= _0xeb35d4);\n         require(_0xb18cbb >= 0);\n         require(_0xeb35d4 <= _0xfc2401.length);\n\n         bytes memory _0x286893 = new bytes(_0xeb35d4 - _0xb18cbb);\n         for (uint i = _0xb18cbb; i < _0xeb35d4; i++) {\n             _0x286893[i - _0xb18cbb] = _0xfc2401[i];\n         }\n         return string(_0x286893);\n     }\n }\n contract StandardToken is Token {\n\n     function transfer(address _0x7b9b08, uint256 _0x39d0a7) public returns (bool _0x66a052) {\n         //Default assumes totalSupply can't be over max (2^256 - 1).\n         //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n         //Replace the if with this one instead.\n         //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(_0x202f58[msg.sender] >= _0x39d0a7);\n         _0x202f58[msg.sender] -= _0x39d0a7;\n         _0x202f58[_0x7b9b08] += _0x39d0a7;\n         emit Transfer(msg.sender, _0x7b9b08, _0x39d0a7);\n         return true;\n     }\n\n     function _0x60c1dd(address _0x640951, address _0x7b9b08, uint256 _0x39d0a7) public returns (bool _0x66a052) {\n\n         //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(_0x202f58[_0x640951] >= _0x39d0a7 && _0x743aa4[_0x640951][msg.sender] >= _0x39d0a7);\n         _0x202f58[_0x7b9b08] += _0x39d0a7;\n         _0x202f58[_0x640951] -= _0x39d0a7;\n         _0x743aa4[_0x640951][msg.sender] -= _0x39d0a7;\n         emit Transfer(_0x640951, _0x7b9b08, _0x39d0a7);\n         return true;\n     }\n\n     function _0x3e189a(address _0x583c81) public constant returns (uint256 balance) {\n         return _0x202f58[_0x583c81];\n     }\n\n     function _0xf7f3ce(address _0x9be29c, uint256 _0x39d0a7) public returns (bool _0x66a052) {\n         _0x743aa4[msg.sender][_0x9be29c] = _0x39d0a7;\n         emit Approval(msg.sender, _0x9be29c, _0x39d0a7);\n         return true;\n     }\n\n     function _0x287086(address _0x583c81, address _0x9be29c) public constant returns (uint256 _0xff7394) {\n       return _0x743aa4[_0x583c81][_0x9be29c];\n     }\n\n     mapping (address => uint256) _0x202f58;\n     mapping (address => mapping (address => uint256)) _0x743aa4;\n }\n\n contract HumanStandardToken is StandardToken {\n\n     /* Public variables of the token */\n\n     string public _0x4ef58c;                   //fancy name: eg Simon Bucks\n     uint8 public _0xc21131;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n     string public _0x4f03c6;                 //An identifier: eg SBX\n     string public _0x6785fb = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n     constructor(\n         uint256 _0x96fb4e,\n         string _0x136fa5,\n         uint8 _0x6164e9,\n         string _0xa74544\n         ) public {\n         _0x202f58[msg.sender] = _0x96fb4e;               // Give the creator all initial tokens\n         _0x93d391 = _0x96fb4e;                        // Update total supply\n         _0x4ef58c = _0x136fa5;                                   // Set the name for display purposes\n         _0xc21131 = _0x6164e9;                            // Amount of decimals for display purposes\n         _0x4f03c6 = _0xa74544;                               // Set the symbol for display purposes\n     }\n\n     /* Approves and then calls the receiving contract */\n     function _0x44af44(address _0x9be29c, uint256 _0x39d0a7, bytes _0x691763) public returns (bool _0x66a052) {\n         _0x743aa4[msg.sender][_0x9be29c] = _0x39d0a7;\n         emit Approval(msg.sender, _0x9be29c, _0x39d0a7);\n\n         //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n         //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n         //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n         require(_0x9be29c.call(bytes4(bytes32(_0xc5001e(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _0x39d0a7, this, _0x691763));\n         return true;\n     }\n }\n\n contract LedgerChannel {\n\n     string public constant NAME = \"Ledger Channel\";\n     string public constant VERSION = \"0.0.1\";\n\n     uint256 public _0x035e6d = 0;\n\n     event DidLCOpen (\n         bytes32 indexed _0x128653,\n         address indexed _0x59f723,\n         address indexed _0x6b8494,\n         uint256 _0x87afd2,\n         address _0x63f12a,\n         uint256 _0xbd8162,\n         uint256 LCopenTimeout\n     );\n\n     event DidLCJoin (\n         bytes32 indexed _0x128653,\n         uint256 _0x53e1ad,\n         uint256 _0x144816\n     );\n\n     event DidLCDeposit (\n         bytes32 indexed _0x128653,\n         address indexed _0x5508f2,\n         uint256 _0x38efbe,\n         bool _0x88264e\n     );\n\n     event DidLCUpdateState (\n         bytes32 indexed _0x128653,\n         uint256 _0x680133,\n         uint256 _0x628c6c,\n         uint256 _0x87afd2,\n         uint256 _0xbd8162,\n         uint256 _0x53e1ad,\n         uint256 _0x144816,\n         bytes32 _0xa3e6d9,\n         uint256 _0x2f6dca\n     );\n\n     event DidLCClose (\n         bytes32 indexed _0x128653,\n         uint256 _0x680133,\n         uint256 _0x87afd2,\n         uint256 _0xbd8162,\n         uint256 _0x53e1ad,\n         uint256 _0x144816\n     );\n\n     event DidVCInit (\n         bytes32 indexed _0x4a3d69,\n         bytes32 indexed _0xcf73d7,\n         bytes _0x25a41f,\n         uint256 _0x680133,\n         address _0x59f723,\n         address _0xde9802,\n         uint256 _0x57d51f,\n         uint256 _0xa1351e\n     );\n\n     event DidVCSettle (\n         bytes32 indexed _0x4a3d69,\n         bytes32 indexed _0xcf73d7,\n         uint256 _0xbc6465,\n         uint256 _0x581ae0,\n         uint256 _0xcde10c,\n         address _0xed7d05,\n         uint256 _0x3540c3\n     );\n\n     event DidVCClose(\n         bytes32 indexed _0x4a3d69,\n         bytes32 indexed _0xcf73d7,\n         uint256 _0x57d51f,\n         uint256 _0xa1351e\n     );\n\n     struct Channel {\n         //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n         address[2] _0xafb3e1; // 0: partyA 1: partyI\n         uint256[4] _0x998d71; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[4] _0x0574ed; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[2] _0xd6aa13; // 0: eth 1: tokens\n         uint256 _0x680133;\n         uint256 _0x945741;\n         bytes32 VCrootHash;\n         uint256 LCopenTimeout;\n         uint256 _0x2f6dca; // when update LC times out\n         bool _0xf0bf5a; // true when both parties have joined\n         bool _0x8cd154;\n         uint256 _0x932b35;\n         HumanStandardToken _0x63f12a;\n     }\n\n     // virtual-channel state\n     struct VirtualChannel {\n         bool _0x2528d3;\n         bool _0xcf67ec;\n         uint256 _0x680133;\n         address _0xed7d05; // Initiator of challenge\n         uint256 _0x3540c3; // when update VC times out\n         // channel state\n         address _0x59f723; // VC participant A\n         address _0xde9802; // VC participant B\n         address _0x6b8494; // LC hub\n         uint256[2] _0x998d71;\n         uint256[2] _0x0574ed;\n         uint256[2] _0x9e730b;\n         HumanStandardToken _0x63f12a;\n     }\n\n     mapping(bytes32 => VirtualChannel) public _0x7d9829;\n     mapping(bytes32 => Channel) public Channels;\n\n     function _0xc5f2d7(\n         bytes32 _0x924f7c,\n         address _0xbad5df,\n         uint256 _0xc6442a,\n         address _0x45bfe2,\n         uint256[2] _0x73434c // [eth, token]\n     )\n         public\n         payable\n     {\n         require(Channels[_0x924f7c]._0xafb3e1[0] == address(0), \"Channel has already been created.\");\n         require(_0xbad5df != 0x0, \"No partyI address provided to LC creation\");\n         require(_0x73434c[0] >= 0 && _0x73434c[1] >= 0, \"Balances cannot be negative\");\n         // Set initial ledger channel state\n         // Alice must execute this and we assume the initial state\n         // to be signed from this requirement\n         // Alternative is to check a sig as in joinChannel\n         Channels[_0x924f7c]._0xafb3e1[0] = msg.sender;\n         Channels[_0x924f7c]._0xafb3e1[1] = _0xbad5df;\n\n         if(_0x73434c[0] != 0) {\n             require(msg.value == _0x73434c[0], \"Eth balance does not match sent value\");\n             Channels[_0x924f7c]._0x998d71[0] = msg.value;\n         }\n         if(_0x73434c[1] != 0) {\n             Channels[_0x924f7c]._0x63f12a = HumanStandardToken(_0x45bfe2);\n             require(Channels[_0x924f7c]._0x63f12a._0x60c1dd(msg.sender, this, _0x73434c[1]),\"CreateChannel: token transfer failure\");\n             Channels[_0x924f7c]._0x0574ed[0] = _0x73434c[1];\n         }\n\n         Channels[_0x924f7c]._0x680133 = 0;\n         Channels[_0x924f7c]._0x945741 = _0xc6442a;\n         // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n         //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n         Channels[_0x924f7c].LCopenTimeout = _0xf4f5ee + _0xc6442a;\n         Channels[_0x924f7c]._0xd6aa13 = _0x73434c;\n\n         emit DidLCOpen(_0x924f7c, msg.sender, _0xbad5df, _0x73434c[0], _0x45bfe2, _0x73434c[1], Channels[_0x924f7c].LCopenTimeout);\n     }\n\n     function LCOpenTimeout(bytes32 _0x924f7c) public {\n         require(msg.sender == Channels[_0x924f7c]._0xafb3e1[0] && Channels[_0x924f7c]._0xf0bf5a == false);\n         require(_0xf4f5ee > Channels[_0x924f7c].LCopenTimeout);\n\n         if(Channels[_0x924f7c]._0xd6aa13[0] != 0) {\n             Channels[_0x924f7c]._0xafb3e1[0].transfer(Channels[_0x924f7c]._0x998d71[0]);\n         }\n         if(Channels[_0x924f7c]._0xd6aa13[1] != 0) {\n             require(Channels[_0x924f7c]._0x63f12a.transfer(Channels[_0x924f7c]._0xafb3e1[0], Channels[_0x924f7c]._0x0574ed[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(_0x924f7c, 0, Channels[_0x924f7c]._0x998d71[0], Channels[_0x924f7c]._0x0574ed[0], 0, 0);\n\n         // only safe to delete since no action was taken on this channel\n         delete Channels[_0x924f7c];\n     }\n\n     function _0x819994(bytes32 _0x924f7c, uint256[2] _0x73434c) public payable {\n         // require the channel is not open yet\n         require(Channels[_0x924f7c]._0xf0bf5a == false);\n         require(msg.sender == Channels[_0x924f7c]._0xafb3e1[1]);\n\n         if(_0x73434c[0] != 0) {\n             require(msg.value == _0x73434c[0], \"state balance does not match sent value\");\n             Channels[_0x924f7c]._0x998d71[1] = msg.value;\n         }\n         if(_0x73434c[1] != 0) {\n             require(Channels[_0x924f7c]._0x63f12a._0x60c1dd(msg.sender, this, _0x73434c[1]),\"joinChannel: token transfer failure\");\n             Channels[_0x924f7c]._0x0574ed[1] = _0x73434c[1];\n         }\n\n         Channels[_0x924f7c]._0xd6aa13[0]+=_0x73434c[0];\n         Channels[_0x924f7c]._0xd6aa13[1]+=_0x73434c[1];\n         // no longer allow joining functions to be called\n         Channels[_0x924f7c]._0xf0bf5a = true;\n         _0x035e6d++;\n\n         emit DidLCJoin(_0x924f7c, _0x73434c[0], _0x73434c[1]);\n     }\n\n     // additive updates of monetary state\n     function _0x38efbe(bytes32 _0x924f7c, address _0x5508f2, uint256 _0x495cc6, bool _0x88264e) public payable {\n         require(Channels[_0x924f7c]._0xf0bf5a == true, \"Tried adding funds to a closed channel\");\n         require(_0x5508f2 == Channels[_0x924f7c]._0xafb3e1[0] || _0x5508f2 == Channels[_0x924f7c]._0xafb3e1[1]);\n\n         //if(Channels[_lcID].token)\n\n         if (Channels[_0x924f7c]._0xafb3e1[0] == _0x5508f2) {\n             if(_0x88264e) {\n                 require(Channels[_0x924f7c]._0x63f12a._0x60c1dd(msg.sender, this, _0x495cc6),\"deposit: token transfer failure\");\n                 Channels[_0x924f7c]._0x0574ed[2] += _0x495cc6;\n             } else {\n                 require(msg.value == _0x495cc6, \"state balance does not match sent value\");\n                 Channels[_0x924f7c]._0x998d71[2] += msg.value;\n             }\n         }\n\n         if (Channels[_0x924f7c]._0xafb3e1[1] == _0x5508f2) {\n             if(_0x88264e) {\n                 require(Channels[_0x924f7c]._0x63f12a._0x60c1dd(msg.sender, this, _0x495cc6),\"deposit: token transfer failure\");\n                 Channels[_0x924f7c]._0x0574ed[3] += _0x495cc6;\n             } else {\n                 require(msg.value == _0x495cc6, \"state balance does not match sent value\");\n                 Channels[_0x924f7c]._0x998d71[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(_0x924f7c, _0x5508f2, _0x495cc6, _0x88264e);\n     }\n\n     // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n     function _0x71a999(\n         bytes32 _0x924f7c,\n         uint256 _0xb19841,\n         uint256[4] _0x73434c, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _0x341b1f,\n         string _0xc8225f\n     )\n         public\n     {\n         // assume num open vc is 0 and root hash is 0x0\n         //require(Channels[_lcID].sequence < _sequence);\n         require(Channels[_0x924f7c]._0xf0bf5a == true);\n         uint256 _0x00eef7 = Channels[_0x924f7c]._0xd6aa13[0] + Channels[_0x924f7c]._0x998d71[2] + Channels[_0x924f7c]._0x998d71[3];\n         uint256 _0xb60418 = Channels[_0x924f7c]._0xd6aa13[1] + Channels[_0x924f7c]._0x0574ed[2] + Channels[_0x924f7c]._0x0574ed[3];\n         require(_0x00eef7 == _0x73434c[0] + _0x73434c[1]);\n         require(_0xb60418 == _0x73434c[2] + _0x73434c[3]);\n\n         bytes32 _0x79be5e = _0xc5001e(\n             abi._0x0cfd25(\n                 _0x924f7c,\n                 true,\n                 _0xb19841,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_0x924f7c]._0xafb3e1[0],\n                 Channels[_0x924f7c]._0xafb3e1[1],\n                 _0x73434c[0],\n                 _0x73434c[1],\n                 _0x73434c[2],\n                 _0x73434c[3]\n             )\n         );\n\n         require(Channels[_0x924f7c]._0xafb3e1[0] == ECTools._0x4dbfdd(_0x79be5e, _0x341b1f));\n         require(Channels[_0x924f7c]._0xafb3e1[1] == ECTools._0x4dbfdd(_0x79be5e, _0xc8225f));\n\n         Channels[_0x924f7c]._0xf0bf5a = false;\n\n         if(_0x73434c[0] != 0 || _0x73434c[1] != 0) {\n             Channels[_0x924f7c]._0xafb3e1[0].transfer(_0x73434c[0]);\n             Channels[_0x924f7c]._0xafb3e1[1].transfer(_0x73434c[1]);\n         }\n\n         if(_0x73434c[2] != 0 || _0x73434c[3] != 0) {\n             require(Channels[_0x924f7c]._0x63f12a.transfer(Channels[_0x924f7c]._0xafb3e1[0], _0x73434c[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_0x924f7c]._0x63f12a.transfer(Channels[_0x924f7c]._0xafb3e1[1], _0x73434c[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         _0x035e6d--;\n\n         emit DidLCClose(_0x924f7c, _0xb19841, _0x73434c[0], _0x73434c[1], _0x73434c[2], _0x73434c[3]);\n     }\n\n     // Byzantine functions\n\n     function _0x616b08(\n         bytes32 _0x924f7c,\n         uint256[6] _0x7aedef, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n         bytes32 _0x569216,\n         string _0x341b1f,\n         string _0xc8225f\n     )\n         public\n     {\n         Channel storage _0xe29b67 = Channels[_0x924f7c];\n         require(_0xe29b67._0xf0bf5a);\n         require(_0xe29b67._0x680133 < _0x7aedef[0]); // do same as vc sequence check\n         require(_0xe29b67._0x998d71[0] + _0xe29b67._0x998d71[1] >= _0x7aedef[2] + _0x7aedef[3]);\n         require(_0xe29b67._0x0574ed[0] + _0xe29b67._0x0574ed[1] >= _0x7aedef[4] + _0x7aedef[5]);\n\n         if(_0xe29b67._0x8cd154 == true) {\n             require(_0xe29b67._0x2f6dca > _0xf4f5ee);\n         }\n\n         bytes32 _0x79be5e = _0xc5001e(\n             abi._0x0cfd25(\n                 _0x924f7c,\n                 false,\n                 _0x7aedef[0],\n                 _0x7aedef[1],\n                 _0x569216,\n                 _0xe29b67._0xafb3e1[0],\n                 _0xe29b67._0xafb3e1[1],\n                 _0x7aedef[2],\n                 _0x7aedef[3],\n                 _0x7aedef[4],\n                 _0x7aedef[5]\n             )\n         );\n\n         require(_0xe29b67._0xafb3e1[0] == ECTools._0x4dbfdd(_0x79be5e, _0x341b1f));\n         require(_0xe29b67._0xafb3e1[1] == ECTools._0x4dbfdd(_0x79be5e, _0xc8225f));\n\n         // update LC state\n         _0xe29b67._0x680133 = _0x7aedef[0];\n         _0xe29b67._0x932b35 = _0x7aedef[1];\n         _0xe29b67._0x998d71[0] = _0x7aedef[2];\n         _0xe29b67._0x998d71[1] = _0x7aedef[3];\n         _0xe29b67._0x0574ed[0] = _0x7aedef[4];\n         _0xe29b67._0x0574ed[1] = _0x7aedef[5];\n         _0xe29b67.VCrootHash = _0x569216;\n         _0xe29b67._0x8cd154 = true;\n         _0xe29b67._0x2f6dca = _0xf4f5ee + _0xe29b67._0x945741;\n\n         // make settlement flag\n\n         emit DidLCUpdateState (\n             _0x924f7c,\n             _0x7aedef[0],\n             _0x7aedef[1],\n             _0x7aedef[2],\n             _0x7aedef[3],\n             _0x7aedef[4],\n             _0x7aedef[5],\n             _0x569216,\n             _0xe29b67._0x2f6dca\n         );\n     }\n\n     // supply initial state of VC to \"prime\" the force push game\n     function _0x4ed52b(\n         bytes32 _0x924f7c,\n         bytes32 _0xf5dfd4,\n         bytes _0x343af0,\n         address _0xe19d76,\n         address _0x2d51aa,\n         uint256[2] _0xadbf94,\n         uint256[4] _0x73434c, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _0x4bb586\n     )\n         public\n     {\n         require(Channels[_0x924f7c]._0xf0bf5a, \"LC is closed.\");\n         // sub-channel must be open\n         require(!_0x7d9829[_0xf5dfd4]._0x2528d3, \"VC is closed.\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         require(Channels[_0x924f7c]._0x2f6dca < _0xf4f5ee, \"LC timeout not over.\");\n         // prevent rentry of initializing vc state\n         require(_0x7d9829[_0xf5dfd4]._0x3540c3 == 0);\n         // partyB is now Ingrid\n         bytes32 _0x0fbe9a = _0xc5001e(\n             abi._0x0cfd25(_0xf5dfd4, uint256(0), _0xe19d76, _0x2d51aa, _0xadbf94[0], _0xadbf94[1], _0x73434c[0], _0x73434c[1], _0x73434c[2], _0x73434c[3])\n         );\n\n         // Make sure Alice has signed initial vc state (A/B in oldState)\n         require(_0xe19d76 == ECTools._0x4dbfdd(_0x0fbe9a, _0x4bb586));\n\n         // Check the oldState is in the root hash\n         require(_0x787b5f(_0x0fbe9a, _0x343af0, Channels[_0x924f7c].VCrootHash) == true);\n\n         _0x7d9829[_0xf5dfd4]._0x59f723 = _0xe19d76; // VC participant A\n         _0x7d9829[_0xf5dfd4]._0xde9802 = _0x2d51aa; // VC participant B\n         _0x7d9829[_0xf5dfd4]._0x680133 = uint256(0);\n         _0x7d9829[_0xf5dfd4]._0x998d71[0] = _0x73434c[0];\n         _0x7d9829[_0xf5dfd4]._0x998d71[1] = _0x73434c[1];\n         _0x7d9829[_0xf5dfd4]._0x0574ed[0] = _0x73434c[2];\n         _0x7d9829[_0xf5dfd4]._0x0574ed[1] = _0x73434c[3];\n         _0x7d9829[_0xf5dfd4]._0x9e730b = _0xadbf94;\n         _0x7d9829[_0xf5dfd4]._0x3540c3 = _0xf4f5ee + Channels[_0x924f7c]._0x945741;\n         _0x7d9829[_0xf5dfd4]._0xcf67ec = true;\n\n         emit DidVCInit(_0x924f7c, _0xf5dfd4, _0x343af0, uint256(0), _0xe19d76, _0x2d51aa, _0x73434c[0], _0x73434c[1]);\n     }\n\n     //TODO: verify state transition since the hub did not agree to this state\n     // make sure the A/B balances are not beyond ingrids bonds\n     // Params: vc init state, vc final balance, vcID\n     function _0x4e2131(\n         bytes32 _0x924f7c,\n         bytes32 _0xf5dfd4,\n         uint256 _0xbc6465,\n         address _0xe19d76,\n         address _0x2d51aa,\n         uint256[4] _0x2b7080, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n         string _0x4bb586\n     )\n         public\n     {\n         require(Channels[_0x924f7c]._0xf0bf5a, \"LC is closed.\");\n         // sub-channel must be open\n         require(!_0x7d9829[_0xf5dfd4]._0x2528d3, \"VC is closed.\");\n         require(_0x7d9829[_0xf5dfd4]._0x680133 < _0xbc6465, \"VC sequence is higher than update sequence.\");\n         require(\n             _0x7d9829[_0xf5dfd4]._0x998d71[1] < _0x2b7080[1] && _0x7d9829[_0xf5dfd4]._0x0574ed[1] < _0x2b7080[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             _0x7d9829[_0xf5dfd4]._0x9e730b[0] == _0x2b7080[0] + _0x2b7080[1] &&\n             _0x7d9829[_0xf5dfd4]._0x9e730b[1] == _0x2b7080[2] + _0x2b7080[3],\n             \"Incorrect balances for bonded amount\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n         // fail if initVC() isn't called first\n         // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n         require(Channels[_0x924f7c]._0x2f6dca < _0xf4f5ee); // for testing!\n\n         bytes32 _0x65b8a3 = _0xc5001e(\n             abi._0x0cfd25(\n                 _0xf5dfd4,\n                 _0xbc6465,\n                 _0xe19d76,\n                 _0x2d51aa,\n                 _0x7d9829[_0xf5dfd4]._0x9e730b[0],\n                 _0x7d9829[_0xf5dfd4]._0x9e730b[1],\n                 _0x2b7080[0],\n                 _0x2b7080[1],\n                 _0x2b7080[2],\n                 _0x2b7080[3]\n             )\n         );\n\n         // Make sure Alice has signed a higher sequence new state\n         require(_0x7d9829[_0xf5dfd4]._0x59f723 == ECTools._0x4dbfdd(_0x65b8a3, _0x4bb586));\n\n         // store VC data\n         // we may want to record who is initiating on-chain settles\n         _0x7d9829[_0xf5dfd4]._0xed7d05 = msg.sender;\n         _0x7d9829[_0xf5dfd4]._0x680133 = _0xbc6465;\n\n         // channel state\n         _0x7d9829[_0xf5dfd4]._0x998d71[0] = _0x2b7080[0];\n         _0x7d9829[_0xf5dfd4]._0x998d71[1] = _0x2b7080[1];\n         _0x7d9829[_0xf5dfd4]._0x0574ed[0] = _0x2b7080[2];\n         _0x7d9829[_0xf5dfd4]._0x0574ed[1] = _0x2b7080[3];\n\n         _0x7d9829[_0xf5dfd4]._0x3540c3 = _0xf4f5ee + Channels[_0x924f7c]._0x945741;\n\n         emit DidVCSettle(_0x924f7c, _0xf5dfd4, _0xbc6465, _0x2b7080[0], _0x2b7080[1], msg.sender, _0x7d9829[_0xf5dfd4]._0x3540c3);\n     }\n\n     function _0x422331(bytes32 _0x924f7c, bytes32 _0xf5dfd4) public {\n         // require(updateLCtimeout > now)\n         require(Channels[_0x924f7c]._0xf0bf5a, \"LC is closed.\");\n         require(_0x7d9829[_0xf5dfd4]._0xcf67ec, \"VC is not in settlement state.\");\n         require(_0x7d9829[_0xf5dfd4]._0x3540c3 < _0xf4f5ee, \"Update vc timeout has not elapsed.\");\n         require(!_0x7d9829[_0xf5dfd4]._0x2528d3, \"VC is already closed\");\n         // reduce the number of open virtual channels stored on LC\n         Channels[_0x924f7c]._0x932b35--;\n         // close vc flags\n         _0x7d9829[_0xf5dfd4]._0x2528d3 = true;\n         // re-introduce the balances back into the LC state from the settled VC\n         // decide if this lc is alice or bob in the vc\n         if(_0x7d9829[_0xf5dfd4]._0x59f723 == Channels[_0x924f7c]._0xafb3e1[0]) {\n             Channels[_0x924f7c]._0x998d71[0] += _0x7d9829[_0xf5dfd4]._0x998d71[0];\n             Channels[_0x924f7c]._0x998d71[1] += _0x7d9829[_0xf5dfd4]._0x998d71[1];\n\n             Channels[_0x924f7c]._0x0574ed[0] += _0x7d9829[_0xf5dfd4]._0x0574ed[0];\n             Channels[_0x924f7c]._0x0574ed[1] += _0x7d9829[_0xf5dfd4]._0x0574ed[1];\n         } else if (_0x7d9829[_0xf5dfd4]._0xde9802 == Channels[_0x924f7c]._0xafb3e1[0]) {\n             Channels[_0x924f7c]._0x998d71[0] += _0x7d9829[_0xf5dfd4]._0x998d71[1];\n             Channels[_0x924f7c]._0x998d71[1] += _0x7d9829[_0xf5dfd4]._0x998d71[0];\n\n             Channels[_0x924f7c]._0x0574ed[0] += _0x7d9829[_0xf5dfd4]._0x0574ed[1];\n             Channels[_0x924f7c]._0x0574ed[1] += _0x7d9829[_0xf5dfd4]._0x0574ed[0];\n         }\n\n         emit DidVCClose(_0x924f7c, _0xf5dfd4, _0x7d9829[_0xf5dfd4]._0x0574ed[0], _0x7d9829[_0xf5dfd4]._0x0574ed[1]);\n     }\n\n     // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n     function _0xb3dae4(bytes32 _0x924f7c) public {\n         Channel storage _0xe29b67 = Channels[_0x924f7c];\n\n         // check settlement flag\n         require(_0xe29b67._0xf0bf5a, \"Channel is not open\");\n         require(_0xe29b67._0x8cd154 == true);\n         require(_0xe29b67._0x932b35 == 0);\n         require(_0xe29b67._0x2f6dca < _0xf4f5ee, \"LC timeout over.\");\n\n         // if off chain state update didnt reblance deposits, just return to deposit owner\n         uint256 _0x00eef7 = _0xe29b67._0xd6aa13[0] + _0xe29b67._0x998d71[2] + _0xe29b67._0x998d71[3];\n         uint256 _0xb60418 = _0xe29b67._0xd6aa13[1] + _0xe29b67._0x0574ed[2] + _0xe29b67._0x0574ed[3];\n\n         uint256 _0xfd13bd = _0xe29b67._0x998d71[0] + _0xe29b67._0x998d71[1];\n         uint256 _0x28628f = _0xe29b67._0x0574ed[0] + _0xe29b67._0x0574ed[1];\n\n         if(_0xfd13bd < _0x00eef7) {\n             _0xe29b67._0x998d71[0]+=_0xe29b67._0x998d71[2];\n             _0xe29b67._0x998d71[1]+=_0xe29b67._0x998d71[3];\n         } else {\n             require(_0xfd13bd == _0x00eef7);\n         }\n\n         if(_0x28628f < _0xb60418) {\n             _0xe29b67._0x0574ed[0]+=_0xe29b67._0x0574ed[2];\n             _0xe29b67._0x0574ed[1]+=_0xe29b67._0x0574ed[3];\n         } else {\n             require(_0x28628f == _0xb60418);\n         }\n\n         uint256 _0xfd0742 = _0xe29b67._0x998d71[0];\n         uint256 _0x67242a = _0xe29b67._0x998d71[1];\n         uint256 _0x7c910a = _0xe29b67._0x0574ed[0];\n         uint256 _0xed00e6 = _0xe29b67._0x0574ed[1];\n\n         _0xe29b67._0x998d71[0] = 0;\n         _0xe29b67._0x998d71[1] = 0;\n         _0xe29b67._0x0574ed[0] = 0;\n         _0xe29b67._0x0574ed[1] = 0;\n\n         if(_0xfd0742 != 0 || _0x67242a != 0) {\n             _0xe29b67._0xafb3e1[0].transfer(_0xfd0742);\n             _0xe29b67._0xafb3e1[1].transfer(_0x67242a);\n         }\n\n         if(_0x7c910a != 0 || _0xed00e6 != 0) {\n             require(\n                 _0xe29b67._0x63f12a.transfer(_0xe29b67._0xafb3e1[0], _0x7c910a),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 _0xe29b67._0x63f12a.transfer(_0xe29b67._0xafb3e1[1], _0xed00e6),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         _0xe29b67._0xf0bf5a = false;\n         _0x035e6d--;\n\n         emit DidLCClose(_0x924f7c, _0xe29b67._0x680133, _0xfd0742, _0x67242a, _0x7c910a, _0xed00e6);\n     }\n\n     function _0x787b5f(bytes32 _0x259065, bytes _0x343af0, bytes32 _0x7b964a) internal pure returns (bool) {\n         bytes32 _0xc5fe79 = _0x259065;\n         bytes32 _0xb907d8;\n\n         for (uint256 i = 64; i <= _0x343af0.length; i += 32) {\n             assembly { _0xb907d8 := mload(add(_0x343af0, i)) }\n\n             if (_0xc5fe79 < _0xb907d8) {\n                 _0xc5fe79 = _0xc5001e(abi._0x0cfd25(_0xc5fe79, _0xb907d8));\n             } else {\n                 _0xc5fe79 = _0xc5001e(abi._0x0cfd25(_0xb907d8, _0xc5fe79));\n             }\n         }\n\n         return _0xc5fe79 == _0x7b964a;\n     }\n\n     //Struct Getters\n     function _0x3eb2fe(bytes32 _0x0ae7a2) public view returns (\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     ) {\n         Channel memory _0xe29b67 = Channels[_0x0ae7a2];\n         return (\n             _0xe29b67._0xafb3e1,\n             _0xe29b67._0x998d71,\n             _0xe29b67._0x0574ed,\n             _0xe29b67._0xd6aa13,\n             _0xe29b67._0x680133,\n             _0xe29b67._0x945741,\n             _0xe29b67.VCrootHash,\n             _0xe29b67.LCopenTimeout,\n             _0xe29b67._0x2f6dca,\n             _0xe29b67._0xf0bf5a,\n             _0xe29b67._0x8cd154,\n             _0xe29b67._0x932b35\n         );\n     }\n\n     function _0xd48511(bytes32 _0x0ae7a2) public view returns(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     ) {\n         VirtualChannel memory _0xaad269 = _0x7d9829[_0x0ae7a2];\n         return(\n             _0xaad269._0x2528d3,\n             _0xaad269._0xcf67ec,\n             _0xaad269._0x680133,\n             _0xaad269._0xed7d05,\n             _0xaad269._0x3540c3,\n             _0xaad269._0x59f723,\n             _0xaad269._0xde9802,\n             _0xaad269._0x6b8494,\n             _0xaad269._0x998d71,\n             _0xaad269._0x0574ed,\n             _0xaad269._0x9e730b\n         );\n     }\n }\n",
      "rename_map": {
        "possibleTotalTokenBeforeDeposit": "_0x28628f",
        "possibleTotalEthBeforeDeposit": "_0xfd13bd",
        "toEthereumSignedMessage": "_0x677728",
        "consensusCloseChannel": "_0x71a999",
        "byzantineCloseChannel": "_0xb3dae4",
        "closeVirtualChannel": "_0x422331",
        "isInSettlementState": "_0xcf67ec",
        "isUpdateLCSettling": "_0x8cd154",
        "getVirtualChannel": "_0xd48511",
        "totalTokenDeposit": "_0xb60418",
        "totalEthDeposit": "_0x00eef7",
        "updateVCtimeout": "_0x3540c3",
        "updateLCtimeout": "_0x2f6dca",
        "virtualChannels": "_0x7d9829",
        "partyAddresses": "_0xafb3e1",
        "initialDeposit": "_0xd6aa13",
        "approveAndCall": "_0x44af44",
        "virtualChannel": "_0xaad269",
        "_initialAmount": "_0x96fb4e",
        "parseInt16Char": "_0x163355",
        "tokenbalanceA": "_0x7c910a",
        "hexstrToBytes": "_0x6278df",
        "tokenBalanceA": "_0xbd8162",
        "_decimalUnits": "_0x6164e9",
        "erc20Balances": "_0x0574ed",
        "uintToBytes32": "_0x74a4bd",
        "recoverSigner": "_0x4dbfdd",
        "updateLCstate": "_0x616b08",
        "tokenBalanceI": "_0x144816",
        "createChannel": "_0xc5f2d7",
        "tokenbalanceI": "_0xed00e6",
        "uintToString": "_0x8c91ea",
        "prefixedHash": "_0x5db7df",
        "encodePacked": "_0x0cfd25",
        "_confirmTime": "_0xc6442a",
        "_isContained": "_0x787b5f",
        "transferFrom": "_0x60c1dd",
        "_updateState": "_0x65b8a3",
        "updateParams": "_0x7aedef",
        "_tokenSymbol": "_0xa74544",
        "ethBalanceI": "_0x53e1ad",
        "joinChannel": "_0x819994",
        "ethBalances": "_0x998d71",
        "numChannels": "_0x035e6d",
        "ethbalanceI": "_0x67242a",
        "totalSupply": "_0x93d391",
        "initVCstate": "_0x4ed52b",
        "confirmTime": "_0x945741",
        "_startIndex": "_0xb18cbb",
        "ethbalanceA": "_0xfd0742",
        "ethBalanceA": "_0x87afd2",
        "_extraData": "_0x691763",
        "getChannel": "_0x3eb2fe",
        "challenger": "_0xed7d05",
        "isSignedBy": "_0x3b5ba6",
        "_initState": "_0x0fbe9a",
        "_hashedMsg": "_0xe0d8a9",
        "_tokenName": "_0x136fa5",
        "updateBalB": "_0xcde10c",
        "updateBalA": "_0x581ae0",
        "balanceOf": "_0x3e189a",
        "substring": "_0x746b0a",
        "keccak256": "_0xc5001e",
        "_balances": "_0x73434c",
        "_endIndex": "_0xeb35d4",
        "channelId": "_0x128653",
        "proofElem": "_0xb907d8",
        "numOpenVC": "_0x932b35",
        "remainder": "_0xf3dcd7",
        "updateSeq": "_0xbc6465",
        "ecrecover": "_0xd9aba3",
        "numOpenVc": "_0x628c6c",
        "recipient": "_0x5508f2",
        "updateBal": "_0x2b7080",
        "_sequence": "_0xb19841",
        "remaining": "_0xff7394",
        "allowance": "_0x287086",
        "balanceB": "_0xa1351e",
        "decimals": "_0xc21131",
        "_spender": "_0x9be29c",
        "sequence": "_0x680133",
        "settleVC": "_0x4e2131",
        "balanceA": "_0x57d51f",
        "_balance": "_0x495cc6",
        "balances": "_0x202f58",
        "strBytes": "_0xfc2401",
        "_partyI": "_0xbad5df",
        "approve": "_0xf7f3ce",
        "version": "_0x6785fb",
        "_VCroot": "_0x569216",
        "isClose": "_0x2528d3",
        "allowed": "_0x743aa4",
        "deposit": "_0x38efbe",
        "_partyB": "_0x2d51aa",
        "isToken": "_0x88264e",
        "success": "_0x66a052",
        "channel": "_0xe29b67",
        "bresult": "_0x2dd805",
        "_partyA": "_0xe19d76",
        "_hexstr": "_0x64c767",
        "cursor": "_0xc5fe79",
        "_value": "_0x39d0a7",
        "vcRoot": "_0xa3e6d9",
        "_token": "_0x45bfe2",
        "_state": "_0x79be5e",
        "partyA": "_0x59f723",
        "_proof": "_0x343af0",
        "result": "_0x286893",
        "partyI": "_0x6b8494",
        "prefix": "_0x6a04c0",
        "symbol": "_0x4f03c6",
        "isOpen": "_0xf0bf5a",
        "partyB": "_0xde9802",
        "_owner": "_0x583c81",
        "proof": "_0x25a41f",
        "_sigA": "_0x341b1f",
        "_uint": "_0x82f715",
        "_lcID": "_0x924f7c",
        "token": "_0x63f12a",
        "_addr": "_0x9b9907",
        "_vcID": "_0xf5dfd4",
        "_bond": "_0xadbf94",
        "_sigI": "_0xc8225f",
        "_root": "_0x7b964a",
        "_char": "_0x2aac04",
        "_hash": "_0x259065",
        "_from": "_0x640951",
        "vcId": "_0xcf73d7",
        "_str": "_0x77f04e",
        "name": "_0x4ef58c",
        "_msg": "_0xb0683a",
        "lcId": "_0x4a3d69",
        "sigA": "_0x4bb586",
        "bond": "_0x9e730b",
        "bstr": "_0xa6d0d5",
        "_sig": "_0xe30511",
        "str": "_0x1ad767",
        "now": "_0xf4f5ee",
        "len": "_0xde24a5",
        "_to": "_0x7b9b08",
        "id": "_0x0ae7a2"
      },
      "changes": [
        "Renamed 141 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_212",
      "transformed_id": "ss_l3_medium_sn_ds_212",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier _0x31214b()\n    {\n        require(msg.sender == _0xbf6eb1);\n        _;\n    }\n\n   modifier _0x01d2bb()\n    {\n        require(_0x44870e);\n        _;\n    }\n\n    modifier _0xfeefbd()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  _0x08fbd4()\n    {\n        require (_0x855f39[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 _0x815fcf, address _0xb279fd);\n    event Win(uint256 _0x815fcf, address _0x4bc3a1);\n    event Lose(uint256 _0x815fcf, address _0x9936bd);\n    event Donate(uint256 _0x815fcf, address _0x4bc3a1, address _0xa0cf97);\n    event DifficultyChanged(uint256 _0x8fae29);\n    event BetLimitChanged(uint256 _0x28f626);\n\n    address private _0xaca6e8;\n    uint256 _0x32632f;\n    uint difficulty;\n    uint private _0x493b4f;\n    address _0xbf6eb1;\n    mapping(address => uint256) _0x8cb2e1;\n    mapping(address => uint256) _0x855f39;\n    bool _0x44870e;\n    uint256 _0x985f3c;\n\n    constructor(address _0x0c5b2c, uint256 _0x136609)\n    _0xfeefbd()\n    public\n    {\n        _0x44870e = false;\n        _0xbf6eb1 = msg.sender;\n        _0xaca6e8 = _0x0c5b2c;\n        _0x985f3c = 0;\n        _0x32632f = _0x136609;\n\n    }\n\n    function OpenToThePublic()\n    _0x31214b()\n    public\n    {\n        _0x44870e = true;\n    }\n\n    function AdjustBetAmounts(uint256 _0x815fcf)\n    _0x31214b()\n    public\n    {\n        _0x32632f = _0x815fcf;\n\n        emit BetLimitChanged(_0x32632f);\n    }\n\n    function AdjustDifficulty(uint256 _0x815fcf)\n    _0x31214b()\n    public\n    {\n        difficulty = _0x815fcf;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function _0x8f6a2e()\n    _0x01d2bb()\n    _0xfeefbd()\n    payable\n    public\n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == _0x32632f);\n\n        //You cannot wager multiple times\n        require(_0x855f39[msg.sender] == 0);\n\n        //log the wager and timestamp(block number)\n        _0x8cb2e1[msg.sender] = block.number;\n        _0x855f39[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function _0x66a54f()\n    _0x01d2bb()\n    _0xfeefbd()\n    _0x08fbd4()\n    public\n    {\n        uint256 _0x7c821d = _0x8cb2e1[msg.sender];\n        if(_0x7c821d < block.number)\n        {\n            _0x8cb2e1[msg.sender] = 0;\n            _0x855f39[msg.sender] = 0;\n\n            uint256 _0x84939d = uint256(_0xb7f01b(abi._0x88cde5(blockhash(_0x7c821d),  msg.sender)))%difficulty +1;\n\n            if(_0x84939d == difficulty / 2)\n            {\n                _0x8a3d05(msg.sender);\n            }\n            else\n            {\n                //player loses\n                _0x0553a7(_0x32632f / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function _0x85feae()\n    _0x01d2bb()\n    public\n    payable\n    {\n        _0xa34236(msg.value);\n    }\n\n    function _0x8a3d05(address _0xa58dd7)\n    internal\n    {\n        uint256 _0x8d9a65 = address(this).balance / 2;\n\n        _0xa58dd7.transfer(_0x8d9a65);\n        emit Win(_0x8d9a65, _0xa58dd7);\n    }\n\n    function _0xa34236(uint256 _0x815fcf)\n    internal\n    {\n        _0xaca6e8.call.value(_0x815fcf)(bytes4(_0xb7f01b(\"donate()\")));\n        _0x985f3c += _0x815fcf;\n        emit Donate(_0x815fcf, _0xaca6e8, msg.sender);\n    }\n\n    function _0x0553a7(uint256 _0x815fcf)\n    internal\n    {\n        _0xaca6e8.call.value(_0x815fcf)(bytes4(_0xb7f01b(\"donate()\")));\n        _0x985f3c += _0x815fcf;\n        emit Lose(_0x815fcf, msg.sender);\n    }\n\n    function _0x0fcbe5()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function _0x8fae29()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function _0x28f626()\n    public\n    view\n    returns (uint256)\n    {\n        return _0x32632f;\n    }\n\n    function _0x55aed6(address _0xc7ce01)\n    public\n    view\n    returns (bool)\n    {\n        if(_0x855f39[_0xc7ce01] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function _0xd04796()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function _0x01d365(address _0x7e3617, address _0xd99e22, uint _0x6a0dc7)\n    public\n    _0x31214b()\n    returns (bool _0xe2f5ec)\n    {\n        return ERC20Interface(_0x7e3617).transfer(_0xd99e22, _0x6a0dc7);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface\n{\n    function transfer(address _0xd53bee, uint256 _0x6a0dc7) public returns (bool _0xe2f5ec);\n}",
      "rename_map": {
        "transferAnyERC20Token": "_0x01d365",
        "currentDifficulty": "_0x8fae29",
        "hasPlayerWagered": "_0x55aed6",
        "currentBetLimit": "_0x28f626",
        "isOpenToPublic": "_0x01d2bb",
        "onlyRealPeople": "_0xfeefbd",
        "donateToWhale": "_0xa34236",
        "winningNumber": "_0x84939d",
        "ethToTransfer": "_0x8d9a65",
        "whaleAddress": "_0x0c5b2c",
        "tokenAddress": "_0x7e3617",
        "totalDonated": "_0x985f3c",
        "encodePacked": "_0x88cde5",
        "openToPublic": "_0x44870e",
        "onlyPlayers": "_0x08fbd4",
        "blockNumber": "_0x7c821d",
        "randomSeed": "_0x493b4f",
        "winnersPot": "_0xd04796",
        "tokenOwner": "_0xd99e22",
        "ethBalance": "_0x0fcbe5",
        "wagerLimit": "_0x136609",
        "timestamps": "_0x8cb2e1",
        "onlyOwner": "_0x31214b",
        "depositer": "_0xb279fd",
        "keccak256": "_0xb7f01b",
        "loseWager": "_0x0553a7",
        "betLimit": "_0x32632f",
        "donator": "_0xa0cf97",
        "success": "_0xe2f5ec",
        "tokens": "_0x6a0dc7",
        "paidTo": "_0x4bc3a1",
        "player": "_0xc7ce01",
        "amount": "_0x815fcf",
        "donate": "_0x85feae",
        "payout": "_0x8a3d05",
        "wagers": "_0x855f39",
        "winner": "_0xa58dd7",
        "whale": "_0xaca6e8",
        "loser": "_0x9936bd",
        "owner": "_0xbf6eb1",
        "wager": "_0x8f6a2e",
        "play": "_0x66a54f",
        "to": "_0xd53bee"
      },
      "changes": [
        "Renamed 43 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_213",
      "transformed_id": "ss_l3_medium_sn_ds_213",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.11;\ninterface _0xf82d7e { function _0x426c47(address _0xff4c81, uint256 _0x3f981f, address _0x1ee7e0, bytes _0xd16422) public; }\n\n// title Migration Agent interface\ncontract MigrationAgent {\n    function _0x63635c(address _0xff4c81, uint256 _0x3f981f);\n}\n\ncontract ERC20 {\n  uint public _0xd4cd9d;\n  function _0xc6f59a(address _0x9028e1) constant returns (uint);\n  function _0x894085(address _0xcc5d42, address _0x8bc102) constant returns (uint);\n\n  function transfer(address _0x09e2f3, uint value) returns (bool _0xf4f33e);\n  function _0xaf4ca1(address from, address _0x09e2f3, uint value) returns (bool _0xf4f33e);\n  function _0x7d1437(address _0x8bc102, uint value) returns (bool _0xf4f33e);\n  event Transfer(address indexed from, address indexed _0x09e2f3, uint value);\n  event Approval(address indexed _0xcc5d42, address indexed _0x8bc102, uint value);\n}\n\ncontract SafeMath {\n  function _0x07bf6f(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function _0x402171(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function _0x8eaa58(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function _0x358a04(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function _0xb4363e(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function _0xe7b0f1(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function _0x42c801(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function _0xb4166a(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function assert(bool _0x9844ff) internal {\n    if (!_0x9844ff) {\n      throw;\n    }\n  }\n}\n\ncontract StandardToken is ERC20, SafeMath {\n\n  /* Token supply got increased and a new owner received these tokens */\n  event Minted(address _0x638f49, uint _0x2f807d);\n\n  /* Actual balances of token holders */\n  mapping(address => uint) _0x41eb5f;\n  // what exaclt ether was sent\n  mapping(address => uint) _0x5533f8;\n  /* approve() allowances */\n  mapping (address => mapping (address => uint)) _0xba0156;\n\n  /* Interface declaration */\n  function _0x950b6d() public constant returns (bool _0x4376a8) {\n    return true;\n  }\n\n  function transfer(address _0x299830, uint _0x3f981f) returns (bool _0x2445d4) {\n    _0x41eb5f[msg.sender] = _0x8eaa58(_0x41eb5f[msg.sender], _0x3f981f);\n    _0x41eb5f[_0x299830] = _0x358a04(_0x41eb5f[_0x299830], _0x3f981f);\n    Transfer(msg.sender, _0x299830, _0x3f981f);\n    return true;\n  }\n\n  function _0xaf4ca1(address _0xff4c81, address _0x299830, uint _0x3f981f) returns (bool _0x2445d4) {\n    uint _0x90b172 = _0xba0156[_0xff4c81][msg.sender];\n\n    _0x41eb5f[_0x299830] = _0x358a04(_0x41eb5f[_0x299830], _0x3f981f);\n    _0x41eb5f[_0xff4c81] = _0x8eaa58(_0x41eb5f[_0xff4c81], _0x3f981f);\n    _0xba0156[_0xff4c81][msg.sender] = _0x8eaa58(_0x90b172, _0x3f981f);\n    Transfer(_0xff4c81, _0x299830, _0x3f981f);\n    return true;\n  }\n\n  function _0xc6f59a(address _0xc9b403) constant returns (uint balance) {\n    return _0x41eb5f[_0xc9b403];\n  }\n\n  function _0x7d1437(address _0x52b1df, uint _0x3f981f) returns (bool _0x2445d4) {\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    if ((_0x3f981f != 0) && (_0xba0156[msg.sender][_0x52b1df] != 0)) throw;\n\n    _0xba0156[msg.sender][_0x52b1df] = _0x3f981f;\n    Approval(msg.sender, _0x52b1df, _0x3f981f);\n    return true;\n  }\n\n  function _0x894085(address _0xc9b403, address _0x52b1df) constant returns (uint _0x6c6954) {\n    return _0xba0156[_0xc9b403][_0x52b1df];\n  }\n\n}\n\n//  daoPOLSKAtokens\ncontract _0x4a0d6c{\n\n    string public _0xa5ddf5 = \"DAO POLSKA TOKEN version 1\";\n    string public _0xae8926 = \"DPL\";\n    uint8 public constant _0x097946 = 18;  // 18 decimal places, the same as ETC/ETH/HEE.\n\n    // Receives\n    address public _0xcc5d42;\n    address public _0x790669;\n    // The current total token supply.\n\n    uint256 public _0xc5cfc2 =1.0 ether;\n    uint256 public _0x299365      = 10000.0 ether;\n\t//totalSupply\n   uint256 public  _0xd4cd9d      = 0.0 ether;\n\t//chains:\n\taddress public Chain1 = 0x0;\n\taddress public Chain2 = 0x0;\n\taddress public Chain3 = 0x0;\n\taddress public Chain4 = 0x0;\n\n\taddress public _0x5190ac=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\n    uint256 public _0xbdd84e;\n\n    event Migrate(address indexed _0xff4c81, address indexed _0x299830, uint256 _0x3f981f);\n    event Refund(address indexed _0xff4c81, uint256 _0x3f981f);\n\n\tstruct _0xc94732{\n\t\tStandardToken _0x81abbf;\n\t\tuint _0x2f807d;\n\t\taddress _0xa957c2;\n\t}\n\tmapping(uint => _0xc94732) _0x1b0127;\n\tuint _0x6e78b1=0;\n\n  mapping (address => uint256) _0x41eb5f;\nmapping (address => uint256) _0x5533f8;\n  mapping (address => mapping (address => uint256)) _0xba0156;\n\n\tevent UpdatedTokenInformation(string _0xebc6c3, string _0x5ef6e6);\n\n    event Transfer(address indexed _0xff4c81, address indexed _0x299830, uint256 _0x3f981f);\n\tevent _0x90e69d(address indexed _0xff4c81,uint256 _0x3f981f);\n  event Approval(address indexed _0xc9b403, address indexed _0x52b1df, uint256 _0x3f981f);\n\n      // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n  //tokenCreationCap\n  bool public _0xaa09c9 = false;\n  bool public _0x68e401 = false;\n\n  function _0x4a0d6c() {\n_0xcc5d42=msg.sender;\n_0x790669=msg.sender;\n}\n\nfunction  _0x52e8dd(uint256 _0xdf5a4c) public {\n    \t   if (msg.sender != _0xcc5d42) {\n      throw;\n    }\n\t\t    \t   if (_0xaa09c9 != false) {\n      throw;\n    }\n\t_0xaa09c9 = true;\n\n if (true) { _0x299365 = _0xdf5a4c ** uint256(_0x097946); }\n//balances[owner]=supplylimit;\n  }\nfunction _0x1c1336(uint256 _0xdf5a4c) public {\n    \t   if (msg.sender != _0xcc5d42) {\n      throw;\n    }\n\t    \t   if (_0xaa09c9 != false) {\n      throw;\n    }\n\n\t_0x68e401 = true;\n\t_0xc5cfc2 = _0xdf5a4c ** uint256(_0x097946);\n\n  }\n    function _0xe4d501(address _0x52b1df, uint256 _0x3f981f, bytes _0xd16422)\n        public\n        returns (bool _0x2445d4) {\n        _0xf82d7e _0x8bc102 = _0xf82d7e(_0x52b1df);\n        if (_0x7d1437(_0x52b1df, _0x3f981f)) {\n            _0x8bc102._0x426c47(msg.sender, _0x3f981f, this, _0xd16422);\n            return true;\n        }\n    }\n\n    function _0xaa29be(uint256 _0x3f981f) public returns (bool _0x2445d4) {\n        require(_0x41eb5f[msg.sender] >= _0x3f981f);   // Check if the sender has enough\n        _0x41eb5f[msg.sender] -= _0x3f981f;            // Subtract from the sender\n        _0xd4cd9d -= _0x3f981f;                      // Updates totalSupply\n        Burn(msg.sender, _0x3f981f);\n        return true;\n    }\n\n    function _0xf483c4(address _0xff4c81, uint256 _0x3f981f) public returns (bool _0x2445d4) {\n        require(_0x41eb5f[_0xff4c81] >= _0x3f981f);                // Check if the targeted balance is enough\n        require(_0x3f981f <= _0xba0156[_0xff4c81][msg.sender]);    // Check allowance\n        _0x41eb5f[_0xff4c81] -= _0x3f981f;                         // Subtract from the targeted balance\n        _0xba0156[_0xff4c81][msg.sender] -= _0x3f981f;             // Subtract from the sender's allowance\n        _0xd4cd9d -= _0x3f981f;                              // Update totalSupply\n        Burn(_0xff4c81, _0x3f981f);\n        return true;\n    }\n\n  function transfer(address _0x299830, uint256 _0x3f981f) returns (bool _0x2445d4) {\n    //Default assumes totalSupply can't be over max (2^256 - 1).\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n    //Replace the if with this one instead.\n    if (_0x41eb5f[msg.sender] >= _0x3f981f && _0x41eb5f[_0x299830] + _0x3f981f > _0x41eb5f[_0x299830]) {\n    //if (balances[msg.sender] >= _value && _value > 0) {\n      _0x41eb5f[msg.sender] -= _0x3f981f;\n      _0x41eb5f[_0x299830] += _0x3f981f;\n      Transfer(msg.sender, _0x299830, _0x3f981f);\n      return true;\n    } else { return false; }\n  }\n\n  function _0xaf4ca1(address _0xff4c81, address _0x299830, uint256 _0x3f981f) returns (bool _0x2445d4) {\n\n    if (_0x41eb5f[_0xff4c81] >= _0x3f981f && _0xba0156[_0xff4c81][msg.sender] >= _0x3f981f && _0x41eb5f[_0x299830] + _0x3f981f > _0x41eb5f[_0x299830]) {\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      _0x41eb5f[_0x299830] += _0x3f981f;\n      _0x41eb5f[_0xff4c81] -= _0x3f981f;\n      _0xba0156[_0xff4c81][msg.sender] -= _0x3f981f;\n      Transfer(_0xff4c81, _0x299830, _0x3f981f);\n      return true;\n    } else { return false; }\n  }\n\n  function _0xc6f59a(address _0xc9b403) constant returns (uint256 balance) {\n    return _0x41eb5f[_0xc9b403];\n  }\n\n  function _0x7d1437(address _0x52b1df, uint256 _0x3f981f) returns (bool _0x2445d4) {\n    _0xba0156[msg.sender][_0x52b1df] = _0x3f981f;\n    Approval(msg.sender, _0x52b1df, _0x3f981f);\n    return true;\n  }\n\n  function _0x894085(address _0xc9b403, address _0x52b1df) constant returns (uint256 _0x6c6954) {\n    return _0xba0156[_0xc9b403][_0x52b1df];\n  }\n\n\t    function () payable  public {\n\t\t if(_0xe965d1){\n        _0x90e69d(msg.sender, msg.value);\n\t\t_0x41eb5f[msg.sender]=_0x41eb5f[msg.sender]+msg.value;\n\t\t} else throw;\n\n    }\n\n  function _0xbb162a(string _0x048e24, string _0xd509aa) {\n\n\t   if (msg.sender != _0xcc5d42) {\n      throw;\n    }\n\t_0xa5ddf5 = _0x048e24;\n    _0xae8926 = _0xd509aa;\n\n    UpdatedTokenInformation(_0xa5ddf5, _0xae8926);\n  }\n\nfunction _0x68ee7e(address _0x38825b, int _0x9ba606) {\n\n\t   if (msg.sender != _0xcc5d42) {\n      throw;\n    }\n\tif(_0x9ba606==1){Chain1=_0x38825b;}\n\tif(_0x9ba606==2){Chain2=_0x38825b;}\n\tif(_0x9ba606==3){Chain3=_0x38825b;}\n\tif(_0x9ba606==4){Chain4=_0x38825b;}\n  }\n\n  function DAOPolskaTokenICOregulations() external returns(string _0x82a909) {\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\n}\n// if accidentally other token was donated to Project Dev\n\n\tfunction _0x2d7486(address StandardTokenAddress, address _0x638f49, uint _0x2f807d){\n\t\tif (msg.sender != _0xcc5d42) {\n\t\tthrow;\n\t\t}\n\t\t_0xc94732 t = _0x1b0127[_0x6e78b1];\n\t\tt._0x81abbf = StandardToken(StandardTokenAddress);\n\t\tt._0x2f807d = _0x2f807d;\n\t\tt._0xa957c2 = _0x638f49;\n\t\tt._0x81abbf.transfer(_0x638f49, _0x2f807d);\n\t\t_0x6e78b1++;\n\t}\n\n     // Crowdfunding:\nuint public _0x50e690=1000;\nuint public _0x40cbe1=1000;\nuint public CreationRate=1761;\n   uint256 public constant _0x6897d4 = 36000;\nuint256 public _0x82bea8 = 5433616;\nbool public _0xe965d1 = true;\nbool public _0xe4e0ca = false;\nbool public _0x24e31f= false;\n        function _0x11774b(address _0xf83bd5) payable {\n\n        if (!_0xe965d1) throw;\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) throw;\n\t\t// check the maximum token creation cap\n        if (msg.value > (_0x299365 - _0xd4cd9d) / CreationRate)\n          throw;\n\n\t\t//bonus structure\n// in early stage there is about 100% more details in ico regulations on website\n// price and converstion rate in tabled to PLN not ether, and is updated daily\n\n\t var _0x157dd4 = msg.value;\n\n        var _0x7231ba = msg.value * CreationRate;\n        _0xd4cd9d += _0x7231ba;\n\n        // Assign new tokens to the sender\n        _0x41eb5f[_0xf83bd5] += _0x7231ba;\n        _0x5533f8[_0xf83bd5] += _0x157dd4;\n        // Log token creation event\n        Transfer(0, _0xf83bd5, _0x7231ba);\n\n\t\t// Create additional Dao Tokens for the community and developers around 12%\n        uint256 _0xbd7716 = 12;\n        uint256 _0x311bf3 = \t_0x7231ba * _0xbd7716 / (100);\n\n        _0xd4cd9d += _0x311bf3;\n\n        _0x41eb5f[_0x790669] += _0x311bf3;\n        Transfer(0, _0x790669, _0x311bf3);\n\n\t}\n\tfunction _0x3b6fb6(uint _0x6fd459){\n\tif(msg.sender == _0xcc5d42) {\n\t_0x40cbe1=_0x6fd459;\n\tCreationRate=_0x50e690+_0x40cbe1;\n\t}\n\t}\n\n    function FundsTransfer() external {\n\tif(_0xe965d1==true) throw;\n\t\t \tif (!_0xcc5d42.send(this.balance)) throw;\n    }\n\n    function PartialFundsTransfer(uint SubX) external {\n\t      if (msg.sender != _0xcc5d42) throw;\n        _0xcc5d42.send(this.balance - SubX);\n\t}\n\tfunction _0x7a241a() external {\n\t      if (msg.sender != _0xcc5d42) throw;\n\t_0xe4e0ca=!_0xe4e0ca;\n        }\n\n\t\t\tfunction _0x4b2118() external {\n\t      if (msg.sender != _0xcc5d42) throw;\n\t_0xe965d1=!_0xe965d1;\n        }\n    function _0x2c9d9e() external {\n\t      if (msg.sender != _0x790669) throw;\n\t_0x24e31f=!_0x24e31f;\n}\n\n    // notice Finalize crowdfunding clossing funding options\n\nfunction _0x75185d() external {\n        if (block.number <= _0x82bea8+8*_0x6897d4) throw;\n        // Switch to Operational state. This is the only place this can happen.\n        _0xe965d1 = false;\n  if (1 == 1) { _0xe4e0ca=!_0xe4e0ca; }\n        // Transfer ETH to theDAO Polska Token network Storage address.\n        if (msg.sender==_0xcc5d42)\n\t\t_0xcc5d42.send(this.balance);\n    }\n    function _0x3ba056(uint256 _0x3f981f) external {\n        // Abort if not in Operational Migration state.\n        if (_0x24e31f) throw;\n\n        // Validate input value.\n        if (_0x3f981f == 0) throw;\n        if (_0x3f981f > _0x41eb5f[msg.sender]) throw;\n\n        _0x41eb5f[msg.sender] -= _0x3f981f;\n        _0xd4cd9d -= _0x3f981f;\n        _0xbdd84e += _0x3f981f;\n        MigrationAgent(_0x5190ac)._0x63635c(msg.sender, _0x3f981f);\n        Migrate(msg.sender, _0x5190ac, _0x3f981f);\n    }\n\nfunction _0xb03a36() external {\n        // Abort if not in Funding Failure state.\n        if (_0xe965d1) throw;\n        if (!_0xe4e0ca) throw;\n\n        var DAOPLTokenValue = _0x41eb5f[msg.sender];\n        var ETHValue = _0x5533f8[msg.sender];\n        if (ETHValue == 0) throw;\n        _0x5533f8[msg.sender] = 0;\n        _0xd4cd9d -= DAOPLTokenValue;\n\n        Refund(msg.sender, ETHValue);\n        msg.sender.transfer(ETHValue);\n}\n\nfunction _0xfb0cf4() external returns(string _0x82a909) {\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\n}\n\n}\n\n//------------------------------------------------------\n",
      "rename_map": {
        "setotherchainstotalsupply": "_0x1c1336",
        "otherchainstotalsupply": "_0xc5cfc2",
        "createDaoPOLSKAtokens": "_0x11774b",
        "setBonusCreationRate": "_0x3b6fb6",
        "setTokenInformation": "_0xbb162a",
        "otherchainstotalset": "_0x68e401",
        "setChainsAddresses": "_0x68ee7e",
        "tokenCreationRate": "_0x50e690",
        "preICOregulations": "_0xfb0cf4",
        "bonusCreationRate": "_0x40cbe1",
        "additionalTokens": "_0x311bf3",
        "receiveApproval": "_0x426c47",
        "migrationMaster": "_0x790669",
        "fundingEndBlock": "_0x82bea8",
        "daoPOLSKAtokens": "_0x4a0d6c",
        "migrationAgent": "_0x5190ac",
        "tokenRecipient": "_0xf82d7e",
        "supplylimitset": "_0xaa09c9",
        "approveAndCall": "_0xe4d501",
        "percentOfTotal": "_0xbd7716",
        "totalMigrated": "_0xbdd84e",
        "sendTokenAway": "_0xc94732",
        "receivedEther": "_0x90e69d",
        "numTransfers": "_0x6e78b1",
        "migratestate": "_0x24e31f",
        "coinContract": "_0x81abbf",
        "supplyLOCKER": "_0xdf5a4c",
        "transferFrom": "_0xaf4ca1",
        "numTokensRAW": "_0x157dd4",
        "fundingState": "_0x4b2118",
        "migrateFrom": "_0x63635c",
        "turnmigrate": "_0x2c9d9e",
        "sendTokenAw": "_0x2d7486",
        "balancesRAW": "_0x5533f8",
        "totalSupply": "_0xd4cd9d",
        "chainnumber": "_0x9ba606",
        "supplylimit": "_0x299365",
        "refundstate": "_0xe4e0ca",
        "_extraData": "_0xd16422",
        "turnrefund": "_0x7a241a",
        "_allowance": "_0x90b172",
        "balanceOf": "_0xc6f59a",
        "refundTRA": "_0xb03a36",
        "numTokens": "_0x7231ba",
        "recipient": "_0xa957c2",
        "newSymbol": "_0x5ef6e6",
        "remaining": "_0x6c6954",
        "setSupply": "_0x52e8dd",
        "allowance": "_0x894085",
        "assertion": "_0x9844ff",
        "transfers": "_0x1b0127",
        "receiver": "_0x638f49",
        "decimals": "_0x097946",
        "_spender": "_0x52b1df",
        "burnFrom": "_0xf483c4",
        "finalize": "_0x75185d",
        "balances": "_0x41eb5f",
        "approve": "_0x7d1437",
        "safeMul": "_0x07bf6f",
        "allowed": "_0xba0156",
        "migrate": "_0x3ba056",
        "_symbol": "_0xd509aa",
        "isToken": "_0x950b6d",
        "success": "_0x2445d4",
        "newRate": "_0x6fd459",
        "funding": "_0xe965d1",
        "chainAd": "_0x38825b",
        "spender": "_0x8bc102",
        "safeDiv": "_0x402171",
        "oneweek": "_0x6897d4",
        "safeAdd": "_0x358a04",
        "safeSub": "_0x8eaa58",
        "newName": "_0xebc6c3",
        "max256": "_0x42c801",
        "_value": "_0x3f981f",
        "min256": "_0xb4166a",
        "_token": "_0x1ee7e0",
        "holder": "_0xf83bd5",
        "symbol": "_0xae8926",
        "amount": "_0x2f807d",
        "_owner": "_0xc9b403",
        "_name": "_0x048e24",
        "max64": "_0xb4363e",
        "min64": "_0xe7b0f1",
        "owner": "_0xcc5d42",
        "weAre": "_0x4376a8",
        "_from": "_0xff4c81",
        "name": "_0xa5ddf5",
        "burn": "_0xaa29be",
        "who": "_0x9028e1",
        "wow": "_0x82a909",
        "_to": "_0x299830",
        "ok": "_0xf4f33e",
        "to": "_0x09e2f3"
      },
      "changes": [
        "Renamed 94 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_214",
      "transformed_id": "ss_l3_medium_sn_ds_214",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract ERC20 {\n    function _0xee647c() constant returns (uint _0xe91321);\n    function _0xb62dae( address _0xcc5e75 ) constant returns (uint value);\n    function _0x7588da( address _0xcb5efa, address _0x9c80df ) constant returns (uint _0x08b60a);\n\n    function transfer( address _0x70f7f1, uint value) returns (bool _0x31c25b);\n    function _0x23aab6( address from, address _0x70f7f1, uint value) returns (bool _0x31c25b);\n    function _0x2c3379( address _0x9c80df, uint value ) returns (bool _0x31c25b);\n\n    event Transfer( address indexed from, address indexed _0x70f7f1, uint value);\n    event Approval( address indexed _0xcb5efa, address indexed _0x9c80df, uint value);\n}\ncontract Ownable {\n  address public _0xcb5efa;\n\n  function Ownable() {\n    _0xcb5efa = msg.sender;\n  }\n\n  modifier _0x017abd() {\n    require(msg.sender == _0xcb5efa);\n    _;\n  }\n\n  function _0x87c5d8(address _0x98e0ca) _0x017abd {\n    if (_0x98e0ca != address(0)) {\n      if (gasleft() > 0) { _0xcb5efa = _0x98e0ca; }\n    }\n  }\n\n}\n\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\ncontract ERC721 {\n    // Required methods\n    function _0xee647c() public view returns (uint256 _0xe60324);\n    function _0xb62dae(address _0xb0e749) public view returns (uint256 balance);\n    function _0xc2f09b(uint256 _0x9437a0) external view returns (address _0xcb5efa);\n    function _0x2c3379(address _0x64cd68, uint256 _0x9437a0) external;\n    function transfer(address _0x64cd68, uint256 _0x9437a0) external;\n    function _0x23aab6(address _0x31fe9e, address _0x64cd68, uint256 _0x9437a0) external;\n\n    // Events\n    event Transfer(address from, address _0x70f7f1, uint256 _0x718a9a);\n    event Approval(address _0xcb5efa, address _0xb3c5b9, uint256 _0x718a9a);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function _0xd896c3(bytes4 _0x4e06d8) external view returns (bool);\n}\n\ncontract GeneScienceInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function _0x3a0461() public pure returns (bool);\n\n    /// @dev given genes of kitten 1 & 2, return a genetic combination - may have a random factor\n    /// @param genes1 genes of mom\n    /// @param genes2 genes of sire\n    /// @return the genes that are supposed to be passed down the child\n    function _0xbb871a(uint256[2] _0xbb3ff5, uint256[2] _0xc0b7ec,uint256 _0xb756a9,uint256 _0xac54c9, uint256 _0x06d311) public returns (uint256[2]);\n\n    function _0x5f4722(uint256[2] _0xaad9e0) public view returns(uint256);\n\n    /// @dev get sex from genes 0: female 1: male\n    function _0x31654d(uint256[2] _0xaad9e0) public view returns(uint256);\n\n    /// @dev get wizz type from gene\n    function _0x30fc22(uint256[2] _0xaad9e0) public view returns(uint256);\n\n    function _0x3a08fc(uint256[2] _0xede1e3) public returns(uint256[2]);\n}\n\n/// @title A facet of PandaCore that manages special access privileges.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaAccessControl {\n    // This facet controls access control for CryptoPandas. There are four roles managed here:\n    //\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n    //         set to the address that created the smart contract in the PandaCore constructor.\n    //\n    //     - The CFO: The CFO can withdraw funds from PandaCore and its auction contracts.\n    //\n    //     - The COO: The COO can release gen0 pandas to auction, and mint promo cats.\n    //\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\n    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n    // account.\n\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n    event ContractUpgrade(address _0x07ce93);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public _0x056adb;\n    address public _0xdf7871;\n    address public _0xd84fc8;\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public _0x86dc0a = false;\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier _0x60b274() {\n        require(msg.sender == _0x056adb);\n        _;\n    }\n\n    /// @dev Access modifier for CFO-only functionality\n    modifier _0xd4d0ef() {\n        require(msg.sender == _0xdf7871);\n        _;\n    }\n\n    /// @dev Access modifier for COO-only functionality\n    modifier _0x864e74() {\n        require(msg.sender == _0xd84fc8);\n        _;\n    }\n\n    modifier _0xcfa2eb() {\n        require(\n            msg.sender == _0xd84fc8 ||\n            msg.sender == _0x056adb ||\n            msg.sender == _0xdf7871\n        );\n        _;\n    }\n\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n    /// @param _newCEO The address of the new CEO\n    function _0x153e41(address _0x389caa) external _0x60b274 {\n        require(_0x389caa != address(0));\n\n        _0x056adb = _0x389caa;\n    }\n\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n    /// @param _newCFO The address of the new CFO\n    function _0xce088c(address _0xbbfea1) external _0x60b274 {\n        require(_0xbbfea1 != address(0));\n\n        _0xdf7871 = _0xbbfea1;\n    }\n\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n    /// @param _newCOO The address of the new COO\n    function _0xc0041f(address _0xe82f6d) external _0x60b274 {\n        require(_0xe82f6d != address(0));\n\n        _0xd84fc8 = _0xe82f6d;\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\n    modifier _0x04df49() {\n        require(!_0x86dc0a);\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the contract IS paused\n    modifier _0x53d1a2 {\n        require(_0x86dc0a);\n        _;\n    }\n\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\n    function _0x23403d() external _0xcfa2eb _0x04df49 {\n        _0x86dc0a = true;\n    }\n\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n    ///  one reason we may pause the contract is when CFO or COO accounts are\n    ///  compromised.\n    /// @notice This is public rather than external so it can be called by\n    ///  derived contracts.\n    function _0xd59e82() public _0x60b274 _0x53d1a2 {\n        // can't unpause if contract was upgraded\n        _0x86dc0a = false;\n    }\n}\n\n/// @title Base contract for CryptoPandas. Holds all common structs, events and base variables.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaBase is PandaAccessControl {\n    /*** EVENTS ***/\n\n    uint256 public constant GEN0_TOTAL_COUNT = 16200;\n    uint256 public _0xc25220;\n\n    /// @dev The Birth event is fired whenever a new kitten comes into existence. This obviously\n    ///  includes any time a cat is created through the giveBirth method, but it is also called\n    ///  when a new gen0 cat is created.\n    event Birth(address _0xcb5efa, uint256 _0xe91074, uint256 _0xcaa582, uint256 _0x9a6a79, uint256[2] _0xd7149e);\n\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a kitten\n    ///  ownership is assigned, including births.\n    event Transfer(address from, address _0x70f7f1, uint256 _0x718a9a);\n\n    /*** DATA TYPES ***/\n\n    /// @dev The main Panda struct. Every cat in CryptoPandas is represented by a copy\n    ///  of this structure, so great care was taken to ensure that it fits neatly into\n    ///  exactly two 256-bit words. Note that the order of the members in this structure\n    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n    struct Panda {\n        // The Panda's genetic code is packed into these 256-bits, the format is\n        // sooper-sekret! A cat's genes never change.\n        uint256[2] _0xd7149e;\n\n        // The timestamp from the block when this cat came into existence.\n        uint64 _0x14d428;\n\n        // The minimum timestamp after which this cat can engage in breeding\n        // activities again. This same timestamp is used for the pregnancy\n        // timer (for matrons) as well as the siring cooldown.\n        uint64 _0x5c4b14;\n\n        // The ID of the parents of this panda, set to 0 for gen0 cats.\n        // Note that using 32-bit unsigned integers limits us to a \"mere\"\n        // 4 billion cats. This number might seem small until you realize\n        // that Ethereum currently has a limit of about 500 million\n        // transactions per year! So, this definitely won't be a problem\n        // for several years (even as Ethereum learns to scale).\n        uint32 _0xcaa582;\n        uint32 _0x9a6a79;\n\n        // Set to the ID of the sire cat for matrons that are pregnant,\n        // zero otherwise. A non-zero value here is how we know a cat\n        // is pregnant. Used to retrieve the genetic material for the new\n        // kitten when the birth transpires.\n        uint32 _0xdb4890;\n\n        // Set to the index in the cooldown array (see below) that represents\n        // the current cooldown duration for this Panda. This starts at zero\n        // for gen0 cats, and is initialized to floor(generation/2) for others.\n        // Incremented by one for each successful breeding action, regardless\n        // of whether this cat is acting as matron or sire.\n        uint16 _0xd993db;\n\n        // The \"generation number\" of this cat. Cats minted by the CK contract\n        // for sale are called \"gen0\" and have a generation number of 0. The\n        // generation number of all other cats is the larger of the two generation\n        // numbers of their parents, plus one.\n        // (i.e. max(matron.generation, sire.generation) + 1)\n        uint16 _0xcb4be8;\n    }\n\n    /*** CONSTANTS ***/\n\n    /// @dev A lookup table indicating the cooldown duration after any successful\n    ///  breeding action, called \"pregnancy time\" for matrons and \"siring cooldown\"\n    ///  for sires. Designed such that the cooldown roughly doubles each time a cat\n    ///  is bred, encouraging owners not to just keep breeding the same cat over\n    ///  and over again. Caps out at one week (a cat can breed an unbounded number\n    ///  of times, and the maximum cooldown is always seven days).\n    uint32[9] public _0xcd20be = [\n        uint32(5 minutes),\n        uint32(30 minutes),\n        uint32(2 hours),\n        uint32(4 hours),\n        uint32(8 hours),\n        uint32(24 hours),\n        uint32(48 hours),\n        uint32(72 hours),\n        uint32(7 days)\n    ];\n\n    // An approximation of currently how many seconds are in between blocks.\n    uint256 public _0xb9bb78 = 15;\n\n    /*** STORAGE ***/\n\n    /// @dev An array containing the Panda struct for all Pandas in existence. The ID\n    ///  of each cat is actually an index into this array. Note that ID 0 is a negacat,\n    ///  the unPanda, the mythical beast that is the parent of all gen0 cats. A bizarre\n    ///  creature that is both matron and sire... to itself! Has an invalid genetic code.\n    ///  In other words, cat ID 0 is invalid... ;-)\n    Panda[] _0xde19c2;\n\n    /// @dev A mapping from cat IDs to the address that owns them. All cats have\n    ///  some valid owner address, even gen0 cats are created with a non-zero owner.\n    mapping (uint256 => address) public _0xa35b09;\n\n    // @dev A mapping from owner address to count of tokens that address owns.\n    //  Used internally inside balanceOf() to resolve ownership count.\n    mapping (address => uint256) _0x07b50b;\n\n    /// @dev A mapping from PandaIDs to an address that has been approved to call\n    ///  transferFrom(). Each Panda can only have one approved address for transfer\n    ///  at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public _0x43de16;\n\n    /// @dev A mapping from PandaIDs to an address that has been approved to use\n    ///  this Panda for siring via breedWith(). Each Panda can only have one approved\n    ///  address for siring at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public _0xacfa1a;\n\n    /// @dev The address of the ClockAuction contract that handles sales of Pandas. This\n    ///  same contract handles both peer-to-peer sales as well as the gen0 sales which are\n    ///  initiated every 15 minutes.\n    SaleClockAuction public _0x9e851a;\n\n    /// @dev The address of a custom ClockAuction subclassed contract that handles siring\n    ///  auctions. Needs to be separate from saleAuction because the actions taken on success\n    ///  after a sales and siring auction are quite different.\n    SiringClockAuction public _0x23c70b;\n\n    /// @dev The address of the sibling contract that is used to implement the sooper-sekret\n    ///  genetic combination algorithm.\n    GeneScienceInterface public _0xc88e88;\n\n    SaleClockAuctionERC20 public _0x3e1e93;\n\n    // wizz panda total\n    mapping (uint256 => uint256) public _0xfd10e4;\n    mapping (uint256 => uint256) public _0x055cb8;\n\n    /// wizz panda control\n    function _0x541479(uint256 _0xccdfde) view external returns(uint256) {\n        return _0xfd10e4[_0xccdfde];\n    }\n\n    function _0x029fc0(uint256 _0xccdfde) view external returns(uint256) {\n        return _0x055cb8[_0xccdfde];\n    }\n\n    function _0x0bc7d2(uint256 _0xccdfde,uint256 _0xc735fc) external _0xcfa2eb {\n        require (_0xfd10e4[_0xccdfde]==0);\n        require (_0xc735fc==uint256(uint32(_0xc735fc)));\n        _0xfd10e4[_0xccdfde] = _0xc735fc;\n    }\n\n    function _0x733b54(uint256 _0xfa9287) view external returns(uint256) {\n        Panda memory _0x2291bb = _0xde19c2[_0xfa9287];\n        return _0xc88e88._0x30fc22(_0x2291bb._0xd7149e);\n    }\n\n    /// @dev Assigns ownership of a specific Panda to an address.\n    function _0x5e6963(address _0x31fe9e, address _0x64cd68, uint256 _0x9437a0) internal {\n\n        _0x07b50b[_0x64cd68]++;\n        // transfer ownership\n        _0xa35b09[_0x9437a0] = _0x64cd68;\n        // When creating new kittens _from is 0x0, but we can't account that address.\n        if (_0x31fe9e != address(0)) {\n            _0x07b50b[_0x31fe9e]--;\n            // once the kitten is transferred also clear sire allowances\n            delete _0xacfa1a[_0x9437a0];\n            // clear any previously approved ownership exchange\n            delete _0x43de16[_0x9437a0];\n        }\n        // Emit the transfer event.\n        Transfer(_0x31fe9e, _0x64cd68, _0x9437a0);\n    }\n\n    /// @dev An internal method that creates a new panda and stores it. This\n    ///  method doesn't do any checking and should only be called when the\n    ///  input data is known to be valid. Will generate both a Birth event\n    ///  and a Transfer event.\n    /// @param _matronId The panda ID of the matron of this cat (zero for gen0)\n    /// @param _sireId The panda ID of the sire of this cat (zero for gen0)\n    /// @param _generation The generation number of this cat, must be computed by caller.\n    /// @param _genes The panda's genetic code.\n    /// @param _owner The inital owner of this cat, must be non-zero (except for the unPanda, ID 0)\n    function _0x5f3cbe(\n        uint256 _0x27eecf,\n        uint256 _0x9027a1,\n        uint256 _0xce7d73,\n        uint256[2] _0xd14de0,\n        address _0xb0e749\n    )\n        internal\n        returns (uint)\n    {\n        // These requires are not strictly necessary, our calling code should make\n        // sure that these conditions are never broken. However! _createPanda() is already\n        // an expensive call (for storage), and it doesn't hurt to be especially careful\n        // to ensure our data structures are always valid.\n        require(_0x27eecf == uint256(uint32(_0x27eecf)));\n        require(_0x9027a1 == uint256(uint32(_0x9027a1)));\n        require(_0xce7d73 == uint256(uint16(_0xce7d73)));\n\n        // New panda starts with the same cooldown as parent gen/2\n        uint16 _0xd993db = 0;\n        // when contract creation, geneScience ref is null\n        if (_0xde19c2.length>0){\n            uint16 _0x649194 = uint16(_0xc88e88._0x5f4722(_0xd14de0));\n            if (_0x649194==0) {\n                _0x649194 = 1;\n            }\n            _0xd993db = 1000/_0x649194;\n            if (_0xd993db%10 < 5){\n                _0xd993db = _0xd993db/10;\n            }else{\n                _0xd993db = _0xd993db/10 + 1;\n            }\n            _0xd993db = _0xd993db - 1;\n            if (_0xd993db > 8) {\n                _0xd993db = 8;\n            }\n            uint256 _0xccdfde = _0xc88e88._0x30fc22(_0xd14de0);\n            if (_0xccdfde>0 && _0xfd10e4[_0xccdfde]<=_0x055cb8[_0xccdfde]) {\n                _0xd14de0 = _0xc88e88._0x3a08fc(_0xd14de0);\n                _0xccdfde = 0;\n            }\n            // gensis panda cooldownIndex should be 24 hours\n            if (_0xccdfde == 1){\n                _0xd993db = 5;\n            }\n\n            // increase wizz counter\n            if (_0xccdfde>0){\n                _0x055cb8[_0xccdfde] = _0x055cb8[_0xccdfde] + 1;\n            }\n            // all gen0&gen1 except gensis\n            if (_0xce7d73 <= 1 && _0xccdfde != 1){\n                require(_0xc25220<GEN0_TOTAL_COUNT);\n                _0xc25220++;\n            }\n        }\n\n        Panda memory _0x8eee79 = Panda({\n            _0xd7149e: _0xd14de0,\n            _0x14d428: uint64(_0xddf414),\n            _0x5c4b14: 0,\n            _0xcaa582: uint32(_0x27eecf),\n            _0x9a6a79: uint32(_0x9027a1),\n            _0xdb4890: 0,\n            _0xd993db: _0xd993db,\n            _0xcb4be8: uint16(_0xce7d73)\n        });\n        uint256 _0xb3c304 = _0xde19c2.push(_0x8eee79) - 1;\n\n        // It's probably never going to happen, 4 billion cats is A LOT, but\n        // let's just be 100% sure we never let this happen.\n        require(_0xb3c304 == uint256(uint32(_0xb3c304)));\n\n        // emit the birth event\n        Birth(\n            _0xb0e749,\n            _0xb3c304,\n            uint256(_0x8eee79._0xcaa582),\n            uint256(_0x8eee79._0x9a6a79),\n            _0x8eee79._0xd7149e\n        );\n\n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _0x5e6963(0, _0xb0e749, _0xb3c304);\n\n        return _0xb3c304;\n    }\n\n    // Any C-level can fix how many seconds per blocks are currently observed.\n    function _0x4255e5(uint256 _0x2b4358) external _0xcfa2eb {\n        require(_0x2b4358 < _0xcd20be[0]);\n        _0xb9bb78 = _0x2b4358;\n    }\n}\n/// @title The external contract that is responsible for generating metadata for the pandas,\n///  it has one function that will return the data as bytes.\ncontract ERC721Metadata {\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\n    function _0x6bffb3(uint256 _0x9437a0, string) public view returns (bytes32[4] _0x229848, uint256 _0xe68344) {\n        if (_0x9437a0 == 1) {\n            _0x229848[0] = \"Hello World! :D\";\n            _0xe68344 = 15;\n        } else if (_0x9437a0 == 2) {\n            _0x229848[0] = \"I would definitely choose a medi\";\n            _0x229848[1] = \"um length string.\";\n            if (true) { _0xe68344 = 49; }\n        } else if (_0x9437a0 == 3) {\n            _0x229848[0] = \"Lorem ipsum dolor sit amet, mi e\";\n            _0x229848[1] = \"st accumsan dapibus augue lorem,\";\n            _0x229848[2] = \" tristique vestibulum id, libero\";\n            _0x229848[3] = \" suscipit varius sapien aliquam.\";\n            _0xe68344 = 128;\n        }\n    }\n}\n\n/// @title The facet of the CryptoPandas core contract that manages ownership, ERC-721 (draft) compliant.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev Ref: https://github.com/ethereum/EIPs/issues/721\n///  See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaOwnership is PandaBase, ERC721 {\n\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n    string public constant _0xa050c9 = \"PandaEarth\";\n    string public constant _0x5f646f = \"PE\";\n\n    bytes4 constant InterfaceSignature_ERC165 =\n        bytes4(_0x2a9820('_0xd896c3(bytes4)'));\n\n    bytes4 constant InterfaceSignature_ERC721 =\n        bytes4(_0x2a9820('_0xa050c9()')) ^\n        bytes4(_0x2a9820('_0x5f646f()')) ^\n        bytes4(_0x2a9820('_0xee647c()')) ^\n        bytes4(_0x2a9820('_0xb62dae(address)')) ^\n        bytes4(_0x2a9820('_0xc2f09b(uint256)')) ^\n        bytes4(_0x2a9820('_0x2c3379(address,uint256)')) ^\n        bytes4(_0x2a9820('transfer(address,uint256)')) ^\n        bytes4(_0x2a9820('_0x23aab6(address,address,uint256)')) ^\n        bytes4(_0x2a9820('_0x9dbf4c(address)')) ^\n        bytes4(_0x2a9820('tokenMetadata(uint256,string)'));\n\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n    ///  ERC-165 (obviously!) and ERC-721.\n    function _0xd896c3(bytes4 _0x4e06d8) external view returns (bool)\n    {\n        // DEBUG ONLY\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n\n        return ((_0x4e06d8 == InterfaceSignature_ERC165) || (_0x4e06d8 == InterfaceSignature_ERC721));\n    }\n\n    // Internal utility functions: These functions all assume that their input arguments\n    // are valid. We leave it to public methods to sanitize their inputs and follow\n    // the required logic.\n\n    /// @dev Checks if a given address is the current owner of a particular Panda.\n    /// @param _claimant the address we are validating against.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _0x65e38c(address _0xf07313, uint256 _0x9437a0) internal view returns (bool) {\n        return _0xa35b09[_0x9437a0] == _0xf07313;\n    }\n\n    /// @dev Checks if a given address currently has transferApproval for a particular Panda.\n    /// @param _claimant the address we are confirming kitten is approved for.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _0x9f7ada(address _0xf07313, uint256 _0x9437a0) internal view returns (bool) {\n        return _0x43de16[_0x9437a0] == _0xf07313;\n    }\n\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n    ///  _approve() and transferFrom() are used together for putting Pandas on auction, and\n    ///  there is no value in spamming the log with Approval events in that case.\n    function _0xd82f3d(uint256 _0x9437a0, address _0xeb3284) internal {\n        _0x43de16[_0x9437a0] = _0xeb3284;\n    }\n\n    /// @notice Returns the number of Pandas owned by a specific address.\n    /// @param _owner The owner address to check.\n    /// @dev Required for ERC-721 compliance\n    function _0xb62dae(address _0xb0e749) public view returns (uint256 _0xe68344) {\n        return _0x07b50b[_0xb0e749];\n    }\n\n    /// @notice Transfers a Panda to another address. If transferring to a smart\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n    ///  CryptoPandas specifically) or your Panda may be lost forever. Seriously.\n    /// @param _to The address of the recipient, can be a user or contract.\n    /// @param _tokenId The ID of the Panda to transfer.\n    /// @dev Required for ERC-721 compliance.\n    function transfer(\n        address _0x64cd68,\n        uint256 _0x9437a0\n    )\n        external\n        _0x04df49\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_0x64cd68 != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any pandas (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        require(_0x64cd68 != address(this));\n        // Disallow transfers to the auction contracts to prevent accidental\n        // misuse. Auction contracts should only take ownership of pandas\n        // through the allow + transferFrom flow.\n        require(_0x64cd68 != address(_0x9e851a));\n        require(_0x64cd68 != address(_0x23c70b));\n\n        // You can only send your own cat.\n        require(_0x65e38c(msg.sender, _0x9437a0));\n\n        // Reassign ownership, clear pending approvals, emit Transfer event.\n        _0x5e6963(msg.sender, _0x64cd68, _0x9437a0);\n    }\n\n    /// @notice Grant another address the right to transfer a specific Panda via\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\n    ///  clear all approvals.\n    /// @param _tokenId The ID of the Panda that can be transferred if this call succeeds.\n    /// @dev Required for ERC-721 compliance.\n    function _0x2c3379(\n        address _0x64cd68,\n        uint256 _0x9437a0\n    )\n        external\n        _0x04df49\n    {\n        // Only an owner can grant transfer approval.\n        require(_0x65e38c(msg.sender, _0x9437a0));\n\n        // Register the approval (replacing any previous approval).\n        _0xd82f3d(_0x9437a0, _0x64cd68);\n\n        // Emit approval event.\n        Approval(msg.sender, _0x64cd68, _0x9437a0);\n    }\n\n    /// @notice Transfer a Panda owned by another address, for which the calling address\n    ///  has previously been granted transfer approval by the owner.\n    /// @param _from The address that owns the Panda to be transfered.\n    /// @param _to The address that should take ownership of the Panda. Can be any address,\n    ///  including the caller.\n    /// @param _tokenId The ID of the Panda to be transferred.\n    /// @dev Required for ERC-721 compliance.\n    function _0x23aab6(\n        address _0x31fe9e,\n        address _0x64cd68,\n        uint256 _0x9437a0\n    )\n        external\n        _0x04df49\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_0x64cd68 != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any pandas (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        require(_0x64cd68 != address(this));\n        // Check for approval and valid ownership\n        require(_0x9f7ada(msg.sender, _0x9437a0));\n        require(_0x65e38c(_0x31fe9e, _0x9437a0));\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _0x5e6963(_0x31fe9e, _0x64cd68, _0x9437a0);\n    }\n\n    /// @notice Returns the total number of Pandas currently in existence.\n    /// @dev Required for ERC-721 compliance.\n    function _0xee647c() public view returns (uint) {\n        return _0xde19c2.length - 1;\n    }\n\n    /// @notice Returns the address currently assigned ownership of a given Panda.\n    /// @dev Required for ERC-721 compliance.\n    function _0xc2f09b(uint256 _0x9437a0)\n        external\n        view\n        returns (address _0xcb5efa)\n    {\n        _0xcb5efa = _0xa35b09[_0x9437a0];\n\n        require(_0xcb5efa != address(0));\n    }\n\n    /// @notice Returns a list of all Panda IDs assigned to an address.\n    /// @param _owner The owner whose Pandas we are interested in.\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Panda array looking for cats belonging to owner),\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function _0x9dbf4c(address _0xb0e749) external view returns(uint256[] _0x70042c) {\n        uint256 _0x0f2760 = _0xb62dae(_0xb0e749);\n\n        if (_0x0f2760 == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory _0xcd5d92 = new uint256[](_0x0f2760);\n            uint256 _0x3f99b8 = _0xee647c();\n            uint256 _0x5f46cb = 0;\n\n            // We count on the fact that all cats have IDs starting at 1 and increasing\n            // sequentially up to the totalCat count.\n            uint256 _0x0d4969;\n\n            for (_0x0d4969 = 1; _0x0d4969 <= _0x3f99b8; _0x0d4969++) {\n                if (_0xa35b09[_0x0d4969] == _0xb0e749) {\n                    _0xcd5d92[_0x5f46cb] = _0x0d4969;\n                    _0x5f46cb++;\n                }\n            }\n\n            return _0xcd5d92;\n        }\n    }\n\n    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\n    ///  This method is licenced under the Apache License.\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n    function _0xa8c8fa(uint _0xad86ce, uint _0x505b2f, uint _0x7ee558) private view {\n        // Copy word-length chunks while possible\n        for(; _0x7ee558 >= 32; _0x7ee558 -= 32) {\n            assembly {\n                mstore(_0xad86ce, mload(_0x505b2f))\n            }\n            _0xad86ce += 32;\n            _0x505b2f += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 _0x44052c = 256 ** (32 - _0x7ee558) - 1;\n        assembly {\n            let _0x4117ec := and(mload(_0x505b2f), not(_0x44052c))\n            let _0x4642a4 := and(mload(_0xad86ce), _0x44052c)\n            mstore(_0xad86ce, or(_0x4642a4, _0x4117ec))\n        }\n    }\n\n    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\n    ///  This method is licenced under the Apache License.\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n    function _0x9cc9c6(bytes32[4] _0x7c4986, uint256 _0x9bf6ac) private view returns (string) {\n        var _0x00572d = new string(_0x9bf6ac);\n        uint256 _0x5c4738;\n        uint256 _0x81ff11;\n\n        assembly {\n            _0x5c4738 := add(_0x00572d, 32)\n            _0x81ff11 := _0x7c4986\n        }\n\n        _0xa8c8fa(_0x5c4738, _0x81ff11, _0x9bf6ac);\n\n        return _0x00572d;\n    }\n\n}\n\n/// @title A facet of PandaCore that manages Panda siring, gestation, and birth.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaBreeding is PandaOwnership {\n\n    uint256 public constant GENSIS_TOTAL_COUNT = 100;\n\n    /// @dev The Pregnant event is fired when two cats successfully breed and the pregnancy\n    ///  timer begins for the matron.\n    event Pregnant(address _0xcb5efa, uint256 _0xcaa582, uint256 _0x9a6a79, uint256 _0x5c4b14);\n    /// @dev The Abortion event is fired when two cats breed failed.\n    event Abortion(address _0xcb5efa, uint256 _0xcaa582, uint256 _0x9a6a79);\n\n    /// @notice The minimum payment required to use breedWithAuto(). This fee goes towards\n    ///  the gas cost paid by whatever calls giveBirth(), and can be dynamically updated by\n    ///  the COO role as the gas price changes.\n    uint256 public _0x3ecc6f = 2 finney;\n\n    // Keeps track of number of pregnant pandas.\n    uint256 public _0x6d06de;\n\n    mapping(uint256 => address) _0xf51b9e;\n\n    /// @dev Update the address of the genetic contract, can only be called by the CEO.\n    /// @param _address An address of a GeneScience contract instance to be used from this point forward.\n    function _0xd3bc24(address _0xf2098b) external _0x60b274 {\n        GeneScienceInterface _0xbfacca = GeneScienceInterface(_0xf2098b);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0xbfacca._0x3a0461());\n\n        // Set the new contract address\n        _0xc88e88 = _0xbfacca;\n    }\n\n    /// @dev Checks that a given kitten is able to breed. Requires that the\n    ///  current cooldown is finished (for sires) and also checks that there is\n    ///  no pending pregnancy.\n    function _0xd21a03(Panda _0x27a589) internal view returns(bool) {\n        // In addition to checking the cooldownEndBlock, we also need to check to see if\n        // the cat has a pending birth; there can be some period of time between the end\n        // of the pregnacy timer and the birth event.\n        return (_0x27a589._0xdb4890 == 0) && (_0x27a589._0x5c4b14 <= uint64(block.number));\n    }\n\n    /// @dev Check if a sire has authorized breeding with this matron. True if both sire\n    ///  and matron have the same owner, or if the sire has given siring permission to\n    ///  the matron's owner (via approveSiring()).\n    function _0x32f44b(uint256 _0x9027a1, uint256 _0x27eecf) internal view returns(bool) {\n        address _0x4990d9 = _0xa35b09[_0x27eecf];\n        address _0x02a7c4 = _0xa35b09[_0x9027a1];\n\n        // Siring is okay if they have same owner, or if the matron's owner was given\n        // permission to breed with this sire.\n        return (_0x4990d9 == _0x02a7c4 || _0xacfa1a[_0x9027a1] == _0x4990d9);\n    }\n\n    /// @dev Set the cooldownEndTime for the given Panda, based on its current cooldownIndex.\n    ///  Also increments the cooldownIndex (unless it has hit the cap).\n    /// @param _kitten A reference to the Panda in storage which needs its timer started.\n    function _0x6d5bc3(Panda storage _0x3e14fd) internal {\n        // Compute an estimation of the cooldown time in blocks (based on current cooldownIndex).\n        _0x3e14fd._0x5c4b14 = uint64((_0xcd20be[_0x3e14fd._0xd993db] / _0xb9bb78) + block.number);\n\n        // Increment the breeding count, clamping it at 13, which is the length of the\n        // cooldowns array. We could check the array size dynamically, but hard-coding\n        // this as a constant saves gas. Yay, Solidity!\n        if (_0x3e14fd._0xd993db < 8 && _0xc88e88._0x30fc22(_0x3e14fd._0xd7149e) != 1) {\n            _0x3e14fd._0xd993db += 1;\n        }\n    }\n\n    /// @notice Grants approval to another user to sire with one of your Pandas.\n    /// @param _addr The address that will be able to sire with your Panda. Set to\n    ///  address(0) to clear all siring approvals for this Panda.\n    /// @param _sireId A Panda that you own that _addr will now be able to sire with.\n    function _0x46b546(address _0xe32f7d, uint256 _0x9027a1)\n    external\n    _0x04df49 {\n        require(_0x65e38c(msg.sender, _0x9027a1));\n        _0xacfa1a[_0x9027a1] = _0xe32f7d;\n    }\n\n    /// @dev Updates the minimum payment required for calling giveBirthAuto(). Can only\n    ///  be called by the COO address. (This fee is used to offset the gas cost incurred\n    ///  by the autobirth daemon).\n    function _0xca8753(uint256 _0x703b13) external _0x864e74 {\n        _0x3ecc6f = _0x703b13;\n    }\n\n    /// @dev Checks to see if a given Panda is pregnant and (if so) if the gestation\n    ///  period has passed.\n    function _0xddfc96(Panda _0x468abf) private view returns(bool) {\n        return (_0x468abf._0xdb4890 != 0) && (_0x468abf._0x5c4b14 <= uint64(block.number));\n    }\n\n    /// @notice Checks that a given kitten is able to breed (i.e. it is not pregnant or\n    ///  in the middle of a siring cooldown).\n    /// @param _pandaId reference the id of the kitten, any user can inquire about it\n    function _0x9ba8b0(uint256 _0x7e84fb)\n    public\n    view\n    returns(bool) {\n        require(_0x7e84fb > 0);\n        Panda storage _0x3cca96 = _0xde19c2[_0x7e84fb];\n        return _0xd21a03(_0x3cca96);\n    }\n\n    /// @dev Checks whether a panda is currently pregnant.\n    /// @param _pandaId reference the id of the kitten, any user can inquire about it\n    function _0x7ccc7a(uint256 _0x7e84fb)\n    public\n    view\n    returns(bool) {\n        require(_0x7e84fb > 0);\n        // A panda is pregnant if and only if this field is set\n        return _0xde19c2[_0x7e84fb]._0xdb4890 != 0;\n    }\n\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair. DOES NOT\n    ///  check ownership permissions (that is up to the caller).\n    /// @param _matron A reference to the Panda struct of the potential matron.\n    /// @param _matronId The matron's ID.\n    /// @param _sire A reference to the Panda struct of the potential sire.\n    /// @param _sireId The sire's ID\n    function _0x6d0cfb(\n        Panda storage _0x468abf,\n        uint256 _0x27eecf,\n        Panda storage _0x37bebf,\n        uint256 _0x9027a1\n    )\n    private\n    view\n    returns(bool) {\n        // A Panda can't breed with itself!\n        if (_0x27eecf == _0x9027a1) {\n            return false;\n        }\n\n        // Pandas can't breed with their parents.\n        if (_0x468abf._0xcaa582 == _0x9027a1 || _0x468abf._0x9a6a79 == _0x9027a1) {\n            return false;\n        }\n        if (_0x37bebf._0xcaa582 == _0x27eecf || _0x37bebf._0x9a6a79 == _0x27eecf) {\n            return false;\n        }\n\n        // We can short circuit the sibling check (below) if either cat is\n        // gen zero (has a matron ID of zero).\n        if (_0x37bebf._0xcaa582 == 0 || _0x468abf._0xcaa582 == 0) {\n            return true;\n        }\n\n        // Pandas can't breed with full or half siblings.\n        if (_0x37bebf._0xcaa582 == _0x468abf._0xcaa582 || _0x37bebf._0xcaa582 == _0x468abf._0x9a6a79) {\n            return false;\n        }\n        if (_0x37bebf._0x9a6a79 == _0x468abf._0xcaa582 || _0x37bebf._0x9a6a79 == _0x468abf._0x9a6a79) {\n            return false;\n        }\n\n        // male should get breed with female\n        if (_0xc88e88._0x31654d(_0x468abf._0xd7149e) + _0xc88e88._0x31654d(_0x37bebf._0xd7149e) != 1) {\n            return false;\n        }\n\n        // Everything seems cool! Let's get DTF.\n        return true;\n    }\n\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair for\n    ///  breeding via auction (i.e. skips ownership and siring approval checks).\n    function _0x90fc42(uint256 _0x27eecf, uint256 _0x9027a1)\n    internal\n    view\n    returns(bool) {\n        Panda storage _0x94f0ad = _0xde19c2[_0x27eecf];\n        Panda storage _0xc4769c = _0xde19c2[_0x9027a1];\n        return _0x6d0cfb(_0x94f0ad, _0x27eecf, _0xc4769c, _0x9027a1);\n    }\n\n    /// @notice Checks to see if two cats can breed together, including checks for\n    ///  ownership and siring approvals. Does NOT check that both cats are ready for\n    ///  breeding (i.e. breedWith could still fail until the cooldowns are finished).\n    ///  TODO: Shouldn't this check pregnancy and cooldowns?!?\n    /// @param _matronId The ID of the proposed matron.\n    /// @param _sireId The ID of the proposed sire.\n    function _0xb089cc(uint256 _0x27eecf, uint256 _0x9027a1)\n    external\n    view\n    returns(bool) {\n        require(_0x27eecf > 0);\n        require(_0x9027a1 > 0);\n        Panda storage _0x94f0ad = _0xde19c2[_0x27eecf];\n        Panda storage _0xc4769c = _0xde19c2[_0x9027a1];\n        return _0x6d0cfb(_0x94f0ad, _0x27eecf, _0xc4769c, _0x9027a1) &&\n            _0x32f44b(_0x9027a1, _0x27eecf);\n    }\n\n    function _0x7e5e58(uint256 _0x27eecf, uint256 _0x9027a1) internal returns(uint256, uint256) {\n        if (_0xc88e88._0x31654d(_0xde19c2[_0x27eecf]._0xd7149e) == 1) {\n            return (_0x9027a1, _0x27eecf);\n        } else {\n            return (_0x27eecf, _0x9027a1);\n        }\n    }\n\n    /// @dev Internal utility function to initiate breeding, assumes that all breeding\n    ///  requirements have been checked.\n    function _0x355b02(uint256 _0x27eecf, uint256 _0x9027a1, address _0xb0e749) internal {\n        // make id point real gender\n        (_0x27eecf, _0x9027a1) = _0x7e5e58(_0x27eecf, _0x9027a1);\n        // Grab a reference to the Pandas from storage.\n        Panda storage _0xc4769c = _0xde19c2[_0x9027a1];\n        Panda storage _0x94f0ad = _0xde19c2[_0x27eecf];\n\n        // Mark the matron as pregnant, keeping track of who the sire is.\n        _0x94f0ad._0xdb4890 = uint32(_0x9027a1);\n\n        // Trigger the cooldown for both parents.\n        _0x6d5bc3(_0xc4769c);\n        _0x6d5bc3(_0x94f0ad);\n\n        // Clear siring permission for both parents. This may not be strictly necessary\n        // but it's likely to avoid confusion!\n        delete _0xacfa1a[_0x27eecf];\n        delete _0xacfa1a[_0x9027a1];\n\n        // Every time a panda gets pregnant, counter is incremented.\n        _0x6d06de++;\n\n        _0xf51b9e[_0x27eecf] = _0xb0e749;\n\n        // Emit the pregnancy event.\n        Pregnant(_0xa35b09[_0x27eecf], _0x27eecf, _0x9027a1, _0x94f0ad._0x5c4b14);\n    }\n\n    /// @notice Breed a Panda you own (as matron) with a sire that you own, or for which you\n    ///  have previously been given Siring approval. Will either make your cat pregnant, or will\n    ///  fail entirely. Requires a pre-payment of the fee given out to the first caller of giveBirth()\n    /// @param _matronId The ID of the Panda acting as matron (will end up pregnant if successful)\n    /// @param _sireId The ID of the Panda acting as sire (will begin its siring cooldown if successful)\n    function _0xd71535(uint256 _0x27eecf, uint256 _0x9027a1)\n    external\n    payable\n    _0x04df49 {\n        // Checks for payment.\n        require(msg.value >= _0x3ecc6f);\n\n        // Caller must own the matron.\n        require(_0x65e38c(msg.sender, _0x27eecf));\n\n        // Neither sire nor matron are allowed to be on auction during a normal\n        // breeding operation, but we don't need to check that explicitly.\n        // For matron: The caller of this function can't be the owner of the matron\n        //   because the owner of a Panda on auction is the auction house, and the\n        //   auction house will never call breedWith().\n        // For sire: Similarly, a sire on auction will be owned by the auction house\n        //   and the act of transferring ownership will have cleared any oustanding\n        //   siring approval.\n        // Thus we don't need to spend gas explicitly checking to see if either cat\n        // is on auction.\n\n        // Check that matron and sire are both owned by caller, or that the sire\n        // has given siring permission to caller (i.e. matron's owner).\n        // Will fail for _sireId = 0\n        require(_0x32f44b(_0x9027a1, _0x27eecf));\n\n        // Grab a reference to the potential matron\n        Panda storage _0x94f0ad = _0xde19c2[_0x27eecf];\n\n        // Make sure matron isn't pregnant, or in the middle of a siring cooldown\n        require(_0xd21a03(_0x94f0ad));\n\n        // Grab a reference to the potential sire\n        Panda storage _0xc4769c = _0xde19c2[_0x9027a1];\n\n        // Make sure sire isn't pregnant, or in the middle of a siring cooldown\n        require(_0xd21a03(_0xc4769c));\n\n        // Test that these cats are a valid mating pair.\n        require(_0x6d0cfb(\n            _0x94f0ad,\n            _0x27eecf,\n            _0xc4769c,\n            _0x9027a1\n        ));\n\n        // All checks passed, panda gets pregnant!\n        _0x355b02(_0x27eecf, _0x9027a1, msg.sender);\n    }\n\n    /// @notice Have a pregnant Panda give birth!\n    /// @param _matronId A Panda ready to give birth.\n    /// @return The Panda ID of the new kitten.\n    /// @dev Looks at a given Panda and, if pregnant and if the gestation period has passed,\n    ///  combines the genes of the two parents to create a new kitten. The new Panda is assigned\n    ///  to the current owner of the matron. Upon successful completion, both the matron and the\n\n    ///  are willing to pay the gas!), but the new kitten always goes to the mother's owner.\n    function _0xa0fe83(uint256 _0x27eecf, uint256[2] _0xe7e447, uint256[2] _0xb495b6)\n    external\n    _0x04df49\n    _0xcfa2eb\n    returns(uint256) {\n        // Grab a reference to the matron in storage.\n        Panda storage _0x94f0ad = _0xde19c2[_0x27eecf];\n\n        // Check that the matron is a valid cat.\n        require(_0x94f0ad._0x14d428 != 0);\n\n        // Check that the matron is pregnant, and that its time has come!\n        require(_0xddfc96(_0x94f0ad));\n\n        // Grab a reference to the sire in storage.\n        uint256 _0x9a6a79 = _0x94f0ad._0xdb4890;\n        Panda storage _0xc4769c = _0xde19c2[_0x9a6a79];\n\n        // Determine the higher generation number of the two parents\n        uint16 _0x4e0a0d = _0x94f0ad._0xcb4be8;\n        if (_0xc4769c._0xcb4be8 > _0x94f0ad._0xcb4be8) {\n            _0x4e0a0d = _0xc4769c._0xcb4be8;\n        }\n\n        // Call the sooper-sekret gene mixing operation.\n        //uint256[2] memory childGenes = geneScience.mixGenes(matron.genes, sire.genes,matron.generation,sire.generation, matron.cooldownEndBlock - 1);\n        uint256[2] memory _0xbfab44 = _0xe7e447;\n\n        uint256 _0x7f537b = 0;\n\n        // birth failed\n        uint256 _0x193529 = (_0xc88e88._0x5f4722(_0x94f0ad._0xd7149e) + _0xc88e88._0x5f4722(_0xc4769c._0xd7149e)) / 2 + _0xb495b6[0];\n        if (_0x193529 >= (_0x4e0a0d + 1) * _0xb495b6[1]) {\n            _0x193529 = _0x193529 - (_0x4e0a0d + 1) * _0xb495b6[1];\n        } else {\n            _0x193529 = 0;\n        }\n        if (_0x4e0a0d == 0 && _0xc25220 == GEN0_TOTAL_COUNT) {\n            _0x193529 = 0;\n        }\n        if (uint256(_0x2a9820(block.blockhash(block.number - 2), _0xddf414)) % 100 < _0x193529) {\n            // Make the new kitten!\n            address _0xcb5efa = _0xf51b9e[_0x27eecf];\n            _0x7f537b = _0x5f3cbe(_0x27eecf, _0x94f0ad._0xdb4890, _0x4e0a0d + 1, _0xbfab44, _0xcb5efa);\n        } else {\n            Abortion(_0xa35b09[_0x27eecf], _0x27eecf, _0x9a6a79);\n        }\n        // Make the new kitten!\n        //address owner = pandaIndexToOwner[_matronId];\n        //address owner = childOwner[_matronId];\n        //uint256 kittenId = _createPanda(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n\n        // Clear the reference to sire from the matron (REQUIRED! Having siringWithId\n        // set is what marks a matron as being pregnant.)\n        delete _0x94f0ad._0xdb4890;\n\n        // Every time a panda gives birth counter is decremented.\n        _0x6d06de--;\n\n        // Send the balance fee to the person who made birth happen.\n        msg.sender.send(_0x3ecc6f);\n\n        delete _0xf51b9e[_0x27eecf];\n\n        // return the new kitten's ID\n        return _0x7f537b;\n    }\n}\n\n/// @title Auction Core\n/// @dev Contains models, variables, and internal methods for the auction.\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract ClockAuctionBase {\n\n    // Represents an auction on an NFT\n    struct Auction {\n        // Current owner of NFT\n        address _0x80bd9c;\n        // Price (in wei) at beginning of auction\n        uint128 _0xc9080f;\n        // Price (in wei) at end of auction\n        uint128 _0xc2d268;\n        // Duration (in seconds) of auction\n        uint64 _0xcfcedd;\n        // Time when auction started\n        // NOTE: 0 if this auction has been concluded\n        uint64 _0x1128b2;\n        // is this auction for gen0 panda\n        uint64 _0x45140e;\n    }\n\n    // Reference to contract tracking NFT ownership\n    ERC721 public _0xc47244;\n\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\n    // Values 0-10,000 map to 0%-100%\n    uint256 public _0x231b95;\n\n    // Map from token ID to their corresponding auction.\n    mapping (uint256 => Auction) _0xd2cf92;\n\n    event AuctionCreated(uint256 _0x718a9a, uint256 _0xc9080f, uint256 _0xc2d268, uint256 _0xcfcedd);\n    event AuctionSuccessful(uint256 _0x718a9a, uint256 _0xcbf674, address _0xba6695);\n    event AuctionCancelled(uint256 _0x718a9a);\n\n    /// @dev Returns true if the claimant owns the token.\n    /// @param _claimant - Address claiming to own the token.\n    /// @param _tokenId - ID of token whose ownership to verify.\n    function _0x65e38c(address _0xf07313, uint256 _0x9437a0) internal view returns (bool) {\n        return (_0xc47244._0xc2f09b(_0x9437a0) == _0xf07313);\n    }\n\n    /// @dev Escrows the NFT, assigning ownership to this contract.\n    /// Throws if the escrow fails.\n    /// @param _owner - Current owner address of token to escrow.\n    /// @param _tokenId - ID of token whose approval to verify.\n    function _0x2a5046(address _0xb0e749, uint256 _0x9437a0) internal {\n        // it will throw if transfer fails\n        _0xc47244._0x23aab6(_0xb0e749, this, _0x9437a0);\n    }\n\n    /// @dev Transfers an NFT owned by this contract to another address.\n    /// Returns true if the transfer succeeds.\n    /// @param _receiver - Address to transfer NFT to.\n    /// @param _tokenId - ID of token to transfer.\n    function _0x5e6963(address _0x415ddd, uint256 _0x9437a0) internal {\n        // it will throw if transfer fails\n        _0xc47244.transfer(_0x415ddd, _0x9437a0);\n    }\n\n    /// @dev Adds an auction to the list of open auctions. Also fires the\n    ///  AuctionCreated event.\n    /// @param _tokenId The ID of the token to be put on auction.\n    /// @param _auction Auction to add.\n    function _0x1dfc37(uint256 _0x9437a0, Auction _0x2897d5) internal {\n        // Require that all auctions have a duration of\n        // at least one minute. (Keeps our math from getting hairy!)\n        require(_0x2897d5._0xcfcedd >= 1 minutes);\n\n        _0xd2cf92[_0x9437a0] = _0x2897d5;\n\n        AuctionCreated(\n            uint256(_0x9437a0),\n            uint256(_0x2897d5._0xc9080f),\n            uint256(_0x2897d5._0xc2d268),\n            uint256(_0x2897d5._0xcfcedd)\n        );\n    }\n\n    /// @dev Cancels an auction unconditionally.\n    function _0x9b83cc(uint256 _0x9437a0, address _0x40303d) internal {\n        _0x3d0124(_0x9437a0);\n        _0x5e6963(_0x40303d, _0x9437a0);\n        AuctionCancelled(_0x9437a0);\n    }\n\n    /// @dev Computes the price and transfers winnings.\n    /// Does NOT transfer ownership of token.\n    function _0x8ec3d7(uint256 _0x9437a0, uint256 _0xc42a3f)\n        internal\n        returns (uint256)\n    {\n        // Get a reference to the auction struct\n        Auction storage _0xfaedc0 = _0xd2cf92[_0x9437a0];\n\n        // Explicitly check that this auction is currently live.\n        // (Because of how Ethereum mappings work, we can't just count\n        // on the lookup above failing. An invalid _tokenId will just\n        // return an auction object that is all zeros.)\n        require(_0xecf5be(_0xfaedc0));\n\n        // Check that the bid is greater than or equal to the current price\n        uint256 _0x34b70c = _0x0b33b4(_0xfaedc0);\n        require(_0xc42a3f >= _0x34b70c);\n\n        // Grab a reference to the seller before the auction struct\n        // gets deleted.\n        address _0x80bd9c = _0xfaedc0._0x80bd9c;\n\n        // The bid is good! Remove the auction before sending the fees\n        _0x3d0124(_0x9437a0);\n\n        // Transfer proceeds to seller (if there are any!)\n        if (_0x34b70c > 0) {\n            // Calculate the auctioneer's cut.\n            // (NOTE: _computeCut() is guaranteed to return a\n            // value <= price, so this subtraction can't go negative.)\n            uint256 _0x96abdb = _0x339e59(_0x34b70c);\n            uint256 _0x04b982 = _0x34b70c - _0x96abdb;\n\n            // NOTE: Doing a transfer() in the middle of a complex\n            // method like this is generally discouraged because of\n            // a contract with an invalid fallback function. We explicitly\n            // before calling transfer(), and the only thing the seller\n\n            // accident, they can call cancelAuction(). )\n            _0x80bd9c.transfer(_0x04b982);\n        }\n\n        // Calculate any excess funds included with the bid. If the excess\n        // is anything worth worrying about, transfer it back to bidder.\n        // NOTE: We checked above that the bid amount is greater than or\n\n        uint256 _0x6e5419 = _0xc42a3f - _0x34b70c;\n\n        // Return the funds. Similar to the previous transfer, this is\n        // removed before any transfers occur.\n        msg.sender.transfer(_0x6e5419);\n\n        // Tell the world!\n        AuctionSuccessful(_0x9437a0, _0x34b70c, msg.sender);\n\n        return _0x34b70c;\n    }\n\n    /// @dev Removes an auction from the list of open auctions.\n    /// @param _tokenId - ID of NFT on auction.\n    function _0x3d0124(uint256 _0x9437a0) internal {\n        delete _0xd2cf92[_0x9437a0];\n    }\n\n    /// @dev Returns true if the NFT is on auction.\n    /// @param _auction - Auction to check.\n    function _0xecf5be(Auction storage _0x2897d5) internal view returns (bool) {\n        return (_0x2897d5._0x1128b2 > 0);\n    }\n\n    /// @dev Returns current price of an NFT on auction. Broken into two\n    ///  functions (this one, that computes the duration from the auction\n    ///  structure, and the other that does the price computation) so we\n    ///  can easily test that the price computation works correctly.\n    function _0x0b33b4(Auction storage _0x2897d5)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _0xf7b6de = 0;\n\n        // A bit of insurance against negative values (or wraparound).\n        // Probably not necessary (since Ethereum guarnatees that the\n        // now variable doesn't ever go backwards).\n        if (_0xddf414 > _0x2897d5._0x1128b2) {\n            _0xf7b6de = _0xddf414 - _0x2897d5._0x1128b2;\n        }\n\n        return _0x6bbbd2(\n            _0x2897d5._0xc9080f,\n            _0x2897d5._0xc2d268,\n            _0x2897d5._0xcfcedd,\n            _0xf7b6de\n        );\n    }\n\n    /// @dev Computes the current price of an auction. Factored out\n    ///  from _currentPrice so we can run extensive unit tests.\n    ///  When testing, make this function public and turn on\n    ///  `Current price computation` test suite.\n    function _0x6bbbd2(\n        uint256 _0x2c416e,\n        uint256 _0x2fb558,\n        uint256 _0x4bffd2,\n        uint256 _0x797c9a\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our public functions carefully cap the maximum values for\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\n        //  also known to be non-zero (see the require() statement in\n        //  _addAuction())\n        if (_0x797c9a >= _0x4bffd2) {\n            // We've reached the end of the dynamic pricing portion\n            // of the auction, just return the end price.\n            return _0x2fb558;\n        } else {\n            // Starting price can be higher than ending price (and often is!), so\n            // this delta can be negative.\n            int256 _0x59c2d1 = int256(_0x2fb558) - int256(_0x2c416e);\n\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\n            // will always fit within 256-bits.\n            int256 _0x654eed = _0x59c2d1 * int256(_0x797c9a) / int256(_0x4bffd2);\n\n            // currentPriceChange can be negative, but if so, will have a magnitude\n            // less that _startingPrice. Thus, this result will always end up positive.\n            int256 _0x484ece = int256(_0x2c416e) + _0x654eed;\n\n            return uint256(_0x484ece);\n        }\n    }\n\n    /// @dev Computes owner's cut of a sale.\n    /// @param _price - Sale price of NFT.\n    function _0x339e59(uint256 _0x3a3c1b) internal view returns (uint256) {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our entry functions carefully cap the maximum values for\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n        //  statement in the ClockAuction constructor). The result of this\n        //  function is always guaranteed to be <= _price.\n        return _0x3a3c1b * _0x231b95 / 10000;\n    }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public _0x86dc0a = false;\n\n  modifier _0x04df49() {\n    require(!_0x86dc0a);\n    _;\n  }\n\n  modifier _0x53d1a2 {\n    require(_0x86dc0a);\n    _;\n  }\n\n  function _0x23403d() _0x017abd _0x04df49 returns (bool) {\n    _0x86dc0a = true;\n    Pause();\n    return true;\n  }\n\n  function _0xd59e82() _0x017abd _0x53d1a2 returns (bool) {\n    _0x86dc0a = false;\n    Unpause();\n    return true;\n  }\n}\n\n/// @title Clock auction for non-fungible tokens.\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract ClockAuction is Pausable, ClockAuctionBase {\n\n    /// @dev The ERC-165 interface signature for ERC-721.\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n\n    /// @dev Constructor creates a reference to the NFT ownership contract\n    ///  and verifies the owner cut is in the valid range.\n    /// @param _nftAddress - address of a deployed contract implementing\n    ///  the Nonfungible Interface.\n    /// @param _cut - percent cut the owner takes on each auction, must be\n    ///  between 0-10,000.\n    function ClockAuction(address _0xd6a833, uint256 _0xc8b9db) public {\n        require(_0xc8b9db <= 10000);\n        _0x231b95 = _0xc8b9db;\n\n        ERC721 _0xbfacca = ERC721(_0xd6a833);\n        require(_0xbfacca._0xd896c3(InterfaceSignature_ERC721));\n        _0xc47244 = _0xbfacca;\n    }\n\n    /// @dev Remove all Ether from the contract, which is the owner's cuts\n    ///  as well as any Ether sent directly to the contract address.\n    ///  Always transfers to the NFT contract, but can be called either by\n    ///  the owner or the NFT contract.\n    function _0xf5ead4() external {\n        address _0x93952e = address(_0xc47244);\n\n        require(\n            msg.sender == _0xcb5efa ||\n            msg.sender == _0x93952e\n        );\n        // We are using this boolean method to make sure that even if one fails it will still work\n        bool _0x11e1bc = _0x93952e.send(this.balance);\n    }\n\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of time to move between starting\n    ///  price and ending price (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0x9bdcc7(\n        uint256 _0x9437a0,\n        uint256 _0x2c416e,\n        uint256 _0x2fb558,\n        uint256 _0x4bffd2,\n        address _0x40303d\n    )\n        external\n        _0x04df49\n    {\n\n        // to store them in the auction struct.\n        require(_0x2c416e == uint256(uint128(_0x2c416e)));\n        require(_0x2fb558 == uint256(uint128(_0x2fb558)));\n        require(_0x4bffd2 == uint256(uint64(_0x4bffd2)));\n\n        require(_0x65e38c(msg.sender, _0x9437a0));\n        _0x2a5046(msg.sender, _0x9437a0);\n        Auction memory _0xfaedc0 = Auction(\n            _0x40303d,\n            uint128(_0x2c416e),\n            uint128(_0x2fb558),\n            uint64(_0x4bffd2),\n            uint64(_0xddf414),\n            0\n        );\n        _0x1dfc37(_0x9437a0, _0xfaedc0);\n    }\n\n    /// @dev Bids on an open auction, completing the auction and transferring\n    ///  ownership of the NFT if enough Ether is supplied.\n    /// @param _tokenId - ID of token to bid on.\n    function _0x3cee2c(uint256 _0x9437a0)\n        external\n        payable\n        _0x04df49\n    {\n        // _bid will throw if the bid or funds transfer fails\n        _0x8ec3d7(_0x9437a0, msg.value);\n        _0x5e6963(msg.sender, _0x9437a0);\n    }\n\n    /// @dev Cancels an auction that hasn't been won yet.\n    ///  Returns the NFT to original owner.\n    /// @notice This is a state-modifying function that can\n    ///  be called while the contract is paused.\n    /// @param _tokenId - ID of token on auction\n    function _0xe43d22(uint256 _0x9437a0)\n        external\n    {\n        Auction storage _0xfaedc0 = _0xd2cf92[_0x9437a0];\n        require(_0xecf5be(_0xfaedc0));\n        address _0x80bd9c = _0xfaedc0._0x80bd9c;\n        require(msg.sender == _0x80bd9c);\n        _0x9b83cc(_0x9437a0, _0x80bd9c);\n    }\n\n    /// @dev Cancels an auction when the contract is paused.\n    ///  Only the owner may do this, and NFTs are returned to\n    ///  the seller. This should only be used in emergencies.\n    /// @param _tokenId - ID of the NFT on auction to cancel.\n    function _0x809ba8(uint256 _0x9437a0)\n        _0x53d1a2\n        _0x017abd\n        external\n    {\n        Auction storage _0xfaedc0 = _0xd2cf92[_0x9437a0];\n        require(_0xecf5be(_0xfaedc0));\n        _0x9b83cc(_0x9437a0, _0xfaedc0._0x80bd9c);\n    }\n\n    /// @dev Returns auction info for an NFT on auction.\n    /// @param _tokenId - ID of NFT on auction.\n    function _0x7cae85(uint256 _0x9437a0)\n        external\n        view\n        returns\n    (\n        address _0x80bd9c,\n        uint256 _0xc9080f,\n        uint256 _0xc2d268,\n        uint256 _0xcfcedd,\n        uint256 _0x1128b2\n    ) {\n        Auction storage _0xfaedc0 = _0xd2cf92[_0x9437a0];\n        require(_0xecf5be(_0xfaedc0));\n        return (\n            _0xfaedc0._0x80bd9c,\n            _0xfaedc0._0xc9080f,\n            _0xfaedc0._0xc2d268,\n            _0xfaedc0._0xcfcedd,\n            _0xfaedc0._0x1128b2\n        );\n    }\n\n    /// @dev Returns the current price of an auction.\n    /// @param _tokenId - ID of the token price we are checking.\n    function _0x99433b(uint256 _0x9437a0)\n        external\n        view\n        returns (uint256)\n    {\n        Auction storage _0xfaedc0 = _0xd2cf92[_0x9437a0];\n        require(_0xecf5be(_0xfaedc0));\n        return _0x0b33b4(_0xfaedc0);\n    }\n\n}\n\n/// @title Reverse auction modified for siring\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SiringClockAuction is ClockAuction {\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSiringAuctionAddress() call.\n    bool public _0x91696e = true;\n\n    // Delegate constructor\n    function SiringClockAuction(address _0x058446, uint256 _0xc8b9db) public\n        ClockAuction(_0x058446, _0xc8b9db) {}\n\n    /// @dev Creates and begins a new auction. Since this function is wrapped,\n    /// require sender to be PandaCore contract.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0x9bdcc7(\n        uint256 _0x9437a0,\n        uint256 _0x2c416e,\n        uint256 _0x2fb558,\n        uint256 _0x4bffd2,\n        address _0x40303d\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0x2c416e == uint256(uint128(_0x2c416e)));\n        require(_0x2fb558 == uint256(uint128(_0x2fb558)));\n        require(_0x4bffd2 == uint256(uint64(_0x4bffd2)));\n\n        require(msg.sender == address(_0xc47244));\n        _0x2a5046(_0x40303d, _0x9437a0);\n        Auction memory _0xfaedc0 = Auction(\n            _0x40303d,\n            uint128(_0x2c416e),\n            uint128(_0x2fb558),\n            uint64(_0x4bffd2),\n            uint64(_0xddf414),\n            0\n        );\n        _0x1dfc37(_0x9437a0, _0xfaedc0);\n    }\n\n    /// @dev Places a bid for siring. Requires the sender\n    /// is the PandaCore contract because all bid methods\n    /// should be wrapped. Also returns the panda to the\n    /// seller rather than the winner.\n    function _0x3cee2c(uint256 _0x9437a0)\n        external\n        payable\n    {\n        require(msg.sender == address(_0xc47244));\n        address _0x80bd9c = _0xd2cf92[_0x9437a0]._0x80bd9c;\n        // _bid checks that token ID is valid and will throw if bid fails\n        _0x8ec3d7(_0x9437a0, msg.value);\n        // We transfer the panda back to the seller, the winner will get\n        // the offspring\n        _0x5e6963(_0x80bd9c, _0x9437a0);\n    }\n\n}\n\n/// @title Clock auction modified for sale of pandas\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SaleClockAuction is ClockAuction {\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSaleAuctionAddress() call.\n    bool public _0x19b3be = true;\n\n    // Tracks last 5 sale price of gen0 panda sales\n    uint256 public _0xb07986;\n    uint256[5] public _0xb62f54;\n    uint256 public constant SurpriseValue = 10 finney;\n\n    uint256[] CommonPanda;\n    uint256[] RarePanda;\n    uint256   CommonPandaIndex;\n    uint256   RarePandaIndex;\n\n    // Delegate constructor\n    function SaleClockAuction(address _0x058446, uint256 _0xc8b9db) public\n        ClockAuction(_0x058446, _0xc8b9db) {\n            CommonPandaIndex = 1;\n            RarePandaIndex   = 1;\n    }\n\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0x9bdcc7(\n        uint256 _0x9437a0,\n        uint256 _0x2c416e,\n        uint256 _0x2fb558,\n        uint256 _0x4bffd2,\n        address _0x40303d\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0x2c416e == uint256(uint128(_0x2c416e)));\n        require(_0x2fb558 == uint256(uint128(_0x2fb558)));\n        require(_0x4bffd2 == uint256(uint64(_0x4bffd2)));\n\n        require(msg.sender == address(_0xc47244));\n        _0x2a5046(_0x40303d, _0x9437a0);\n        Auction memory _0xfaedc0 = Auction(\n            _0x40303d,\n            uint128(_0x2c416e),\n            uint128(_0x2fb558),\n            uint64(_0x4bffd2),\n            uint64(_0xddf414),\n            0\n        );\n        _0x1dfc37(_0x9437a0, _0xfaedc0);\n    }\n\n    function _0xba0de6(\n        uint256 _0x9437a0,\n        uint256 _0x2c416e,\n        uint256 _0x2fb558,\n        uint256 _0x4bffd2,\n        address _0x40303d\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0x2c416e == uint256(uint128(_0x2c416e)));\n        require(_0x2fb558 == uint256(uint128(_0x2fb558)));\n        require(_0x4bffd2 == uint256(uint64(_0x4bffd2)));\n\n        require(msg.sender == address(_0xc47244));\n        _0x2a5046(_0x40303d, _0x9437a0);\n        Auction memory _0xfaedc0 = Auction(\n            _0x40303d,\n            uint128(_0x2c416e),\n            uint128(_0x2fb558),\n            uint64(_0x4bffd2),\n            uint64(_0xddf414),\n            1\n        );\n        _0x1dfc37(_0x9437a0, _0xfaedc0);\n    }\n\n    /// @dev Updates lastSalePrice if seller is the nft contract\n    /// Otherwise, works the same as default bid method.\n    function _0x3cee2c(uint256 _0x9437a0)\n        external\n        payable\n    {\n        // _bid verifies token ID size\n        uint64 _0x45140e = _0xd2cf92[_0x9437a0]._0x45140e;\n        uint256 _0x34b70c = _0x8ec3d7(_0x9437a0, msg.value);\n        _0x5e6963(msg.sender, _0x9437a0);\n\n        // If not a gen0 auction, exit\n        if (_0x45140e == 1) {\n            // Track gen0 sale prices\n            _0xb62f54[_0xb07986 % 5] = _0x34b70c;\n            _0xb07986++;\n        }\n    }\n\n    function _0x18bf09(uint256 _0x9437a0,uint256 _0x0df092)\n        external\n    {\n        require(msg.sender == address(_0xc47244));\n        if (_0x0df092 == 0) {\n            CommonPanda.push(_0x9437a0);\n        }else {\n            RarePanda.push(_0x9437a0);\n        }\n    }\n\n    function _0xb26472()\n        external\n        payable\n    {\n        bytes32 _0x41ee68 = _0x2a9820(block.blockhash(block.number),block.blockhash(block.number-1));\n        uint256 PandaIndex;\n        if (_0x41ee68[25] > 0xC8) {\n            require(uint256(RarePanda.length) >= RarePandaIndex);\n            PandaIndex = RarePandaIndex;\n            RarePandaIndex ++;\n\n        } else{\n            require(uint256(CommonPanda.length) >= CommonPandaIndex);\n            PandaIndex = CommonPandaIndex;\n            CommonPandaIndex ++;\n        }\n        _0x5e6963(msg.sender,PandaIndex);\n    }\n\n    function _0x1dd16f() external view returns(uint256 _0x7efa86,uint256 _0xa213f5) {\n        if (true) { _0x7efa86   = CommonPanda.length + 1 - CommonPandaIndex; }\n        _0xa213f5 = RarePanda.length + 1 - RarePandaIndex;\n    }\n\n    function _0x082d33() external view returns (uint256) {\n        uint256 _0xfd6cae = 0;\n        for (uint256 i = 0; i < 5; i++) {\n            _0xfd6cae += _0xb62f54[i];\n        }\n        return _0xfd6cae / 5;\n    }\n\n}\n\n/// @title Clock auction modified for sale of pandas\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SaleClockAuctionERC20 is ClockAuction {\n\n    event AuctionERC20Created(uint256 _0x718a9a, uint256 _0xc9080f, uint256 _0xc2d268, uint256 _0xcfcedd, address _0x212724);\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSaleAuctionAddress() call.\n    bool public _0x994b87 = true;\n\n    mapping (uint256 => address) public _0x9ee408;\n\n    mapping (address => uint256) public _0x3e2cea;\n\n    mapping (address => uint256) public _0x85b4a9;\n\n    // Delegate constructor\n    function SaleClockAuctionERC20(address _0x058446, uint256 _0xc8b9db) public\n        ClockAuction(_0x058446, _0xc8b9db) {}\n\n    function _0x548c8c(address _0xabb9f5, uint256 _0x6017ad) external{\n        require (msg.sender == address(_0xc47244));\n\n        require (_0xabb9f5 != address(0));\n\n        _0x3e2cea[_0xabb9f5] = _0x6017ad;\n    }\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0x9bdcc7(\n        uint256 _0x9437a0,\n        address _0x4b897b,\n        uint256 _0x2c416e,\n        uint256 _0x2fb558,\n        uint256 _0x4bffd2,\n        address _0x40303d\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0x2c416e == uint256(uint128(_0x2c416e)));\n        require(_0x2fb558 == uint256(uint128(_0x2fb558)));\n        require(_0x4bffd2 == uint256(uint64(_0x4bffd2)));\n\n        require(msg.sender == address(_0xc47244));\n\n        require (_0x3e2cea[_0x4b897b] > 0);\n\n        _0x2a5046(_0x40303d, _0x9437a0);\n        Auction memory _0xfaedc0 = Auction(\n            _0x40303d,\n            uint128(_0x2c416e),\n            uint128(_0x2fb558),\n            uint64(_0x4bffd2),\n            uint64(_0xddf414),\n            0\n        );\n        _0xd3823c(_0x9437a0, _0xfaedc0, _0x4b897b);\n        _0x9ee408[_0x9437a0] = _0x4b897b;\n    }\n\n    /// @dev Adds an auction to the list of open auctions. Also fires the\n    ///  AuctionCreated event.\n    /// @param _tokenId The ID of the token to be put on auction.\n    /// @param _auction Auction to add.\n    function _0xd3823c(uint256 _0x9437a0, Auction _0x2897d5, address _0xabb9f5) internal {\n        // Require that all auctions have a duration of\n        // at least one minute. (Keeps our math from getting hairy!)\n        require(_0x2897d5._0xcfcedd >= 1 minutes);\n\n        _0xd2cf92[_0x9437a0] = _0x2897d5;\n\n        AuctionERC20Created(\n            uint256(_0x9437a0),\n            uint256(_0x2897d5._0xc9080f),\n            uint256(_0x2897d5._0xc2d268),\n            uint256(_0x2897d5._0xcfcedd),\n            _0xabb9f5\n        );\n    }\n\n    function _0x3cee2c(uint256 _0x9437a0)\n        external\n        payable{\n            // do nothing\n    }\n\n    /// @dev Updates lastSalePrice if seller is the nft contract\n    /// Otherwise, works the same as default bid method.\n    function _0xc2d832(uint256 _0x9437a0,uint256 _0xad0126)\n        external\n    {\n        // _bid verifies token ID size\n        address _0x80bd9c = _0xd2cf92[_0x9437a0]._0x80bd9c;\n        address _0xabb9f5 = _0x9ee408[_0x9437a0];\n        require (_0xabb9f5 != address(0));\n        uint256 _0x34b70c = _0x76e4c1(_0xabb9f5,msg.sender,_0x9437a0, _0xad0126);\n        _0x5e6963(msg.sender, _0x9437a0);\n        delete _0x9ee408[_0x9437a0];\n    }\n\n    function _0xe43d22(uint256 _0x9437a0)\n        external\n    {\n        Auction storage _0xfaedc0 = _0xd2cf92[_0x9437a0];\n        require(_0xecf5be(_0xfaedc0));\n        address _0x80bd9c = _0xfaedc0._0x80bd9c;\n        require(msg.sender == _0x80bd9c);\n        _0x9b83cc(_0x9437a0, _0x80bd9c);\n        delete _0x9ee408[_0x9437a0];\n    }\n\n    function _0xe1a339(address _0x4b897b, address _0x64cd68) external returns(bool _0x11e1bc)  {\n        require (_0x85b4a9[_0x4b897b] > 0);\n        require(msg.sender == address(_0xc47244));\n        ERC20(_0x4b897b).transfer(_0x64cd68, _0x85b4a9[_0x4b897b]);\n    }\n\n    /// @dev Computes the price and transfers winnings.\n    /// Does NOT transfer ownership of token.\n    function _0x76e4c1(address _0x4b897b,address _0xbffa38, uint256 _0x9437a0, uint256 _0xc42a3f)\n        internal\n        returns (uint256)\n    {\n        // Get a reference to the auction struct\n        Auction storage _0xfaedc0 = _0xd2cf92[_0x9437a0];\n\n        // Explicitly check that this auction is currently live.\n        // (Because of how Ethereum mappings work, we can't just count\n        // on the lookup above failing. An invalid _tokenId will just\n        // return an auction object that is all zeros.)\n        require(_0xecf5be(_0xfaedc0));\n\n        require (_0x4b897b != address(0) && _0x4b897b == _0x9ee408[_0x9437a0]);\n\n        // Check that the bid is greater than or equal to the current price\n        uint256 _0x34b70c = _0x0b33b4(_0xfaedc0);\n        require(_0xc42a3f >= _0x34b70c);\n\n        // Grab a reference to the seller before the auction struct\n        // gets deleted.\n        address _0x80bd9c = _0xfaedc0._0x80bd9c;\n\n        // The bid is good! Remove the auction before sending the fees\n        _0x3d0124(_0x9437a0);\n\n        // Transfer proceeds to seller (if there are any!)\n        if (_0x34b70c > 0) {\n            // Calculate the auctioneer's cut.\n            // (NOTE: _computeCut() is guaranteed to return a\n            // value <= price, so this subtraction can't go negative.)\n            uint256 _0x96abdb = _0x339e59(_0x34b70c);\n            uint256 _0x04b982 = _0x34b70c - _0x96abdb;\n\n            // Send Erc20 Token to seller should call Erc20 contract\n            // Reference to contract\n            require(ERC20(_0x4b897b)._0x23aab6(_0xbffa38,_0x80bd9c,_0x04b982));\n            if (_0x96abdb > 0){\n                require(ERC20(_0x4b897b)._0x23aab6(_0xbffa38,address(this),_0x96abdb));\n                _0x85b4a9[_0x4b897b] += _0x96abdb;\n            }\n        }\n\n        // Tell the world!\n        AuctionSuccessful(_0x9437a0, _0x34b70c, msg.sender);\n\n        return _0x34b70c;\n    }\n}\n\n/// @title Handles creating auctions for sale and siring of pandas.\n///  This wrapper of ReverseAuction exists only so that users can create\n///  auctions with only one transaction.\ncontract PandaAuction is PandaBreeding {\n\n    // @notice The auction contract variables are defined in PandaBase to allow\n    //  us to refer to them in PandaOwnership to prevent accidental transfers.\n    // `saleAuction` refers to the auction for gen0 and p2p sale of pandas.\n    // `siringAuction` refers to the auction for siring rights of pandas.\n\n    /// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function _0xb4d642(address _0xf2098b) external _0x60b274 {\n        SaleClockAuction _0xbfacca = SaleClockAuction(_0xf2098b);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0xbfacca._0x19b3be());\n\n        // Set the new contract address\n        _0x9e851a = _0xbfacca;\n    }\n\n    function _0xf1b588(address _0xf2098b) external _0x60b274 {\n        SaleClockAuctionERC20 _0xbfacca = SaleClockAuctionERC20(_0xf2098b);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0xbfacca._0x994b87());\n\n        // Set the new contract address\n        _0x3e1e93 = _0xbfacca;\n    }\n\n    /// @dev Sets the reference to the siring auction.\n    /// @param _address - Address of siring contract.\n    function _0xe0800d(address _0xf2098b) external _0x60b274 {\n        SiringClockAuction _0xbfacca = SiringClockAuction(_0xf2098b);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0xbfacca._0x91696e());\n\n        // Set the new contract address\n        _0x23c70b = _0xbfacca;\n    }\n\n    /// @dev Put a panda up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function _0xe77f95(\n        uint256 _0x7e84fb,\n        uint256 _0x2c416e,\n        uint256 _0x2fb558,\n        uint256 _0x4bffd2\n    )\n        external\n        _0x04df49\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_0x65e38c(msg.sender, _0x7e84fb));\n        // Ensure the panda is not pregnant to prevent the auction\n        // contract accidentally receiving ownership of the child.\n        // NOTE: the panda IS allowed to be in a cooldown.\n        require(!_0x7ccc7a(_0x7e84fb));\n        _0xd82f3d(_0x7e84fb, _0x9e851a);\n        // Sale auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        _0x9e851a._0x9bdcc7(\n            _0x7e84fb,\n            _0x2c416e,\n            _0x2fb558,\n            _0x4bffd2,\n            msg.sender\n        );\n    }\n\n    /// @dev Put a panda up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function _0xe98e0a(\n        uint256 _0x7e84fb,\n        address _0xabb9f5,\n        uint256 _0x2c416e,\n        uint256 _0x2fb558,\n        uint256 _0x4bffd2\n    )\n        external\n        _0x04df49\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_0x65e38c(msg.sender, _0x7e84fb));\n        // Ensure the panda is not pregnant to prevent the auction\n        // contract accidentally receiving ownership of the child.\n        // NOTE: the panda IS allowed to be in a cooldown.\n        require(!_0x7ccc7a(_0x7e84fb));\n        _0xd82f3d(_0x7e84fb, _0x3e1e93);\n        // Sale auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        _0x3e1e93._0x9bdcc7(\n            _0x7e84fb,\n            _0xabb9f5,\n            _0x2c416e,\n            _0x2fb558,\n            _0x4bffd2,\n            msg.sender\n        );\n    }\n\n    function _0x4a1b92(address _0xabb9f5, uint256 _0x6017ad) external _0x864e74{\n        _0x3e1e93._0x548c8c(_0xabb9f5,_0x6017ad);\n    }\n\n    /// @dev Put a panda up for auction to be sire.\n    ///  Performs checks to ensure the panda can be sired, then\n    ///  delegates to reverse auction.\n    function _0xf31553(\n        uint256 _0x7e84fb,\n        uint256 _0x2c416e,\n        uint256 _0x2fb558,\n        uint256 _0x4bffd2\n    )\n        external\n        _0x04df49\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_0x65e38c(msg.sender, _0x7e84fb));\n        require(_0x9ba8b0(_0x7e84fb));\n        _0xd82f3d(_0x7e84fb, _0x23c70b);\n        // Siring auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        _0x23c70b._0x9bdcc7(\n            _0x7e84fb,\n            _0x2c416e,\n            _0x2fb558,\n            _0x4bffd2,\n            msg.sender\n        );\n    }\n\n    /// @dev Completes a siring auction by bidding.\n    ///  Immediately breeds the winning matron with the sire on auction.\n    /// @param _sireId - ID of the sire on auction.\n    /// @param _matronId - ID of the matron owned by the bidder.\n    function _0xf91b2a(\n        uint256 _0x9027a1,\n        uint256 _0x27eecf\n    )\n        external\n        payable\n        _0x04df49\n    {\n        // Auction contract checks input sizes\n        require(_0x65e38c(msg.sender, _0x27eecf));\n        require(_0x9ba8b0(_0x27eecf));\n        require(_0x90fc42(_0x27eecf, _0x9027a1));\n\n        // Define the current price of the auction.\n        uint256 _0x484ece = _0x23c70b._0x99433b(_0x9027a1);\n        require(msg.value >= _0x484ece + _0x3ecc6f);\n\n        // Siring auction will throw if the bid fails.\n        _0x23c70b._0x3cee2c.value(msg.value - _0x3ecc6f)(_0x9027a1);\n        _0x355b02(uint32(_0x27eecf), uint32(_0x9027a1), msg.sender);\n    }\n\n    /// @dev Transfers the balance of the sale auction contract\n    /// to the PandaCore contract. We use two-step withdrawal to\n    /// prevent two transfer calls in the auction bid function.\n    function _0x8a3138() external _0xcfa2eb {\n        _0x9e851a._0xf5ead4();\n        _0x23c70b._0xf5ead4();\n    }\n\n    function _0xe1a339(address _0x4b897b, address _0x64cd68) external _0xcfa2eb {\n        require(_0x3e1e93 != address(0));\n        _0x3e1e93._0xe1a339(_0x4b897b,_0x64cd68);\n    }\n}\n\n/// @title all functions related to creating kittens\ncontract PandaMinting is PandaAuction {\n\n    // Limits the number of cats the contract owner can ever create.\n    //uint256 public constant PROMO_CREATION_LIMIT = 5000;\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\n\n    // Constants for gen0 auctions.\n    uint256 public constant GEN0_STARTING_PRICE = 100 finney;\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\n    uint256 public constant OPEN_PACKAGE_PRICE = 10 finney;\n\n    // Counts the number of cats the contract owner has created.\n    //uint256 public promoCreatedCount;\n\n    /// @dev we can create promo kittens, up to a limit. Only callable by COO\n    /// @param _genes the encoded genes of the kitten to be created, any value is accepted\n    /// @param _owner the future owner of the created kittens. Default to contract COO\n    function _0x3c08f8(uint256[2] _0xd14de0, uint256 _0xce7d73, address _0xb0e749) external _0x864e74 {\n        address _0x30c421 = _0xb0e749;\n        if (_0x30c421 == address(0)) {\n            _0x30c421 = _0xd84fc8;\n        }\n\n        _0x5f3cbe(0, 0, _0xce7d73, _0xd14de0, _0x30c421);\n    }\n\n    /// @dev create pandaWithGenes\n    /// @param _genes panda genes\n    /// @param _type  0 common 1 rare\n    function _0x18bf09(uint256[2] _0xd14de0,uint256 _0xce7d73,uint256 _0x0df092)\n        external\n        payable\n        _0x864e74\n        _0x04df49\n    {\n        require(msg.value >= OPEN_PACKAGE_PRICE);\n        uint256 _0x7f537b = _0x5f3cbe(0, 0, _0xce7d73, _0xd14de0, _0x9e851a);\n        _0x9e851a._0x18bf09(_0x7f537b,_0x0df092);\n    }\n\n    //function buyPandaERC20(address _erc20Address, address _buyerAddress, uint256 _pandaID, uint256 _amount)\n    //external\n    //onlyCOO\n    //whenNotPaused {\n    //    saleAuctionERC20.bid(_erc20Address, _buyerAddress, _pandaID, _amount);\n    //}\n\n    /// @dev Creates a new gen0 panda with the given genes and\n    ///  creates an auction for it.\n    //function createGen0Auction(uint256[2] _genes) external onlyCOO {\n    //    require(gen0CreatedCount < GEN0_CREATION_LIMIT);\n    //\n    //    uint256 pandaId = _createPanda(0, 0, 0, _genes, address(this));\n    //    _approve(pandaId, saleAuction);\n    //\n    //    saleAuction.createAuction(\n    //        pandaId,\n    //        _computeNextGen0Price(),\n    //        0,\n    //        GEN0_AUCTION_DURATION,\n    //        address(this)\n    //    );\n    //\n    //    gen0CreatedCount++;\n    //}\n\n    function _0xba0de6(uint256 _0x7e84fb) external _0x864e74 {\n        require(_0x65e38c(msg.sender, _0x7e84fb));\n        //require(pandas[_pandaId].generation==1);\n\n        _0xd82f3d(_0x7e84fb, _0x9e851a);\n\n        _0x9e851a._0xba0de6(\n            _0x7e84fb,\n            _0xcb80b7(),\n            0,\n            GEN0_AUCTION_DURATION,\n            msg.sender\n        );\n    }\n\n    /// @dev Computes the next gen0 auction starting price, given\n    ///  the average of the past 5 prices + 50%.\n    function _0xcb80b7() internal view returns(uint256) {\n        uint256 _0xdd6371 = _0x9e851a._0x082d33();\n\n        require(_0xdd6371 == uint256(uint128(_0xdd6371)));\n\n        uint256 _0xa871aa = _0xdd6371 + (_0xdd6371 / 2);\n\n        // We never auction for less than starting price\n        if (_0xa871aa < GEN0_STARTING_PRICE) {\n            _0xa871aa = GEN0_STARTING_PRICE;\n        }\n\n        return _0xa871aa;\n    }\n}\n\n/// @title CryptoPandas: Collectible, breedable, and oh-so-adorable cats on the Ethereum blockchain.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev The main CryptoPandas contract, keeps track of kittens so they don't wander around and get lost.\ncontract PandaCore is PandaMinting {\n\n    // This is the main CryptoPandas contract. In order to keep our code seperated into logical sections,\n    // we've broken it up in two ways. First, we have several seperately-instantiated sibling contracts\n    // that handle auctions and our super-top-secret genetic combination algorithm. The auctions are\n    // seperate since their logic is somewhat complex and there's always a risk of subtle bugs. By keeping\n    // them in their own contracts, we can upgrade them without disrupting the main contract that tracks\n    // panda ownership. The genetic combination algorithm is kept seperate so we can open-source all of\n    // the rest of our code without making it _too_ easy for folks to figure out how the genetics work.\n    // Don't worry, I'm sure someone will reverse engineer it soon enough!\n    //\n    // Secondly, we break the core contract into multiple files using inheritence, one for each major\n    // facet of functionality of CK. This allows us to keep related code bundled together while still\n    // avoiding a single giant file with everything in it. The breakdown is as follows:\n    //\n    //      - PandaBase: This is where we define the most fundamental code shared throughout the core\n    //             functionality. This includes our main data storage, constants and data types, plus\n    //             internal functions for managing these items.\n    //\n    //      - PandaAccessControl: This contract manages the various addresses and constraints for operations\n    //             that can be executed only by specific roles. Namely CEO, CFO and COO.\n    //\n    //      - PandaOwnership: This provides the methods required for basic non-fungible token\n    //             transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).\n    //\n    //      - PandaBreeding: This file contains the methods necessary to breed cats together, including\n    //             keeping track of siring offers, and relies on an external genetic combination contract.\n    //\n    //      - PandaAuctions: Here we have the public methods for auctioning or bidding on cats or siring\n    //             services. The actual auction functionality is handled in two sibling contracts (one\n    //             for sales and one for siring), while auction creation and bidding is mostly mediated\n    //             through this facet of the core contract.\n    //\n    //      - PandaMinting: This final facet contains the functionality we use for creating new gen0 cats.\n    //             the community is new), and all others can only be created and then immediately put up\n    //             for auction via an algorithmically determined starting price. Regardless of how they\n    //             are created, there is a hard limit of 50k gen0 cats. After that, it's all up to the\n    //             community to breed, breed, breed!\n\n    // Set in case the core contract is broken and an upgrade is required\n    address public _0x90d77a;\n\n    /// @notice Creates the main CryptoPandas smart contract instance.\n    function PandaCore() public {\n        // Starts paused.\n        _0x86dc0a = true;\n\n        // the creator of the contract is the initial CEO\n        _0x056adb = msg.sender;\n\n        // the creator of the contract is also the initial COO\n        if (1 == 1) { _0xd84fc8 = msg.sender; }\n\n        // move these code to init(), so we not excceed gas limit\n        //uint256[2] memory _genes = [uint256(-1),uint256(-1)];\n\n        //wizzPandaQuota[1] = 100;\n\n        //_createPanda(0, 0, 0, _genes, address(0));\n    }\n\n    /// init contract\n    function _0xedb3eb() external _0x60b274 _0x53d1a2 {\n        // make sure init() only run once\n        require(_0xde19c2.length == 0);\n        // start with the mythical kitten 0 - so we don't have generation-0 parent issues\n        uint256[2] memory _0xd14de0 = [uint256(-1),uint256(-1)];\n\n        _0xfd10e4[1] = 100;\n       _0x5f3cbe(0, 0, 0, _0xd14de0, address(0));\n    }\n\n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n\n    ///  emit a message indicating that the new address is set. It's up to clients of this\n    ///  contract to update to the new contract address in that case. (This contract will\n    ///  be paused indefinitely if such an upgrade takes place.)\n    /// @param _v2Address new address\n    function _0xf1cd00(address _0x4153ae) external _0x60b274 _0x53d1a2 {\n        // See README.md for updgrade plan\n        _0x90d77a = _0x4153ae;\n        ContractUpgrade(_0x4153ae);\n    }\n\n    /// @notice No tipping!\n    /// @dev Reject all Ether from being sent here, unless it's from one of the\n    ///  two auction contracts. (Hopefully, we can prevent user accidents.)\n    function() external payable {\n        require(\n            msg.sender == address(_0x9e851a) ||\n            msg.sender == address(_0x23c70b)\n        );\n    }\n\n    /// @notice Returns all the relevant information about a specific panda.\n    /// @param _id The ID of the panda of interest.\n    function _0xb7a553(uint256 _0xfa9287)\n        external\n        view\n        returns (\n        bool _0x18f41c,\n        bool _0xc176bb,\n        uint256 _0xd993db,\n        uint256 _0x51b1ce,\n        uint256 _0xdb4890,\n        uint256 _0x14d428,\n        uint256 _0xcaa582,\n        uint256 _0x9a6a79,\n        uint256 _0xcb4be8,\n        uint256[2] _0xd7149e\n    ) {\n        Panda storage _0x3cca96 = _0xde19c2[_0xfa9287];\n\n        // if this variable is 0 then it's not gestating\n        _0x18f41c = (_0x3cca96._0xdb4890 != 0);\n        _0xc176bb = (_0x3cca96._0x5c4b14 <= block.number);\n        _0xd993db = uint256(_0x3cca96._0xd993db);\n        _0x51b1ce = uint256(_0x3cca96._0x5c4b14);\n        _0xdb4890 = uint256(_0x3cca96._0xdb4890);\n        _0x14d428 = uint256(_0x3cca96._0x14d428);\n        _0xcaa582 = uint256(_0x3cca96._0xcaa582);\n        _0x9a6a79 = uint256(_0x3cca96._0x9a6a79);\n        _0xcb4be8 = uint256(_0x3cca96._0xcb4be8);\n        _0xd7149e = _0x3cca96._0xd7149e;\n    }\n\n    /// @dev Override unpause so it requires all external contract addresses\n    ///  to be set before contract can be unpaused. Also, we can't have\n    ///  newContractAddress set either, because then the contract was upgraded.\n    /// @notice This is public rather than external so we can call super.unpause\n    ///  without using an expensive CALL.\n    function _0xd59e82() public _0x60b274 _0x53d1a2 {\n        require(_0x9e851a != address(0));\n        require(_0x23c70b != address(0));\n        require(_0xc88e88 != address(0));\n        require(_0x90d77a == address(0));\n\n        // Actually unpause the contract.\n        super._0xd59e82();\n    }\n\n    // @dev Allows the CFO to capture the balance available to the contract.\n    function _0xf5ead4() external _0xd4d0ef {\n        uint256 balance = this.balance;\n        // Subtract all the currently pregnant kittens we have, plus 1 of margin.\n        uint256 _0xd33c6f = (_0x6d06de + 1) * _0x3ecc6f;\n\n        if (balance > _0xd33c6f) {\n            _0xdf7871.send(balance - _0xd33c6f);\n        }\n    }\n}\n",
      "rename_map": {
        "setSaleAuctionERC20Address": "_0xf1b588",
        "switchSaleAuctionERC20For": "_0x4a1b92",
        "withdrawAuctionBalances": "_0x8a3138",
        "isSaleClockAuctionERC20": "_0x994b87",
        "setSiringAuctionAddress": "_0xe0800d",
        "cancelAuctionWhenPaused": "_0x809ba8",
        "_canBreedWithViaAuction": "_0x90fc42",
        "createSaleAuctionERC20": "_0xe98e0a",
        "erc20ContractsSwitcher": "_0x3e2cea",
        "setSaleAuctionAddress": "_0xb4d642",
        "setGeneScienceAddress": "_0xd3bc24",
        "_computeNextGen0Price": "_0xcb80b7",
        "_exchangeMatronSireId": "_0x7e5e58",
        "tokenIdToErc20Address": "_0x9ee408",
        "sireAllowedToAddress": "_0xacfa1a",
        "_computeCurrentPrice": "_0x6bbbd2",
        "isSiringClockAuction": "_0x91696e",
        "averageGen0SalePrice": "_0x082d33",
        "withdrawERC20Balance": "_0xe1a339",
        "pandaIndexToApproved": "_0x43de16",
        "getWizzPandaQuotaOf": "_0x541479",
        "erc20ContractSwitch": "_0x548c8c",
        "getWizzPandaCountOf": "_0x029fc0",
        "ownershipTokenCount": "_0x07b50b",
        "createSiringAuction": "_0xf31553",
        "setTotalWizzPandaOf": "_0x0bc7d2",
        "nonFungibleContract": "_0xc47244",
        "_isReadyToGiveBirth": "_0xddfc96",
        "setSecondsPerBlock": "_0x4255e5",
        "bidOnSiringAuction": "_0xf91b2a",
        "_isSiringPermitted": "_0x32f44b",
        "lastGen0SalePrices": "_0xb62f54",
        "_isValidMatingPair": "_0x6d0cfb",
        "currentPriceChange": "_0x654eed",
        "newContractAddress": "_0x90d77a",
        "isSaleClockAuction": "_0x19b3be",
        "createGen0Auction": "_0xba0de6",
        "pandaIndexToOwner": "_0xa35b09",
        "supportsInterface": "_0xd896c3",
        "transferOwnership": "_0x87c5d8",
        "candidateContract": "_0xbfacca",
        "createSaleAuction": "_0xe77f95",
        "_addAuctionERC20": "_0xd3823c",
        "gen0CreatedCount": "_0xc25220",
        "_triggerCooldown": "_0x6d5bc3",
        "cooldownEndBlock": "_0x5c4b14",
        "tokenIdToAuction": "_0xd2cf92",
        "totalPriceChange": "_0x59c2d1",
        "saleAuctionERC20": "_0x3e1e93",
        "setAutoBirthFee": "_0xca8753",
        "createWizzPanda": "_0x3c08f8",
        "withdrawBalance": "_0xf5ead4",
        "getCurrentPrice": "_0x99433b",
        "_isReadyToBreed": "_0xd21a03",
        "getPureFromGene": "_0x5f4722",
        "secondsPerBlock": "_0xb9bb78",
        "_removeAuction": "_0x3d0124",
        "_secondsPassed": "_0x797c9a",
        "wizzPandaQuota": "_0xfd10e4",
        "_startingPrice": "_0x2c416e",
        "isReadyToBreed": "_0x9ba8b0",
        "sellerProceeds": "_0x04b982",
        "_cancelAuction": "_0x9b83cc",
        "pregnantPandas": "_0x6d06de",
        "wizzPandaCount": "_0x055cb8",
        "cooldownIndex": "_0xd993db",
        "isGeneScience": "_0x3a0461",
        "secondsPassed": "_0xf7b6de",
        "auctioneerCut": "_0x96abdb",
        "approveSiring": "_0x46b546",
        "whenNotPaused": "_0x04df49",
        "startingPrice": "_0xc9080f",
        "clearWizzType": "_0x3a08fc",
        "_buyerAddress": "_0xbffa38",
        "siringAuction": "_0x23c70b",
        "setNewAddress": "_0xf1cd00",
        "breedWithAuto": "_0xd71535",
        "cancelAuction": "_0xe43d22",
        "gen0SaleCount": "_0xb07986",
        "_stringLength": "_0x9bf6ac",
        "_erc20Address": "_0x4b897b",
        "getWizzTypeOf": "_0x733b54",
        "erc20Contract": "_0x212724",
        "_erc20address": "_0xabb9f5",
        "_currentPrice": "_0x0b33b4",
        "createAuction": "_0x9bdcc7",
        "tokensOfOwner": "_0x9dbf4c",
        "surprisePanda": "_0xb26472",
        "_interfaceID": "_0x4e06d8",
        "subtractFees": "_0xd33c6f",
        "outputString": "_0x00572d",
        "siringWithId": "_0xdb4890",
        "transferFrom": "_0x23aab6",
        "_createPanda": "_0x5f3cbe",
        "_endingPrice": "_0x2fb558",
        "_approvedFor": "_0x9f7ada",
        "currentPrice": "_0x484ece",
        "autoBirthFee": "_0x3ecc6f",
        "packageCount": "_0x1dd16f",
        "_isOnAuction": "_0xecf5be",
        "canBreedWith": "_0xb089cc",
        "nextActionAt": "_0x51b1ce",
        "probability": "_0x193529",
        "targetBlock": "_0x06d311",
        "endingPrice": "_0xc2d268",
        "saleAuction": "_0x9e851a",
        "_computeCut": "_0x339e59",
        "_childGenes": "_0xe7e447",
        "geneScience": "_0xc88e88",
        "ownerTokens": "_0x70042c",
        "matronOwner": "_0x4990d9",
        "_nftAddress": "_0xd6a833",
        "_addAuction": "_0x1dfc37",
        "_generation": "_0xce7d73",
        "totalSupply": "_0xee647c",
        "newKittenId": "_0xb3c304",
        "getMetadata": "_0x6bffb3",
        "createPanda": "_0x18bf09",
        "resultIndex": "_0x5f46cb",
        "isGestating": "_0x18f41c",
        "getWizzType": "_0x30fc22",
        "newContract": "_0x07ce93",
        "cooAddress": "_0xd84fc8",
        "ceoAddress": "_0x056adb",
        "generation": "_0xcb4be8",
        "_bidAmount": "_0xc42a3f",
        "onlyCLevel": "_0xcfa2eb",
        "isPregnant": "_0x7ccc7a",
        "_v2Address": "_0x4153ae",
        "pandaOwner": "_0x30c421",
        "nftAddress": "_0x93952e",
        "tokenCount": "_0x0f2760",
        "whenPaused": "_0x53d1a2",
        "childOwner": "_0xf51b9e",
        "_breedWith": "_0x355b02",
        "childGenes": "_0xbfab44",
        "pureDegree": "_0x649194",
        "_allowance": "_0x08b60a",
        "getAuction": "_0x7cae85",
        "cfoAddress": "_0xdf7871",
        "totalPrice": "_0xcbf674",
        "balanceOf": "_0xb62dae",
        "bidExcess": "_0x6e5419",
        "_matronId": "_0x27eecf",
        "keccak256": "_0x2a9820",
        "startedAt": "_0x1128b2",
        "_duration": "_0x4bffd2",
        "_approved": "_0xeb3284",
        "_toString": "_0x9cc9c6",
        "birthTime": "_0x14d428",
        "_transfer": "_0x5e6963",
        "parentGen": "_0x4e0a0d",
        "sireOwner": "_0x02a7c4",
        "onlyOwner": "_0x017abd",
        "_rawBytes": "_0x7c4986",
        "outputPtr": "_0x5c4738",
        "_receiver": "_0x415ddd",
        "giveBirth": "_0xa0fe83",
        "nextPrice": "_0xa871aa",
        "cooldowns": "_0xcd20be",
        "totalCats": "_0x3f99b8",
        "_bidERC20": "_0x76e4c1",
        "_claimant": "_0xf07313",
        "allowance": "_0x7588da",
        "matronId": "_0xcaa582",
        "getPanda": "_0xb7a553",
        "_tokenId": "_0x9437a0",
        "approved": "_0xb3c5b9",
        "destpart": "_0x4642a4",
        "_pandaId": "_0x7e84fb",
        "bytesPtr": "_0x81ff11",
        "_factors": "_0xb495b6",
        "mixGenes": "_0xbb871a",
        "_nftAddr": "_0x058446",
        "surprise": "_0xa213f5",
        "_auction": "_0x2897d5",
        "duration": "_0xcfcedd",
        "newOwner": "_0x98e0ca",
        "kittenId": "_0x7f537b",
        "avePrice": "_0xdd6371",
        "bidERC20": "_0xc2d832",
        "balances": "_0x85b4a9",
        "_approve": "_0xd82f3d",
        "ownerCut": "_0x231b95",
        "_address": "_0xf2098b",
        "_amount": "_0xad0126",
        "_kitten": "_0x3e14fd",
        "onlyCEO": "_0x60b274",
        "approve": "_0x2c3379",
        "pandaId": "_0xe91074",
        "tokenId": "_0x718a9a",
        "_newCEO": "_0x389caa",
        "_memcpy": "_0xa8c8fa",
        "_escrow": "_0x2a5046",
        "_newCFO": "_0xbbfea1",
        "_seller": "_0x40303d",
        "unpause": "_0xd59e82",
        "_matron": "_0x468abf",
        "_newCOO": "_0xe82f6d",
        "srcpart": "_0x4117ec",
        "_sireId": "_0x9027a1",
        "onlyCFO": "_0xd4d0ef",
        "onlyCOO": "_0x864e74",
        "ownerOf": "_0xc2f09b",
        "auction": "_0xfaedc0",
        "spender": "_0x9c80df",
        "isReady": "_0xc176bb",
        "_genes": "_0xd14de0",
        "seller": "_0x80bd9c",
        "supply": "_0xe91321",
        "common": "_0x7efa86",
        "matron": "_0x94f0ad",
        "paused": "_0x86dc0a",
        "pandas": "_0xde19c2",
        "_onoff": "_0x6017ad",
        "isGen0": "_0x45140e",
        "setCEO": "_0x153e41",
        "_panda": "_0x8eee79",
        "setCOO": "_0xc0041f",
        "genes1": "_0xbb3ff5",
        "result": "_0xcd5d92",
        "setCFO": "_0xce088c",
        "_price": "_0x3a3c1b",
        "sireId": "_0x9a6a79",
        "getSex": "_0x31654d",
        "symbol": "_0x5f646f",
        "_total": "_0xc735fc",
        "genes2": "_0xc0b7ec",
        "buffer": "_0x229848",
        "winner": "_0xba6695",
        "_owner": "_0xb0e749",
        "catId": "_0x0d4969",
        "_dest": "_0xad86ce",
        "bHash": "_0x41ee68",
        "_type": "_0x0df092",
        "_sire": "_0x37bebf",
        "price": "_0x34b70c",
        "pause": "_0x23403d",
        "_addr": "_0xe32f7d",
        "_gene": "_0xede1e3",
        "_owns": "_0x65e38c",
        "owner": "_0xcb5efa",
        "count": "_0xe68344",
        "total": "_0xe60324",
        "genes": "_0xd7149e",
        "_from": "_0x31fe9e",
        "gene": "_0xaad9e0",
        "name": "_0xa050c9",
        "secs": "_0x2b4358",
        "_len": "_0x7ee558",
        "_bid": "_0x8ec3d7",
        "_src": "_0x505b2f",
        "_cut": "_0xc8b9db",
        "init": "_0xedb3eb",
        "sire": "_0xc4769c",
        "_kit": "_0x27a589",
        "mask": "_0x44052c",
        "_id": "_0xfa9287",
        "who": "_0xcc5e75",
        "_tp": "_0xccdfde",
        "val": "_0x703b13",
        "sum": "_0xfd6cae",
        "kit": "_0x3cca96",
        "bid": "_0x3cee2c",
        "now": "_0xddf414",
        "res": "_0x11e1bc",
        "_to": "_0x64cd68",
        "ok": "_0x31c25b",
        "g1": "_0xb756a9",
        "to": "_0x70f7f1",
        "g2": "_0xac54c9",
        "_p": "_0x2291bb"
      },
      "changes": [
        "Renamed 272 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_215",
      "transformed_id": "ss_l3_medium_sn_ds_215",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier _0x1ad0f9()\n    {\n        require(msg.sender == _0x271408);\n        _;\n    }\n\n   modifier _0x7fffab()\n    {\n        require(_0xc560a2);\n        _;\n    }\n\n    modifier _0x5bf969()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  _0xdd70ae()\n    {\n        require (_0x9ce95b[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 _0x623937, address _0x16a8c9);\n    event Win(uint256 _0x623937, address _0x63faa7);\n    event Lose(uint256 _0x623937, address _0x8888b6);\n    event Donate(uint256 _0x623937, address _0x63faa7, address _0xd481a1);\n    event DifficultyChanged(uint256 _0x1e9aba);\n    event BetLimitChanged(uint256 _0x4def14);\n\n    address private _0x83158d;\n    uint256 _0x186441;\n    uint difficulty;\n    uint private _0xa4e291;\n    address _0x271408;\n    mapping(address => uint256) _0x35b225;\n    mapping(address => uint256) _0x9ce95b;\n    bool _0xc560a2;\n    uint256 _0x9afdab;\n\n    constructor(address _0x174ed8, uint256 _0x4fa959)\n    _0x5bf969()\n    public\n    {\n        _0xc560a2 = false;\n        _0x271408 = msg.sender;\n        _0x83158d = _0x174ed8;\n        _0x9afdab = 0;\n        _0x186441 = _0x4fa959;\n\n    }\n\n    function OpenToThePublic()\n    _0x1ad0f9()\n    public\n    {\n        _0xc560a2 = true;\n    }\n\n    function AdjustBetAmounts(uint256 _0x623937)\n    _0x1ad0f9()\n    public\n    {\n        _0x186441 = _0x623937;\n\n        emit BetLimitChanged(_0x186441);\n    }\n\n    function AdjustDifficulty(uint256 _0x623937)\n    _0x1ad0f9()\n    public\n    {\n        difficulty = _0x623937;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function _0xac1e86()\n    _0x7fffab()\n    _0x5bf969()\n    payable\n    public\n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == _0x186441);\n\n        //log the wager and timestamp(block number)\n        _0x35b225[msg.sender] = block.number;\n        _0x9ce95b[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function _0x559043()\n    _0x7fffab()\n    _0x5bf969()\n    _0xdd70ae()\n    public\n    {\n        uint256 _0xbac8a7 = _0x35b225[msg.sender];\n        if(_0xbac8a7 < block.number)\n        {\n            _0x35b225[msg.sender] = 0;\n            _0x9ce95b[msg.sender] = 0;\n\n            uint256 _0xf1bea0 = uint256(_0x78b5fc(abi._0xbb6933(blockhash(_0xbac8a7),  msg.sender)))%difficulty +1;\n\n            if(_0xf1bea0 == difficulty / 2)\n            {\n                _0x983bc5(msg.sender);\n            }\n            else\n            {\n                //player loses\n                _0x1c4422(_0x186441 / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function _0xfc0c5f()\n    _0x7fffab()\n    public\n    payable\n    {\n        _0x3f1b25(msg.value);\n    }\n\n    function _0x983bc5(address _0x282822)\n    internal\n    {\n        uint256 _0x4715d8 = address(this).balance / 2;\n\n        _0x282822.transfer(_0x4715d8);\n        emit Win(_0x4715d8, _0x282822);\n    }\n\n    function _0x3f1b25(uint256 _0x623937)\n    internal\n    {\n        _0x83158d.call.value(_0x623937)(bytes4(_0x78b5fc(\"donate()\")));\n        _0x9afdab += _0x623937;\n        emit Donate(_0x623937, _0x83158d, msg.sender);\n    }\n\n    function _0x1c4422(uint256 _0x623937)\n    internal\n    {\n        _0x83158d.call.value(_0x623937)(bytes4(_0x78b5fc(\"donate()\")));\n        _0x9afdab += _0x623937;\n        emit Lose(_0x623937, msg.sender);\n    }\n\n    function _0x8e5870()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function _0x1e9aba()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function _0x4def14()\n    public\n    view\n    returns (uint256)\n    {\n        return _0x186441;\n    }\n\n    function _0x538475(address _0x559a1e)\n    public\n    view\n    returns (bool)\n    {\n        if(_0x9ce95b[_0x559a1e] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function _0x409a83()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function _0x3c174c(address _0x8826d3, address _0x9f74e3, uint _0x52edb3)\n    public\n    _0x1ad0f9()\n    returns (bool _0xcdb899)\n    {\n        return ERC20Interface(_0x8826d3).transfer(_0x9f74e3, _0x52edb3);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface\n{\n    function transfer(address _0x6c0d64, uint256 _0x52edb3) public returns (bool _0xcdb899);\n}",
      "rename_map": {
        "transferAnyERC20Token": "_0x3c174c",
        "currentDifficulty": "_0x1e9aba",
        "hasPlayerWagered": "_0x538475",
        "currentBetLimit": "_0x4def14",
        "isOpenToPublic": "_0x7fffab",
        "onlyRealPeople": "_0x5bf969",
        "donateToWhale": "_0x3f1b25",
        "winningNumber": "_0xf1bea0",
        "ethToTransfer": "_0x4715d8",
        "whaleAddress": "_0x174ed8",
        "tokenAddress": "_0x8826d3",
        "totalDonated": "_0x9afdab",
        "encodePacked": "_0xbb6933",
        "openToPublic": "_0xc560a2",
        "onlyPlayers": "_0xdd70ae",
        "blockNumber": "_0xbac8a7",
        "randomSeed": "_0xa4e291",
        "winnersPot": "_0x409a83",
        "tokenOwner": "_0x9f74e3",
        "ethBalance": "_0x8e5870",
        "wagerLimit": "_0x4fa959",
        "timestamps": "_0x35b225",
        "onlyOwner": "_0x1ad0f9",
        "depositer": "_0x16a8c9",
        "keccak256": "_0x78b5fc",
        "loseWager": "_0x1c4422",
        "betLimit": "_0x186441",
        "donator": "_0xd481a1",
        "success": "_0xcdb899",
        "tokens": "_0x52edb3",
        "paidTo": "_0x63faa7",
        "player": "_0x559a1e",
        "amount": "_0x623937",
        "donate": "_0xfc0c5f",
        "payout": "_0x983bc5",
        "wagers": "_0x9ce95b",
        "winner": "_0x282822",
        "whale": "_0x83158d",
        "loser": "_0x8888b6",
        "owner": "_0x271408",
        "wager": "_0xac1e86",
        "play": "_0x559043",
        "to": "_0x6c0d64"
      },
      "changes": [
        "Renamed 43 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_216",
      "transformed_id": "ss_l3_medium_sn_ds_216",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract FiftyFlip {\n    uint constant DONATING_X = 20; // 2% kujira\n\n    // Need to be discussed\n    uint constant JACKPOT_FEE = 10; // 1% jackpot\n    uint constant JACKPOT_MODULO = 1000; // 0.1% jackpotwin\n    uint constant DEV_FEE = 20; // 2% devfee\n    uint constant WIN_X = 1900; // 1.9x\n\n    // There is minimum and maximum bets.\n    uint constant MIN_BET = 0.01 ether;\n    uint constant MAX_BET = 1 ether;\n\n    uint constant BET_EXPIRATION_BLOCKS = 250;\n\n    // owner and PoC contract address\n    address public _0xd0d20a;\n    address public _0x21d36e;\n    address public _0xfa3e82;\n    address private _0x3b4a70;\n\n    // Accumulated jackpot fund.\n    uint256 public _0x576696;\n    uint256 public _0x9403fb;\n\n    // Funds that are locked in potentially winning bets.\n    uint256 public _0x9a96ca;\n    uint256 public _0xc0b9ed;\n\n    struct Bet {\n        // Wager amount in wei.\n        uint _0x43082a;\n        // Block number of placeBet tx.\n        uint256 _0xc781fa;\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\n        bool _0x979b59;\n        // Address of a player, used to pay out winning bets.\n        address _0x04f417;\n    }\n\n    mapping (uint => Bet) _0xb1101c;\n    mapping (address => uint) _0x8e7e47;\n\n    // events\n    event Wager(uint _0x1226fd, uint _0x4e0894, uint256 _0xabc80b, bool _0x979b59, address _0xeab177);\n    event Win(address _0x956aa6, uint _0x43082a, uint _0x1226fd, bool _0xc236c5, uint _0x27d73c);\n    event Lose(address _0x6659ff, uint _0x43082a, uint _0x1226fd, bool _0xc236c5, uint _0x27d73c);\n    event Refund(uint _0x1226fd, uint256 _0x43082a, address _0x567306);\n    event Donate(uint256 _0x43082a, address _0xb5a8b1);\n    event FailedPayment(address _0x4c269f, uint _0x43082a);\n    event Payment(address _0xe50a94, uint _0x43082a);\n    event JackpotPayment(address _0x04f417, uint _0x1226fd, uint _0x8cfa3d);\n\n    // constructor\n    constructor (address _0x510915, address _0xf71845, address _0x695e57) public {\n        _0xd0d20a = msg.sender;\n        _0x21d36e = _0xf71845;\n        if (gasleft() > 0) { _0x3b4a70 = _0x510915; }\n        _0xfa3e82 = _0x695e57;\n        _0x576696 = 0;\n        _0x9403fb = 0;\n        _0x9a96ca = 0;\n        _0xc0b9ed = 0;\n    }\n\n    // modifiers\n    modifier _0xbc4f00() {\n        require (msg.sender == _0xd0d20a, \"You are not the owner of this contract!\");\n        _;\n    }\n\n    modifier _0xdd65fd() {\n        require (msg.sender == _0x21d36e, \"You are not the bot of this contract!\");\n        _;\n    }\n\n    modifier _0x80db11() {\n        require (address(this).balance >= _0x9a96ca + _0x576696 + _0x9403fb, \"This contract doesn't have enough balance, it is stopped till someone donate to this game!\");\n        _;\n    }\n\n    // betMast:\n    // false is front, true is back\n\n    function() public payable { }\n\n    function _0xf0168c(address _0xf71845)\n    _0xbc4f00()\n    external\n    {\n        _0x21d36e = _0xf71845;\n    }\n\n    function _0x2e021a(address _0x543901)\n    _0xbc4f00()\n    external\n    {\n        _0xfa3e82 = _0x543901;\n    }\n\n    // wager function\n    function _0x34bd9e(bool _0xc742c4, uint _0x1226fd, uint _0x485788, uint8 v, bytes32 r, bytes32 s)\n    _0x80db11()\n    external\n    payable {\n        Bet storage _0x469f31 = _0xb1101c[_0x1226fd];\n        uint _0x43082a = msg.value;\n        address _0x04f417 = msg.sender;\n        require (_0x469f31._0x04f417 == address(0), \"Ticket is not new one!\");\n        require (_0x43082a >= MIN_BET, \"Your bet is lower than minimum bet amount\");\n        require (_0x43082a <= MAX_BET, \"Your bet is higher than maximum bet amount\");\n        require (_0x06ab22() >= 2 * _0x43082a, \"If we accept this, this contract will be in danger!\");\n\n        require (block.number <= _0x485788, \"Ticket has expired.\");\n        bytes32 _0x29ae2f = _0x54bf8f(abi._0x7c28da('\\x19Ethereum Signed Message:\\n37', uint40(_0x485788), _0x1226fd));\n        require (_0xfa3e82 == _0x78330c(_0x29ae2f, v, r, s), \"web3 vrs signature is not valid.\");\n\n        _0x576696 += _0x43082a * JACKPOT_FEE / 1000;\n        _0x9403fb += _0x43082a * DEV_FEE / 1000;\n        _0x9a96ca += _0x43082a * WIN_X / 1000;\n\n        uint _0xbeee50 = _0x43082a * DONATING_X / 1000;\n        _0x3b4a70.call.value(_0xbeee50)(bytes4(_0x54bf8f(\"donate()\")));\n        _0xc0b9ed += _0xbeee50;\n\n        _0x469f31._0x43082a = _0x43082a;\n        _0x469f31._0xc781fa = block.number;\n        _0x469f31._0x979b59 = _0xc742c4;\n        _0x469f31._0x04f417 = _0x04f417;\n\n        emit Wager(_0x1226fd, _0x469f31._0x43082a, _0x469f31._0xc781fa, _0x469f31._0x979b59, _0x469f31._0x04f417);\n    }\n\n    // method to determine winners and losers\n    function _0x906b87(uint _0x924eac)\n    _0x80db11()\n    external\n    {\n        uint _0x1226fd = uint(_0x54bf8f(abi._0x7c28da(_0x924eac)));\n        Bet storage _0x469f31 = _0xb1101c[_0x1226fd];\n        require (_0x469f31._0x04f417 != address(0), \"TicketID is not correct!\");\n        require (_0x469f31._0x43082a != 0, \"Ticket is already used one!\");\n        uint256 _0xc781fa = _0x469f31._0xc781fa;\n        if(_0xc781fa < block.number && _0xc781fa >= block.number - BET_EXPIRATION_BLOCKS)\n        {\n            uint256 _0xe5dcab = uint256(_0x54bf8f(abi._0x7c28da(blockhash(_0xc781fa),  _0x924eac)));\n            bool _0xc236c5 = (_0xe5dcab % 2) !=0;\n            uint _0x27d73c = _0xe5dcab % JACKPOT_MODULO;\n\n            uint _0xa4b621 = _0x469f31._0x43082a * WIN_X / 1000;\n\n            uint _0x42aa54 = 0;\n            uint _0x8cfa3d = 0;\n\n            if(_0x469f31._0x979b59 == _0xc236c5) {\n                _0x42aa54 = _0xa4b621;\n            }\n            if(_0x27d73c == 0) {\n                _0x8cfa3d = _0x576696;\n                _0x576696 = 0;\n            }\n            if (_0x8cfa3d > 0) {\n                emit JackpotPayment(_0x469f31._0x04f417, _0x1226fd, _0x8cfa3d);\n            }\n            if(_0x42aa54 + _0x8cfa3d > 0)\n            {\n                _0x87d5d1(_0x469f31._0x04f417, _0x42aa54 + _0x8cfa3d, _0x1226fd, _0xc236c5, _0x27d73c);\n            }\n            else\n            {\n                _0x0cb204(_0x469f31._0x04f417, _0x469f31._0x43082a, _0x1226fd, _0xc236c5, _0x27d73c);\n            }\n            _0x9a96ca -= _0xa4b621;\n            _0x469f31._0x43082a = 0;\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function _0xe07afd()\n    external\n    payable\n    {\n        _0x8e7e47[msg.sender] += msg.value;\n        emit Donate(msg.value, msg.sender);\n    }\n\n    function _0x176f6f(uint _0x43082a)\n    external\n    {\n        require(_0x8e7e47[msg.sender] >= _0x43082a, \"You are going to withdraw more than you donated!\");\n\n        if (_0x5b1aeb(msg.sender, _0x43082a)){\n            _0x8e7e47[msg.sender] -= _0x43082a;\n        }\n    }\n\n    // method to refund\n    function _0x87cfe4(uint _0x1226fd)\n    _0x80db11()\n    external {\n        Bet storage _0x469f31 = _0xb1101c[_0x1226fd];\n\n        require (_0x469f31._0x43082a != 0, \"this ticket has no balance\");\n        require (block.number > _0x469f31._0xc781fa + BET_EXPIRATION_BLOCKS, \"this ticket is expired.\");\n        _0xf60805(_0x1226fd);\n    }\n\n    // Funds withdrawl\n    function _0x64880c(address _0x772615, uint _0x5aa1b9)\n    _0xbc4f00()\n    _0x80db11()\n    external {\n        require (_0x9403fb >= _0x5aa1b9, \"You are trying to withdraw more amount than developer fee.\");\n        require (_0x5aa1b9 <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (_0x9403fb <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (_0x5b1aeb(_0x772615, _0x5aa1b9)){\n            _0x9403fb -= _0x5aa1b9;\n        }\n    }\n\n    // Funds withdrawl\n    function _0x45a63e(uint _0x5aa1b9)\n    _0xdd65fd()\n    _0x80db11()\n    external {\n        require (_0x9403fb >= _0x5aa1b9, \"You are trying to withdraw more amount than developer fee.\");\n        require (_0x5aa1b9 <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (_0x9403fb <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (_0x5b1aeb(_0x21d36e, _0x5aa1b9)){\n            _0x9403fb -= _0x5aa1b9;\n        }\n    }\n\n    // Get Bet Info from id\n    function _0x288d2c(uint _0x1226fd)\n    constant\n    external\n    returns (uint, uint256, bool, address){\n        Bet storage _0x469f31 = _0xb1101c[_0x1226fd];\n        return (_0x469f31._0x43082a, _0x469f31._0xc781fa, _0x469f31._0x979b59, _0x469f31._0x04f417);\n    }\n\n    // Get Bet Info from id\n    function _0xddf88b()\n    constant\n    external\n    returns (uint){\n        return address(this).balance;\n    }\n\n    // Get Collateral for Bet\n    function _0x06ab22()\n    constant\n    public\n    returns (uint){\n        if (address(this).balance > _0x9a96ca + _0x576696 + _0x9403fb)\n            return address(this).balance - _0x9a96ca - _0x576696 - _0x9403fb;\n        return 0;\n    }\n\n    // Contract may be destroyed only when there are no ongoing bets,\n    // either settled or refunded. All funds are transferred to contract owner.\n    function _0x6a4143() external _0xbc4f00() {\n        require (_0x9a96ca == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n        selfdestruct(_0xd0d20a);\n    }\n\n    // Payout ETH to winner\n    function _0x87d5d1(address _0x956aa6, uint _0x5d750a, uint _0x1226fd, bool _0xc236c5, uint _0x27d73c)\n    internal\n    {\n        _0x956aa6.transfer(_0x5d750a);\n        emit Win(_0x956aa6, _0x5d750a, _0x1226fd, _0xc236c5, _0x27d73c);\n    }\n\n    // sendRefund to requester\n    function _0xf60805(uint _0x1226fd)\n    internal\n    {\n        Bet storage _0x469f31 = _0xb1101c[_0x1226fd];\n        address _0x567306 = _0x469f31._0x04f417;\n        uint256 _0x5d750a = _0x469f31._0x43082a;\n        _0x567306.transfer(_0x5d750a);\n\n        uint _0xa4b621 = _0x469f31._0x43082a * WIN_X / 1000;\n        _0x9a96ca -= _0xa4b621;\n\n        _0x469f31._0x43082a = 0;\n        emit Refund(_0x1226fd, _0x5d750a, _0x567306);\n    }\n\n    // Helper routine to process the payment.\n    function _0x5b1aeb(address _0x4c269f, uint _0x43082a) private returns (bool){\n        bool _0x04c5a4 = _0x4c269f.send(_0x43082a);\n        if (_0x04c5a4) {\n            emit Payment(_0x4c269f, _0x43082a);\n        } else {\n            emit FailedPayment(_0x4c269f, _0x43082a);\n        }\n        return _0x04c5a4;\n    }\n    // Payout ETH to whale when player loses\n    function _0x0cb204(address _0x04f417, uint _0x43082a, uint _0x1226fd, bool _0xc236c5, uint _0x27d73c)\n    internal\n    {\n        emit Lose(_0x04f417, _0x43082a, _0x1226fd, _0xc236c5, _0x27d73c);\n    }\n\n    // bulk clean the storage.\n    function _0x6da697(uint[] _0xa097cd) external {\n        uint length = _0xa097cd.length;\n\n        for (uint i = 0; i < length; i++) {\n            _0x13e564(_0xa097cd[i]);\n        }\n    }\n\n    // Helper routine to move 'processed' bets into 'clean' state.\n    function _0x13e564(uint _0x1226fd) private {\n        Bet storage _0x469f31 = _0xb1101c[_0x1226fd];\n\n        // Do not overwrite active bets with zeros; additionally prevent cleanup of bets\n        // for which ticketID signatures may have not expired yet (see whitepaper for details).\n        if (_0x469f31._0x43082a != 0 || block.number <= _0x469f31._0xc781fa + BET_EXPIRATION_BLOCKS) {\n            return;\n        }\n\n        _0x469f31._0xc781fa = 0;\n        _0x469f31._0x979b59 = false;\n        _0x469f31._0x04f417 = address(0);\n    }\n\n    // A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n    function _0xc52485(address _0x1b229c, address _0xc19bcb, uint _0xcf27d1)\n    public\n    _0xbc4f00()\n    returns (bool _0x04c5a4)\n    {\n        return ERC20Interface(_0x1b229c).transfer(_0xc19bcb, _0xcf27d1);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface\n{\n    function transfer(address _0xf34416, uint256 _0xcf27d1) public returns (bool _0x04c5a4);\n}\n",
      "rename_map": {
        "donateForContractHealth": "_0xe07afd",
        "transferAnyERC20Token": "_0xc52485",
        "getCollateralBalance": "_0x06ab22",
        "secretSignerAddress": "_0x695e57",
        "checkContractHealth": "_0x80db11",
        "autoPlayBotAddress": "_0xf71845",
        "getContractBalance": "_0xddf88b",
        "totalAmountToWhale": "_0xc0b9ed",
        "clearProcessedBet": "_0x13e564",
        "withdrawDonation": "_0x176f6f",
        "toCleanTicketIDs": "_0xa097cd",
        "setSecretSigner": "_0x2e021a",
        "ticketLastBlock": "_0x485788",
        "withdrawAddress": "_0x772615",
        "withdrawAmount": "_0x5aa1b9",
        "withdrawDevFee": "_0x64880c",
        "betBlockNumber": "_0xabc80b",
        "withdrawBotFee": "_0x45a63e",
        "setBotAddress": "_0xf0168c",
        "tossWinAmount": "_0xa4b621",
        "signatureHash": "_0x29ae2f",
        "donate_amount": "_0xbeee50",
        "ethToTransfer": "_0x5d750a",
        "_secretSigner": "_0x543901",
        "secretSigner": "_0xfa3e82",
        "ticketReveal": "_0x924eac",
        "whaleAddress": "_0x510915",
        "lockedInBets": "_0x9a96ca",
        "tokenAddress": "_0x1b229c",
        "clearStorage": "_0x6da697",
        "donateAmount": "_0x8e7e47",
        "encodePacked": "_0x7c28da",
        "jackpotSize": "_0x576696",
        "autoPlayBot": "_0x21d36e",
        "blockNumber": "_0xc781fa",
        "jackpotWin": "_0x8cfa3d",
        "getBetInfo": "_0x288d2c",
        "tokenOwner": "_0xc19bcb",
        "noPaidUser": "_0xe50a94",
        "sendRefund": "_0xf60805",
        "devFeeSize": "_0x9403fb",
        "jackpotRes": "_0x27d73c",
        "ecrecover": "_0x78330c",
        "sendFunds": "_0x5b1aeb",
        "betPlayer": "_0xeab177",
        "onlyOwner": "_0xbc4f00",
        "keccak256": "_0x54bf8f",
        "requester": "_0x567306",
        "betAmount": "_0x4e0894",
        "loseWager": "_0x0cb204",
        "paidUser": "_0x4c269f",
        "ticketID": "_0x1226fd",
        "donator": "_0xb5a8b1",
        "tossWin": "_0x42aa54",
        "success": "_0x04c5a4",
        "onlyBot": "_0xdd65fd",
        "betMask": "_0x979b59",
        "maskRes": "_0xc236c5",
        "tokens": "_0xcf27d1",
        "random": "_0xe5dcab",
        "player": "_0x04f417",
        "amount": "_0x43082a",
        "payout": "_0x87d5d1",
        "refund": "_0x87cfe4",
        "winner": "_0x956aa6",
        "whale": "_0x3b4a70",
        "bMask": "_0xc742c4",
        "loser": "_0x6659ff",
        "owner": "_0xd0d20a",
        "wager": "_0x34bd9e",
        "play": "_0x906b87",
        "kill": "_0x6a4143",
        "bets": "_0xb1101c",
        "bet": "_0x469f31",
        "to": "_0xf34416"
      },
      "changes": [
        "Renamed 75 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_232",
      "transformed_id": "ss_l3_medium_sn_ds_232",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\nlibrary SafeMath {\n  function _0xc094db(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n\n  function _0x06b43d(uint256 a, uint256 b) internal constant returns (uint256) {\n    // require(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function _0x904db4(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function _0xaf2075(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint256 public _0x63fc50;\n  function _0xb0163c(address _0x1f6707) public constant returns (uint256);\n  function transfer(address _0x5131a4, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed _0x5131a4, uint256 value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) _0x772e32;\n\n  function transfer(address _0x846034, uint256 _0xaaf99f) public returns (bool) {\n    require(_0x846034 != address(0));\n    require(_0xaaf99f > 0 && _0xaaf99f <= _0x772e32[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    _0x772e32[msg.sender] = _0x772e32[msg.sender]._0x904db4(_0xaaf99f);\n    _0x772e32[_0x846034] = _0x772e32[_0x846034]._0xaf2075(_0xaaf99f);\n    Transfer(msg.sender, _0x846034, _0xaaf99f);\n    return true;\n  }\n\n  function _0xb0163c(address _0xe3d294) public constant returns (uint256 balance) {\n    return _0x772e32[_0xe3d294];\n  }\n}\n\ncontract ERC20 is ERC20Basic {\n  function _0xcb9dea(address _0xd60292, address _0x2f47b5) public constant returns (uint256);\n  function _0x13168e(address from, address _0x5131a4, uint256 value) public returns (bool);\n  function _0x5a00f0(address _0x2f47b5, uint256 value) public returns (bool);\n  event Approval(address indexed _0xd60292, address indexed _0x2f47b5, uint256 value);\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal _0x8b6fc6;\n\n  function _0x13168e(address _0x6f079b, address _0x846034, uint256 _0xaaf99f) public returns (bool) {\n    require(_0x846034 != address(0));\n    require(_0xaaf99f > 0 && _0xaaf99f <= _0x772e32[_0x6f079b]);\n    require(_0xaaf99f <= _0x8b6fc6[_0x6f079b][msg.sender]);\n\n    _0x772e32[_0x6f079b] = _0x772e32[_0x6f079b]._0x904db4(_0xaaf99f);\n    _0x772e32[_0x846034] = _0x772e32[_0x846034]._0xaf2075(_0xaaf99f);\n    _0x8b6fc6[_0x6f079b][msg.sender] = _0x8b6fc6[_0x6f079b][msg.sender]._0x904db4(_0xaaf99f);\n    Transfer(_0x6f079b, _0x846034, _0xaaf99f);\n    return true;\n  }\n\n  function _0x5a00f0(address _0x5b1e5e, uint256 _0xaaf99f) public returns (bool) {\n    _0x8b6fc6[msg.sender][_0x5b1e5e] = _0xaaf99f;\n    Approval(msg.sender, _0x5b1e5e, _0xaaf99f);\n    return true;\n  }\n\n  function _0xcb9dea(address _0xe3d294, address _0x5b1e5e) public constant returns (uint256 _0x6d3b6d) {\n    return _0x8b6fc6[_0xe3d294][_0x5b1e5e];\n  }\n}\n\ncontract Ownable {\n  address public _0xd60292;\n\n  event OwnershipTransferred(address indexed _0x1db2fe, address indexed _0x5281de);\n\n  function Ownable() {\n    _0xd60292 = msg.sender;\n  }\n\n  modifier _0x4e2b3e() {\n    require(msg.sender == _0xd60292);\n    _;\n  }\n\n  function _0x8f3cbf(address _0x5281de) _0x4e2b3e public {\n    require(_0x5281de != address(0));\n    OwnershipTransferred(_0xd60292, _0x5281de);\n    if (gasleft() > 0) { _0xd60292 = _0x5281de; }\n  }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public _0xef940a = false;\n\n  modifier _0x5c382b() {\n    require(!_0xef940a);\n    _;\n  }\n\n  modifier _0xf5aa5b() {\n    require(_0xef940a);\n    _;\n  }\n\n  function _0xed3fa8() _0x4e2b3e _0x5c382b public {\n    if (block.timestamp > 0) { _0xef940a = true; }\n    Pause();\n  }\n\n  function _0x1df195() _0x4e2b3e _0xf5aa5b public {\n    _0xef940a = false;\n    Unpause();\n  }\n}\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _0x846034, uint256 _0xaaf99f) public _0x5c382b returns (bool) {\n    return super.transfer(_0x846034, _0xaaf99f);\n  }\n\n  function _0x13168e(address _0x6f079b, address _0x846034, uint256 _0xaaf99f) public _0x5c382b returns (bool) {\n    return super._0x13168e(_0x6f079b, _0x846034, _0xaaf99f);\n  }\n\n  function _0x5a00f0(address _0x5b1e5e, uint256 _0xaaf99f) public _0x5c382b returns (bool) {\n    return super._0x5a00f0(_0x5b1e5e, _0xaaf99f);\n  }\n\n  function _0x63d142(address[] _0xbc7a0f, uint256 _0xaaf99f) public _0x5c382b returns (bool) {\n    uint _0xfd5768 = _0xbc7a0f.length;\n    uint256 _0xa9f7d0 = uint256(_0xfd5768) * _0xaaf99f;\n    require(_0xfd5768 > 0 && _0xfd5768 <= 20);\n    require(_0xaaf99f > 0 && _0x772e32[msg.sender] >= _0xa9f7d0);\n\n    _0x772e32[msg.sender] = _0x772e32[msg.sender]._0x904db4(_0xa9f7d0);\n    for (uint i = 0; i < _0xfd5768; i++) {\n        _0x772e32[_0xbc7a0f[i]] = _0x772e32[_0xbc7a0f[i]]._0xaf2075(_0xaaf99f);\n        Transfer(msg.sender, _0xbc7a0f[i], _0xaaf99f);\n    }\n    return true;\n  }\n}\n\ncontract BecToken is PausableToken {\n    string public _0x1f44fe = \"BeautyChain\";\n    string public _0x290202 = \"BEC\";\n    string public _0xd70edf = '1.0.0';\n    uint8 public _0x8eea87 = 18;\n\n    function BecToken() {\n      _0x63fc50 = 7000000000 * (10**(uint256(_0x8eea87)));\n      _0x772e32[msg.sender] = _0x63fc50;    // Give the creator all initial tokens\n    }\n\n    function () {\n        //if ether is sent to this address, send it back.\n        revert();\n    }\n}\n",
      "rename_map": {
        "transferOwnership": "_0x8f3cbf",
        "batchTransfer": "_0x63d142",
        "whenNotPaused": "_0x5c382b",
        "previousOwner": "_0x1db2fe",
        "transferFrom": "_0x13168e",
        "totalSupply": "_0x63fc50",
        "whenPaused": "_0xf5aa5b",
        "_receivers": "_0xbc7a0f",
        "balanceOf": "_0xb0163c",
        "onlyOwner": "_0x4e2b3e",
        "remaining": "_0x6d3b6d",
        "allowance": "_0xcb9dea",
        "_spender": "_0x5b1e5e",
        "newOwner": "_0x5281de",
        "balances": "_0x772e32",
        "decimals": "_0x8eea87",
        "spender": "_0x2f47b5",
        "approve": "_0x5a00f0",
        "version": "_0xd70edf",
        "allowed": "_0x8b6fc6",
        "unpause": "_0x1df195",
        "_value": "_0xaaf99f",
        "amount": "_0xa9f7d0",
        "paused": "_0xef940a",
        "_owner": "_0xe3d294",
        "symbol": "_0x290202",
        "owner": "_0xd60292",
        "pause": "_0xed3fa8",
        "_from": "_0x6f079b",
        "name": "_0x1f44fe",
        "add": "_0xaf2075",
        "cnt": "_0xfd5768",
        "who": "_0x1f6707",
        "div": "_0x06b43d",
        "sub": "_0x904db4",
        "_to": "_0x846034",
        "mul": "_0xc094db",
        "to": "_0x5131a4"
      },
      "changes": [
        "Renamed 38 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_233",
      "transformed_id": "ss_l3_medium_sn_ds_233",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.9_0x649862library Deck {\n\t// returns random number from 0 to 51\n\t// let's say 'value' % 4 means suit (0 - Hearts, 1 - Spades, 2 - Diamonds, 3 - Clubs)\n\t//\t\t\t 'value' / 4 means: 0 - King, 1 - Ace, 2 - 10 - pip values, 11 - Jacket, 12 - Queen\n\n\tfunction _0xf9d8b6(address _0xb56353, uint8 _0xfddb59) internal returns (uint8) {\n\t\tuint b = block.number;\n\t\tuint timestamp = block.timestamp;\n\t\treturn uint8(uint256(_0x54da02(block.blockhash(b), _0xb56353, _0xfddb59, timestamp)) % 52);\n\t}\n\n\tfunction _0xcdd354(uint8 _0xb7f20f, bool _0x518bb8) internal constant returns (uint8) {\n\t\tuint8 value = _0xb7f20f / 4;\n\t\tif (value == 0 || value == 11 || value == 12) { // Face cards\n\t\t\treturn 10;\n\t\t}\n\t\tif (value == 1 && _0x518bb8) { // Ace is worth 11\n\t\t\treturn 11;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction _0xa282f9(uint8 _0xb7f20f) internal constant returns (bool) {\n\t\treturn _0xb7f20f / 4 == 1;\n\t}\n\n\tfunction _0x8c952a(uint8 _0xb7f20f) internal constant returns (bool) {\n\t\treturn _0xb7f20f / 4 == 10;\n\t}\n}\n\ncontract BlackJack {\n\tusing Deck for *;\n\n\tuint public _0x66c82b = 50 finney; // 0.05 eth\n\tuint public _0x40e0cf = 5 ether;\n\n\tuint8 BLACKJACK = 21;\n\n  enum GameState { Ongoing, Player, Tie, House }\n\n\tstruct Game_0x10c8b7address _0xb56353; // address \u0438\u0433\u0440\u043e\u043a\u0430_0xc6cf20uint _0x52f48a; // \u0441\u0442\u044b\u0432\u043a\u0430\n\n\t\tuint8[] houseCards; // \u043a\u0430\u0440\u0442\u044b \u0434\u0438\u043b\u043b\u0435\u0440\u0430_0xc6cf20uint8[] _0x68e83b; // \u043a\u0430\u0440\u0442\u044b \u0438\u0433\u0440\u043e\u043a\u0430\n\n\t\tGameState state; // \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435_0xc6cf20uint8 cardsDealt;\n\t}\n\n\tmapping (address => Game) public games;\n\n\tmodifier gameIsGoingOn() {\n\t\tif (_0x348859sender]._0xb56353 == 0 || _0x348859sender].state != GameState.Ongoing) {\n\t\t\tthrow; // game doesn't exist or already finished\n\t\t}\n\t\t_;\n\t}\n\n\tevent Deal(\n        bool isUser,\n        uint8 _card\n    );\n\n    event GameStatus(\n    \tuint8 houseScore,\n    \tuint8 houseScoreBig,\n    \tuint8 playerScore,\n    \tuint8 playerScoreBig\n    );\n\n    event Log(\n    \tuint8 value\n    );\n\n\tfunction BlackJack() {\n\n\t}\n\n\tfunction () payable {\n\n\t}\n\n\t// starts a new game\n\tfunction _0xf9d8b6() public payable_0x10c8b7if (_0x348859sender]._0xb56353 != 0 && _0x348859sender].state == GameState.Ongoing) {\n\t\t\tthrow; // game is already going on\n\t\t}\n\n\t\tif_0x6366b6.value < _0x66c82b || msg.value > _0x40e0cf) {\n\t\t\tthrow; // incorrect bet\n\t\t}\n\n\t\tuint8[] memory houseCards = new uint8[](1);\n\t\tuint8[] memory _0x68e83b = new uint8[](2);\n\n\t\t// deal the cards_0xc6cf20_0x68e83b[0] = Deck.deal_0x95ef29, 0);\n\t\tDeal(true, _0x68e83b[0]);\n\t\thouseCards[0] = Deck.deal_0x95ef29, 1);\n\t\tDeal(false, houseCards[0]);\n\t\t_0x68e83b[1] = Deck.deal_0x95ef29, 2);\n\t\tDeal(true, _0x68e83b[1]);\n\n\t\t_0x348859sender] = Game({\n\t\t\t_0xb56353: msg.sender,\n\t\t\t_0x52f48a: msg.value,\n\t\t\thouseCards: houseCards,\n\t\t\t_0x68e83b: _0x68e83b,\n\t\t\tstate: GameState.Ongoing,\n\t\t\tcardsDealt: 3\n\t\t});\n\n\t\tcheckGameResult(_0x348859sender], false);\n\t}\n\n\t// deals one more card to the player\n\tfunction hit() public gameIsGoingOn_0x10c8b7uint8 nextCard = _0x348859sender].cardsDealt;\n\t\t_0x348859sender]._0x68e83b._0x41a4fddeal_0x95ef29, nextCard));\n\t\t_0x348859sender].cardsDealt = nextCard + 1;\n\t\tDeal(true, _0x348859sender]._0x68e83b[_0x348859sender]._0x68e83b.length - 1]);\n\t\tcheckGameResult(_0x348859sender], false);\n\t}\n\n\t// finishes the game\n\tfunction stand() public gameIsGoingOn {\n\n\t\tvar (houseScore, houseScoreBig) = calculateScore(_0x348859sender].houseCards);\n\n\t\twhile (houseScoreBig < 17) {\n\t\t\tuint8 nextCard = _0x348859sender].cardsDealt;\n\t\t\tuint8 newCard = Deck.deal_0x95ef29, nextCard);\n\t\t\t_0x348859sender].houseCards.push(newCard);\n\t\t\t_0x348859sender].cardsDealt = nextCard + 1;\n\t\t\thouseScoreBig += Deck._0xcdd354(newCard, true);\n\t\t\tDeal(false, newCard);\n\t\t}\n\n\t\tcheckGameResult(_0x348859sender], true);\n\t}\n\n\t// @param finishGame - whether to finish the game or not (in case of Blackjack the game finishes anyway)\n\tfunction checkGameResult(Game _0x70073f, bool finishGame_0x235292_0x10c8b7// calculate house score_0xc6cf20var (houseScore, houseScoreBig) = calculateScore(_0x5e8e1dhouseCards);\n\t\t// calculate player score_0xc6cf20var (playerScore, playerScoreBig) = calculateScore(_0x5e8e1d_0x68e83b);\n\n\t\tGameStatus(houseScore, houseScoreBig, playerScore, playerScoreBig);\n\n\t\tif (houseScoreBig == BLACKJACK || houseScore == BLACKJACK) {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\t\t\t\t// TIE_0x02f835if (!msg.sender._0x83ddae)) throw; // return bet to the player_0x02f835_0x348859sender].state = GameState.Tie; // finish the game_0x02f835return;\n\t\t\t} else {\n\t\t\t\t// HOUSE WON_0x02f835_0x348859sender].state = GameState.House; // simply finish the game_0x02f835return;\n\t\t\t}\n\t\t} else {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\t\t\t\t// PLAYER WON_0x02f835if (_0x5e8e1d_0x68e83b.length == 2 && (Deck._0x8c952a(_0x5e8e1d_0x68e83b[0]) || Deck._0x8c952a(_0x5e8e1d_0x68e83b[1]))) {\n\t\t\t\t\t// Natural blackjack => return x2.5\n\t\t\t\t\tif (!msg.sender.send((_0x5e8e1dbet * 5) / 2)) throw; // send prize to the player\n\t\t\t\t} else {\n\t\t\t\t\t// Usual blackjack => return x2\n\t\t\t\t\tif (!msg.sender._0x83ddae * 2)) throw; // send prize to the player\n\t\t\t\t}\n\t\t\t\t_0x348859sender].state = GameState.Player; // finish the game_0x02f835return;\n\t\t\t} else {\n\n\t\t\t\tif (playerScore > BLACKJACK) {\n\t\t\t\t\t// BUST, HOUSE WON\n\t\t\t\t\tLog(1);\n\t\t\t\t\t_0x348859sender].state = GameState.House; // finish the game\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!finishGame) {\n\t\t\t\t\treturn; // continue the game\n\t\t\t\t}\n\n                // \u043d\u0435\u0434\u043e\u0431\u043e\u0440_0x02f835uint8 playerShortage = 0;\n\t\t\t\tuint8 houseShortage = 0;\n\n\t\t\t\t// player decided to finish the game_0x02f835if (playerScoreBig > BLACKJACK) {\n\t\t\t\t\tif (playerScore > BLACKJACK) {\n\t\t\t\t\t\t// HOUSE WON\n\t\t\t\t\t\t_0x348859sender].state = GameState.House; // simply finish the game\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplayerShortage = BLACKJACK - playerScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tplayerShortage = BLACKJACK - playerScoreBig;\n\t\t\t\t}\n\n\t\t\t\tif (houseScoreBig > BLACKJACK) {\n\t\t\t\t\tif (houseScore > BLACKJACK) {\n\t\t\t\t\t\t// PLAYER WON\n\t\t\t\t\t\tif (!msg.sender._0x83ddae * 2)) throw; // send prize to the player\n\t\t\t\t\t\t_0x348859sender].state = GameState.Player;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thouseShortage = BLACKJACK - houseScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thouseShortage = BLACKJACK - houseScoreBig;\n\t\t\t\t}\n\n                // ?????????????????????? \u043f\u043e\u0447\u0435\u043c\u0443 \u0438\u0433\u0440\u0430 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f?_0x02f835if (houseShortage == playerShortage) {\n\t\t\t\t\t// TIE\n\t\t\t\t\tif (!msg.sender._0x83ddae)) throw; // return bet to the player\n\t\t\t\t\t_0x348859sender].state = GameState.Tie;\n\t\t\t\t} else if (houseShortage > playerShortage) {\n\t\t\t\t\t// PLAYER WON\n\t\t\t\t\tif (!msg.sender._0x83ddae * 2)) throw; // send prize to the player\n\t\t\t\t\t_0x348859sender].state = GameState.Player;\n\t\t\t\t} else {\n\t\t\t\t\t_0x348859sender].state = GameState.House;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction calculateScore(uint8[] cards_0x235292 constant returns (uint8, uint8) {\n\t\t_0x573ffe0;\n\t\tuint8 scoreBig = 0; // in case of Ace there could be 2 different scores_0xc6cf20bool bigAceUsed = false;\n\t\tfor (uint i = 0; i < cards.length; ++i) {\n\t\t\tuint8 _0xb7f20f = cards[i];\n\t\t\tif (Deck._0xa282f9(_0xb7f20f) && !bigAceUsed) { // doesn't make sense to use the second Ace as 11, because it leads to the losing_0x02f835scoreBig += Deck._0xcdd354(_0xb7f20f, true);\n\t\t\t\tbigAceUsed = true;\n\t\t\t} else {\n\t\t\t\tscoreBig += Deck._0xcdd354(_0xb7f20f, false);\n\t\t\t}\n\t\t\tscore += Deck._0xcdd354(_0xb7f20f, false);\n\t\t}\n\t\treturn (score, scoreBig);\n\t}\n\n\tfunction getPlayerCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif_0x511611id > _0x348859sender]._0x68e83b.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn _0x348859sender]._0x68e83b_0x1c7954function getHouseCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif_0x511611id > _0x348859sender].houseCards.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn _0x348859sender].houseCards_0x1c7954function getPlayerCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn _0x348859sender]._0x68e83b.length;\n\t}\n\n\tfunction getHouseCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn _0x348859sender].houseCards.length;\n\t}\n\n\tfunction getGameState() public constant returns (uint8) {\n\t\tif (_0x348859sender]._0xb56353 == 0) {\n\t\t\tthrow; // game doesn't exist\n\t\t}\n\n\t\tGame _0x70073f = _0x348859sender];\n\n\t\tif (_0x5e8e1dstate == GameState.Player) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (_0x5e8e1dstate == GameState.House) {\n\t\t\treturn 2;\n\t\t}\n\t\tif (_0x5e8e1dstate == GameState.Tie) {\n\t\t\treturn 3;\n\t\t}\n\n\t\treturn 0; // the game is still going on\n\t}\n\n}",
      "rename_map": {
        "urn games[msg.sender": "_0x239c34",
        "rn games[msg.sender": "_0x3df9b9",
        "}\n\n\t// finishes": "_0x34abc8",
        "\n\n\t// @param fi": "_0x8b0ecd",
        "private {\n\t\t// ": "_0x97c0cd",
        "}\n\n\t// deals on": "_0xafbba5",
        "tus(houseScore": "_0x2af797",
        "2)) throw; // ": "_0xe2a394",
        "\t\t\t// player d": "_0x603381",
        "uint8 score = ": "_0x573ffe",
        "// return bet ": "_0xfc6636",
        "> BLACKJACK) {": "_0x78da29",
        "int8 value\n   ": "_0xee676b",
        ";\n\n\t\twhile (ho": "_0x4e4388",
        "\t\t} else {\n\t\t\t": "_0xcf5173",
        "ate player sco": "_0xebf154",
        "\n\t\t\t\tif (house": "_0x3a9d72",
        "\t\tif (!msg.sen": "_0x0c25bc",
        " WON\n\t\t\t\tif (g": "_0xa6b53e",
        ".sender].card": "_0xfaa6ba",
        "mes[msg.sende": "_0xe68c4a",
        "???????????? ": "_0x5d01b7",
        "nder].houseCa": "_0x972c84",
        "f (id < 0 || ": "_0x976173",
        ";\n\t\t\tDeal(fal": "_0xe02f23",
        "uint8 playerS": "_0x5f529e",
        "ds.length;\n\t}": "_0xe73e63",
        " the game\n\t\t\t": "_0xd8cae4",
        "             ": "_0x0e5595",
        "ayer == 0 || ": "_0x6f3d68",
        "send(game.bet": "_0x83ddae",
        "} else {\n\t\t\t\t": "_0x281e1c",
        "rds);\n\t\t// ca": "_0x03d0d4",
        "rds.length;\n\t": "_0x1c8f60",
        "der].houseCar": "_0xd6d407",
        "der].playerCa": "_0x7c24d1",
        "ame.bet)) thr": "_0x78a0bd",
        "\n\n\t\tif (house": "_0x7dde3f",
        "reBig) = calc": "_0x1acefd",
        "layer == 0) ": "_0x634f32",
        " (id < 0 || ": "_0x511611",
        "playerCards": "_0x68e83b",
        "ds[1]))) {\n": "_0xbb985e",
        "[id];\n\t}\n\n\t": "_0x1c7954",
        "\tgames[msg.": "_0x7fb6fc",
        "e = BLACKJA": "_0x83022c",
        "oreBig == B": "_0xcda19f",
        " constant r": "_0x369c24",
        "eScoreBig, ": "_0xe1cefe",
        "(msg.sender": "_0x95ef29",
        ";\n\n    even": "_0x9cbdd1",
        "({\n\t\t\tplaye": "_0x1d7577",
        "k => return": "_0xd3fd9e",
        "e(game.play": "_0x183a2d",
        "e.Ongoing,\n": "_0x3fc14a",
        "\u0440\u043e\u043a\u0430\n\n\t\tGam": "_0xc6f67f",
        "ngth - 1]);": "_0x29d6fd",
        "\tcardsDealt": "_0x1ccbbc",
        "ard));\n\t\tga": "_0xc62a5c",
        "= BLACKJACK": "_0xba4060",
        "\tDeal(true,": "_0x040a7d",
        "games[msg.s": "_0xb24291",
        " cards\n\t\tpl": "_0xcc5645",
        "cardNumber": "_0xfddb59",
        "core\n\t\tvar": "_0x75f110",
        "d];\n\t}\n\n\tf": "_0x9cd91c",
        "push(Deck.": "_0x41a4fd",
        "// \u043a\u0430\u0440\u0442\u044b \u0434": "_0x415c97",
        "ame\n\t\t\t\t}\n": "_0x8a578d",
        ".sender, n": "_0x66c082",
        "+= Deck.va": "_0x1a81be",
        "ard = card": "_0x1e76aa",
        "r].cardsDe": "_0x3d7385",
        "y playerCa": "_0x97a232",
        "ar (player": "_0x9f67e2",
        "s[msg.send": "_0x9f8f71",
        "\tif (!msg.": "_0x83c0b2",
        "(msg.sende": "_0xe65277",
        "e == BLACK": "_0xd5411a",
        "\n\t\t\tuint8 ": "_0xee576d",
        "state: Gam": "_0xbfefd3",
        "erCards,\n\t": "_0xbfa6c1",
        "\t\t\t}\n\t\t\tsc": "_0x11351b",
        "game.house": "_0x04ea88",
        "constant r": "_0xdf5db9",
        "int8 playe": "_0x00eedb",
        "t leads to": "_0xeef4e5",
        "erScoreBig": "_0xae5b9f",
        "ublic game": "_0xbe429c",
        "[msg.sende": "_0xe8e033",
        "int8) {\n\t\t": "_0xba6e97",
        "= BLACKJAC": "_0x71cac5",
        "games[msg.": "_0x348859",
        "8 houseSco": "_0x03ac1a",
        "der].stat": "_0x835f7c",
        "urn;\n\t\t\t}": "_0x391b04",
        "'t exist ": "_0xb1a116",
        "{\n\t\t\tretu": "_0xf4e0ac",
        "\t\t\t\t// HO": "_0xb2a85d",
        "turn;\n\t\t\t": "_0xc19609",
        "\t\t\t\t// TI": "_0xbf49ed",
        ") private": "_0x235292",
        "\t\t\t\t// PL": "_0x97e2a5",
        "\t\treturn ": "_0x8ec9bb",
        "\thouseSho": "_0x2eb021",
        "playerCar": "_0x275003",
        "useShorta": "_0xa06068",
        "use;\n\t\t\t\t": "_0xeaa9a3",
        "reBig > B": "_0xe78be7",
        " || playe": "_0x5bfebd",
        ";\n\t\t\t} el": "_0x1d8665",
        "layerShor": "_0x30272b",
        "}\n\n\t// st": "_0x70ac6c",
        "/ ???????": "_0x52f8db",
        "der.send(": "_0xcc4d20",
        "t8 cardsD": "_0x3b8cdc",
        "g(1);\n\t\t\t": "_0xd30a4d",
        "keccak256": "_0x54da02",
        "urn;\n\t\t\t\t": "_0x6d3f68",
        "f (player": "_0xcf3a37",
        "send(game": "_0x5345e3",
        "\t\t\t// PLA": "_0x2ccd64",
        "ready goi": "_0xb3c876",
        "\t\t\treturn": "_0x90d814",
        "\tcheckGam": "_0x9ae075",
        "; // gam": "_0x1abf83",
        "uint8 ne": "_0xcc128d",
        "\n\tfuncti": "_0x907a33",
        " false);": "_0x10ee6d",
        " nextCar": "_0x19bfcc",
        "tant ret": "_0x2193e1",
        "isBigAce": "_0x518bb8",
        "on\n\t}\n\n}": "_0x9330f7",
        "ds.lengt": "_0xcebdae",
        "\t\t\tscore": "_0xe44bc1",
        ".playerC": "_0x3e3e06",
        "\n\n\tfunct": "_0x9436dc",
        "ush(newC": "_0x217773",
        "igAceUse": "_0xbae5a3",
        " // in c": "_0x11d8a4",
        "s.length": "_0x40b183",
        "ames[msg": "_0x7a8e35",
        "yerCard": "_0x484cd9",
        "ender],": "_0xacc5b5",
        "\t\tgames": "_0x6ae38a",
        "turn (s": "_0x960827",
        "g on\n\t\t": "_0x11d069",
        "r alrea": "_0x26387e",
        "ck.valu": "_0xdfefbe",
        "valueOf": "_0xcdd354",
        "nextCar": "_0xe04fc7",
        "\n\n\t\tche": "_0xfdb3e5",
        "rd);\n\t\t": "_0x11efa1",
        "ender]": "_0x1707a4",
        "minBet": "_0x66c82b",
        " incor": "_0x65b9f5",
        "re(uin": "_0x891a14",
        "to the": "_0xf8264d",
        " < 17)": "_0x139772",
        "uint8[": "_0x914ef6",
        "functi": "_0xd26872",
        "\t\t} el": "_0x094a97",
        "\n\t\t\t}\n": "_0x206a2d",
        "houseC": "_0x1b7713",
        "te == ": "_0x528048",
        "te != ": "_0xeb82e6",
        "ize to": "_0x909aea",
        "player": "_0xb56353",
        "nder],": "_0xff6b91",
        "\tgames": "_0xd72e72",
        "turns ": "_0x92c588",
        "ow; //": "_0x060a08",
        "eUsed)": "_0xd5b304",
        "et: ms": "_0xc0c66f",
        "end pr": "_0xbf99ca",
        "erCard": "_0x83e06e",
        "0]) ||": "_0x40867a",
        "tage =": "_0x56c16b",
        "else {": "_0x1e81bb",
        "he gam": "_0x6c7d2e",
        "n 2;\n\t": "_0x03c6b8",
        "eIsGoi": "_0xf67b7f",
        "coreBi": "_0xc7c7e9",
        "f (gam": "_0x3d7359",
        "nction": "_0x2b85ef",
        "whethe": "_0xe71bdc",
        "ge) {\n": "_0x50865d",
        "eResul": "_0xf5e24b",
        " to th": "_0x1ff298",
        "meStat": "_0xf8f35c",
        "games[": "_0x00c805",
        "deal(m": "_0xcb3f36",
        "unctio": "_0x2e4ab4",
        "r, nex": "_0x807b74",
        "sDealt": "_0x103601",
        " game\n": "_0xa6d1f0",
        "sGoing": "_0xa52e91",
        "maxBet": "_0x40e0cf",
        "ue, ga": "_0xc2acc3",
        "yerCar": "_0x1cdbea",
        "ame.st": "_0x70b256",
        "t Game": "_0x332458",
        "e = Ga": "_0x431071",
        "the ga": "_0x2eda0d",
        "useCar": "_0x063701",
        "eCards": "_0x5fbadb",
        "the pl": "_0x9d60ee",
        "sg.sen": "_0x5efd0b",
        "inish ": "_0x5fc9c1",
        "g.send": "_0x96889c",
        "y fin": "_0xcaa094",
        "uncti": "_0x7d12db",
        "[] ca": "_0x16c720",
        "hrow;": "_0x2bb816",
        "shed\n": "_0x08529d",
        "ishGa": "_0x93f931",
        "ll go": "_0xd41041",
        "lic g": "_0x39e65f",
        "y hou": "_0x3015f6",
        "\n\t\tDe": "_0xb7fe4c",
        "\n\t\t\th": "_0x173dd4",
        "\n\t\t}\n": "_0x9c69fb",
        "funct": "_0x7b01aa",
        ";\n\t\t}": "_0x4b13d8",
        "eturn": "_0xcf2612",
        "me ga": "_0x4e0bd4",
        "/ sim": "_0x27e4c9",
        "er].p": "_0x0e8b10",
        "finis": "_0xd23888",
        "to us": "_0x4d06a8",
        "ent s": "_0xa954b9",
        "mes[m": "_0x7c8000",
        "\t});\n": "_0xeedcf6",
        "\n\t\t\t\t": "_0x02f835",
        "const": "_0x98566e",
        "[msg.": "_0x2e54d4",
        "e.Tie": "_0x22cf88",
        "alt;\n": "_0x54fd9a",
        "game.": "_0x5e8e1d",
        "sende": "_0xb9beee",
        "\t\t\t//": "_0x5613e2",
        "8 sco": "_0x8eaeee",
        "ards:": "_0xbad267",
        ") {\n\t": "_0xa867f9",
        " more": "_0x1509df",
        "e.Pla": "_0x36c0b1",
        " (msg": "_0x6366b6",
        "/ fin": "_0xa557c0",
        "seSco": "_0x2a2b24",
        "!bigA": "_0xe91ee3",
        "onsta": "_0xd141a5",
        "\tgame": "_0xab7787",
        "e gam": "_0x651913",
        "isTen": "_0x8c952a",
        "\t\t\tga": "_0xb77d72",
        "\n\t\t\t}": "_0x486129",
        "(msg.": "_0x2ba21a",
        "useCa": "_0xc0edbb",
        "\t}\n\t\t": "_0x1f9ba2",
        "isAce": "_0xa282f9",
        "// fi": "_0x76b83a",
        "\t\t\t\t\t": "_0xa1a4f7",
        "ame d": "_0x7f9b51",
        "ame i": "_0xfbf3bd",
        "t8 ho": "_0xe0fe1b",
        "\t\tche": "_0x19c967",
        "the g": "_0xb05a65",
        "lcula": "_0xd2527c",
        "publi": "_0xe52767",
        "\t\tret": "_0x6951af",
        "e.Hou": "_0xddfe64",
        "rd = ": "_0x6c080a",
        "ayerS": "_0x25d78a",
        "e.pla": "_0x61e9d5",
        "as 11": "_0x111d2e",
        "nder,": "_0xa401b5",
        "nder]": "_0x24544c",
        ".Tie)": "_0x25fe61",
        "al bl": "_0x2707f7",
        "\t} el": "_0x484bee",
        " {\n\t\t": "_0x10c8b7",
        "blic ": "_0x68b861",
        "ender": "_0x746540",
        "\n\n\t\t\t": "_0x68c1ad",
        "e {\n\t": "_0x12d3d6",
        "yerCa": "_0x661ecf",
        "ate ": "_0x8adf6d",
        "the ": "_0xb152b5",
        "newC": "_0x8dfa19",
        "es[m": "_0xdbdd8e",
        "= De": "_0x5339a5",
        "play": "_0xe99d47",
        "eSta": "_0xcb6789",
        "\t\t\t\t": "_0x3fb672",
        "tate": "_0x8ee2f3",
        " bec": "_0xc0339f",
        " Ace": "_0x744f78",
        "ckja": "_0x636738",
        "rd\n ": "_0x6feea1",
        "() {": "_0x603b9b",
        "r\n\t\t": "_0x339d47",
        "s[0]": "_0xe43b2c",
        "n(ga": "_0x23cd0a",
        "\tret": "_0x247dc3",
        "ore,": "_0x1746ce",
        "card": "_0xb7f20f",
        "\n\t\tr": "_0x95d7d8",
        "yer\n": "_0x857baa",
        "rn 1": "_0x7826c7",
        "der]": "_0x1e1627",
        "rCar": "_0x099d03",
        "g.se": "_0x254f4a",
        "er].": "_0x52404e",
        "ze t": "_0x0ccbc9",
        " sen": "_0xf9d031",
        "s st": "_0x2d8460",
        "s[1]": "_0x9d2b7a",
        "lt =": "_0xbc6331",
        "erCa": "_0x0b13bb",
        "game": "_0x70073f",
        "(gam": "_0xb1e418",
        "+= D": "_0x0daf96",
        " = G": "_0x2a6981",
        "lue,": "_0xba42f1",
        "deal": "_0xf9d8b6",
        "eCar": "_0xab6ad5",
        "laye": "_0xabc8c7",
        "etPl": "_0x29e6a2",
        "e\n\t\t": "_0x391dd0",
        " = D": "_0x3cee10",
        " hou": "_0x64db39",
        "alcu": "_0xbe569b",
        "stat": "_0x81e08b",
        "e {": "_0x6e0e2f",
        " th": "_0xdc4096",
        ".pl": "_0x6de16f",
        "eBi": "_0x2f5b7f",
        "gam": "_0xbcedec",
        "\tth": "_0x702993",
        ";\n\n": "_0x649862",
        "me\n": "_0xf79741",
        "lay": "_0x941366",
        "ish": "_0xf7e7e3",
        "sg.": "_0x8af3a7",
        " be": "_0x2ad9cd",
        "kJa": "_0x4c99b0",
        "tat": "_0x184c13",
        "sta": "_0x6d5f0f",
        "meI": "_0x4c943a",
        "ame": "_0x01f8ca",
        "= G": "_0x34fb3e",
        " ga": "_0x997aac",
        "d =": "_0xd798d3",
        "\tga": "_0x664ee4",
        "d p": "_0x25a4dc",
        "yer": "_0x41bcd0",
        "meS": "_0xafebc8",
        ": h": "_0x5e36d9",
        "hou": "_0xa3f96d",
        " to": "_0x75656e",
        "end": "_0x48dddf",
        "sh ": "_0x40e259",
        "es[": "_0xc296b5",
        "car": "_0xd77d83",
        "e -": "_0x1224e4",
        "aye": "_0x553b20",
        "e =": "_0x341e20",
        "f (": "_0x5e043d",
        ";\n\t": "_0xfe5e14",
        "ly ": "_0x05d7e1",
        "eSc": "_0x750ca8",
        "\t\t\t": "_0x282eb0",
        "bet": "_0x52f48a",
        "l(t": "_0xf6cdf5",
        "ort": "_0xe11b45",
        "kGa": "_0x539ebb",
        "eck": "_0x831cb6",
        "pla": "_0x9b70e7",
        "t r": "_0xe0cd2b",
        ".st": "_0xba58a6",
        "\n\t\t": "_0xc6cf20",
        "\t\tp": "_0x63225a",
        "use": "_0x2c0777",
        "// ": "_0x81436f",
        "/ \u0441": "_0x752c5a",
        "ms": "_0x949e45",
        "ur": "_0x8c08ab",
        "tu": "_0x99a904",
        "rn": "_0x6b7825",
        "sg": "_0xb33881",
        "me": "_0x4e553d"
      },
      "changes": [
        "Renamed 391 identifiers using hex style"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 2, column 8', 'Syntax error at line 9, column 3', 'Syntax error at line 31, column 1']"
    },
    {
      "original_id": "sn_ds_234",
      "transformed_id": "ss_l3_medium_sn_ds_234",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.13;\n\nlibrary SafeMath {\n  function _0x330500(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n  function _0xa1d47b(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint public _0xd3cd25;\n  address public _0x50a488; //owner\n  address public _0x2e62a7; //animator\n  function _0x993698(address _0x216a87) constant returns (uint);\n  function transfer(address _0x7c29ef, uint value);\n  event Transfer(address indexed from, address indexed _0x7c29ef, uint value);\n  function _0x7216d2(address _0x216a87) internal; // pays remaining dividend\n}\n\ncontract ERC20 is ERC20Basic {\n  function _0x2473a1(address _0x50a488, address _0xb8c331) constant returns (uint);\n  function _0x4b3fe4(address from, address _0x7c29ef, uint value);\n  function _0x161bc1(address _0xb8c331, uint value);\n  event Approval(address indexed _0x50a488, address indexed _0xb8c331, uint value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n  mapping(address => uint) _0xd89c86;\n\n  modifier _0xafde03(uint _0xcb6c88) {\n     assert(msg.data.length >= _0xcb6c88 + 4);\n     _;\n  }\n\n  function transfer(address _0x304d65, uint _0x951b29) _0xafde03(2 * 32) {\n    _0x7216d2(msg.sender);\n    _0xd89c86[msg.sender] = _0xd89c86[msg.sender]._0x330500(_0x951b29);\n    if(_0x304d65 == address(this)) {\n        _0x7216d2(_0x50a488);\n        _0xd89c86[_0x50a488] = _0xd89c86[_0x50a488]._0xa1d47b(_0x951b29);\n        Transfer(msg.sender, _0x50a488, _0x951b29);\n    }\n    else {\n        _0x7216d2(_0x304d65);\n        _0xd89c86[_0x304d65] = _0xd89c86[_0x304d65]._0xa1d47b(_0x951b29);\n        Transfer(msg.sender, _0x304d65, _0x951b29);\n    }\n  }\n\n  function _0x993698(address _0xa8cc7b) constant returns (uint balance) {\n    return _0xd89c86[_0xa8cc7b];\n  }\n}\n\ncontract StandardToken is BasicToken, ERC20 {\n  mapping (address => mapping (address => uint)) _0x96b65b;\n\n  function _0x4b3fe4(address _0xc70665, address _0x304d65, uint _0x951b29) _0xafde03(3 * 32) {\n    var _0x4a1aa6 = _0x96b65b[_0xc70665][msg.sender];\n    _0x7216d2(_0xc70665);\n    _0x7216d2(_0x304d65);\n    _0xd89c86[_0x304d65] = _0xd89c86[_0x304d65]._0xa1d47b(_0x951b29);\n    _0xd89c86[_0xc70665] = _0xd89c86[_0xc70665]._0x330500(_0x951b29);\n    _0x96b65b[_0xc70665][msg.sender] = _0x4a1aa6._0x330500(_0x951b29);\n    Transfer(_0xc70665, _0x304d65, _0x951b29);\n  }\n\n  function _0x161bc1(address _0x8914e8, uint _0x951b29) {\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    assert(!((_0x951b29 != 0) && (_0x96b65b[msg.sender][_0x8914e8] != 0)));\n    _0x96b65b[msg.sender][_0x8914e8] = _0x951b29;\n    Approval(msg.sender, _0x8914e8, _0x951b29);\n  }\n\n  function _0x2473a1(address _0xa8cc7b, address _0x8914e8) constant returns (uint _0xa0fc2e) {\n    return _0x96b65b[_0xa8cc7b][_0x8914e8];\n  }\n}\n\ncontract SmartBillions is StandardToken {\n\n    // metadata\n    string public constant _0x18f173 = \"SmartBillions Token\";\n    string public constant _0x614c5e = \"PLAY\";\n    uint public constant _0x32000a = 0;\n\n    // contract state\n    struct Wallet {\n        uint208 balance; // current balance of user\n    \tuint16 _0x432b83; // last processed dividend period of user's tokens\n    \tuint32 _0x81f71a; // next withdrawal possible after this block number\n    }\n    mapping (address => Wallet) _0x5e1f38;\n    struct Bet {\n        uint192 value; // bet size\n        uint32 _0x5716fa; // selected numbers\n        uint32 _0x1b5107; // blocknumber when lottery runs\n    }\n    mapping (address => Bet) _0x503ecd;\n\n    uint public _0x32f784 = 0; // sum of funds in wallets\n\n    // investment parameters\n    uint public _0x336e91 = 1; // investment start block, 0: closed, 1: preparation\n    uint public _0x698eb0 = 0; // funding from investors\n    uint public _0xef6de2 = 200000 ether; // maximum funding\n    uint public _0x6738a1 = 1;\n    uint[] public _0x224581; // dividens collected per period, growing array\n\n    // betting parameters\n    uint public _0xca264e = 0; // maximum prize won\n    uint public _0x31065c = 0; // start time of building hashes database\n    uint public _0xb190da = 0; // last saved block of hashes\n    uint public _0x66251d = 0; // next available bet block.number\n    uint public _0x88e578 = 0; // used bet volume of next block\n    uint public _0x293c1b = 5 ether; // maximum bet size per block\n    uint[] public _0x5eb69a; // space for storing lottery results\n\n    // constants\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\n    uint public constant _0xbd973e = 16384 ; // 30 days of blocks\n    uint public _0xb854b6 = 0 ; // block of last cold store transfer\n\n    // events\n    event LogBet(address indexed _0xbc904f, uint _0xf9f77e, uint _0xc2d5d3, uint _0x159f47);\n    event LogLoss(address indexed _0xbc904f, uint _0xf9f77e, uint _0x7ed265);\n    event LogWin(address indexed _0xbc904f, uint _0xf9f77e, uint _0x7ed265, uint _0xf1699d);\n    event LogInvestment(address indexed _0x68e703, address indexed _0xa48b13, uint _0x2da7df);\n    event LogRecordWin(address indexed _0xbc904f, uint _0x2da7df);\n    event LogLate(address indexed _0xbc904f,uint _0x081a50,uint _0x047bd6);\n    event LogDividend(address indexed _0x68e703, uint _0x2da7df, uint _0xf36143);\n\n    modifier _0x100f01() {\n        assert(msg.sender == _0x50a488);\n        _;\n    }\n\n    modifier _0xcab4c7() {\n        assert(msg.sender == _0x2e62a7);\n        _;\n    }\n\n    // constructor\n    function SmartBillions() {\n        _0x50a488 = msg.sender;\n        if (block.timestamp > 0) { _0x2e62a7 = msg.sender; }\n        _0x5e1f38[_0x50a488]._0x432b83 = uint16(_0x6738a1);\n        _0x224581.push(0); // not used\n        _0x224581.push(0); // current dividend\n    }\n\n/* getters */\n\n    function _0x4de3d2() constant external returns (uint) {\n        return uint(_0x5eb69a.length);\n    }\n\n    function _0x79cf77(address _0xa8cc7b) constant external returns (uint) {\n        return uint(_0x5e1f38[_0xa8cc7b].balance);\n    }\n\n    function _0x0c5a27(address _0xa8cc7b) constant external returns (uint) {\n        return uint(_0x5e1f38[_0xa8cc7b]._0x432b83);\n    }\n\n    function _0x1840a0(address _0xa8cc7b) constant external returns (uint) {\n        return uint(_0x5e1f38[_0xa8cc7b]._0x81f71a);\n    }\n\n    function _0x41330b(address _0xa8cc7b) constant external returns (uint) {\n        return uint(_0x503ecd[_0xa8cc7b].value);\n    }\n\n    function _0xb4342b(address _0xa8cc7b) constant external returns (uint) {\n        return uint(_0x503ecd[_0xa8cc7b]._0x5716fa);\n    }\n\n    function _0x9de658(address _0xa8cc7b) constant external returns (uint) {\n        return uint(_0x503ecd[_0xa8cc7b]._0x1b5107);\n    }\n\n    function _0x68922f() constant external returns (uint) {\n        if(_0x336e91 > 0) {\n            return(0);\n        }\n        uint _0xf36143 = (block.number - _0x31065c) / (10 * _0xbd973e);\n        if(_0xf36143 > _0x6738a1) {\n            return(0);\n        }\n        return((10 * _0xbd973e) - ((block.number - _0x31065c) % (10 * _0xbd973e)));\n    }\n\n/* administrative functions */\n\n    function _0xb71ae8(address _0x7fb89a) external _0x100f01 {\n        assert(_0x7fb89a != address(0));\n        _0x7216d2(msg.sender);\n        _0x7216d2(_0x7fb89a);\n        _0x50a488 = _0x7fb89a;\n    }\n\n    function _0x241cf2(address _0x7fb89a) external _0xcab4c7 {\n        assert(_0x7fb89a != address(0));\n        _0x7216d2(msg.sender);\n        _0x7216d2(_0x7fb89a);\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x2e62a7 = _0x7fb89a; }\n    }\n\n    function _0xf50feb(uint _0xbb030f) external _0x100f01 {\n        require(_0x336e91 == 1 && _0x31065c > 0 && block.number < _0xbb030f);\n        _0x336e91 = _0xbb030f;\n    }\n\n    function _0x30f874(uint _0xe8e3c9) external _0x100f01 {\n        _0x293c1b = _0xe8e3c9;\n    }\n\n    function _0xd20b1e() external _0x100f01 {\n        if (true) { _0x66251d = block.number + 3; }\n        if (block.timestamp > 0) { _0x88e578 = 0; }\n    }\n\n    function _0x433a0a(uint _0xb8f422) external _0x100f01 {\n        _0x29aa27();\n        require(_0xb8f422 > 0 && this.balance >= (_0x698eb0 * 9 / 10) + _0x32f784 + _0xb8f422);\n        if(_0x698eb0 >= _0xef6de2 / 2){ // additional jackpot protection\n            require((_0xb8f422 <= this.balance / 400) && _0xb854b6 + 4 * 60 * 24 * 7 <= block.number);\n        }\n        msg.sender.transfer(_0xb8f422);\n        _0xb854b6 = block.number;\n    }\n\n    function _0x7ad8d6() payable external {\n        _0x29aa27();\n    }\n\n/* housekeeping functions */\n\n    function _0x29aa27() public {\n        if(_0x336e91 > 1 && block.number >= _0x336e91 + (_0xbd973e * 5)){ // ca. 14 days\n            _0x336e91 = 0; // start dividend payments\n        }\n        else {\n            if(_0x31065c > 0){\n\t\t        uint _0xf36143 = (block.number - _0x31065c) / (10 * _0xbd973e );\n                if(_0xf36143 > _0x224581.length - 2) {\n                    _0x224581.push(0);\n                }\n                if(_0xf36143 > _0x6738a1 && _0x336e91 == 0 && _0x6738a1 < _0x224581.length - 1) {\n                    _0x6738a1++;\n                }\n            }\n        }\n    }\n\n/* payments */\n\n    function _0x6b5c7b() public {\n        if(_0x5e1f38[msg.sender].balance > 0 && _0x5e1f38[msg.sender]._0x81f71a <= block.number){\n            uint balance = _0x5e1f38[msg.sender].balance;\n            _0x5e1f38[msg.sender].balance = 0;\n            _0x32f784 -= balance;\n            _0xf0d534(balance);\n        }\n    }\n\n    function _0xf0d534(uint _0xb8f422) private {\n        uint _0x78e405 = this.balance / 2;\n        if(_0x78e405 >= _0xb8f422) {\n            msg.sender.transfer(_0xb8f422);\n            if(_0xb8f422 > 1 finney) {\n                _0x29aa27();\n            }\n        }\n        else {\n            uint _0x088037 = _0xb8f422 - _0x78e405;\n            _0x32f784 += _0x088037;\n            _0x5e1f38[msg.sender].balance += uint208(_0x088037);\n            _0x5e1f38[msg.sender]._0x81f71a = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\n            msg.sender.transfer(_0x78e405);\n        }\n    }\n\n/* investment functions */\n\n    function _0x679fe1() payable external {\n        _0x771d28(_0x50a488);\n    }\n\n    function _0x771d28(address _0xccb8b7) payable public {\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\n        require(_0x336e91 > 1 && block.number < _0x336e91 + (_0xbd973e * 5) && _0x698eb0 < _0xef6de2);\n        uint _0x88d79c = msg.value;\n        if(_0x88d79c > _0xef6de2 - _0x698eb0) {\n            if (true) { _0x88d79c = _0xef6de2 - _0x698eb0; }\n            _0x698eb0 = _0xef6de2;\n            _0x336e91 = 0; // close investment round\n            msg.sender.transfer(msg.value._0x330500(_0x88d79c)); // send back funds immediately\n        }\n        else{\n            _0x698eb0 += _0x88d79c;\n        }\n        if(_0xccb8b7 == address(0) || _0xccb8b7 == _0x50a488){\n            _0x32f784 += _0x88d79c / 10;\n            _0x5e1f38[_0x50a488].balance += uint208(_0x88d79c / 10);} // 10% for marketing if no affiliates\n        else{\n            _0x32f784 += (_0x88d79c * 5 / 100) * 2;\n            _0x5e1f38[_0x50a488].balance += uint208(_0x88d79c * 5 / 100); // 5% initial marketing funds\n            _0x5e1f38[_0xccb8b7].balance += uint208(_0x88d79c * 5 / 100);} // 5% for affiliates\n        _0x5e1f38[msg.sender]._0x432b83 = uint16(_0x6738a1); // assert(dividendPeriod == 1);\n        uint _0x72277c = _0x88d79c / 10**15;\n        uint _0x29d386 = _0x88d79c * 16 / 10**17  ;\n        uint _0xdb67f8 = _0x88d79c * 10 / 10**17  ;\n        _0xd89c86[msg.sender] += _0x72277c;\n        _0xd89c86[_0x50a488] += _0x29d386 ; // 13% of shares go to developers\n        _0xd89c86[_0x2e62a7] += _0xdb67f8 ; // 8% of shares go to animator\n        _0xd3cd25 += _0x72277c + _0x29d386 + _0xdb67f8;\n        Transfer(address(0),msg.sender,_0x72277c); // for etherscan\n        Transfer(address(0),_0x50a488,_0x29d386); // for etherscan\n        Transfer(address(0),_0x2e62a7,_0xdb67f8); // for etherscan\n        LogInvestment(msg.sender,_0xccb8b7,_0x88d79c);\n    }\n\n    function _0x143392() external {\n        require(_0x336e91 == 0);\n        _0x7216d2(msg.sender);\n        uint _0x6e7e49 = _0xd89c86[msg.sender] * 10**15;\n        Transfer(msg.sender,address(0),_0xd89c86[msg.sender]); // for etherscan\n        delete _0xd89c86[msg.sender]; // totalSupply stays the same, investBalance is reduced\n        _0x698eb0 -= _0x6e7e49;\n        _0x5e1f38[msg.sender].balance += uint208(_0x6e7e49 * 9 / 10);\n        _0x6b5c7b();\n    }\n\n    function _0x5fb42f() external {\n        require(_0x336e91 == 0);\n        _0x7216d2(msg.sender);\n        _0x6b5c7b();\n    }\n\n    function _0x7216d2(address _0x7fb89a) internal {\n        uint _0x134a05 = _0x5e1f38[_0x7fb89a]._0x432b83;\n        if((_0xd89c86[_0x7fb89a]==0) || (_0x134a05==0)){\n            _0x5e1f38[_0x7fb89a]._0x432b83=uint16(_0x6738a1);\n            return;\n        }\n        if(_0x134a05==_0x6738a1) {\n            return;\n        }\n        uint _0xc3ee1c = _0xd89c86[_0x7fb89a] * 0xffffffff / _0xd3cd25;\n        uint balance = 0;\n        for(;_0x134a05<_0x6738a1;_0x134a05++) {\n            balance += _0xc3ee1c * _0x224581[_0x134a05];\n        }\n        balance = (balance / 0xffffffff);\n        _0x32f784 += balance;\n        _0x5e1f38[_0x7fb89a].balance += uint208(balance);\n        _0x5e1f38[_0x7fb89a]._0x432b83 = uint16(_0x134a05);\n        LogDividend(_0x7fb89a,balance,_0x134a05);\n    }\n\n/* lottery functions */\n\n    function _0xb5cce3(Bet _0xdb6075, uint24 _0x2eec08) constant private returns (uint) { // house fee 13.85%\n        uint24 _0xf9f77e = uint24(_0xdb6075._0x5716fa);\n        uint24 _0xab1101 = _0xf9f77e ^ _0x2eec08;\n        uint24 _0x11df20 =\n            ((_0xab1101 & 0xF) == 0 ? 1 : 0 ) +\n            ((_0xab1101 & 0xF0) == 0 ? 1 : 0 ) +\n            ((_0xab1101 & 0xF00) == 0 ? 1 : 0 ) +\n            ((_0xab1101 & 0xF000) == 0 ? 1 : 0 ) +\n            ((_0xab1101 & 0xF0000) == 0 ? 1 : 0 ) +\n            ((_0xab1101 & 0xF00000) == 0 ? 1 : 0 );\n        if(_0x11df20 == 6){\n            return(uint(_0xdb6075.value) * 7000000);\n        }\n        if(_0x11df20 == 5){\n            return(uint(_0xdb6075.value) * 20000);\n        }\n        if(_0x11df20 == 4){\n            return(uint(_0xdb6075.value) * 500);\n        }\n        if(_0x11df20 == 3){\n            return(uint(_0xdb6075.value) * 25);\n        }\n        if(_0x11df20 == 2){\n            return(uint(_0xdb6075.value) * 3);\n        }\n        return(0);\n    }\n\n    function _0x87d286(address _0x7fb89a) constant external returns (uint)  {\n        Bet memory _0xbc904f = _0x503ecd[_0x7fb89a];\n        if( (_0xbc904f.value==0) ||\n            (_0xbc904f._0x1b5107<=1) ||\n            (block.number<_0xbc904f._0x1b5107) ||\n            (block.number>=_0xbc904f._0x1b5107 + (10 * _0xbd973e))){\n            return(0);\n        }\n        if(block.number<_0xbc904f._0x1b5107+256){\n            return(_0xb5cce3(_0xbc904f,uint24(block.blockhash(_0xbc904f._0x1b5107))));\n        }\n        if(_0x31065c>0){\n            uint32 _0x7ed265 = _0x0c0455(_0xbc904f._0x1b5107);\n            if(_0x7ed265 == 0x1000000) { // load hash failed :-(, return funds\n                return(uint(_0xbc904f.value));\n            }\n            else{\n                return(_0xb5cce3(_0xbc904f,uint24(_0x7ed265)));\n            }\n\t}\n        return(0);\n    }\n\n    function _0xa8cea4() public {\n        Bet memory _0xbc904f = _0x503ecd[msg.sender];\n        if(_0xbc904f._0x1b5107==0){ // create a new player\n            _0x503ecd[msg.sender] = Bet({value: 0, _0x5716fa: 0, _0x1b5107: 1});\n            return;\n        }\n        if((_0xbc904f.value==0) || (_0xbc904f._0x1b5107==1)){\n            _0x6b5c7b();\n            return;\n        }\n        require(block.number>_0xbc904f._0x1b5107); // if there is an active bet, throw()\n        if(_0xbc904f._0x1b5107 + (10 * _0xbd973e) <= block.number){ // last bet too long ago, lost !\n            LogLate(msg.sender,_0xbc904f._0x1b5107,block.number);\n            _0x503ecd[msg.sender] = Bet({value: 0, _0x5716fa: 0, _0x1b5107: 1});\n            return;\n        }\n        uint _0xf1699d = 0;\n        uint32 _0x7ed265 = 0;\n        if(block.number<_0xbc904f._0x1b5107+256){\n            if (msg.sender != address(0) || msg.sender == address(0)) { _0x7ed265 = uint24(block.blockhash(_0xbc904f._0x1b5107)); }\n            _0xf1699d = _0xb5cce3(_0xbc904f,uint24(_0x7ed265));\n        }\n        else {\n            if(_0x31065c>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\n                if (block.timestamp > 0) { _0x7ed265 = _0x0c0455(_0xbc904f._0x1b5107); }\n                if(_0x7ed265 == 0x1000000) { // load hash failed :-(, return funds\n                    _0xf1699d = uint(_0xbc904f.value);\n                }\n                else{\n                    _0xf1699d = _0xb5cce3(_0xbc904f,uint24(_0x7ed265));\n                }\n\t    }\n            else{\n                LogLate(msg.sender,_0xbc904f._0x1b5107,block.number);\n                _0x503ecd[msg.sender] = Bet({value: 0, _0x5716fa: 0, _0x1b5107: 1});\n                return();\n            }\n        }\n        _0x503ecd[msg.sender] = Bet({value: 0, _0x5716fa: 0, _0x1b5107: 1});\n        if(_0xf1699d>0) {\n            LogWin(msg.sender,uint(_0xbc904f._0x5716fa),uint(_0x7ed265),_0xf1699d);\n            if(_0xf1699d > _0xca264e){\n                _0xca264e = _0xf1699d;\n                LogRecordWin(msg.sender,_0xf1699d);\n            }\n            _0xf0d534(_0xf1699d);\n        }\n        else{\n            LogLoss(msg.sender,uint(_0xbc904f._0x5716fa),uint(_0x7ed265));\n        }\n    }\n\n    function () payable external {\n        if(msg.value > 0){\n            if(_0x336e91>1){ // during ICO payment to the contract is treated as investment\n                _0x771d28(_0x50a488);\n            }\n            else{ // if not ICO running payment to contract is treated as play\n                _0xaaf82f();\n            }\n            return;\n        }\n        //check for dividends and other assets\n        if(_0x336e91 == 0 && _0xd89c86[msg.sender]>0){\n            _0x7216d2(msg.sender);}\n        _0xa8cea4(); // will run payWallet() if nothing else available\n    }\n\n    function _0xaaf82f() payable public returns (uint) {\n        return _0xe542a2(uint(_0x8269f7(msg.sender,block.number)), address(0));\n    }\n\n    function _0x0f5709(address _0xccb8b7) payable public returns (uint) {\n        return _0xe542a2(uint(_0x8269f7(msg.sender,block.number)), _0xccb8b7);\n    }\n\n    function _0xe542a2(uint _0x2eec08, address _0xccb8b7) payable public returns (uint) {\n        _0xa8cea4(); // check if player did not win\n        uint24 _0xf9f77e = uint24(_0x2eec08);\n        require(msg.value <= 1 ether && msg.value < _0x293c1b);\n        if(msg.value > 0){\n            if(_0x336e91==0) { // dividends only after investment finished\n                _0x224581[_0x6738a1] += msg.value / 20; // 5% dividend\n            }\n            if(_0xccb8b7 != address(0)) {\n                uint _0xda985f = msg.value / 100;\n                _0x32f784 += _0xda985f;\n                _0x5e1f38[_0xccb8b7].balance += uint208(_0xda985f); // 1% for affiliates\n            }\n            if(_0x66251d < block.number + 3) {\n                if (gasleft() > 0) { _0x66251d = block.number + 3; }\n                _0x88e578 = msg.value;\n            }\n            else{\n                if(_0x88e578 > _0x293c1b) {\n                    _0x66251d++;\n                    if (true) { _0x88e578 = msg.value; }\n                }\n                else{\n                    _0x88e578 += msg.value;\n                }\n            }\n            _0x503ecd[msg.sender] = Bet({value: uint192(msg.value), _0x5716fa: uint32(_0xf9f77e), _0x1b5107: uint32(_0x66251d)});\n            LogBet(msg.sender,uint(_0xf9f77e),_0x66251d,msg.value);\n        }\n        _0x4cd01c(); // players help collecing data\n        return(_0x66251d);\n    }\n\n/* database functions */\n\n    function _0x0f11fa(uint _0x22284e) public returns (uint) {\n        require(_0x31065c == 0 && _0x22284e > 0 && _0x22284e <= _0xbd973e);\n        uint n = _0x5eb69a.length;\n        if(n + _0x22284e > _0xbd973e){\n            _0x5eb69a.length = _0xbd973e;\n        }\n        else{\n            _0x5eb69a.length += _0x22284e;\n        }\n        for(;n<_0x5eb69a.length;n++){ // make sure to burn gas\n            _0x5eb69a[n] = 1;\n        }\n        if(_0x5eb69a.length>=_0xbd973e) { // assume block.number > 10\n            _0x31065c = block.number - ( block.number % 10);\n            _0xb190da = _0x31065c;\n        }\n        return(_0x5eb69a.length);\n    }\n\n    function _0xd34a12() external returns (uint) {\n        return(_0x0f11fa(128));\n    }\n\n    function _0x32d14e(uint32 _0xf5e413, uint32 _0x21c865) constant private returns (uint) {\n        return( ( uint(block.blockhash(_0xf5e413  )) & 0xFFFFFF )\n            | ( ( uint(block.blockhash(_0xf5e413+1)) & 0xFFFFFF ) << 24 )\n            | ( ( uint(block.blockhash(_0xf5e413+2)) & 0xFFFFFF ) << 48 )\n            | ( ( uint(block.blockhash(_0xf5e413+3)) & 0xFFFFFF ) << 72 )\n            | ( ( uint(block.blockhash(_0xf5e413+4)) & 0xFFFFFF ) << 96 )\n            | ( ( uint(block.blockhash(_0xf5e413+5)) & 0xFFFFFF ) << 120 )\n            | ( ( uint(block.blockhash(_0xf5e413+6)) & 0xFFFFFF ) << 144 )\n            | ( ( uint(block.blockhash(_0xf5e413+7)) & 0xFFFFFF ) << 168 )\n            | ( ( uint(block.blockhash(_0xf5e413+8)) & 0xFFFFFF ) << 192 )\n            | ( ( uint(block.blockhash(_0xf5e413+9)) & 0xFFFFFF ) << 216 )\n            | ( ( uint(_0x21c865) / _0xbd973e) << 240));\n    }\n\n    function _0x0c0455(uint _0xe7025c) constant private returns (uint32) {\n        uint _0x50e328 = (_0xe7025c - _0x31065c) / 10;\n        uint _0x7ed265 = _0x5eb69a[_0x50e328 % _0xbd973e];\n        if(_0x50e328 / _0xbd973e != _0x7ed265 >> 240) {\n            return(0x1000000); // load failed, incorrect data in hashes\n        }\n        uint _0x8f38fb = (_0xe7025c - _0x31065c) % 10;\n        return(uint32((_0x7ed265 >> (24 * _0x8f38fb)) & 0xFFFFFF));\n    }\n\n    function _0x4cd01c() public returns (bool) {\n        uint _0x1a7dc4 = _0xb190da;\n        if(_0x1a7dc4 == 0 || block.number <= _0x1a7dc4 + 10) {\n            return(false);\n        }\n        uint _0x224578;\n        if(block.number<256) { // useless test for testnet :-(\n            if (true) { _0x224578 = 0; }\n        }\n        else{\n            _0x224578 = block.number - 256;\n        }\n        if(_0x1a7dc4 < _0x224578) {\n            uint _0x249652 = _0x224578;\n            _0x249652 += _0x249652 % 10;\n            _0x1a7dc4 = _0x249652;\n        }\n        uint _0x50e328 = (_0x1a7dc4 - _0x31065c) / 10;\n        _0x5eb69a[_0x50e328 % _0xbd973e] = _0x32d14e(uint32(_0x1a7dc4),uint32(_0x50e328));\n        _0xb190da = _0x1a7dc4 + 10;\n        return(true);\n    }\n\n    function _0x2e122e(uint _0x2da9af) external {\n        uint n=0;\n        for(;n<_0x2da9af;n++){\n            if(!_0x4cd01c()){\n                return;\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "currentBlockNumber": "_0x047bd6",
        "lastDividendPeriod": "_0x432b83",
        "playerBlockNumber": "_0x081a50",
        "initialInvestment": "_0x6e7e49",
        "nextWithdrawBlock": "_0x81f71a",
        "investBalanceMax": "_0xef6de2",
        "betBlockNumberOf": "_0x9de658",
        "dividendsBlocks": "_0x68922f",
        "walletBalanceOf": "_0x79cf77",
        "animatorBalance": "_0xdb67f8",
        "onlyPayloadSize": "_0xafde03",
        "changeAnimator": "_0x241cf2",
        "dividendPeriod": "_0x6738a1",
        "walletPeriodOf": "_0x0c5a27",
        "setInvestStart": "_0xf50feb",
        "commitDividend": "_0x7216d2",
        "walletBlockOf": "_0x1840a0",
        "coldStoreLast": "_0xb854b6",
        "senderBalance": "_0x72277c",
        "investBalance": "_0x698eb0",
        "walletBalance": "_0x32f784",
        "onlyAnimator": "_0xcab4c7",
        "transferFrom": "_0x4b3fe4",
        "hashesLength": "_0x4de3d2",
        "investDirect": "_0x679fe1",
        "houseKeeping": "_0x29aa27",
        "payDividends": "_0x5fb42f",
        "ownerBalance": "_0x29d386",
        "addHashes128": "_0xd34a12",
        "changeOwner": "_0xb71ae8",
        "investStart": "_0x336e91",
        "keepbalance": "_0x088037",
        "blocknumber": "_0xc2d5d3",
        "totalSupply": "_0xd3cd25",
        "hashBetMax": "_0x293c1b",
        "hashesSize": "_0xbd973e",
        "betValueOf": "_0x41330b",
        "hashBetSum": "_0x88e578",
        "_allowance": "_0x4a1aa6",
        "calcHashes": "_0x32d14e",
        "playRandom": "_0x0f5709",
        "playSystem": "_0xe542a2",
        "balanceOf": "_0x993698",
        "disinvest": "_0x143392",
        "addHashes": "_0x0f11fa",
        "putHashes": "_0x2e122e",
        "dividends": "_0x224581",
        "setBetMax": "_0x30f874",
        "blockn256": "_0x224578",
        "investing": "_0x88d79c",
        "onlyOwner": "_0x100f01",
        "betHashOf": "_0xb4342b",
        "remaining": "_0xa0fc2e",
        "payWallet": "_0x6b5c7b",
        "hashFirst": "_0x31065c",
        "coldStore": "_0x433a0a",
        "allowance": "_0x2473a1",
        "hotStore": "_0x7ad8d6",
        "investor": "_0x68e703",
        "hashNext": "_0x66251d",
        "_partner": "_0xccb8b7",
        "decimals": "_0x32000a",
        "_spender": "_0x8914e8",
        "hashLast": "_0xb190da",
        "resetBet": "_0xd20b1e",
        "blockNum": "_0x1b5107",
        "animator": "_0x2e62a7",
        "balances": "_0xd89c86",
        "betPrize": "_0xb5cce3",
        "_amount": "_0xb8f422",
        "approve": "_0x161bc1",
        "wallets": "_0x5e1f38",
        "betsize": "_0x159f47",
        "bethash": "_0xf9f77e",
        "allowed": "_0x96b65b",
        "_player": "_0xdb6075",
        "matches": "_0x11df20",
        "getHash": "_0x0c0455",
        "_maxsum": "_0xe8e3c9",
        "putHash": "_0x4cd01c",
        "partner": "_0xa48b13",
        "betHash": "_0x5716fa",
        "spender": "_0xb8c331",
        "_value": "_0x951b29",
        "hashes": "_0x5eb69a",
        "period": "_0xf36143",
        "maxWin": "_0xca264e",
        "_block": "_0xe7025c",
        "_delta": "_0x21c865",
        "symbol": "_0x614c5e",
        "maxpay": "_0x78e405",
        "_lastb": "_0xf5e413",
        "player": "_0xbc904f",
        "amount": "_0x2da7df",
        "_owner": "_0xa8cc7b",
        "invest": "_0x771d28",
        "betOf": "_0x87d286",
        "_when": "_0xbb030f",
        "share": "_0xc3ee1c",
        "delta": "_0x50e328",
        "owner": "_0x50a488",
        "prize": "_0xf1699d",
        "slotp": "_0x8f38fb",
        "lastb": "_0x1a7dc4",
        "_sadd": "_0x22284e",
        "_hash": "_0x2eec08",
        "_from": "_0xc70665",
        "name": "_0x18f173",
        "play": "_0xaaf82f",
        "hash": "_0x7ed265",
        "bets": "_0x503ecd",
        "sha3": "_0x8269f7",
        "_who": "_0x7fb89a",
        "size": "_0xcb6c88",
        "_num": "_0x2da9af",
        "last": "_0x134a05",
        "pay": "_0xf0d534",
        "who": "_0x216a87",
        "sub": "_0x330500",
        "num": "_0x249652",
        "add": "_0xa1d47b",
        "won": "_0xa8cea4",
        "fee": "_0xda985f",
        "_to": "_0x304d65",
        "hit": "_0xab1101",
        "to": "_0x7c29ef"
      },
      "changes": [
        "Renamed 126 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_001",
      "transformed_id": "ss_l3_medium_sn_gs_001",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title GovernanceHYBR (gHYBR)\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\n */\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Lock period for new deposits (configurable between 12-24 hours)\n    uint256 public _0xbe2390 = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public _0x0dc852 = 1200; // 5days\n    uint256 public _0xf80792 = 300; // 1day\n\n    // Withdraw fee configuration (basis points, 10000 = 100%)\n    uint256 public _0x3d0f4f = 100; // 1% default fee\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\n    uint256 public constant BASIS = 10000;\n    address public Team; // Address to receive fees\n    uint256 public _0x955bbb;\n    uint256 public _0xbb663d;\n    uint256 public _0x95c23e;\n    // User deposit tracking for transfer locks\n    struct UserLock {\n        uint256 _0x1b3d67;\n        uint256 _0x7d3e11;\n    }\n\n    mapping(address => UserLock[]) public _0xd0ddf3;\n    mapping(address => uint256) public _0x92082b;\n\n    // Core contracts\n    address public immutable HYBR;\n    address public immutable _0xf973eb;\n    address public _0x73b9b8;\n    address public _0x32463b;\n    address public _0x29d856;\n    uint256 public _0x4d642b; // The veNFT owned by this contract\n\n    // Auto-voting strategy\n    address public _0x47eaa7; // Address that can manage voting strategy\n    uint256 public _0x8662a8; // Last epoch when we voted\n\n    // Reward tracking\n    uint256 public _0x222cf5;\n    uint256 public _0x78b0f4;\n\n    // Swap module\n    ISwapper public _0xf0fa28;\n\n    // Errors\n    error NOT_AUTHORIZED();\n\n    // Events\n    event Deposit(address indexed _0xc4cb9f, uint256 _0x3290a4, uint256 _0x19666b);\n    event Withdraw(address indexed _0xc4cb9f, uint256 _0xd0f815, uint256 _0x3290a4, uint256 _0xe3e2c3);\n    event Compound(uint256 _0x8be3a2, uint256 _0x496b91);\n    event PenaltyRewardReceived(uint256 _0x1b3d67);\n    event TransferLockPeriodUpdated(uint256 _0x30b604, uint256 _0x30ae58);\n    event SwapperUpdated(address indexed _0x0ef62e, address indexed _0x869361);\n    event VoterSet(address _0x73b9b8);\n    event EmergencyUnlock(address indexed _0xc4cb9f);\n    event AutoVotingEnabled(bool _0x80b1c8);\n    event OperatorUpdated(address indexed _0x2bbadb, address indexed _0x5985ac);\n    event DefaultVotingStrategyUpdated(address[] _0xa058c4, uint256[] _0x958ebe);\n    event AutoVoteExecuted(uint256 _0x1fdd42, address[] _0xa058c4, uint256[] _0x958ebe);\n\n    constructor(\n        address _0x435a3d,\n        address _0xd0fcb9\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_0x435a3d != address(0), \"Invalid HYBR\");\n        require(_0xd0fcb9 != address(0), \"Invalid VE\");\n\n        HYBR = _0x435a3d;\n        _0xf973eb = _0xd0fcb9;\n        _0x222cf5 = block.timestamp;\n        _0x78b0f4 = block.timestamp;\n        _0x47eaa7 = msg.sender; // Initially set deployer as operator\n    }\n\n    function _0x67103b(address _0xb97b58) external _0xc34fba {\n        require(_0xb97b58 != address(0), \"Invalid rewards distributor\");\n        _0x32463b = _0xb97b58;\n    }\n\n    function _0xb0608d(address _0x9aa5f8) external _0xc34fba {\n        require(_0x9aa5f8 != address(0), \"Invalid gauge manager\");\n        _0x29d856 = _0x9aa5f8;\n    }\n\n      /**\n     * @notice Modifier to check authorization (owner or operator)\n     */\n    modifier _0xedbc8f() {\n        if (msg.sender != _0x47eaa7) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n    /**\n     * @notice Deposit HYBR and receive gHYBR shares\n     * @param amount Amount of HYBR to deposit\n     * @param recipient Recipient of gHYBR shares\n     */\n    function _0xf64c1b(uint256 _0x1b3d67, address _0xefe868) external _0x78f0a4 {\n        require(_0x1b3d67 > 0, \"Zero amount\");\n        _0xefe868 = _0xefe868 == address(0) ? msg.sender : _0xefe868;\n\n        // Transfer HYBR from user first\n        IERC20(HYBR)._0x10db0a(msg.sender, address(this), _0x1b3d67);\n\n        // Initialize veNFT on first deposit\n        if (_0x4d642b == 0) {\n            _0xb8d615(_0x1b3d67);\n        } else {\n            // Add to existing veNFT\n            IERC20(HYBR)._0x152e36(_0xf973eb, _0x1b3d67);\n            IVotingEscrow(_0xf973eb)._0x1841e0(_0x4d642b, _0x1b3d67);\n\n            // Extend lock to maximum duration\n            _0x058960();\n        }\n\n        // Calculate shares to mint based on current totalAssets\n        uint256 _0xd0f815 = _0xe71b00(_0x1b3d67);\n\n        // Mint gHYBR shares\n        _0xbdf3eb(_0xefe868, _0xd0f815);\n\n        // Add transfer lock for recipient\n        _0xfd84d0(_0xefe868, _0xd0f815);\n\n        emit Deposit(msg.sender, _0x1b3d67, _0xd0f815);\n    }\n\n    /**\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\n     * @param shares Amount of gHYBR shares to burn\n     * @return userTokenId The ID of the new veNFT created for the user\n     */\n    function _0x34c1af(uint256 _0xd0f815) external _0x78f0a4 returns (uint256 _0xb81f0b) {\n        require(_0xd0f815 > 0, \"Zero shares\");\n        require(_0x6d6164(msg.sender) >= _0xd0f815, \"Insufficient balance\");\n        require(_0x4d642b != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(_0xf973eb)._0x13e23f(_0x4d642b) == false, \"Cannot withdraw yet\");\n\n        uint256 _0xfc7860 = HybraTimeLibrary._0xfc7860(block.timestamp);\n        uint256 _0xe601dc = HybraTimeLibrary._0xe601dc(block.timestamp);\n\n        require(block.timestamp >= _0xfc7860 + _0x0dc852 && block.timestamp < _0xe601dc - _0xf80792, \"Cannot withdraw yet\");\n\n        // Calculate proportional HYBR amount from veNFT\n        uint256 _0x3290a4 = _0x43c5e7(_0xd0f815);\n        require(_0x3290a4 > 0, \"No assets to withdraw\");\n\n        // Calculate fee amount (from the HYBR amount, not shares)\n        uint256 _0xdc5c10 = 0;\n        if (_0x3d0f4f > 0) {\n            _0xdc5c10 = (_0x3290a4 * _0x3d0f4f) / BASIS;\n        }\n\n        // User receives amount minus fee\n        uint256 _0x31b902 = _0x3290a4 - _0xdc5c10;\n        require(_0x31b902 > 0, \"Amount too small after fee\");\n\n        // Get actual HYBR locked amount (not voting power)\n        uint256 _0xaa2a69 = _0xbb9eb9();\n        require(_0x3290a4 <= _0xaa2a69, \"Insufficient veNFT balance\");\n\n        uint256 _0xf5a3d1 = _0xaa2a69 - _0x31b902 - _0xdc5c10;\n        require(_0xf5a3d1 >= 0, \"Cannot withdraw entire veNFT\");\n\n        // Burn gHYBR shares (full amount)\n        _0x6c3a7d(msg.sender, _0xd0f815);\n\n        // Use multiSplit to create two NFTs: one for user, one for contract\n        uint256[] memory _0xebbc05 = new uint256[](3);\n        _0xebbc05[0] = _0xf5a3d1; // Amount staying with gHYBR\n        _0xebbc05[1] = _0x31b902;      // Amount going to user (after fee)\n        _0xebbc05[2] = _0xdc5c10;      // Amount going to fee recipient\n\n        uint256[] memory _0x6ee3bd = IVotingEscrow(_0xf973eb)._0x7c4cb5(_0x4d642b, _0xebbc05);\n\n        // Update contract's veTokenId to the first new token\n        _0x4d642b = _0x6ee3bd[0];\n        if (1 == 1) { _0xb81f0b = _0x6ee3bd[1]; }\n        uint256 _0x8d2652 = _0x6ee3bd[2];\n        // Note: userTokenId is transferred to user, they can manage their own lock time\n        IVotingEscrow(_0xf973eb)._0xacb51c(address(this), msg.sender, _0xb81f0b);\n        IVotingEscrow(_0xf973eb)._0xacb51c(address(this), Team, _0x8d2652);\n        emit Withdraw(msg.sender, _0xd0f815, _0x31b902, _0xdc5c10);\n    }\n\n    /**\n     * @notice Internal function to initialize veNFT on first deposit\n     */\n    function _0xb8d615(uint256 _0xae0c53) internal {\n        // Create max lock with the initial deposit amount\n        IERC20(HYBR)._0x152e36(_0xf973eb, type(uint256)._0x0c0d19);\n        uint256 _0x97e6f9 = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n        // Create lock with initial amount\n        _0x4d642b = IVotingEscrow(_0xf973eb)._0x308b87(_0xae0c53, _0x97e6f9, address(this));\n\n    }\n\n    /**\n     * @notice Calculate shares to mint based on deposit amount\n     */\n    function _0xe71b00(uint256 _0x1b3d67) public view returns (uint256) {\n        uint256 _0x0fa401 = _0x0179fb();\n        uint256 _0xd9e5c4 = _0xbb9eb9();\n        if (_0x0fa401 == 0 || _0xd9e5c4 == 0) {\n            return _0x1b3d67;\n        }\n        return (_0x1b3d67 * _0x0fa401) / _0xd9e5c4;\n    }\n\n    /**\n     * @notice Calculate HYBR value of shares\n     */\n    function _0x43c5e7(uint256 _0xd0f815) public view returns (uint256) {\n        uint256 _0x0fa401 = _0x0179fb();\n        if (_0x0fa401 == 0) {\n            return _0xd0f815;\n        }\n        return (_0xd0f815 * _0xbb9eb9()) / _0x0fa401;\n    }\n\n    /**\n     * @notice Get total assets (HYBR) locked in veNFT\n     * @dev Returns actual HYBR amount, not voting power\n     */\n    function _0xbb9eb9() public view returns (uint256) {\n        if (_0x4d642b == 0) {\n            return 0;\n        }\n        // Get actual locked HYBR amount, not voting power\n        IVotingEscrow.LockedBalance memory _0x62d34b = IVotingEscrow(_0xf973eb)._0x62d34b(_0x4d642b);\n        return uint256(int256(_0x62d34b._0x1b3d67));\n    }\n\n    /**\n     * @notice Add transfer lock for new deposits\n     */\n    function _0xfd84d0(address _0xc4cb9f, uint256 _0x1b3d67) internal {\n        uint256 _0x7d3e11 = block.timestamp + _0xbe2390;\n        _0xd0ddf3[_0xc4cb9f].push(UserLock({\n            _0x1b3d67: _0x1b3d67,\n            _0x7d3e11: _0x7d3e11\n        }));\n        _0x92082b[_0xc4cb9f] += _0x1b3d67;\n    }\n\n    /**\n     * @notice Preview available balance (total - currently locked)\n     * @param user The user address to check\n     * @return available The current available balance for transfer\n     */\n    function _0x770a2d(address _0xc4cb9f) external view returns (uint256 _0xc5a7af) {\n        uint256 _0xcb489a = _0x6d6164(_0xc4cb9f);\n        uint256 _0xd1ae56 = 0;\n\n        UserLock[] storage _0xa5db0c = _0xd0ddf3[_0xc4cb9f];\n        for (uint256 i = 0; i < _0xa5db0c.length; i++) {\n            if (_0xa5db0c[i]._0x7d3e11 > block.timestamp) {\n                _0xd1ae56 += _0xa5db0c[i]._0x1b3d67;\n            }\n        }\n\n        return _0xcb489a > _0xd1ae56 ? _0xcb489a - _0xd1ae56 : 0;\n    }\n    /**\n     * @notice Clean expired locks and update locked balance\n     * @param user The user address to clean locks for\n     * @return freed The amount of tokens freed from expired locks\n     */\n    function _0xfb6bf1(address _0xc4cb9f) internal returns (uint256 _0xfc8dcf) {\n        UserLock[] storage _0xa5db0c = _0xd0ddf3[_0xc4cb9f];\n        uint256 _0x9b2758 = _0xa5db0c.length;\n        if (_0x9b2758 == 0) return 0;\n\n        uint256 _0x95644e = 0;\n        unchecked {\n            for (uint256 i = 0; i < _0x9b2758; i++) {\n                UserLock memory L = _0xa5db0c[i];\n                if (L._0x7d3e11 <= block.timestamp) {\n                    _0xfc8dcf += L._0x1b3d67;\n                } else {\n                    if (_0x95644e != i) _0xa5db0c[_0x95644e] = L;\n                    _0x95644e++;\n                }\n            }\n            if (_0xfc8dcf > 0) {\n                _0x92082b[_0xc4cb9f] -= _0xfc8dcf;\n            }\n            while (_0xa5db0c.length > _0x95644e) {\n                _0xa5db0c.pop();\n            }\n        }\n    }\n\n    /**\n     * @notice Override transfer to implement lock mechanism\n     */\n    function _0x40ac0f(\n        address from,\n        address _0x83f025,\n        uint256 _0x1b3d67\n    ) internal override {\n        super._0x40ac0f(from, _0x83f025, _0x1b3d67);\n\n        if (from != address(0) && _0x83f025 != address(0)) { // Not mint or burn\n            uint256 _0xcb489a = _0x6d6164(from);\n\n            // Step 1: Check current available balance using cached lockedBalance\n            uint256 _0x95163a = _0xcb489a > _0x92082b[from] ? _0xcb489a - _0x92082b[from] : 0;\n\n            // Step 2: If current available >= amount, pass directly\n            if (_0x95163a >= _0x1b3d67) {\n                return;\n            }\n\n            // Step 3: Not enough, clean expired locks and recalculate\n            _0xfb6bf1(from);\n            uint256 _0x5b0a51 = _0xcb489a > _0x92082b[from] ? _0xcb489a - _0x92082b[from] : 0;\n\n            // Step 4: Check final available balance\n            require(_0x5b0a51 >= _0x1b3d67, \"Tokens locked\");\n        }\n    }\n\n    /**\n     * @notice Claim all rewards from voting and rebase\n     */\n    function _0x97f764() external _0xedbc8f {\n        require(_0x73b9b8 != address(0), \"Voter not set\");\n        require(_0x32463b != address(0), \"Distributor not set\");\n\n        // Claim rebase rewards from RewardsDistributor\n        uint256  _0x5586ab = IRewardsDistributor(_0x32463b)._0x805b04(_0x4d642b);\n        _0x955bbb += _0x5586ab;\n        // Claim bribes from voted pools\n        address[] memory _0xbf7432 = IVoter(_0x73b9b8)._0x3db4b1(_0x4d642b);\n\n        for (uint256 i = 0; i < _0xbf7432.length; i++) {\n            if (_0xbf7432[i] != address(0)) {\n                address _0xd5c1ad = IGaugeManager(_0x29d856)._0x9c9478(_0xbf7432[i]);\n\n                if (_0xd5c1ad != address(0)) {\n                    // Prepare arrays for single bribe claim\n                    address[] memory _0x44be78 = new address[](1);\n                    address[][] memory _0xef073f = new address[][](1);\n\n                    // Claim internal bribe (trading fees)\n                    address _0xd9adf9 = IGaugeManager(_0x29d856)._0x616fcc(_0xd5c1ad);\n                    if (_0xd9adf9 != address(0)) {\n                        uint256 _0x7f91e6 = IBribe(_0xd9adf9)._0x0a203b();\n                        if (_0x7f91e6 > 0) {\n                            address[] memory _0xdbf79c = new address[](_0x7f91e6);\n                            for (uint256 j = 0; j < _0x7f91e6; j++) {\n                                _0xdbf79c[j] = IBribe(_0xd9adf9)._0xdbf79c(j);\n                            }\n                            _0x44be78[0] = _0xd9adf9;\n                            _0xef073f[0] = _0xdbf79c;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x29d856)._0x6373ef(_0x44be78, _0xef073f, _0x4d642b);\n                        }\n                    }\n\n                    // Claim external bribe\n                    address _0x0df5c2 = IGaugeManager(_0x29d856)._0x03af4a(_0xd5c1ad);\n                    if (_0x0df5c2 != address(0)) {\n                        uint256 _0x7f91e6 = IBribe(_0x0df5c2)._0x0a203b();\n                        if (_0x7f91e6 > 0) {\n                            address[] memory _0xdbf79c = new address[](_0x7f91e6);\n                            for (uint256 j = 0; j < _0x7f91e6; j++) {\n                                _0xdbf79c[j] = IBribe(_0x0df5c2)._0xdbf79c(j);\n                            }\n                            _0x44be78[0] = _0x0df5c2;\n                            _0xef073f[0] = _0xdbf79c;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x29d856)._0x6373ef(_0x44be78, _0xef073f, _0x4d642b);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Execute swap through the configured swapper module\n     * @param _params Swap parameters for the swapper module\n     */\n    function _0x963d77(ISwapper.SwapParams calldata _0x1929f2) external _0x78f0a4 _0xedbc8f {\n        require(address(_0xf0fa28) != address(0), \"Swapper not set\");\n\n        // Get token balance before swap\n        uint256 _0x49d652 = IERC20(_0x1929f2._0x79c517)._0x6d6164(address(this));\n        require(_0x49d652 >= _0x1929f2._0x7aae48, \"Insufficient token balance\");\n\n        // Approve swapper to spend tokens\n        IERC20(_0x1929f2._0x79c517)._0x94deb6(address(_0xf0fa28), _0x1929f2._0x7aae48);\n\n        // Execute swap through swapper module\n        uint256 _0xf16090 = _0xf0fa28._0x472ac2(_0x1929f2);\n\n        // Reset approval for safety\n        IERC20(_0x1929f2._0x79c517)._0x94deb6(address(_0xf0fa28), 0);\n\n        // HYBR is now in this contract, ready for compounding\n        _0x95c23e += _0xf16090;\n    }\n\n    /**\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\n     */\n    function _0xba6d3e() external _0xedbc8f {\n\n        // Get current HYBR balance\n        uint256 _0xdeceba = IERC20(HYBR)._0x6d6164(address(this));\n\n        if (_0xdeceba > 0) {\n            // Lock all HYBR to existing veNFT\n            IERC20(HYBR)._0x94deb6(_0xf973eb, _0xdeceba);\n            IVotingEscrow(_0xf973eb)._0x1841e0(_0x4d642b, _0xdeceba);\n\n            // Extend lock to maximum duration\n            _0x058960();\n\n            _0x78b0f4 = block.timestamp;\n\n            emit Compound(_0xdeceba, _0xbb9eb9());\n        }\n    }\n\n    /**\n     * @notice Vote for gauges using the veNFT\n     * @param _poolVote Array of pools to vote for\n     * @param _weights Array of weights for each pool\n     */\n    function _0x6f0ee1(address[] calldata _0x57982b, uint256[] calldata _0x81fc74) external {\n        require(msg.sender == _0x382e4b() || msg.sender == _0x47eaa7, \"Not authorized\");\n        require(_0x73b9b8 != address(0), \"Voter not set\");\n\n        IVoter(_0x73b9b8)._0x6f0ee1(_0x4d642b, _0x57982b, _0x81fc74);\n        _0x8662a8 = HybraTimeLibrary._0xfc7860(block.timestamp);\n\n    }\n\n    /**\n     * @notice Reset votes\n     */\n    function _0xd6eb10() external {\n        require(msg.sender == _0x382e4b() || msg.sender == _0x47eaa7, \"Not authorized\");\n        require(_0x73b9b8 != address(0), \"Voter not set\");\n\n        IVoter(_0x73b9b8)._0xd6eb10(_0x4d642b);\n    }\n\n    /**\n     * @notice Receive penalty rewards from rHYBR conversions\n     */\n    function _0x9ab62c(uint256 _0x1b3d67) external {\n\n        // Auto-compound penalty rewards to existing veNFT\n        if (_0x1b3d67 > 0) {\n            IERC20(HYBR)._0x152e36(_0xf973eb, _0x1b3d67);\n\n            if(_0x4d642b == 0){\n                _0xb8d615(_0x1b3d67);\n            } else{\n                IVotingEscrow(_0xf973eb)._0x1841e0(_0x4d642b, _0x1b3d67);\n\n                // Extend lock to maximum duration\n                _0x058960();\n            }\n        }\n        _0xbb663d += _0x1b3d67;\n        emit PenaltyRewardReceived(_0x1b3d67);\n    }\n\n    /**\n     * @notice Set the voter contract\n     */\n    function _0xf47c09(address _0x04e9a0) external _0xc34fba {\n        require(_0x04e9a0 != address(0), \"Invalid voter\");\n        _0x73b9b8 = _0x04e9a0;\n        emit VoterSet(_0x04e9a0);\n    }\n\n    /**\n     * @notice Update transfer lock period\n     */\n    function _0x058672(uint256 _0xffd02e) external _0xc34fba {\n        require(_0xffd02e >= MIN_LOCK_PERIOD && _0xffd02e <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 _0x30b604 = _0xbe2390;\n        _0xbe2390 = _0xffd02e;\n        emit TransferLockPeriodUpdated(_0x30b604, _0xffd02e);\n    }\n\n    /**\n     * @notice Set withdraw fee (in basis points)\n     * @param _fee Fee amount (10-30 basis points)\n     */\n    function _0x744d15(uint256 _0xe57000) external _0xc34fba {\n        require(_0xe57000 >= MIN_WITHDRAW_FEE && _0xe57000 <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        _0x3d0f4f = _0xe57000;\n    }\n\n    function _0x8624e3(uint256 _0xebe4d9) external _0xc34fba {\n        _0x0dc852 = _0xebe4d9;\n    }\n\n    function _0x4c331a(uint256 _0xebe4d9) external _0xc34fba {\n        _0xf80792 = _0xebe4d9;\n    }\n\n    /**\n     * @notice Set the swapper module\n     * @param _swapper Address of the swapper module\n     */\n    function _0xc6f493(address _0x122ae1) external _0xc34fba {\n        require(_0x122ae1 != address(0), \"Invalid swapper\");\n        address _0x0ef62e = address(_0xf0fa28);\n        if (gasleft() > 0) { _0xf0fa28 = ISwapper(_0x122ae1); }\n        emit SwapperUpdated(_0x0ef62e, _0x122ae1);\n    }\n\n    /**\n     * @notice Set the team address\n     */\n    function _0x3a150e(address _0x192916) external _0xc34fba {\n        require(_0x192916 != address(0), \"Invalid team\");\n        if (block.timestamp > 0) { Team = _0x192916; }\n    }\n\n    /**\n     * @notice Emergency unlock for a user (owner only)\n     */\n    function _0x0b82fe(address _0xc4cb9f) external _0xedbc8f {\n        delete _0xd0ddf3[_0xc4cb9f];\n        _0x92082b[_0xc4cb9f] = 0;\n        emit EmergencyUnlock(_0xc4cb9f);\n    }\n\n    /**\n     * @notice Get user's locks info\n     */\n    function _0x03d5fc(address _0xc4cb9f) external view returns (UserLock[] memory) {\n        return _0xd0ddf3[_0xc4cb9f];\n    }\n\n    /**\n     * @notice Set operator address\n     */\n    function _0xbc3aaa(address _0x5439e1) external _0xc34fba {\n        require(_0x5439e1 != address(0), \"Invalid operator\");\n        address _0x2bbadb = _0x47eaa7;\n        _0x47eaa7 = _0x5439e1;\n        emit OperatorUpdated(_0x2bbadb, _0x5439e1);\n    }\n\n    /**\n     * @notice Get veNFT lock end time\n     */\n    function _0x19e091() external view returns (uint256) {\n        if (_0x4d642b == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory _0x62d34b = IVotingEscrow(_0xf973eb)._0x62d34b(_0x4d642b);\n        return uint256(_0x62d34b._0x5e1b09);\n    }\n\n    /**\n     * @notice Internal helper to safely extend lock to maximum duration\n     * @dev Calculates exact duration needed to reach max allowed unlock time\n     */\n    function _0x058960() internal {\n        if (_0x4d642b == 0) return;\n\n        IVotingEscrow.LockedBalance memory _0x62d34b = IVotingEscrow(_0xf973eb)._0x62d34b(_0x4d642b);\n        if (_0x62d34b._0x08e108 || _0x62d34b._0x5e1b09 <= block.timestamp) return;\n\n        uint256 _0xcd8fde = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n        // Only extend if difference is more than 2 hours\n        if (_0xcd8fde > _0x62d34b._0x5e1b09 + 2 hours) {\n            try IVotingEscrow(_0xf973eb)._0xb3913f(_0x4d642b, HybraTimeLibrary.MAX_LOCK_DURATION) {\n                // Extension successful\n            } catch {\n                // Extension failed, continue without error\n                // This can happen if already at max possible time or other constraints\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setTailNotWithdrawTime": "_0x4c331a",
        "head_not_withdraw_time": "_0x0dc852",
        "tail_not_withdraw_time": "_0xf80792",
        "setHeadNotWithdrawTime": "_0x8624e3",
        "setTransferLockPeriod": "_0x058672",
        "setRewardsDistributor": "_0x67103b",
        "increase_unlock_time": "_0xb3913f",
        "_beforeTokenTransfer": "_0x40ac0f",
        "receivePenaltyReward": "_0x9ab62c",
        "_rewardsDistributor": "_0xb97b58",
        "rewardsDistributor": "_0x32463b",
        "transferLockPeriod": "_0xbe2390",
        "rewardsListLength": "_0x0a203b",
        "lastCompoundTime": "_0x78b0f4",
        "currentAvailable": "_0x95163a",
        "previewAvailable": "_0x770a2d",
        "_addTransferLock": "_0xfd84d0",
        "_extendLockToMax": "_0x058960",
        "_initializeVeNFT": "_0xb8d615",
        "safeTransferFrom": "_0xacb51c",
        "create_lock_for": "_0x308b87",
        "external_bribes": "_0x03af4a",
        "internal_bribes": "_0x616fcc",
        "setGaugeManager": "_0xb0608d",
        "remainingAmount": "_0xf5a3d1",
        "calculateShares": "_0xe71b00",
        "calculateAssets": "_0x43c5e7",
        "emergencyUnlock": "_0x0b82fe",
        "setWithdrawFee": "_0x744d15",
        "getLockEndTime": "_0x19e091",
        "finalAvailable": "_0x5b0a51",
        "sharesReceived": "_0x19666b",
        "lastRebaseTime": "_0x222cf5",
        "newTotalLocked": "_0x496b91",
        "initialAmount": "_0xae0c53",
        "maxUnlockTime": "_0xcd8fde",
        "lockedBalance": "_0x92082b",
        "_cleanExpired": "_0xfb6bf1",
        "currentLocked": "_0xd1ae56",
        "internalBribe": "_0xd9adf9",
        "externalBribe": "_0x0df5c2",
        "lastVoteEpoch": "_0x8662a8",
        "_votingEscrow": "_0xd0fcb9",
        "_gaugeManager": "_0x9aa5f8",
        "nonReentrant": "_0x78f0a4",
        "hybrReceived": "_0xf16090",
        "onlyOperator": "_0xedbc8f",
        "transferFrom": "_0x10db0a",
        "getUserLocks": "_0x03d5fc",
        "rebaseAmount": "_0x5586ab",
        "votingEscrow": "_0xf973eb",
        "_totalSupply": "_0x0fa401",
        "tokenBalance": "_0x49d652",
        "claimRewards": "_0x97f764",
        "totalBalance": "_0xcb489a",
        "gaugeManager": "_0x29d856",
        "_totalAssets": "_0xd9e5c4",
        "totalAssets": "_0xbb9eb9",
        "newTokenIds": "_0x6ee3bd",
        "userTokenId": "_0xb81f0b",
        "bribeTokens": "_0xdbf79c",
        "withdrawFee": "_0x3d0f4f",
        "deposit_for": "_0x1841e0",
        "claimBribes": "_0x6373ef",
        "newOperator": "_0x5985ac",
        "oldOperator": "_0x2bbadb",
        "votingYield": "_0x95c23e",
        "totalSupply": "_0x0179fb",
        "setOperator": "_0xbc3aaa",
        "isPermanent": "_0x08e108",
        "executeSwap": "_0x963d77",
        "safeApprove": "_0x94deb6",
        "hybrBalance": "_0xdeceba",
        "feeTokenId": "_0x8d2652",
        "unlockTime": "_0x7d3e11",
        "votedPools": "_0xbf7432",
        "tokenCount": "_0x7f91e6",
        "userAmount": "_0x31b902",
        "setSwapper": "_0xc6f493",
        "swapToHYBR": "_0x472ac2",
        "oldSwapper": "_0x0ef62e",
        "hybrAmount": "_0x3290a4",
        "epochStart": "_0xfc7860",
        "newSwapper": "_0x869361",
        "multiSplit": "_0x7c4cb5",
        "balanceOf": "_0x6d6164",
        "veBalance": "_0xaa2a69",
        "available": "_0xc5a7af",
        "veTokenId": "_0x4d642b",
        "_operator": "_0x5439e1",
        "newPeriod": "_0x30ae58",
        "oldPeriod": "_0x30b604",
        "onlyOwner": "_0xc34fba",
        "feeAmount": "_0xdc5c10",
        "userLocks": "_0xd0ddf3",
        "recipient": "_0xefe868",
        "_poolVote": "_0x57982b",
        "epochNext": "_0xe601dc",
        "withdraw": "_0x34c1af",
        "compound": "_0xba6d3e",
        "_weights": "_0x81fc74",
        "_swapper": "_0x122ae1",
        "poolVote": "_0x3db4b1",
        "operator": "_0x47eaa7",
        "lockTime": "_0x97e6f9",
        "amountIn": "_0x7aae48",
        "setVoter": "_0xf47c09",
        "approve": "_0x152e36",
        "_period": "_0xffd02e",
        "amounts": "_0xebbc05",
        "weights": "_0x958ebe",
        "swapper": "_0xf0fa28",
        "penalty": "_0xbb663d",
        "_params": "_0x1929f2",
        "deposit": "_0xf64c1b",
        "tokenIn": "_0x79c517",
        "rewards": "_0x8be3a2",
        "enabled": "_0x80b1c8",
        "setTeam": "_0x3a150e",
        "tokens": "_0xef073f",
        "_voter": "_0x04e9a0",
        "locked": "_0x62d34b",
        "bribes": "_0x44be78",
        "gauges": "_0x9c9478",
        "shares": "_0xd0f815",
        "rebase": "_0x955bbb",
        "amount": "_0x1b3d67",
        "epoch": "_0x1fdd42",
        "freed": "_0xfc8dcf",
        "_team": "_0x192916",
        "gauge": "_0xd5c1ad",
        "pools": "_0xa058c4",
        "reset": "_0xd6eb10",
        "voter": "_0x73b9b8",
        "owner": "_0x382e4b",
        "_burn": "_0x6c3a7d",
        "_time": "_0xebe4d9",
        "_HYBR": "_0x435a3d",
        "_mint": "_0xbdf3eb",
        "voted": "_0x13e23f",
        "claim": "_0x805b04",
        "write": "_0x95644e",
        "user": "_0xc4cb9f",
        "vote": "_0x6f0ee1",
        "_fee": "_0xe57000",
        "fee": "_0xe3e2c3",
        "end": "_0x5e1b09",
        "max": "_0x0c0d19",
        "arr": "_0xa5db0c",
        "len": "_0x9b2758",
        "to": "_0x83f025"
      },
      "changes": [
        "Renamed 151 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_002",
      "transformed_id": "ss_l3_medium_sn_gs_002",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\n\nimport \"./interfaces/ICLFactory.sol\";\nimport \"./interfaces/fees/IFeeModule.sol\";\n\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/IFactoryRegistry.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@nomad-xyz/src/ExcessivelySafeCall.sol\";\nimport \"./CLPool.sol\";\n\n/// @title Canonical CL factory\n/// @notice Deploys CL pools and manages ownership and control over pool protocol fees\ncontract CLFactory is ICLFactory {\n    using ExcessivelySafeCall for address;\n\n    /// @inheritdoc ICLFactory\n    IGaugeManager public override _0xee5f0a;\n    /// @inheritdoc ICLFactory\n    address public immutable override _0xd951ad;\n    /// @inheritdoc ICLFactory\n    address public override _0x8fa640;\n    /// @inheritdoc ICLFactory\n    address public override _0xb02cd9;\n    /// @inheritdoc ICLFactory\n    address public override _0xdaef6b;\n    /// @inheritdoc ICLFactory\n    address public override _0x05409e;\n    /// @inheritdoc ICLFactory\n    address public override _0x0a9685;\n    /// @inheritdoc ICLFactory\n    uint24 public override _0xea63e0;\n    /// @inheritdoc ICLFactory\n\n    address public override _0xa5c525;\n    /// @inheritdoc ICLFactory\n    address public override _0x0f2a97;\n    /// @inheritdoc ICLFactory\n    uint24 public override _0x496616;\n\n    mapping(int24 => uint24) public override _0x03575d;\n    /// @inheritdoc ICLFactory\n    mapping(address => mapping(address => mapping(int24 => address))) public override _0x176b13;\n    /// @dev Used in VotingEscrow to determine if a contract is a valid pool\n    mapping(address => bool) private _0x8ef29f;\n    /// @inheritdoc ICLFactory\n    address[] public override _0x3164dd;\n\n    int24[] private _0xe031f0;\n\n    constructor(address _0x0c6cf1) {\n        _0x8fa640 = msg.sender;\n        _0xb02cd9 = msg.sender;\n        _0x05409e = msg.sender;\n        _0xa5c525 = msg.sender;\n        _0xd951ad = _0x0c6cf1;\n        _0xea63e0 = 100_000;\n        if (true) { _0x496616 = 250_000; }\n        emit OwnerChanged(address(0), msg.sender);\n        emit SwapFeeManagerChanged(address(0), msg.sender);\n        emit UnstakedFeeManagerChanged(address(0), msg.sender);\n        emit DefaultUnstakedFeeChanged(0, 100_000);\n\n        _0x98b93a(1, 100);\n        _0x98b93a(50, 500);\n        _0x98b93a(100, 500);\n        _0x98b93a(200, 3_000);\n        _0x98b93a(2_000, 10_000);\n    }\n\n    function _0x94897d(address _0x7f52bd) external {\n        require(msg.sender == _0x8fa640);\n        _0xee5f0a = IGaugeManager(_0x7f52bd);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x457b42(address _0x0fa457, address _0x4e6d8f, int24 _0x0af33b, uint160 _0x124512)\n        external\n        override\n        returns (address _0x07bf17)\n    {\n        require(_0x0fa457 != _0x4e6d8f);\n        (address _0xf5c528, address _0xd2e9ac) = _0x0fa457 < _0x4e6d8f ? (_0x0fa457, _0x4e6d8f) : (_0x4e6d8f, _0x0fa457);\n        require(_0xf5c528 != address(0));\n        require(_0x03575d[_0x0af33b] != 0);\n        require(_0x176b13[_0xf5c528][_0xd2e9ac][_0x0af33b] == address(0));\n        _0x07bf17 = Clones._0xf46c78({\n            _0xcb8c3f: _0xd951ad,\n            _0x21dc8a: _0x161112(abi._0x6dcd53(_0xf5c528, _0xd2e9ac, _0x0af33b))\n        });\n        CLPool(_0x07bf17)._0xbd0ba6({\n            _0x0e4c6e: address(this),\n            _0xa8d0dc: _0xf5c528,\n            _0xf7d16f: _0xd2e9ac,\n            _0x8923ab: _0x0af33b,\n            _0x7f52bd: address(_0xee5f0a),\n            _0xe89013: _0x124512\n        });\n        _0x3164dd.push(_0x07bf17);\n        _0x8ef29f[_0x07bf17] = true;\n        _0x176b13[_0xf5c528][_0xd2e9ac][_0x0af33b] = _0x07bf17;\n        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses\n        _0x176b13[_0xd2e9ac][_0xf5c528][_0x0af33b] = _0x07bf17;\n        emit PoolCreated(_0xf5c528, _0xd2e9ac, _0x0af33b, _0x07bf17);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x41072a(address _0x093366) external override {\n        address _0xd0c909 = _0x8fa640;\n        require(msg.sender == _0xd0c909);\n        require(_0x093366 != address(0));\n        emit OwnerChanged(_0xd0c909, _0x093366);\n        if (block.timestamp > 0) { _0x8fa640 = _0x093366; }\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xaf74d9(address _0x850aae) external override {\n        address _0xa9edd4 = _0xb02cd9;\n        require(msg.sender == _0xa9edd4);\n        require(_0x850aae != address(0));\n        _0xb02cd9 = _0x850aae;\n        emit SwapFeeManagerChanged(_0xa9edd4, _0x850aae);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x5dc2d7(address _0x00c5b3) external override {\n        address _0x41fd10 = _0x05409e;\n        require(msg.sender == _0x41fd10);\n        require(_0x00c5b3 != address(0));\n        if (1 == 1) { _0x05409e = _0x00c5b3; }\n        emit UnstakedFeeManagerChanged(_0x41fd10, _0x00c5b3);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xc53ef8(address _0xff4869) external override {\n        require(msg.sender == _0xb02cd9);\n        require(_0xff4869 != address(0));\n        address _0x6dade6 = _0xdaef6b;\n        if (true) { _0xdaef6b = _0xff4869; }\n        emit SwapFeeModuleChanged(_0x6dade6, _0xff4869);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xa62dd7(address _0x813879) external override {\n        require(msg.sender == _0x05409e);\n        require(_0x813879 != address(0));\n        address _0x6dade6 = _0x0a9685;\n        _0x0a9685 = _0x813879;\n        emit UnstakedFeeModuleChanged(_0x6dade6, _0x813879);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xf1fec2(uint24 _0xee94e3) external override {\n        require(msg.sender == _0x05409e);\n        require(_0xee94e3 <= 500_000);\n        uint24 _0xacd761 = _0xea63e0;\n        _0xea63e0 = _0xee94e3;\n        emit DefaultUnstakedFeeChanged(_0xacd761, _0xee94e3);\n    }\n\n    function _0xe49dfc(address _0x8d758e) external override {\n        require(msg.sender == _0xa5c525);\n        require(_0x8d758e != address(0));\n        _0x0f2a97 = _0x8d758e;\n    }\n\n    function _0x9e0fbb(address _0x37005f) external override {\n        require(msg.sender == _0xa5c525);\n        require(_0x37005f != address(0));\n        if (1 == 1) { _0xa5c525 = _0x37005f; }\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x7f763e(address _0x07bf17) external view override returns (uint24) {\n        if (_0xdaef6b != address(0)) {\n            (bool _0xcee5f6, bytes memory data) = _0xdaef6b._0x05bedd(\n                200_000, 32, abi._0xf9119a(IFeeModule._0xf1d6dd.selector, _0x07bf17)\n            );\n            if (_0xcee5f6) {\n                uint24 _0x624fec = abi._0x9153d6(data, (uint24));\n                if (_0x624fec <= 100_000) {\n                    return _0x624fec;\n                }\n            }\n        }\n        return _0x03575d[CLPool(_0x07bf17)._0x0af33b()];\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x403a09(address _0x07bf17) external view override returns (uint24) {\n\n        if (!_0xee5f0a._0x275f36(_0x07bf17)) {\n            return 0;\n        }\n        if (_0x0a9685 != address(0)) {\n            (bool _0xcee5f6, bytes memory data) = _0x0a9685._0x05bedd(\n                200_000, 32, abi._0xf9119a(IFeeModule._0xf1d6dd.selector, _0x07bf17)\n            );\n            if (_0xcee5f6) {\n                uint24 _0x624fec = abi._0x9153d6(data, (uint24));\n                if (_0x624fec <= 1_000_000) {\n                    return _0x624fec;\n                }\n            }\n        }\n        return _0xea63e0;\n    }\n\n    function _0x74d4d2(address _0x07bf17) external view override returns (uint24) {\n        // if the gauge is alive, return 0, protocol fee is only for inactive gauges\n        if (_0xee5f0a._0x275f36(_0x07bf17)) {\n            return 0;\n        }\n\n        if (_0x0f2a97 != address(0)) {\n            (bool _0xcee5f6, bytes memory data) = _0x0f2a97._0x05bedd(\n                200_000, 32, abi._0xf9119a(IFeeModule._0xf1d6dd.selector, _0x07bf17)\n            );\n            if (_0xcee5f6) {\n                uint24 _0x624fec = abi._0x9153d6(data, (uint24));\n                if (_0x624fec <= 500_000) {\n                    return _0x624fec;\n                }\n            }\n        }\n        return _0x496616;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x98b93a(int24 _0x0af33b, uint24 _0x624fec) public override {\n        require(msg.sender == _0x8fa640);\n        require(_0x624fec > 0 && _0x624fec <= 100_000);\n        // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that\n\n        // 16384 ticks represents a >5x price change with ticks of 1 bips\n        require(_0x0af33b > 0 && _0x0af33b < 16384);\n        require(_0x03575d[_0x0af33b] == 0);\n\n        _0x03575d[_0x0af33b] = _0x624fec;\n        _0xe031f0.push(_0x0af33b);\n        emit TickSpacingEnabled(_0x0af33b, _0x624fec);\n    }\n\n    function _0x94c2b3() external  {\n        require(msg.sender == _0x8fa640);\n\n        for (uint256 i = 0; i < _0x3164dd.length; i++) {\n            CLPool(_0x3164dd[i])._0x8a639d(msg.sender);\n        }\n    }\n\n    function _0x8a639d(address _0x07bf17) external returns (uint128 _0x5ca4d2, uint128 _0x976e11) {\n        require(msg.sender == _0x8fa640);\n        (_0x5ca4d2, _0x976e11) = CLPool(_0x07bf17)._0x8a639d(msg.sender);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xa0d43a() external view override returns (int24[] memory) {\n        return _0xe031f0;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xc2d0a6() external view override returns (uint256) {\n        return _0x3164dd.length;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xd05d0a(address _0x07bf17) external view override returns (bool) {\n        return _0x8ef29f[_0x07bf17];\n    }\n}",
      "rename_map": {
        "excessivelySafeStaticCall": "_0x05bedd",
        "cachedUnstakedFeeManager": "_0x41fd10",
        "collectAllProtocolFees": "_0x94c2b3",
        "setDefaultUnstakedFee": "_0xf1fec2",
        "setProtocolFeeManager": "_0x9e0fbb",
        "setUnstakedFeeManager": "_0x5dc2d7",
        "cachedSwapFeeManager": "_0xa9edd4",
        "setProtocolFeeModule": "_0xe49dfc",
        "setUnstakedFeeModule": "_0xa62dd7",
        "isGaugeAliveForPool": "_0x275f36",
        "_defaultUnstakedFee": "_0xee94e3",
        "_poolImplementation": "_0x0c6cf1",
        "_protocolFeeManager": "_0x37005f",
        "_unstakedFeeManager": "_0x00c5b3",
        "collectProtocolFees": "_0x8a639d",
        "_unstakedFeeModule": "_0x813879",
        "cloneDeterministic": "_0xf46c78",
        "defaultUnstakedFee": "_0xea63e0",
        "unstakedFeeManager": "_0x05409e",
        "poolImplementation": "_0xd951ad",
        "defaultProtocolFee": "_0x496616",
        "_protocolFeeModule": "_0x8d758e",
        "protocolFeeManager": "_0xa5c525",
        "encodeWithSelector": "_0xf9119a",
        "setSwapFeeManager": "_0xaf74d9",
        "enableTickSpacing": "_0x98b93a",
        "protocolFeeModule": "_0x0f2a97",
        "unstakedFeeModule": "_0x0a9685",
        "tickSpacingToFee": "_0x03575d",
        "setSwapFeeModule": "_0xc53ef8",
        "_swapFeeManager": "_0x850aae",
        "setGaugeManager": "_0x94897d",
        "oldUnstakedFee": "_0xacd761",
        "swapFeeManager": "_0xb02cd9",
        "_swapFeeModule": "_0xff4869",
        "getUnstakedFee": "_0x403a09",
        "getProtocolFee": "_0x74d4d2",
        "allPoolsLength": "_0xc2d0a6",
        "_tickSpacings": "_0xe031f0",
        "_sqrtPriceX96": "_0xe89013",
        "swapFeeModule": "_0xdaef6b",
        "_gaugeManager": "_0x7f52bd",
        "sqrtPriceX96": "_0x124512",
        "tickSpacings": "_0xa0d43a",
        "_tickSpacing": "_0x8923ab",
        "oldFeeModule": "_0x6dade6",
        "gaugeManager": "_0xee5f0a",
        "tickSpacing": "_0x0af33b",
        "cachedOwner": "_0xd0c909",
        "getSwapFee": "_0x7f763e",
        "createPool": "_0x457b42",
        "initialize": "_0xbd0ba6",
        "keccak256": "_0x161112",
        "setOwner": "_0x41072a",
        "allPools": "_0x3164dd",
        "_factory": "_0x0e4c6e",
        "getPool": "_0x176b13",
        "amount0": "_0x5ca4d2",
        "amount1": "_0x976e11",
        "_token0": "_0xa8d0dc",
        "_token1": "_0xf7d16f",
        "success": "_0xcee5f6",
        "_isPool": "_0x8ef29f",
        "token1": "_0xd2e9ac",
        "decode": "_0x9153d6",
        "tokenB": "_0x4e6d8f",
        "master": "_0xcb8c3f",
        "isPool": "_0xd05d0a",
        "tokenA": "_0x0fa457",
        "getFee": "_0xf1d6dd",
        "token0": "_0xf5c528",
        "encode": "_0x6dcd53",
        "_owner": "_0x093366",
        "owner": "_0x8fa640",
        "pool": "_0x07bf17",
        "salt": "_0x21dc8a",
        "fee": "_0x624fec"
      },
      "changes": [
        "Renamed 77 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_003",
      "transformed_id": "ss_l3_medium_sn_gs_003",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport './interfaces/IPair.sol';\nimport './interfaces/IBribe.sol';\nimport \"./libraries/Math.sol\";\n\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport './interfaces/IRHYBR.sol';\ninterface IRewarder {\n    function _0x3aad9c(\n        address _0x614d18,\n        address _0xf23337,\n        uint256 _0x872952\n    ) external;\n}\n\ncontract GaugeV2 is ReentrancyGuard, Ownable {\n\n    using SafeERC20 for IERC20;\n\n    bool public immutable _0x7e3b20;\n    bool public _0xcfc0c2;\n\n    IERC20 public immutable _0xc4a110;\n    IERC20 public immutable TOKEN;\n    address public immutable _0x1a4a3a;\n    address public VE;\n    address public DISTRIBUTION;\n    address public _0x1924a1;\n    address public _0xc59eab;\n    address public _0xd42b2c;\n\n    uint256 public DURATION;\n    uint256 internal _0xbdc981;\n    uint256 public _0xa5ded9;\n    uint256 public _0xded964;\n    uint256 public _0x17e405;\n\n    mapping(address => uint256) public _0xbc3303;\n    mapping(address => uint256) public _0x7a6046;\n\n    uint256 internal _0xd6bbf3;\n    mapping(address => uint256) internal _0x345986;\n    mapping(address => uint256) public _0xaefeef;\n\n    event RewardAdded(uint256 _0x0c35d4);\n    event Deposit(address indexed _0x614d18, uint256 _0x6736d8);\n    event Withdraw(address indexed _0x614d18, uint256 _0x6736d8);\n    event Harvest(address indexed _0x614d18, uint256 _0x0c35d4);\n\n    event ClaimFees(address indexed from, uint256 _0x16f463, uint256 _0xe032e2);\n    event EmergencyActivated(address indexed _0xa1d73a, uint256 timestamp);\n    event EmergencyDeactivated(address indexed _0xa1d73a, uint256 timestamp);\n\n    modifier _0x1024ab(address _0x01902d) {\n        _0x17e405 = _0x6f017c();\n        _0xded964 = _0x14de82();\n        if (_0x01902d != address(0)) {\n            _0x7a6046[_0x01902d] = _0x2ba055(_0x01902d);\n            _0xbc3303[_0x01902d] = _0x17e405;\n        }\n        _;\n    }\n\n    modifier _0x39ed7c() {\n        require(msg.sender == DISTRIBUTION, \"NA\");\n        _;\n    }\n\n    modifier _0xa9efc5() {\n        require(_0xcfc0c2 == false, \"EMER\");\n        _;\n    }\n\n    constructor(address _0xdbe695,address _0xd52ef0,address _0xac1db5,address _0x3d9a66,address _0x4b18e5, address _0x850b19, address _0x5cc3db, bool _0x51e68a) {\n        _0xc4a110 = IERC20(_0xdbe695);     // main reward\n        _0x1a4a3a = _0xd52ef0;\n        VE = _0xac1db5;                               // vested\n        TOKEN = IERC20(_0x3d9a66);                 // underlying (LP)\n        DISTRIBUTION = _0x4b18e5;           // distro address (GaugeManager)\n        DURATION = HybraTimeLibrary.WEEK;\n\n        _0xc59eab = _0x850b19;       // lp fees goes here\n        _0xd42b2c = _0x5cc3db;       // bribe fees goes here\n\n        _0x7e3b20 = _0x51e68a;                 // pair boolean, if false no claim_fees\n\n        _0xcfc0c2 = false;                      // emergency flag\n\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    ONLY OWNER\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    ///@notice set distribution address (should be GaugeManager)\n    function _0x7c89f5(address _0x4b18e5) external _0x79a9d2 {\n        require(_0x4b18e5 != address(0), \"ZA\");\n        require(_0x4b18e5 != DISTRIBUTION, \"SAME_ADDR\");\n        if (1 == 1) { DISTRIBUTION = _0x4b18e5; }\n    }\n\n    ///@notice set gauge rewarder address\n    function _0xbc15d3(address _0x217bf1) external _0x79a9d2 {\n        require(_0x217bf1 != _0x1924a1, \"SAME_ADDR\");\n        _0x1924a1 = _0x217bf1;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function _0x4c44c4(address _0xae94ed) external _0x79a9d2 {\n        require(_0xae94ed >= address(0), \"ZA\");\n        _0xc59eab = _0xae94ed;\n    }\n\n    function _0x721dbe() external _0x79a9d2 {\n        require(_0xcfc0c2 == false, \"EMER\");\n        _0xcfc0c2 = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function _0x5c208d() external _0x79a9d2 {\n\n        require(_0xcfc0c2 == true,\"EMER\");\n\n        _0xcfc0c2 = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VIEW FUNCTIONS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    ///@notice total supply held\n    function _0xa4e307() public view returns (uint256) {\n        return _0xd6bbf3;\n    }\n\n    ///@notice balance of a user\n    function _0x1005d5(address _0x01902d) external view returns (uint256) {\n        return _0x1658db(_0x01902d);\n    }\n\n    function _0x1658db(address _0x01902d) internal view returns (uint256) {\n\n        return _0x345986[_0x01902d];\n    }\n\n    ///@notice last time reward\n    function _0x14de82() public view returns (uint256) {\n        return Math._0x30de27(block.timestamp, _0xbdc981);\n    }\n\n    ///@notice  reward for a sinle token\n    function _0x6f017c() public view returns (uint256) {\n        if (_0xd6bbf3 == 0) {\n            return _0x17e405;\n        } else {\n            return _0x17e405 + (_0x14de82() - _0xded964) * _0xa5ded9 * 1e18 / _0xd6bbf3;\n        }\n    }\n\n    ///@notice see earned rewards for user\n    function _0x2ba055(address _0x01902d) public view returns (uint256) {\n        return _0x7a6046[_0x01902d] + _0x1658db(_0x01902d) * (_0x6f017c() - _0xbc3303[_0x01902d]) / 1e18;\n    }\n\n    ///@notice get total reward for the duration\n    function _0x8c91c1() external view returns (uint256) {\n        return _0xa5ded9 * DURATION;\n    }\n\n    function _0x72d578() external view returns (uint256) {\n        return _0xbdc981;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    // send whole liquidity as additional param\n\n    ///@notice deposit all TOKEN of msg.sender\n    function _0xe1f8e2() external {\n        _0xc05b84(TOKEN._0x1005d5(msg.sender), msg.sender);\n    }\n\n    ///@notice deposit amount TOKEN\n    function _0x8d6b39(uint256 _0x6736d8) external {\n        _0xc05b84(_0x6736d8, msg.sender);\n    }\n\n    ///@notice deposit internal\n    function _0xc05b84(uint256 _0x6736d8, address _0x01902d) internal _0x4ca03d _0xa9efc5 _0x1024ab(_0x01902d) {\n        require(_0x6736d8 > 0, \"ZV\");\n\n        _0x345986[_0x01902d] = _0x345986[_0x01902d] + _0x6736d8;\n        _0xd6bbf3 = _0xd6bbf3 + _0x6736d8;\n        if (address(_0x1924a1) != address(0)) {\n            IRewarder(_0x1924a1)._0x3aad9c(_0x01902d, _0x01902d, _0x1658db(_0x01902d));\n        }\n\n        TOKEN._0xb7a36d(_0x01902d, address(this), _0x6736d8);\n\n        emit Deposit(_0x01902d, _0x6736d8);\n    }\n\n    ///@notice withdraw all token\n    function _0x2bd416() external {\n        _0xd45c11(_0x1658db(msg.sender));\n    }\n\n    ///@notice withdraw a certain amount of TOKEN\n    function _0x650def(uint256 _0x6736d8) external {\n        _0xd45c11(_0x6736d8);\n    }\n\n    ///@notice withdraw internal\n    function _0xd45c11(uint256 _0x6736d8) internal _0x4ca03d _0xa9efc5 _0x1024ab(msg.sender) {\n        require(_0x6736d8 > 0, \"ZV\");\n        require(_0x1658db(msg.sender) > 0, \"ZV\");\n        require(block.timestamp >= _0xaefeef[msg.sender], \"!MATURE\");\n\n        _0xd6bbf3 = _0xd6bbf3 - _0x6736d8;\n        _0x345986[msg.sender] = _0x345986[msg.sender] - _0x6736d8;\n\n        if (address(_0x1924a1) != address(0)) {\n            IRewarder(_0x1924a1)._0x3aad9c(msg.sender, msg.sender,_0x1658db(msg.sender));\n        }\n\n        TOKEN._0x9ccd26(msg.sender, _0x6736d8);\n\n        emit Withdraw(msg.sender, _0x6736d8);\n    }\n\n    function _0x73e346() external _0x4ca03d {\n        require(_0xcfc0c2, \"EMER\");\n        uint256 _0x27e7ec = _0x1658db(msg.sender);\n        require(_0x27e7ec > 0, \"ZV\");\n        if (block.timestamp > 0) { _0xd6bbf3 = _0xd6bbf3 - _0x27e7ec; }\n\n        _0x345986[msg.sender] = 0;\n\n        TOKEN._0x9ccd26(msg.sender, _0x27e7ec);\n        emit Withdraw(msg.sender, _0x27e7ec);\n    }\n\n    function _0x1b4455(uint256 _0x27e7ec) external _0x4ca03d {\n\n        require(_0xcfc0c2, \"EMER\");\n        _0xd6bbf3 = _0xd6bbf3 - _0x27e7ec;\n\n        _0x345986[msg.sender] = _0x345986[msg.sender] - _0x27e7ec;\n\n        TOKEN._0x9ccd26(msg.sender, _0x27e7ec);\n        emit Withdraw(msg.sender, _0x27e7ec);\n    }\n\n    ///@notice withdraw all TOKEN and harvest rewardToken\n    function _0x889b85(uint8 _0x251c3a) external {\n        _0xd45c11(_0x1658db(msg.sender));\n        _0xb478bd(_0x251c3a);\n    }\n\n    ///@notice User harvest function called from distribution (GaugeManager allows harvest on multiple gauges)\n    function _0xb478bd(address _0xf4a407, uint8 _0x251c3a) public _0x4ca03d _0x39ed7c _0x1024ab(_0xf4a407) {\n        uint256 _0x0c35d4 = _0x7a6046[_0xf4a407];\n        if (_0x0c35d4 > 0) {\n            _0x7a6046[_0xf4a407] = 0;\n            IERC20(_0xc4a110)._0xd6b5c1(_0x1a4a3a, _0x0c35d4);\n            IRHYBR(_0x1a4a3a)._0x915d0d(_0x0c35d4);\n            IRHYBR(_0x1a4a3a)._0xbebd30(_0x0c35d4, _0x251c3a, _0xf4a407);\n            emit Harvest(_0xf4a407, _0x0c35d4);\n        }\n\n        if (_0x1924a1 != address(0)) {\n            IRewarder(_0x1924a1)._0x3aad9c(_0xf4a407, _0xf4a407, _0x1658db(_0xf4a407));\n        }\n    }\n\n    ///@notice User harvest function\n    function _0xb478bd(uint8 _0x251c3a) public _0x4ca03d _0x1024ab(msg.sender) {\n        uint256 _0x0c35d4 = _0x7a6046[msg.sender];\n        if (_0x0c35d4 > 0) {\n            _0x7a6046[msg.sender] = 0;\n            IERC20(_0xc4a110)._0xd6b5c1(_0x1a4a3a, _0x0c35d4);\n            IRHYBR(_0x1a4a3a)._0x915d0d(_0x0c35d4);\n            IRHYBR(_0x1a4a3a)._0xbebd30(_0x0c35d4, _0x251c3a, msg.sender);\n            emit Harvest(msg.sender, _0x0c35d4);\n        }\n\n        if (_0x1924a1 != address(0)) {\n            IRewarder(_0x1924a1)._0x3aad9c(msg.sender, msg.sender, _0x1658db(msg.sender));\n        }\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    DISTRIBUTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @dev Receive rewards from distribution\n\n    function _0x306102(address _0x0f3c3f, uint256 _0x0c35d4) external _0x4ca03d _0xa9efc5 _0x39ed7c _0x1024ab(address(0)) {\n        require(_0x0f3c3f == address(_0xc4a110), \"IA\");\n        _0xc4a110._0xb7a36d(DISTRIBUTION, address(this), _0x0c35d4);\n\n        if (block.timestamp >= _0xbdc981) {\n            _0xa5ded9 = _0x0c35d4 / DURATION;\n        } else {\n            uint256 _0x20b903 = _0xbdc981 - block.timestamp;\n            uint256 _0xb5d1b5 = _0x20b903 * _0xa5ded9;\n            if (gasleft() > 0) { _0xa5ded9 = (_0x0c35d4 + _0xb5d1b5) / DURATION; }\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n\n        uint256 balance = _0xc4a110._0x1005d5(address(this));\n        require(_0xa5ded9 <= balance / DURATION, \"REWARD_HIGH\");\n\n        if (1 == 1) { _0xded964 = block.timestamp; }\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xbdc981 = block.timestamp + DURATION; }\n        emit RewardAdded(_0x0c35d4);\n    }\n\n    function _0x44e070() external _0x4ca03d returns (uint256 _0x16f463, uint256 _0xe032e2) {\n        return _0xba7eac();\n    }\n\n     function _0xba7eac() internal returns (uint256 _0x16f463, uint256 _0xe032e2) {\n        if (!_0x7e3b20) {\n            return (0, 0);\n        }\n        address _0x3d9a66 = address(TOKEN);\n        (_0x16f463, _0xe032e2) = IPair(_0x3d9a66)._0x44e070();\n        if (_0x16f463 > 0 || _0xe032e2 > 0) {\n\n            uint256 _0x86c98d = _0x16f463;\n            uint256 _0x83c677 = _0xe032e2;\n\n            (address _0xd62033, address _0x553428) = IPair(_0x3d9a66)._0xd8bddc();\n\n            if (_0x86c98d  > 0) {\n                IERC20(_0xd62033)._0xd6b5c1(_0xc59eab, 0);\n                IERC20(_0xd62033)._0xd6b5c1(_0xc59eab, _0x86c98d);\n                IBribe(_0xc59eab)._0x306102(_0xd62033, _0x86c98d);\n            }\n            if (_0x83c677  > 0) {\n                IERC20(_0x553428)._0xd6b5c1(_0xc59eab, 0);\n                IERC20(_0x553428)._0xd6b5c1(_0xc59eab, _0x83c677);\n                IBribe(_0xc59eab)._0x306102(_0x553428, _0x83c677);\n            }\n            emit ClaimFees(msg.sender, _0x16f463, _0xe032e2);\n        }\n    }\n\n}",
      "rename_map": {
        "lastTimeRewardApplicable": "_0x14de82",
        "depostionEmissionsToken": "_0x915d0d",
        "emergencyWithdrawAmount": "_0x1b4455",
        "userRewardPerTokenPaid": "_0xbc3303",
        "activateEmergencyMode": "_0x721dbe",
        "withdrawAllAndHarvest": "_0x889b85",
        "rewardPerTokenStored": "_0x17e405",
        "notifyRewardAmount": "_0x306102",
        "rewardForDuration": "_0x8c91c1",
        "stopEmergencyMode": "_0x5c208d",
        "emergencyWithdraw": "_0x73e346",
        "setGaugeRewarder": "_0xbc15d3",
        "setInternalBribe": "_0x4c44c4",
        "onlyDistribution": "_0x39ed7c",
        "safeTransferFrom": "_0xb7a36d",
        "_external_bribe": "_0x5cc3db",
        "setDistribution": "_0x7c89f5",
        "_internal_bribe": "_0x850b19",
        "rewardPerToken": "_0x6f017c",
        "_gaugeRewarder": "_0x217bf1",
        "isNotEmergency": "_0xa9efc5",
        "lastUpdateTime": "_0xded964",
        "external_bribe": "_0xd42b2c",
        "internal_bribe": "_0xc59eab",
        "_distribution": "_0x4b18e5",
        "_periodFinish": "_0xbdc981",
        "gaugeRewarder": "_0x1924a1",
        "nonReentrant": "_0x4ca03d",
        "safeTransfer": "_0x9ccd26",
        "_rewardToken": "_0xdbe695",
        "periodFinish": "_0x72d578",
        "_totalSupply": "_0xd6bbf3",
        "updateReward": "_0x1024ab",
        "maturityTime": "_0xaefeef",
        "_redeemType": "_0x251c3a",
        "withdrawAll": "_0x2bd416",
        "userBalance": "_0x872952",
        "rewardToken": "_0xc4a110",
        "totalSupply": "_0xa4e307",
        "safeApprove": "_0xd6b5c1",
        "depositAll": "_0xe1f8e2",
        "_balanceOf": "_0x1658db",
        "_isForPair": "_0x51e68a",
        "rewardRate": "_0xa5ded9",
        "_claimFees": "_0xba7eac",
        "balanceOf": "_0x1005d5",
        "getReward": "_0xb478bd",
        "_balances": "_0x345986",
        "onlyOwner": "_0x79a9d2",
        "_withdraw": "_0xd45c11",
        "recipient": "_0xf23337",
        "emergency": "_0xcfc0c2",
        "isForPair": "_0x7e3b20",
        "remaining": "_0x20b903",
        "claimFees": "_0x44e070",
        "redeemFor": "_0xbebd30",
        "withdraw": "_0x650def",
        "leftover": "_0xb5d1b5",
        "onReward": "_0x3aad9c",
        "_deposit": "_0xc05b84",
        "claimed0": "_0x16f463",
        "claimed1": "_0xe032e2",
        "_amount": "_0x27e7ec",
        "account": "_0x01902d",
        "_token0": "_0xd62033",
        "deposit": "_0x8d6b39",
        "_token1": "_0x553428",
        "rewards": "_0x7a6046",
        "earned": "_0x2ba055",
        "_rHYBR": "_0xd52ef0",
        "tokens": "_0xd8bddc",
        "_token": "_0x3d9a66",
        "_fees1": "_0x83c677",
        "_fees0": "_0x86c98d",
        "reward": "_0x0c35d4",
        "amount": "_0x6736d8",
        "gauge": "_0xa1d73a",
        "token": "_0x0f3c3f",
        "rHYBR": "_0x1a4a3a",
        "_user": "_0xf4a407",
        "user": "_0x614d18",
        "_int": "_0xae94ed",
        "_ve": "_0xac1db5",
        "min": "_0x30de27"
      },
      "changes": [
        "Renamed 84 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_004",
      "transformed_id": "ss_l3_medium_sn_gs_004",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title GovernanceHYBR (gHYBR)\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\n */\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Lock period for new deposits (configurable between 12-24 hours)\n    uint256 public _0xfd37c6 = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public _0xa735a6 = 1200; // 5days\n    uint256 public _0x337477 = 300; // 1day\n\n    // Withdraw fee configuration (basis points, 10000 = 100%)\n    uint256 public _0x37b482 = 100; // 1% default fee\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\n    uint256 public constant BASIS = 10000;\n    address public Team; // Address to receive fees\n    uint256 public _0x5ff5a1;\n    uint256 public _0x39dc15;\n    uint256 public _0xfbee50;\n    // User deposit tracking for transfer locks\n    struct UserLock {\n        uint256 _0x00524f;\n        uint256 _0x8e028f;\n    }\n\n    mapping(address => UserLock[]) public _0xddab6d;\n    mapping(address => uint256) public _0x17ad5a;\n\n    // Core contracts\n    address public immutable HYBR;\n    address public immutable _0xa19a98;\n    address public _0xad5dc3;\n    address public _0x0f9cca;\n    address public _0xeb40b1;\n    uint256 public _0x14f424; // The veNFT owned by this contract\n\n    // Auto-voting strategy\n    address public _0x0f751b; // Address that can manage voting strategy\n    uint256 public _0xac4718; // Last epoch when we voted\n\n    // Reward tracking\n    uint256 public _0xb2d2b3;\n    uint256 public _0xda0b42;\n\n    // Swap module\n    ISwapper public _0x22e07d;\n\n    // Errors\n    error NOT_AUTHORIZED();\n\n    // Events\n    event Deposit(address indexed _0xb67c23, uint256 _0x5fe0ab, uint256 _0xa0c15f);\n    event Withdraw(address indexed _0xb67c23, uint256 _0x05758e, uint256 _0x5fe0ab, uint256 _0x6368f2);\n    event Compound(uint256 _0x1e5f4f, uint256 _0x67e1bb);\n    event PenaltyRewardReceived(uint256 _0x00524f);\n    event TransferLockPeriodUpdated(uint256 _0x5dbf4e, uint256 _0xf4f599);\n    event SwapperUpdated(address indexed _0xbfab54, address indexed _0x2c38b9);\n    event VoterSet(address _0xad5dc3);\n    event EmergencyUnlock(address indexed _0xb67c23);\n    event AutoVotingEnabled(bool _0x2bd059);\n    event OperatorUpdated(address indexed _0x3f7f8c, address indexed _0x254785);\n    event DefaultVotingStrategyUpdated(address[] _0x7e3808, uint256[] _0x22a754);\n    event AutoVoteExecuted(uint256 _0xa27f2f, address[] _0x7e3808, uint256[] _0x22a754);\n\n    constructor(\n        address _0xcb5f95,\n        address _0xed5f76\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_0xcb5f95 != address(0), \"Invalid HYBR\");\n        require(_0xed5f76 != address(0), \"Invalid VE\");\n\n        HYBR = _0xcb5f95;\n        _0xa19a98 = _0xed5f76;\n        _0xb2d2b3 = block.timestamp;\n        _0xda0b42 = block.timestamp;\n        _0x0f751b = msg.sender; // Initially set deployer as operator\n    }\n\n    function _0xeb290e(address _0x7af843) external _0x13085c {\n        require(_0x7af843 != address(0), \"Invalid rewards distributor\");\n        if (1 == 1) { _0x0f9cca = _0x7af843; }\n    }\n\n    function _0x9ad765(address _0xdc0939) external _0x13085c {\n        require(_0xdc0939 != address(0), \"Invalid gauge manager\");\n        _0xeb40b1 = _0xdc0939;\n    }\n\n      /**\n     * @notice Modifier to check authorization (owner or operator)\n     */\n    modifier _0xe90de7() {\n        if (msg.sender != _0x0f751b) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n    /**\n     * @notice Deposit HYBR and receive gHYBR shares\n     * @param amount Amount of HYBR to deposit\n     * @param recipient Recipient of gHYBR shares\n     */\n    function _0x4e512c(uint256 _0x00524f, address _0xa36533) external _0x46ce13 {\n        require(_0x00524f > 0, \"Zero amount\");\n        _0xa36533 = _0xa36533 == address(0) ? msg.sender : _0xa36533;\n\n        // Transfer HYBR from user first\n        IERC20(HYBR)._0xea4289(msg.sender, address(this), _0x00524f);\n\n        // Initialize veNFT on first deposit\n        if (_0x14f424 == 0) {\n            _0xc8129f(_0x00524f);\n        } else {\n            // Add to existing veNFT\n            IERC20(HYBR)._0x70423f(_0xa19a98, _0x00524f);\n            IVotingEscrow(_0xa19a98)._0xa4cd82(_0x14f424, _0x00524f);\n\n            // Extend lock to maximum duration\n            _0xea6382();\n        }\n\n        // Calculate shares to mint based on current totalAssets\n        uint256 _0x05758e = _0x43ea14(_0x00524f);\n\n        // Mint gHYBR shares\n        _0xa9e8aa(_0xa36533, _0x05758e);\n\n        // Add transfer lock for recipient\n        _0x075441(_0xa36533, _0x05758e);\n\n        emit Deposit(msg.sender, _0x00524f, _0x05758e);\n    }\n\n    /**\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\n     * @param shares Amount of gHYBR shares to burn\n     * @return userTokenId The ID of the new veNFT created for the user\n     */\n    function _0x3ebe83(uint256 _0x05758e) external _0x46ce13 returns (uint256 _0xdeff95) {\n        require(_0x05758e > 0, \"Zero shares\");\n        require(_0xeab9e3(msg.sender) >= _0x05758e, \"Insufficient balance\");\n        require(_0x14f424 != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(_0xa19a98)._0x588068(_0x14f424) == false, \"Cannot withdraw yet\");\n\n        uint256 _0x8abb9d = HybraTimeLibrary._0x8abb9d(block.timestamp);\n        uint256 _0xe0968b = HybraTimeLibrary._0xe0968b(block.timestamp);\n\n        require(block.timestamp >= _0x8abb9d + _0xa735a6 && block.timestamp < _0xe0968b - _0x337477, \"Cannot withdraw yet\");\n\n        // Calculate proportional HYBR amount from veNFT\n        uint256 _0x5fe0ab = _0x4c6272(_0x05758e);\n        require(_0x5fe0ab > 0, \"No assets to withdraw\");\n\n        // Calculate fee amount (from the HYBR amount, not shares)\n        uint256 _0x983560 = 0;\n        if (_0x37b482 > 0) {\n            _0x983560 = (_0x5fe0ab * _0x37b482) / BASIS;\n        }\n\n        // User receives amount minus fee\n        uint256 _0xdb2d76 = _0x5fe0ab - _0x983560;\n        require(_0xdb2d76 > 0, \"Amount too small after fee\");\n\n        // Get actual HYBR locked amount (not voting power)\n        uint256 _0x416975 = _0x8f5c0d();\n        require(_0x5fe0ab <= _0x416975, \"Insufficient veNFT balance\");\n\n        uint256 _0xfb0168 = _0x416975 - _0xdb2d76 - _0x983560;\n        require(_0xfb0168 >= 0, \"Cannot withdraw entire veNFT\");\n\n        // Burn gHYBR shares (full amount)\n        _0x2a6945(msg.sender, _0x05758e);\n\n        // Use multiSplit to create two NFTs: one for user, one for contract\n        uint256[] memory _0x359bba = new uint256[](3);\n        _0x359bba[0] = _0xfb0168; // Amount staying with gHYBR\n        _0x359bba[1] = _0xdb2d76;      // Amount going to user (after fee)\n        _0x359bba[2] = _0x983560;      // Amount going to fee recipient\n\n        uint256[] memory _0x2235c9 = IVotingEscrow(_0xa19a98)._0x46f745(_0x14f424, _0x359bba);\n\n        // Update contract's veTokenId to the first new token\n        _0x14f424 = _0x2235c9[0];\n        _0xdeff95 = _0x2235c9[1];\n        uint256 _0x601d7c = _0x2235c9[2];\n        // Note: userTokenId is transferred to user, they can manage their own lock time\n        IVotingEscrow(_0xa19a98)._0x7abc5e(address(this), msg.sender, _0xdeff95);\n        IVotingEscrow(_0xa19a98)._0x7abc5e(address(this), Team, _0x601d7c);\n        emit Withdraw(msg.sender, _0x05758e, _0xdb2d76, _0x983560);\n    }\n\n    /**\n     * @notice Internal function to initialize veNFT on first deposit\n     */\n    function _0xc8129f(uint256 _0x00c4de) internal {\n        // Create max lock with the initial deposit amount\n        IERC20(HYBR)._0x70423f(_0xa19a98, type(uint256)._0x3dc52c);\n        uint256 _0x7713e6 = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n        // Create lock with initial amount\n        _0x14f424 = IVotingEscrow(_0xa19a98)._0xc60e99(_0x00c4de, _0x7713e6, address(this));\n\n    }\n\n    /**\n     * @notice Calculate shares to mint based on deposit amount\n     */\n    function _0x43ea14(uint256 _0x00524f) public view returns (uint256) {\n        uint256 _0xf9d920 = _0xd73546();\n        uint256 _0x520207 = _0x8f5c0d();\n        if (_0xf9d920 == 0 || _0x520207 == 0) {\n            return _0x00524f;\n        }\n        return (_0x00524f * _0xf9d920) / _0x520207;\n    }\n\n    /**\n     * @notice Calculate HYBR value of shares\n     */\n    function _0x4c6272(uint256 _0x05758e) public view returns (uint256) {\n        uint256 _0xf9d920 = _0xd73546();\n        if (_0xf9d920 == 0) {\n            return _0x05758e;\n        }\n        return (_0x05758e * _0x8f5c0d()) / _0xf9d920;\n    }\n\n    /**\n     * @notice Get total assets (HYBR) locked in veNFT\n     * @dev Returns actual HYBR amount, not voting power\n     */\n    function _0x8f5c0d() public view returns (uint256) {\n        if (_0x14f424 == 0) {\n            return 0;\n        }\n        // Get actual locked HYBR amount, not voting power\n        IVotingEscrow.LockedBalance memory _0xb463b9 = IVotingEscrow(_0xa19a98)._0xb463b9(_0x14f424);\n        return uint256(int256(_0xb463b9._0x00524f));\n    }\n\n    /**\n     * @notice Add transfer lock for new deposits\n     */\n    function _0x075441(address _0xb67c23, uint256 _0x00524f) internal {\n        uint256 _0x8e028f = block.timestamp + _0xfd37c6;\n        _0xddab6d[_0xb67c23].push(UserLock({\n            _0x00524f: _0x00524f,\n            _0x8e028f: _0x8e028f\n        }));\n        _0x17ad5a[_0xb67c23] += _0x00524f;\n    }\n\n    /**\n     * @notice Preview available balance (total - currently locked)\n     * @param user The user address to check\n     * @return available The current available balance for transfer\n     */\n    function _0x30b8d2(address _0xb67c23) external view returns (uint256 _0x39fc6e) {\n        uint256 _0xacb7f5 = _0xeab9e3(_0xb67c23);\n        uint256 _0xf9e1bd = 0;\n\n        UserLock[] storage _0x7a5069 = _0xddab6d[_0xb67c23];\n        for (uint256 i = 0; i < _0x7a5069.length; i++) {\n            if (_0x7a5069[i]._0x8e028f > block.timestamp) {\n                _0xf9e1bd += _0x7a5069[i]._0x00524f;\n            }\n        }\n\n        return _0xacb7f5 > _0xf9e1bd ? _0xacb7f5 - _0xf9e1bd : 0;\n    }\n    /**\n     * @notice Clean expired locks and update locked balance\n     * @param user The user address to clean locks for\n     * @return freed The amount of tokens freed from expired locks\n     */\n    function _0xb00368(address _0xb67c23) internal returns (uint256 _0x74ccd5) {\n        UserLock[] storage _0x7a5069 = _0xddab6d[_0xb67c23];\n        uint256 _0x71069b = _0x7a5069.length;\n        if (_0x71069b == 0) return 0;\n\n        uint256 _0xcc8b70 = 0;\n        unchecked {\n            for (uint256 i = 0; i < _0x71069b; i++) {\n                UserLock memory L = _0x7a5069[i];\n                if (L._0x8e028f <= block.timestamp) {\n                    _0x74ccd5 += L._0x00524f;\n                } else {\n                    if (_0xcc8b70 != i) _0x7a5069[_0xcc8b70] = L;\n                    _0xcc8b70++;\n                }\n            }\n            if (_0x74ccd5 > 0) {\n                _0x17ad5a[_0xb67c23] -= _0x74ccd5;\n            }\n            while (_0x7a5069.length > _0xcc8b70) {\n                _0x7a5069.pop();\n            }\n        }\n    }\n\n    /**\n     * @notice Override transfer to implement lock mechanism\n     */\n    function _0x088a0e(\n        address from,\n        address _0x016c21,\n        uint256 _0x00524f\n    ) internal override {\n        super._0x088a0e(from, _0x016c21, _0x00524f);\n\n        if (from != address(0) && _0x016c21 != address(0)) { // Not mint or burn\n            uint256 _0xacb7f5 = _0xeab9e3(from);\n\n            // Step 1: Check current available balance using cached lockedBalance\n            uint256 _0xf7bef9 = _0xacb7f5 > _0x17ad5a[from] ? _0xacb7f5 - _0x17ad5a[from] : 0;\n\n            // Step 2: If current available >= amount, pass directly\n            if (_0xf7bef9 >= _0x00524f) {\n                return;\n            }\n\n            // Step 3: Not enough, clean expired locks and recalculate\n            _0xb00368(from);\n            uint256 _0xf6edaa = _0xacb7f5 > _0x17ad5a[from] ? _0xacb7f5 - _0x17ad5a[from] : 0;\n\n            // Step 4: Check final available balance\n            require(_0xf6edaa >= _0x00524f, \"Tokens locked\");\n        }\n    }\n\n    /**\n     * @notice Claim all rewards from voting and rebase\n     */\n    function _0xe1ed2a() external _0xe90de7 {\n        require(_0xad5dc3 != address(0), \"Voter not set\");\n        require(_0x0f9cca != address(0), \"Distributor not set\");\n\n        // Claim rebase rewards from RewardsDistributor\n        uint256  _0x76fdca = IRewardsDistributor(_0x0f9cca)._0x763b0c(_0x14f424);\n        _0x5ff5a1 += _0x76fdca;\n        // Claim bribes from voted pools\n        address[] memory _0xc43de0 = IVoter(_0xad5dc3)._0xec1b80(_0x14f424);\n\n        for (uint256 i = 0; i < _0xc43de0.length; i++) {\n            if (_0xc43de0[i] != address(0)) {\n                address _0x93079f = IGaugeManager(_0xeb40b1)._0x9201df(_0xc43de0[i]);\n\n                if (_0x93079f != address(0)) {\n                    // Prepare arrays for single bribe claim\n                    address[] memory _0x27a43d = new address[](1);\n                    address[][] memory _0x7361b9 = new address[][](1);\n\n                    // Claim internal bribe (trading fees)\n                    address _0xb14032 = IGaugeManager(_0xeb40b1)._0x1b0944(_0x93079f);\n                    if (_0xb14032 != address(0)) {\n                        uint256 _0xde7502 = IBribe(_0xb14032)._0x97a056();\n                        if (_0xde7502 > 0) {\n                            address[] memory _0xe915f9 = new address[](_0xde7502);\n                            for (uint256 j = 0; j < _0xde7502; j++) {\n                                _0xe915f9[j] = IBribe(_0xb14032)._0xe915f9(j);\n                            }\n                            _0x27a43d[0] = _0xb14032;\n                            _0x7361b9[0] = _0xe915f9;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0xeb40b1)._0x45fce0(_0x27a43d, _0x7361b9, _0x14f424);\n                        }\n                    }\n\n                    // Claim external bribe\n                    address _0xd603c5 = IGaugeManager(_0xeb40b1)._0xdc06b3(_0x93079f);\n                    if (_0xd603c5 != address(0)) {\n                        uint256 _0xde7502 = IBribe(_0xd603c5)._0x97a056();\n                        if (_0xde7502 > 0) {\n                            address[] memory _0xe915f9 = new address[](_0xde7502);\n                            for (uint256 j = 0; j < _0xde7502; j++) {\n                                _0xe915f9[j] = IBribe(_0xd603c5)._0xe915f9(j);\n                            }\n                            _0x27a43d[0] = _0xd603c5;\n                            _0x7361b9[0] = _0xe915f9;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0xeb40b1)._0x45fce0(_0x27a43d, _0x7361b9, _0x14f424);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Execute swap through the configured swapper module\n     * @param _params Swap parameters for the swapper module\n     */\n    function _0x9fe54c(ISwapper.SwapParams calldata _0x4549e9) external _0x46ce13 _0xe90de7 {\n        require(address(_0x22e07d) != address(0), \"Swapper not set\");\n\n        // Get token balance before swap\n        uint256 _0xf27774 = IERC20(_0x4549e9._0xf77751)._0xeab9e3(address(this));\n        require(_0xf27774 >= _0x4549e9._0x473a2f, \"Insufficient token balance\");\n\n        // Approve swapper to spend tokens\n        IERC20(_0x4549e9._0xf77751)._0x783294(address(_0x22e07d), _0x4549e9._0x473a2f);\n\n        // Execute swap through swapper module\n        uint256 _0xcc7487 = _0x22e07d._0xd064e4(_0x4549e9);\n\n        // Reset approval for safety\n        IERC20(_0x4549e9._0xf77751)._0x783294(address(_0x22e07d), 0);\n\n        // HYBR is now in this contract, ready for compounding\n        _0xfbee50 += _0xcc7487;\n    }\n\n    /**\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\n     */\n    function _0x6ebd9f() external _0xe90de7 {\n\n        // Get current HYBR balance\n        uint256 _0x609c77 = IERC20(HYBR)._0xeab9e3(address(this));\n\n        if (_0x609c77 > 0) {\n            // Lock all HYBR to existing veNFT\n            IERC20(HYBR)._0x783294(_0xa19a98, _0x609c77);\n            IVotingEscrow(_0xa19a98)._0xa4cd82(_0x14f424, _0x609c77);\n\n            // Extend lock to maximum duration\n            _0xea6382();\n\n            _0xda0b42 = block.timestamp;\n\n            emit Compound(_0x609c77, _0x8f5c0d());\n        }\n    }\n\n    /**\n     * @notice Vote for gauges using the veNFT\n     * @param _poolVote Array of pools to vote for\n     * @param _weights Array of weights for each pool\n     */\n    function _0xfef4c7(address[] calldata _0x7e8a27, uint256[] calldata _0xe5efb5) external {\n        require(msg.sender == _0xa0e476() || msg.sender == _0x0f751b, \"Not authorized\");\n        require(_0xad5dc3 != address(0), \"Voter not set\");\n\n        IVoter(_0xad5dc3)._0xfef4c7(_0x14f424, _0x7e8a27, _0xe5efb5);\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xac4718 = HybraTimeLibrary._0x8abb9d(block.timestamp); }\n\n    }\n\n    /**\n     * @notice Reset votes\n     */\n    function _0x5a946d() external {\n        require(msg.sender == _0xa0e476() || msg.sender == _0x0f751b, \"Not authorized\");\n        require(_0xad5dc3 != address(0), \"Voter not set\");\n\n        IVoter(_0xad5dc3)._0x5a946d(_0x14f424);\n    }\n\n    /**\n     * @notice Receive penalty rewards from rHYBR conversions\n     */\n    function _0x667c62(uint256 _0x00524f) external {\n\n        // Auto-compound penalty rewards to existing veNFT\n        if (_0x00524f > 0) {\n            IERC20(HYBR)._0x70423f(_0xa19a98, _0x00524f);\n\n            if(_0x14f424 == 0){\n                _0xc8129f(_0x00524f);\n            } else{\n                IVotingEscrow(_0xa19a98)._0xa4cd82(_0x14f424, _0x00524f);\n\n                // Extend lock to maximum duration\n                _0xea6382();\n            }\n        }\n        _0x39dc15 += _0x00524f;\n        emit PenaltyRewardReceived(_0x00524f);\n    }\n\n    /**\n     * @notice Set the voter contract\n     */\n    function _0xc31fe3(address _0x3705db) external _0x13085c {\n        require(_0x3705db != address(0), \"Invalid voter\");\n        _0xad5dc3 = _0x3705db;\n        emit VoterSet(_0x3705db);\n    }\n\n    /**\n     * @notice Update transfer lock period\n     */\n    function _0x17e382(uint256 _0xa93924) external _0x13085c {\n        require(_0xa93924 >= MIN_LOCK_PERIOD && _0xa93924 <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 _0x5dbf4e = _0xfd37c6;\n        _0xfd37c6 = _0xa93924;\n        emit TransferLockPeriodUpdated(_0x5dbf4e, _0xa93924);\n    }\n\n    /**\n     * @notice Set withdraw fee (in basis points)\n     * @param _fee Fee amount (10-30 basis points)\n     */\n    function _0x436483(uint256 _0x585381) external _0x13085c {\n        require(_0x585381 >= MIN_WITHDRAW_FEE && _0x585381 <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        _0x37b482 = _0x585381;\n    }\n\n    function _0xbb6c9b(uint256 _0xcbf49a) external _0x13085c {\n        _0xa735a6 = _0xcbf49a;\n    }\n\n    function _0xfc3809(uint256 _0xcbf49a) external _0x13085c {\n        _0x337477 = _0xcbf49a;\n    }\n\n    /**\n     * @notice Set the swapper module\n     * @param _swapper Address of the swapper module\n     */\n    function _0x62c251(address _0x3ad31c) external _0x13085c {\n        require(_0x3ad31c != address(0), \"Invalid swapper\");\n        address _0xbfab54 = address(_0x22e07d);\n        _0x22e07d = ISwapper(_0x3ad31c);\n        emit SwapperUpdated(_0xbfab54, _0x3ad31c);\n    }\n\n    /**\n     * @notice Set the team address\n     */\n    function _0x483522(address _0x5f4112) external _0x13085c {\n        require(_0x5f4112 != address(0), \"Invalid team\");\n        Team = _0x5f4112;\n    }\n\n    /**\n     * @notice Emergency unlock for a user (owner only)\n     */\n    function _0xcd5621(address _0xb67c23) external _0xe90de7 {\n        delete _0xddab6d[_0xb67c23];\n        _0x17ad5a[_0xb67c23] = 0;\n        emit EmergencyUnlock(_0xb67c23);\n    }\n\n    /**\n     * @notice Get user's locks info\n     */\n    function _0xbd8f05(address _0xb67c23) external view returns (UserLock[] memory) {\n        return _0xddab6d[_0xb67c23];\n    }\n\n    /**\n     * @notice Set operator address\n     */\n    function _0x5593fd(address _0x2c3dd8) external _0x13085c {\n        require(_0x2c3dd8 != address(0), \"Invalid operator\");\n        address _0x3f7f8c = _0x0f751b;\n        _0x0f751b = _0x2c3dd8;\n        emit OperatorUpdated(_0x3f7f8c, _0x2c3dd8);\n    }\n\n    /**\n     * @notice Get veNFT lock end time\n     */\n    function _0x1bd197() external view returns (uint256) {\n        if (_0x14f424 == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory _0xb463b9 = IVotingEscrow(_0xa19a98)._0xb463b9(_0x14f424);\n        return uint256(_0xb463b9._0x59a952);\n    }\n\n    /**\n     * @notice Internal helper to safely extend lock to maximum duration\n     * @dev Calculates exact duration needed to reach max allowed unlock time\n     */\n    function _0xea6382() internal {\n        if (_0x14f424 == 0) return;\n\n        IVotingEscrow.LockedBalance memory _0xb463b9 = IVotingEscrow(_0xa19a98)._0xb463b9(_0x14f424);\n        if (_0xb463b9._0xd50e01 || _0xb463b9._0x59a952 <= block.timestamp) return;\n\n        uint256 _0x284b8e = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n        // Only extend if difference is more than 2 hours\n        if (_0x284b8e > _0xb463b9._0x59a952 + 2 hours) {\n            try IVotingEscrow(_0xa19a98)._0xcc0c7f(_0x14f424, HybraTimeLibrary.MAX_LOCK_DURATION) {\n                // Extension successful\n            } catch {\n                // Extension failed, continue without error\n                // This can happen if already at max possible time or other constraints\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setTailNotWithdrawTime": "_0xfc3809",
        "head_not_withdraw_time": "_0xa735a6",
        "tail_not_withdraw_time": "_0x337477",
        "setHeadNotWithdrawTime": "_0xbb6c9b",
        "setTransferLockPeriod": "_0x17e382",
        "setRewardsDistributor": "_0xeb290e",
        "increase_unlock_time": "_0xcc0c7f",
        "_beforeTokenTransfer": "_0x088a0e",
        "receivePenaltyReward": "_0x667c62",
        "_rewardsDistributor": "_0x7af843",
        "rewardsDistributor": "_0x0f9cca",
        "transferLockPeriod": "_0xfd37c6",
        "rewardsListLength": "_0x97a056",
        "lastCompoundTime": "_0xda0b42",
        "currentAvailable": "_0xf7bef9",
        "previewAvailable": "_0x30b8d2",
        "_addTransferLock": "_0x075441",
        "_extendLockToMax": "_0xea6382",
        "_initializeVeNFT": "_0xc8129f",
        "safeTransferFrom": "_0x7abc5e",
        "create_lock_for": "_0xc60e99",
        "external_bribes": "_0xdc06b3",
        "internal_bribes": "_0x1b0944",
        "setGaugeManager": "_0x9ad765",
        "remainingAmount": "_0xfb0168",
        "calculateShares": "_0x43ea14",
        "calculateAssets": "_0x4c6272",
        "emergencyUnlock": "_0xcd5621",
        "setWithdrawFee": "_0x436483",
        "getLockEndTime": "_0x1bd197",
        "finalAvailable": "_0xf6edaa",
        "sharesReceived": "_0xa0c15f",
        "lastRebaseTime": "_0xb2d2b3",
        "newTotalLocked": "_0x67e1bb",
        "initialAmount": "_0x00c4de",
        "maxUnlockTime": "_0x284b8e",
        "lockedBalance": "_0x17ad5a",
        "_cleanExpired": "_0xb00368",
        "currentLocked": "_0xf9e1bd",
        "internalBribe": "_0xb14032",
        "externalBribe": "_0xd603c5",
        "lastVoteEpoch": "_0xac4718",
        "_votingEscrow": "_0xed5f76",
        "_gaugeManager": "_0xdc0939",
        "nonReentrant": "_0x46ce13",
        "hybrReceived": "_0xcc7487",
        "onlyOperator": "_0xe90de7",
        "transferFrom": "_0xea4289",
        "getUserLocks": "_0xbd8f05",
        "rebaseAmount": "_0x76fdca",
        "votingEscrow": "_0xa19a98",
        "_totalSupply": "_0xf9d920",
        "tokenBalance": "_0xf27774",
        "claimRewards": "_0xe1ed2a",
        "totalBalance": "_0xacb7f5",
        "gaugeManager": "_0xeb40b1",
        "_totalAssets": "_0x520207",
        "totalAssets": "_0x8f5c0d",
        "newTokenIds": "_0x2235c9",
        "userTokenId": "_0xdeff95",
        "bribeTokens": "_0xe915f9",
        "withdrawFee": "_0x37b482",
        "deposit_for": "_0xa4cd82",
        "claimBribes": "_0x45fce0",
        "newOperator": "_0x254785",
        "oldOperator": "_0x3f7f8c",
        "votingYield": "_0xfbee50",
        "totalSupply": "_0xd73546",
        "setOperator": "_0x5593fd",
        "isPermanent": "_0xd50e01",
        "executeSwap": "_0x9fe54c",
        "safeApprove": "_0x783294",
        "hybrBalance": "_0x609c77",
        "feeTokenId": "_0x601d7c",
        "unlockTime": "_0x8e028f",
        "votedPools": "_0xc43de0",
        "tokenCount": "_0xde7502",
        "userAmount": "_0xdb2d76",
        "setSwapper": "_0x62c251",
        "swapToHYBR": "_0xd064e4",
        "oldSwapper": "_0xbfab54",
        "hybrAmount": "_0x5fe0ab",
        "epochStart": "_0x8abb9d",
        "newSwapper": "_0x2c38b9",
        "multiSplit": "_0x46f745",
        "balanceOf": "_0xeab9e3",
        "veBalance": "_0x416975",
        "available": "_0x39fc6e",
        "veTokenId": "_0x14f424",
        "_operator": "_0x2c3dd8",
        "newPeriod": "_0xf4f599",
        "oldPeriod": "_0x5dbf4e",
        "onlyOwner": "_0x13085c",
        "feeAmount": "_0x983560",
        "userLocks": "_0xddab6d",
        "recipient": "_0xa36533",
        "_poolVote": "_0x7e8a27",
        "epochNext": "_0xe0968b",
        "withdraw": "_0x3ebe83",
        "compound": "_0x6ebd9f",
        "_weights": "_0xe5efb5",
        "_swapper": "_0x3ad31c",
        "poolVote": "_0xec1b80",
        "operator": "_0x0f751b",
        "lockTime": "_0x7713e6",
        "amountIn": "_0x473a2f",
        "setVoter": "_0xc31fe3",
        "approve": "_0x70423f",
        "_period": "_0xa93924",
        "amounts": "_0x359bba",
        "weights": "_0x22a754",
        "swapper": "_0x22e07d",
        "penalty": "_0x39dc15",
        "_params": "_0x4549e9",
        "deposit": "_0x4e512c",
        "tokenIn": "_0xf77751",
        "rewards": "_0x1e5f4f",
        "enabled": "_0x2bd059",
        "setTeam": "_0x483522",
        "tokens": "_0x7361b9",
        "_voter": "_0x3705db",
        "locked": "_0xb463b9",
        "bribes": "_0x27a43d",
        "gauges": "_0x9201df",
        "shares": "_0x05758e",
        "rebase": "_0x5ff5a1",
        "amount": "_0x00524f",
        "epoch": "_0xa27f2f",
        "freed": "_0x74ccd5",
        "_team": "_0x5f4112",
        "gauge": "_0x93079f",
        "pools": "_0x7e3808",
        "reset": "_0x5a946d",
        "voter": "_0xad5dc3",
        "owner": "_0xa0e476",
        "_burn": "_0x2a6945",
        "_time": "_0xcbf49a",
        "_HYBR": "_0xcb5f95",
        "_mint": "_0xa9e8aa",
        "voted": "_0x588068",
        "claim": "_0x763b0c",
        "write": "_0xcc8b70",
        "user": "_0xb67c23",
        "vote": "_0xfef4c7",
        "_fee": "_0x585381",
        "fee": "_0x6368f2",
        "end": "_0x59a952",
        "max": "_0x3dc52c",
        "arr": "_0x7a5069",
        "len": "_0x71069b",
        "to": "_0x016c21"
      },
      "changes": [
        "Renamed 151 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_005",
      "transformed_id": "ss_l3_medium_sn_gs_005",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPairInfo.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVotingEscrow.sol';\nimport './interfaces/IGaugeManager.sol';\nimport './interfaces/IPermissionsRegistry.sol';\nimport './interfaces/ITokenHandler.sol';\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract VoterV3 is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public _0x6fa09b;                                         // the ve token that governs these contracts\n    address internal _0x7d440d;                                      // $the token\n    address public _0xddf6fa;                          // registry to check accesses\n    address public _0x9619d2;\n    uint256 public _0xf30a34;\n    uint public EPOCH_DURATION;\n    uint256 internal constant MIN_VOTING_NUM = 10;\n    IGaugeManager public _0x274bc7;\n\n    mapping(uint256 => mapping(address => uint256)) public _0x54fde2;  // nft      => pool     => votes\n    mapping(uint256 => address[]) public _0x68a852;                 // nft      => pools\n\n    mapping(address => uint256) public _0x2fcb25;\n    uint256 public _0xcc7489;\n    mapping(uint256 => uint256) public _0xecf93c;\n\n    mapping(uint256 => uint256) public _0xcd4c8b;                     // nft      => timestamp of last vote (this is shifted to thursday of that epoc)\n    mapping(uint256 => uint256) public _0x6b27c3;            // nft      => timestamp of last vote\n\n    event Voted(address indexed _0xd6e28c, uint256 _0xda489b, uint256 _0x22d0a2);\n    event Abstained(uint256 _0xda489b, uint256 _0x22d0a2);\n    event SetPermissionRegistry(address indexed _0x940bc7, address indexed _0x928650);\n\n    constructor() {}\n\n    // function initialize(address __ve, address _pairFactory, address  _gaugeFactory, address _bribes, address _tokenHandler) initializer public {\n    function _0x4cd392(\n        address __ve,\n        address _0x1e1518,\n        address _0xb01f3d,\n        address _0x2895d9\n    ) public _0xac4ba8 {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _0x6fa09b = __ve;\n        if (gasleft() > 0) { _0x7d440d = IVotingEscrow(__ve)._0xbebe92(); }\n        _0x274bc7 = IGaugeManager(_0xb01f3d);\n        _0xddf6fa = _0x2895d9;\n        _0x9619d2 = _0x1e1518;\n        if (gasleft() > 0) { _0xf30a34 = 30; }\n        EPOCH_DURATION = HybraTimeLibrary.WEEK;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    MODIFIERS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    modifier VoterAdmin() {\n        require(IPermissionsRegistry(_0xddf6fa)._0x8beed8(\"VOTER_ADMIN\",msg.sender), 'VOTER_ADMIN');\n        _;\n    }\n\n    modifier Governance() {\n        require(IPermissionsRegistry(_0xddf6fa)._0x8beed8(\"GOVERNANCE\",msg.sender), 'GOVERNANCE');\n        _;\n    }\n\n    modifier GenesisManager() {\n        require(IPermissionsRegistry(_0xddf6fa)._0x8beed8(\"GENESIS_MANAGER\", msg.sender), 'GENESIS_MANAGER');\n        _;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VoterAdmin\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice Set a new PermissionRegistry\n    function _0x6cc6cc(address _0x2895d9) external VoterAdmin {\n        require(_0x2895d9.code.length > 0, \"CODELEN\");\n        require(_0x2895d9 != address(0), \"ZA\");\n        emit SetPermissionRegistry(_0xddf6fa, _0x2895d9);\n        _0xddf6fa = _0x2895d9;\n    }\n\n    function _0x15df49(uint256 _0xf959e4) external VoterAdmin {\n        require (_0xf959e4 >= MIN_VOTING_NUM, \"LOW_VOTE\");\n        _0xf30a34 = _0xf959e4;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice Reset the votes of a given TokenID\n    function _0xadf2bb(uint256 _0x5dc30e) external _0xf8cee0(_0x5dc30e) _0x13c365 {\n        require(IVotingEscrow(_0x6fa09b)._0x1a78bc(msg.sender, _0x5dc30e), \"NAO\");\n        _0x1064c0(_0x5dc30e);\n        IVotingEscrow(_0x6fa09b)._0x858603(_0x5dc30e);\n    }\n\n    function _0x1064c0(uint256 _0x5dc30e) internal {\n        address[] storage _0x387252 = _0x68a852[_0x5dc30e];\n        uint256 _0xd8e50b = _0x387252.length;\n        uint256 _0x14b8fa = 0;\n\n        for (uint256 i = 0; i < _0xd8e50b; i ++) {\n            address _0x13ccf4 = _0x387252[i];\n            uint256 _0xb121cb = _0x54fde2[_0x5dc30e][_0x13ccf4];\n\n            if (_0xb121cb != 0) {\n                _0x2fcb25[_0x13ccf4] -= _0xb121cb;\n\n                _0x54fde2[_0x5dc30e][_0x13ccf4] -= _0xb121cb;\n                address _0x4634e7 = _0x274bc7._0xa361b1(_0x13ccf4);\n                address _0xc3fbb6 = _0x274bc7._0x8798e4(_0x13ccf4);\n                IBribe(_0x4634e7)._0x4fd59e(uint256(_0xb121cb), _0x5dc30e);\n                IBribe(_0xc3fbb6)._0x4fd59e(uint256(_0xb121cb), _0x5dc30e);\n\n                // decrease totalWeight irrespective of gauge is killed/alive for this current pool\n                _0x14b8fa += _0xb121cb;\n\n                emit Abstained(_0x5dc30e, _0xb121cb);\n            }\n        }\n        _0xcc7489 -= _0x14b8fa;\n        _0xecf93c[_0x5dc30e] = 0;\n        delete _0x68a852[_0x5dc30e];\n    }\n\n    /// @notice Recast the saved votes of a given TokenID\n    function _0x563058(uint256 _0x5dc30e) external _0x13c365 {\n        uint256 _0x9c1191 = block.timestamp;\n        if (_0x9c1191 <= HybraTimeLibrary._0x708539(_0x9c1191)){\n            revert(\"DW\");\n        }\n        require(IVotingEscrow(_0x6fa09b)._0x1a78bc(msg.sender, _0x5dc30e) || msg.sender == _0x6fa09b, \"NAO||VE\");\n        address[] memory _0x387252 = _0x68a852[_0x5dc30e];\n        uint256 _0x4b6967 = _0x387252.length;\n        uint256[] memory _0x2b4332 = new uint256[](_0x4b6967);\n\n        for (uint256 i = 0; i < _0x4b6967; i ++) {\n            _0x2b4332[i] = _0x54fde2[_0x5dc30e][_0x387252[i]];\n        }\n\n        _0x5edc85(_0x5dc30e, _0x387252, _0x2b4332);\n    }\n\n    /// @notice Vote for pools\n    /// @param  _tokenId    veNFT tokenID used to vote\n    /// @param  _poolVote   array of LPs addresses to vote  (eg.: [sAMM usdc-usdt   , sAMM busd-usdt, vAMM wbnb-the ,...])\n    /// @param  _weights    array of weights for each LPs   (eg.: [10               , 90            , 45             ,...])\n    function _0x2ba2ec(uint256 _0x5dc30e, address[] calldata _0x387252, uint256[] calldata _0x2b4332)\n        external _0xf8cee0(_0x5dc30e) _0x13c365 {\n        require(IVotingEscrow(_0x6fa09b)._0x1a78bc(msg.sender, _0x5dc30e), \"NAO\");\n        require(_0x387252.length == _0x2b4332.length, \"MISMATCH_LEN\");\n        require(_0x387252.length <= _0xf30a34, \"EXCEEDS\");\n        uint256 _0x9c1191 = block.timestamp;\n\n        _0x5edc85(_0x5dc30e, _0x387252, _0x2b4332);\n        _0xcd4c8b[_0x5dc30e] = HybraTimeLibrary._0xf6485f(block.timestamp) + 1;\n        _0x6b27c3[_0x5dc30e] = block.timestamp;\n    }\n\n    function _0x5edc85(uint256 _0x5dc30e, address[] memory _0x387252, uint256[] memory _0x2b4332) internal {\n        _0x1064c0(_0x5dc30e);\n        uint256 _0x4b6967 = _0x387252.length;\n        uint256 _0xa69d4e = IVotingEscrow(_0x6fa09b)._0x227cb5(_0x5dc30e);\n        uint256 _0x71db0f = 0;\n        uint256 _0x7f7007 = 0;\n\n        for (uint i = 0; i < _0x4b6967; i++) {\n\n            if(_0x274bc7._0x7971d3(_0x387252[i])) _0x71db0f += _0x2b4332[i];\n        }\n\n        for (uint256 i = 0; i < _0x4b6967; i++) {\n            address _0x13ccf4 = _0x387252[i];\n\n            if (_0x274bc7._0x7971d3(_0x13ccf4)) {\n                uint256 _0x88fa47 = _0x2b4332[i] * _0xa69d4e / _0x71db0f;\n\n                require(_0x54fde2[_0x5dc30e][_0x13ccf4] == 0, \"ZV\");\n                require(_0x88fa47 != 0, \"ZV\");\n\n                _0x68a852[_0x5dc30e].push(_0x13ccf4);\n                _0x2fcb25[_0x13ccf4] += _0x88fa47;\n\n                _0x54fde2[_0x5dc30e][_0x13ccf4] = _0x88fa47;\n                address _0x4634e7 = _0x274bc7._0xa361b1(_0x13ccf4);\n                address _0xc3fbb6 = _0x274bc7._0x8798e4(_0x13ccf4);\n\n                IBribe(_0x4634e7)._0xc077e7(uint256(_0x88fa47), _0x5dc30e);\n                IBribe(_0xc3fbb6)._0xc077e7(uint256(_0x88fa47), _0x5dc30e);\n\n                _0x7f7007 += _0x88fa47;\n                emit Voted(msg.sender, _0x5dc30e, _0x88fa47);\n            }\n        }\n        if (_0x7f7007 > 0) IVotingEscrow(_0x6fa09b)._0x9594f4(_0x5dc30e);\n        _0xcc7489 += _0x7f7007;\n        _0xecf93c[_0x5dc30e] = _0x7f7007;\n    }\n\n    modifier _0xf8cee0(uint256 _0x5dc30e) {\n        // ensure new epoch since last vote\n        if (HybraTimeLibrary._0xf6485f(block.timestamp) <= _0xcd4c8b[_0x5dc30e]) revert(\"VOTED\");\n        if (block.timestamp <= HybraTimeLibrary._0x708539(block.timestamp)) revert(\"DW\");\n        _;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VIEW FUNCTIONS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice view the total length of the pools\n    function length() external view returns (uint256) {\n        return _0x274bc7._0x688fd9().length;\n    }\n\n    /// @notice view the total length of the voted pools given a tokenId\n    function _0x5957d2(uint256 _0xda489b) external view returns(uint256) {\n        return _0x68a852[_0xda489b].length;\n    }\n\n    function _0x9a8b39(address _0xb01f3d) external VoterAdmin {\n        require(_0xb01f3d != address(0));\n        if (true) { _0x274bc7 = IGaugeManager(_0xb01f3d); }\n    }\n\n}",
      "rename_map": {
        "fetchExternalBribeFromPool": "_0x8798e4",
        "fetchInternalBribeFromPool": "_0xa361b1",
        "setPermissionsRegistry": "_0x6cc6cc",
        "_permissionRegistry": "_0x2895d9",
        "isGaugeAliveForPool": "_0x7971d3",
        "permissionRegistry": "_0xddf6fa",
        "lastVotedTimestamp": "_0x6b27c3",
        "isApprovedOrOwner": "_0x1a78bc",
        "_totalVoteWeight": "_0x71db0f",
        "setGaugeManager": "_0x9a8b39",
        "setMaxVotingNum": "_0x15df49",
        "internal_bribe": "_0x4634e7",
        "epochVoteStart": "_0x708539",
        "external_bribe": "_0xc3fbb6",
        "poolVoteLength": "_0x5957d2",
        "_gaugeManager": "_0xb01f3d",
        "_tokenHandler": "_0x1e1518",
        "_maxVotingNum": "_0xf959e4",
        "nonReentrant": "_0x13c365",
        "onlyNewEpoch": "_0xf8cee0",
        "_totalWeight": "_0x14b8fa",
        "gaugeManager": "_0x274bc7",
        "maxVotingNum": "_0xf30a34",
        "balanceOfNFT": "_0x227cb5",
        "tokenHandler": "_0x9619d2",
        "_poolVoteCnt": "_0xd8e50b",
        "usedWeights": "_0xecf93c",
        "totalWeight": "_0xcc7489",
        "_poolWeight": "_0x88fa47",
        "initializer": "_0xac4ba8",
        "_usedWeight": "_0x7f7007",
        "initialize": "_0x4cd392",
        "_timestamp": "_0x9c1191",
        "epochStart": "_0xf6485f",
        "_poolVote": "_0x387252",
        "lastVoted": "_0xcd4c8b",
        "withdraw": "_0x4fd59e",
        "poolVote": "_0x68a852",
        "_tokenId": "_0x5dc30e",
        "_weights": "_0x2b4332",
        "_poolCnt": "_0x4b6967",
        "abstain": "_0x858603",
        "hasRole": "_0x8beed8",
        "tokenId": "_0xda489b",
        "_weight": "_0xa69d4e",
        "deposit": "_0xc077e7",
        "weights": "_0x2fcb25",
        "_reset": "_0x1064c0",
        "latest": "_0x928650",
        "_votes": "_0xb121cb",
        "voting": "_0x9594f4",
        "weight": "_0x22d0a2",
        "votes": "_0x54fde2",
        "_pool": "_0x13ccf4",
        "token": "_0xbebe92",
        "reset": "_0xadf2bb",
        "pools": "_0x688fd9",
        "voter": "_0xd6e28c",
        "_vote": "_0x5edc85",
        "poke": "_0x563058",
        "vote": "_0x2ba2ec",
        "base": "_0x7d440d",
        "old": "_0x940bc7",
        "_ve": "_0x6fa09b"
      },
      "changes": [
        "Renamed 64 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_006",
      "transformed_id": "ss_l3_medium_sn_gs_006",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable _0xc4c79a;\n    address public immutable _0x46e7de;\n    address public VE;\n    address public DISTRIBUTION;\n    address public _0x94dad1;\n    address public _0xb7a841;\n\n    uint256 public DURATION;\n    uint256 internal _0x0efb95;\n    uint256 public _0x6d0ac1;\n    ICLPool public _0x98ccf2;\n    address public _0xa12e09;\n    INonfungiblePositionManager public _0x8c5a8c;\n\n    bool public _0xf344f9;\n    bool public immutable _0xc2bf4a;\n    address immutable _0xadcaa1;\n\n    mapping(uint256 => uint256) public  _0xc552e2; // epoch => reward rate\n    mapping(address => EnumerableSet.UintSet) internal _0xbe27dd;\n    mapping(uint256 => uint256) public  _0xd8b552;\n\n    mapping(uint256 => uint256) public  _0x58b4b2;\n\n    mapping(uint256 => uint256) public  _0xcb9598;\n\n    event RewardAdded(uint256 _0xe69a91);\n    event Deposit(address indexed _0x22ebb5, uint256 _0x98c362);\n    event Withdraw(address indexed _0x22ebb5, uint256 _0x98c362);\n    event Harvest(address indexed _0x22ebb5, uint256 _0xe69a91);\n    event ClaimFees(address indexed from, uint256 _0xae3464, uint256 _0x491fcb);\n    event EmergencyActivated(address indexed _0xe1c620, uint256 timestamp);\n    event EmergencyDeactivated(address indexed _0xe1c620, uint256 timestamp);\n\n    constructor(address _0xf82f5f, address _0xe1e8e9, address _0x15ef47, address _0xf32cb2, address _0xd1888d, address _0xc62c3f,\n        address _0x89ada9, bool _0x844c26, address _0x4dfed5,  address _0x6a3e11) {\n        _0xadcaa1 = _0x6a3e11;\n        _0xc4c79a = IERC20(_0xf82f5f);     // main reward\n        _0x46e7de = _0xe1e8e9;\n        VE = _0x15ef47;                               // vested\n        _0xa12e09 = _0xf32cb2;\n        _0x98ccf2 = ICLPool(_0xf32cb2);\n        DISTRIBUTION = _0xd1888d;           // distro address (GaugeManager)\n        DURATION = HybraTimeLibrary.WEEK;\n\n        _0x94dad1 = _0xc62c3f;       // lp fees goes here\n        _0xb7a841 = _0x89ada9;       // bribe fees goes here\n        _0xc2bf4a = _0x844c26;\n        _0x8c5a8c = INonfungiblePositionManager(_0x4dfed5);\n        _0xf344f9 = false;\n    }\n\n    modifier _0x5d7472() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier _0xaaea2f() {\n        require(_0xf344f9 == false, \"emergency\");\n        _;\n    }\n\n    function _0x0e369e(uint256 _0x70f394, int24 _0x3235b5, int24 _0xe03b69) internal {\n        if (_0xcb9598[_0x70f394] == block.timestamp) return;\n        _0x98ccf2._0xe2f713();\n        _0xcb9598[_0x70f394] = block.timestamp;\n        _0x58b4b2[_0x70f394] += _0x9ff2c7(_0x70f394);\n        _0xd8b552[_0x70f394] = _0x98ccf2._0x6bd8ee(_0x3235b5, _0xe03b69, 0);\n    }\n\n    function _0x51e88c() external _0xf6c1ef {\n        require(_0xf344f9 == false, \"emergency\");\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xf344f9 = true; }\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function _0x3c8220() external _0xf6c1ef {\n\n        require(_0xf344f9 == true,\"emergency\");\n\n        _0xf344f9 = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function _0x897ed7(uint256 _0x70f394) external view returns (uint256) {\n        (,,,,,,,uint128 _0xbfe162,,,,) = _0x8c5a8c._0x8053e4(_0x70f394);\n        return _0xbfe162;\n    }\n\n    function _0x15b5f2(address _0x556085, address _0xc8a7e5, int24 _0x1ae9cd) internal view returns (address) {\n        return ICLFactory(_0x8c5a8c._0xadcaa1())._0x12d8a9(_0x556085, _0xc8a7e5, _0x1ae9cd);\n    }\n\n    function _0x28e9ed(uint256 _0x70f394) external view returns (uint256 _0xe69a91) {\n        require(_0xbe27dd[msg.sender]._0x2a90bc(_0x70f394), \"NA\");\n\n        uint256 _0xe69a91 = _0x9ff2c7(_0x70f394);\n        return (_0xe69a91); // bonsReward is 0 for now\n    }\n\n       function _0x9ff2c7(uint256 _0x70f394) internal view returns (uint256) {\n        uint256 _0x200357 = _0x98ccf2._0x200357();\n\n        uint256 _0x326561 = block.timestamp - _0x200357;\n\n        uint256 _0x568d09 = _0x98ccf2._0x568d09();\n        uint256 _0xc69793 = _0x98ccf2._0xc69793();\n\n        if (_0x326561 != 0 && _0xc69793 > 0 && _0x98ccf2._0x0ff066() > 0) {\n            uint256 _0xe69a91 = _0x6d0ac1 * _0x326561;\n            if (_0xe69a91 > _0xc69793) _0xe69a91 = _0xc69793;\n\n            _0x568d09 += FullMath._0xa2391f(_0xe69a91, FixedPoint128.Q128, _0x98ccf2._0x0ff066());\n        }\n\n        (,,,,, int24 _0x3235b5, int24 _0xe03b69, uint128 _0xbfe162,,,,) = _0x8c5a8c._0x8053e4(_0x70f394);\n\n        uint256 _0x510467 = _0xd8b552[_0x70f394];\n        uint256 _0x63e3f8 = _0x98ccf2._0x6bd8ee(_0x3235b5, _0xe03b69, _0x568d09);\n\n        uint256 _0xfbfefd =\n            FullMath._0xa2391f(_0x63e3f8 - _0x510467, _0xbfe162, FixedPoint128.Q128);\n        return _0xfbfefd;\n    }\n\n    function _0x1d78b5(uint256 _0x70f394) external _0x893b07 _0xaaea2f {\n\n         (,,address _0x556085, address _0xc8a7e5, int24 _0x1ae9cd, int24 _0x3235b5, int24 _0xe03b69, uint128 _0xbfe162,,,,) =\n            _0x8c5a8c._0x8053e4(_0x70f394);\n\n        require(_0xbfe162 > 0, \"Gauge: zero liquidity\");\n        // Calculate pool address from position parameters\n        address _0xe1957b = _0x15b5f2(_0x556085, _0xc8a7e5, _0x1ae9cd);\n        // Verify that the position's pool matches this gauge's pool\n        require(_0xe1957b == _0xa12e09, \"Pool mismatch: Position not for this gauge pool\");\n        // collect fees\n        _0x8c5a8c._0xf2592e(INonfungiblePositionManager.CollectParams({\n                _0x70f394: _0x70f394,\n                _0x835d69: msg.sender,\n                _0xbcba7c: type(uint128)._0x8fb28e,\n                _0x75696c: type(uint128)._0x8fb28e\n            }));\n\n        _0x8c5a8c._0xaece97(msg.sender, address(this), _0x70f394);\n\n        _0x98ccf2._0xe6627a(int128(_0xbfe162), _0x3235b5, _0xe03b69, true);\n\n        uint256 _0x5c9dc8 = _0x98ccf2._0x6bd8ee(_0x3235b5, _0xe03b69, 0);\n        _0xd8b552[_0x70f394] = _0x5c9dc8;\n        _0xcb9598[_0x70f394] = block.timestamp;\n\n        _0xbe27dd[msg.sender]._0x6d7ba0(_0x70f394);\n\n        emit Deposit(msg.sender, _0x70f394);\n    }\n\n    function _0x18a110(uint256 _0x70f394, uint8 _0x482578) external _0x893b07 _0xaaea2f {\n           require(_0xbe27dd[msg.sender]._0x2a90bc(_0x70f394), \"NA\");\n\n        // trigger update on staked position so NFT will be in sync with the pool\n        _0x8c5a8c._0xf2592e(\n            INonfungiblePositionManager.CollectParams({\n                _0x70f394: _0x70f394,\n                _0x835d69: msg.sender,\n                _0xbcba7c: type(uint128)._0x8fb28e,\n                _0x75696c: type(uint128)._0x8fb28e\n            })\n        );\n\n        (,,,,, int24 _0x3235b5, int24 _0xe03b69, uint128 _0xffed38,,,,) = _0x8c5a8c._0x8053e4(_0x70f394);\n        _0x47f031(_0x3235b5, _0xe03b69, _0x70f394, msg.sender, _0x482578);\n\n        // update virtual liquidity in pool only if token has existing liquidity\n        // i.e. not all removed already via decreaseStakedLiquidity\n        if (_0xffed38 != 0) {\n            _0x98ccf2._0xe6627a(-int128(_0xffed38), _0x3235b5, _0xe03b69, true);\n        }\n\n        _0xbe27dd[msg.sender]._0x2a64da(_0x70f394);\n        _0x8c5a8c._0xaece97(address(this), msg.sender, _0x70f394);\n\n        emit Withdraw(msg.sender, _0x70f394);\n    }\n\n    function _0x161ae4(uint256 _0x70f394, address _0x9bee36,uint8 _0x482578 ) public _0x893b07 _0x5d7472 {\n\n        require(_0xbe27dd[_0x9bee36]._0x2a90bc(_0x70f394), \"NA\");\n\n        (,,,,, int24 _0x3235b5, int24 _0xe03b69,,,,,) = _0x8c5a8c._0x8053e4(_0x70f394);\n        _0x47f031(_0x3235b5, _0xe03b69, _0x70f394, _0x9bee36, _0x482578);\n    }\n\n    function _0x47f031(int24 _0x3235b5, int24 _0xe03b69, uint256 _0x70f394,address _0x9bee36, uint8 _0x482578) internal {\n        _0x0e369e(_0x70f394, _0x3235b5, _0xe03b69);\n        uint256 _0xc28b09 = _0x58b4b2[_0x70f394];\n        if(_0xc28b09 > 0){\n            delete _0x58b4b2[_0x70f394];\n            _0xc4c79a._0x45f787(_0x46e7de, _0xc28b09);\n            IRHYBR(_0x46e7de)._0x68de3f(_0xc28b09);\n            IRHYBR(_0x46e7de)._0xda5e69(_0xc28b09, _0x482578, _0x9bee36);\n        }\n        emit Harvest(msg.sender, _0xc28b09);\n    }\n\n    function _0x3521ed(address _0x413600, uint256 _0xc28b09) external _0x893b07\n        _0xaaea2f _0x5d7472 returns (uint256 _0x5fb60c) {\n        require(_0x413600 == address(_0xc4c79a), \"Invalid reward token\");\n\n        // Update global reward growth before processing new rewards\n        _0x98ccf2._0xe2f713();\n\n        // Calculate time remaining until next epoch begins\n        uint256 _0xc95066 = HybraTimeLibrary._0x72c553(block.timestamp) - block.timestamp;\n        uint256 _0x1521ed = block.timestamp + _0xc95066;\n\n        // Include any rolled over rewards from previous period\n        uint256 _0xda122a = _0xc28b09 + _0x98ccf2._0x55a1f6();\n\n        // Check if we are starting a new reward period or continuing existing one\n        if (block.timestamp >= _0x0efb95) {\n            // New period: distribute rewards over remaining epoch time\n            _0x6d0ac1 = _0xc28b09 / _0xc95066;\n            _0x98ccf2._0xd90d51({\n                _0x6d0ac1: _0x6d0ac1,\n                _0xc69793: _0xda122a,\n                _0xb583ac: _0x1521ed\n            });\n        } else {\n            // Existing period: add new rewards to pending distribution\n            uint256 _0x20cacd = _0xc95066 * _0x6d0ac1;\n            _0x6d0ac1 = (_0xc28b09 + _0x20cacd) / _0xc95066;\n            _0x98ccf2._0xd90d51({\n                _0x6d0ac1: _0x6d0ac1,\n                _0xc69793: _0xda122a + _0x20cacd,\n                _0xb583ac: _0x1521ed\n            });\n        }\n\n        // Store reward rate for current epoch tracking\n        _0xc552e2[HybraTimeLibrary._0x49aa15(block.timestamp)] = _0x6d0ac1;\n\n        // Transfer reward tokens from distributor to gauge\n        _0xc4c79a._0xaece97(DISTRIBUTION, address(this), _0xc28b09);\n\n        // Verify contract has sufficient balance to support calculated reward rate\n        uint256 _0x23e4ea = _0xc4c79a._0x897ed7(address(this));\n        require(_0x6d0ac1 <= _0x23e4ea / _0xc95066, \"Insufficient balance for reward rate\");\n\n        // Update period finish time and return current rate\n        _0x0efb95 = _0x1521ed;\n        _0x5fb60c = _0x6d0ac1;\n\n        emit RewardAdded(_0xc28b09);\n    }\n\n    function _0xb13c94() external view returns (uint256 _0x556085, uint256 _0xc8a7e5){\n\n        (_0x556085, _0xc8a7e5) = _0x98ccf2._0x21bc4d();\n\n    }\n\n    function _0xe624e5() external _0x893b07 returns (uint256 _0xae3464, uint256 _0x491fcb) {\n        return _0xb263c3();\n    }\n\n    function _0xb263c3() internal returns (uint256 _0xae3464, uint256 _0x491fcb) {\n        if (!_0xc2bf4a) {\n            return (0, 0);\n        }\n\n        _0x98ccf2._0xed5748();\n\n        address _0x75d126 = _0x98ccf2._0x556085();\n        address _0xe73c33 = _0x98ccf2._0xc8a7e5();\n        // Fetch fee from the whole epoch which just eneded and transfer it to internal Bribe address.\n        _0xae3464 = IERC20(_0x75d126)._0x897ed7(address(this));\n        _0x491fcb = IERC20(_0xe73c33)._0x897ed7(address(this));\n\n        if (_0xae3464 > 0 || _0x491fcb > 0) {\n\n            uint256 _0x0bfd33 = _0xae3464;\n            uint256 _0x1b51d6 = _0x491fcb;\n\n            if (_0x0bfd33  > 0) {\n                IERC20(_0x75d126)._0x45f787(_0x94dad1, 0);\n                IERC20(_0x75d126)._0x45f787(_0x94dad1, _0x0bfd33);\n                IBribe(_0x94dad1)._0x3521ed(_0x75d126, _0x0bfd33);\n            }\n            if (_0x1b51d6  > 0) {\n                IERC20(_0xe73c33)._0x45f787(_0x94dad1, 0);\n                IERC20(_0xe73c33)._0x45f787(_0x94dad1, _0x1b51d6);\n                IBribe(_0x94dad1)._0x3521ed(_0xe73c33, _0x1b51d6);\n            }\n            emit ClaimFees(msg.sender, _0xae3464, _0x491fcb);\n        }\n    }\n\n    ///@notice get total reward for the duration\n    function _0x23d798() external view returns (uint256) {\n        return _0x6d0ac1 * DURATION;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function _0x067592(address _0xd4bf54) external _0xf6c1ef {\n        require(_0xd4bf54 >= address(0), \"zero\");\n        _0x94dad1 = _0xd4bf54;\n    }\n\n    function _0x678565(address _0x413600,address _0x2f5f2a,uint256 value) internal {\n        require(_0x413600.code.length > 0);\n        (bool _0xd32d7f, bytes memory data) = _0x413600.call(abi._0x58f8f2(IERC20.transfer.selector, _0x2f5f2a, value));\n        require(_0xd32d7f && (data.length == 0 || abi._0x479150(data, (bool))));\n    }\n\n    /**\n     * @dev Handle the receipt of an NFT\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function _0xe370c2(\n        address _0xef11fc,\n        address from,\n        uint256 _0x70f394,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver._0xe370c2.selector;\n    }\n\n}\n\n",
      "rename_map": {
        "rewardPerTokenInsideInitialX128": "_0x510467",
        "nonfungiblePositionManager": "_0x8c5a8c",
        "updateRewardsGrowthGlobal": "_0xe2f713",
        "rewardPerTokenInsideX128": "_0x63e3f8",
        "depostionEmissionsToken": "_0x68de3f",
        "rewardGrowthGlobalX128": "_0x568d09",
        "activateEmergencyMode": "_0x51e88c",
        "getRewardGrowthInside": "_0x6bd8ee",
        "epochTimeRemaining": "_0xc95066",
        "rewardGrowthInside": "_0xd8b552",
        "notifyRewardAmount": "_0x3521ed",
        "encodeWithSelector": "_0x58f8f2",
        "epochEndTimestamp": "_0x1521ed",
        "rewardForDuration": "_0x23d798",
        "stopEmergencyMode": "_0x3c8220",
        "rewardRateByEpoch": "_0xc552e2",
        "totalRewardAmount": "_0xda122a",
        "setInternalBribe": "_0x067592",
        "onlyDistribution": "_0x5d7472",
        "liquidityToStake": "_0xffed38",
        "onERC721Received": "_0xe370c2",
        "safeTransferFrom": "_0xaece97",
        "_external_bribe": "_0x89ada9",
        "stakedLiquidity": "_0x0ff066",
        "_getPoolAddress": "_0x15b5f2",
        "contractBalance": "_0x23e4ea",
        "_internal_bribe": "_0xc62c3f",
        "isNotEmergency": "_0xaaea2f",
        "lastUpdateTime": "_0xcb9598",
        "_updateRewards": "_0x0e369e",
        "pendingRewards": "_0x20cacd",
        "external_bribe": "_0xb7a841",
        "internal_bribe": "_0x94dad1",
        "rewardReserve": "_0xc69793",
        "gaugeBalances": "_0xb13c94",
        "_distribution": "_0xd1888d",
        "_safeTransfer": "_0x678565",
        "_periodFinish": "_0x0efb95",
        "nonReentrant": "_0x893b07",
        "_rewardToken": "_0xf82f5f",
        "periodFinish": "_0xb583ac",
        "rewardAmount": "_0xc28b09",
        "rewardGrowth": "_0x5c9dc8",
        "positionPool": "_0xe1957b",
        "currentRate": "_0x5fb60c",
        "tickSpacing": "_0x1ae9cd",
        "poolAddress": "_0xa12e09",
        "lastUpdated": "_0x200357",
        "rewardToken": "_0xc4c79a",
        "collectFees": "_0xed5748",
        "safeApprove": "_0x45f787",
        "_isForPair": "_0x844c26",
        "amount0Max": "_0xbcba7c",
        "syncReward": "_0xd90d51",
        "redeemType": "_0x482578",
        "epochStart": "_0x49aa15",
        "amount1Max": "_0x75696c",
        "rewardRate": "_0x6d0ac1",
        "_getReward": "_0x47f031",
        "_claimFees": "_0xb263c3",
        "balanceOf": "_0x897ed7",
        "timeDelta": "_0x326561",
        "getReward": "_0x161ae4",
        "claimable": "_0xfbfefd",
        "tickUpper": "_0xe03b69",
        "liquidity": "_0xbfe162",
        "onlyOwner": "_0xf6c1ef",
        "recipient": "_0x835d69",
        "emergency": "_0xf344f9",
        "isForPair": "_0xc2bf4a",
        "gaugeFees": "_0x21bc4d",
        "tickLower": "_0x3235b5",
        "claimFees": "_0xe624e5",
        "epochNext": "_0x72c553",
        "redeemFor": "_0xda5e69",
        "positions": "_0x8053e4",
        "withdraw": "_0x18a110",
        "rollover": "_0x55a1f6",
        "_factory": "_0x6a3e11",
        "contains": "_0x2a90bc",
        "claimed0": "_0xae3464",
        "operator": "_0xef11fc",
        "claimed1": "_0x491fcb",
        "collect": "_0xf2592e",
        "getPool": "_0x12d8a9",
        "factory": "_0xadcaa1",
        "tokenId": "_0x70f394",
        "account": "_0x9bee36",
        "_token0": "_0x75d126",
        "deposit": "_0x1d78b5",
        "_earned": "_0x9ff2c7",
        "_token1": "_0xe73c33",
        "rewards": "_0x58b4b2",
        "success": "_0xd32d7f",
        "_stakes": "_0xbe27dd",
        "mulDiv": "_0xa2391f",
        "earned": "_0x28e9ed",
        "_rHYBR": "_0xe1e8e9",
        "token1": "_0xc8a7e5",
        "decode": "_0x479150",
        "_fees1": "_0x1b51d6",
        "_fees0": "_0x0bfd33",
        "token0": "_0x556085",
        "reward": "_0xe69a91",
        "clPool": "_0x98ccf2",
        "amount": "_0x98c362",
        "remove": "_0x2a64da",
        "gauge": "_0xe1c620",
        "stake": "_0xe6627a",
        "token": "_0x413600",
        "_pool": "_0xf32cb2",
        "rHYBR": "_0x46e7de",
        "nfpm": "_0x4dfed5",
        "user": "_0x22ebb5",
        "_int": "_0xd4bf54",
        "_ve": "_0x15ef47",
        "add": "_0x6d7ba0",
        "max": "_0x8fb28e",
        "to": "_0x2f5f2a"
      },
      "changes": [
        "Renamed 119 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_007",
      "transformed_id": "ss_l3_medium_sn_gs_007",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable _0xd7798c;\n    address public immutable _0x2cea87;\n    address public VE;\n    address public DISTRIBUTION;\n    address public _0xed2a19;\n    address public _0x153362;\n\n    uint256 public DURATION;\n    uint256 internal _0xee22da;\n    uint256 public _0x7e4188;\n    ICLPool public _0x9cebf0;\n    address public _0x8e1047;\n    INonfungiblePositionManager public _0xadad59;\n\n    bool public _0x347319;\n    bool public immutable _0xc5523c;\n    address immutable _0x717ece;\n\n    mapping(uint256 => uint256) public  _0xa13679; // epoch => reward rate\n    mapping(address => EnumerableSet.UintSet) internal _0x5b2005;\n    mapping(uint256 => uint256) public  _0x06bbb7;\n\n    mapping(uint256 => uint256) public  _0xf894bc;\n\n    mapping(uint256 => uint256) public  _0x7916e1;\n\n    event RewardAdded(uint256 _0xdf19a6);\n    event Deposit(address indexed _0x3d6692, uint256 _0x92d532);\n    event Withdraw(address indexed _0x3d6692, uint256 _0x92d532);\n    event Harvest(address indexed _0x3d6692, uint256 _0xdf19a6);\n    event ClaimFees(address indexed from, uint256 _0xbc9460, uint256 _0xe707de);\n    event EmergencyActivated(address indexed _0x5728c2, uint256 timestamp);\n    event EmergencyDeactivated(address indexed _0x5728c2, uint256 timestamp);\n\n    constructor(address _0x3dcae3, address _0xb71010, address _0x7974e8, address _0x7c731e, address _0x987d01, address _0xcb35a1,\n        address _0x224f10, bool _0x998ed9, address _0x4dbe39,  address _0x99697b) {\n        _0x717ece = _0x99697b;\n        _0xd7798c = IERC20(_0x3dcae3);     // main reward\n        _0x2cea87 = _0xb71010;\n        VE = _0x7974e8;                               // vested\n        _0x8e1047 = _0x7c731e;\n        _0x9cebf0 = ICLPool(_0x7c731e);\n        DISTRIBUTION = _0x987d01;           // distro address (GaugeManager)\n        DURATION = HybraTimeLibrary.WEEK;\n\n        _0xed2a19 = _0xcb35a1;       // lp fees goes here\n        _0x153362 = _0x224f10;       // bribe fees goes here\n        _0xc5523c = _0x998ed9;\n        _0xadad59 = INonfungiblePositionManager(_0x4dbe39);\n        _0x347319 = false;\n    }\n\n    modifier _0xfac871() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier _0xde51c2() {\n        require(_0x347319 == false, \"emergency\");\n        _;\n    }\n\n    function _0x0a6bd0(uint256 _0xf50e29, int24 _0x987762, int24 _0xb4f989) internal {\n        if (_0x7916e1[_0xf50e29] == block.timestamp) return;\n        _0x9cebf0._0x51a36a();\n        _0x7916e1[_0xf50e29] = block.timestamp;\n        _0xf894bc[_0xf50e29] += _0xef1410(_0xf50e29);\n        _0x06bbb7[_0xf50e29] = _0x9cebf0._0x5cfb18(_0x987762, _0xb4f989, 0);\n    }\n\n    function _0x302e5a() external _0xe79b80 {\n        require(_0x347319 == false, \"emergency\");\n        _0x347319 = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function _0x022f9f() external _0xe79b80 {\n\n        require(_0x347319 == true,\"emergency\");\n\n        _0x347319 = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function _0x92b3ea(uint256 _0xf50e29) external view returns (uint256) {\n        (,,,,,,,uint128 _0x984caf,,,,) = _0xadad59._0x3a6593(_0xf50e29);\n        return _0x984caf;\n    }\n\n    function _0x921d05(address _0x994d79, address _0x1f0e9b, int24 _0x0cb8e1) internal view returns (address) {\n        return ICLFactory(_0xadad59._0x717ece())._0xad6336(_0x994d79, _0x1f0e9b, _0x0cb8e1);\n    }\n\n    function _0xf91ff3(uint256 _0xf50e29) external view returns (uint256 _0xdf19a6) {\n        require(_0x5b2005[msg.sender]._0xb0daff(_0xf50e29), \"NA\");\n\n        uint256 _0xdf19a6 = _0xef1410(_0xf50e29);\n        return (_0xdf19a6); // bonsReward is 0 for now\n    }\n\n       function _0xef1410(uint256 _0xf50e29) internal view returns (uint256) {\n        uint256 _0x14bed8 = _0x9cebf0._0x14bed8();\n\n        uint256 _0xb9e515 = block.timestamp - _0x14bed8;\n\n        uint256 _0x4dc08c = _0x9cebf0._0x4dc08c();\n        uint256 _0x11d09a = _0x9cebf0._0x11d09a();\n\n        if (_0xb9e515 != 0 && _0x11d09a > 0 && _0x9cebf0._0xeb6408() > 0) {\n            uint256 _0xdf19a6 = _0x7e4188 * _0xb9e515;\n            if (_0xdf19a6 > _0x11d09a) _0xdf19a6 = _0x11d09a;\n\n            _0x4dc08c += FullMath._0x9d0c45(_0xdf19a6, FixedPoint128.Q128, _0x9cebf0._0xeb6408());\n        }\n\n        (,,,,, int24 _0x987762, int24 _0xb4f989, uint128 _0x984caf,,,,) = _0xadad59._0x3a6593(_0xf50e29);\n\n        uint256 _0xa1c7da = _0x06bbb7[_0xf50e29];\n        uint256 _0x87e16d = _0x9cebf0._0x5cfb18(_0x987762, _0xb4f989, _0x4dc08c);\n\n        uint256 _0x16a203 =\n            FullMath._0x9d0c45(_0x87e16d - _0xa1c7da, _0x984caf, FixedPoint128.Q128);\n        return _0x16a203;\n    }\n\n    function _0x29f915(uint256 _0xf50e29) external _0x503c96 _0xde51c2 {\n\n         (,,address _0x994d79, address _0x1f0e9b, int24 _0x0cb8e1, int24 _0x987762, int24 _0xb4f989, uint128 _0x984caf,,,,) =\n            _0xadad59._0x3a6593(_0xf50e29);\n\n        require(_0x984caf > 0, \"Gauge: zero liquidity\");\n        // Calculate pool address from position parameters\n        address _0xe29e18 = _0x921d05(_0x994d79, _0x1f0e9b, _0x0cb8e1);\n        // Verify that the position's pool matches this gauge's pool\n        require(_0xe29e18 == _0x8e1047, \"Pool mismatch: Position not for this gauge pool\");\n        // collect fees\n        _0xadad59._0x17bc31(INonfungiblePositionManager.CollectParams({\n                _0xf50e29: _0xf50e29,\n                _0xdf9a6e: msg.sender,\n                _0x1017fa: type(uint128)._0xd71873,\n                _0x33c82e: type(uint128)._0xd71873\n            }));\n\n        _0xadad59._0xa1eda3(msg.sender, address(this), _0xf50e29);\n\n        _0x9cebf0._0xa71882(int128(_0x984caf), _0x987762, _0xb4f989, true);\n\n        uint256 _0xa81007 = _0x9cebf0._0x5cfb18(_0x987762, _0xb4f989, 0);\n        _0x06bbb7[_0xf50e29] = _0xa81007;\n        _0x7916e1[_0xf50e29] = block.timestamp;\n\n        _0x5b2005[msg.sender]._0x09bd36(_0xf50e29);\n\n        emit Deposit(msg.sender, _0xf50e29);\n    }\n\n    function _0x4a0efc(uint256 _0xf50e29, uint8 _0x238cd1) external _0x503c96 _0xde51c2 {\n           require(_0x5b2005[msg.sender]._0xb0daff(_0xf50e29), \"NA\");\n\n        // trigger update on staked position so NFT will be in sync with the pool\n        _0xadad59._0x17bc31(\n            INonfungiblePositionManager.CollectParams({\n                _0xf50e29: _0xf50e29,\n                _0xdf9a6e: msg.sender,\n                _0x1017fa: type(uint128)._0xd71873,\n                _0x33c82e: type(uint128)._0xd71873\n            })\n        );\n\n        (,,,,, int24 _0x987762, int24 _0xb4f989, uint128 _0x94d007,,,,) = _0xadad59._0x3a6593(_0xf50e29);\n        _0x4a5e56(_0x987762, _0xb4f989, _0xf50e29, msg.sender, _0x238cd1);\n\n        // update virtual liquidity in pool only if token has existing liquidity\n        // i.e. not all removed already via decreaseStakedLiquidity\n        if (_0x94d007 != 0) {\n            _0x9cebf0._0xa71882(-int128(_0x94d007), _0x987762, _0xb4f989, true);\n        }\n\n        _0x5b2005[msg.sender]._0xbfd0b1(_0xf50e29);\n        _0xadad59._0xa1eda3(address(this), msg.sender, _0xf50e29);\n\n        emit Withdraw(msg.sender, _0xf50e29);\n    }\n\n    function _0x76dfbc(uint256 _0xf50e29, address _0xb06b03,uint8 _0x238cd1 ) public _0x503c96 _0xfac871 {\n\n        require(_0x5b2005[_0xb06b03]._0xb0daff(_0xf50e29), \"NA\");\n\n        (,,,,, int24 _0x987762, int24 _0xb4f989,,,,,) = _0xadad59._0x3a6593(_0xf50e29);\n        _0x4a5e56(_0x987762, _0xb4f989, _0xf50e29, _0xb06b03, _0x238cd1);\n    }\n\n    function _0x4a5e56(int24 _0x987762, int24 _0xb4f989, uint256 _0xf50e29,address _0xb06b03, uint8 _0x238cd1) internal {\n        _0x0a6bd0(_0xf50e29, _0x987762, _0xb4f989);\n        uint256 _0x95ae15 = _0xf894bc[_0xf50e29];\n        if(_0x95ae15 > 0){\n            delete _0xf894bc[_0xf50e29];\n            _0xd7798c._0x9ddbfb(_0x2cea87, _0x95ae15);\n            IRHYBR(_0x2cea87)._0x5ab3ac(_0x95ae15);\n            IRHYBR(_0x2cea87)._0x822a9f(_0x95ae15, _0x238cd1, _0xb06b03);\n        }\n        emit Harvest(msg.sender, _0x95ae15);\n    }\n\n    function _0xc2d99e(address _0x41ec1f, uint256 _0x95ae15) external _0x503c96\n        _0xde51c2 _0xfac871 returns (uint256 _0x5ddb0e) {\n        require(_0x41ec1f == address(_0xd7798c), \"Invalid reward token\");\n\n        // Update global reward growth before processing new rewards\n        _0x9cebf0._0x51a36a();\n\n        // Calculate time remaining until next epoch begins\n        uint256 _0x12a806 = HybraTimeLibrary._0x9477d0(block.timestamp) - block.timestamp;\n        uint256 _0x8438d7 = block.timestamp + _0x12a806;\n\n        // Include any rolled over rewards from previous period\n        uint256 _0xadf28d = _0x95ae15 + _0x9cebf0._0x4de5d0();\n\n        // Check if we are starting a new reward period or continuing existing one\n        if (block.timestamp >= _0xee22da) {\n            // New period: distribute rewards over remaining epoch time\n            _0x7e4188 = _0x95ae15 / _0x12a806;\n            _0x9cebf0._0xce97b8({\n                _0x7e4188: _0x7e4188,\n                _0x11d09a: _0xadf28d,\n                _0x508f08: _0x8438d7\n            });\n        } else {\n            // Existing period: add new rewards to pending distribution\n            uint256 _0x374f58 = _0x12a806 * _0x7e4188;\n            _0x7e4188 = (_0x95ae15 + _0x374f58) / _0x12a806;\n            _0x9cebf0._0xce97b8({\n                _0x7e4188: _0x7e4188,\n                _0x11d09a: _0xadf28d + _0x374f58,\n                _0x508f08: _0x8438d7\n            });\n        }\n\n        // Store reward rate for current epoch tracking\n        _0xa13679[HybraTimeLibrary._0xa8cc74(block.timestamp)] = _0x7e4188;\n\n        // Transfer reward tokens from distributor to gauge\n        _0xd7798c._0xa1eda3(DISTRIBUTION, address(this), _0x95ae15);\n\n        // Verify contract has sufficient balance to support calculated reward rate\n        uint256 _0x72cdcf = _0xd7798c._0x92b3ea(address(this));\n        require(_0x7e4188 <= _0x72cdcf / _0x12a806, \"Insufficient balance for reward rate\");\n\n        // Update period finish time and return current rate\n        _0xee22da = _0x8438d7;\n        _0x5ddb0e = _0x7e4188;\n\n        emit RewardAdded(_0x95ae15);\n    }\n\n    function _0xc6e0f4() external view returns (uint256 _0x994d79, uint256 _0x1f0e9b){\n\n        (_0x994d79, _0x1f0e9b) = _0x9cebf0._0x0491f6();\n\n    }\n\n    function _0x6fc1ec() external _0x503c96 returns (uint256 _0xbc9460, uint256 _0xe707de) {\n        return _0x6c8128();\n    }\n\n    function _0x6c8128() internal returns (uint256 _0xbc9460, uint256 _0xe707de) {\n        if (!_0xc5523c) {\n            return (0, 0);\n        }\n\n        _0x9cebf0._0x73f7b1();\n\n        address _0x8b8e30 = _0x9cebf0._0x994d79();\n        address _0x9cd0ad = _0x9cebf0._0x1f0e9b();\n        // Fetch fee from the whole epoch which just eneded and transfer it to internal Bribe address.\n        _0xbc9460 = IERC20(_0x8b8e30)._0x92b3ea(address(this));\n        _0xe707de = IERC20(_0x9cd0ad)._0x92b3ea(address(this));\n\n        if (_0xbc9460 > 0 || _0xe707de > 0) {\n\n            uint256 _0x9ad63f = _0xbc9460;\n            uint256 _0xff2123 = _0xe707de;\n\n            if (_0x9ad63f  > 0) {\n                IERC20(_0x8b8e30)._0x9ddbfb(_0xed2a19, 0);\n                IERC20(_0x8b8e30)._0x9ddbfb(_0xed2a19, _0x9ad63f);\n                IBribe(_0xed2a19)._0xc2d99e(_0x8b8e30, _0x9ad63f);\n            }\n            if (_0xff2123  > 0) {\n                IERC20(_0x9cd0ad)._0x9ddbfb(_0xed2a19, 0);\n                IERC20(_0x9cd0ad)._0x9ddbfb(_0xed2a19, _0xff2123);\n                IBribe(_0xed2a19)._0xc2d99e(_0x9cd0ad, _0xff2123);\n            }\n            emit ClaimFees(msg.sender, _0xbc9460, _0xe707de);\n        }\n    }\n\n    ///@notice get total reward for the duration\n    function _0xb2045f() external view returns (uint256) {\n        return _0x7e4188 * DURATION;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function _0xb2bf15(address _0xdd477c) external _0xe79b80 {\n        require(_0xdd477c >= address(0), \"zero\");\n        _0xed2a19 = _0xdd477c;\n    }\n\n    function _0x11bd71(address _0x41ec1f,address _0x1dc5de,uint256 value) internal {\n        require(_0x41ec1f.code.length > 0);\n        (bool _0x39161d, bytes memory data) = _0x41ec1f.call(abi._0x7a9555(IERC20.transfer.selector, _0x1dc5de, value));\n        require(_0x39161d && (data.length == 0 || abi._0x8cd874(data, (bool))));\n    }\n\n    /**\n     * @dev Handle the receipt of an NFT\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function _0x5ab2a1(\n        address _0xeff6df,\n        address from,\n        uint256 _0xf50e29,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver._0x5ab2a1.selector;\n    }\n\n}\n\n",
      "rename_map": {
        "rewardPerTokenInsideInitialX128": "_0xa1c7da",
        "nonfungiblePositionManager": "_0xadad59",
        "updateRewardsGrowthGlobal": "_0x51a36a",
        "rewardPerTokenInsideX128": "_0x87e16d",
        "depostionEmissionsToken": "_0x5ab3ac",
        "rewardGrowthGlobalX128": "_0x4dc08c",
        "activateEmergencyMode": "_0x302e5a",
        "getRewardGrowthInside": "_0x5cfb18",
        "epochTimeRemaining": "_0x12a806",
        "rewardGrowthInside": "_0x06bbb7",
        "notifyRewardAmount": "_0xc2d99e",
        "encodeWithSelector": "_0x7a9555",
        "epochEndTimestamp": "_0x8438d7",
        "rewardForDuration": "_0xb2045f",
        "stopEmergencyMode": "_0x022f9f",
        "rewardRateByEpoch": "_0xa13679",
        "totalRewardAmount": "_0xadf28d",
        "setInternalBribe": "_0xb2bf15",
        "onlyDistribution": "_0xfac871",
        "liquidityToStake": "_0x94d007",
        "onERC721Received": "_0x5ab2a1",
        "safeTransferFrom": "_0xa1eda3",
        "_external_bribe": "_0x224f10",
        "stakedLiquidity": "_0xeb6408",
        "_getPoolAddress": "_0x921d05",
        "contractBalance": "_0x72cdcf",
        "_internal_bribe": "_0xcb35a1",
        "isNotEmergency": "_0xde51c2",
        "lastUpdateTime": "_0x7916e1",
        "_updateRewards": "_0x0a6bd0",
        "pendingRewards": "_0x374f58",
        "external_bribe": "_0x153362",
        "internal_bribe": "_0xed2a19",
        "rewardReserve": "_0x11d09a",
        "gaugeBalances": "_0xc6e0f4",
        "_distribution": "_0x987d01",
        "_safeTransfer": "_0x11bd71",
        "_periodFinish": "_0xee22da",
        "nonReentrant": "_0x503c96",
        "_rewardToken": "_0x3dcae3",
        "periodFinish": "_0x508f08",
        "rewardAmount": "_0x95ae15",
        "rewardGrowth": "_0xa81007",
        "positionPool": "_0xe29e18",
        "currentRate": "_0x5ddb0e",
        "tickSpacing": "_0x0cb8e1",
        "poolAddress": "_0x8e1047",
        "lastUpdated": "_0x14bed8",
        "rewardToken": "_0xd7798c",
        "collectFees": "_0x73f7b1",
        "safeApprove": "_0x9ddbfb",
        "_isForPair": "_0x998ed9",
        "amount0Max": "_0x1017fa",
        "syncReward": "_0xce97b8",
        "redeemType": "_0x238cd1",
        "epochStart": "_0xa8cc74",
        "amount1Max": "_0x33c82e",
        "rewardRate": "_0x7e4188",
        "_getReward": "_0x4a5e56",
        "_claimFees": "_0x6c8128",
        "balanceOf": "_0x92b3ea",
        "timeDelta": "_0xb9e515",
        "getReward": "_0x76dfbc",
        "claimable": "_0x16a203",
        "tickUpper": "_0xb4f989",
        "liquidity": "_0x984caf",
        "onlyOwner": "_0xe79b80",
        "recipient": "_0xdf9a6e",
        "emergency": "_0x347319",
        "isForPair": "_0xc5523c",
        "gaugeFees": "_0x0491f6",
        "tickLower": "_0x987762",
        "claimFees": "_0x6fc1ec",
        "epochNext": "_0x9477d0",
        "redeemFor": "_0x822a9f",
        "positions": "_0x3a6593",
        "withdraw": "_0x4a0efc",
        "rollover": "_0x4de5d0",
        "_factory": "_0x99697b",
        "contains": "_0xb0daff",
        "claimed0": "_0xbc9460",
        "operator": "_0xeff6df",
        "claimed1": "_0xe707de",
        "collect": "_0x17bc31",
        "getPool": "_0xad6336",
        "factory": "_0x717ece",
        "tokenId": "_0xf50e29",
        "account": "_0xb06b03",
        "_token0": "_0x8b8e30",
        "deposit": "_0x29f915",
        "_earned": "_0xef1410",
        "_token1": "_0x9cd0ad",
        "rewards": "_0xf894bc",
        "success": "_0x39161d",
        "_stakes": "_0x5b2005",
        "mulDiv": "_0x9d0c45",
        "earned": "_0xf91ff3",
        "_rHYBR": "_0xb71010",
        "token1": "_0x1f0e9b",
        "decode": "_0x8cd874",
        "_fees1": "_0xff2123",
        "_fees0": "_0x9ad63f",
        "token0": "_0x994d79",
        "reward": "_0xdf19a6",
        "clPool": "_0x9cebf0",
        "amount": "_0x92d532",
        "remove": "_0xbfd0b1",
        "gauge": "_0x5728c2",
        "stake": "_0xa71882",
        "token": "_0x41ec1f",
        "_pool": "_0x7c731e",
        "rHYBR": "_0x2cea87",
        "nfpm": "_0x4dbe39",
        "user": "_0x3d6692",
        "_int": "_0xdd477c",
        "_ve": "_0x7974e8",
        "add": "_0x09bd36",
        "max": "_0xd71873",
        "to": "_0x1dc5de"
      },
      "changes": [
        "Renamed 119 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_008",
      "transformed_id": "ss_l3_medium_sn_gs_008",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title GovernanceHYBR (gHYBR)\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\n */\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Lock period for new deposits (configurable between 12-24 hours)\n    uint256 public _0xe0eef7 = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public _0x220a62 = 1200; // 5days\n    uint256 public _0x0de0a1 = 300; // 1day\n\n    // Withdraw fee configuration (basis points, 10000 = 100%)\n    uint256 public _0xc2c2ac = 100; // 1% default fee\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\n    uint256 public constant BASIS = 10000;\n    address public Team; // Address to receive fees\n    uint256 public _0x14b0c0;\n    uint256 public _0x5f49b2;\n    uint256 public _0xe4ece7;\n    // User deposit tracking for transfer locks\n    struct UserLock {\n        uint256 _0xff82c9;\n        uint256 _0xf23477;\n    }\n\n    mapping(address => UserLock[]) public _0xab9311;\n    mapping(address => uint256) public _0x4a3a45;\n\n    // Core contracts\n    address public immutable HYBR;\n    address public immutable _0x58d027;\n    address public _0x4f9b99;\n    address public _0x718751;\n    address public _0x1569db;\n    uint256 public _0xad72c4; // The veNFT owned by this contract\n\n    // Auto-voting strategy\n    address public _0xc4e758; // Address that can manage voting strategy\n    uint256 public _0xc33e8b; // Last epoch when we voted\n\n    // Reward tracking\n    uint256 public _0x04fdae;\n    uint256 public _0x082728;\n\n    // Swap module\n    ISwapper public _0xa7566b;\n\n    // Errors\n    error NOT_AUTHORIZED();\n\n    // Events\n    event Deposit(address indexed _0x08bb5b, uint256 _0xc3f280, uint256 _0xcc5ce1);\n    event Withdraw(address indexed _0x08bb5b, uint256 _0xe9fdd8, uint256 _0xc3f280, uint256 _0x3b28cc);\n    event Compound(uint256 _0x948c6d, uint256 _0x6cea88);\n    event PenaltyRewardReceived(uint256 _0xff82c9);\n    event TransferLockPeriodUpdated(uint256 _0x8a3880, uint256 _0x63965e);\n    event SwapperUpdated(address indexed _0x1cc1a7, address indexed _0x39351b);\n    event VoterSet(address _0x4f9b99);\n    event EmergencyUnlock(address indexed _0x08bb5b);\n    event AutoVotingEnabled(bool _0xad8fb7);\n    event OperatorUpdated(address indexed _0x6734af, address indexed _0x04d483);\n    event DefaultVotingStrategyUpdated(address[] _0x126c3e, uint256[] _0xe05eee);\n    event AutoVoteExecuted(uint256 _0xa6a6ac, address[] _0x126c3e, uint256[] _0xe05eee);\n\n    constructor(\n        address _0x946451,\n        address _0xa548a2\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_0x946451 != address(0), \"Invalid HYBR\");\n        require(_0xa548a2 != address(0), \"Invalid VE\");\n\n        HYBR = _0x946451;\n        _0x58d027 = _0xa548a2;\n        _0x04fdae = block.timestamp;\n        _0x082728 = block.timestamp;\n        _0xc4e758 = msg.sender; // Initially set deployer as operator\n    }\n\n    function _0x1042d0(address _0x321c05) external _0x00e107 {\n        require(_0x321c05 != address(0), \"Invalid rewards distributor\");\n        if (gasleft() > 0) { _0x718751 = _0x321c05; }\n    }\n\n    function _0x565c1a(address _0x5c0b7d) external _0x00e107 {\n        require(_0x5c0b7d != address(0), \"Invalid gauge manager\");\n        if (gasleft() > 0) { _0x1569db = _0x5c0b7d; }\n    }\n\n      /**\n     * @notice Modifier to check authorization (owner or operator)\n     */\n    modifier _0x9b489e() {\n        if (msg.sender != _0xc4e758) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n    /**\n     * @notice Deposit HYBR and receive gHYBR shares\n     * @param amount Amount of HYBR to deposit\n     * @param recipient Recipient of gHYBR shares\n     */\n    function _0xcd7c26(uint256 _0xff82c9, address _0x2056ce) external _0x52335a {\n        require(_0xff82c9 > 0, \"Zero amount\");\n        _0x2056ce = _0x2056ce == address(0) ? msg.sender : _0x2056ce;\n\n        // Transfer HYBR from user first\n        IERC20(HYBR)._0x324ea5(msg.sender, address(this), _0xff82c9);\n\n        // Initialize veNFT on first deposit\n        if (_0xad72c4 == 0) {\n            _0xe604e1(_0xff82c9);\n        } else {\n            // Add to existing veNFT\n            IERC20(HYBR)._0xe03fed(_0x58d027, _0xff82c9);\n            IVotingEscrow(_0x58d027)._0xdac168(_0xad72c4, _0xff82c9);\n\n            // Extend lock to maximum duration\n            _0x7dbf21();\n        }\n\n        // Calculate shares to mint based on current totalAssets\n        uint256 _0xe9fdd8 = _0xfe91e2(_0xff82c9);\n\n        // Mint gHYBR shares\n        _0xa22fd6(_0x2056ce, _0xe9fdd8);\n\n        // Add transfer lock for recipient\n        _0x2f5716(_0x2056ce, _0xe9fdd8);\n\n        emit Deposit(msg.sender, _0xff82c9, _0xe9fdd8);\n    }\n\n    /**\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\n     * @param shares Amount of gHYBR shares to burn\n     * @return userTokenId The ID of the new veNFT created for the user\n     */\n    function _0x8f2ceb(uint256 _0xe9fdd8) external _0x52335a returns (uint256 _0xa1215c) {\n        require(_0xe9fdd8 > 0, \"Zero shares\");\n        require(_0x857aeb(msg.sender) >= _0xe9fdd8, \"Insufficient balance\");\n        require(_0xad72c4 != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(_0x58d027)._0x16ad4d(_0xad72c4) == false, \"Cannot withdraw yet\");\n\n        uint256 _0x89411a = HybraTimeLibrary._0x89411a(block.timestamp);\n        uint256 _0x098e4f = HybraTimeLibrary._0x098e4f(block.timestamp);\n\n        require(block.timestamp >= _0x89411a + _0x220a62 && block.timestamp < _0x098e4f - _0x0de0a1, \"Cannot withdraw yet\");\n\n        // Calculate proportional HYBR amount from veNFT\n        uint256 _0xc3f280 = _0x8574ef(_0xe9fdd8);\n        require(_0xc3f280 > 0, \"No assets to withdraw\");\n\n        // Calculate fee amount (from the HYBR amount, not shares)\n        uint256 _0xfb503e = 0;\n        if (_0xc2c2ac > 0) {\n            _0xfb503e = (_0xc3f280 * _0xc2c2ac) / BASIS;\n        }\n\n        // User receives amount minus fee\n        uint256 _0xd6abea = _0xc3f280 - _0xfb503e;\n        require(_0xd6abea > 0, \"Amount too small after fee\");\n\n        // Get actual HYBR locked amount (not voting power)\n        uint256 _0x1fd3ec = _0x457b1a();\n        require(_0xc3f280 <= _0x1fd3ec, \"Insufficient veNFT balance\");\n\n        uint256 _0xea77e2 = _0x1fd3ec - _0xd6abea - _0xfb503e;\n        require(_0xea77e2 >= 0, \"Cannot withdraw entire veNFT\");\n\n        // Burn gHYBR shares (full amount)\n        _0xa55b13(msg.sender, _0xe9fdd8);\n\n        // Use multiSplit to create two NFTs: one for user, one for contract\n        uint256[] memory _0x68fb10 = new uint256[](3);\n        _0x68fb10[0] = _0xea77e2; // Amount staying with gHYBR\n        _0x68fb10[1] = _0xd6abea;      // Amount going to user (after fee)\n        _0x68fb10[2] = _0xfb503e;      // Amount going to fee recipient\n\n        uint256[] memory _0x8b1c51 = IVotingEscrow(_0x58d027)._0xf871b6(_0xad72c4, _0x68fb10);\n\n        // Update contract's veTokenId to the first new token\n        _0xad72c4 = _0x8b1c51[0];\n        _0xa1215c = _0x8b1c51[1];\n        uint256 _0x3d99e1 = _0x8b1c51[2];\n        // Note: userTokenId is transferred to user, they can manage their own lock time\n        IVotingEscrow(_0x58d027)._0xeb4b6e(address(this), msg.sender, _0xa1215c);\n        IVotingEscrow(_0x58d027)._0xeb4b6e(address(this), Team, _0x3d99e1);\n        emit Withdraw(msg.sender, _0xe9fdd8, _0xd6abea, _0xfb503e);\n    }\n\n    /**\n     * @notice Internal function to initialize veNFT on first deposit\n     */\n    function _0xe604e1(uint256 _0x0dcf1c) internal {\n        // Create max lock with the initial deposit amount\n        IERC20(HYBR)._0xe03fed(_0x58d027, type(uint256)._0x461195);\n        uint256 _0xd041d6 = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n        // Create lock with initial amount\n        _0xad72c4 = IVotingEscrow(_0x58d027)._0xa35319(_0x0dcf1c, _0xd041d6, address(this));\n\n    }\n\n    /**\n     * @notice Calculate shares to mint based on deposit amount\n     */\n    function _0xfe91e2(uint256 _0xff82c9) public view returns (uint256) {\n        uint256 _0x89fa13 = _0x697d50();\n        uint256 _0xb83531 = _0x457b1a();\n        if (_0x89fa13 == 0 || _0xb83531 == 0) {\n            return _0xff82c9;\n        }\n        return (_0xff82c9 * _0x89fa13) / _0xb83531;\n    }\n\n    /**\n     * @notice Calculate HYBR value of shares\n     */\n    function _0x8574ef(uint256 _0xe9fdd8) public view returns (uint256) {\n        uint256 _0x89fa13 = _0x697d50();\n        if (_0x89fa13 == 0) {\n            return _0xe9fdd8;\n        }\n        return (_0xe9fdd8 * _0x457b1a()) / _0x89fa13;\n    }\n\n    /**\n     * @notice Get total assets (HYBR) locked in veNFT\n     * @dev Returns actual HYBR amount, not voting power\n     */\n    function _0x457b1a() public view returns (uint256) {\n        if (_0xad72c4 == 0) {\n            return 0;\n        }\n        // Get actual locked HYBR amount, not voting power\n        IVotingEscrow.LockedBalance memory _0x037e61 = IVotingEscrow(_0x58d027)._0x037e61(_0xad72c4);\n        return uint256(int256(_0x037e61._0xff82c9));\n    }\n\n    /**\n     * @notice Add transfer lock for new deposits\n     */\n    function _0x2f5716(address _0x08bb5b, uint256 _0xff82c9) internal {\n        uint256 _0xf23477 = block.timestamp + _0xe0eef7;\n        _0xab9311[_0x08bb5b].push(UserLock({\n            _0xff82c9: _0xff82c9,\n            _0xf23477: _0xf23477\n        }));\n        _0x4a3a45[_0x08bb5b] += _0xff82c9;\n    }\n\n    /**\n     * @notice Preview available balance (total - currently locked)\n     * @param user The user address to check\n     * @return available The current available balance for transfer\n     */\n    function _0x551e29(address _0x08bb5b) external view returns (uint256 _0xb02078) {\n        uint256 _0x227d88 = _0x857aeb(_0x08bb5b);\n        uint256 _0x8b7d3e = 0;\n\n        UserLock[] storage _0xedf23f = _0xab9311[_0x08bb5b];\n        for (uint256 i = 0; i < _0xedf23f.length; i++) {\n            if (_0xedf23f[i]._0xf23477 > block.timestamp) {\n                _0x8b7d3e += _0xedf23f[i]._0xff82c9;\n            }\n        }\n\n        return _0x227d88 > _0x8b7d3e ? _0x227d88 - _0x8b7d3e : 0;\n    }\n    /**\n     * @notice Clean expired locks and update locked balance\n     * @param user The user address to clean locks for\n     * @return freed The amount of tokens freed from expired locks\n     */\n    function _0xc9ca8a(address _0x08bb5b) internal returns (uint256 _0x23fc6e) {\n        UserLock[] storage _0xedf23f = _0xab9311[_0x08bb5b];\n        uint256 _0x43dd7b = _0xedf23f.length;\n        if (_0x43dd7b == 0) return 0;\n\n        uint256 _0x0ffccc = 0;\n        unchecked {\n            for (uint256 i = 0; i < _0x43dd7b; i++) {\n                UserLock memory L = _0xedf23f[i];\n                if (L._0xf23477 <= block.timestamp) {\n                    _0x23fc6e += L._0xff82c9;\n                } else {\n                    if (_0x0ffccc != i) _0xedf23f[_0x0ffccc] = L;\n                    _0x0ffccc++;\n                }\n            }\n            if (_0x23fc6e > 0) {\n                _0x4a3a45[_0x08bb5b] -= _0x23fc6e;\n            }\n            while (_0xedf23f.length > _0x0ffccc) {\n                _0xedf23f.pop();\n            }\n        }\n    }\n\n    /**\n     * @notice Override transfer to implement lock mechanism\n     */\n    function _0x3a3579(\n        address from,\n        address _0xb8c4a5,\n        uint256 _0xff82c9\n    ) internal override {\n        super._0x3a3579(from, _0xb8c4a5, _0xff82c9);\n\n        if (from != address(0) && _0xb8c4a5 != address(0)) { // Not mint or burn\n            uint256 _0x227d88 = _0x857aeb(from);\n\n            // Step 1: Check current available balance using cached lockedBalance\n            uint256 _0x10cadb = _0x227d88 > _0x4a3a45[from] ? _0x227d88 - _0x4a3a45[from] : 0;\n\n            // Step 2: If current available >= amount, pass directly\n            if (_0x10cadb >= _0xff82c9) {\n                return;\n            }\n\n            // Step 3: Not enough, clean expired locks and recalculate\n            _0xc9ca8a(from);\n            uint256 _0x4f676d = _0x227d88 > _0x4a3a45[from] ? _0x227d88 - _0x4a3a45[from] : 0;\n\n            // Step 4: Check final available balance\n            require(_0x4f676d >= _0xff82c9, \"Tokens locked\");\n        }\n    }\n\n    /**\n     * @notice Claim all rewards from voting and rebase\n     */\n    function _0xeedb0c() external _0x9b489e {\n        require(_0x4f9b99 != address(0), \"Voter not set\");\n        require(_0x718751 != address(0), \"Distributor not set\");\n\n        // Claim rebase rewards from RewardsDistributor\n        uint256  _0x1f65c6 = IRewardsDistributor(_0x718751)._0x4c122e(_0xad72c4);\n        _0x14b0c0 += _0x1f65c6;\n        // Claim bribes from voted pools\n        address[] memory _0x00a6fe = IVoter(_0x4f9b99)._0xd4a7dd(_0xad72c4);\n\n        for (uint256 i = 0; i < _0x00a6fe.length; i++) {\n            if (_0x00a6fe[i] != address(0)) {\n                address _0x1039dc = IGaugeManager(_0x1569db)._0x144b0e(_0x00a6fe[i]);\n\n                if (_0x1039dc != address(0)) {\n                    // Prepare arrays for single bribe claim\n                    address[] memory _0x6d7b3b = new address[](1);\n                    address[][] memory _0xe85560 = new address[][](1);\n\n                    // Claim internal bribe (trading fees)\n                    address _0x26fedb = IGaugeManager(_0x1569db)._0x219aff(_0x1039dc);\n                    if (_0x26fedb != address(0)) {\n                        uint256 _0x6dcc9e = IBribe(_0x26fedb)._0x024058();\n                        if (_0x6dcc9e > 0) {\n                            address[] memory _0x08becb = new address[](_0x6dcc9e);\n                            for (uint256 j = 0; j < _0x6dcc9e; j++) {\n                                _0x08becb[j] = IBribe(_0x26fedb)._0x08becb(j);\n                            }\n                            _0x6d7b3b[0] = _0x26fedb;\n                            _0xe85560[0] = _0x08becb;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x1569db)._0xb80dcd(_0x6d7b3b, _0xe85560, _0xad72c4);\n                        }\n                    }\n\n                    // Claim external bribe\n                    address _0xf86f07 = IGaugeManager(_0x1569db)._0x064b9f(_0x1039dc);\n                    if (_0xf86f07 != address(0)) {\n                        uint256 _0x6dcc9e = IBribe(_0xf86f07)._0x024058();\n                        if (_0x6dcc9e > 0) {\n                            address[] memory _0x08becb = new address[](_0x6dcc9e);\n                            for (uint256 j = 0; j < _0x6dcc9e; j++) {\n                                _0x08becb[j] = IBribe(_0xf86f07)._0x08becb(j);\n                            }\n                            _0x6d7b3b[0] = _0xf86f07;\n                            _0xe85560[0] = _0x08becb;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x1569db)._0xb80dcd(_0x6d7b3b, _0xe85560, _0xad72c4);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Execute swap through the configured swapper module\n     * @param _params Swap parameters for the swapper module\n     */\n    function _0x17d6a3(ISwapper.SwapParams calldata _0x676893) external _0x52335a _0x9b489e {\n        require(address(_0xa7566b) != address(0), \"Swapper not set\");\n\n        // Get token balance before swap\n        uint256 _0x0bfa0a = IERC20(_0x676893._0xd54330)._0x857aeb(address(this));\n        require(_0x0bfa0a >= _0x676893._0x8e512a, \"Insufficient token balance\");\n\n        // Approve swapper to spend tokens\n        IERC20(_0x676893._0xd54330)._0xf38950(address(_0xa7566b), _0x676893._0x8e512a);\n\n        // Execute swap through swapper module\n        uint256 _0x138abc = _0xa7566b._0xf0a2f7(_0x676893);\n\n        // Reset approval for safety\n        IERC20(_0x676893._0xd54330)._0xf38950(address(_0xa7566b), 0);\n\n        // HYBR is now in this contract, ready for compounding\n        _0xe4ece7 += _0x138abc;\n    }\n\n    /**\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\n     */\n    function _0xa56aa6() external _0x9b489e {\n\n        // Get current HYBR balance\n        uint256 _0x93a345 = IERC20(HYBR)._0x857aeb(address(this));\n\n        if (_0x93a345 > 0) {\n            // Lock all HYBR to existing veNFT\n            IERC20(HYBR)._0xf38950(_0x58d027, _0x93a345);\n            IVotingEscrow(_0x58d027)._0xdac168(_0xad72c4, _0x93a345);\n\n            // Extend lock to maximum duration\n            _0x7dbf21();\n\n            if (true) { _0x082728 = block.timestamp; }\n\n            emit Compound(_0x93a345, _0x457b1a());\n        }\n    }\n\n    /**\n     * @notice Vote for gauges using the veNFT\n     * @param _poolVote Array of pools to vote for\n     * @param _weights Array of weights for each pool\n     */\n    function _0xa9816c(address[] calldata _0x65f60b, uint256[] calldata _0x19b88f) external {\n        require(msg.sender == _0x4d2699() || msg.sender == _0xc4e758, \"Not authorized\");\n        require(_0x4f9b99 != address(0), \"Voter not set\");\n\n        IVoter(_0x4f9b99)._0xa9816c(_0xad72c4, _0x65f60b, _0x19b88f);\n        if (gasleft() > 0) { _0xc33e8b = HybraTimeLibrary._0x89411a(block.timestamp); }\n\n    }\n\n    /**\n     * @notice Reset votes\n     */\n    function _0x1e1ddf() external {\n        require(msg.sender == _0x4d2699() || msg.sender == _0xc4e758, \"Not authorized\");\n        require(_0x4f9b99 != address(0), \"Voter not set\");\n\n        IVoter(_0x4f9b99)._0x1e1ddf(_0xad72c4);\n    }\n\n    /**\n     * @notice Receive penalty rewards from rHYBR conversions\n     */\n    function _0xdd8f90(uint256 _0xff82c9) external {\n\n        // Auto-compound penalty rewards to existing veNFT\n        if (_0xff82c9 > 0) {\n            IERC20(HYBR)._0xe03fed(_0x58d027, _0xff82c9);\n\n            if(_0xad72c4 == 0){\n                _0xe604e1(_0xff82c9);\n            } else{\n                IVotingEscrow(_0x58d027)._0xdac168(_0xad72c4, _0xff82c9);\n\n                // Extend lock to maximum duration\n                _0x7dbf21();\n            }\n        }\n        _0x5f49b2 += _0xff82c9;\n        emit PenaltyRewardReceived(_0xff82c9);\n    }\n\n    /**\n     * @notice Set the voter contract\n     */\n    function _0x9fc35b(address _0xad999c) external _0x00e107 {\n        require(_0xad999c != address(0), \"Invalid voter\");\n        _0x4f9b99 = _0xad999c;\n        emit VoterSet(_0xad999c);\n    }\n\n    /**\n     * @notice Update transfer lock period\n     */\n    function _0x86dc7e(uint256 _0x2b1b08) external _0x00e107 {\n        require(_0x2b1b08 >= MIN_LOCK_PERIOD && _0x2b1b08 <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 _0x8a3880 = _0xe0eef7;\n        _0xe0eef7 = _0x2b1b08;\n        emit TransferLockPeriodUpdated(_0x8a3880, _0x2b1b08);\n    }\n\n    /**\n     * @notice Set withdraw fee (in basis points)\n     * @param _fee Fee amount (10-30 basis points)\n     */\n    function _0x085cca(uint256 _0x127eeb) external _0x00e107 {\n        require(_0x127eeb >= MIN_WITHDRAW_FEE && _0x127eeb <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        _0xc2c2ac = _0x127eeb;\n    }\n\n    function _0x4e1fdc(uint256 _0x6f62d0) external _0x00e107 {\n        _0x220a62 = _0x6f62d0;\n    }\n\n    function _0x1b6a81(uint256 _0x6f62d0) external _0x00e107 {\n        _0x0de0a1 = _0x6f62d0;\n    }\n\n    /**\n     * @notice Set the swapper module\n     * @param _swapper Address of the swapper module\n     */\n    function _0x9fe9ee(address _0xd5c1ba) external _0x00e107 {\n        require(_0xd5c1ba != address(0), \"Invalid swapper\");\n        address _0x1cc1a7 = address(_0xa7566b);\n        _0xa7566b = ISwapper(_0xd5c1ba);\n        emit SwapperUpdated(_0x1cc1a7, _0xd5c1ba);\n    }\n\n    /**\n     * @notice Set the team address\n     */\n    function _0xf43353(address _0xf1906f) external _0x00e107 {\n        require(_0xf1906f != address(0), \"Invalid team\");\n        if (1 == 1) { Team = _0xf1906f; }\n    }\n\n    /**\n     * @notice Emergency unlock for a user (owner only)\n     */\n    function _0xb33f99(address _0x08bb5b) external _0x9b489e {\n        delete _0xab9311[_0x08bb5b];\n        _0x4a3a45[_0x08bb5b] = 0;\n        emit EmergencyUnlock(_0x08bb5b);\n    }\n\n    /**\n     * @notice Get user's locks info\n     */\n    function _0x50f90a(address _0x08bb5b) external view returns (UserLock[] memory) {\n        return _0xab9311[_0x08bb5b];\n    }\n\n    /**\n     * @notice Set operator address\n     */\n    function _0xa44ff3(address _0x35979b) external _0x00e107 {\n        require(_0x35979b != address(0), \"Invalid operator\");\n        address _0x6734af = _0xc4e758;\n        if (true) { _0xc4e758 = _0x35979b; }\n        emit OperatorUpdated(_0x6734af, _0x35979b);\n    }\n\n    /**\n     * @notice Get veNFT lock end time\n     */\n    function _0xd2fe26() external view returns (uint256) {\n        if (_0xad72c4 == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory _0x037e61 = IVotingEscrow(_0x58d027)._0x037e61(_0xad72c4);\n        return uint256(_0x037e61._0xbaed85);\n    }\n\n    /**\n     * @notice Internal helper to safely extend lock to maximum duration\n     * @dev Calculates exact duration needed to reach max allowed unlock time\n     */\n    function _0x7dbf21() internal {\n        if (_0xad72c4 == 0) return;\n\n        IVotingEscrow.LockedBalance memory _0x037e61 = IVotingEscrow(_0x58d027)._0x037e61(_0xad72c4);\n        if (_0x037e61._0xd96ef7 || _0x037e61._0xbaed85 <= block.timestamp) return;\n\n        uint256 _0xc0b5e6 = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n        // Only extend if difference is more than 2 hours\n        if (_0xc0b5e6 > _0x037e61._0xbaed85 + 2 hours) {\n            try IVotingEscrow(_0x58d027)._0x0cbb8f(_0xad72c4, HybraTimeLibrary.MAX_LOCK_DURATION) {\n                // Extension successful\n            } catch {\n                // Extension failed, continue without error\n                // This can happen if already at max possible time or other constraints\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setTailNotWithdrawTime": "_0x1b6a81",
        "head_not_withdraw_time": "_0x220a62",
        "tail_not_withdraw_time": "_0x0de0a1",
        "setHeadNotWithdrawTime": "_0x4e1fdc",
        "setTransferLockPeriod": "_0x86dc7e",
        "setRewardsDistributor": "_0x1042d0",
        "increase_unlock_time": "_0x0cbb8f",
        "_beforeTokenTransfer": "_0x3a3579",
        "receivePenaltyReward": "_0xdd8f90",
        "_rewardsDistributor": "_0x321c05",
        "rewardsDistributor": "_0x718751",
        "transferLockPeriod": "_0xe0eef7",
        "rewardsListLength": "_0x024058",
        "lastCompoundTime": "_0x082728",
        "currentAvailable": "_0x10cadb",
        "previewAvailable": "_0x551e29",
        "_addTransferLock": "_0x2f5716",
        "_extendLockToMax": "_0x7dbf21",
        "_initializeVeNFT": "_0xe604e1",
        "safeTransferFrom": "_0xeb4b6e",
        "create_lock_for": "_0xa35319",
        "external_bribes": "_0x064b9f",
        "internal_bribes": "_0x219aff",
        "setGaugeManager": "_0x565c1a",
        "remainingAmount": "_0xea77e2",
        "calculateShares": "_0xfe91e2",
        "calculateAssets": "_0x8574ef",
        "emergencyUnlock": "_0xb33f99",
        "setWithdrawFee": "_0x085cca",
        "getLockEndTime": "_0xd2fe26",
        "finalAvailable": "_0x4f676d",
        "sharesReceived": "_0xcc5ce1",
        "lastRebaseTime": "_0x04fdae",
        "newTotalLocked": "_0x6cea88",
        "initialAmount": "_0x0dcf1c",
        "maxUnlockTime": "_0xc0b5e6",
        "lockedBalance": "_0x4a3a45",
        "_cleanExpired": "_0xc9ca8a",
        "currentLocked": "_0x8b7d3e",
        "internalBribe": "_0x26fedb",
        "externalBribe": "_0xf86f07",
        "lastVoteEpoch": "_0xc33e8b",
        "_votingEscrow": "_0xa548a2",
        "_gaugeManager": "_0x5c0b7d",
        "nonReentrant": "_0x52335a",
        "hybrReceived": "_0x138abc",
        "onlyOperator": "_0x9b489e",
        "transferFrom": "_0x324ea5",
        "getUserLocks": "_0x50f90a",
        "rebaseAmount": "_0x1f65c6",
        "votingEscrow": "_0x58d027",
        "_totalSupply": "_0x89fa13",
        "tokenBalance": "_0x0bfa0a",
        "claimRewards": "_0xeedb0c",
        "totalBalance": "_0x227d88",
        "gaugeManager": "_0x1569db",
        "_totalAssets": "_0xb83531",
        "totalAssets": "_0x457b1a",
        "newTokenIds": "_0x8b1c51",
        "userTokenId": "_0xa1215c",
        "bribeTokens": "_0x08becb",
        "withdrawFee": "_0xc2c2ac",
        "deposit_for": "_0xdac168",
        "claimBribes": "_0xb80dcd",
        "newOperator": "_0x04d483",
        "oldOperator": "_0x6734af",
        "votingYield": "_0xe4ece7",
        "totalSupply": "_0x697d50",
        "setOperator": "_0xa44ff3",
        "isPermanent": "_0xd96ef7",
        "executeSwap": "_0x17d6a3",
        "safeApprove": "_0xf38950",
        "hybrBalance": "_0x93a345",
        "feeTokenId": "_0x3d99e1",
        "unlockTime": "_0xf23477",
        "votedPools": "_0x00a6fe",
        "tokenCount": "_0x6dcc9e",
        "userAmount": "_0xd6abea",
        "setSwapper": "_0x9fe9ee",
        "swapToHYBR": "_0xf0a2f7",
        "oldSwapper": "_0x1cc1a7",
        "hybrAmount": "_0xc3f280",
        "epochStart": "_0x89411a",
        "newSwapper": "_0x39351b",
        "multiSplit": "_0xf871b6",
        "balanceOf": "_0x857aeb",
        "veBalance": "_0x1fd3ec",
        "available": "_0xb02078",
        "veTokenId": "_0xad72c4",
        "_operator": "_0x35979b",
        "newPeriod": "_0x63965e",
        "oldPeriod": "_0x8a3880",
        "onlyOwner": "_0x00e107",
        "feeAmount": "_0xfb503e",
        "userLocks": "_0xab9311",
        "recipient": "_0x2056ce",
        "_poolVote": "_0x65f60b",
        "epochNext": "_0x098e4f",
        "withdraw": "_0x8f2ceb",
        "compound": "_0xa56aa6",
        "_weights": "_0x19b88f",
        "_swapper": "_0xd5c1ba",
        "poolVote": "_0xd4a7dd",
        "operator": "_0xc4e758",
        "lockTime": "_0xd041d6",
        "amountIn": "_0x8e512a",
        "setVoter": "_0x9fc35b",
        "approve": "_0xe03fed",
        "_period": "_0x2b1b08",
        "amounts": "_0x68fb10",
        "weights": "_0xe05eee",
        "swapper": "_0xa7566b",
        "penalty": "_0x5f49b2",
        "_params": "_0x676893",
        "deposit": "_0xcd7c26",
        "tokenIn": "_0xd54330",
        "rewards": "_0x948c6d",
        "enabled": "_0xad8fb7",
        "setTeam": "_0xf43353",
        "tokens": "_0xe85560",
        "_voter": "_0xad999c",
        "locked": "_0x037e61",
        "bribes": "_0x6d7b3b",
        "gauges": "_0x144b0e",
        "shares": "_0xe9fdd8",
        "rebase": "_0x14b0c0",
        "amount": "_0xff82c9",
        "epoch": "_0xa6a6ac",
        "freed": "_0x23fc6e",
        "_team": "_0xf1906f",
        "gauge": "_0x1039dc",
        "pools": "_0x126c3e",
        "reset": "_0x1e1ddf",
        "voter": "_0x4f9b99",
        "owner": "_0x4d2699",
        "_burn": "_0xa55b13",
        "_time": "_0x6f62d0",
        "_HYBR": "_0x946451",
        "_mint": "_0xa22fd6",
        "voted": "_0x16ad4d",
        "claim": "_0x4c122e",
        "write": "_0x0ffccc",
        "user": "_0x08bb5b",
        "vote": "_0xa9816c",
        "_fee": "_0x127eeb",
        "fee": "_0x3b28cc",
        "end": "_0xbaed85",
        "max": "_0x461195",
        "arr": "_0xedf23f",
        "len": "_0x43dd7b",
        "to": "_0xb8c4a5"
      },
      "changes": [
        "Renamed 151 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_009",
      "transformed_id": "ss_l3_medium_sn_gs_009",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IHybra.sol\";\nimport {IHybraVotes} from \"./interfaces/IHybraVotes.sol\";\nimport {IVeArtProxy} from \"./interfaces/IVeArtProxy.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport {VotingDelegationLib} from \"./libraries/VotingDelegationLib.sol\";\nimport {VotingBalanceLogic} from \"./libraries/VotingBalanceLogic.sol\";\n\n/// @title Voting Escrow\n/// @notice veNFT implementation that escrows ERC-20 tokens in the form of an ERC-721 NFT\n/// @notice Votes have a weight depending on time, so that users are committed to the future of (whatever they are voting for)\n/// @author Modified from Solidly (https://github.com/solidlyexchange/solidly/blob/master/contracts/ve.sol)\n/// @author Modified from Curve (https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n/// @author Modified from Nouns DAO (https://github.com/withtally/my-nft-dao-project/blob/main/contracts/ERC721Checkpointable.sol)\n/// @dev Vote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (2 years).\ncontract VotingEscrow is IERC721, IERC721Metadata, IHybraVotes {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed _0xa57699,\n        uint _0xf9b79a,\n        uint value,\n        uint indexed _0x7b807b,\n        DepositType _0x09a3bc,\n        uint _0x3817a1\n    );\n\n    event Merge(\n        address indexed _0x0a5fd7,\n        uint256 indexed _0xf1bd82,\n        uint256 indexed _0x86fe88,\n        uint256 _0x3e7ef0,\n        uint256 _0xc8f922,\n        uint256 _0xf4920f,\n        uint256 _0x991ab9,\n        uint256 _0xb0122a\n    );\n    event Split(\n        uint256 indexed _0xf1bd82,\n        uint256 indexed _0x66c40e,\n        uint256 indexed _0xddbb19,\n        address _0x0a5fd7,\n        uint256 _0xed3622,\n        uint256 _0x63619f,\n        uint256 _0x991ab9,\n        uint256 _0xb0122a\n    );\n\n    event MultiSplit(\n        uint256 indexed _0xf1bd82,\n        uint256[] _0x65a0ee,\n        address _0x0a5fd7,\n        uint256[] _0x633778,\n        uint256 _0x991ab9,\n        uint256 _0xb0122a\n    );\n\n    event MetadataUpdate(uint256 _0xf4153c);\n    event BatchMetadataUpdate(uint256 _0x2efb4e, uint256 _0x4ad7d6);\n\n    event Withdraw(address indexed _0xa57699, uint _0xf9b79a, uint value, uint _0x3817a1);\n    event LockPermanent(address indexed _0x739fe3, uint256 indexed _0xf4153c, uint256 _0x8eafe4, uint256 _0xb0122a);\n    event UnlockPermanent(address indexed _0x739fe3, uint256 indexed _0xf4153c, uint256 _0x8eafe4, uint256 _0xb0122a);\n    event Supply(uint _0x13159c, uint _0xd12c33);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable _0xcb3865;\n    address public _0x7103cf;\n    address public _0xd8e71c;\n    address public _0xc18e2b;\n    // address public burnTokenAddress=0x000000000000000000000000000000000000dEaD;\n\n    uint public PRECISISON = 10000;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal _0xd54dbd;\n    mapping(uint => bool) internal _0x2f3ba2;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @dev Current count of token\n    uint internal _0xf9b79a;\n\n    uint internal WEEK;\n\n    uint internal MAXTIME;\n    int128 internal _0x3a9b7c;\n    IHybra public _0xd4ecb3;\n\n    // Instance of the library's storage struct\n    VotingDelegationLib.Data private _0xbb0530;\n\n    VotingBalanceLogic.Data private _0x7bd7aa;\n\n    /// @notice Contract constructor\n    /// @param token_addr `BLACK` token address\n    constructor(address _0x23608b, address _0xd96bc8) {\n        _0xcb3865 = _0x23608b;\n        _0x7103cf = msg.sender;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xd8e71c = msg.sender; }\n        if (gasleft() > 0) { _0xc18e2b = _0xd96bc8; }\n        WEEK = HybraTimeLibrary.WEEK;\n        MAXTIME = HybraTimeLibrary.MAX_LOCK_DURATION;\n        if (gasleft() > 0) { _0x3a9b7c = int128(int256(HybraTimeLibrary.MAX_LOCK_DURATION)); }\n\n        _0x7bd7aa._0x0efeda[0]._0xed655a = block.number;\n        _0x7bd7aa._0x0efeda[0]._0x3817a1 = block.timestamp;\n\n        _0xd54dbd[ERC165_INTERFACE_ID] = true;\n        _0xd54dbd[ERC721_INTERFACE_ID] = true;\n        _0xd54dbd[ERC721_METADATA_INTERFACE_ID] = true;\n        _0xd4ecb3 = IHybra(_0xcb3865);\n\n        // mint-ish\n        emit Transfer(address(0), address(this), _0xf9b79a);\n        // burn-ish\n        emit Transfer(address(this), address(0), _0xf9b79a);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    uint8 internal constant _0xd90791 = 1;\n    uint8 internal constant _0xd9c2ef = 2;\n    uint8 internal _0x28c106 = 1;\n    modifier _0xdb48fe() {\n        require(_0x28c106 == _0xd90791);\n        _0x28c106 = _0xd9c2ef;\n        _;\n        _0x28c106 = _0xd90791;\n    }\n\n    modifier _0xe89367(uint256 _0xf4153c) {\n        require(!_0x2f3ba2[_0xf4153c], \"PNFT\");\n        _;\n    }\n\n    modifier _0xb6bbc7(uint _0xf1bd82) {\n        require(_0xc3769f[msg.sender] || _0xc3769f[address(0)], \"!SPLIT\");\n        require(_0x6ac856[_0xf1bd82] == 0 && !_0x6d233a[_0xf1bd82], \"ATT\");\n        require(_0x013902(msg.sender, _0xf1bd82), \"NAO\");\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string constant public _0x463e31 = \"veHYBR\";\n    string constant public _0x202b6d = \"veHYBR\";\n    string constant public _0x8116d2 = \"1.0.0\";\n    uint8 constant public _0x0d49f8 = 18;\n\n    function _0x88c554(address _0xc2a075) external {\n        require(msg.sender == _0xd8e71c);\n        if (1 == 1) { _0xd8e71c = _0xc2a075; }\n    }\n\n    function _0x68db9c(address _0xdc351c) external {\n        require(msg.sender == _0xd8e71c);\n        _0xc18e2b = _0xdc351c;\n        emit BatchMetadataUpdate(0, type(uint256)._0x1043b9);\n    }\n\n    /// @param _tokenId The token ID to modify\n    /// @param _isPartner Whether this should be a partner veNFT\n    function _0x313fee(uint _0xf4153c, bool _0x269c90) external {\n        require(msg.sender == _0xd8e71c, \"NA\");\n        require(_0x4ffc79[_0xf4153c] != address(0), \"DNE\");\n        _0x2f3ba2[_0xf4153c] = _0x269c90;\n    }\n\n    /// @dev Returns current token URI metadata\n    /// @param _tokenId Token ID to fetch URI for.\n    function _0x420fff(uint _0xf4153c) external view returns (string memory) {\n        require(_0x4ffc79[_0xf4153c] != address(0), \"DNE\");\n        IVotingEscrow.LockedBalance memory _0xc3f976 = _0x5c55a4[_0xf4153c];\n\n        return IVeArtProxy(_0xc18e2b)._0x621583(_0xf4153c,VotingBalanceLogic._0x1183d7(_0xf4153c, block.timestamp, _0x7bd7aa),_0xc3f976._0x779ba8,uint(int256(_0xc3f976._0x8eafe4)));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint => address) internal _0x4ffc79;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint) internal _0xea5ad4;\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function _0xe48e84(uint _0xf4153c) public view returns (address) {\n        return _0x4ffc79[_0xf4153c];\n    }\n\n    function _0x5e1a64(address _0xcdbcbe) public view returns (uint) {\n\n        return _0xea5ad4[_0xcdbcbe];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned p to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _0xaceffc(address _0x739fe3) internal view returns (uint) {\n        return _0xea5ad4[_0x739fe3];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _0x1a92e4(address _0x739fe3) external view returns (uint) {\n        return _0xaceffc(_0x739fe3);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint => address) internal _0x009b76;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal _0x0b7f62;\n\n    mapping(uint => uint) public _0x91f392;\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function _0xf47716(uint _0xf4153c) external view returns (address) {\n        return _0x009b76[_0xf4153c];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function _0x7e8b03(address _0x739fe3, address _0xf722e4) external view returns (bool) {\n        return (_0x0b7f62[_0x739fe3])[_0xf722e4];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n    /// @param _approved Address to be approved for the given NFT ID.\n    /// @param _tokenId ID of the token to be approved.\n    function _0x6a7459(address _0x2ac7b5, uint _0xf4153c) public {\n        address _0xcdbcbe = _0x4ffc79[_0xf4153c];\n        // Throws if `_tokenId` is not a valid NFT\n        require(_0xcdbcbe != address(0), \"ZA\");\n        // Throws if `_approved` is the current owner\n        require(_0x2ac7b5 != _0xcdbcbe, \"IA\");\n        // Check requirements\n        bool _0x2bb6a3 = (_0x4ffc79[_0xf4153c] == msg.sender);\n        bool _0xc7145b = (_0x0b7f62[_0xcdbcbe])[msg.sender];\n        require(_0x2bb6a3 || _0xc7145b, \"NAO\");\n        // Set the approval\n        _0x009b76[_0xf4153c] = _0x2ac7b5;\n        emit Approval(_0xcdbcbe, _0x2ac7b5, _0xf4153c);\n    }\n\n    /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n    /// @notice This works even if sender doesn't own any tokens at the time.\n    /// @param _operator Address to add to the set of authorized operators.\n    /// @param _approved True if the operators is approved, false to revoke approval.\n    function _0xc8828c(address _0xf722e4, bool _0x2ac7b5) external {\n        // Throws if `_operator` is the `msg.sender`\n        assert(_0xf722e4 != msg.sender);\n        _0x0b7f62[msg.sender][_0xf722e4] = _0x2ac7b5;\n        emit ApprovalForAll(msg.sender, _0xf722e4, _0x2ac7b5);\n    }\n\n    /* TRANSFER FUNCTIONS */\n    /// @dev Clear an approval of a given address\n    ///      Throws if `_owner` is not the current owner.\n    function _0xeb1035(address _0x739fe3, uint _0xf4153c) internal {\n        // Throws if `_owner` is not the current owner\n        assert(_0x4ffc79[_0xf4153c] == _0x739fe3);\n        if (_0x009b76[_0xf4153c] != address(0)) {\n            // Reset approvals\n            _0x009b76[_0xf4153c] = address(0);\n        }\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\n    function _0x013902(address _0xe306cb, uint _0xf4153c) internal view returns (bool) {\n        address _0xcdbcbe = _0x4ffc79[_0xf4153c];\n        bool _0x385d8a = _0xcdbcbe == _0xe306cb;\n        bool _0xea5663 = _0xe306cb == _0x009b76[_0xf4153c];\n        bool _0xf701a9 = (_0x0b7f62[_0xcdbcbe])[_0xe306cb];\n        return _0x385d8a || _0xea5663 || _0xf701a9;\n    }\n\n    function _0xf7adae(address _0xe306cb, uint _0xf4153c) external view returns (bool) {\n        return _0x013902(_0xe306cb, _0xf4153c);\n    }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _0x9a7ec7(\n        address _0xf1bd82,\n        address _0x86fe88,\n        uint _0xf4153c,\n        address _0x0a5fd7\n    ) internal _0xe89367(_0xf4153c) {\n        require(_0x6ac856[_0xf4153c] == 0 && !_0x6d233a[_0xf4153c], \"ATT\");\n        // Check requirements\n        require(_0x013902(_0x0a5fd7, _0xf4153c), \"NAO\");\n\n        // Clear approval. Throws if `_from` is not the current owner\n        _0xeb1035(_0xf1bd82, _0xf4153c);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _0x54ad52(_0xf1bd82, _0xf4153c);\n        // auto re-delegate\n        VotingDelegationLib._0x9c78a8(_0xbb0530, _0xea6071(_0xf1bd82), _0xea6071(_0x86fe88), _0xf4153c, _0xe48e84);\n        // Add NFT\n        _0xd63a34(_0x86fe88, _0xf4153c);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        _0x91f392[_0xf4153c] = block.number;\n\n        // Log the transfer\n        emit Transfer(_0xf1bd82, _0x86fe88, _0xf4153c);\n    }\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n    ///        they maybe be permanently lost.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function _0x18b9ba(\n        address _0xf1bd82,\n        address _0x86fe88,\n        uint _0xf4153c\n    ) external {\n        _0x9a7ec7(_0xf1bd82, _0x86fe88, _0xf4153c, msg.sender);\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function _0xfba11e(\n        address _0xf1bd82,\n        address _0x86fe88,\n        uint _0xf4153c\n    ) external {\n        _0xfba11e(_0xf1bd82, _0x86fe88, _0xf4153c, \"\");\n    }\n\n    function _0x031006(address _0x0eb3e6) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint _0x2bbe07;\n        assembly {\n            _0x2bbe07 := extcodesize(_0x0eb3e6)\n        }\n        return _0x2bbe07 > 0;\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\n    function _0xfba11e(\n        address _0xf1bd82,\n        address _0x86fe88,\n        uint _0xf4153c,\n        bytes memory _0x3f86a0\n    ) public {\n        _0x9a7ec7(_0xf1bd82, _0x86fe88, _0xf4153c, msg.sender);\n\n        if (_0x031006(_0x86fe88)) {\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\n            try IERC721Receiver(_0x86fe88)._0xce63a1(msg.sender, _0xf1bd82, _0xf4153c, _0x3f86a0) returns (bytes4 _0x636857) {\n                if (_0x636857 != IERC721Receiver(_0x86fe88)._0xce63a1.selector) {\n                    revert(\"E721_RJ\");\n                }\n            } catch (bytes memory _0x45d9e7) {\n                if (_0x45d9e7.length == 0) {\n                    revert('E721_NRCV');\n                } else {\n                    assembly {\n                        revert(add(32, _0x45d9e7), mload(_0x45d9e7))\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function _0x894bc9(bytes4 _0xe76f22) external view returns (bool) {\n        return _0xd54dbd[_0xe76f22];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint => uint)) internal _0x9eefbe;\n\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint => uint) internal _0x917b38;\n\n    /// @dev  Get token by index\n    function _0x57d822(address _0x739fe3, uint _0x8044c2) public view returns (uint) {\n        return _0x9eefbe[_0x739fe3][_0x8044c2];\n    }\n\n    /// @dev Add a NFT to an index mapping to a given addressndashushun\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _0x7d34ae(address _0x86fe88, uint _0xf4153c) internal {\n        uint _0x6bedf6 = _0xaceffc(_0x86fe88);\n\n        _0x9eefbe[_0x86fe88][_0x6bedf6] = _0xf4153c;\n        _0x917b38[_0xf4153c] = _0x6bedf6;\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _0xd63a34(address _0x86fe88, uint _0xf4153c) internal {\n        // Throws if `_tokenId` is owned by someone\n        assert(_0x4ffc79[_0xf4153c] == address(0));\n        // Change the owner\n        _0x4ffc79[_0xf4153c] = _0x86fe88;\n        // Update owner token index tracking\n        _0x7d34ae(_0x86fe88, _0xf4153c);\n        // Change count tracking\n        _0xea5ad4[_0x86fe88] += 1;\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _0xaa1217(address _0x86fe88, uint _0xf4153c) internal returns (bool) {\n        // Throws if `_to` is zero address\n        assert(_0x86fe88 != address(0));\n        // checkpoint for gov\n        VotingDelegationLib._0x9c78a8(_0xbb0530, address(0), _0xea6071(_0x86fe88), _0xf4153c, _0xe48e84);\n        // Add NFT. Throws if `_tokenId` is owned by someone\n        _0xd63a34(_0x86fe88, _0xf4153c);\n        emit Transfer(address(0), _0x86fe88, _0xf4153c);\n        return true;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _0x4dd452(address _0xf1bd82, uint _0xf4153c) internal {\n        // Delete\n        uint _0x6bedf6 = _0xaceffc(_0xf1bd82) - 1;\n        uint _0xb1afb5 = _0x917b38[_0xf4153c];\n\n        if (_0x6bedf6 == _0xb1afb5) {\n            // update ownerToNFTokenIdList\n            _0x9eefbe[_0xf1bd82][_0x6bedf6] = 0;\n            // update tokenToOwnerIndex\n            _0x917b38[_0xf4153c] = 0;\n        } else {\n            uint _0x388ac5 = _0x9eefbe[_0xf1bd82][_0x6bedf6];\n\n            // Add\n            // update ownerToNFTokenIdList\n            _0x9eefbe[_0xf1bd82][_0xb1afb5] = _0x388ac5;\n            // update tokenToOwnerIndex\n            _0x917b38[_0x388ac5] = _0xb1afb5;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            _0x9eefbe[_0xf1bd82][_0x6bedf6] = 0;\n            // update tokenToOwnerIndex\n            _0x917b38[_0xf4153c] = 0;\n        }\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _0x54ad52(address _0xf1bd82, uint _0xf4153c) internal {\n        // Throws if `_from` is not the current owner\n        assert(_0x4ffc79[_0xf4153c] == _0xf1bd82);\n        // Change the owner\n        _0x4ffc79[_0xf4153c] = address(0);\n        // Update owner token index tracking\n        _0x4dd452(_0xf1bd82, _0xf4153c);\n        // Change count tracking\n        _0xea5ad4[_0xf1bd82] -= 1;\n    }\n\n    function _0x7fd32c(uint _0xf4153c) internal {\n        require(_0x013902(msg.sender, _0xf4153c), \"NAO\");\n\n        address _0xcdbcbe = _0xe48e84(_0xf4153c);\n\n        // Clear approval\n        delete _0x009b76[_0xf4153c];\n        // Remove token\n        //_removeTokenFrom(msg.sender, _tokenId);\n        _0x54ad52(_0xcdbcbe, _0xf4153c);\n        // checkpoint for gov\n        VotingDelegationLib._0x9c78a8(_0xbb0530, _0xea6071(_0xcdbcbe), address(0), _0xf4153c, _0xe48e84);\n\n        emit Transfer(_0xcdbcbe, address(0), _0xf4153c);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint => IVotingEscrow.LockedBalance) public _0x5c55a4;\n    uint public _0x295a03;\n    uint public _0x2178ce;\n    mapping(uint => int128) public _0x902170; // time -> signed slope change\n    uint public _0xd12c33;\n    mapping(address => bool) public _0xc3769f;\n\n    uint internal constant MULTIPLIER = 1 ether;\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function _0xec8f70(uint _0xf4153c) external view returns (int128) {\n        uint _0x846afb = _0x7bd7aa._0x542dd9[_0xf4153c];\n        return _0x7bd7aa._0x60ef2f[_0xf4153c][_0x846afb]._0x2e811a;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function _0x60ef2f(uint _0xf4153c, uint _0x5092c7) external view returns (IVotingEscrow.Point memory) {\n        return _0x7bd7aa._0x60ef2f[_0xf4153c][_0x5092c7];\n    }\n\n    function _0x0efeda(uint _0x2178ce) external view returns (IVotingEscrow.Point memory) {\n        return _0x7bd7aa._0x0efeda[_0x2178ce];\n    }\n\n    function _0x542dd9(uint _0xf9b79a) external view returns (uint) {\n        return _0x7bd7aa._0x542dd9[_0xf9b79a];\n    }\n\n    /// @notice Record global and per-user data to checkpoint\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\n    /// @param old_locked Pevious locked amount / end lock time for the user\n    /// @param new_locked New locked amount / end lock time for the user\n    function _0xfcbaa1(\n        uint _0xf4153c,\n        IVotingEscrow.LockedBalance memory _0x7c99c2,\n        IVotingEscrow.LockedBalance memory _0xc51949\n    ) internal {\n        IVotingEscrow.Point memory _0xf41ab1;\n        IVotingEscrow.Point memory _0x592b6d;\n        int128 _0x65ea62 = 0;\n        int128 _0x72e328 = 0;\n        uint _0xa37be7 = _0x2178ce;\n\n        if (_0xf4153c != 0) {\n            _0x592b6d._0xc3653f = 0;\n\n            if(_0xc51949._0x305b19){\n                _0x592b6d._0xc3653f = uint(int256(_0xc51949._0x8eafe4));\n            }\n\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_0x7c99c2._0x779ba8 > block.timestamp && _0x7c99c2._0x8eafe4 > 0) {\n                _0xf41ab1._0x2e811a = _0x7c99c2._0x8eafe4 / _0x3a9b7c;\n                _0xf41ab1._0x7a210c = _0xf41ab1._0x2e811a * int128(int256(_0x7c99c2._0x779ba8 - block.timestamp));\n            }\n            if (_0xc51949._0x779ba8 > block.timestamp && _0xc51949._0x8eafe4 > 0) {\n                _0x592b6d._0x2e811a = _0xc51949._0x8eafe4 / _0x3a9b7c;\n                _0x592b6d._0x7a210c = _0x592b6d._0x2e811a * int128(int256(_0xc51949._0x779ba8 - block.timestamp));\n            }\n\n            // Read values of scheduled changes in the slope\n            // old_locked.end can be in the past and in the future\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            _0x65ea62 = _0x902170[_0x7c99c2._0x779ba8];\n            if (_0xc51949._0x779ba8 != 0) {\n                if (_0xc51949._0x779ba8 == _0x7c99c2._0x779ba8) {\n                    _0x72e328 = _0x65ea62;\n                } else {\n                    _0x72e328 = _0x902170[_0xc51949._0x779ba8];\n                }\n            }\n        }\n\n        IVotingEscrow.Point memory _0x9752dd = IVotingEscrow.Point({_0x7a210c: 0, _0x2e811a: 0, _0x3817a1: block.timestamp, _0xed655a: block.number, _0xc3653f: 0});\n        if (_0xa37be7 > 0) {\n            _0x9752dd = _0x7bd7aa._0x0efeda[_0xa37be7];\n        }\n        uint _0x6990a4 = _0x9752dd._0x3817a1;\n        // initial_last_point is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        IVotingEscrow.Point memory _0x040068 = _0x9752dd;\n        uint _0xc449e3 = 0; // dblock/dt\n        if (block.timestamp > _0x9752dd._0x3817a1) {\n            _0xc449e3 = (MULTIPLIER * (block.number - _0x9752dd._0xed655a)) / (block.timestamp - _0x9752dd._0x3817a1);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        {\n            uint _0xbb92f6 = (_0x6990a4 / WEEK) * WEEK;\n            for (uint i = 0; i < 255; ++i) {\n                // Hopefully it won't happen that this won't get used in 5 years!\n                // If it does, users will be able to withdraw but vote weight will be broken\n                _0xbb92f6 += WEEK;\n                int128 _0x7c069f = 0;\n                if (_0xbb92f6 > block.timestamp) {\n                    _0xbb92f6 = block.timestamp;\n                } else {\n                    _0x7c069f = _0x902170[_0xbb92f6];\n                }\n                _0x9752dd._0x7a210c -= _0x9752dd._0x2e811a * int128(int256(_0xbb92f6 - _0x6990a4));\n                _0x9752dd._0x2e811a += _0x7c069f;\n                if (_0x9752dd._0x7a210c < 0) {\n                    // This can happen\n                    _0x9752dd._0x7a210c = 0;\n                }\n                if (_0x9752dd._0x2e811a < 0) {\n                    // This cannot happen - just in case\n                    _0x9752dd._0x2e811a = 0;\n                }\n                _0x6990a4 = _0xbb92f6;\n                _0x9752dd._0x3817a1 = _0xbb92f6;\n                _0x9752dd._0xed655a = _0x040068._0xed655a + (_0xc449e3 * (_0xbb92f6 - _0x040068._0x3817a1)) / MULTIPLIER;\n                _0xa37be7 += 1;\n                if (_0xbb92f6 == block.timestamp) {\n                    _0x9752dd._0xed655a = block.number;\n                    break;\n                } else {\n                    _0x7bd7aa._0x0efeda[_0xa37be7] = _0x9752dd;\n                }\n            }\n        }\n\n        _0x2178ce = _0xa37be7;\n        // Now point_history is filled until t=now\n\n        if (_0xf4153c != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            _0x9752dd._0x2e811a += (_0x592b6d._0x2e811a - _0xf41ab1._0x2e811a);\n            _0x9752dd._0x7a210c += (_0x592b6d._0x7a210c - _0xf41ab1._0x7a210c);\n            if (_0x9752dd._0x2e811a < 0) {\n                _0x9752dd._0x2e811a = 0;\n            }\n            if (_0x9752dd._0x7a210c < 0) {\n                _0x9752dd._0x7a210c = 0;\n            }\n            _0x9752dd._0xc3653f = _0x295a03;\n        }\n\n        // Record the changed point into history\n        _0x7bd7aa._0x0efeda[_0xa37be7] = _0x9752dd;\n\n        if (_0xf4153c != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (_0x7c99c2._0x779ba8 > block.timestamp) {\n                // old_dslope was <something> - u_old.slope, so we cancel that\n                _0x65ea62 += _0xf41ab1._0x2e811a;\n                if (_0xc51949._0x779ba8 == _0x7c99c2._0x779ba8) {\n                    _0x65ea62 -= _0x592b6d._0x2e811a; // It was a new deposit, not extension\n                }\n                _0x902170[_0x7c99c2._0x779ba8] = _0x65ea62;\n            }\n\n            if (_0xc51949._0x779ba8 > block.timestamp) {\n                if (_0xc51949._0x779ba8 > _0x7c99c2._0x779ba8) {\n                    _0x72e328 -= _0x592b6d._0x2e811a; // old slope disappeared at this point\n                    _0x902170[_0xc51949._0x779ba8] = _0x72e328;\n                }\n                // else: we recorded it already in old_dslope\n            }\n            // Now handle user history\n            uint _0x0eb01f = _0x7bd7aa._0x542dd9[_0xf4153c] + 1;\n\n            _0x7bd7aa._0x542dd9[_0xf4153c] = _0x0eb01f;\n            _0x592b6d._0x3817a1 = block.timestamp;\n            _0x592b6d._0xed655a = block.number;\n            _0x7bd7aa._0x60ef2f[_0xf4153c][_0x0eb01f] = _0x592b6d;\n        }\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    /// @param _tokenId NFT that holds lock\n    /// @param _value Amount to deposit\n    /// @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    /// @param locked_balance Previous locked amount / timestamp\n    /// @param deposit_type The type of deposit\n    function _0xac88fd(\n        uint _0xf4153c,\n        uint _0x566660,\n        uint _0xe29c8b,\n        IVotingEscrow.LockedBalance memory _0xc06928,\n        DepositType _0x09a3bc\n    ) internal {\n        IVotingEscrow.LockedBalance memory _0xc3f976 = _0xc06928;\n        uint _0x83f80b = _0xd12c33;\n\n        _0xd12c33 = _0x83f80b + _0x566660;\n        IVotingEscrow.LockedBalance memory _0x7c99c2;\n        (_0x7c99c2._0x8eafe4, _0x7c99c2._0x779ba8, _0x7c99c2._0x305b19) = (_0xc3f976._0x8eafe4, _0xc3f976._0x779ba8, _0xc3f976._0x305b19);\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        _0xc3f976._0x8eafe4 += int128(int256(_0x566660));\n\n        if (_0xe29c8b != 0) {\n            _0xc3f976._0x779ba8 = _0xe29c8b;\n        }\n        _0x5c55a4[_0xf4153c] = _0xc3f976;\n\n        // Possibilities:\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // _locked.end > block.timestamp (always)\n        _0xfcbaa1(_0xf4153c, _0x7c99c2, _0xc3f976);\n\n        address from = msg.sender;\n        if (_0x566660 != 0) {\n            assert(IERC20(_0xcb3865)._0x18b9ba(from, address(this), _0x566660));\n        }\n\n        emit Deposit(from, _0xf4153c, _0x566660, _0xc3f976._0x779ba8, _0x09a3bc, block.timestamp);\n        emit Supply(_0x83f80b, _0x83f80b + _0x566660);\n    }\n\n    /// @notice Record global data to checkpoint\n    function _0x369e14() external {\n        _0xfcbaa1(0, IVotingEscrow.LockedBalance(0, 0, false), IVotingEscrow.LockedBalance(0, 0, false));\n    }\n\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _tokenId lock NFT\n    /// @param _value Amount to add to user's lock\n    function _0x2351d2(uint _0xf4153c, uint _0x566660) external _0xdb48fe {\n        IVotingEscrow.LockedBalance memory _0xc3f976 = _0x5c55a4[_0xf4153c];\n\n        require(_0x566660 > 0, \"ZV\"); // dev: need non-zero value\n        require(_0xc3f976._0x8eafe4 > 0, 'ZL');\n        require(_0xc3f976._0x779ba8 > block.timestamp || _0xc3f976._0x305b19, 'EXP');\n\n        if (_0xc3f976._0x305b19) _0x295a03 += _0x566660;\n\n        _0xac88fd(_0xf4153c, _0x566660, 0, _0xc3f976, DepositType.DEPOSIT_FOR_TYPE);\n\n        if(_0x6d233a[_0xf4153c]) {\n            IVoter(_0x7103cf)._0xf01546(_0xf4153c);\n        }\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _0x4c2a69(uint _0x566660, uint _0x878c6c, address _0x86fe88) internal returns (uint) {\n        uint _0xe29c8b = (block.timestamp + _0x878c6c) / WEEK * WEEK; // Locktime is rounded down to weeks\n\n        require(_0x566660 > 0, \"ZV\"); // dev: need non-zero value\n        require(_0xe29c8b > block.timestamp && (_0xe29c8b <= block.timestamp + MAXTIME), 'IUT');\n\n        ++_0xf9b79a;\n        uint _0xf4153c = _0xf9b79a;\n        _0xaa1217(_0x86fe88, _0xf4153c);\n\n        IVotingEscrow.LockedBalance memory _0xc3f976 = _0x5c55a4[_0xf4153c];\n\n        _0xac88fd(_0xf4153c, _0x566660, _0xe29c8b, _0xc3f976, DepositType.CREATE_LOCK_TYPE);\n        return _0xf4153c;\n    }\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    function _0x0a3e35(uint _0x566660, uint _0x878c6c) external _0xdb48fe returns (uint) {\n        return _0x4c2a69(_0x566660, _0x878c6c, msg.sender);\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _0xde5e5f(uint _0x566660, uint _0x878c6c, address _0x86fe88) external _0xdb48fe returns (uint) {\n        return _0x4c2a69(_0x566660, _0x878c6c, _0x86fe88);\n    }\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function _0x71597b(uint _0xf4153c, uint _0x566660) external _0xdb48fe {\n        assert(_0x013902(msg.sender, _0xf4153c));\n\n        IVotingEscrow.LockedBalance memory _0xc3f976 = _0x5c55a4[_0xf4153c];\n\n        assert(_0x566660 > 0); // dev: need non-zero value\n        require(_0xc3f976._0x8eafe4 > 0, 'ZL');\n        require(_0xc3f976._0x779ba8 > block.timestamp || _0xc3f976._0x305b19, 'EXP');\n\n        if (_0xc3f976._0x305b19) _0x295a03 += _0x566660;\n        _0xac88fd(_0xf4153c, _0x566660, 0, _0xc3f976, DepositType.INCREASE_LOCK_AMOUNT);\n\n        // poke for the gained voting power\n        if(_0x6d233a[_0xf4153c]) {\n            IVoter(_0x7103cf)._0xf01546(_0xf4153c);\n        }\n        emit MetadataUpdate(_0xf4153c);\n    }\n\n    /// @notice Extend the unlock time for `_tokenId`\n    /// @param _lock_duration New number of seconds until tokens unlock\n    function _0x61cce2(uint _0xf4153c, uint _0x878c6c) external _0xdb48fe {\n        assert(_0x013902(msg.sender, _0xf4153c));\n\n        IVotingEscrow.LockedBalance memory _0xc3f976 = _0x5c55a4[_0xf4153c];\n        require(!_0xc3f976._0x305b19, \"!NORM\");\n        uint _0xe29c8b = (block.timestamp + _0x878c6c) / WEEK * WEEK; // Locktime is rounded down to weeks\n\n        require(_0xc3f976._0x779ba8 > block.timestamp && _0xc3f976._0x8eafe4 > 0, 'EXP||ZV');\n        require(_0xe29c8b > _0xc3f976._0x779ba8 && (_0xe29c8b <= block.timestamp + MAXTIME), 'IUT'); // IUT -> invalid unlock time\n\n        _0xac88fd(_0xf4153c, 0, _0xe29c8b, _0xc3f976, DepositType.INCREASE_UNLOCK_TIME);\n\n        // poke for the gained voting power\n        if(_0x6d233a[_0xf4153c]) {\n            IVoter(_0x7103cf)._0xf01546(_0xf4153c);\n        }\n        emit MetadataUpdate(_0xf4153c);\n    }\n\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function _0xdb4191(uint _0xf4153c) external _0xdb48fe {\n        assert(_0x013902(msg.sender, _0xf4153c));\n        require(_0x6ac856[_0xf4153c] == 0 && !_0x6d233a[_0xf4153c], \"ATT\");\n\n        IVotingEscrow.LockedBalance memory _0xc3f976 = _0x5c55a4[_0xf4153c];\n        require(!_0xc3f976._0x305b19, \"!NORM\");\n        require(block.timestamp >= _0xc3f976._0x779ba8, \"!EXP\");\n        uint value = uint(int256(_0xc3f976._0x8eafe4));\n\n        _0x5c55a4[_0xf4153c] = IVotingEscrow.LockedBalance(0, 0, false);\n        uint _0x83f80b = _0xd12c33;\n        if (true) { _0xd12c33 = _0x83f80b - value; }\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _0xfcbaa1(_0xf4153c, _0xc3f976, IVotingEscrow.LockedBalance(0, 0, false));\n\n        assert(IERC20(_0xcb3865).transfer(msg.sender, value));\n\n        // Burn the NFT\n        _0x7fd32c(_0xf4153c);\n\n        emit Withdraw(msg.sender, _0xf4153c, value, block.timestamp);\n        emit Supply(_0x83f80b, _0x83f80b - value);\n    }\n\n    function _0xfef59a(uint _0xf4153c) external {\n        address sender = msg.sender;\n        require(_0x013902(sender, _0xf4153c), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory _0x6ead86 = _0x5c55a4[_0xf4153c];\n        require(!_0x6ead86._0x305b19, \"!NORM\");\n        require(_0x6ead86._0x779ba8 > block.timestamp, \"EXP\");\n        require(_0x6ead86._0x8eafe4 > 0, \"ZV\");\n\n        uint _0xfd32de = uint(int256(_0x6ead86._0x8eafe4));\n        _0x295a03 += _0xfd32de;\n        _0x6ead86._0x779ba8 = 0;\n        _0x6ead86._0x305b19 = true;\n        _0xfcbaa1(_0xf4153c, _0x5c55a4[_0xf4153c], _0x6ead86);\n        _0x5c55a4[_0xf4153c] = _0x6ead86;\n        if(_0x6d233a[_0xf4153c]) {\n            IVoter(_0x7103cf)._0xf01546(_0xf4153c);\n        }\n        emit LockPermanent(sender, _0xf4153c, _0xfd32de, block.timestamp);\n        emit MetadataUpdate(_0xf4153c);\n    }\n\n    function _0xad24fc(uint _0xf4153c) external {\n        address sender = msg.sender;\n        require(_0x013902(msg.sender, _0xf4153c), \"NAO\");\n\n        require(_0x6ac856[_0xf4153c] == 0 && !_0x6d233a[_0xf4153c], \"ATT\");\n        IVotingEscrow.LockedBalance memory _0x6ead86 = _0x5c55a4[_0xf4153c];\n        require(_0x6ead86._0x305b19, \"!NORM\");\n        uint _0xfd32de = uint(int256(_0x6ead86._0x8eafe4));\n        _0x295a03 -= _0xfd32de;\n        _0x6ead86._0x779ba8 = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n        _0x6ead86._0x305b19 = false;\n\n        _0xfcbaa1(_0xf4153c, _0x5c55a4[_0xf4153c], _0x6ead86);\n        _0x5c55a4[_0xf4153c] = _0x6ead86;\n\n        emit UnlockPermanent(sender, _0xf4153c, _0xfd32de, block.timestamp);\n        emit MetadataUpdate(_0xf4153c);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           GAUGE VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    function _0x1183d7(uint _0xf4153c) external view returns (uint) {\n        if (_0x91f392[_0xf4153c] == block.number) return 0;\n        return VotingBalanceLogic._0x1183d7(_0xf4153c, block.timestamp, _0x7bd7aa);\n    }\n\n    function _0x4c083e(uint _0xf4153c, uint _0x13fbab) external view returns (uint) {\n        return VotingBalanceLogic._0x1183d7(_0xf4153c, _0x13fbab, _0x7bd7aa);\n    }\n\n    function _0x3fa352(uint _0xf4153c, uint _0x519a62) external view returns (uint) {\n        return VotingBalanceLogic._0x3fa352(_0xf4153c, _0x519a62, _0x7bd7aa, _0x2178ce);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _block Block to calculate the total voting power at\n    /// @return Total voting power at `_block`\n    function _0xfe200c(uint _0x519a62) external view returns (uint) {\n        return VotingBalanceLogic._0xfe200c(_0x519a62, _0x2178ce, _0x7bd7aa, _0x902170);\n    }\n\n    function _0x91c6bb() external view returns (uint) {\n        return _0x6c9c07(block.timestamp);\n    }\n\n    /// @notice Calculate total voting power\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    /// @return Total voting power\n    function _0x6c9c07(uint t) public view returns (uint) {\n        return VotingBalanceLogic._0x6c9c07(t, _0x2178ce, _0x902170,  _0x7bd7aa);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint => uint) public _0x6ac856;\n    mapping(uint => bool) public _0x6d233a;\n\n    function _0xc159b5(address _0x6fb619) external {\n        require(msg.sender == _0xd8e71c);\n        _0x7103cf = _0x6fb619;\n    }\n\n    function _0xbc5fd4(uint _0xf4153c) external {\n        require(msg.sender == _0x7103cf);\n        _0x6d233a[_0xf4153c] = true;\n    }\n\n    function _0x68df64(uint _0xf4153c) external {\n        require(msg.sender == _0x7103cf, \"NA\");\n        _0x6d233a[_0xf4153c] = false;\n    }\n\n    function _0xd7863d(uint _0xf4153c) external {\n        require(msg.sender == _0x7103cf, \"NA\");\n        _0x6ac856[_0xf4153c] = _0x6ac856[_0xf4153c] + 1;\n    }\n\n    function _0xb1b758(uint _0xf4153c) external {\n        require(msg.sender == _0x7103cf, \"NA\");\n        _0x6ac856[_0xf4153c] = _0x6ac856[_0xf4153c] - 1;\n    }\n\n    function _0x36b721(uint _0xf1bd82, uint _0x86fe88) external _0xdb48fe _0xe89367(_0xf1bd82) {\n        require(_0x6ac856[_0xf1bd82] == 0 && !_0x6d233a[_0xf1bd82], \"ATT\");\n        require(_0xf1bd82 != _0x86fe88, \"SAME\");\n        require(_0x013902(msg.sender, _0xf1bd82) &&\n        _0x013902(msg.sender, _0x86fe88), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory _0xc3c7a8 = _0x5c55a4[_0xf1bd82];\n        IVotingEscrow.LockedBalance memory _0x3dd92c = _0x5c55a4[_0x86fe88];\n        require(_0x3dd92c._0x779ba8 > block.timestamp ||  _0x3dd92c._0x305b19,\"EXP||PERM\");\n        require(_0xc3c7a8._0x305b19 ? _0x3dd92c._0x305b19 : true, \"!MERGE\");\n\n        uint _0x1d48aa = uint(int256(_0xc3c7a8._0x8eafe4));\n        uint _0x779ba8 = _0xc3c7a8._0x779ba8 >= _0x3dd92c._0x779ba8 ? _0xc3c7a8._0x779ba8 : _0x3dd92c._0x779ba8;\n\n        _0x5c55a4[_0xf1bd82] = IVotingEscrow.LockedBalance(0, 0, false);\n        _0xfcbaa1(_0xf1bd82, _0xc3c7a8, IVotingEscrow.LockedBalance(0, 0, false));\n        _0x7fd32c(_0xf1bd82);\n\n        IVotingEscrow.LockedBalance memory _0x04c2d3;\n        _0x04c2d3._0x305b19 = _0x3dd92c._0x305b19;\n\n        if (_0x04c2d3._0x305b19){\n            _0x04c2d3._0x8eafe4 = _0x3dd92c._0x8eafe4 + _0xc3c7a8._0x8eafe4;\n            if (!_0xc3c7a8._0x305b19) {  // Only add if source wasn't already permanent\n                _0x295a03 += _0x1d48aa;\n            }\n        }else{\n            _0x04c2d3._0x8eafe4 = _0x3dd92c._0x8eafe4 + _0xc3c7a8._0x8eafe4;\n            _0x04c2d3._0x779ba8 = _0x779ba8;\n        }\n\n        //_checkpointDelegatee(_delegates[_to], value0, true);\n        _0xfcbaa1(_0x86fe88, _0x3dd92c, _0x04c2d3);\n        _0x5c55a4[_0x86fe88] = _0x04c2d3;\n\n        if(_0x6d233a[_0x86fe88]) {\n            IVoter(_0x7103cf)._0xf01546(_0x86fe88);\n        }\n        emit Merge(\n            msg.sender,\n            _0xf1bd82,\n            _0x86fe88,\n            uint(int256(_0xc3c7a8._0x8eafe4)),\n            uint(int256(_0x3dd92c._0x8eafe4)),\n            uint(int256(_0x04c2d3._0x8eafe4)),\n            _0x04c2d3._0x779ba8,\n            block.timestamp\n        );\n        emit MetadataUpdate(_0x86fe88);\n    }\n\n    // function split(\n    //     uint _from,\n    //     uint _amount\n    // ) external nonreentrant splitAllowed(_from) notPartnerNFT(_from) returns (uint256 _tokenId1, uint256 _tokenId2) {\n    //     address owner = idToOwner[_from];\n\n    //     IVotingEscrow.LockedBalance memory newLocked = locked[_from];\n    //     require(newLocked.end > block.timestamp || newLocked.isPermanent, \"EXP\");\n\n    //     int128 _splitAmount = int128(int256(_amount));\n\n    //     require(_splitAmount != 0, \"ZV\");\n    //     require(newLocked.amount > _splitAmount, \"BIGVAL\");\n\n    //     locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n    //     _checkpoint(_from, newLocked, IVotingEscrow.LockedBalance(0, 0, false));\n    //     _burn(_from);\n\n    //     newLocked.amount -= _splitAmount;\n    //     _tokenId1 = _createSplitNFT(owner, newLocked);\n\n    //     newLocked.amount = _splitAmount;\n    //     _tokenId2 = _createSplitNFT(owner, newLocked);\n\n    //     // emit Split(\n    //     //     _from,\n    //     //     _tokenId1,\n    //     //     _tokenId2,\n    //     //     msg.sender,\n    //     //     uint(int256(locked[_tokenId1].amount)),\n    //     //     uint(int256(_splitAmount)),\n    //     //     newLocked.end,\n    //     //     block.timestamp\n    //     // );\n    // }\n\n    /// @notice Split a veNFT into multiple new veNFTs with specified weight distribution\n    /// @param _from The token ID to split\n    /// @param amounts Array of weights for distributing the locked amount\n    /// @return newTokenIds Array of newly created token IDs\n    function _0xe9ee73(\n        uint _0xf1bd82,\n        uint[] memory _0x6bec2b\n    ) external _0xdb48fe _0xb6bbc7(_0xf1bd82) _0xe89367(_0xf1bd82) returns (uint256[] memory _0xa17014) {\n        require(_0x6bec2b.length >= 2 && _0x6bec2b.length <= 10, \"MIN2MAX10\");\n\n        address _0xcdbcbe = _0x4ffc79[_0xf1bd82];\n\n        IVotingEscrow.LockedBalance memory _0x31ff67 = _0x5c55a4[_0xf1bd82];\n        require(_0x31ff67._0x779ba8 > block.timestamp || _0x31ff67._0x305b19, \"EXP\");\n        require(_0x31ff67._0x8eafe4 > 0, \"ZV\");\n\n        // Calculate total weight\n        uint _0x29ef5c = 0;\n        for(uint i = 0; i < _0x6bec2b.length; i++) {\n            require(_0x6bec2b[i] > 0, \"ZW\"); // Zero weight not allowed\n            _0x29ef5c += _0x6bec2b[i];\n        }\n\n        // Burn the original NFT\n        _0x5c55a4[_0xf1bd82] = IVotingEscrow.LockedBalance(0, 0, false);\n        _0xfcbaa1(_0xf1bd82, _0x31ff67, IVotingEscrow.LockedBalance(0, 0, false));\n        _0x7fd32c(_0xf1bd82);\n\n        // Create new NFTs with proportional amounts\n        _0xa17014 = new uint256[](_0x6bec2b.length);\n        uint[] memory _0x860d54 = new uint[](_0x6bec2b.length);\n\n        for(uint i = 0; i < _0x6bec2b.length; i++) {\n            IVotingEscrow.LockedBalance memory _0x8af79e = IVotingEscrow.LockedBalance({\n                _0x8eafe4: int128(int256(uint256(int256(_0x31ff67._0x8eafe4)) * _0x6bec2b[i] / _0x29ef5c)),\n                _0x779ba8: _0x31ff67._0x779ba8,\n                _0x305b19: _0x31ff67._0x305b19\n            });\n\n            _0xa17014[i] = _0x528ee1(_0xcdbcbe, _0x8af79e);\n            _0x860d54[i] = uint256(int256(_0x8af79e._0x8eafe4));\n        }\n\n        emit MultiSplit(\n            _0xf1bd82,\n            _0xa17014,\n            msg.sender,\n            _0x860d54,\n            _0x31ff67._0x779ba8,\n            block.timestamp\n        );\n    }\n\n    function _0x528ee1(address _0x86fe88, IVotingEscrow.LockedBalance memory _0x6ead86) private returns (uint256 _0xf4153c) {\n        if (true) { _0xf4153c = ++_0xf9b79a; }\n        _0x5c55a4[_0xf4153c] = _0x6ead86;\n        _0xfcbaa1(_0xf4153c, IVotingEscrow.LockedBalance(0, 0, false), _0x6ead86);\n        _0xaa1217(_0x86fe88, _0xf4153c);\n    }\n\n    function _0x568638(address _0x816550, bool _0xdc1db2) external {\n        require(msg.sender == _0xd8e71c);\n        _0xc3769f[_0x816550] = _0xdc1db2;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            DAO VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = _0xb4e977(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = _0xb4e977(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) private _0xaa9640;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint) public _0x765dad;\n\n    /**\n     * @notice Overrides the standard `Comp.sol` delegates mapping to return\n     * the delegator's own address if they haven't delegated.\n     * This avoids having to delegate to oneself.\n     */\n    function _0xea6071(address _0x9f0a41) public view returns (address) {\n        address _0x56a7c3 = _0xaa9640[_0x9f0a41];\n        return _0x56a7c3 == address(0) ? _0x9f0a41 : _0x56a7c3;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function _0x89a7e2(address _0x0eb3e6) external view returns (uint) {\n        uint32 _0x8936bc = _0xbb0530._0x008c14[_0x0eb3e6];\n        if (_0x8936bc == 0) {\n            return 0;\n        }\n        uint[] storage _0xd1cd94 = _0xbb0530._0x451e48[_0x0eb3e6][_0x8936bc - 1]._0xbb706d;\n        uint _0x51359f = 0;\n        for (uint i = 0; i < _0xd1cd94.length; i++) {\n            uint _0x9d90c9 = _0xd1cd94[i];\n            _0x51359f = _0x51359f + VotingBalanceLogic._0x1183d7(_0x9d90c9, block.timestamp, _0x7bd7aa);\n        }\n        return _0x51359f;\n    }\n\n    function _0xde9b9c(address _0x0eb3e6, uint timestamp)\n        public\n        view\n        returns (uint)\n    {\n        uint32 _0x0bcac8 = VotingDelegationLib._0x791337(_0xbb0530, _0x0eb3e6, timestamp);\n        // Sum votes\n        uint[] storage _0xd1cd94 = _0xbb0530._0x451e48[_0x0eb3e6][_0x0bcac8]._0xbb706d;\n        uint _0x51359f = 0;\n        for (uint i = 0; i < _0xd1cd94.length; i++) {\n            uint _0x9d90c9 = _0xd1cd94[i];\n            // Use the provided input timestamp here to get the right decay\n            _0x51359f = _0x51359f + VotingBalanceLogic._0x1183d7(_0x9d90c9, timestamp,  _0x7bd7aa);\n        }\n\n        return _0x51359f;\n    }\n\n    function _0x875783(uint256 timestamp) external view returns (uint) {\n        return _0x6c9c07(timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             DAO VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function _0x42573e(address _0x9f0a41, address _0x7cb8ab) internal {\n        /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\n        address _0x9a7c2e = _0xea6071(_0x9f0a41);\n\n        _0xaa9640[_0x9f0a41] = _0x7cb8ab;\n\n        emit DelegateChanged(_0x9f0a41, _0x9a7c2e, _0x7cb8ab);\n        VotingDelegationLib.TokenHelpers memory _0xfa103a = VotingDelegationLib.TokenHelpers({\n            _0x09e11c: _0xe48e84,\n            _0x5e1a64: _0x5e1a64,\n            _0x57d822:_0x57d822\n        });\n        VotingDelegationLib._0xae4b9d(_0xbb0530, _0x9f0a41, _0x9a7c2e, _0x7cb8ab, _0xfa103a);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function _0xcb9069(address _0x7cb8ab) public {\n        if (_0x7cb8ab == address(0)) _0x7cb8ab = msg.sender;\n        return _0x42573e(msg.sender, _0x7cb8ab);\n    }\n\n    function _0x61f7c6(\n        address _0x7cb8ab,\n        uint _0xc8f290,\n        uint _0xe6a642,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(_0x7cb8ab != msg.sender, \"NA\");\n        require(_0x7cb8ab != address(0), \"ZA\");\n\n        bytes32 _0xd95cac = _0xb4e977(\n            abi._0x1fbd30(\n                DOMAIN_TYPEHASH,\n                _0xb4e977(bytes(_0x463e31)),\n                _0xb4e977(bytes(_0x8116d2)),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 _0x7c5691 = _0xb4e977(\n            abi._0x1fbd30(DELEGATION_TYPEHASH, _0x7cb8ab, _0xc8f290, _0xe6a642)\n        );\n        bytes32 _0xa42f92 = _0xb4e977(\n            abi._0x87cb04(\"\\x19\\x01\", _0xd95cac, _0x7c5691)\n        );\n        address _0x40ef0e = _0x04b114(_0xa42f92, v, r, s);\n        require(\n            _0x40ef0e != address(0),\n            \"ZA\"\n        );\n        require(\n            _0xc8f290 == _0x765dad[_0x40ef0e]++,\n            \"!NONCE\"\n        );\n        require(\n            block.timestamp <= _0xe6a642,\n            \"EXP\"\n        );\n        return _0x42573e(_0x40ef0e, _0x7cb8ab);\n    }\n\n}",
      "rename_map": {
        "_removeTokenFromOwnerList": "_0x4dd452",
        "spenderIsApprovedForAll": "_0xf701a9",
        "senderIsApprovedForAll": "_0xc7145b",
        "votingBalanceLogicData": "_0x7bd7aa",
        "ownerToNFTokenCountFn": "_0x5e1a64",
        "increase_unlock_time": "_0x61cce2",
        "ownerToNFTokenIdList": "_0x9eefbe",
        "_addTokenToOwnerList": "_0x7d34ae",
        "permanentLockBalance": "_0x295a03",
        "get_last_user_slope": "_0xec8f70",
        "supportedInterfaces": "_0xd54dbd",
        "ownerToNFTokenCount": "_0xea5ad4",
        "tokenOfOwnerByIndex": "_0x57d822",
        "getPastTotalSupply": "_0x875783",
        "_isApprovedOrOwner": "_0x013902",
        "moveTokenDelegates": "_0x9c78a8",
        "user_point_history": "_0x60ef2f",
        "initial_last_point": "_0x040068",
        "supportsInterface": "_0x894bc9",
        "spenderIsApproved": "_0xea5663",
        "tokenToOwnerIndex": "_0x917b38",
        "_moveAllDelegates": "_0xae4b9d",
        "getPastVotesIndex": "_0x791337",
        "isApprovedOrOwner": "_0xf7adae",
        "setApprovalForAll": "_0xc8828c",
        "ownership_change": "_0x91f392",
        "_removeTokenFrom": "_0x54ad52",
        "isApprovedForAll": "_0x7e8b03",
        "user_point_epoch": "_0x542dd9",
        "ownerToOperators": "_0x0b7f62",
        "onERC721Received": "_0xce63a1",
        "safeTransferFrom": "_0xfba11e",
        "unlockPermanent": "_0xad24fc",
        "create_lock_for": "_0xde5e5f",
        "setPartnerVeNFT": "_0x313fee",
        "domainSeparator": "_0xd95cac",
        "_createSplitNFT": "_0x528ee1",
        "last_checkpoint": "_0x6990a4",
        "increase_amount": "_0x71597b",
        "currentDelegate": "_0x9a7c2e",
        "_lock_duration": "_0x878c6c",
        "spenderIsOwner": "_0x385d8a",
        "_entered_state": "_0x28c106",
        "locked_balance": "_0xc06928",
        "_clearApproval": "_0xeb1035",
        "numCheckpoints": "_0x008c14",
        "balanceOfAtNFT": "_0x3fa352",
        "balanceOfNFTAt": "_0x4c083e",
        "isPartnerVeNFT": "_0x2f3ba2",
        "totalSupplyAtT": "_0x6c9c07",
        "originalLocked": "_0x31ff67",
        "idToApprovals": "_0x009b76",
        "supply_before": "_0x83f80b",
        "current_index": "_0xb1afb5",
        "_splitAmount2": "_0x63619f",
        "actualAmounts": "_0x860d54",
        "slope_changes": "_0x902170",
        "_splitAmount1": "_0xed3622",
        "delegateBySig": "_0x61f7c6",
        "notPartnerNFT": "_0xe89367",
        "current_count": "_0x6bedf6",
        "senderIsOwner": "_0x2bb6a3",
        "_transferFrom": "_0x9a7ec7",
        "lockPermanent": "_0xfef59a",
        "totalSupplyAt": "_0xfe200c",
        "point_history": "_0x0efeda",
        "nonreentrant": "_0xdb48fe",
        "_interfaceID": "_0xe76f22",
        "nCheckpoints": "_0x8936bc",
        "deposit_type": "_0x09a3bc",
        "encodePacked": "_0x87cb04",
        "transferFrom": "_0x18b9ba",
        "getPastVotes": "_0xde9b9c",
        "_not_entered": "_0xd90791",
        "_create_lock": "_0x4c2a69",
        "splitAllowed": "_0xb6bbc7",
        "_deposit_for": "_0xac88fd",
        "_newTokenIds": "_0x65a0ee",
        "tokenHelpers": "_0xfa103a",
        "_amountFinal": "_0xf4920f",
        "_fromTokenId": "_0x2efb4e",
        "balanceOfNFT": "_0x1183d7",
        "newTokenIds": "_0xa17014",
        "getApproved": "_0xf47716",
        "totalWeight": "_0x29ef5c",
        "_tokenIndex": "_0x8044c2",
        "toggleSplit": "_0x568638",
        "block_slope": "_0xc449e3",
        "deposit_for": "_0x2351d2",
        "_isContract": "_0x031006",
        "_checkIndex": "_0x0bcac8",
        "lastTokenId": "_0x388ac5",
        "checkpoints": "_0x451e48",
        "attachments": "_0x6ac856",
        "newLockedTo": "_0x04c2d3",
        "setArtProxy": "_0x68db9c",
        "totalSupply": "_0x91c6bb",
        "isPermanent": "_0x305b19",
        "unlock_time": "_0xe29c8b",
        "create_lock": "_0x0a3e35",
        "_addTokenTo": "_0xd63a34",
        "_amountFrom": "_0x3e7ef0",
        "_checkpoint": "_0xfcbaa1",
        "structHash": "_0x7c5691",
        "_toTokenId": "_0x4ad7d6",
        "old_locked": "_0x7c99c2",
        "old_dslope": "_0x65ea62",
        "user_epoch": "_0x0eb01f",
        "last_point": "_0x9752dd",
        "_delegates": "_0xaa9640",
        "_isPartner": "_0x269c90",
        "token_addr": "_0x23608b",
        "new_locked": "_0xc51949",
        "checkpoint": "_0x369e14",
        "prevSupply": "_0x13159c",
        "new_dslope": "_0x72e328",
        "_newLocked": "_0x6ead86",
        "multiSplit": "_0xe9ee73",
        "ownerOfFn": "_0x09e11c",
        "balanceOf": "_0x1a92e4",
        "_tokenIds": "_0xd1cd94",
        "_tokenURI": "_0x621583",
        "permanent": "_0xc3653f",
        "art_proxy": "_0xd96bc8",
        "keccak256": "_0xb4e977",
        "_tokenId2": "_0xddbb19",
        "_delegate": "_0x42573e",
        "_locktime": "_0x991ab9",
        "_amountTo": "_0xc8f922",
        "_approved": "_0x2ac7b5",
        "_operator": "_0xf722e4",
        "ecrecover": "_0x04b114",
        "idToOwner": "_0x4ffc79",
        "delegatee": "_0x7cb8ab",
        "newLocked": "_0x8af79e",
        "delegates": "_0xea6071",
        "signatory": "_0x40ef0e",
        "delegator": "_0x9f0a41",
        "_tokenId1": "_0x66c40e",
        "withdraw": "_0xdb4191",
        "response": "_0x636857",
        "_tokenId": "_0xf4153c",
        "provider": "_0xa57699",
        "getVotes": "_0x89a7e2",
        "decimals": "_0x0d49f8",
        "_spender": "_0xe306cb",
        "iMAXTIME": "_0x3a9b7c",
        "_account": "_0x816550",
        "locktime": "_0x7b807b",
        "_entered": "_0xd9c2ef",
        "tokenIds": "_0xbb706d",
        "_amounts": "_0x633778",
        "canSplit": "_0xc3769f",
        "artProxy": "_0xc18e2b",
        "_locked1": "_0x3dd92c",
        "setVoter": "_0xc159b5",
        "_locked0": "_0xc3c7a8",
        "_balance": "_0xaceffc",
        "tokenURI": "_0x420fff",
        "delegate": "_0xcb9069",
        "_amount": "_0xfd32de",
        "_locked": "_0xc3f976",
        "approve": "_0x6a7459",
        "version": "_0x8116d2",
        "tokenId": "_0xf9b79a",
        "amounts": "_0x6bec2b",
        "d_slope": "_0x7c069f",
        "account": "_0x0eb3e6",
        "current": "_0x56a7c3",
        "abstain": "_0x68df64",
        "_sender": "_0x0a5fd7",
        "ownerOf": "_0xe48e84",
        "setTeam": "_0x88c554",
        "_value": "_0x566660",
        "supply": "_0xd12c33",
        "voting": "_0xbc5fd4",
        "_proxy": "_0xdc351c",
        "expiry": "_0xe6a642",
        "detach": "_0xb1b758",
        "value0": "_0x1d48aa",
        "_voter": "_0x6fb619",
        "locked": "_0x5c55a4",
        "uepoch": "_0x846afb",
        "_block": "_0x519a62",
        "digest": "_0xa42f92",
        "attach": "_0xd7863d",
        "_epoch": "_0xa37be7",
        "nonces": "_0x765dad",
        "cpData": "_0xbb0530",
        "symbol": "_0x202b6d",
        "encode": "_0x1fbd30",
        "amount": "_0x8eafe4",
        "_owner": "_0x739fe3",
        "reason": "_0x45d9e7",
        "epoch": "_0x2178ce",
        "nonce": "_0xc8f290",
        "_team": "_0xc2a075",
        "_bool": "_0xdc1db2",
        "_hybr": "_0xd4ecb3",
        "slope": "_0x2e811a",
        "token": "_0xcb3865",
        "voter": "_0x7103cf",
        "merge": "_0x36b721",
        "owner": "_0xcdbcbe",
        "_burn": "_0x7fd32c",
        "_data": "_0x3f86a0",
        "u_new": "_0x592b6d",
        "votes": "_0x51359f",
        "_mint": "_0xaa1217",
        "voted": "_0x6d233a",
        "u_old": "_0xf41ab1",
        "_from": "_0xf1bd82",
        "bias": "_0x7a210c",
        "name": "_0x463e31",
        "team": "_0xd8e71c",
        "_idx": "_0x5092c7",
        "size": "_0x2bbe07",
        "poke": "_0xf01546",
        "t_i": "_0xbb92f6",
        "blk": "_0xed655a",
        "tId": "_0x9d90c9",
        "end": "_0x779ba8",
        "_ts": "_0xb0122a",
        "max": "_0x1043b9",
        "_to": "_0x86fe88",
        "ts": "_0x3817a1",
        "_t": "_0x13fbab"
      },
      "changes": [
        "Renamed 227 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_011",
      "transformed_id": "ss_l3_medium_sn_gs_011",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n/// @title MinVotingPowerCondition\n/// @author Aragon X - 2024\n/// @notice Checks if an account's voting power or token balance meets the threshold defined on the given plugin.\n/// @custom:security-contact sirt@aragon.org\ncontract MinVotingPowerCondition is PermissionCondition {\n    /// @notice The address of the `ILockToGovernBase` plugin used to fetch the settings from.\n    ILockToGovernBase public immutable _0xe4da4d;\n\n    /// @notice The address of the LockManager used by the plugin.\n    ILockManager public immutable _0x643d89;\n\n    /// @notice The `IERC20` token interface used to check token balance.\n    IERC20 public immutable _0xdf01d0;\n\n    /// @notice Initializes the contract with the `ILockToGovernBase` plugin address and caches the associated token.\n    /// @param _plugin The address of the `ILockToGovernBase` plugin.\n    constructor(ILockToGovernBase _0x010bb7) {\n        _0xe4da4d = _0x010bb7;\n        if (true) { _0xdf01d0 = _0xe4da4d._0xdf01d0(); }\n        if (block.timestamp > 0) { _0x643d89 = _0xe4da4d._0x643d89(); }\n    }\n\n    /// @inheritdoc IPermissionCondition\n    /// @dev The function checks both the voting power and token balance to ensure `_who` meets the minimum voting\n    ///      threshold defined in the `TokenVoting` plugin. Returns `false` if the minimum requirement is unmet.\n    function _0x1e3245(address _0xd28509, address _0x09688c, bytes32 _0x970de4, bytes calldata _0x5dea0a)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (_0xd28509, _0x5dea0a, _0x970de4);\n\n        uint256 _0x080595 = _0xdf01d0._0x1af84e(_0x09688c) + _0x643d89._0x2ad189(_0x09688c);\n        uint256 _0x6fb625 = _0xe4da4d._0xab3afc();\n\n        return _0x080595 >= _0x6fb625;\n    }\n}\n",
      "rename_map": {
        "_minProposerVotingPower": "_0x6fb625",
        "minProposerVotingPower": "_0xab3afc",
        "getLockedBalance": "_0x2ad189",
        "_currentBalance": "_0x080595",
        "_permissionId": "_0x970de4",
        "lockManager": "_0x643d89",
        "balanceOf": "_0x1af84e",
        "isGranted": "_0x1e3245",
        "_plugin": "_0x010bb7",
        "plugin": "_0xe4da4d",
        "_where": "_0xd28509",
        "token": "_0xdf01d0",
        "_data": "_0x5dea0a",
        "_who": "_0x09688c"
      },
      "changes": [
        "Renamed 14 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_012",
      "transformed_id": "ss_l3_medium_sn_gs_012",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this._0x10ed43.selector ^ this._0x66ac4c.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = _0x32d0c1(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = _0x32d0c1(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 _0x3bbf80, address _0xd182b2);\n\n    error VoteRemovalForbidden(uint256 _0x3bbf80, address _0xd182b2);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function _0xb86194(\n        IDAO _0x72def4,\n        ILockManager _0xb5e478,\n        VotingSettings calldata _0x21c33e,\n        IPlugin.TargetConfig calldata _0x967f71,\n        bytes calldata _0x901579\n    ) external _0xb2dd6b _0x2e0072(1) {\n        __MajorityVotingBase_init(_0x72def4, _0x21c33e, _0x967f71, _0x901579);\n        __LockToGovernBase_init(_0xb5e478);\n\n        emit MembershipContractAnnounced({_0x74130c: address(_0xb5e478._0x69cc27())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function _0x11382d(bytes4 _0x59967c)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _0x59967c == LOCK_TO_VOTE_INTERFACE_ID || _0x59967c == type(ILockToVote)._0x4ef6b1\n            || super._0x11382d(_0x59967c);\n    }\n\n    /// @inheritdoc IProposal\n    function _0x465fdc() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function _0x66ac4c(\n        bytes calldata _0x1a3c6b,\n        Action[] memory _0x57f626,\n        uint64 _0x187649,\n        uint64 _0x362e37,\n        bytes memory _0x784526\n    ) external _0x345a7e(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 _0x3bbf80) {\n        uint256 _0x6d6883;\n\n        if (_0x784526.length != 0) {\n            (_0x6d6883) = abi._0xe23003(_0x784526, (uint256));\n        }\n\n        if (_0x2c1e50() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_0x187649, _0x362e37) = _0x967078(_0x187649, _0x362e37);\n\n        _0x3bbf80 = _0x343043(_0x32d0c1(abi._0x5e66ac(_0x57f626, _0x1a3c6b)));\n\n        if (_0x1fe55e(_0x3bbf80)) {\n            revert ProposalAlreadyExists(_0x3bbf80);\n        }\n\n        // Store proposal related information\n        Proposal storage _0xc1996a = _0x176087[_0x3bbf80];\n\n        _0xc1996a._0xadf6b4._0xef210b = _0xef210b();\n        _0xc1996a._0xadf6b4._0x38e97d = _0x38e97d();\n        _0xc1996a._0xadf6b4._0x197451 = _0x187649;\n        _0xc1996a._0xadf6b4._0xc34607 = _0x362e37;\n        _0xc1996a._0xadf6b4._0xf36d5b = _0xf36d5b();\n        _0xc1996a._0xadf6b4._0xc67fb0 = _0xc67fb0();\n\n        _0xc1996a._0x5a3094 = _0x0859ec();\n\n        // Reduce costs\n        if (_0x6d6883 != 0) {\n            _0xc1996a._0x1da272 = _0x6d6883;\n        }\n\n        for (uint256 i; i < _0x57f626.length;) {\n            _0xc1996a._0x11f939.push(_0x57f626[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(_0x3bbf80, _0x6574a1(), _0x187649, _0x362e37, _0x1a3c6b, _0x57f626, _0x6d6883);\n\n        _0xef432e._0x2c25be(_0x3bbf80);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function _0xf06d42(uint256 _0x72468b, address _0x87a35f, VoteOption _0x919faa) public view returns (bool) {\n        if (!_0x1fe55e(_0x72468b)) {\n            revert NonexistentProposal(_0x72468b);\n        }\n\n        Proposal storage _0xc1996a = _0x176087[_0x72468b];\n        return _0x9e1ef6(_0xc1996a, _0x87a35f, _0x919faa, _0xef432e._0x9c546a(_0x87a35f));\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x164e48(uint256 _0x72468b, address _0x87a35f, VoteOption _0x919faa, uint256 _0xc7a007)\n        public\n        override\n        _0x345a7e(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage _0xc1996a = _0x176087[_0x72468b];\n\n        if (!_0x9e1ef6(_0xc1996a, _0x87a35f, _0x919faa, _0xc7a007)) {\n            revert VoteCastForbidden(_0x72468b, _0x87a35f);\n        }\n\n        // Same vote\n        if (_0x919faa == _0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a) {\n            // Same value, nothing to do\n            if (_0xc7a007 == _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 _0xa31c0a = _0xc7a007 - _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0;\n            _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0 = _0xc7a007;\n\n            if (_0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a == VoteOption.Yes) {\n                _0xc1996a._0xddc670._0xbc7eac += _0xa31c0a;\n            } else if (_0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a == VoteOption.No) {\n                _0xc1996a._0xddc670._0xc00348 += _0xa31c0a;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                _0xc1996a._0xddc670._0xb3ff89 += _0xa31c0a;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (_0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0 > 0) {\n                // Undo that vote\n                if (_0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a == VoteOption.Yes) {\n                    _0xc1996a._0xddc670._0xbc7eac -= _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0;\n                } else if (_0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a == VoteOption.No) {\n                    _0xc1996a._0xddc670._0xc00348 -= _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    _0xc1996a._0xddc670._0xb3ff89 -= _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0;\n                }\n            }\n\n            // Register the new vote\n            if (_0x919faa == VoteOption.Yes) {\n                _0xc1996a._0xddc670._0xbc7eac += _0xc7a007;\n            } else if (_0x919faa == VoteOption.No) {\n                _0xc1996a._0xddc670._0xc00348 += _0xc7a007;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                _0xc1996a._0xddc670._0xb3ff89 += _0xc7a007;\n            }\n            _0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a = _0x919faa;\n            _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0 = _0xc7a007;\n        }\n\n        emit VoteCast(_0x72468b, _0x87a35f, _0x919faa, _0xc7a007);\n\n        if (_0xc1996a._0xadf6b4._0xef210b == VotingMode.EarlyExecution) {\n            _0xcb28b6(_0x72468b, _0x6574a1());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x184b9a(uint256 _0x72468b, address _0x87a35f) external _0x345a7e(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage _0xc1996a = _0x176087[_0x72468b];\n        if (!_0x617f0b(_0xc1996a)) {\n            revert VoteRemovalForbidden(_0x72468b, _0x87a35f);\n        } else if (_0xc1996a._0xadf6b4._0xef210b != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_0x72468b, _0x87a35f);\n        } else if (_0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0 == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (_0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a == VoteOption.Yes) {\n            _0xc1996a._0xddc670._0xbc7eac -= _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0;\n        } else if (_0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a == VoteOption.No) {\n            _0xc1996a._0xddc670._0xc00348 -= _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (_0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a == VoteOption.Abstain) {\n            _0xc1996a._0xddc670._0xb3ff89 -= _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0;\n        }\n        _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0 = 0;\n\n        emit VoteCleared(_0x72468b, _0x87a35f);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x3bf222(uint256 _0x72468b) external view returns (bool) {\n        Proposal storage _0xc1996a = _0x176087[_0x72468b];\n        return _0x617f0b(_0xc1996a);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0x10ed43() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase._0x10ed43();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0x2c1e50() public view override returns (uint256) {\n        return IERC20(_0xef432e._0x69cc27())._0xd4b5b6();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x64b89e(uint256 _0x72468b, address _0x87a35f) public view returns (uint256) {\n        return _0x176087[_0x72468b]._0xb164bd[_0x87a35f]._0x1d3cb0;\n    }\n\n    // Internal helpers\n\n    function _0x9e1ef6(Proposal storage _0xc1996a, address _0x87a35f, VoteOption _0x919faa, uint256 _0xc7a007)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _0xeb4ef3 = _0xc1996a._0xb164bd[_0x87a35f]._0x1d3cb0;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_0x617f0b(_0xc1996a)) {\n            return false;\n        } else if (_0x919faa == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (_0xc1996a._0xadf6b4._0xef210b != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_0xc7a007 <= _0xeb4ef3) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                _0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a != VoteOption.None\n                    && _0x919faa != _0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_0xc7a007 == 0 || _0xc7a007 < _0xeb4ef3) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_0xc7a007 == _0xeb4ef3 && _0x919faa == _0xc1996a._0xb164bd[_0x87a35f]._0xb3e90a) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _0xcb28b6(uint256 _0x72468b, address _0xeb0aad) internal {\n        if (!_0xb4baaf(_0x72468b)) {\n            return;\n        } else if (!_0xd56997()._0x07b8f0(address(this), _0xeb0aad, EXECUTE_PROPOSAL_PERMISSION_ID, _0xd691b2())) {\n            return;\n        }\n\n        _0x1bdaa4(_0x72468b);\n    }\n\n    function _0x1bdaa4(uint256 _0x72468b) internal override {\n        super._0x1bdaa4(_0x72468b);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        _0xef432e._0x3c41a5(_0x72468b);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "rename_map": {
        "onlyCallAtInitialization": "_0xb2dd6b",
        "customProposalParamsABI": "_0x465fdc",
        "_attemptEarlyExecution": "_0xcb28b6",
        "_validateProposalDates": "_0x967078",
        "minProposerVotingPower": "_0x10ed43",
        "supportThresholdRatio": "_0x38e97d",
        "minParticipationRatio": "_0xf36d5b",
        "_currentVotingPower": "_0xeb4ef3",
        "currentTokenSupply": "_0x2c1e50",
        "supportsInterface": "_0x11382d",
        "_createProposalId": "_0x343043",
        "definingContract": "_0x74130c",
        "_allowFailureMap": "_0x6d6883",
        "getLockedBalance": "_0x9c546a",
        "minApprovalRatio": "_0xc67fb0",
        "_isProposalOpen": "_0x617f0b",
        "allowFailureMap": "_0x1da272",
        "getTargetConfig": "_0x0859ec",
        "_votingSettings": "_0x21c33e",
        "_pluginMetadata": "_0x901579",
        "_proposalExists": "_0x1fe55e",
        "usedVotingPower": "_0x64b89e",
        "proposalCreated": "_0x2c25be",
        "_newVotingPower": "_0xc7a007",
        "isProposalOpen": "_0x3bf222",
        "createProposal": "_0x66ac4c",
        "proposalEnded": "_0x3c41a5",
        "reinitializer": "_0x2e0072",
        "_targetConfig": "_0x967f71",
        "hasPermission": "_0x07b8f0",
        "_interfaceId": "_0x59967c",
        "targetConfig": "_0x5a3094",
        "_lockManager": "_0xb5e478",
        "interfaceId": "_0x4ef6b1",
        "_proposalId": "_0x72468b",
        "votingPower": "_0x1d3cb0",
        "totalSupply": "_0xd4b5b6",
        "_voteOption": "_0x919faa",
        "_canExecute": "_0xb4baaf",
        "lockManager": "_0xef432e",
        "_voteCaller": "_0xeb0aad",
        "proposalId": "_0x3bbf80",
        "votingMode": "_0xef210b",
        "voteOption": "_0xb3e90a",
        "_startDate": "_0x187649",
        "parameters": "_0xadf6b4",
        "initialize": "_0xb86194",
        "_msgSender": "_0x6574a1",
        "keccak256": "_0x32d0c1",
        "clearVote": "_0x184b9a",
        "startDate": "_0x197451",
        "proposals": "_0x176087",
        "proposal_": "_0xc1996a",
        "_metadata": "_0x1a3c6b",
        "_actions": "_0x57f626",
        "_execute": "_0x1bdaa4",
        "_canVote": "_0x9e1ef6",
        "_endDate": "_0x362e37",
        "_msgData": "_0xd691b2",
        "abstain": "_0xb3ff89",
        "canVote": "_0xf06d42",
        "endDate": "_0xc34607",
        "actions": "_0x11f939",
        "decode": "_0xe23003",
        "_voter": "_0x87a35f",
        "encode": "_0x5e66ac",
        "tally": "_0xddc670",
        "token": "_0x69cc27",
        "voter": "_0xd182b2",
        "_data": "_0x784526",
        "votes": "_0xb164bd",
        "_dao": "_0x72def4",
        "diff": "_0xa31c0a",
        "auth": "_0x345a7e",
        "vote": "_0x164e48",
        "dao": "_0xd56997",
        "yes": "_0xbc7eac",
        "no": "_0xc00348"
      },
      "changes": [
        "Renamed 78 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_013",
      "transformed_id": "ss_l3_medium_sn_gs_013",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title LockManagerERC20\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n    /// @notice The address of the token contract used to determine the voting power\n    IERC20 private immutable _0xea56f0;\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    /// @param _token The address of the token contract that users can lock\n    constructor(LockManagerSettings memory _0x5195ab, IERC20 _0x1d06fb) LockManagerBase(_0x5195ab) {\n        if (true) { _0xea56f0 = _0x1d06fb; }\n    }\n\n    /// @inheritdoc ILockManager\n    /// @dev Not having `token` as a public variable because the return types would differ (address vs IERC20)\n    function _0x034f33() public view virtual returns (address _0x1d06fb) {\n        return address(_0xea56f0);\n    }\n\n    // Overrides\n\n    /// @inheritdoc LockManagerBase\n    function _0x36ee27() internal view virtual override returns (uint256) {\n        return _0xea56f0._0x7ce974(msg.sender, address(this));\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0xabf34a(uint256 _0xbce9e2) internal virtual override {\n        _0xea56f0._0xa0f0a6(msg.sender, address(this), _0xbce9e2);\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0x9b7cf9(address _0xc84877, uint256 _0xbce9e2) internal virtual override {\n        _0xea56f0.transfer(_0xc84877, _0xbce9e2);\n    }\n}\n",
      "rename_map": {
        "_incomingTokenBalance": "_0x36ee27",
        "_doUnlockTransfer": "_0x9b7cf9",
        "_doLockTransfer": "_0xabf34a",
        "transferFrom": "_0xa0f0a6",
        "_recipient": "_0xc84877",
        "erc20Token": "_0xea56f0",
        "_settings": "_0x5195ab",
        "allowance": "_0x7ce974",
        "_amount": "_0xbce9e2",
        "_token": "_0x1d06fb",
        "token": "_0x034f33"
      },
      "changes": [
        "Renamed 11 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_014",
      "transformed_id": "ss_l3_medium_sn_gs_014",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title LockManagerERC20\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n    /// @notice The address of the token contract used to determine the voting power\n    IERC20 private immutable _0xf80ab0;\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    /// @param _token The address of the token contract that users can lock\n    constructor(LockManagerSettings memory _0x1b525f, IERC20 _0xc87d74) LockManagerBase(_0x1b525f) {\n        _0xf80ab0 = _0xc87d74;\n    }\n\n    /// @inheritdoc ILockManager\n    /// @dev Not having `token` as a public variable because the return types would differ (address vs IERC20)\n    function _0x5e12ec() public view virtual returns (address _0xc87d74) {\n        return address(_0xf80ab0);\n    }\n\n    // Overrides\n\n    /// @inheritdoc LockManagerBase\n    function _0x77dc90() internal view virtual override returns (uint256) {\n        return _0xf80ab0._0xdb4eea(msg.sender, address(this));\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0xcb4e8e(uint256 _0x7e520c) internal virtual override {\n        _0xf80ab0._0x89646b(msg.sender, address(this), _0x7e520c);\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0xfb1904(address _0x1dde51, uint256 _0x7e520c) internal virtual override {\n        _0xf80ab0.transfer(_0x1dde51, _0x7e520c);\n    }\n}\n",
      "rename_map": {
        "_incomingTokenBalance": "_0x77dc90",
        "_doUnlockTransfer": "_0xfb1904",
        "_doLockTransfer": "_0xcb4e8e",
        "transferFrom": "_0x89646b",
        "_recipient": "_0x1dde51",
        "erc20Token": "_0xf80ab0",
        "_settings": "_0x1b525f",
        "allowance": "_0xdb4eea",
        "_amount": "_0x7e520c",
        "_token": "_0xc87d74",
        "token": "_0x5e12ec"
      },
      "changes": [
        "Renamed 11 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_015",
      "transformed_id": "ss_l3_medium_sn_gs_015",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title LockManagerBase\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @notice The current LockManager settings\n    LockManagerSettings public _0x9e845e;\n\n    /// @notice The address of the lock to vote plugin to use\n    ILockToGovernBase public _0xd5ade2;\n\n    /// @notice Keeps track of the amount of tokens locked by address\n    mapping(address => uint256) private _0xcae5c1;\n\n    /// @notice Keeps track of the known active proposal ID's\n    /// @dev NOTE: Executed proposals will be actively reported, but defeated proposals will need to be garbage collected over time.\n    EnumerableSet.UintSet internal _0x5f26d2;\n\n    /// @notice Emitted when a token holder locks funds into the manager contract\n    event BalanceLocked(address _0x1bdd10, uint256 _0x109aa3);\n\n    /// @notice Emitted when a token holder unlocks funds from the manager contract\n    event BalanceUnlocked(address _0x1bdd10, uint256 _0x109aa3);\n\n    /// @notice Emitted when the plugin reports a proposal as ended\n    /// @param proposalId The ID the proposal where votes can no longer be submitted or cleared\n    event ProposalEnded(uint256 _0x900c40);\n\n    /// @notice Thrown when the address calling proposalEnded() is not the plugin's\n    error InvalidPluginAddress();\n\n    /// @notice Raised when the caller holds no tokens or didn't lock any tokens\n    error NoBalance();\n\n    /// @notice Raised when attempting to unlock while active votes are cast in strict mode\n    error LocksStillActive();\n\n    /// @notice Thrown when trying to set an invalid contract as the plugin\n    error InvalidPlugin();\n\n    /// @notice Thrown when trying to set an invalid PluginMode value, or when trying to use an operation not supported by the current pluginMode\n    error InvalidPluginMode();\n\n    /// @notice Thrown when trying to define the address of the plugin after it already was\n    error SetPluginAddressForbidden();\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    constructor(LockManagerSettings memory _0xcf5f8c) {\n        _0x9e845e._0x56c972 = _0xcf5f8c._0x56c972;\n    }\n\n    /// @notice Returns the known proposalID at the given index\n    function _0x99c130(uint256 _0xde9328) public view virtual returns (uint256) {\n        return _0x5f26d2._0xba3f52(_0xde9328);\n    }\n\n    /// @notice Returns the number of known proposalID's\n    function _0xc9175a() public view virtual returns (uint256) {\n        return _0x5f26d2.length();\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x5ddb1a() public virtual {\n        _0x15d36b(_0xe6d2c1());\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x5ddb1a(uint256 _0xd306da) public virtual {\n        _0x15d36b(_0xd306da);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xec61a9(uint256 _0x03c9a9, IMajorityVoting.VoteOption _0x9f6ae0) public virtual {\n        if (_0x9e845e._0x56c972 != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _0x15d36b(_0xe6d2c1());\n        _0x34bcdb(_0x03c9a9, _0x9f6ae0);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xec61a9(uint256 _0x03c9a9, IMajorityVoting.VoteOption _0x9f6ae0, uint256 _0xd306da) public virtual {\n        if (_0x9e845e._0x56c972 != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _0x15d36b(_0xd306da);\n        _0x34bcdb(_0x03c9a9, _0x9f6ae0);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x1d988f(uint256 _0x03c9a9, IMajorityVoting.VoteOption _0x9f6ae0) public virtual {\n        if (_0x9e845e._0x56c972 != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _0x34bcdb(_0x03c9a9, _0x9f6ae0);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x6eddde(address _0x04b73c) public view virtual returns (uint256) {\n        return _0xcae5c1[_0x04b73c];\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xe67164(uint256 _0x03c9a9, address _0x74d2a7, IMajorityVoting.VoteOption _0x9f6ae0)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(_0xd5ade2))._0xe67164(_0x03c9a9, _0x74d2a7, _0x9f6ae0);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x5e5bf5() public virtual {\n        uint256 _0x1c2ccf = _0x6eddde(msg.sender);\n        if (_0x1c2ccf == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev The plugin may decide to revert if its voting mode doesn't allow for it\n        _0x251839();\n\n        // All votes clear\n\n        _0xcae5c1[msg.sender] = 0;\n\n        // Withdraw\n        _0x9d7414(msg.sender, _0x1c2ccf);\n        emit BalanceUnlocked(msg.sender, _0x1c2ccf);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x7d632d(uint256 _0x03c9a9) public virtual {\n        if (msg.sender != address(_0xd5ade2)) {\n            revert InvalidPluginAddress();\n        }\n\n        // @dev Not checking for duplicate proposalId's\n        // @dev Both plugins already enforce unicity\n\n        _0x5f26d2._0xbb0d83(_0x03c9a9);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x27eaa4(uint256 _0x03c9a9) public virtual {\n        if (msg.sender != address(_0xd5ade2)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(_0x03c9a9);\n        _0x5f26d2._0xffc845(_0x03c9a9);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x1418ca(ILockToGovernBase _0xe9a00e) public virtual {\n        if (address(_0xd5ade2) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(_0xe9a00e))._0x694666(type(ILockToGovernBase)._0xd2e6f3)) {\n            revert InvalidPlugin();\n        }\n        // Is it the right type of plugin?\n        else if (\n            _0x9e845e._0x56c972 == PluginMode.Voting\n                && !IERC165(address(_0xe9a00e))._0x694666(type(ILockToVote)._0xd2e6f3)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        _0xd5ade2 = _0xe9a00e;\n    }\n\n    // Internal\n\n    /// @notice Returns the amount of tokens that LockManager receives or can transfer from msg.sender\n    function _0xe6d2c1() internal view virtual returns (uint256);\n\n    /// @notice Takes the user's tokens and registers the received amount.\n    function _0x15d36b(uint256 _0xd306da) internal virtual {\n        if (_0xd306da == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev Reverts if not enough balance is approved\n        _0xf7162f(_0xd306da);\n\n        _0xcae5c1[msg.sender] += _0xd306da;\n        emit BalanceLocked(msg.sender, _0xd306da);\n    }\n\n    /// @notice Triggers the transfer needed in order to complete the token locking flow.\n    ///     Reverts if the requested amount cannot be locked.\n    function _0xf7162f(uint256 _0xd306da) internal virtual;\n\n    /// @notice Transfers the requested amount of tokens to the recipient\n    /// @param _recipient The address that will receive the locked tokens back\n    /// @param _amount The amount of tokens that the recipient will get\n    function _0x9d7414(address _0xae9a01, uint256 _0xd306da) internal virtual;\n\n    function _0x34bcdb(uint256 _0x03c9a9, IMajorityVoting.VoteOption _0x9f6ae0) internal virtual {\n        uint256 _0x2ed829 = _0x6eddde(msg.sender);\n\n        /// @dev The voting power value is checked within plugin.vote()\n\n        ILockToVote(address(_0xd5ade2))._0x1d988f(_0x03c9a9, msg.sender, _0x9f6ae0, _0x2ed829);\n    }\n\n    function _0x251839() internal virtual {\n        uint256 _0x314b8a = _0x5f26d2.length();\n        for (uint256 _0xccd8af; _0xccd8af < _0x314b8a;) {\n            uint256 _0x03c9a9 = _0x5f26d2._0xba3f52(_0xccd8af);\n            if (!_0xd5ade2._0x3c0ea1(_0x03c9a9)) {\n                _0x5f26d2._0xffc845(_0x03c9a9);\n                if (msg.sender != address(0) || msg.sender == address(0)) { _0x314b8a = _0x5f26d2.length(); }\n\n                // Were we at the last element?\n                if (_0xccd8af == _0x314b8a) {\n                    return;\n                }\n\n                // Recheck the same index (now, another proposalId)\n                continue;\n            }\n\n            if (_0xd5ade2._0x0328d2(_0x03c9a9, msg.sender) > 0) {\n                ILockToVote(address(_0xd5ade2))._0xfa234a(_0x03c9a9, msg.sender);\n            }\n\n            unchecked {\n                _0xccd8af++;\n            }\n        }\n    }\n}\n",
      "rename_map": {
        "_withdrawActiveVotingPower": "_0x251839",
        "knownProposalIdsLength": "_0xc9175a",
        "_incomingTokenBalance": "_0xe6d2c1",
        "_currentVotingPower": "_0x2ed829",
        "_refundableBalance": "_0x1c2ccf",
        "_doUnlockTransfer": "_0x9d7414",
        "supportsInterface": "_0x694666",
        "_newPluginAddress": "_0xe9a00e",
        "knownProposalIdAt": "_0x99c130",
        "setPluginAddress": "_0x1418ca",
        "knownProposalIds": "_0x5f26d2",
        "getLockedBalance": "_0x6eddde",
        "usedVotingPower": "_0x0328d2",
        "proposalCreated": "_0x7d632d",
        "_doLockTransfer": "_0xf7162f",
        "isProposalOpen": "_0x3c0ea1",
        "_proposalCount": "_0x314b8a",
        "lockedBalances": "_0xcae5c1",
        "proposalEnded": "_0x27eaa4",
        "interfaceId": "_0xd2e6f3",
        "_voteOption": "_0x9f6ae0",
        "_proposalId": "_0x03c9a9",
        "lockAndVote": "_0xec61a9",
        "proposalId": "_0x900c40",
        "_recipient": "_0xae9a01",
        "pluginMode": "_0x56c972",
        "_settings": "_0xcf5f8c",
        "clearVote": "_0xfa234a",
        "settings": "_0x9e845e",
        "_account": "_0x04b73c",
        "canVote": "_0xe67164",
        "_amount": "_0xd306da",
        "_index": "_0xde9328",
        "unlock": "_0x5e5bf5",
        "amount": "_0x109aa3",
        "_voter": "_0x74d2a7",
        "remove": "_0xffc845",
        "plugin": "_0xd5ade2",
        "_lock": "_0x15d36b",
        "voter": "_0x1bdd10",
        "_vote": "_0x34bcdb",
        "vote": "_0x1d988f",
        "lock": "_0x5ddb1a",
        "add": "_0xbb0d83",
        "_i": "_0xccd8af",
        "at": "_0xba3f52"
      },
      "changes": [
        "Renamed 46 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_016",
      "transformed_id": "ss_l3_medium_sn_gs_016",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this._0xd9265b.selector ^ this._0xa5cdd5.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = _0x3d1aad(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = _0x3d1aad(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 _0xec3996, address _0xc9c953);\n\n    error VoteRemovalForbidden(uint256 _0xec3996, address _0xc9c953);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function _0x702df7(\n        IDAO _0x5902b8,\n        ILockManager _0xbcd401,\n        VotingSettings calldata _0x32e59b,\n        IPlugin.TargetConfig calldata _0x71f57a,\n        bytes calldata _0x637302\n    ) external _0x90db51 _0x5bd88c(1) {\n        __MajorityVotingBase_init(_0x5902b8, _0x32e59b, _0x71f57a, _0x637302);\n        __LockToGovernBase_init(_0xbcd401);\n\n        emit MembershipContractAnnounced({_0x9cff11: address(_0xbcd401._0xc5e18e())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function _0x4adbfc(bytes4 _0x7ea1a4)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _0x7ea1a4 == LOCK_TO_VOTE_INTERFACE_ID || _0x7ea1a4 == type(ILockToVote)._0xf2592e\n            || super._0x4adbfc(_0x7ea1a4);\n    }\n\n    /// @inheritdoc IProposal\n    function _0x463d53() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function _0xa5cdd5(\n        bytes calldata _0xaab115,\n        Action[] memory _0x00e78c,\n        uint64 _0x27f50d,\n        uint64 _0x3d1967,\n        bytes memory _0x0d6606\n    ) external _0x78009e(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 _0xec3996) {\n        uint256 _0x14577c;\n\n        if (_0x0d6606.length != 0) {\n            (_0x14577c) = abi._0x4cecce(_0x0d6606, (uint256));\n        }\n\n        if (_0x7c0d6d() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_0x27f50d, _0x3d1967) = _0xd6353f(_0x27f50d, _0x3d1967);\n\n        _0xec3996 = _0x2b50b9(_0x3d1aad(abi._0x0dd26a(_0x00e78c, _0xaab115)));\n\n        if (_0xa2889a(_0xec3996)) {\n            revert ProposalAlreadyExists(_0xec3996);\n        }\n\n        // Store proposal related information\n        Proposal storage _0x03bb67 = _0x00ee96[_0xec3996];\n\n        _0x03bb67._0x1f0233._0x2fa94f = _0x2fa94f();\n        _0x03bb67._0x1f0233._0xa99611 = _0xa99611();\n        _0x03bb67._0x1f0233._0xefae6e = _0x27f50d;\n        _0x03bb67._0x1f0233._0xf8f367 = _0x3d1967;\n        _0x03bb67._0x1f0233._0xa2dd3f = _0xa2dd3f();\n        _0x03bb67._0x1f0233._0xf74622 = _0xf74622();\n\n        _0x03bb67._0x86a212 = _0x42b21a();\n\n        // Reduce costs\n        if (_0x14577c != 0) {\n            _0x03bb67._0xdc4d02 = _0x14577c;\n        }\n\n        for (uint256 i; i < _0x00e78c.length;) {\n            _0x03bb67._0x9af0f5.push(_0x00e78c[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(_0xec3996, _0x5539c0(), _0x27f50d, _0x3d1967, _0xaab115, _0x00e78c, _0x14577c);\n\n        _0xa35adc._0x4459ca(_0xec3996);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function _0x0ebfb5(uint256 _0x35ae6e, address _0x3269a5, VoteOption _0x77489c) public view returns (bool) {\n        if (!_0xa2889a(_0x35ae6e)) {\n            revert NonexistentProposal(_0x35ae6e);\n        }\n\n        Proposal storage _0x03bb67 = _0x00ee96[_0x35ae6e];\n        return _0x8dd973(_0x03bb67, _0x3269a5, _0x77489c, _0xa35adc._0xf99950(_0x3269a5));\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x3ca628(uint256 _0x35ae6e, address _0x3269a5, VoteOption _0x77489c, uint256 _0xe934ce)\n        public\n        override\n        _0x78009e(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage _0x03bb67 = _0x00ee96[_0x35ae6e];\n\n        if (!_0x8dd973(_0x03bb67, _0x3269a5, _0x77489c, _0xe934ce)) {\n            revert VoteCastForbidden(_0x35ae6e, _0x3269a5);\n        }\n\n        // Same vote\n        if (_0x77489c == _0x03bb67._0xd8adb6[_0x3269a5]._0x943107) {\n            // Same value, nothing to do\n            if (_0xe934ce == _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 _0xcbcbf8 = _0xe934ce - _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61;\n            _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61 = _0xe934ce;\n\n            if (_0x03bb67._0xd8adb6[_0x3269a5]._0x943107 == VoteOption.Yes) {\n                _0x03bb67._0x052bae._0xa8af7c += _0xcbcbf8;\n            } else if (_0x03bb67._0xd8adb6[_0x3269a5]._0x943107 == VoteOption.No) {\n                _0x03bb67._0x052bae._0xbd57af += _0xcbcbf8;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                _0x03bb67._0x052bae._0xbbfe01 += _0xcbcbf8;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (_0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61 > 0) {\n                // Undo that vote\n                if (_0x03bb67._0xd8adb6[_0x3269a5]._0x943107 == VoteOption.Yes) {\n                    _0x03bb67._0x052bae._0xa8af7c -= _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61;\n                } else if (_0x03bb67._0xd8adb6[_0x3269a5]._0x943107 == VoteOption.No) {\n                    _0x03bb67._0x052bae._0xbd57af -= _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    _0x03bb67._0x052bae._0xbbfe01 -= _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61;\n                }\n            }\n\n            // Register the new vote\n            if (_0x77489c == VoteOption.Yes) {\n                _0x03bb67._0x052bae._0xa8af7c += _0xe934ce;\n            } else if (_0x77489c == VoteOption.No) {\n                _0x03bb67._0x052bae._0xbd57af += _0xe934ce;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                _0x03bb67._0x052bae._0xbbfe01 += _0xe934ce;\n            }\n            _0x03bb67._0xd8adb6[_0x3269a5]._0x943107 = _0x77489c;\n            _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61 = _0xe934ce;\n        }\n\n        emit VoteCast(_0x35ae6e, _0x3269a5, _0x77489c, _0xe934ce);\n\n        if (_0x03bb67._0x1f0233._0x2fa94f == VotingMode.EarlyExecution) {\n            _0x8da64a(_0x35ae6e, _0x5539c0());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x26d886(uint256 _0x35ae6e, address _0x3269a5) external _0x78009e(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage _0x03bb67 = _0x00ee96[_0x35ae6e];\n        if (!_0xa37454(_0x03bb67)) {\n            revert VoteRemovalForbidden(_0x35ae6e, _0x3269a5);\n        } else if (_0x03bb67._0x1f0233._0x2fa94f != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_0x35ae6e, _0x3269a5);\n        } else if (_0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61 == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (_0x03bb67._0xd8adb6[_0x3269a5]._0x943107 == VoteOption.Yes) {\n            _0x03bb67._0x052bae._0xa8af7c -= _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61;\n        } else if (_0x03bb67._0xd8adb6[_0x3269a5]._0x943107 == VoteOption.No) {\n            _0x03bb67._0x052bae._0xbd57af -= _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (_0x03bb67._0xd8adb6[_0x3269a5]._0x943107 == VoteOption.Abstain) {\n            _0x03bb67._0x052bae._0xbbfe01 -= _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61;\n        }\n        _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61 = 0;\n\n        emit VoteCleared(_0x35ae6e, _0x3269a5);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x3bb5e4(uint256 _0x35ae6e) external view returns (bool) {\n        Proposal storage _0x03bb67 = _0x00ee96[_0x35ae6e];\n        return _0xa37454(_0x03bb67);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0xd9265b() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase._0xd9265b();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0x7c0d6d() public view override returns (uint256) {\n        return IERC20(_0xa35adc._0xc5e18e())._0x1f073a();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x9da156(uint256 _0x35ae6e, address _0x3269a5) public view returns (uint256) {\n        return _0x00ee96[_0x35ae6e]._0xd8adb6[_0x3269a5]._0xd11d61;\n    }\n\n    // Internal helpers\n\n    function _0x8dd973(Proposal storage _0x03bb67, address _0x3269a5, VoteOption _0x77489c, uint256 _0xe934ce)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _0x245e37 = _0x03bb67._0xd8adb6[_0x3269a5]._0xd11d61;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_0xa37454(_0x03bb67)) {\n            return false;\n        } else if (_0x77489c == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (_0x03bb67._0x1f0233._0x2fa94f != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_0xe934ce <= _0x245e37) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                _0x03bb67._0xd8adb6[_0x3269a5]._0x943107 != VoteOption.None\n                    && _0x77489c != _0x03bb67._0xd8adb6[_0x3269a5]._0x943107\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_0xe934ce == 0 || _0xe934ce < _0x245e37) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_0xe934ce == _0x245e37 && _0x77489c == _0x03bb67._0xd8adb6[_0x3269a5]._0x943107) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _0x8da64a(uint256 _0x35ae6e, address _0x7c0822) internal {\n        if (!_0x084cae(_0x35ae6e)) {\n            return;\n        } else if (!_0xd7b841()._0xf58d1c(address(this), _0x7c0822, EXECUTE_PROPOSAL_PERMISSION_ID, _0x622e8b())) {\n            return;\n        }\n\n        _0x001483(_0x35ae6e);\n    }\n\n    function _0x001483(uint256 _0x35ae6e) internal override {\n        super._0x001483(_0x35ae6e);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        _0xa35adc._0x6e49dc(_0x35ae6e);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "rename_map": {
        "onlyCallAtInitialization": "_0x90db51",
        "customProposalParamsABI": "_0x463d53",
        "_attemptEarlyExecution": "_0x8da64a",
        "_validateProposalDates": "_0xd6353f",
        "minProposerVotingPower": "_0xd9265b",
        "supportThresholdRatio": "_0xa99611",
        "minParticipationRatio": "_0xa2dd3f",
        "_currentVotingPower": "_0x245e37",
        "currentTokenSupply": "_0x7c0d6d",
        "supportsInterface": "_0x4adbfc",
        "_createProposalId": "_0x2b50b9",
        "definingContract": "_0x9cff11",
        "_allowFailureMap": "_0x14577c",
        "getLockedBalance": "_0xf99950",
        "minApprovalRatio": "_0xf74622",
        "_isProposalOpen": "_0xa37454",
        "allowFailureMap": "_0xdc4d02",
        "getTargetConfig": "_0x42b21a",
        "_votingSettings": "_0x32e59b",
        "_pluginMetadata": "_0x637302",
        "_proposalExists": "_0xa2889a",
        "usedVotingPower": "_0x9da156",
        "proposalCreated": "_0x4459ca",
        "_newVotingPower": "_0xe934ce",
        "isProposalOpen": "_0x3bb5e4",
        "createProposal": "_0xa5cdd5",
        "proposalEnded": "_0x6e49dc",
        "reinitializer": "_0x5bd88c",
        "_targetConfig": "_0x71f57a",
        "hasPermission": "_0xf58d1c",
        "_interfaceId": "_0x7ea1a4",
        "targetConfig": "_0x86a212",
        "_lockManager": "_0xbcd401",
        "interfaceId": "_0xf2592e",
        "_proposalId": "_0x35ae6e",
        "votingPower": "_0xd11d61",
        "totalSupply": "_0x1f073a",
        "_voteOption": "_0x77489c",
        "_canExecute": "_0x084cae",
        "lockManager": "_0xa35adc",
        "_voteCaller": "_0x7c0822",
        "proposalId": "_0xec3996",
        "votingMode": "_0x2fa94f",
        "voteOption": "_0x943107",
        "_startDate": "_0x27f50d",
        "parameters": "_0x1f0233",
        "initialize": "_0x702df7",
        "_msgSender": "_0x5539c0",
        "keccak256": "_0x3d1aad",
        "clearVote": "_0x26d886",
        "startDate": "_0xefae6e",
        "proposals": "_0x00ee96",
        "proposal_": "_0x03bb67",
        "_metadata": "_0xaab115",
        "_actions": "_0x00e78c",
        "_execute": "_0x001483",
        "_canVote": "_0x8dd973",
        "_endDate": "_0x3d1967",
        "_msgData": "_0x622e8b",
        "abstain": "_0xbbfe01",
        "canVote": "_0x0ebfb5",
        "endDate": "_0xf8f367",
        "actions": "_0x9af0f5",
        "decode": "_0x4cecce",
        "_voter": "_0x3269a5",
        "encode": "_0x0dd26a",
        "tally": "_0x052bae",
        "token": "_0xc5e18e",
        "voter": "_0xc9c953",
        "_data": "_0x0d6606",
        "votes": "_0xd8adb6",
        "_dao": "_0x5902b8",
        "diff": "_0xcbcbf8",
        "auth": "_0x78009e",
        "vote": "_0x3ca628",
        "dao": "_0xd7b841",
        "yes": "_0xa8af7c",
        "no": "_0xbd57af"
      },
      "changes": [
        "Renamed 78 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_017",
      "transformed_id": "ss_l3_medium_sn_gs_017",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n/// @title MinVotingPowerCondition\n/// @author Aragon X - 2024\n/// @notice Checks if an account's voting power or token balance meets the threshold defined on the given plugin.\n/// @custom:security-contact sirt@aragon.org\ncontract MinVotingPowerCondition is PermissionCondition {\n    /// @notice The address of the `ILockToGovernBase` plugin used to fetch the settings from.\n    ILockToGovernBase public immutable _0xb9525c;\n\n    /// @notice The address of the LockManager used by the plugin.\n    ILockManager public immutable _0x8e5477;\n\n    /// @notice The `IERC20` token interface used to check token balance.\n    IERC20 public immutable _0x80af25;\n\n    /// @notice Initializes the contract with the `ILockToGovernBase` plugin address and caches the associated token.\n    /// @param _plugin The address of the `ILockToGovernBase` plugin.\n    constructor(ILockToGovernBase _0x7b82b4) {\n        if (1 == 1) { _0xb9525c = _0x7b82b4; }\n        _0x80af25 = _0xb9525c._0x80af25();\n        _0x8e5477 = _0xb9525c._0x8e5477();\n    }\n\n    /// @inheritdoc IPermissionCondition\n    /// @dev The function checks both the voting power and token balance to ensure `_who` meets the minimum voting\n    ///      threshold defined in the `TokenVoting` plugin. Returns `false` if the minimum requirement is unmet.\n    function _0x65a269(address _0xbaeb7c, address _0x67264a, bytes32 _0x243d36, bytes calldata _0xd64959)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (_0xbaeb7c, _0xd64959, _0x243d36);\n\n        uint256 _0x5f9e40 = _0x80af25._0x09818f(_0x67264a) + _0x8e5477._0xd8a47c(_0x67264a);\n        uint256 _0x7b3d2e = _0xb9525c._0x6af5dd();\n\n        return _0x5f9e40 >= _0x7b3d2e;\n    }\n}\n",
      "rename_map": {
        "_minProposerVotingPower": "_0x7b3d2e",
        "minProposerVotingPower": "_0x6af5dd",
        "getLockedBalance": "_0xd8a47c",
        "_currentBalance": "_0x5f9e40",
        "_permissionId": "_0x243d36",
        "lockManager": "_0x8e5477",
        "balanceOf": "_0x09818f",
        "isGranted": "_0x65a269",
        "_plugin": "_0x7b82b4",
        "plugin": "_0xb9525c",
        "_where": "_0xbaeb7c",
        "token": "_0x80af25",
        "_data": "_0xd64959",
        "_who": "_0x67264a"
      },
      "changes": [
        "Renamed 14 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_018",
      "transformed_id": "ss_l3_medium_sn_gs_018",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this._0x8f6290.selector ^ this._0x96acb0.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = _0x562d70(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = _0x562d70(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 _0x108bf8, address _0xa8831a);\n\n    error VoteRemovalForbidden(uint256 _0x108bf8, address _0xa8831a);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function _0x2f65c3(\n        IDAO _0x149e36,\n        ILockManager _0xbc51e4,\n        VotingSettings calldata _0x2cec61,\n        IPlugin.TargetConfig calldata _0x6bb9f4,\n        bytes calldata _0xcc8473\n    ) external _0x36516a _0x769004(1) {\n        __MajorityVotingBase_init(_0x149e36, _0x2cec61, _0x6bb9f4, _0xcc8473);\n        __LockToGovernBase_init(_0xbc51e4);\n\n        emit MembershipContractAnnounced({_0x2560f1: address(_0xbc51e4._0xcf96ca())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function _0xd8a802(bytes4 _0x5fe3ad)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _0x5fe3ad == LOCK_TO_VOTE_INTERFACE_ID || _0x5fe3ad == type(ILockToVote)._0xa9e5ed\n            || super._0xd8a802(_0x5fe3ad);\n    }\n\n    /// @inheritdoc IProposal\n    function _0x597e65() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function _0x96acb0(\n        bytes calldata _0xb2379c,\n        Action[] memory _0xb4d5d6,\n        uint64 _0xf70ca1,\n        uint64 _0xc1a21b,\n        bytes memory _0x5fac18\n    ) external _0x111d7c(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 _0x108bf8) {\n        uint256 _0x6c4a01;\n\n        if (_0x5fac18.length != 0) {\n            (_0x6c4a01) = abi._0xee5277(_0x5fac18, (uint256));\n        }\n\n        if (_0x7b8be1() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_0xf70ca1, _0xc1a21b) = _0xf742e6(_0xf70ca1, _0xc1a21b);\n\n        _0x108bf8 = _0xa7a8f1(_0x562d70(abi._0x222b3a(_0xb4d5d6, _0xb2379c)));\n\n        if (_0x345d3b(_0x108bf8)) {\n            revert ProposalAlreadyExists(_0x108bf8);\n        }\n\n        // Store proposal related information\n        Proposal storage _0xcd4f7e = _0xf5bc57[_0x108bf8];\n\n        _0xcd4f7e._0x1d07fe._0x87a0e9 = _0x87a0e9();\n        _0xcd4f7e._0x1d07fe._0x264e4a = _0x264e4a();\n        _0xcd4f7e._0x1d07fe._0xfb6d8d = _0xf70ca1;\n        _0xcd4f7e._0x1d07fe._0x0be217 = _0xc1a21b;\n        _0xcd4f7e._0x1d07fe._0x76ebbe = _0x76ebbe();\n        _0xcd4f7e._0x1d07fe._0x89456c = _0x89456c();\n\n        _0xcd4f7e._0x1f947b = _0xb0965c();\n\n        // Reduce costs\n        if (_0x6c4a01 != 0) {\n            _0xcd4f7e._0x60d1b2 = _0x6c4a01;\n        }\n\n        for (uint256 i; i < _0xb4d5d6.length;) {\n            _0xcd4f7e._0x6f4e7e.push(_0xb4d5d6[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(_0x108bf8, _0xfe2c09(), _0xf70ca1, _0xc1a21b, _0xb2379c, _0xb4d5d6, _0x6c4a01);\n\n        _0x742228._0x2e89e1(_0x108bf8);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function _0xc41067(uint256 _0x0c25c1, address _0xdc2e58, VoteOption _0x3d4ffb) public view returns (bool) {\n        if (!_0x345d3b(_0x0c25c1)) {\n            revert NonexistentProposal(_0x0c25c1);\n        }\n\n        Proposal storage _0xcd4f7e = _0xf5bc57[_0x0c25c1];\n        return _0xb8cc53(_0xcd4f7e, _0xdc2e58, _0x3d4ffb, _0x742228._0x7dbfb5(_0xdc2e58));\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0xe2b95f(uint256 _0x0c25c1, address _0xdc2e58, VoteOption _0x3d4ffb, uint256 _0x5f960d)\n        public\n        override\n        _0x111d7c(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage _0xcd4f7e = _0xf5bc57[_0x0c25c1];\n\n        if (!_0xb8cc53(_0xcd4f7e, _0xdc2e58, _0x3d4ffb, _0x5f960d)) {\n            revert VoteCastForbidden(_0x0c25c1, _0xdc2e58);\n        }\n\n        // Same vote\n        if (_0x3d4ffb == _0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6) {\n            // Same value, nothing to do\n            if (_0x5f960d == _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 _0x49d1e2 = _0x5f960d - _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026;\n            _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026 = _0x5f960d;\n\n            if (_0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6 == VoteOption.Yes) {\n                _0xcd4f7e._0xce78bf._0x5d6ed5 += _0x49d1e2;\n            } else if (_0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6 == VoteOption.No) {\n                _0xcd4f7e._0xce78bf._0xb4ebd5 += _0x49d1e2;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                _0xcd4f7e._0xce78bf._0xe5429e += _0x49d1e2;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (_0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026 > 0) {\n                // Undo that vote\n                if (_0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6 == VoteOption.Yes) {\n                    _0xcd4f7e._0xce78bf._0x5d6ed5 -= _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026;\n                } else if (_0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6 == VoteOption.No) {\n                    _0xcd4f7e._0xce78bf._0xb4ebd5 -= _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    _0xcd4f7e._0xce78bf._0xe5429e -= _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026;\n                }\n            }\n\n            // Register the new vote\n            if (_0x3d4ffb == VoteOption.Yes) {\n                _0xcd4f7e._0xce78bf._0x5d6ed5 += _0x5f960d;\n            } else if (_0x3d4ffb == VoteOption.No) {\n                _0xcd4f7e._0xce78bf._0xb4ebd5 += _0x5f960d;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                _0xcd4f7e._0xce78bf._0xe5429e += _0x5f960d;\n            }\n            _0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6 = _0x3d4ffb;\n            _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026 = _0x5f960d;\n        }\n\n        emit VoteCast(_0x0c25c1, _0xdc2e58, _0x3d4ffb, _0x5f960d);\n\n        if (_0xcd4f7e._0x1d07fe._0x87a0e9 == VotingMode.EarlyExecution) {\n            _0xe76c53(_0x0c25c1, _0xfe2c09());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x33168a(uint256 _0x0c25c1, address _0xdc2e58) external _0x111d7c(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage _0xcd4f7e = _0xf5bc57[_0x0c25c1];\n        if (!_0x5e363d(_0xcd4f7e)) {\n            revert VoteRemovalForbidden(_0x0c25c1, _0xdc2e58);\n        } else if (_0xcd4f7e._0x1d07fe._0x87a0e9 != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_0x0c25c1, _0xdc2e58);\n        } else if (_0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026 == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (_0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6 == VoteOption.Yes) {\n            _0xcd4f7e._0xce78bf._0x5d6ed5 -= _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026;\n        } else if (_0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6 == VoteOption.No) {\n            _0xcd4f7e._0xce78bf._0xb4ebd5 -= _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (_0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6 == VoteOption.Abstain) {\n            _0xcd4f7e._0xce78bf._0xe5429e -= _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026;\n        }\n        _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026 = 0;\n\n        emit VoteCleared(_0x0c25c1, _0xdc2e58);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0xb42d04(uint256 _0x0c25c1) external view returns (bool) {\n        Proposal storage _0xcd4f7e = _0xf5bc57[_0x0c25c1];\n        return _0x5e363d(_0xcd4f7e);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0x8f6290() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase._0x8f6290();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0x7b8be1() public view override returns (uint256) {\n        return IERC20(_0x742228._0xcf96ca())._0x3649b4();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x7f18b0(uint256 _0x0c25c1, address _0xdc2e58) public view returns (uint256) {\n        return _0xf5bc57[_0x0c25c1]._0x58a145[_0xdc2e58]._0x6b3026;\n    }\n\n    // Internal helpers\n\n    function _0xb8cc53(Proposal storage _0xcd4f7e, address _0xdc2e58, VoteOption _0x3d4ffb, uint256 _0x5f960d)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _0xf6e702 = _0xcd4f7e._0x58a145[_0xdc2e58]._0x6b3026;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_0x5e363d(_0xcd4f7e)) {\n            return false;\n        } else if (_0x3d4ffb == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (_0xcd4f7e._0x1d07fe._0x87a0e9 != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_0x5f960d <= _0xf6e702) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                _0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6 != VoteOption.None\n                    && _0x3d4ffb != _0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_0x5f960d == 0 || _0x5f960d < _0xf6e702) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_0x5f960d == _0xf6e702 && _0x3d4ffb == _0xcd4f7e._0x58a145[_0xdc2e58]._0x5a85c6) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _0xe76c53(uint256 _0x0c25c1, address _0xb7d187) internal {\n        if (!_0x4d7509(_0x0c25c1)) {\n            return;\n        } else if (!_0x33d9fc()._0xa61cf1(address(this), _0xb7d187, EXECUTE_PROPOSAL_PERMISSION_ID, _0x8bd298())) {\n            return;\n        }\n\n        _0x891b7d(_0x0c25c1);\n    }\n\n    function _0x891b7d(uint256 _0x0c25c1) internal override {\n        super._0x891b7d(_0x0c25c1);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        _0x742228._0x3d7c32(_0x0c25c1);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "rename_map": {
        "onlyCallAtInitialization": "_0x36516a",
        "customProposalParamsABI": "_0x597e65",
        "_attemptEarlyExecution": "_0xe76c53",
        "_validateProposalDates": "_0xf742e6",
        "minProposerVotingPower": "_0x8f6290",
        "supportThresholdRatio": "_0x264e4a",
        "minParticipationRatio": "_0x76ebbe",
        "_currentVotingPower": "_0xf6e702",
        "currentTokenSupply": "_0x7b8be1",
        "supportsInterface": "_0xd8a802",
        "_createProposalId": "_0xa7a8f1",
        "definingContract": "_0x2560f1",
        "_allowFailureMap": "_0x6c4a01",
        "getLockedBalance": "_0x7dbfb5",
        "minApprovalRatio": "_0x89456c",
        "_isProposalOpen": "_0x5e363d",
        "allowFailureMap": "_0x60d1b2",
        "getTargetConfig": "_0xb0965c",
        "_votingSettings": "_0x2cec61",
        "_pluginMetadata": "_0xcc8473",
        "_proposalExists": "_0x345d3b",
        "usedVotingPower": "_0x7f18b0",
        "proposalCreated": "_0x2e89e1",
        "_newVotingPower": "_0x5f960d",
        "isProposalOpen": "_0xb42d04",
        "createProposal": "_0x96acb0",
        "proposalEnded": "_0x3d7c32",
        "reinitializer": "_0x769004",
        "_targetConfig": "_0x6bb9f4",
        "hasPermission": "_0xa61cf1",
        "_interfaceId": "_0x5fe3ad",
        "targetConfig": "_0x1f947b",
        "_lockManager": "_0xbc51e4",
        "interfaceId": "_0xa9e5ed",
        "_proposalId": "_0x0c25c1",
        "votingPower": "_0x6b3026",
        "totalSupply": "_0x3649b4",
        "_voteOption": "_0x3d4ffb",
        "_canExecute": "_0x4d7509",
        "lockManager": "_0x742228",
        "_voteCaller": "_0xb7d187",
        "proposalId": "_0x108bf8",
        "votingMode": "_0x87a0e9",
        "voteOption": "_0x5a85c6",
        "_startDate": "_0xf70ca1",
        "parameters": "_0x1d07fe",
        "initialize": "_0x2f65c3",
        "_msgSender": "_0xfe2c09",
        "keccak256": "_0x562d70",
        "clearVote": "_0x33168a",
        "startDate": "_0xfb6d8d",
        "proposals": "_0xf5bc57",
        "proposal_": "_0xcd4f7e",
        "_metadata": "_0xb2379c",
        "_actions": "_0xb4d5d6",
        "_execute": "_0x891b7d",
        "_canVote": "_0xb8cc53",
        "_endDate": "_0xc1a21b",
        "_msgData": "_0x8bd298",
        "abstain": "_0xe5429e",
        "canVote": "_0xc41067",
        "endDate": "_0x0be217",
        "actions": "_0x6f4e7e",
        "decode": "_0xee5277",
        "_voter": "_0xdc2e58",
        "encode": "_0x222b3a",
        "tally": "_0xce78bf",
        "token": "_0xcf96ca",
        "voter": "_0xa8831a",
        "_data": "_0x5fac18",
        "votes": "_0x58a145",
        "_dao": "_0x149e36",
        "diff": "_0x49d1e2",
        "auth": "_0x111d7c",
        "vote": "_0xe2b95f",
        "dao": "_0x33d9fc",
        "yes": "_0x5d6ed5",
        "no": "_0xb4ebd5"
      },
      "changes": [
        "Renamed 78 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_019",
      "transformed_id": "ss_l3_medium_sn_gs_019",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {ReentrancyGuardTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\n/// @title Midas Redemption Vault Gateway\n/// @notice Gateway contract that manages redemptions from Midas vault on behalf of users\n/// @dev Stores pending redemption requests and handles partial withdrawals\ncontract MidasRedemptionVaultGateway is ReentrancyGuardTrait, IMidasRedemptionVaultGateway {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant override _0x7c05aa = \"GATEWAY::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override _0xbd0774 = 3_10;\n\n    address public immutable _0x943ef4;\n    address public immutable _0x686670;\n\n    mapping(address => PendingRedemption) public _0x97755c;\n\n    /// @notice Constructor\n    /// @param _midasRedemptionVault Address of the Midas Redemption Vault\n    constructor(address _0x4979f0) {\n        _0x943ef4 = _0x4979f0;\n        _0x686670 = IMidasRedemptionVault(_0x4979f0)._0x686670();\n    }\n\n    /// @notice Performs instant redemption of mToken for output token\n    /// @param tokenOut Output token to receive\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @param minReceiveAmount Minimum amount of output token to receive\n    /// @dev Transfers mToken from sender, redeems, and transfers output token back\n    function _0x860391(address _0xb5bae4, uint256 _0x26f25c, uint256 _0x9d4d95) external _0x0277d5 {\n        IERC20(_0x686670)._0xa5fe67(msg.sender, address(this), _0x26f25c);\n\n        uint256 _0x76d010 = IERC20(_0xb5bae4)._0xff6fe9(address(this));\n\n        IERC20(_0x686670)._0xfcf066(_0x943ef4, _0x26f25c);\n        IMidasRedemptionVault(_0x943ef4)._0x860391(_0xb5bae4, _0x26f25c, _0x9d4d95);\n\n        uint256 _0xa26c3e = IERC20(_0xb5bae4)._0xff6fe9(address(this)) - _0x76d010;\n\n        IERC20(_0xb5bae4)._0xcf9288(msg.sender, _0xa26c3e);\n    }\n\n    /// @notice Requests a redemption of mToken for output token\n    /// @param tokenOut Output token to receive\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @dev Stores the request ID and timestamp for tracking\n    function _0xd17159(address _0xb5bae4, uint256 _0x26f25c) external _0x0277d5 {\n        if (_0x97755c[msg.sender]._0x1f917e) {\n            revert(\"MidasRedemptionVaultGateway: user has a pending redemption\");\n        }\n\n        uint256 _0x72f468 = IMidasRedemptionVault(_0x943ef4)._0xa07e70();\n\n        IERC20(_0x686670)._0xa5fe67(msg.sender, address(this), _0x26f25c);\n\n        IERC20(_0x686670)._0xfcf066(_0x943ef4, _0x26f25c);\n        IMidasRedemptionVault(_0x943ef4)._0x3e0a6e(_0xb5bae4, _0x26f25c);\n\n        _0x97755c[msg.sender] =\n            PendingRedemption({_0x1f917e: true, _0x72f468: _0x72f468, timestamp: block.timestamp, _0xcac908: 0});\n    }\n\n    /// @notice Withdraws tokens from a fulfilled redemption request\n    /// @param amount Amount of output token to withdraw\n    /// @dev Supports partial withdrawals by tracking remainder\n    function _0x392b8d(uint256 _0xa26c3e) external _0x0277d5 {\n        PendingRedemption memory _0x3d89ec = _0x97755c[msg.sender];\n\n        if (!_0x3d89ec._0x1f917e) {\n            revert(\"MidasRedemptionVaultGateway: user does not have a pending redemption\");\n        }\n\n        (\n            address sender,\n            address _0xb5bae4,\n            uint8 _0xdd119b,\n            uint256 _0x26f25c,\n            uint256 _0x0c33b7,\n            uint256 _0x475bfe\n        ) = IMidasRedemptionVault(_0x943ef4)._0x3b59c8(_0x3d89ec._0x72f468);\n\n        if (sender != address(this)) {\n            revert(\"MidasRedemptionVaultGateway: invalid request\");\n        }\n\n        if (_0xdd119b != 1) {\n            revert(\"MidasRedemptionVaultGateway: redemption not fulfilled\");\n        }\n\n        uint256 _0x40a09a;\n\n        if (_0x3d89ec._0xcac908 > 0) {\n            _0x40a09a = _0x3d89ec._0xcac908;\n        } else {\n            if (1 == 1) { _0x40a09a = _0xc95055(_0x26f25c, _0x0c33b7, _0x475bfe, _0xb5bae4); }\n        }\n\n        if (_0xa26c3e > _0x40a09a) {\n            revert(\"MidasRedemptionVaultGateway: amount exceeds available\");\n        }\n\n        if (_0xa26c3e == _0x40a09a) {\n            delete _0x97755c[msg.sender];\n        } else {\n            _0x97755c[msg.sender]._0xcac908 = _0x40a09a - _0xa26c3e;\n        }\n\n        IERC20(_0xb5bae4)._0xcf9288(msg.sender, _0xa26c3e);\n    }\n\n    /// @notice Returns the expected amount of output token for a user's pending redemption\n    /// @param user User address to check\n    /// @param tokenOut Output token to check\n    /// @return Expected amount of output token, considering any partial withdrawals\n    function _0xe2e7c7(address _0x508584, address _0xb5bae4) external view returns (uint256) {\n        PendingRedemption memory _0x3d89ec = _0x97755c[_0x508584];\n\n        if (!_0x3d89ec._0x1f917e) {\n            return 0;\n        }\n\n        (address sender, address _0x89fd61,, uint256 _0x26f25c, uint256 _0x0c33b7, uint256 _0x475bfe) =\n            IMidasRedemptionVault(_0x943ef4)._0x3b59c8(_0x3d89ec._0x72f468);\n\n        if (sender != address(this) || _0x89fd61 != _0xb5bae4) {\n            return 0;\n        }\n\n        if (_0x3d89ec._0xcac908 > 0) {\n            return _0x3d89ec._0xcac908;\n        } else {\n            return _0xc95055(_0x26f25c, _0x0c33b7, _0x475bfe, _0xb5bae4);\n        }\n    }\n\n    /// @dev Calculates the output token amount from mToken amount and rates\n    /// @param amountMTokenIn Amount of mToken\n    /// @param mTokenRate Rate of mToken\n    /// @param tokenOutRate Rate of output token\n    /// @param tokenOut Address of output token\n    /// @return Amount of output token in its native decimals\n    function _0xc95055(\n        uint256 _0x26f25c,\n        uint256 _0x0c33b7,\n        uint256 _0x475bfe,\n        address _0xb5bae4\n    ) internal view returns (uint256) {\n        uint256 _0x8769e2 = (_0x26f25c * _0x0c33b7) / _0x475bfe;\n\n        uint256 _0x482370 = 10 ** IERC20Metadata(_0xb5bae4)._0x183065();\n\n        return _0x8769e2 * _0x482370 / 1e18;\n    }\n}",
      "rename_map": {
        "_calculateTokenOutAmount": "_0xc95055",
        "pendingTokenOutAmount": "_0xe2e7c7",
        "_midasRedemptionVault": "_0x4979f0",
        "midasRedemptionVault": "_0x943ef4",
        "pendingRedemptions": "_0x97755c",
        "currentRequestId": "_0xa07e70",
        "minReceiveAmount": "_0x9d4d95",
        "safeTransferFrom": "_0xa5fe67",
        "availableAmount": "_0x40a09a",
        "requestTokenOut": "_0x89fd61",
        "redeemRequests": "_0x3b59c8",
        "amountMTokenIn": "_0x26f25c",
        "redeemRequest": "_0x3e0a6e",
        "redeemInstant": "_0x860391",
        "balanceBefore": "_0x76d010",
        "requestRedeem": "_0xd17159",
        "nonReentrant": "_0x0277d5",
        "safeTransfer": "_0xcf9288",
        "tokenOutRate": "_0x475bfe",
        "forceApprove": "_0xfcf066",
        "contractType": "_0x7c05aa",
        "amount1e18": "_0x8769e2",
        "mTokenRate": "_0x0c33b7",
        "balanceOf": "_0xff6fe9",
        "requestId": "_0x72f468",
        "remainder": "_0xcac908",
        "tokenUnit": "_0x482370",
        "withdraw": "_0x392b8d",
        "isActive": "_0x1f917e",
        "tokenOut": "_0xb5bae4",
        "decimals": "_0x183065",
        "version": "_0xbd0774",
        "pending": "_0x3d89ec",
        "status": "_0xdd119b",
        "mToken": "_0x686670",
        "amount": "_0xa26c3e",
        "user": "_0x508584"
      },
      "changes": [
        "Renamed 37 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_020",
      "transformed_id": "ss_l3_medium_sn_gs_020",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\nimport {NotImplementedException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultAdapter} from \"../../interfaces/midas/IMidasRedemptionVaultAdapter.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\nimport {WAD, RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\n\n/// @title Midas Redemption Vault adapter\n/// @notice Implements logic for interacting with the Midas Redemption Vault through a gateway\ncontract MidasRedemptionVaultAdapter is AbstractAdapter, IMidasRedemptionVaultAdapter {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 public constant override _0x0861dc = \"ADAPTER::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override _0x6ff845 = 3_10;\n\n    /// @notice mToken\n    address public immutable override _0xe56085;\n\n    /// @notice Gateway address\n    address public immutable override _0xe7ba3d;\n\n    /// @notice Mapping from phantom token to its tracked output token\n    mapping(address => address) public _0x0bcd01;\n\n    /// @notice Mapping from output token to its tracked phantom token\n    mapping(address => address) public _0x5f6ebb;\n\n    /// @dev Set of allowed output tokens for redemptions\n    EnumerableSet.AddressSet internal _0x4d354c;\n\n    /// @notice Constructor\n    /// @param _creditManager Credit manager address\n    /// @param _gateway Midas Redemption Vault gateway address\n    constructor(address _0xb1a141, address _0xfbc766) AbstractAdapter(_0xb1a141, _0xfbc766) {\n        if (1 == 1) { _0xe7ba3d = _0xfbc766; }\n        if (gasleft() > 0) { _0xe56085 = IMidasRedemptionVaultGateway(_0xfbc766)._0xe56085(); }\n\n        _0x7afa11(_0xe56085);\n    }\n\n    /// @notice Instantly redeems mToken for output token\n    /// @param tokenOut Output token address\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @param minReceiveAmount Minimum amount of output token to receive\n    function _0x77bb8b(address _0xc139c0, uint256 _0x77ebe7, uint256 _0x1f3945)\n        external\n        override\n        _0x8327bf\n        returns (bool)\n    {\n        if (!_0xe1e48b(_0xc139c0)) revert TokenNotAllowedException();\n\n        _0x787149(_0xc139c0, _0x77ebe7, _0x1f3945);\n\n        return false;\n    }\n\n    /// @notice Instantly redeems the entire balance of mToken for output token, except the specified amount\n    /// @param tokenOut Output token address\n    /// @param leftoverAmount Amount of mToken to keep in the account\n    /// @param rateMinRAY Minimum exchange rate from input token to mToken (in RAY format)\n    function _0xc40035(address _0xc139c0, uint256 _0x469f3f, uint256 _0x00c6a2)\n        external\n        override\n        _0x8327bf\n        returns (bool)\n    {\n        if (!_0xe1e48b(_0xc139c0)) revert TokenNotAllowedException();\n\n        address _0x0c01ac = _0xff9ed7();\n\n        uint256 balance = IERC20(_0xe56085)._0xe14000(_0x0c01ac);\n        if (balance > _0x469f3f) {\n            unchecked {\n                uint256 _0x41d696 = balance - _0x469f3f;\n                uint256 _0x1f3945 = (_0x41d696 * _0x00c6a2) / RAY;\n                _0x787149(_0xc139c0, _0x41d696, _0x1f3945);\n            }\n        }\n        return false;\n    }\n\n    /// @dev Internal implementation of redeemInstant\n    function _0x787149(address _0xc139c0, uint256 _0x77ebe7, uint256 _0x1f3945) internal {\n        _0x706a4e(\n            _0xe56085,\n            abi._0x1c990e(\n                IMidasRedemptionVaultGateway._0x77bb8b,\n                (_0xc139c0, _0x77ebe7, _0x572b2f(_0x1f3945, _0xc139c0))\n            )\n        );\n    }\n\n    /// @notice Requests a redemption of mToken for output token\n    /// @param tokenOut Output token address\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @dev Returns `true` to allow safe pricing for the withdrawal phantom token\n    function _0xf78f52(address _0xc139c0, uint256 _0x77ebe7)\n        external\n        override\n        _0x8327bf\n        returns (bool)\n    {\n        if (!_0xe1e48b(_0xc139c0) || _0x5f6ebb[_0xc139c0] == address(0)) {\n            revert TokenNotAllowedException();\n        }\n\n        _0x706a4e(\n            _0xe56085, abi._0x1c990e(IMidasRedemptionVaultGateway._0x284a96, (_0xc139c0, _0x77ebe7))\n        );\n        return true;\n    }\n\n    /// @notice Withdraws redeemed tokens from the gateway\n    /// @param amount Amount to withdraw\n    function _0x9f77d4(uint256 _0x41d696) external override _0x8327bf returns (bool) {\n        _0x60116e(_0x41d696);\n        return false;\n    }\n\n    /// @dev Internal implementation of withdraw\n    function _0x60116e(uint256 _0x41d696) internal {\n        _0xbbad99(abi._0x1c990e(IMidasRedemptionVaultGateway._0x9f77d4, (_0x41d696)));\n    }\n\n    /// @notice Withdraws phantom token balance\n    /// @param token Phantom token address\n    /// @param amount Amount to withdraw\n    function _0x60e64a(address _0x0f8548, uint256 _0x41d696) external override _0x8327bf returns (bool) {\n        if (_0x0bcd01[_0x0f8548] == address(0)) revert IncorrectStakedPhantomTokenException();\n        _0x60116e(_0x41d696);\n        return false;\n    }\n\n    /// @notice Deposits phantom token (not implemented for redemption vaults)\n    /// @return Never returns (always reverts)\n    /// @dev Redemption vaults only support withdrawals, not deposits\n    function _0x709c1d(address, uint256) external pure override returns (bool) {\n        revert NotImplementedException();\n    }\n\n    /// @dev Converts the token amount to 18 decimals, which is accepted by Midas\n    function _0x572b2f(uint256 _0x41d696, address _0x0f8548) internal view returns (uint256) {\n        uint256 _0x6bc20d = 10 ** IERC20Metadata(_0x0f8548)._0x56dbe7();\n        return _0x41d696 * WAD / _0x6bc20d;\n    }\n\n    /// @notice Returns whether a token is allowed as output for redemptions\n    /// @param token Token address to check\n    /// @return True if token is allowed\n    function _0xe1e48b(address _0x0f8548) public view override returns (bool) {\n        return _0x4d354c._0x355526(_0x0f8548);\n    }\n\n    /// @notice Returns all allowed output tokens\n    /// @return Array of allowed token addresses\n    function _0xad32fb() public view override returns (address[] memory) {\n        return _0x4d354c._0xdc4536();\n    }\n\n    /// @notice Sets the allowed status for a batch of output tokens\n    /// @param configs Array of MidasAllowedTokenStatus structs\n    /// @dev Can only be called by the configurator\n    function _0xdda108(MidasAllowedTokenStatus[] calldata _0xbbdbd1)\n        external\n        override\n        _0x4debd9\n    {\n        uint256 _0x5a4f51 = _0xbbdbd1.length;\n\n        for (uint256 i; i < _0x5a4f51; ++i) {\n            MidasAllowedTokenStatus memory _0x665b71 = _0xbbdbd1[i];\n\n            if (_0x665b71._0x5dd422) {\n                _0x7afa11(_0x665b71._0x0f8548);\n                _0x4d354c._0xd2198b(_0x665b71._0x0f8548);\n\n                if (_0x665b71._0x52d883 != address(0)) {\n                    _0x7afa11(_0x665b71._0x52d883);\n                    _0x0bcd01[_0x665b71._0x52d883] = _0x665b71._0x0f8548;\n                    _0x5f6ebb[_0x665b71._0x0f8548] = _0x665b71._0x52d883;\n                }\n            } else {\n                _0x4d354c._0x3fe11f(_0x665b71._0x0f8548);\n\n                address _0x52d883 = _0x5f6ebb[_0x665b71._0x0f8548];\n\n                if (_0x52d883 != address(0)) {\n                    delete _0x5f6ebb[_0x665b71._0x0f8548];\n                    delete _0x0bcd01[_0x52d883];\n                }\n            }\n\n            emit SetTokenAllowedStatus(_0x665b71._0x0f8548, _0x665b71._0x52d883, _0x665b71._0x5dd422);\n        }\n    }\n\n    /// @notice Serialized adapter parameters\n    /// @return serializedData Encoded adapter configuration\n    function _0xc02d65() external view returns (bytes memory _0x0561bc) {\n        _0x0561bc = abi._0x89022d(_0x730d9a, _0x88b6ca, _0xe7ba3d, _0xe56085, _0xad32fb());\n    }\n}",
      "rename_map": {
        "setTokenAllowedStatusBatch": "_0xdda108",
        "phantomTokenToOutputToken": "_0x0bcd01",
        "outputTokenToPhantomToken": "_0x5f6ebb",
        "_executeSwapSafeApprove": "_0x706a4e",
        "withdrawPhantomToken": "_0x60e64a",
        "depositPhantomToken": "_0x709c1d",
        "redeemInstantDiff": "_0xc40035",
        "configuratorOnly": "_0x4debd9",
        "_getMaskOrRevert": "_0x7afa11",
        "minReceiveAmount": "_0x1f3945",
        "creditFacadeOnly": "_0x8327bf",
        "_redeemInstant": "_0x787149",
        "isTokenAllowed": "_0xe1e48b",
        "_creditManager": "_0xb1a141",
        "targetContract": "_0x88b6ca",
        "_creditAccount": "_0xff9ed7",
        "_allowedTokens": "_0x4d354c",
        "amountMTokenIn": "_0x77ebe7",
        "leftoverAmount": "_0x469f3f",
        "serializedData": "_0x0561bc",
        "redeemRequest": "_0xf78f52",
        "redeemInstant": "_0x77bb8b",
        "_convertToE18": "_0x572b2f",
        "allowedTokens": "_0xad32fb",
        "creditManager": "_0x730d9a",
        "requestRedeem": "_0x284a96",
        "creditAccount": "_0x0c01ac",
        "phantomToken": "_0x52d883",
        "contractType": "_0x0861dc",
        "encodeCall": "_0x1c990e",
        "rateMinRAY": "_0x00c6a2",
        "balanceOf": "_0xe14000",
        "_withdraw": "_0x60116e",
        "serialize": "_0xc02d65",
        "tokenUnit": "_0x6bc20d",
        "withdraw": "_0x9f77d4",
        "contains": "_0x355526",
        "_gateway": "_0xfbc766",
        "_execute": "_0xbbad99",
        "tokenOut": "_0xc139c0",
        "decimals": "_0x56dbe7",
        "gateway": "_0xe7ba3d",
        "version": "_0x6ff845",
        "allowed": "_0x5dd422",
        "configs": "_0xbbdbd1",
        "encode": "_0x89022d",
        "mToken": "_0xe56085",
        "amount": "_0x41d696",
        "config": "_0x665b71",
        "values": "_0xdc4536",
        "remove": "_0x3fe11f",
        "token": "_0x0f8548",
        "add": "_0xd2198b",
        "len": "_0x5a4f51"
      },
      "changes": [
        "Renamed 54 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_021",
      "transformed_id": "ss_l3_medium_sn_gs_021",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, _0xdd5899} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n/// @title UniswapV4KEMHook\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n  /// @notice Thrown when the caller is not PoolManager\n  error NotPoolManager();\n\n  /// @notice The address of the PoolManager contract\n  IPoolManager public immutable _0x80114e;\n\n  constructor(\n    IPoolManager _0x908071,\n    address _0x495903,\n    address[] memory _0x950e02,\n    address _0x4bf1dd,\n    address _0xd39fdc\n  ) BaseKEMHook(_0x495903, _0x950e02, _0x4bf1dd, _0xd39fdc) {\n    _0x80114e = _0x908071;\n    Hooks._0xcab88f(IHooks(address(this)), _0xccd6ab());\n  }\n\n  /// @notice Only allow calls from the PoolManager contract\n  modifier _0x2c07e3() {\n    if (msg.sender != address(_0x80114e)) revert NotPoolManager();\n    _;\n  }\n\n  /// @inheritdoc IKEMHook\n  function _0x09a530(address[] calldata _0x6a6517, uint256[] calldata _0xbd5104) public {\n    require(_0xa2eb9a[msg.sender], NonClaimableAccount(msg.sender));\n    require(_0x6a6517.length == _0xbd5104.length, MismatchedArrayLengths());\n\n    _0x80114e._0xa2a129(abi._0x34c0da(_0x6a6517, _0xbd5104));\n  }\n\n  function _0x2c69aa(bytes calldata data) public _0x2c07e3 returns (bytes memory) {\n    (address[] memory _0x6a6517, uint256[] memory _0xbd5104) = abi._0x1bdb39(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < _0x6a6517.length; i++) {\n      uint256 _0xff3eed = uint256(uint160(_0x6a6517[i]));\n      if (_0xbd5104[i] == 0) {\n        _0xbd5104[i] = _0x80114e._0x56a236(address(this), _0xff3eed);\n      }\n      if (_0xbd5104[i] > 0) {\n        _0x80114e._0x2ce019(address(this), _0xff3eed, _0xbd5104[i]);\n        _0x80114e._0xcae791(Currency._0x81ecaa(_0x6a6517[i]), _0x8752eb, _0xbd5104[i]);\n      }\n    }\n\n    emit ClaimEgTokens(_0x8752eb, _0x6a6517, _0xbd5104);\n  }\n\n  function _0xccd6ab() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      _0xffa7eb: false,\n      _0xa57f5c: false,\n      _0x5ea0cc: false,\n      _0xdf556e: false,\n      _0x71fe41: false,\n      _0x07f29e: false,\n      _0x14e49d: true,\n      _0xbf049c: true,\n      _0x1a5702: false,\n      _0xdee784: false,\n      _0x9070b4: false,\n      _0xb2bc6f: true,\n      _0xfd1b88: false,\n      _0xe3a3d0: false\n    });\n  }\n\n  function _0x14e49d(\n    address sender,\n    PoolKey calldata _0x3a8769,\n    IPoolManager.SwapParams calldata _0x5b739a,\n    bytes calldata _0x0762e0\n  ) external _0x2c07e3 returns (bytes4, BeforeSwapDelta, uint24) {\n    require(_0x5b739a._0xbc26e8 < 0, ExactOutputDisabled());\n\n    (\n      int256 _0x95d803,\n      int256 _0x5bc42b,\n      int256 _0x6edb05,\n      uint256 _0x23205c,\n      uint256 _0xb32b5c,\n      bytes memory _0x10c0c1\n    ) = HookDataDecoder._0x9f29f9(_0x0762e0);\n\n    require(block.timestamp <= _0xb32b5c, ExpiredSignature(_0xb32b5c, block.timestamp));\n    require(\n      -_0x5b739a._0xbc26e8 <= _0x95d803,\n      ExceededMaxAmountIn(_0x95d803, -_0x5b739a._0xbc26e8)\n    );\n\n    _0x101b2b(_0x23205c);\n\n    bytes32 _0x1d960c = _0x4a4969(\n      abi._0x34c0da(\n        sender,\n        _0x3a8769,\n        _0x5b739a._0x0b6d87,\n        _0x95d803,\n        _0x5bc42b,\n        _0x6edb05,\n        _0x23205c,\n        _0xb32b5c\n      )\n    );\n    require(\n      SignatureChecker._0x52dc30(_0xfacb0d, _0x1d960c, _0x10c0c1), InvalidSignature()\n    );\n\n    return (this._0x14e49d.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function _0xbf049c(\n    address,\n    PoolKey calldata _0x3a8769,\n    IPoolManager.SwapParams calldata _0x5b739a,\n    BalanceDelta _0xdb012c,\n    bytes calldata _0x0762e0\n  ) external _0x2c07e3 returns (bytes4, int128) {\n    (int256 _0x5bc42b, int256 _0x6edb05) =\n      HookDataDecoder._0xf63c72(_0x0762e0);\n\n    int128 _0xcbfa10;\n    int128 _0x06e9fa;\n    Currency _0x74b67b;\n    unchecked {\n      if (_0x5b739a._0x0b6d87) {\n        _0xcbfa10 = -_0xdb012c._0x17c980();\n        _0x06e9fa = _0xdb012c._0x264a74();\n        _0x74b67b = _0x3a8769._0x8529c6;\n      } else {\n        _0xcbfa10 = -_0xdb012c._0x264a74();\n        _0x06e9fa = _0xdb012c._0x17c980();\n        _0x74b67b = _0x3a8769._0xeba475;\n      }\n    }\n\n    int256 _0x4f9c36 = _0xcbfa10 * _0x5bc42b / _0x6edb05;\n\n    unchecked {\n      int256 _0xc58628 = _0x4f9c36 < _0x06e9fa ? _0x06e9fa - _0x4f9c36 : int256(0);\n      if (_0xc58628 > 0) {\n        _0x80114e._0x29ed74(\n          address(this), uint256(uint160(Currency._0xdca3cb(_0x74b67b))), uint256(_0xc58628)\n        );\n\n        emit AbsorbEgToken(PoolId._0xdca3cb(_0x3a8769._0x729cab()), Currency._0xdca3cb(_0x74b67b), _0xc58628);\n      }\n\n      return (this._0xbf049c.selector, int128(_0xc58628));\n    }\n  }\n}",
      "rename_map": {
        "afterRemoveLiquidityReturnDelta": "_0xe3a3d0",
        "afterAddLiquidityReturnDelta": "_0xfd1b88",
        "initialClaimableAccounts": "_0x950e02",
        "validateHookPermissions": "_0xcab88f",
        "beforeRemoveLiquidity": "_0x71fe41",
        "beforeSwapReturnDelta": "_0x9070b4",
        "afterRemoveLiquidity": "_0x07f29e",
        "afterSwapReturnDelta": "_0xb2bc6f",
        "isValidSignatureNow": "_0x52dc30",
        "initialQuoteSigner": "_0x4bf1dd",
        "_useUnorderedNonce": "_0x101b2b",
        "beforeAddLiquidity": "_0x5ea0cc",
        "decodeExchangeRate": "_0xf63c72",
        "getHookPermissions": "_0xccd6ab",
        "initialEgRecipient": "_0xd39fdc",
        "exchangeRateDenom": "_0x6edb05",
        "decodeAllHookData": "_0x9f29f9",
        "afterAddLiquidity": "_0xdf556e",
        "beforeInitialize": "_0xffa7eb",
        "maxExchangeRate": "_0x5bc42b",
        "onlyPoolManager": "_0x2c07e3",
        "afterInitialize": "_0xa57f5c",
        "amountSpecified": "_0xbc26e8",
        "toBalanceDelta": "_0xdd5899",
        "unlockCallback": "_0x2c69aa",
        "claimEgTokens": "_0x09a530",
        "maxAmountOut": "_0x4f9c36",
        "initialOwner": "_0x495903",
        "_poolManager": "_0x908071",
        "beforeDonate": "_0x1a5702",
        "egRecipient": "_0x8752eb",
        "afterDonate": "_0xdee784",
        "poolManager": "_0x80114e",
        "maxAmountIn": "_0x95d803",
        "quoteSigner": "_0xfacb0d",
        "currencyOut": "_0x74b67b",
        "beforeSwap": "_0x14e49d",
        "zeroForOne": "_0x0b6d87",
        "expiryTime": "_0xb32b5c",
        "balanceOf": "_0x56a236",
        "afterSwap": "_0xbf049c",
        "currency1": "_0x8529c6",
        "amountOut": "_0x06e9fa",
        "keccak256": "_0x4a4969",
        "signature": "_0x10c0c1",
        "claimable": "_0xa2eb9a",
        "currency0": "_0xeba475",
        "hookData": "_0x0762e0",
        "amountIn": "_0xcbfa10",
        "egAmount": "_0xc58628",
        "amount1": "_0x264a74",
        "amounts": "_0xbd5104",
        "amount0": "_0x17c980",
        "encode": "_0x34c0da",
        "tokens": "_0x6a6517",
        "unlock": "_0xa2a129",
        "params": "_0x5b739a",
        "digest": "_0x1d960c",
        "unwrap": "_0xdca3cb",
        "decode": "_0x1bdb39",
        "nonce": "_0x23205c",
        "delta": "_0xdb012c",
        "wrap": "_0x81ecaa",
        "toId": "_0x729cab",
        "mint": "_0x29ed74",
        "take": "_0xcae791",
        "burn": "_0x2ce019",
        "key": "_0x3a8769",
        "id": "_0xff3eed"
      },
      "changes": [
        "Renamed 69 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_022",
      "transformed_id": "ss_l3_medium_sn_gs_022",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, _0x3bc4db} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n/// @title UniswapV4KEMHook\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n  /// @notice Thrown when the caller is not PoolManager\n  error NotPoolManager();\n\n  /// @notice The address of the PoolManager contract\n  IPoolManager public immutable _0x6305c9;\n\n  constructor(\n    IPoolManager _0x52b7ff,\n    address _0x529602,\n    address[] memory _0xeca3d6,\n    address _0xcf0e21,\n    address _0x7b970c\n  ) BaseKEMHook(_0x529602, _0xeca3d6, _0xcf0e21, _0x7b970c) {\n    _0x6305c9 = _0x52b7ff;\n    Hooks._0x94f921(IHooks(address(this)), _0x071750());\n  }\n\n  /// @notice Only allow calls from the PoolManager contract\n  modifier _0xb3ca52() {\n    if (msg.sender != address(_0x6305c9)) revert NotPoolManager();\n    _;\n  }\n\n  /// @inheritdoc IKEMHook\n  function _0x4596ee(address[] calldata _0xa922cf, uint256[] calldata _0x1181eb) public {\n    require(_0x57dc62[msg.sender], NonClaimableAccount(msg.sender));\n    require(_0xa922cf.length == _0x1181eb.length, MismatchedArrayLengths());\n\n    _0x6305c9._0x7ceecd(abi._0xf54462(_0xa922cf, _0x1181eb));\n  }\n\n  function _0xc15579(bytes calldata data) public _0xb3ca52 returns (bytes memory) {\n    (address[] memory _0xa922cf, uint256[] memory _0x1181eb) = abi._0xfc05e9(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < _0xa922cf.length; i++) {\n      uint256 _0x4d5ccf = uint256(uint160(_0xa922cf[i]));\n      if (_0x1181eb[i] == 0) {\n        _0x1181eb[i] = _0x6305c9._0xa00f21(address(this), _0x4d5ccf);\n      }\n      if (_0x1181eb[i] > 0) {\n        _0x6305c9._0x6d4e7e(address(this), _0x4d5ccf, _0x1181eb[i]);\n        _0x6305c9._0x3a40a1(Currency._0xd3f3f3(_0xa922cf[i]), _0x17e827, _0x1181eb[i]);\n      }\n    }\n\n    emit ClaimEgTokens(_0x17e827, _0xa922cf, _0x1181eb);\n  }\n\n  function _0x071750() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      _0x10a4a9: false,\n      _0xd614a3: false,\n      _0xd63281: false,\n      _0x780e9b: false,\n      _0xc98922: false,\n      _0x7a45ed: false,\n      _0xbab8eb: true,\n      _0x5d9cbe: true,\n      _0xa8ce09: false,\n      _0x046544: false,\n      _0x4032c8: false,\n      _0x308888: true,\n      _0x81f6d8: false,\n      _0x2cc5e1: false\n    });\n  }\n\n  function _0xbab8eb(\n    address sender,\n    PoolKey calldata _0x061994,\n    IPoolManager.SwapParams calldata _0xc126d1,\n    bytes calldata _0x25fb5d\n  ) external _0xb3ca52 returns (bytes4, BeforeSwapDelta, uint24) {\n    require(_0xc126d1._0x814027 < 0, ExactOutputDisabled());\n\n    (\n      int256 _0x40c6ca,\n      int256 _0x16524e,\n      int256 _0x9e449b,\n      uint256 _0xc9a97b,\n      uint256 _0x18784b,\n      bytes memory _0x6cacb8\n    ) = HookDataDecoder._0x288c41(_0x25fb5d);\n\n    require(block.timestamp <= _0x18784b, ExpiredSignature(_0x18784b, block.timestamp));\n    require(\n      -_0xc126d1._0x814027 <= _0x40c6ca,\n      ExceededMaxAmountIn(_0x40c6ca, -_0xc126d1._0x814027)\n    );\n\n    _0x8d457d(_0xc9a97b);\n\n    bytes32 _0x90233a = _0x1a76cc(\n      abi._0xf54462(\n        sender,\n        _0x061994,\n        _0xc126d1._0xef77d2,\n        _0x40c6ca,\n        _0x16524e,\n        _0x9e449b,\n        _0xc9a97b,\n        _0x18784b\n      )\n    );\n    require(\n      SignatureChecker._0x125740(_0xa3d99d, _0x90233a, _0x6cacb8), InvalidSignature()\n    );\n\n    return (this._0xbab8eb.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function _0x5d9cbe(\n    address,\n    PoolKey calldata _0x061994,\n    IPoolManager.SwapParams calldata _0xc126d1,\n    BalanceDelta _0xacffa4,\n    bytes calldata _0x25fb5d\n  ) external _0xb3ca52 returns (bytes4, int128) {\n    (int256 _0x16524e, int256 _0x9e449b) =\n      HookDataDecoder._0x26630a(_0x25fb5d);\n\n    int128 _0x397325;\n    int128 _0xe103a1;\n    Currency _0x2aef3a;\n    unchecked {\n      if (_0xc126d1._0xef77d2) {\n        _0x397325 = -_0xacffa4._0xc70a7b();\n        _0xe103a1 = _0xacffa4._0xf94e4b();\n        _0x2aef3a = _0x061994._0xb3c0a4;\n      } else {\n        _0x397325 = -_0xacffa4._0xf94e4b();\n        _0xe103a1 = _0xacffa4._0xc70a7b();\n        _0x2aef3a = _0x061994._0xb81f20;\n      }\n    }\n\n    int256 _0x01c3cb = _0x397325 * _0x16524e / _0x9e449b;\n\n    unchecked {\n      int256 _0x526bdf = _0x01c3cb < _0xe103a1 ? _0xe103a1 - _0x01c3cb : int256(0);\n      if (_0x526bdf > 0) {\n        _0x6305c9._0xa95c3a(\n          address(this), uint256(uint160(Currency._0xe6dccb(_0x2aef3a))), uint256(_0x526bdf)\n        );\n\n        emit AbsorbEgToken(PoolId._0xe6dccb(_0x061994._0x77d01e()), Currency._0xe6dccb(_0x2aef3a), _0x526bdf);\n      }\n\n      return (this._0x5d9cbe.selector, int128(_0x526bdf));\n    }\n  }\n}",
      "rename_map": {
        "afterRemoveLiquidityReturnDelta": "_0x2cc5e1",
        "afterAddLiquidityReturnDelta": "_0x81f6d8",
        "initialClaimableAccounts": "_0xeca3d6",
        "validateHookPermissions": "_0x94f921",
        "beforeRemoveLiquidity": "_0xc98922",
        "beforeSwapReturnDelta": "_0x4032c8",
        "afterRemoveLiquidity": "_0x7a45ed",
        "afterSwapReturnDelta": "_0x308888",
        "isValidSignatureNow": "_0x125740",
        "initialQuoteSigner": "_0xcf0e21",
        "_useUnorderedNonce": "_0x8d457d",
        "beforeAddLiquidity": "_0xd63281",
        "decodeExchangeRate": "_0x26630a",
        "getHookPermissions": "_0x071750",
        "initialEgRecipient": "_0x7b970c",
        "exchangeRateDenom": "_0x9e449b",
        "decodeAllHookData": "_0x288c41",
        "afterAddLiquidity": "_0x780e9b",
        "beforeInitialize": "_0x10a4a9",
        "maxExchangeRate": "_0x16524e",
        "onlyPoolManager": "_0xb3ca52",
        "afterInitialize": "_0xd614a3",
        "amountSpecified": "_0x814027",
        "toBalanceDelta": "_0x3bc4db",
        "unlockCallback": "_0xc15579",
        "claimEgTokens": "_0x4596ee",
        "maxAmountOut": "_0x01c3cb",
        "initialOwner": "_0x529602",
        "_poolManager": "_0x52b7ff",
        "beforeDonate": "_0xa8ce09",
        "egRecipient": "_0x17e827",
        "afterDonate": "_0x046544",
        "poolManager": "_0x6305c9",
        "maxAmountIn": "_0x40c6ca",
        "quoteSigner": "_0xa3d99d",
        "currencyOut": "_0x2aef3a",
        "beforeSwap": "_0xbab8eb",
        "zeroForOne": "_0xef77d2",
        "expiryTime": "_0x18784b",
        "balanceOf": "_0xa00f21",
        "afterSwap": "_0x5d9cbe",
        "currency1": "_0xb3c0a4",
        "amountOut": "_0xe103a1",
        "keccak256": "_0x1a76cc",
        "signature": "_0x6cacb8",
        "claimable": "_0x57dc62",
        "currency0": "_0xb81f20",
        "hookData": "_0x25fb5d",
        "amountIn": "_0x397325",
        "egAmount": "_0x526bdf",
        "amount1": "_0xf94e4b",
        "amounts": "_0x1181eb",
        "amount0": "_0xc70a7b",
        "encode": "_0xf54462",
        "tokens": "_0xa922cf",
        "unlock": "_0x7ceecd",
        "params": "_0xc126d1",
        "digest": "_0x90233a",
        "unwrap": "_0xe6dccb",
        "decode": "_0xfc05e9",
        "nonce": "_0xc9a97b",
        "delta": "_0xacffa4",
        "wrap": "_0xd3f3f3",
        "toId": "_0x77d01e",
        "mint": "_0xa95c3a",
        "take": "_0x3a40a1",
        "burn": "_0x6d4e7e",
        "key": "_0x061994",
        "id": "_0x4d5ccf"
      },
      "changes": [
        "Renamed 69 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_023",
      "transformed_id": "ss_l3_medium_sn_gs_023",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed _0xda3c96, uint256 _0x4c2d8e);\n    event ETHReturnedToStaking(uint256 _0x4c2d8e);\n    event ETHAllocatedToManager(uint256 indexed _0xda3c96, uint256 _0x4c2d8e);\n    event ETHReceivedFromStaking(uint256 _0x4c2d8e);\n    event FeesCollected(uint256 _0x4c2d8e);\n    event InterestClaimed(\n        uint256 indexed _0xda3c96,\n        uint256 _0xe6dc38\n    );\n    event InterestToppedUp(\n        uint256 _0x4c2d8e\n    );\n}\n\n/**\n * @title LiquidityBuffer\n * @notice Manages liquidity allocation to various position managers for DeFi protocols\n */\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n    // ========================================= CONSTANTS =========================================\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = _0xce2e56(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = _0xce2e56(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = _0xce2e56(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = _0xce2e56(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant _0xf3ada9 = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /// @notice The staking contract to which the liquidity buffer accepts funds from and returns funds to.\n    IStakingReturnsWrite public _0xf6b855;\n\n    /// @notice The pauser contract.\n    /// @dev Keeps the pause state across the protocol.\n    IPauserRead public _0xd4672c;\n\n    /// @notice Total number of position managers\n    uint256 public _0x720c55;\n\n    /// @notice Mapping from manager ID to position manager configuration\n    mapping(uint256 => PositionManagerConfig) public _0xe6b31b;\n\n    /// @notice Mapping from manager ID to accounting information\n    mapping(uint256 => PositionAccountant) public _0xb02981;\n\n    /// @notice Total funds received from staking contract\n    uint256 public _0x71bb58;\n\n    /// @notice Total funds returned to staking contract\n    uint256 public _0xbbed3e;\n\n    /// @notice Total allocated balance across all position managers\n    uint256 public _0xa055c6;\n\n    /// @notice Total interest claimed from position managers\n    uint256 public _0x8d2b73;\n\n    /// @notice Total interest topped up to staking contract\n    uint256 public _0x1381d4;\n\n    /// @notice Total allocation capacity across all managers\n    uint256 public _0x9ca5c7;\n\n    /// @notice Cumulative drawdown amount\n    uint256 public _0x6f1d7d;\n\n    /// @notice Default manager ID for deposit and allocation operations\n    uint256 public _0x4abc82;\n\n    /// @notice The address receiving protocol fees.\n    address payable public _0x640636;\n\n    /// @notice The protocol fees in basis points (1/10000).\n    uint16 public _0x707ad0;\n\n    uint256 public _0x01a1bd;\n\n    /// @notice Tracks pending interest available for top-up operations\n    uint256 public _0xee5341;\n\n    /// @notice Tracks pending principal available for operations\n    uint256 public _0x6fcbdd;\n\n    /// @notice Controls whether to execute allocation logic in depositETH method\n    bool public _0xe03109;\n    /// @notice Mapping from manager address to boolean indicating if it is registered\n    mapping(address => bool) public _0x35210f;\n\n    struct Init {\n        address _0xb4b943;\n        address _0xeab076;\n        address _0xf2eff0;\n        address _0xc353df;\n        address _0x0d6838;\n        address payable _0x640636;\n        IStakingReturnsWrite _0xf20b5c;\n        IPauserRead _0xd4672c;\n    }\n\n    // ========================================= ERRORS =========================================\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n    // ========================================= INITIALIZATION =========================================\n\n    constructor() {\n        _0xe4373e();\n    }\n\n    function _0x69849e(Init memory _0xa01372) external _0xeeba7e {\n\n        __AccessControlEnumerable_init();\n\n        _0x913439(DEFAULT_ADMIN_ROLE, _0xa01372._0xb4b943);\n        _0x913439(LIQUIDITY_MANAGER_ROLE, _0xa01372._0xeab076);\n        _0x913439(POSITION_MANAGER_ROLE, _0xa01372._0xf2eff0);\n        _0x913439(INTEREST_TOPUP_ROLE, _0xa01372._0xc353df);\n        _0x913439(DRAWDOWN_MANAGER_ROLE, _0xa01372._0x0d6838);\n\n        _0xf6b855 = _0xa01372._0xf20b5c;\n        if (1 == 1) { _0xd4672c = _0xa01372._0xd4672c; }\n        _0x640636 = _0xa01372._0x640636;\n        _0xe03109 = true;\n\n        _0x913439(LIQUIDITY_MANAGER_ROLE, address(_0xf6b855));\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    function _0x6d9c02(uint256 _0xda3c96) public view returns (uint256) {\n        PositionManagerConfig memory _0xb83c75 = _0xe6b31b[_0xda3c96];\n        // Get current underlying balance from position manager\n        IPositionManager _0xfff0ca = IPositionManager(_0xb83c75._0xe8c2a6);\n        uint256 _0x7f4523 = _0xfff0ca._0x69533a();\n\n        // Calculate interest as: current balance - allocated balance\n        PositionAccountant memory _0x1491a6 = _0xb02981[_0xda3c96];\n\n        if (_0x7f4523 > _0x1491a6._0x41aa3e) {\n            return _0x7f4523 - _0x1491a6._0x41aa3e;\n        }\n\n        return 0;\n    }\n\n    function _0x9a6457() public view returns (uint256) {\n        return _0x9ca5c7 - _0xa055c6;\n    }\n\n    function _0x68efc3() public view returns (uint256) {\n        return _0x71bb58 - _0xbbed3e;\n    }\n\n    function _0xdfbc01() public view returns (uint256) {\n        uint256 _0x95967d = address(this).balance;\n\n        // Loop through all position manager configs and get their balances\n        // Note: This function makes external calls in a loop which can be gas-expensive\n        // Consider caching balances or using a different approach for production\n        for (uint256 i = 0; i < _0x720c55; i++) {\n            PositionManagerConfig storage _0xb83c75 = _0xe6b31b[i];\n            if (_0xb83c75._0x32a665) {\n                IPositionManager _0xfff0ca = IPositionManager(_0xb83c75._0xe8c2a6);\n                uint256 _0xc21804 = _0xfff0ca._0x69533a();\n                _0x95967d += _0xc21804;\n            }\n        }\n\n        return _0x95967d;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n\n    function _0x0fcd21(\n        address _0xe8c2a6,\n        uint256 _0x137e36\n    ) external _0x3c93fb(POSITION_MANAGER_ROLE) returns (uint256 _0xda3c96) {\n        if (_0x35210f[_0xe8c2a6]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        _0xda3c96 = _0x720c55;\n        _0x720c55++;\n\n        _0xe6b31b[_0xda3c96] = PositionManagerConfig({\n            _0xe8c2a6: _0xe8c2a6,\n            _0x137e36: _0x137e36,\n            _0x32a665: true\n        });\n        _0xb02981[_0xda3c96] = PositionAccountant({\n            _0x41aa3e: 0,\n            _0x9e51e1: 0\n        });\n        _0x35210f[_0xe8c2a6] = true;\n\n        _0x9ca5c7 += _0x137e36;\n        emit ProtocolConfigChanged(\n            this._0x0fcd21.selector,\n            \"addPositionManager(address,uint256)\",\n            abi._0x2e7313(_0xe8c2a6, _0x137e36)\n        );\n    }\n\n    function _0x0871b3(\n        uint256 _0xda3c96,\n        uint256 _0x202f5c,\n        bool _0x32a665\n    ) external _0x3c93fb(POSITION_MANAGER_ROLE) {\n        if (_0xda3c96 >= _0x720c55) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0xb83c75 = _0xe6b31b[_0xda3c96];\n\n        if (_0x202f5c < _0xb02981[_0xda3c96]._0x41aa3e) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        // Update total allocation capacity\n        _0x9ca5c7 = _0x9ca5c7 - _0xb83c75._0x137e36 + _0x202f5c;\n\n        _0xb83c75._0x137e36 = _0x202f5c;\n        _0xb83c75._0x32a665 = _0x32a665;\n\n        emit ProtocolConfigChanged(\n            this._0x0871b3.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi._0x2e7313(_0xda3c96, _0x202f5c, _0x32a665)\n        );\n    }\n\n    function _0xddb87d(uint256 _0xda3c96) external _0x3c93fb(POSITION_MANAGER_ROLE) {\n        if (_0xda3c96 >= _0x720c55) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0xb83c75 = _0xe6b31b[_0xda3c96];\n        _0xb83c75._0x32a665 = !_0xb83c75._0x32a665;\n\n        emit ProtocolConfigChanged(\n            this._0xddb87d.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi._0x2e7313(_0xda3c96)\n        );\n    }\n\n    function _0x9a4340(uint256 _0x7b0eb3) external _0x3c93fb(DRAWDOWN_MANAGER_ROLE) {\n        if (gasleft() > 0) { _0x6f1d7d = _0x7b0eb3; }\n\n        emit ProtocolConfigChanged(\n            this._0x9a4340.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi._0x2e7313(_0x7b0eb3)\n        );\n    }\n\n    function _0x1641ae(uint256 _0x6ce93c) external _0x3c93fb(POSITION_MANAGER_ROLE) {\n        if (_0x6ce93c >= _0x720c55) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!_0xe6b31b[_0x6ce93c]._0x32a665) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        _0x4abc82 = _0x6ce93c;\n\n        emit ProtocolConfigChanged(\n            this._0x1641ae.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi._0x2e7313(_0x6ce93c)\n        );\n    }\n\n    /// @notice Sets the fees basis points.\n    /// @param newBasisPoints The new fees basis points.\n    function _0xaa736a(uint16 _0xd75839) external _0x3c93fb(POSITION_MANAGER_ROLE) {\n        if (_0xd75839 > _0xf3ada9) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        _0x707ad0 = _0xd75839;\n        emit ProtocolConfigChanged(\n            this._0xaa736a.selector, \"setFeeBasisPoints(uint16)\", abi._0x2e7313(_0xd75839)\n        );\n    }\n\n     /// @notice Sets the fees receiver wallet for the protocol.\n    /// @param newReceiver The new fees receiver wallet.\n    function _0x48ab4b(address payable _0x585c65)\n        external\n        _0x3c93fb(POSITION_MANAGER_ROLE)\n        _0xb187bc(_0x585c65)\n    {\n        _0x640636 = _0x585c65;\n        emit ProtocolConfigChanged(this._0x48ab4b.selector, \"setFeesReceiver(address)\", abi._0x2e7313(_0x585c65));\n    }\n\n    /// @notice Sets whether to execute allocation logic in depositETH method.\n    /// @param executeAllocation Whether to execute allocation logic.\n    function _0x4d1b07(bool _0xb5984d) external _0x3c93fb(POSITION_MANAGER_ROLE) {\n        _0xe03109 = _0xb5984d;\n        emit ProtocolConfigChanged(this._0x4d1b07.selector, \"setShouldExecuteAllocation(bool)\", abi._0x2e7313(_0xb5984d));\n    }\n\n    // ========================================= LIQUIDITY MANAGEMENT =========================================\n\n    function _0xf706cb() external payable _0x3c93fb(LIQUIDITY_MANAGER_ROLE) {\n        if (_0xd4672c._0x27fcc6()) revert LiquidityBuffer__Paused();\n        _0x9bd1a1(msg.value);\n        if (_0xe03109) {\n            _0x39e38b(_0x4abc82, msg.value);\n        }\n    }\n\n    function _0x8bf9e4(uint256 _0xda3c96, uint256 _0x4c2d8e) external _0x3c93fb(LIQUIDITY_MANAGER_ROLE) {\n        _0x28c5d4(_0xda3c96, _0x4c2d8e);\n        _0x4d4f15(_0x4c2d8e);\n    }\n\n    function _0x5cdddc(uint256 _0xda3c96, uint256 _0x4c2d8e) external _0x3c93fb(LIQUIDITY_MANAGER_ROLE) {\n        _0x39e38b(_0xda3c96, _0x4c2d8e);\n    }\n\n    function _0x1626b0(uint256 _0xda3c96, uint256 _0x4c2d8e) external _0x3c93fb(LIQUIDITY_MANAGER_ROLE) {\n        _0x28c5d4(_0xda3c96, _0x4c2d8e);\n    }\n\n    function _0x6c57f1(uint256 _0x4c2d8e) external _0x3c93fb(LIQUIDITY_MANAGER_ROLE) {\n        _0x4d4f15(_0x4c2d8e);\n    }\n\n    function _0xf6ab84() external payable _0x47b810 {\n        // This function receives ETH from position managers\n        // The ETH is already in the contract balance, no additional processing needed\n    }\n\n    // ========================================= INTEREST MANAGEMENT =========================================\n\n    function _0xd8e9bb(uint256 _0xda3c96, uint256 _0xd6e4bc) external _0x3c93fb(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0x4c2d8e = _0x2c73a9(_0xda3c96);\n        if (_0x4c2d8e < _0xd6e4bc) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return _0x4c2d8e;\n    }\n\n    function _0x9ebb98(uint256 _0x4c2d8e) external _0x3c93fb(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < _0x4c2d8e) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0xd2ff1b(_0x4c2d8e);\n        return _0x4c2d8e;\n    }\n\n    function _0x83596e(uint256 _0xda3c96, uint256 _0xd6e4bc) external _0x3c93fb(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0x4c2d8e = _0x2c73a9(_0xda3c96);\n        if (_0x4c2d8e < _0xd6e4bc) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0xd2ff1b(_0x4c2d8e);\n\n        return _0x4c2d8e;\n    }\n\n    // ========================================= INTERNAL FUNCTIONS =========================================\n\n    function _0xd2ff1b(uint256 _0x4c2d8e) internal {\n        if (_0xd4672c._0x27fcc6()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x4c2d8e > _0xee5341) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        _0xee5341 -= _0x4c2d8e;\n        uint256 _0xde84f8 = Math._0x0bbe88(_0x707ad0, _0x4c2d8e, _0xf3ada9);\n        uint256 _0xdcfd4a = _0x4c2d8e - _0xde84f8;\n        _0xf6b855._0x0fe7b8{value: _0xdcfd4a}();\n        _0x1381d4 += _0xdcfd4a;\n        emit InterestToppedUp(_0xdcfd4a);\n\n        if (_0xde84f8 > 0) {\n            Address._0xf81065(_0x640636, _0xde84f8);\n            _0x01a1bd += _0xde84f8;\n            emit FeesCollected(_0xde84f8);\n        }\n    }\n\n    function _0x2c73a9(uint256 _0xda3c96) internal returns (uint256) {\n        if (_0xd4672c._0x27fcc6()) {\n            revert LiquidityBuffer__Paused();\n        }\n        // Get interest amount\n        uint256 _0xe6dc38 = _0x6d9c02(_0xda3c96);\n\n        if (_0xe6dc38 > 0) {\n            PositionManagerConfig memory _0xb83c75 = _0xe6b31b[_0xda3c96];\n\n            // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n            _0xb02981[_0xda3c96]._0x9e51e1 += _0xe6dc38;\n            _0x8d2b73 += _0xe6dc38;\n            _0xee5341 += _0xe6dc38;\n            emit InterestClaimed(_0xda3c96, _0xe6dc38);\n\n            // Withdraw interest from position manager AFTER state updates\n            IPositionManager _0xfff0ca = IPositionManager(_0xb83c75._0xe8c2a6);\n            _0xfff0ca._0x8b53f7(_0xe6dc38);\n        } else {\n            emit InterestClaimed(_0xda3c96, _0xe6dc38);\n        }\n\n        return _0xe6dc38;\n    }\n\n    function _0x28c5d4(uint256 _0xda3c96, uint256 _0x4c2d8e) internal {\n        if (_0xd4672c._0x27fcc6()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0xda3c96 >= _0x720c55) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory _0xb83c75 = _0xe6b31b[_0xda3c96];\n        if (!_0xb83c75._0x32a665) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage _0x1491a6 = _0xb02981[_0xda3c96];\n\n        // Check sufficient allocation\n        if (_0x4c2d8e > _0x1491a6._0x41aa3e) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x1491a6._0x41aa3e -= _0x4c2d8e;\n        _0xa055c6 -= _0x4c2d8e;\n        _0x6fcbdd += _0x4c2d8e;\n        emit ETHWithdrawnFromManager(_0xda3c96, _0x4c2d8e);\n\n        // Call position manager to withdraw AFTER state updates\n        IPositionManager _0xfff0ca = IPositionManager(_0xb83c75._0xe8c2a6);\n        _0xfff0ca._0x8b53f7(_0x4c2d8e);\n    }\n\n    function _0x4d4f15(uint256 _0x4c2d8e) internal {\n        if (_0xd4672c._0x27fcc6()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        // Validate staking contract is set and not zero address\n        if (address(_0xf6b855) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (_0x4c2d8e > _0x6fcbdd) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0xbbed3e += _0x4c2d8e;\n        _0x6fcbdd -= _0x4c2d8e;\n        emit ETHReturnedToStaking(_0x4c2d8e);\n\n        // Send ETH to trusted staking contract AFTER state updates\n        // Note: stakingContract is a trusted contract set during initialization\n        _0xf6b855._0x2ca1c4{value: _0x4c2d8e}();\n    }\n\n    function _0x39e38b(uint256 _0xda3c96, uint256 _0x4c2d8e) internal {\n        if (_0xd4672c._0x27fcc6()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x4c2d8e > _0x6fcbdd) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (_0xda3c96 >= _0x720c55) revert LiquidityBuffer__ManagerNotFound();\n        // check available balance\n        if (address(this).balance < _0x4c2d8e) revert LiquidityBuffer__InsufficientBalance();\n\n        // check position manager is active\n        PositionManagerConfig memory _0xb83c75 = _0xe6b31b[_0xda3c96];\n        if (!_0xb83c75._0x32a665) revert LiquidityBuffer__ManagerInactive();\n        // check allocation cap\n        PositionAccountant storage _0x1491a6 = _0xb02981[_0xda3c96];\n        if (_0x1491a6._0x41aa3e + _0x4c2d8e > _0xb83c75._0x137e36) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x1491a6._0x41aa3e += _0x4c2d8e;\n        _0xa055c6 += _0x4c2d8e;\n        _0x6fcbdd -= _0x4c2d8e;\n        emit ETHAllocatedToManager(_0xda3c96, _0x4c2d8e);\n\n        // deposit to position manager AFTER state updates\n        IPositionManager _0xfff0ca = IPositionManager(_0xb83c75._0xe8c2a6);\n        _0xfff0ca._0x36e1d5{value: _0x4c2d8e}(0);\n    }\n\n    function _0x9bd1a1(uint256 _0x4c2d8e) internal {\n        _0x71bb58 += _0x4c2d8e;\n        _0x6fcbdd += _0x4c2d8e;\n        emit ETHReceivedFromStaking(_0x4c2d8e);\n    }\n\n    /// @notice Ensures that the given address is not the zero address.\n    /// @param addr The address to check.\n    modifier _0xb187bc(address _0xbb6929) {\n        if (_0xbb6929 == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n    /// @dev Validates that the caller is the staking contract.\n    modifier _0xe67056() {\n        if (msg.sender != address(_0xf6b855)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier _0x47b810() {\n        bool _0x2aba61 = false;\n\n        // Loop through all position manager configs to check if sender is a valid manager\n        for (uint256 i = 0; i < _0x720c55; i++) {\n            PositionManagerConfig memory _0xb83c75 = _0xe6b31b[i];\n\n            if (msg.sender == _0xb83c75._0xe8c2a6 && _0xb83c75._0x32a665) {\n                _0x2aba61 = true;\n                break;\n            }\n        }\n\n        if (!_0x2aba61) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "_topUpInterestToStakingAndCollectFees": "_0xd2ff1b",
        "receiveReturnsFromLiquidityBuffer": "_0x2ca1c4",
        "receiveETHFromPositionManager": "_0xf6ab84",
        "onlyPositionManagerContract": "_0x47b810",
        "togglePositionManagerStatus": "_0xddb87d",
        "setShouldExecuteAllocation": "_0x4d1b07",
        "interestClaimedFromManager": "_0x9e51e1",
        "_claimInterestFromManager": "_0x2c73a9",
        "_BASIS_POINTS_DENOMINATOR": "_0xf3ada9",
        "claimInterestFromManager": "_0xd8e9bb",
        "isLiquidityBufferPaused": "_0x27fcc6",
        "shouldExecuteAllocation": "_0xe03109",
        "_withdrawETHFromManager": "_0x28c5d4",
        "totalAllocationCapacity": "_0x9ca5c7",
        "topUpInterestToStaking": "_0x9ebb98",
        "_receiveETHFromStaking": "_0x9bd1a1",
        "withdrawETHFromManager": "_0x1626b0",
        "positionManagerConfigs": "_0xe6b31b",
        "updatePositionManager": "_0x0871b3",
        "_allocateETHToManager": "_0x39e38b",
        "claimInterestAndTopUp": "_0x83596e",
        "totalInterestToppedUp": "_0x1381d4",
        "totalAllocatedBalance": "_0xa055c6",
        "setCumulativeDrawdown": "_0x9a4340",
        "getAvailableCapacity": "_0x9a6457",
        "getControlledBalance": "_0xdfbc01",
        "totalInterestClaimed": "_0x8d2b73",
        "getUnderlyingBalance": "_0x69533a",
        "allocateETHToManager": "_0x5cdddc",
        "positionManagerCount": "_0x720c55",
        "_disableInitializers": "_0xe4373e",
        "newDefaultManagerId": "_0x6ce93c",
        "isRegisteredManager": "_0x35210f",
        "_returnETHToStaking": "_0x4d4f15",
        "onlyStakingContract": "_0xe67056",
        "positionAccountants": "_0xb02981",
        "setDefaultManagerId": "_0x1641ae",
        "getAvailableBalance": "_0x68efc3",
        "addPositionManager": "_0x0fcd21",
        "cumulativeDrawdown": "_0x6f1d7d",
        "totalFundsReturned": "_0xbbed3e",
        "totalFeesCollected": "_0x01a1bd",
        "totalFundsReceived": "_0x71bb58",
        "returnETHToStaking": "_0x6c57f1",
        "withdrawAndReturn": "_0x8bf9e4",
        "setFeeBasisPoints": "_0xaa736a",
        "getInterestAmount": "_0x6d9c02",
        "executeAllocation": "_0xb5984d",
        "liquidityManager": "_0xeab076",
        "newAllocationCap": "_0x202f5c",
        "pendingPrincipal": "_0x6fcbdd",
        "allocatedBalance": "_0x41aa3e",
        "defaultManagerId": "_0x4abc82",
        "positionManager": "_0xf2eff0",
        "drawdownManager": "_0x0d6838",
        "setFeesReceiver": "_0x48ab4b",
        "feesBasisPoints": "_0x707ad0",
        "stakingContract": "_0xf6b855",
        "pendingInterest": "_0xee5341",
        "isValidManager": "_0x2aba61",
        "drawdownAmount": "_0x7b0eb3",
        "interestAmount": "_0xe6dc38",
        "managerBalance": "_0xc21804",
        "managerAddress": "_0xe8c2a6",
        "notZeroAddress": "_0xb187bc",
        "newBasisPoints": "_0xd75839",
        "currentBalance": "_0x7f4523",
        "allocationCap": "_0x137e36",
        "interestTopUp": "_0xc353df",
        "feesReceiver": "_0x640636",
        "totalBalance": "_0x95967d",
        "initializer": "_0xeeba7e",
        "topUpAmount": "_0xdcfd4a",
        "newReceiver": "_0x585c65",
        "accounting": "_0x1491a6",
        "initialize": "_0x69849e",
        "_grantRole": "_0x913439",
        "depositETH": "_0xf706cb",
        "keccak256": "_0xce2e56",
        "sendValue": "_0xf81065",
        "minAmount": "_0xd6e4bc",
        "managerId": "_0xda3c96",
        "withdraw": "_0x8b53f7",
        "isActive": "_0x32a665",
        "onlyRole": "_0x3c93fb",
        "deposit": "_0x36e1d5",
        "staking": "_0xf20b5c",
        "manager": "_0xfff0ca",
        "mulDiv": "_0x0bbe88",
        "config": "_0xb83c75",
        "pauser": "_0xd4672c",
        "encode": "_0x2e7313",
        "amount": "_0x4c2d8e",
        "topUp": "_0x0fe7b8",
        "admin": "_0xb4b943",
        "addr": "_0xbb6929",
        "fees": "_0xde84f8",
        "init": "_0xa01372"
      },
      "changes": [
        "Renamed 98 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_024",
      "transformed_id": "ss_l3_medium_sn_gs_024",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed _0x568cf0, uint256 _0xdb014e);\n    event ETHReturnedToStaking(uint256 _0xdb014e);\n    event ETHAllocatedToManager(uint256 indexed _0x568cf0, uint256 _0xdb014e);\n    event ETHReceivedFromStaking(uint256 _0xdb014e);\n    event FeesCollected(uint256 _0xdb014e);\n    event InterestClaimed(\n        uint256 indexed _0x568cf0,\n        uint256 _0xb63450\n    );\n    event InterestToppedUp(\n        uint256 _0xdb014e\n    );\n}\n\n/**\n * @title LiquidityBuffer\n * @notice Manages liquidity allocation to various position managers for DeFi protocols\n */\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n    // ========================================= CONSTANTS =========================================\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = _0x00b885(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = _0x00b885(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = _0x00b885(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = _0x00b885(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant _0x379c22 = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /// @notice The staking contract to which the liquidity buffer accepts funds from and returns funds to.\n    IStakingReturnsWrite public _0x45779a;\n\n    /// @notice The pauser contract.\n    /// @dev Keeps the pause state across the protocol.\n    IPauserRead public _0xf8c67d;\n\n    /// @notice Total number of position managers\n    uint256 public _0xc1ad63;\n\n    /// @notice Mapping from manager ID to position manager configuration\n    mapping(uint256 => PositionManagerConfig) public _0xf4007e;\n\n    /// @notice Mapping from manager ID to accounting information\n    mapping(uint256 => PositionAccountant) public _0x322f75;\n\n    /// @notice Total funds received from staking contract\n    uint256 public _0x33da39;\n\n    /// @notice Total funds returned to staking contract\n    uint256 public _0x92b42c;\n\n    /// @notice Total allocated balance across all position managers\n    uint256 public _0x9f8b20;\n\n    /// @notice Total interest claimed from position managers\n    uint256 public _0xf6609e;\n\n    /// @notice Total interest topped up to staking contract\n    uint256 public _0x43e4b0;\n\n    /// @notice Total allocation capacity across all managers\n    uint256 public _0x426266;\n\n    /// @notice Cumulative drawdown amount\n    uint256 public _0x3d3e9a;\n\n    /// @notice Default manager ID for deposit and allocation operations\n    uint256 public _0x52309d;\n\n    /// @notice The address receiving protocol fees.\n    address payable public _0xb413eb;\n\n    /// @notice The protocol fees in basis points (1/10000).\n    uint16 public _0x1a7ab7;\n\n    uint256 public _0x5d05b4;\n\n    /// @notice Tracks pending interest available for top-up operations\n    uint256 public _0xcd2a4f;\n\n    /// @notice Tracks pending principal available for operations\n    uint256 public _0x894c31;\n\n    /// @notice Controls whether to execute allocation logic in depositETH method\n    bool public _0xe99be6;\n    /// @notice Mapping from manager address to boolean indicating if it is registered\n    mapping(address => bool) public _0xf27d5a;\n\n    struct Init {\n        address _0x14a4dd;\n        address _0x5ad681;\n        address _0x4b87f7;\n        address _0xda1d87;\n        address _0xc016e1;\n        address payable _0xb413eb;\n        IStakingReturnsWrite _0x1b854a;\n        IPauserRead _0xf8c67d;\n    }\n\n    // ========================================= ERRORS =========================================\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n    // ========================================= INITIALIZATION =========================================\n\n    constructor() {\n        _0x14122b();\n    }\n\n    function _0xc77e4d(Init memory _0x5ff935) external _0x140543 {\n\n        __AccessControlEnumerable_init();\n\n        _0x3db946(DEFAULT_ADMIN_ROLE, _0x5ff935._0x14a4dd);\n        _0x3db946(LIQUIDITY_MANAGER_ROLE, _0x5ff935._0x5ad681);\n        _0x3db946(POSITION_MANAGER_ROLE, _0x5ff935._0x4b87f7);\n        _0x3db946(INTEREST_TOPUP_ROLE, _0x5ff935._0xda1d87);\n        _0x3db946(DRAWDOWN_MANAGER_ROLE, _0x5ff935._0xc016e1);\n\n        _0x45779a = _0x5ff935._0x1b854a;\n        _0xf8c67d = _0x5ff935._0xf8c67d;\n        _0xb413eb = _0x5ff935._0xb413eb;\n        _0xe99be6 = true;\n\n        _0x3db946(LIQUIDITY_MANAGER_ROLE, address(_0x45779a));\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    function _0x8fba2d(uint256 _0x568cf0) public view returns (uint256) {\n        PositionManagerConfig memory _0xdaac59 = _0xf4007e[_0x568cf0];\n        // Get current underlying balance from position manager\n        IPositionManager _0xd995df = IPositionManager(_0xdaac59._0x013b81);\n        uint256 _0xbf7a5a = _0xd995df._0x876c25();\n\n        // Calculate interest as: current balance - allocated balance\n        PositionAccountant memory _0x3bf06d = _0x322f75[_0x568cf0];\n\n        if (_0xbf7a5a > _0x3bf06d._0x315d92) {\n            return _0xbf7a5a - _0x3bf06d._0x315d92;\n        }\n\n        return 0;\n    }\n\n    function _0xff2fbf() public view returns (uint256) {\n        return _0x426266 - _0x9f8b20;\n    }\n\n    function _0x57f87c() public view returns (uint256) {\n        return _0x33da39 - _0x92b42c;\n    }\n\n    function _0x29bb22() public view returns (uint256) {\n        uint256 _0xf84cf7 = address(this).balance;\n\n        // Loop through all position manager configs and get their balances\n        // Note: This function makes external calls in a loop which can be gas-expensive\n        // Consider caching balances or using a different approach for production\n        for (uint256 i = 0; i < _0xc1ad63; i++) {\n            PositionManagerConfig storage _0xdaac59 = _0xf4007e[i];\n            if (_0xdaac59._0xb254b5) {\n                IPositionManager _0xd995df = IPositionManager(_0xdaac59._0x013b81);\n                uint256 _0x3db72f = _0xd995df._0x876c25();\n                _0xf84cf7 += _0x3db72f;\n            }\n        }\n\n        return _0xf84cf7;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n\n    function _0x4b9ce7(\n        address _0x013b81,\n        uint256 _0x5d3dcc\n    ) external _0xcb68c7(POSITION_MANAGER_ROLE) returns (uint256 _0x568cf0) {\n        if (_0xf27d5a[_0x013b81]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        _0x568cf0 = _0xc1ad63;\n        _0xc1ad63++;\n\n        _0xf4007e[_0x568cf0] = PositionManagerConfig({\n            _0x013b81: _0x013b81,\n            _0x5d3dcc: _0x5d3dcc,\n            _0xb254b5: true\n        });\n        _0x322f75[_0x568cf0] = PositionAccountant({\n            _0x315d92: 0,\n            _0xf27d2e: 0\n        });\n        _0xf27d5a[_0x013b81] = true;\n\n        _0x426266 += _0x5d3dcc;\n        emit ProtocolConfigChanged(\n            this._0x4b9ce7.selector,\n            \"addPositionManager(address,uint256)\",\n            abi._0xbc585b(_0x013b81, _0x5d3dcc)\n        );\n    }\n\n    function _0x275c94(\n        uint256 _0x568cf0,\n        uint256 _0x6b8344,\n        bool _0xb254b5\n    ) external _0xcb68c7(POSITION_MANAGER_ROLE) {\n        if (_0x568cf0 >= _0xc1ad63) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0xdaac59 = _0xf4007e[_0x568cf0];\n\n        if (_0x6b8344 < _0x322f75[_0x568cf0]._0x315d92) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        // Update total allocation capacity\n        _0x426266 = _0x426266 - _0xdaac59._0x5d3dcc + _0x6b8344;\n\n        _0xdaac59._0x5d3dcc = _0x6b8344;\n        _0xdaac59._0xb254b5 = _0xb254b5;\n\n        emit ProtocolConfigChanged(\n            this._0x275c94.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi._0xbc585b(_0x568cf0, _0x6b8344, _0xb254b5)\n        );\n    }\n\n    function _0xc11800(uint256 _0x568cf0) external _0xcb68c7(POSITION_MANAGER_ROLE) {\n        if (_0x568cf0 >= _0xc1ad63) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0xdaac59 = _0xf4007e[_0x568cf0];\n        _0xdaac59._0xb254b5 = !_0xdaac59._0xb254b5;\n\n        emit ProtocolConfigChanged(\n            this._0xc11800.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi._0xbc585b(_0x568cf0)\n        );\n    }\n\n    function _0xc86839(uint256 _0x9216e9) external _0xcb68c7(DRAWDOWN_MANAGER_ROLE) {\n        _0x3d3e9a = _0x9216e9;\n\n        emit ProtocolConfigChanged(\n            this._0xc86839.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi._0xbc585b(_0x9216e9)\n        );\n    }\n\n    function _0x74d644(uint256 _0x3dd1d8) external _0xcb68c7(POSITION_MANAGER_ROLE) {\n        if (_0x3dd1d8 >= _0xc1ad63) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!_0xf4007e[_0x3dd1d8]._0xb254b5) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x52309d = _0x3dd1d8; }\n\n        emit ProtocolConfigChanged(\n            this._0x74d644.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi._0xbc585b(_0x3dd1d8)\n        );\n    }\n\n    /// @notice Sets the fees basis points.\n    /// @param newBasisPoints The new fees basis points.\n    function _0x71a80d(uint16 _0x86afe4) external _0xcb68c7(POSITION_MANAGER_ROLE) {\n        if (_0x86afe4 > _0x379c22) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        _0x1a7ab7 = _0x86afe4;\n        emit ProtocolConfigChanged(\n            this._0x71a80d.selector, \"setFeeBasisPoints(uint16)\", abi._0xbc585b(_0x86afe4)\n        );\n    }\n\n     /// @notice Sets the fees receiver wallet for the protocol.\n    /// @param newReceiver The new fees receiver wallet.\n    function _0x03f7ce(address payable _0x68b17b)\n        external\n        _0xcb68c7(POSITION_MANAGER_ROLE)\n        _0x5a5edd(_0x68b17b)\n    {\n        _0xb413eb = _0x68b17b;\n        emit ProtocolConfigChanged(this._0x03f7ce.selector, \"setFeesReceiver(address)\", abi._0xbc585b(_0x68b17b));\n    }\n\n    /// @notice Sets whether to execute allocation logic in depositETH method.\n    /// @param executeAllocation Whether to execute allocation logic.\n    function _0x84b421(bool _0x90908d) external _0xcb68c7(POSITION_MANAGER_ROLE) {\n        if (block.timestamp > 0) { _0xe99be6 = _0x90908d; }\n        emit ProtocolConfigChanged(this._0x84b421.selector, \"setShouldExecuteAllocation(bool)\", abi._0xbc585b(_0x90908d));\n    }\n\n    // ========================================= LIQUIDITY MANAGEMENT =========================================\n\n    function _0xba1d13() external payable _0xcb68c7(LIQUIDITY_MANAGER_ROLE) {\n        if (_0xf8c67d._0x712acd()) revert LiquidityBuffer__Paused();\n        _0xb38959(msg.value);\n        if (_0xe99be6) {\n            _0x50a3f6(_0x52309d, msg.value);\n        }\n    }\n\n    function _0xa154bd(uint256 _0x568cf0, uint256 _0xdb014e) external _0xcb68c7(LIQUIDITY_MANAGER_ROLE) {\n        _0x2442c9(_0x568cf0, _0xdb014e);\n        _0xdd7a56(_0xdb014e);\n    }\n\n    function _0x05fa77(uint256 _0x568cf0, uint256 _0xdb014e) external _0xcb68c7(LIQUIDITY_MANAGER_ROLE) {\n        _0x50a3f6(_0x568cf0, _0xdb014e);\n    }\n\n    function _0x8d79f0(uint256 _0x568cf0, uint256 _0xdb014e) external _0xcb68c7(LIQUIDITY_MANAGER_ROLE) {\n        _0x2442c9(_0x568cf0, _0xdb014e);\n    }\n\n    function _0x4f8c37(uint256 _0xdb014e) external _0xcb68c7(LIQUIDITY_MANAGER_ROLE) {\n        _0xdd7a56(_0xdb014e);\n    }\n\n    function _0x336123() external payable _0x03d795 {\n        // This function receives ETH from position managers\n        // The ETH is already in the contract balance, no additional processing needed\n    }\n\n    // ========================================= INTEREST MANAGEMENT =========================================\n\n    function _0x5e90f3(uint256 _0x568cf0, uint256 _0x801e75) external _0xcb68c7(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0xdb014e = _0xfe656a(_0x568cf0);\n        if (_0xdb014e < _0x801e75) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return _0xdb014e;\n    }\n\n    function _0x0451e7(uint256 _0xdb014e) external _0xcb68c7(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < _0xdb014e) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0x4b851a(_0xdb014e);\n        return _0xdb014e;\n    }\n\n    function _0x37a567(uint256 _0x568cf0, uint256 _0x801e75) external _0xcb68c7(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0xdb014e = _0xfe656a(_0x568cf0);\n        if (_0xdb014e < _0x801e75) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0x4b851a(_0xdb014e);\n\n        return _0xdb014e;\n    }\n\n    // ========================================= INTERNAL FUNCTIONS =========================================\n\n    function _0x4b851a(uint256 _0xdb014e) internal {\n        if (_0xf8c67d._0x712acd()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0xdb014e > _0xcd2a4f) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        _0xcd2a4f -= _0xdb014e;\n        uint256 _0x29ed9c = Math._0xc05081(_0x1a7ab7, _0xdb014e, _0x379c22);\n        uint256 _0x34cd4f = _0xdb014e - _0x29ed9c;\n        _0x45779a._0x173b22{value: _0x34cd4f}();\n        _0x43e4b0 += _0x34cd4f;\n        emit InterestToppedUp(_0x34cd4f);\n\n        if (_0x29ed9c > 0) {\n            Address._0x0d4fee(_0xb413eb, _0x29ed9c);\n            _0x5d05b4 += _0x29ed9c;\n            emit FeesCollected(_0x29ed9c);\n        }\n    }\n\n    function _0xfe656a(uint256 _0x568cf0) internal returns (uint256) {\n        if (_0xf8c67d._0x712acd()) {\n            revert LiquidityBuffer__Paused();\n        }\n        // Get interest amount\n        uint256 _0xb63450 = _0x8fba2d(_0x568cf0);\n\n        if (_0xb63450 > 0) {\n            PositionManagerConfig memory _0xdaac59 = _0xf4007e[_0x568cf0];\n\n            // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n            _0x322f75[_0x568cf0]._0xf27d2e += _0xb63450;\n            _0xf6609e += _0xb63450;\n            _0xcd2a4f += _0xb63450;\n            emit InterestClaimed(_0x568cf0, _0xb63450);\n\n            // Withdraw interest from position manager AFTER state updates\n            IPositionManager _0xd995df = IPositionManager(_0xdaac59._0x013b81);\n            _0xd995df._0x707bd4(_0xb63450);\n        } else {\n            emit InterestClaimed(_0x568cf0, _0xb63450);\n        }\n\n        return _0xb63450;\n    }\n\n    function _0x2442c9(uint256 _0x568cf0, uint256 _0xdb014e) internal {\n        if (_0xf8c67d._0x712acd()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x568cf0 >= _0xc1ad63) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory _0xdaac59 = _0xf4007e[_0x568cf0];\n        if (!_0xdaac59._0xb254b5) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage _0x3bf06d = _0x322f75[_0x568cf0];\n\n        // Check sufficient allocation\n        if (_0xdb014e > _0x3bf06d._0x315d92) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x3bf06d._0x315d92 -= _0xdb014e;\n        _0x9f8b20 -= _0xdb014e;\n        _0x894c31 += _0xdb014e;\n        emit ETHWithdrawnFromManager(_0x568cf0, _0xdb014e);\n\n        // Call position manager to withdraw AFTER state updates\n        IPositionManager _0xd995df = IPositionManager(_0xdaac59._0x013b81);\n        _0xd995df._0x707bd4(_0xdb014e);\n    }\n\n    function _0xdd7a56(uint256 _0xdb014e) internal {\n        if (_0xf8c67d._0x712acd()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        // Validate staking contract is set and not zero address\n        if (address(_0x45779a) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (_0xdb014e > _0x894c31) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x92b42c += _0xdb014e;\n        _0x894c31 -= _0xdb014e;\n        emit ETHReturnedToStaking(_0xdb014e);\n\n        // Send ETH to trusted staking contract AFTER state updates\n        // Note: stakingContract is a trusted contract set during initialization\n        _0x45779a._0xd2aa50{value: _0xdb014e}();\n    }\n\n    function _0x50a3f6(uint256 _0x568cf0, uint256 _0xdb014e) internal {\n        if (_0xf8c67d._0x712acd()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0xdb014e > _0x894c31) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (_0x568cf0 >= _0xc1ad63) revert LiquidityBuffer__ManagerNotFound();\n        // check available balance\n        if (address(this).balance < _0xdb014e) revert LiquidityBuffer__InsufficientBalance();\n\n        // check position manager is active\n        PositionManagerConfig memory _0xdaac59 = _0xf4007e[_0x568cf0];\n        if (!_0xdaac59._0xb254b5) revert LiquidityBuffer__ManagerInactive();\n        // check allocation cap\n        PositionAccountant storage _0x3bf06d = _0x322f75[_0x568cf0];\n        if (_0x3bf06d._0x315d92 + _0xdb014e > _0xdaac59._0x5d3dcc) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x3bf06d._0x315d92 += _0xdb014e;\n        _0x9f8b20 += _0xdb014e;\n        _0x894c31 -= _0xdb014e;\n        emit ETHAllocatedToManager(_0x568cf0, _0xdb014e);\n\n        // deposit to position manager AFTER state updates\n        IPositionManager _0xd995df = IPositionManager(_0xdaac59._0x013b81);\n        _0xd995df._0x4c2aa7{value: _0xdb014e}(0);\n    }\n\n    function _0xb38959(uint256 _0xdb014e) internal {\n        _0x33da39 += _0xdb014e;\n        _0x894c31 += _0xdb014e;\n        emit ETHReceivedFromStaking(_0xdb014e);\n    }\n\n    /// @notice Ensures that the given address is not the zero address.\n    /// @param addr The address to check.\n    modifier _0x5a5edd(address _0x42e956) {\n        if (_0x42e956 == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n    /// @dev Validates that the caller is the staking contract.\n    modifier _0xbc29e4() {\n        if (msg.sender != address(_0x45779a)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier _0x03d795() {\n        bool _0xee18de = false;\n\n        // Loop through all position manager configs to check if sender is a valid manager\n        for (uint256 i = 0; i < _0xc1ad63; i++) {\n            PositionManagerConfig memory _0xdaac59 = _0xf4007e[i];\n\n            if (msg.sender == _0xdaac59._0x013b81 && _0xdaac59._0xb254b5) {\n                _0xee18de = true;\n                break;\n            }\n        }\n\n        if (!_0xee18de) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "_topUpInterestToStakingAndCollectFees": "_0x4b851a",
        "receiveReturnsFromLiquidityBuffer": "_0xd2aa50",
        "receiveETHFromPositionManager": "_0x336123",
        "onlyPositionManagerContract": "_0x03d795",
        "togglePositionManagerStatus": "_0xc11800",
        "setShouldExecuteAllocation": "_0x84b421",
        "interestClaimedFromManager": "_0xf27d2e",
        "_claimInterestFromManager": "_0xfe656a",
        "_BASIS_POINTS_DENOMINATOR": "_0x379c22",
        "claimInterestFromManager": "_0x5e90f3",
        "isLiquidityBufferPaused": "_0x712acd",
        "shouldExecuteAllocation": "_0xe99be6",
        "_withdrawETHFromManager": "_0x2442c9",
        "totalAllocationCapacity": "_0x426266",
        "topUpInterestToStaking": "_0x0451e7",
        "_receiveETHFromStaking": "_0xb38959",
        "withdrawETHFromManager": "_0x8d79f0",
        "positionManagerConfigs": "_0xf4007e",
        "updatePositionManager": "_0x275c94",
        "_allocateETHToManager": "_0x50a3f6",
        "claimInterestAndTopUp": "_0x37a567",
        "totalInterestToppedUp": "_0x43e4b0",
        "totalAllocatedBalance": "_0x9f8b20",
        "setCumulativeDrawdown": "_0xc86839",
        "getAvailableCapacity": "_0xff2fbf",
        "getControlledBalance": "_0x29bb22",
        "totalInterestClaimed": "_0xf6609e",
        "getUnderlyingBalance": "_0x876c25",
        "allocateETHToManager": "_0x05fa77",
        "positionManagerCount": "_0xc1ad63",
        "_disableInitializers": "_0x14122b",
        "newDefaultManagerId": "_0x3dd1d8",
        "isRegisteredManager": "_0xf27d5a",
        "_returnETHToStaking": "_0xdd7a56",
        "onlyStakingContract": "_0xbc29e4",
        "positionAccountants": "_0x322f75",
        "setDefaultManagerId": "_0x74d644",
        "getAvailableBalance": "_0x57f87c",
        "addPositionManager": "_0x4b9ce7",
        "cumulativeDrawdown": "_0x3d3e9a",
        "totalFundsReturned": "_0x92b42c",
        "totalFeesCollected": "_0x5d05b4",
        "totalFundsReceived": "_0x33da39",
        "returnETHToStaking": "_0x4f8c37",
        "withdrawAndReturn": "_0xa154bd",
        "setFeeBasisPoints": "_0x71a80d",
        "getInterestAmount": "_0x8fba2d",
        "executeAllocation": "_0x90908d",
        "liquidityManager": "_0x5ad681",
        "newAllocationCap": "_0x6b8344",
        "pendingPrincipal": "_0x894c31",
        "allocatedBalance": "_0x315d92",
        "defaultManagerId": "_0x52309d",
        "positionManager": "_0x4b87f7",
        "drawdownManager": "_0xc016e1",
        "setFeesReceiver": "_0x03f7ce",
        "feesBasisPoints": "_0x1a7ab7",
        "stakingContract": "_0x45779a",
        "pendingInterest": "_0xcd2a4f",
        "isValidManager": "_0xee18de",
        "drawdownAmount": "_0x9216e9",
        "interestAmount": "_0xb63450",
        "managerBalance": "_0x3db72f",
        "managerAddress": "_0x013b81",
        "notZeroAddress": "_0x5a5edd",
        "newBasisPoints": "_0x86afe4",
        "currentBalance": "_0xbf7a5a",
        "allocationCap": "_0x5d3dcc",
        "interestTopUp": "_0xda1d87",
        "feesReceiver": "_0xb413eb",
        "totalBalance": "_0xf84cf7",
        "initializer": "_0x140543",
        "topUpAmount": "_0x34cd4f",
        "newReceiver": "_0x68b17b",
        "accounting": "_0x3bf06d",
        "initialize": "_0xc77e4d",
        "_grantRole": "_0x3db946",
        "depositETH": "_0xba1d13",
        "keccak256": "_0x00b885",
        "sendValue": "_0x0d4fee",
        "minAmount": "_0x801e75",
        "managerId": "_0x568cf0",
        "withdraw": "_0x707bd4",
        "isActive": "_0xb254b5",
        "onlyRole": "_0xcb68c7",
        "deposit": "_0x4c2aa7",
        "staking": "_0x1b854a",
        "manager": "_0xd995df",
        "mulDiv": "_0xc05081",
        "config": "_0xdaac59",
        "pauser": "_0xf8c67d",
        "encode": "_0xbc585b",
        "amount": "_0xdb014e",
        "topUp": "_0x173b22",
        "admin": "_0x14a4dd",
        "addr": "_0x42e956",
        "fees": "_0x29ed9c",
        "init": "_0x5ff935"
      },
      "changes": [
        "Renamed 98 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_025",
      "transformed_id": "ss_l3_medium_sn_gs_025",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed _0xd01e02, uint256 _0x7c9ba5, uint256 _0x0248ba);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed _0x036721, address indexed _0xd01e02, uint256 _0x7c9ba5, uint256 _0xdacc5e);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed _0x036721, address indexed _0xd01e02);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed _0x036721, uint256 indexed _0x79cb83, bytes _0x8da423, uint256 _0x89395e);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 _0x079bdd);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 _0x079bdd);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 _0x079bdd);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 _0x079bdd);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 _0x079bdd);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 _0xc7d397, uint256 _0x86b195);\n    error UnstakeBelowMinimumETHAmount(uint256 _0x7c9ba5, uint256 _0x86b195);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = _0xee65fc(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = _0xee65fc(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = _0xee65fc(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = _0xee65fc(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = _0xee65fc(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = _0xee65fc(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 _0x79cb83;\n        uint256 _0x7f090f;\n        bytes _0x8da423;\n        bytes _0x9ad676;\n        bytes _0x2ad157;\n        bytes32 _0xe45518;\n    }\n\n    mapping(bytes _0x8da423 => bool _0x910d8b) public _0x118e23;\n    uint256 public _0xd8d9c7;\n    uint256 public _0xc52a5f;\n    uint256 public _0x372bf0;\n    uint256 public _0x1fb505;\n    uint256 public _0xfee16f;\n    uint256 public _0x663da6;\n    uint16 public _0x95ed0c;\n    uint16 internal constant _0x5531e7 = 10_000;\n    uint16 internal constant _0x379585 = _0x5531e7 / 10;\n    uint256 public _0x9ac968;\n    uint256 public _0xa657c3;\n    IDepositContract public _0xe3c00e;\n    IMETH public _0x0c6a2b;\n    IOracleReadRecord public _0xb35f0e;\n    IPauserRead public _0x848af2;\n    IUnstakeRequestsManager public _0xdb0051;\n    address public _0x40cd20;\n    address public _0x7e02d3;\n    bool public _0x60e2b4;\n    uint256 public _0xb7b26e;\n    uint256 public _0x79b92f;\n    ILiquidityBuffer public _0xfdeb18;\n\n    struct Init {\n        address _0x465828;\n        address _0x2bdccd;\n        address _0xe3b8c2;\n        address _0x4d61d8;\n        address _0x7e02d3;\n        address _0x40cd20;\n        IMETH _0x0c6a2b;\n        IDepositContract _0xe3c00e;\n        IOracleReadRecord _0xb35f0e;\n        IPauserRead _0x848af2;\n        IUnstakeRequestsManager _0xdb0051;\n    }\n\n    constructor() {\n        _0xf0935e();\n    }\n\n    function _0xe78826(Init memory _0x7182b3) external _0x1c9467 {\n        __AccessControlEnumerable_init();\n\n        _0x32e155(DEFAULT_ADMIN_ROLE, _0x7182b3._0x465828);\n        _0x32e155(STAKING_MANAGER_ROLE, _0x7182b3._0x2bdccd);\n        _0x32e155(ALLOCATOR_SERVICE_ROLE, _0x7182b3._0xe3b8c2);\n        _0x32e155(INITIATOR_SERVICE_ROLE, _0x7182b3._0x4d61d8);\n\n        _0xcfc826(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _0xcfc826(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        _0x0c6a2b = _0x7182b3._0x0c6a2b;\n        _0xe3c00e = _0x7182b3._0xe3c00e;\n        _0xb35f0e = _0x7182b3._0xb35f0e;\n        _0x848af2 = _0x7182b3._0x848af2;\n        if (block.timestamp > 0) { _0x7e02d3 = _0x7182b3._0x7e02d3; }\n        _0xdb0051 = _0x7182b3._0xdb0051;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x40cd20 = _0x7182b3._0x40cd20; }\n\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xfee16f = 0.1 ether; }\n        _0x663da6 = 0.01 ether;\n        _0x9ac968 = 32 ether;\n        _0xa657c3 = 32 ether;\n        _0x60e2b4 = true;\n        _0xb7b26e = block.number;\n        _0x79b92f = 1024 ether;\n    }\n\n    function _0xb9fb24(ILiquidityBuffer _0xbc2f44) public _0xad803b(2) {\n        _0xfdeb18 = _0xbc2f44;\n    }\n\n    function _0x2b94ca(uint256 _0x0c3638) external payable {\n        if (_0x848af2._0xbdacda()) {\n            revert Paused();\n        }\n\n        if (_0x60e2b4) {\n            _0xe62d92(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < _0xfee16f) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 _0x4c1b48 = _0x157d65(msg.value);\n        if (_0x4c1b48 + _0x0c6a2b._0xbedbf2() > _0x79b92f) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (_0x4c1b48 < _0x0c3638) {\n            revert StakeBelowMinimumMETHAmount(_0x4c1b48, _0x0c3638);\n        }\n\n        _0x372bf0 += msg.value;\n\n        emit Staked(msg.sender, msg.value, _0x4c1b48);\n        _0x0c6a2b._0xd148d3(msg.sender, _0x4c1b48);\n    }\n\n    function _0x762a3d(uint128 _0xc7d397, uint128 _0x47efdd) external returns (uint256) {\n        return _0x190ae7(_0xc7d397, _0x47efdd);\n    }\n\n    function _0x866fcd(\n        uint128 _0xc7d397,\n        uint128 _0x47efdd,\n        uint256 _0x21ad8e,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable._0xb13d72(_0x0c6a2b, msg.sender, address(this), _0xc7d397, _0x21ad8e, v, r, s);\n        return _0x190ae7(_0xc7d397, _0x47efdd);\n    }\n\n    function _0x190ae7(uint128 _0xc7d397, uint128 _0x47efdd) internal returns (uint256) {\n        if (_0x848af2._0x1990a4()) {\n            revert Paused();\n        }\n\n        if (_0xc7d397 < _0x663da6) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 _0x7c9ba5 = uint128(_0x0721a9(_0xc7d397));\n        if (_0x7c9ba5 < _0x47efdd) {\n            revert UnstakeBelowMinimumETHAmount(_0x7c9ba5, _0x47efdd);\n        }\n\n        uint256 _0xdba3e7 =\n            _0xdb0051._0x1763c9({_0xced563: msg.sender, _0xdacc5e: _0xc7d397, _0xbba33d: _0x7c9ba5});\n        emit UnstakeRequested({_0x036721: _0xdba3e7, _0xd01e02: msg.sender, _0x7c9ba5: _0x7c9ba5, _0xdacc5e: _0xc7d397});\n\n        SafeERC20Upgradeable._0x3bd27b(_0x0c6a2b, msg.sender, address(_0xdb0051), _0xc7d397);\n\n        return _0xdba3e7;\n    }\n\n    function _0x157d65(uint256 _0x7c9ba5) public view returns (uint256) {\n        if (_0x0c6a2b._0xbedbf2() == 0) {\n            return _0x7c9ba5;\n        }\n        uint256 _0x6a3c1d = Math._0x66fd58(\n            _0xe73b1f(), _0x5531e7 + _0x95ed0c, _0x5531e7\n        );\n        return Math._0x66fd58(_0x7c9ba5, _0x0c6a2b._0xbedbf2(), _0x6a3c1d);\n    }\n\n    function _0x0721a9(uint256 _0x0248ba) public view returns (uint256) {\n        if (_0x0c6a2b._0xbedbf2() == 0) {\n            return _0x0248ba;\n        }\n        return Math._0x66fd58(_0x0248ba, _0xe73b1f(), _0x0c6a2b._0xbedbf2());\n    }\n\n    function _0xe73b1f() public view returns (uint256) {\n        OracleRecord memory _0x413e46 = _0xb35f0e._0xd26300();\n        uint256 _0x177d81 = 0;\n        _0x177d81 += _0x372bf0;\n        _0x177d81 += _0x1fb505;\n        _0x177d81 += _0xd8d9c7 - _0x413e46._0x28aa05;\n        _0x177d81 += _0x413e46._0xe44f82;\n        _0x177d81 += _0xfdeb18._0xaa4425();\n        _0x177d81 -= _0xfdeb18._0x472c0f();\n        _0x177d81 += _0xdb0051.balance();\n        return _0x177d81;\n    }\n\n    function _0x812b75() external payable _0xe679ca {\n        emit ReturnsReceived(msg.value);\n        _0x372bf0 += msg.value;\n    }\n\n    function _0xab481a() external payable _0x5ea0db {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        _0x372bf0 += msg.value;\n    }\n\n    modifier _0xe679ca() {\n        if (msg.sender != _0x7e02d3) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier _0x5ea0db() {\n        if (msg.sender != address(_0xfdeb18)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier _0xb57c59() {\n        if (msg.sender != address(_0xdb0051)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier _0xd4df1d(address _0x9cd317) {\n        if (_0x9cd317 == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "_0xab481a",
        "isUnstakeRequestsAndClaimsPaused": "_0x1990a4",
        "cumulativeProcessedDepositAmount": "_0x28aa05",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "_0x379585",
        "currentTotalValidatorBalance": "_0xe44f82",
        "totalDepositedInValidators": "_0xd8d9c7",
        "onlyUnstakeRequestsManager": "_0xb57c59",
        "initializationBlockNumber": "_0xb7b26e",
        "_BASIS_POINTS_DENOMINATOR": "_0x5531e7",
        "unstakeRequestWithPermit": "_0x866fcd",
        "adjustedTotalControlled": "_0x6a3c1d",
        "allocatedETHForDeposits": "_0x1fb505",
        "numInitiatedValidators": "_0xc52a5f",
        "exchangeAdjustmentRate": "_0x95ed0c",
        "unstakeRequestsManager": "_0xdb0051",
        "withdrawalCredentials": "_0x9ad676",
        "onlyReturnsAggregator": "_0xe679ca",
        "minimumDepositAmount": "_0x9ac968",
        "maximumDepositAmount": "_0xa657c3",
        "_disableInitializers": "_0xf0935e",
        "onlyLiquidityBuffer": "_0x5ea0db",
        "minimumUnstakeBound": "_0x663da6",
        "getAvailableBalance": "_0xaa4425",
        "isStakingAllowlist": "_0x60e2b4",
        "cumulativeDrawdown": "_0x472c0f",
        "maximumMETHSupply": "_0x79b92f",
        "returnsAggregator": "_0x7e02d3",
        "minimumStakeBound": "_0xfee16f",
        "allocatorService": "_0xe3b8c2",
        "withdrawalWallet": "_0x40cd20",
        "initiatorService": "_0x4d61d8",
        "safeTransferFrom": "_0x3bd27b",
        "depositContract": "_0xe3c00e",
        "amountDeposited": "_0x89395e",
        "isStakingPaused": "_0xbdacda",
        "_unstakeRequest": "_0x190ae7",
        "expectedMinimum": "_0x86b195",
        "depositDataRoot": "_0xe45518",
        "totalControlled": "_0xe73b1f",
        "liquidityBuffer": "_0xfdeb18",
        "unstakeRequest": "_0x762a3d",
        "usedValidators": "_0x118e23",
        "notZeroAddress": "_0xd4df1d",
        "receiveReturns": "_0x812b75",
        "mETHMintAmount": "_0x4c1b48",
        "unallocatedETH": "_0x372bf0",
        "depositAmount": "_0x7f090f",
        "reinitializer": "_0xad803b",
        "minMETHAmount": "_0x0c3638",
        "_setRoleAdmin": "_0xcfc826",
        "initializeV2": "_0xb9fb24",
        "latestRecord": "_0xd26300",
        "minETHAmount": "_0x47efdd",
        "ethRequested": "_0xbba33d",
        "initializer": "_0x1c9467",
        "totalSupply": "_0xbedbf2",
        "mETHAmount": "_0x0248ba",
        "mETHLocked": "_0xdacc5e",
        "_checkRole": "_0xe62d92",
        "initialize": "_0xe78826",
        "methAmount": "_0xc7d397",
        "_grantRole": "_0x32e155",
        "operatorID": "_0x79cb83",
        "safePermit": "_0xb13d72",
        "keccak256": "_0xee65fc",
        "ethAmount": "_0x7c9ba5",
        "mETHToETH": "_0x0721a9",
        "requester": "_0xced563",
        "ethToMETH": "_0x157d65",
        "requestID": "_0xdba3e7",
        "signature": "_0x2ad157",
        "deadline": "_0x21ad8e",
        "manager": "_0x2bdccd",
        "mulDiv": "_0x66fd58",
        "create": "_0x1763c9",
        "pauser": "_0x848af2",
        "exists": "_0x910d8b",
        "oracle": "_0xb35f0e",
        "record": "_0x413e46",
        "pubkey": "_0x8da423",
        "amount": "_0x079bdd",
        "staker": "_0xd01e02",
        "stake": "_0x2b94ca",
        "admin": "_0x465828",
        "total": "_0x177d81",
        "mETH": "_0x0c6a2b",
        "addr": "_0x9cd317",
        "mint": "_0xd148d3",
        "init": "_0x7182b3",
        "lb": "_0xbc2f44",
        "id": "_0x036721"
      },
      "changes": [
        "Renamed 91 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_026",
      "transformed_id": "ss_l3_medium_sn_gs_026",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IPool} from \"aave-v3/interfaces/IPool.sol\";\nimport {DataTypes} from \"aave-v3/protocol/libraries/types/DataTypes.sol\";\nimport {IPositionManager} from './interfaces/IPositionManager.sol';\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {ILiquidityBuffer} from \"../liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/**\n * @title PositionManager\n * @dev Position manager with role-based access control\n * inspired by WrappedTokenGatewayV3 0xd01607c3c5ecaba394d8be377a08590149325722\n */\ncontract PositionManager is Initializable, AccessControlEnumerableUpgradeable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n    // Role definitions\n    bytes32 public constant EXECUTOR_ROLE = _0xa09df9(\"EXECUTOR_ROLE\");\n    bytes32 public constant MANAGER_ROLE = _0xa09df9(\"MANAGER_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = _0xa09df9(\"EMERGENCY_ROLE\");\n\n    // State variables\n    IPool public _0xa9f97f;\n    IWETH public _0x932202;\n    ILiquidityBuffer public _0x0b179f;\n\n    /// @notice Configuration for contract initialization.\n    struct Init {\n        address _0x09961c;\n        address _0x95ced1;\n        ILiquidityBuffer _0x0b179f;\n        IWETH _0x932202;\n        IPool _0xa9f97f;\n    }\n\n    // Events\n    event Deposit(address indexed _0x7c4552, uint _0x5e79c6, uint _0xf251f6);\n    event Withdraw(address indexed _0x7c4552, uint _0x5e79c6);\n    event Borrow(address indexed _0x7c4552, uint _0x5e79c6, uint _0xe1e393);\n    event Repay(address indexed _0x7c4552, uint _0x5e79c6, uint _0xe1e393);\n    event SetUserEMode(address indexed _0x7c4552, uint8 _0xbc30e4);\n\n    constructor() {\n        _0x135998();\n    }\n\n    function _0x09969f(Init memory _0x062198) external _0xed15cb {\n        __AccessControlEnumerable_init();\n\n        if (gasleft() > 0) { _0x932202 = _0x062198._0x932202; }\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xa9f97f = _0x062198._0xa9f97f; }\n        _0x0b179f = _0x062198._0x0b179f;\n\n        // Set up roles\n        _0x9d1b4a(DEFAULT_ADMIN_ROLE, _0x062198._0x09961c);\n        _0x9d1b4a(MANAGER_ROLE, _0x062198._0x95ced1);\n        _0x9d1b4a(EXECUTOR_ROLE, address(_0x062198._0x0b179f));\n\n        // Approve pool to spend WETH\n        _0x932202._0xd47bd6(address(_0xa9f97f), type(uint256)._0xc27879);\n    }\n\n    // IPositionManager Implementation\n\n    function _0x4608b6(uint16 _0xbd955c) external payable override _0x6c6f38(EXECUTOR_ROLE) {\n        if (msg.value > 0) {\n            // Wrap ETH to WETH\n            _0x932202._0x4608b6{value: msg.value}();\n\n            // Deposit WETH into pool\n            _0xa9f97f._0x4608b6(address(_0x932202), msg.value, address(this), _0xbd955c);\n\n            emit Deposit(msg.sender, msg.value, msg.value);\n        }\n    }\n\n    function _0xbaa2d4(uint256 _0x5e79c6) external override _0x6c6f38(EXECUTOR_ROLE) {\n        require(_0x5e79c6 > 0, 'Invalid _0x5e79c6');\n\n        // Get aWETH token\n        IERC20 _0x5619e6 = IERC20(_0xa9f97f._0x051824(address(_0x932202)));\n        uint256 _0x384e26 = _0x5619e6._0x5e9ffe(address(this));\n\n        uint256 _0x71537d = _0x5e79c6;\n        if (_0x5e79c6 == type(uint256)._0xc27879) {\n            _0x71537d = _0x384e26;\n        }\n\n        require(_0x71537d <= _0x384e26, 'Insufficient balance');\n\n        // Withdraw from pool\n        _0xa9f97f._0xbaa2d4(address(_0x932202), _0x71537d, address(this));\n\n        // Unwrap WETH to ETH\n        _0x932202._0xbaa2d4(_0x71537d);\n\n        // Transfer ETH to LiquidityBuffer via receiveETHFromPositionManager\n        _0x0b179f._0x4e8c8a{value: _0x71537d}();\n\n        emit Withdraw(msg.sender, _0x71537d);\n    }\n\n    function _0x3763e8() external view returns (uint256) {\n        IERC20 _0x5619e6 = IERC20(_0xa9f97f._0x051824(address(_0x932202)));\n        return _0x5619e6._0x5e9ffe(address(this));\n    }\n\n    function _0x3084de(uint8 _0xbc30e4) external override _0x6c6f38(MANAGER_ROLE) {\n        // Set user E-mode category\n        _0xa9f97f._0x3084de(_0xbc30e4);\n\n        emit SetUserEMode(msg.sender, _0xbc30e4);\n    }\n    function _0x6faf95(address _0x458745, address _0x667968, uint256 _0x9bb48c) external override _0x6c6f38(MANAGER_ROLE) {\n        IERC20(_0x458745)._0xfb67fb(_0x667968, _0x9bb48c);\n    }\n\n    function _0xa36b77(address _0x458745, address _0x667968) external override _0x6c6f38(MANAGER_ROLE) {\n        IERC20(_0x458745)._0xfb67fb(_0x667968, 0);\n    }\n\n    // Additional helper functions\n\n    function _0x70119f() external view returns (uint256) {\n        address _0x340d1d = _0xa9f97f._0x9342e6(address(_0x932202));\n        return IERC20(_0x340d1d)._0x5e9ffe(address(this));\n    }\n\n    function _0x466828() external view returns (uint256) {\n        IERC20 _0x5619e6 = IERC20(_0xa9f97f._0x051824(address(_0x932202)));\n        return _0x5619e6._0x5e9ffe(address(this));\n    }\n\n    function _0x3cffc7() external view returns (uint256) {\n        return _0xa9f97f._0x3cffc7(address(this));\n    }\n\n    function _0x94545a(address _0xe2e582, bool _0xd49d66) external _0x6c6f38(MANAGER_ROLE) {\n        _0xa9f97f._0x94545a(_0xe2e582, _0xd49d66);\n    }\n\n    function _0x62df52(address _0x2b53f4) external _0x6c6f38(MANAGER_ROLE) {\n        _0x03c9ee(EXECUTOR_ROLE, address(_0x0b179f));\n        _0x9d1b4a(EXECUTOR_ROLE, _0x2b53f4);\n        _0x0b179f = ILiquidityBuffer(_0x2b53f4);\n    }\n\n    /**\n    * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n    * direct transfers to the contract address.\n    * @param token token to transfer\n    * @param to recipient of the transfer\n    * @param amount amount to send\n    */\n    function _0x4272b3(address _0x458745, address _0xc68492, uint256 _0x5e79c6) external _0x6c6f38(EMERGENCY_ROLE) {\n        IERC20(_0x458745)._0x056be2(_0xc68492, _0x5e79c6);\n    }\n\n    /**\n    * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\n    * due to selfdestructs or ether transfers to the pre-computed contract address before deployment.\n    * @param to recipient of the transfer\n    * @param amount amount to send\n    */\n    function _0xaf95e2(address _0xc68492, uint256 _0x5e79c6) external _0x6c6f38(EMERGENCY_ROLE) {\n        _0x3fff17(_0xc68492, _0x5e79c6);\n    }\n\n    /**\n     * @dev transfer ETH to an address, revert if it fails.\n     * @param to recipient of the transfer\n     * @param value the amount to send\n     */\n    function _0x3fff17(address _0xc68492, uint256 value) internal {\n        (bool _0xb89040, ) = _0xc68492.call{value: value}(new bytes(0));\n        require(_0xb89040, 'ETH_TRANSFER_FAILED');\n    }\n\n    /**\n    * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n    */\n    receive() external payable {\n        require(msg.sender == address(_0x932202), 'Receive not allowed');\n    }\n\n    /**\n    * @dev Revert fallback calls\n    */\n    fallback() external payable {\n        revert('Fallback not allowed');\n    }\n}",
      "rename_map": {
        "receiveETHFromPositionManager": "_0x4e8c8a",
        "setUserUseReserveAsCollateral": "_0x94545a",
        "getReserveVariableDebtToken": "_0x9342e6",
        "emergencyTokenTransfer": "_0x4272b3",
        "emergencyEtherTransfer": "_0xaf95e2",
        "getUnderlyingBalance": "_0x3763e8",
        "getCollateralBalance": "_0x466828",
        "_disableInitializers": "_0x135998",
        "setLiquidityBuffer": "_0x62df52",
        "amountToWithdraw": "_0x71537d",
        "_liquidityBuffer": "_0x2b53f4",
        "_safeTransferETH": "_0x3fff17",
        "getReserveAToken": "_0x051824",
        "getBorrowBalance": "_0x70119f",
        "liquidityBuffer": "_0x0b179f",
        "useAsCollateral": "_0xd49d66",
        "safeTransfer": "_0x056be2",
        "referralCode": "_0xbd955c",
        "getUserEMode": "_0x3cffc7",
        "setUserEMode": "_0x3084de",
        "aTokenAmount": "_0xf251f6",
        "approveToken": "_0x6faf95",
        "revokeToken": "_0xa36b77",
        "userBalance": "_0x384e26",
        "initializer": "_0xed15cb",
        "_revokeRole": "_0x03c9ee",
        "safeApprove": "_0xfb67fb",
        "initialize": "_0x09969f",
        "categoryId": "_0xbc30e4",
        "_grantRole": "_0x9d1b4a",
        "balanceOf": "_0x5e9ffe",
        "debtToken": "_0x340d1d",
        "keccak256": "_0xa09df9",
        "withdraw": "_0xbaa2d4",
        "onlyRole": "_0x6c6f38",
        "rateMode": "_0xe1e393",
        "manager": "_0x95ced1",
        "approve": "_0xd47bd6",
        "success": "_0xb89040",
        "deposit": "_0x4608b6",
        "caller": "_0x7c4552",
        "amount": "_0x5e79c6",
        "asset": "_0xe2e582",
        "aWETH": "_0x5619e6",
        "token": "_0x458745",
        "admin": "_0x09961c",
        "weth": "_0x932202",
        "pool": "_0xa9f97f",
        "addr": "_0x667968",
        "init": "_0x062198",
        "max": "_0xc27879",
        "wad": "_0x9bb48c",
        "to": "_0xc68492"
      },
      "changes": [
        "Renamed 53 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_027",
      "transformed_id": "ss_l3_medium_sn_gs_027",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed _0x2437ac, uint256 _0x6e32f8, uint256 _0x4dcf68);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed _0x5cee3d, address indexed _0x2437ac, uint256 _0x6e32f8, uint256 _0x5a0a49);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed _0x5cee3d, address indexed _0x2437ac);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed _0x5cee3d, uint256 indexed _0x9cf752, bytes _0x975407, uint256 _0xbb4754);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 _0x2c404b);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 _0x2c404b);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 _0x2c404b);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 _0x2c404b);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 _0x2c404b);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 _0x8ccf8c, uint256 _0x7e9706);\n    error UnstakeBelowMinimumETHAmount(uint256 _0x6e32f8, uint256 _0x7e9706);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = _0x5d9f5f(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = _0x5d9f5f(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = _0x5d9f5f(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = _0x5d9f5f(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = _0x5d9f5f(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = _0x5d9f5f(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 _0x9cf752;\n        uint256 _0xcc8fa8;\n        bytes _0x975407;\n        bytes _0xf1e881;\n        bytes _0x1af1fa;\n        bytes32 _0x5b5670;\n    }\n\n    mapping(bytes _0x975407 => bool _0x291fdd) public _0x999ebd;\n    uint256 public _0x593449;\n    uint256 public _0xa6cd35;\n    uint256 public _0xabc312;\n    uint256 public _0x644791;\n    uint256 public _0x3132ba;\n    uint256 public _0xdbd162;\n    uint16 public _0x3f7003;\n    uint16 internal constant _0x32ca70 = 10_000;\n    uint16 internal constant _0xc40c2d = _0x32ca70 / 10;\n    uint256 public _0x135bd0;\n    uint256 public _0x67b92b;\n    IDepositContract public _0xc48fb9;\n    IMETH public _0x378f53;\n    IOracleReadRecord public _0x19de20;\n    IPauserRead public _0x34a3cc;\n    IUnstakeRequestsManager public _0x40c82c;\n    address public _0x9e9dd8;\n    address public _0xe9cc77;\n    bool public _0x9fd48e;\n    uint256 public _0x85537d;\n    uint256 public _0x1817de;\n    ILiquidityBuffer public _0x0fdd9f;\n\n    struct Init {\n        address _0x5cf380;\n        address _0xaaddd4;\n        address _0x5db6a4;\n        address _0x3823b5;\n        address _0xe9cc77;\n        address _0x9e9dd8;\n        IMETH _0x378f53;\n        IDepositContract _0xc48fb9;\n        IOracleReadRecord _0x19de20;\n        IPauserRead _0x34a3cc;\n        IUnstakeRequestsManager _0x40c82c;\n    }\n\n    constructor() {\n        _0x0b0634();\n    }\n\n    function _0x0b8bc4(Init memory _0x7cc04d) external _0x424b65 {\n        __AccessControlEnumerable_init();\n\n        _0x0f6232(DEFAULT_ADMIN_ROLE, _0x7cc04d._0x5cf380);\n        _0x0f6232(STAKING_MANAGER_ROLE, _0x7cc04d._0xaaddd4);\n        _0x0f6232(ALLOCATOR_SERVICE_ROLE, _0x7cc04d._0x5db6a4);\n        _0x0f6232(INITIATOR_SERVICE_ROLE, _0x7cc04d._0x3823b5);\n\n        _0x73941f(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _0x73941f(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        _0x378f53 = _0x7cc04d._0x378f53;\n        _0xc48fb9 = _0x7cc04d._0xc48fb9;\n        _0x19de20 = _0x7cc04d._0x19de20;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x34a3cc = _0x7cc04d._0x34a3cc; }\n        if (block.timestamp > 0) { _0xe9cc77 = _0x7cc04d._0xe9cc77; }\n        _0x40c82c = _0x7cc04d._0x40c82c;\n        _0x9e9dd8 = _0x7cc04d._0x9e9dd8;\n\n        _0x3132ba = 0.1 ether;\n        _0xdbd162 = 0.01 ether;\n        if (block.timestamp > 0) { _0x135bd0 = 32 ether; }\n        _0x67b92b = 32 ether;\n        _0x9fd48e = true;\n        _0x85537d = block.number;\n        _0x1817de = 1024 ether;\n    }\n\n    function _0x4812df(ILiquidityBuffer _0x1cce84) public _0xd83e91(2) {\n        if (gasleft() > 0) { _0x0fdd9f = _0x1cce84; }\n    }\n\n    function _0x197180(uint256 _0x64ca5d) external payable {\n        if (_0x34a3cc._0x846d69()) {\n            revert Paused();\n        }\n\n        if (_0x9fd48e) {\n            _0x5ff95d(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < _0x3132ba) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 _0x3e7d38 = _0x7ac8a0(msg.value);\n        if (_0x3e7d38 + _0x378f53._0xfbea08() > _0x1817de) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (_0x3e7d38 < _0x64ca5d) {\n            revert StakeBelowMinimumMETHAmount(_0x3e7d38, _0x64ca5d);\n        }\n\n        _0xabc312 += msg.value;\n\n        emit Staked(msg.sender, msg.value, _0x3e7d38);\n        _0x378f53._0x63c5a9(msg.sender, _0x3e7d38);\n    }\n\n    function _0x9d538a(uint128 _0x8ccf8c, uint128 _0x672567) external returns (uint256) {\n        return _0x9ae6d8(_0x8ccf8c, _0x672567);\n    }\n\n    function _0x392d32(\n        uint128 _0x8ccf8c,\n        uint128 _0x672567,\n        uint256 _0x719fa6,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable._0xb92b83(_0x378f53, msg.sender, address(this), _0x8ccf8c, _0x719fa6, v, r, s);\n        return _0x9ae6d8(_0x8ccf8c, _0x672567);\n    }\n\n    function _0x9ae6d8(uint128 _0x8ccf8c, uint128 _0x672567) internal returns (uint256) {\n        if (_0x34a3cc._0x75822b()) {\n            revert Paused();\n        }\n\n        if (_0x8ccf8c < _0xdbd162) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 _0x6e32f8 = uint128(_0x54b1b5(_0x8ccf8c));\n        if (_0x6e32f8 < _0x672567) {\n            revert UnstakeBelowMinimumETHAmount(_0x6e32f8, _0x672567);\n        }\n\n        uint256 _0xc764b3 =\n            _0x40c82c._0xde35e0({_0xbd3441: msg.sender, _0x5a0a49: _0x8ccf8c, _0x10692f: _0x6e32f8});\n        emit UnstakeRequested({_0x5cee3d: _0xc764b3, _0x2437ac: msg.sender, _0x6e32f8: _0x6e32f8, _0x5a0a49: _0x8ccf8c});\n\n        SafeERC20Upgradeable._0x2fb894(_0x378f53, msg.sender, address(_0x40c82c), _0x8ccf8c);\n\n        return _0xc764b3;\n    }\n\n    function _0x7ac8a0(uint256 _0x6e32f8) public view returns (uint256) {\n        if (_0x378f53._0xfbea08() == 0) {\n            return _0x6e32f8;\n        }\n        uint256 _0xe55c69 = Math._0x816a9b(\n            _0x339c88(), _0x32ca70 + _0x3f7003, _0x32ca70\n        );\n        return Math._0x816a9b(_0x6e32f8, _0x378f53._0xfbea08(), _0xe55c69);\n    }\n\n    function _0x54b1b5(uint256 _0x4dcf68) public view returns (uint256) {\n        if (_0x378f53._0xfbea08() == 0) {\n            return _0x4dcf68;\n        }\n        return Math._0x816a9b(_0x4dcf68, _0x339c88(), _0x378f53._0xfbea08());\n    }\n\n    function _0x339c88() public view returns (uint256) {\n        OracleRecord memory _0xc32b19 = _0x19de20._0xbe38cd();\n        uint256 _0x6589ff = 0;\n        _0x6589ff += _0xabc312;\n        _0x6589ff += _0x644791;\n        _0x6589ff += _0x593449 - _0xc32b19._0x287ed6;\n        _0x6589ff += _0xc32b19._0xe70fe3;\n        _0x6589ff += _0x0fdd9f._0xc146f7();\n        _0x6589ff -= _0x0fdd9f._0xc67d8f();\n        _0x6589ff += _0x40c82c.balance();\n        return _0x6589ff;\n    }\n\n    function _0xe938f5() external payable _0x72e867 {\n        emit ReturnsReceived(msg.value);\n        _0xabc312 += msg.value;\n    }\n\n    function _0xe88efa() external payable _0xb1ce9a {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        _0xabc312 += msg.value;\n    }\n\n    modifier _0x72e867() {\n        if (msg.sender != _0xe9cc77) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier _0xb1ce9a() {\n        if (msg.sender != address(_0x0fdd9f)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier _0xecf4fa() {\n        if (msg.sender != address(_0x40c82c)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier _0x71ba1e(address _0x9f9706) {\n        if (_0x9f9706 == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "_0xe88efa",
        "isUnstakeRequestsAndClaimsPaused": "_0x75822b",
        "cumulativeProcessedDepositAmount": "_0x287ed6",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "_0xc40c2d",
        "currentTotalValidatorBalance": "_0xe70fe3",
        "totalDepositedInValidators": "_0x593449",
        "onlyUnstakeRequestsManager": "_0xecf4fa",
        "initializationBlockNumber": "_0x85537d",
        "_BASIS_POINTS_DENOMINATOR": "_0x32ca70",
        "unstakeRequestWithPermit": "_0x392d32",
        "adjustedTotalControlled": "_0xe55c69",
        "allocatedETHForDeposits": "_0x644791",
        "numInitiatedValidators": "_0xa6cd35",
        "exchangeAdjustmentRate": "_0x3f7003",
        "unstakeRequestsManager": "_0x40c82c",
        "withdrawalCredentials": "_0xf1e881",
        "onlyReturnsAggregator": "_0x72e867",
        "minimumDepositAmount": "_0x135bd0",
        "maximumDepositAmount": "_0x67b92b",
        "_disableInitializers": "_0x0b0634",
        "onlyLiquidityBuffer": "_0xb1ce9a",
        "minimumUnstakeBound": "_0xdbd162",
        "getAvailableBalance": "_0xc146f7",
        "isStakingAllowlist": "_0x9fd48e",
        "cumulativeDrawdown": "_0xc67d8f",
        "maximumMETHSupply": "_0x1817de",
        "returnsAggregator": "_0xe9cc77",
        "minimumStakeBound": "_0x3132ba",
        "allocatorService": "_0x5db6a4",
        "withdrawalWallet": "_0x9e9dd8",
        "initiatorService": "_0x3823b5",
        "safeTransferFrom": "_0x2fb894",
        "depositContract": "_0xc48fb9",
        "amountDeposited": "_0xbb4754",
        "isStakingPaused": "_0x846d69",
        "_unstakeRequest": "_0x9ae6d8",
        "expectedMinimum": "_0x7e9706",
        "depositDataRoot": "_0x5b5670",
        "totalControlled": "_0x339c88",
        "liquidityBuffer": "_0x0fdd9f",
        "unstakeRequest": "_0x9d538a",
        "usedValidators": "_0x999ebd",
        "notZeroAddress": "_0x71ba1e",
        "receiveReturns": "_0xe938f5",
        "mETHMintAmount": "_0x3e7d38",
        "unallocatedETH": "_0xabc312",
        "depositAmount": "_0xcc8fa8",
        "reinitializer": "_0xd83e91",
        "minMETHAmount": "_0x64ca5d",
        "_setRoleAdmin": "_0x73941f",
        "initializeV2": "_0x4812df",
        "latestRecord": "_0xbe38cd",
        "minETHAmount": "_0x672567",
        "ethRequested": "_0x10692f",
        "initializer": "_0x424b65",
        "totalSupply": "_0xfbea08",
        "mETHAmount": "_0x4dcf68",
        "mETHLocked": "_0x5a0a49",
        "_checkRole": "_0x5ff95d",
        "initialize": "_0x0b8bc4",
        "methAmount": "_0x8ccf8c",
        "_grantRole": "_0x0f6232",
        "operatorID": "_0x9cf752",
        "safePermit": "_0xb92b83",
        "keccak256": "_0x5d9f5f",
        "ethAmount": "_0x6e32f8",
        "mETHToETH": "_0x54b1b5",
        "requester": "_0xbd3441",
        "ethToMETH": "_0x7ac8a0",
        "requestID": "_0xc764b3",
        "signature": "_0x1af1fa",
        "deadline": "_0x719fa6",
        "manager": "_0xaaddd4",
        "mulDiv": "_0x816a9b",
        "create": "_0xde35e0",
        "pauser": "_0x34a3cc",
        "exists": "_0x291fdd",
        "oracle": "_0x19de20",
        "record": "_0xc32b19",
        "pubkey": "_0x975407",
        "amount": "_0x2c404b",
        "staker": "_0x2437ac",
        "stake": "_0x197180",
        "admin": "_0x5cf380",
        "total": "_0x6589ff",
        "mETH": "_0x378f53",
        "addr": "_0x9f9706",
        "mint": "_0x63c5a9",
        "init": "_0x7cc04d",
        "lb": "_0x1cce84",
        "id": "_0x5cee3d"
      },
      "changes": [
        "Renamed 91 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_028",
      "transformed_id": "ss_l3_medium_sn_gs_028",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed _0x639245, uint256 _0xc0c89f, uint256 _0xe9c12d);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed _0xa51627, address indexed _0x639245, uint256 _0xc0c89f, uint256 _0xb1a19b);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed _0xa51627, address indexed _0x639245);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed _0xa51627, uint256 indexed _0x8d8902, bytes _0xf47541, uint256 _0xa1305a);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 _0x5ca114);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 _0x5ca114);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 _0x5ca114);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 _0x5ca114);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 _0x5ca114);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 _0xb4ba41, uint256 _0x1b0124);\n    error UnstakeBelowMinimumETHAmount(uint256 _0xc0c89f, uint256 _0x1b0124);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = _0xc33f94(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = _0xc33f94(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = _0xc33f94(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = _0xc33f94(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = _0xc33f94(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = _0xc33f94(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 _0x8d8902;\n        uint256 _0x927c90;\n        bytes _0xf47541;\n        bytes _0x62c097;\n        bytes _0x3abe05;\n        bytes32 _0x391378;\n    }\n\n    mapping(bytes _0xf47541 => bool _0x0fb0db) public _0x4ca502;\n    uint256 public _0xce95b6;\n    uint256 public _0x1d7b41;\n    uint256 public _0xa87783;\n    uint256 public _0xa64842;\n    uint256 public _0x2478df;\n    uint256 public _0xcea1b4;\n    uint16 public _0x5c7cd4;\n    uint16 internal constant _0x8fdd57 = 10_000;\n    uint16 internal constant _0x8cee4b = _0x8fdd57 / 10;\n    uint256 public _0x923c58;\n    uint256 public _0xaa7c09;\n    IDepositContract public _0xd4c36b;\n    IMETH public _0x9ecab8;\n    IOracleReadRecord public _0x1d5b23;\n    IPauserRead public _0x05c9e4;\n    IUnstakeRequestsManager public _0xd9445b;\n    address public _0xcc5346;\n    address public _0x622bf9;\n    bool public _0x3a6b89;\n    uint256 public _0x7d972d;\n    uint256 public _0xe0514f;\n    ILiquidityBuffer public _0x18841d;\n\n    struct Init {\n        address _0x0a1871;\n        address _0xaac58f;\n        address _0x4c2caa;\n        address _0xe25414;\n        address _0x622bf9;\n        address _0xcc5346;\n        IMETH _0x9ecab8;\n        IDepositContract _0xd4c36b;\n        IOracleReadRecord _0x1d5b23;\n        IPauserRead _0x05c9e4;\n        IUnstakeRequestsManager _0xd9445b;\n    }\n\n    constructor() {\n        _0xf2ca9b();\n    }\n\n    function _0x9560cf(Init memory _0xb01807) external _0xb18a61 {\n        __AccessControlEnumerable_init();\n\n        _0xd39816(DEFAULT_ADMIN_ROLE, _0xb01807._0x0a1871);\n        _0xd39816(STAKING_MANAGER_ROLE, _0xb01807._0xaac58f);\n        _0xd39816(ALLOCATOR_SERVICE_ROLE, _0xb01807._0x4c2caa);\n        _0xd39816(INITIATOR_SERVICE_ROLE, _0xb01807._0xe25414);\n\n        _0x878b4d(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _0x878b4d(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        _0x9ecab8 = _0xb01807._0x9ecab8;\n        _0xd4c36b = _0xb01807._0xd4c36b;\n        _0x1d5b23 = _0xb01807._0x1d5b23;\n        _0x05c9e4 = _0xb01807._0x05c9e4;\n        _0x622bf9 = _0xb01807._0x622bf9;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xd9445b = _0xb01807._0xd9445b; }\n        if (1 == 1) { _0xcc5346 = _0xb01807._0xcc5346; }\n\n        _0x2478df = 0.1 ether;\n        _0xcea1b4 = 0.01 ether;\n        _0x923c58 = 32 ether;\n        _0xaa7c09 = 32 ether;\n        _0x3a6b89 = true;\n        if (block.timestamp > 0) { _0x7d972d = block.number; }\n        _0xe0514f = 1024 ether;\n    }\n\n    function _0x5cd769(ILiquidityBuffer _0x3c69ee) public _0x44cff8(2) {\n        _0x18841d = _0x3c69ee;\n    }\n\n    function _0x1df392(uint256 _0x85f8a4) external payable {\n        if (_0x05c9e4._0x7cab70()) {\n            revert Paused();\n        }\n\n        if (_0x3a6b89) {\n            _0xf0d4f4(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < _0x2478df) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 _0xe4b114 = _0xc78ccf(msg.value);\n        if (_0xe4b114 + _0x9ecab8._0x37c5b8() > _0xe0514f) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (_0xe4b114 < _0x85f8a4) {\n            revert StakeBelowMinimumMETHAmount(_0xe4b114, _0x85f8a4);\n        }\n\n        _0xa87783 += msg.value;\n\n        emit Staked(msg.sender, msg.value, _0xe4b114);\n        _0x9ecab8._0x7cbf1a(msg.sender, _0xe4b114);\n    }\n\n    function _0x27146f(uint128 _0xb4ba41, uint128 _0x120dc3) external returns (uint256) {\n        return _0xf43a2d(_0xb4ba41, _0x120dc3);\n    }\n\n    function _0x87b335(\n        uint128 _0xb4ba41,\n        uint128 _0x120dc3,\n        uint256 _0x92fe2c,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable._0xe40672(_0x9ecab8, msg.sender, address(this), _0xb4ba41, _0x92fe2c, v, r, s);\n        return _0xf43a2d(_0xb4ba41, _0x120dc3);\n    }\n\n    function _0xf43a2d(uint128 _0xb4ba41, uint128 _0x120dc3) internal returns (uint256) {\n        if (_0x05c9e4._0xd5ecc6()) {\n            revert Paused();\n        }\n\n        if (_0xb4ba41 < _0xcea1b4) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 _0xc0c89f = uint128(_0xab738e(_0xb4ba41));\n        if (_0xc0c89f < _0x120dc3) {\n            revert UnstakeBelowMinimumETHAmount(_0xc0c89f, _0x120dc3);\n        }\n\n        uint256 _0x95b9df =\n            _0xd9445b._0xc550d2({_0x3c6026: msg.sender, _0xb1a19b: _0xb4ba41, _0x3c5f51: _0xc0c89f});\n        emit UnstakeRequested({_0xa51627: _0x95b9df, _0x639245: msg.sender, _0xc0c89f: _0xc0c89f, _0xb1a19b: _0xb4ba41});\n\n        SafeERC20Upgradeable._0xd9089e(_0x9ecab8, msg.sender, address(_0xd9445b), _0xb4ba41);\n\n        return _0x95b9df;\n    }\n\n    function _0xc78ccf(uint256 _0xc0c89f) public view returns (uint256) {\n        if (_0x9ecab8._0x37c5b8() == 0) {\n            return _0xc0c89f;\n        }\n        uint256 _0xe2e21d = Math._0xcb3594(\n            _0x914733(), _0x8fdd57 + _0x5c7cd4, _0x8fdd57\n        );\n        return Math._0xcb3594(_0xc0c89f, _0x9ecab8._0x37c5b8(), _0xe2e21d);\n    }\n\n    function _0xab738e(uint256 _0xe9c12d) public view returns (uint256) {\n        if (_0x9ecab8._0x37c5b8() == 0) {\n            return _0xe9c12d;\n        }\n        return Math._0xcb3594(_0xe9c12d, _0x914733(), _0x9ecab8._0x37c5b8());\n    }\n\n    function _0x914733() public view returns (uint256) {\n        OracleRecord memory _0xfb8dbd = _0x1d5b23._0x02937f();\n        uint256 _0xb66b59 = 0;\n        _0xb66b59 += _0xa87783;\n        _0xb66b59 += _0xa64842;\n        _0xb66b59 += _0xce95b6 - _0xfb8dbd._0xc29690;\n        _0xb66b59 += _0xfb8dbd._0x2593ef;\n        _0xb66b59 += _0x18841d._0xbde952();\n        _0xb66b59 -= _0x18841d._0x6e508d();\n        _0xb66b59 += _0xd9445b.balance();\n        return _0xb66b59;\n    }\n\n    function _0x10860c() external payable _0x09a780 {\n        emit ReturnsReceived(msg.value);\n        _0xa87783 += msg.value;\n    }\n\n    function _0x220428() external payable _0x3f4f72 {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        _0xa87783 += msg.value;\n    }\n\n    modifier _0x09a780() {\n        if (msg.sender != _0x622bf9) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier _0x3f4f72() {\n        if (msg.sender != address(_0x18841d)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier _0x3450cd() {\n        if (msg.sender != address(_0xd9445b)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier _0x70b285(address _0x1c1a78) {\n        if (_0x1c1a78 == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "_0x220428",
        "isUnstakeRequestsAndClaimsPaused": "_0xd5ecc6",
        "cumulativeProcessedDepositAmount": "_0xc29690",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "_0x8cee4b",
        "currentTotalValidatorBalance": "_0x2593ef",
        "totalDepositedInValidators": "_0xce95b6",
        "onlyUnstakeRequestsManager": "_0x3450cd",
        "initializationBlockNumber": "_0x7d972d",
        "_BASIS_POINTS_DENOMINATOR": "_0x8fdd57",
        "unstakeRequestWithPermit": "_0x87b335",
        "adjustedTotalControlled": "_0xe2e21d",
        "allocatedETHForDeposits": "_0xa64842",
        "numInitiatedValidators": "_0x1d7b41",
        "exchangeAdjustmentRate": "_0x5c7cd4",
        "unstakeRequestsManager": "_0xd9445b",
        "withdrawalCredentials": "_0x62c097",
        "onlyReturnsAggregator": "_0x09a780",
        "minimumDepositAmount": "_0x923c58",
        "maximumDepositAmount": "_0xaa7c09",
        "_disableInitializers": "_0xf2ca9b",
        "onlyLiquidityBuffer": "_0x3f4f72",
        "minimumUnstakeBound": "_0xcea1b4",
        "getAvailableBalance": "_0xbde952",
        "isStakingAllowlist": "_0x3a6b89",
        "cumulativeDrawdown": "_0x6e508d",
        "maximumMETHSupply": "_0xe0514f",
        "returnsAggregator": "_0x622bf9",
        "minimumStakeBound": "_0x2478df",
        "allocatorService": "_0x4c2caa",
        "withdrawalWallet": "_0xcc5346",
        "initiatorService": "_0xe25414",
        "safeTransferFrom": "_0xd9089e",
        "depositContract": "_0xd4c36b",
        "amountDeposited": "_0xa1305a",
        "isStakingPaused": "_0x7cab70",
        "_unstakeRequest": "_0xf43a2d",
        "expectedMinimum": "_0x1b0124",
        "depositDataRoot": "_0x391378",
        "totalControlled": "_0x914733",
        "liquidityBuffer": "_0x18841d",
        "unstakeRequest": "_0x27146f",
        "usedValidators": "_0x4ca502",
        "notZeroAddress": "_0x70b285",
        "receiveReturns": "_0x10860c",
        "mETHMintAmount": "_0xe4b114",
        "unallocatedETH": "_0xa87783",
        "depositAmount": "_0x927c90",
        "reinitializer": "_0x44cff8",
        "minMETHAmount": "_0x85f8a4",
        "_setRoleAdmin": "_0x878b4d",
        "initializeV2": "_0x5cd769",
        "latestRecord": "_0x02937f",
        "minETHAmount": "_0x120dc3",
        "ethRequested": "_0x3c5f51",
        "initializer": "_0xb18a61",
        "totalSupply": "_0x37c5b8",
        "mETHAmount": "_0xe9c12d",
        "mETHLocked": "_0xb1a19b",
        "_checkRole": "_0xf0d4f4",
        "initialize": "_0x9560cf",
        "methAmount": "_0xb4ba41",
        "_grantRole": "_0xd39816",
        "operatorID": "_0x8d8902",
        "safePermit": "_0xe40672",
        "keccak256": "_0xc33f94",
        "ethAmount": "_0xc0c89f",
        "mETHToETH": "_0xab738e",
        "requester": "_0x3c6026",
        "ethToMETH": "_0xc78ccf",
        "requestID": "_0x95b9df",
        "signature": "_0x3abe05",
        "deadline": "_0x92fe2c",
        "manager": "_0xaac58f",
        "mulDiv": "_0xcb3594",
        "create": "_0xc550d2",
        "pauser": "_0x05c9e4",
        "exists": "_0x0fb0db",
        "oracle": "_0x1d5b23",
        "record": "_0xfb8dbd",
        "pubkey": "_0xf47541",
        "amount": "_0x5ca114",
        "staker": "_0x639245",
        "stake": "_0x1df392",
        "admin": "_0x0a1871",
        "total": "_0xb66b59",
        "mETH": "_0x9ecab8",
        "addr": "_0x1c1a78",
        "mint": "_0x7cbf1a",
        "init": "_0xb01807",
        "lb": "_0x3c69ee",
        "id": "_0xa51627"
      },
      "changes": [
        "Renamed 91 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_029",
      "transformed_id": "ss_l3_medium_sn_gs_029",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { Payload } from \"../Payload.sol\";\n\nimport { ICheckpointer, Snapshot } from \"../interfaces/ICheckpointer.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\nimport { ISapient, ISapientCompact } from \"../interfaces/ISapient.sol\";\n\nusing LibBytes for bytes;\nusing Payload for Payload.Decoded;\n\n/// @title BaseSig\n/// @author Agustin Aguilar, Michael Standen, William Hua, Shun Kakinoki\n/// @notice Library for recovering signatures from the base-auth payload\nlibrary BaseSig {\n\n  uint256 internal constant FLAG_SIGNATURE_HASH = 0;\n  uint256 internal constant FLAG_ADDRESS = 1;\n  uint256 internal constant FLAG_SIGNATURE_ERC1271 = 2;\n  uint256 internal constant FLAG_NODE = 3;\n  uint256 internal constant FLAG_BRANCH = 4;\n  uint256 internal constant FLAG_SUBDIGEST = 5;\n  uint256 internal constant FLAG_NESTED = 6;\n  uint256 internal constant FLAG_SIGNATURE_ETH_SIGN = 7;\n  uint256 internal constant FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST = 8;\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT = 9;\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT_COMPACT = 10;\n\n  /// @notice Error thrown when the weight is too low for a chained signature\n  error LowWeightChainedSignature(bytes _0x5e4311, uint256 _0xcd08cd, uint256 _0x5d82c6);\n  /// @notice Error thrown when the ERC1271 signature is invalid\n  error InvalidERC1271Signature(bytes32 _0x42164d, address _0xe4af84, bytes _0x5e4311);\n  /// @notice Error thrown when the checkpoint order is wrong\n  error WrongChainedCheckpointOrder(uint256 _0x0634e6, uint256 _0xd5a87f);\n  /// @notice Error thrown when the snapshot is unused\n  error UnusedSnapshot(Snapshot _0xaffb01);\n  /// @notice Error thrown when the signature flag is invalid\n  error InvalidSignatureFlag(uint256 _0xe3c9df);\n\n  function _0xe502cd(address _0x753b07, uint256 _0x5d82c6) internal pure returns (bytes32) {\n    return _0xa87ec2(abi._0xa6265d(\"Sequence signer:\\n\", _0x753b07, _0x5d82c6));\n  }\n\n  function _0x8d96c6(bytes32 _0x4c3034, uint256 _0xcd08cd, uint256 _0x5d82c6) internal pure returns (bytes32) {\n    return _0xa87ec2(abi._0xa6265d(\"Sequence nested config:\\n\", _0x4c3034, _0xcd08cd, _0x5d82c6));\n  }\n\n  function _0x09a750(address _0x753b07, uint256 _0x5d82c6, bytes32 _0x6a40d6) internal pure returns (bytes32) {\n    return _0xa87ec2(abi._0xa6265d(\"Sequence sapient config:\\n\", _0x753b07, _0x5d82c6, _0x6a40d6));\n  }\n\n  function _0xe1e9e5(\n    bytes32 _0xa4c338\n  ) internal pure returns (bytes32) {\n    return _0xa87ec2(abi._0xa6265d(\"Sequence static digest:\\n\", _0xa4c338));\n  }\n\n  function _0x5f9234(\n    bytes32 _0xe1ade6\n  ) internal pure returns (bytes32) {\n    return _0xa87ec2(abi._0xa6265d(\"Sequence any address subdigest:\\n\", _0xe1ade6));\n  }\n\n  function _0xeb607d(\n    Payload.Decoded memory _0xa7c4e2,\n    bytes calldata _0x5e4311,\n    bool _0x44fb97,\n    address _0xd49d0c\n  ) internal view returns (uint256 _0x304d06, uint256 _0x771862, bytes32 _0x2a3c49, uint256 _0x5fa4df, bytes32 _0xa8b3fb) {\n    // First byte is the signature flag\n    (uint256 _0x5e8106, uint256 _0xb16d4d) = _0x5e4311._0x884e3d();\n\n    // The possible flags are:\n    // - 0000 00XX (bits [1..0]): signature type (00 = normal, 01/11 = chained, 10 = no chain id)\n    // - 000X XX00 (bits [4..2]): checkpoint size (00 = 0 bytes, 001 = 1 byte, 010 = 2 bytes...)\n    // - 00X0 0000 (bit [5]): threshold size (0 = 1 byte, 1 = 2 bytes)\n    // - 0X00 0000 (bit [6]): set if imageHash checkpointer is used\n    // - X000 0000 (bit [7]): reserved by base-auth\n\n    Snapshot memory _0x93bf79;\n\n    // Recover the imageHash checkpointer if any\n    // but checkpointer passed as argument takes precedence\n    // since it can be defined by the chained signatures\n    if (_0x5e8106 & 0x40 == 0x40 && _0xd49d0c == address(0)) {\n      // Override the checkpointer\n      // not ideal, but we don't have much room in the stack\n      (_0xd49d0c, _0xb16d4d) = _0x5e4311._0x2edd46(_0xb16d4d);\n\n      if (!_0x44fb97) {\n        // Next 3 bytes determine the checkpointer data size\n        uint256 _0xe91c40;\n        (_0xe91c40, _0xb16d4d) = _0x5e4311._0xc58f74(_0xb16d4d);\n\n        // Read the checkpointer data\n        bytes memory _0x50e138 = _0x5e4311[_0xb16d4d:_0xb16d4d + _0xe91c40];\n\n        // Call the middleware\n        _0x93bf79 = ICheckpointer(_0xd49d0c)._0xb3433f(address(this), _0x50e138);\n\n        _0xb16d4d += _0xe91c40;\n      }\n    }\n\n    // If signature type is 01 or 11 we do a chained signature\n    if (_0x5e8106 & 0x01 == 0x01) {\n      return _0x67d80d(_0xa7c4e2, _0xd49d0c, _0x93bf79, _0x5e4311[_0xb16d4d:]);\n    }\n\n    // If the signature type is 10 we do a no chain id signature\n    _0xa7c4e2._0xee6193 = _0x5e8106 & 0x02 == 0x02;\n\n    {\n      // Recover the checkpoint using the size defined by the flag\n      uint256 _0xdee3b4 = (_0x5e8106 & 0x1c) >> 2;\n      (_0x5fa4df, _0xb16d4d) = _0x5e4311._0x3dcb48(_0xb16d4d, _0xdee3b4);\n    }\n\n    // Recover the threshold, using the flag for the size\n    {\n      uint256 _0xc1db23 = ((_0x5e8106 & 0x20) >> 5) + 1;\n      (_0x304d06, _0xb16d4d) = _0x5e4311._0x3dcb48(_0xb16d4d, _0xc1db23);\n    }\n\n    // Recover the tree\n    _0xa8b3fb = _0xa7c4e2._0xd94ebd();\n    (_0x771862, _0x2a3c49) = _0x3808cf(_0xa7c4e2, _0xa8b3fb, _0x5e4311[_0xb16d4d:]);\n\n    _0x2a3c49 = LibOptim._0xf2f208(_0x2a3c49, bytes32(_0x304d06));\n    _0x2a3c49 = LibOptim._0xf2f208(_0x2a3c49, bytes32(_0x5fa4df));\n    _0x2a3c49 = LibOptim._0xf2f208(_0x2a3c49, bytes32(uint256(uint160(_0xd49d0c))));\n\n    // If the snapshot is used, either the imageHash must match\n    // or the checkpoint must be greater than the snapshot checkpoint\n    if (_0x93bf79._0x2a3c49 != bytes32(0) && _0x93bf79._0x2a3c49 != _0x2a3c49 && _0x5fa4df <= _0x93bf79._0x5fa4df) {\n      revert UnusedSnapshot(_0x93bf79);\n    }\n  }\n\n  function _0x67d80d(\n    Payload.Decoded memory _0xa7c4e2,\n    address _0xd49d0c,\n    Snapshot memory _0xaffb01,\n    bytes calldata _0x5e4311\n  ) internal view returns (uint256 _0x304d06, uint256 _0x771862, bytes32 _0x2a3c49, uint256 _0x5fa4df, bytes32 _0xa8b3fb) {\n    Payload.Decoded memory _0x62ac50;\n    _0x62ac50._0x1f529e = Payload.KIND_CONFIG_UPDATE;\n\n    uint256 _0xb16d4d;\n    uint256 _0x2194fc = type(uint256)._0xf40cde;\n\n    while (_0xb16d4d < _0x5e4311.length) {\n      uint256 _0xfd4493;\n\n      {\n        uint256 _0x74ed7d;\n        (_0x74ed7d, _0xb16d4d) = _0x5e4311._0xc58f74(_0xb16d4d);\n        _0xfd4493 = _0x74ed7d + _0xb16d4d;\n      }\n\n      address _0x40e96c = _0xfd4493 == _0x5e4311.length ? _0xd49d0c : address(0);\n\n      if (_0x2194fc == type(uint256)._0xf40cde) {\n        (_0x304d06, _0x771862, _0x2a3c49, _0x5fa4df, _0xa8b3fb) =\n          _0xeb607d(_0xa7c4e2, _0x5e4311[_0xb16d4d:_0xfd4493], true, _0x40e96c);\n      } else {\n        (_0x304d06, _0x771862, _0x2a3c49, _0x5fa4df,) =\n          _0xeb607d(_0x62ac50, _0x5e4311[_0xb16d4d:_0xfd4493], true, _0x40e96c);\n      }\n\n      if (_0x771862 < _0x304d06) {\n        revert LowWeightChainedSignature(_0x5e4311[_0xb16d4d:_0xfd4493], _0x304d06, _0x771862);\n      }\n      _0xb16d4d = _0xfd4493;\n\n      if (_0xaffb01._0x2a3c49 == _0x2a3c49) {\n        _0xaffb01._0x2a3c49 = bytes32(0);\n      }\n\n      if (_0x5fa4df >= _0x2194fc) {\n        revert WrongChainedCheckpointOrder(_0x5fa4df, _0x2194fc);\n      }\n\n      _0x62ac50._0x2a3c49 = _0x2a3c49;\n      _0x2194fc = _0x5fa4df;\n    }\n\n    if (_0xaffb01._0x2a3c49 != bytes32(0) && _0x5fa4df <= _0xaffb01._0x5fa4df) {\n      revert UnusedSnapshot(_0xaffb01);\n    }\n  }\n\n  function _0x3808cf(\n    Payload.Decoded memory _0xa7c4e2,\n    bytes32 _0x42164d,\n    bytes calldata _0x5e4311\n  ) internal view returns (uint256 _0x771862, bytes32 _0x8636bb) {\n    unchecked {\n      uint256 _0xb16d4d;\n\n      // Iterate until the image is completed\n      while (_0xb16d4d < _0x5e4311.length) {\n        // The first byte is half flag (the top nibble)\n        // and the second set of 4 bits can freely be used by the part\n\n        // Read next item type\n        uint256 _0x486b66;\n        (_0x486b66, _0xb16d4d) = _0x5e4311._0xe02997(_0xb16d4d);\n\n        // The top 4 bits are the flag\n        uint256 _0x34e945 = (_0x486b66 & 0xf0) >> 4;\n\n        // Signature hash (0x00)\n        if (_0x34e945 == FLAG_SIGNATURE_HASH) {\n          // Free bits layout:\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, ..., 1111 = 15)\n          // We read 64 bytes for an ERC-2098 compact signature (r, yParityAndS).\n          // The top bit of yParityAndS is yParity, the remaining 255 bits are s.\n\n          uint8 _0x21b150 = uint8(_0x486b66 & 0x0f);\n          if (_0x21b150 == 0) {\n            (_0x21b150, _0xb16d4d) = _0x5e4311._0xe02997(_0xb16d4d);\n          }\n\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0xb16d4d) = _0x5e4311._0xa7181e(_0xb16d4d);\n\n          address _0x208f29 = _0x4e263e(_0x42164d, v, r, s);\n\n          _0x771862 += _0x21b150;\n          bytes32 _0xfd524a = _0xe502cd(_0x208f29, _0x21b150);\n          _0x8636bb = _0x8636bb != bytes32(0) ? LibOptim._0xf2f208(_0x8636bb, _0xfd524a) : _0xfd524a;\n          continue;\n        }\n\n        // Address (0x01) (without signature)\n        if (_0x34e945 == FLAG_ADDRESS) {\n          // Free bits layout:\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, 0010 = 2, ...)\n\n          // Read weight\n          uint8 _0x21b150 = uint8(_0x486b66 & 0x0f);\n          if (_0x21b150 == 0) {\n            (_0x21b150, _0xb16d4d) = _0x5e4311._0xe02997(_0xb16d4d);\n          }\n\n          // Read address\n          address _0x208f29;\n          (_0x208f29, _0xb16d4d) = _0x5e4311._0x2edd46(_0xb16d4d);\n\n          // Compute the merkle root WITHOUT adding the weight\n          bytes32 _0xfd524a = _0xe502cd(_0x208f29, _0x21b150);\n          _0x8636bb = _0x8636bb != bytes32(0) ? LibOptim._0xf2f208(_0x8636bb, _0xfd524a) : _0xfd524a;\n          continue;\n        }\n\n        // Signature ERC1271 (0x02)\n        if (_0x34e945 == FLAG_SIGNATURE_ERC1271) {\n          // Free bits layout:\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Read weight\n          uint8 _0x21b150 = uint8(_0x486b66 & 0x03);\n          if (_0x21b150 == 0) {\n            (_0x21b150, _0xb16d4d) = _0x5e4311._0xe02997(_0xb16d4d);\n          }\n\n          // Read signer\n          address _0x208f29;\n          (_0x208f29, _0xb16d4d) = _0x5e4311._0x2edd46(_0xb16d4d);\n\n          // Read signature size\n          uint256 _0x211f01 = uint8(_0x486b66 & 0x0c) >> 2;\n          uint256 _0xd9bf28;\n          (_0xd9bf28, _0xb16d4d) = _0x5e4311._0x3dcb48(_0xb16d4d, _0x211f01);\n\n          // Read dynamic size signature\n          uint256 _0xfd4493 = _0xb16d4d + _0xd9bf28;\n\n          // Call the ERC1271 contract to check if the signature is valid\n          if (IERC1271(_0x208f29)._0x36a754(_0x42164d, _0x5e4311[_0xb16d4d:_0xfd4493]) != IERC1271_MAGIC_VALUE_HASH) {\n            revert InvalidERC1271Signature(_0x42164d, _0x208f29, _0x5e4311[_0xb16d4d:_0xfd4493]);\n          }\n          _0xb16d4d = _0xfd4493;\n          // Add the weight and compute the merkle root\n          _0x771862 += _0x21b150;\n          bytes32 _0xfd524a = _0xe502cd(_0x208f29, _0x21b150);\n          _0x8636bb = _0x8636bb != bytes32(0) ? LibOptim._0xf2f208(_0x8636bb, _0xfd524a) : _0xfd524a;\n          continue;\n        }\n\n        // Node (0x03)\n        if (_0x34e945 == FLAG_NODE) {\n          // Free bits left unused\n\n          // Read node hash\n          bytes32 _0xfd524a;\n          (_0xfd524a, _0xb16d4d) = _0x5e4311._0x80c542(_0xb16d4d);\n          _0x8636bb = _0x8636bb != bytes32(0) ? LibOptim._0xf2f208(_0x8636bb, _0xfd524a) : _0xfd524a;\n          continue;\n        }\n\n        // Branch (0x04)\n        if (_0x34e945 == FLAG_BRANCH) {\n          // Free bits layout:\n          // - XXXX : Size size (0000 = 0 byte, 0001 = 1 byte, 0010 = 2 bytes, ...)\n\n          // Read size\n          uint256 _0x211f01 = uint8(_0x486b66 & 0x0f);\n          uint256 _0xd9bf28;\n          (_0xd9bf28, _0xb16d4d) = _0x5e4311._0x3dcb48(_0xb16d4d, _0x211f01);\n\n          // Enter a branch of the signature merkle tree\n          uint256 _0xfd4493 = _0xb16d4d + _0xd9bf28;\n\n          (uint256 _0xaa5ca8, bytes32 _0xfd524a) = _0x3808cf(_0xa7c4e2, _0x42164d, _0x5e4311[_0xb16d4d:_0xfd4493]);\n          _0xb16d4d = _0xfd4493;\n\n          _0x771862 += _0xaa5ca8;\n          _0x8636bb = LibOptim._0xf2f208(_0x8636bb, _0xfd524a);\n          continue;\n        }\n\n        // Nested (0x06)\n        if (_0x34e945 == FLAG_NESTED) {\n          // Unused free bits:\n          // - XX00 : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n          // - 00XX : Threshold (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Enter a branch of the signature merkle tree\n          // but with an internal threshold and an external fixed weight\n          uint256 _0xc15bad = uint8(_0x486b66 & 0x0c) >> 2;\n          if (_0xc15bad == 0) {\n            (_0xc15bad, _0xb16d4d) = _0x5e4311._0xe02997(_0xb16d4d);\n          }\n\n          uint256 _0x45bad0 = uint8(_0x486b66 & 0x03);\n          if (_0x45bad0 == 0) {\n            (_0x45bad0, _0xb16d4d) = _0x5e4311._0xdcfe87(_0xb16d4d);\n          }\n\n          uint256 _0xd9bf28;\n          (_0xd9bf28, _0xb16d4d) = _0x5e4311._0xc58f74(_0xb16d4d);\n          uint256 _0xfd4493 = _0xb16d4d + _0xd9bf28;\n\n          (uint256 _0xbb487d, bytes32 _0xa258b0) = _0x3808cf(_0xa7c4e2, _0x42164d, _0x5e4311[_0xb16d4d:_0xfd4493]);\n          _0xb16d4d = _0xfd4493;\n\n          if (_0xbb487d >= _0x45bad0) {\n            _0x771862 += _0xc15bad;\n          }\n\n          bytes32 _0xfd524a = _0x8d96c6(_0xa258b0, _0x45bad0, _0xc15bad);\n          _0x8636bb = _0x8636bb != bytes32(0) ? LibOptim._0xf2f208(_0x8636bb, _0xfd524a) : _0xfd524a;\n          continue;\n        }\n\n        // Subdigest (0x05)\n        if (_0x34e945 == FLAG_SUBDIGEST) {\n          // Free bits left unused\n\n          // A hardcoded always accepted digest\n          // it pushes the weight to the maximum\n          bytes32 _0xdcc809;\n          (_0xdcc809, _0xb16d4d) = _0x5e4311._0x80c542(_0xb16d4d);\n          if (_0xdcc809 == _0x42164d) {\n            _0x771862 = type(uint256)._0xf40cde;\n          }\n\n          bytes32 _0xfd524a = _0xe1e9e5(_0xdcc809);\n          _0x8636bb = _0x8636bb != bytes32(0) ? LibOptim._0xf2f208(_0x8636bb, _0xfd524a) : _0xfd524a;\n          continue;\n        }\n\n        // Signature ETH Sign (0x07)\n        if (_0x34e945 == FLAG_SIGNATURE_ETH_SIGN) {\n          // Free bits layout:\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, ..., 1111 = 15)\n          // We read 64 bytes for an ERC-2098 compact signature (r, yParityAndS).\n          // The top bit of yParityAndS is yParity, the remaining 255 bits are s.\n\n          uint8 _0x21b150 = uint8(_0x486b66 & 0x0f);\n          if (_0x21b150 == 0) {\n            (_0x21b150, _0xb16d4d) = _0x5e4311._0xe02997(_0xb16d4d);\n          }\n\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0xb16d4d) = _0x5e4311._0xa7181e(_0xb16d4d);\n\n          address _0x208f29 = _0x4e263e(_0xa87ec2(abi._0xa6265d(\"\\x19Ethereum Signed Message:\\n32\", _0x42164d)), v, r, s);\n\n          _0x771862 += _0x21b150;\n          bytes32 _0xfd524a = _0xe502cd(_0x208f29, _0x21b150);\n          _0x8636bb = _0x8636bb != bytes32(0) ? LibOptim._0xf2f208(_0x8636bb, _0xfd524a) : _0xfd524a;\n          continue;\n        }\n\n        // Signature Any address subdigest (0x08)\n        // similar to subdigest, but allows for counter-factual payloads\n        if (_0x34e945 == FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST) {\n          // Free bits left unused\n\n          // A hardcoded always accepted digest\n          // it pushes the weight to the maximum\n          bytes32 _0xdcc809;\n          (_0xdcc809, _0xb16d4d) = _0x5e4311._0x80c542(_0xb16d4d);\n          bytes32 _0xe3146c = _0xa7c4e2._0xedadcc(address(0));\n          if (_0xdcc809 == _0xe3146c) {\n            _0x771862 = type(uint256)._0xf40cde;\n          }\n\n          bytes32 _0xfd524a = _0x5f9234(_0xdcc809);\n          _0x8636bb = _0x8636bb != bytes32(0) ? LibOptim._0xf2f208(_0x8636bb, _0xfd524a) : _0xfd524a;\n          continue;\n        }\n\n        // Signature Sapient (0x09)\n        if (_0x34e945 == FLAG_SIGNATURE_SAPIENT) {\n          // Free bits layout:\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Read signer and weight\n          uint8 _0x21b150 = uint8(_0x486b66 & 0x03);\n          if (_0x21b150 == 0) {\n            (_0x21b150, _0xb16d4d) = _0x5e4311._0xe02997(_0xb16d4d);\n          }\n\n          address _0x208f29;\n          (_0x208f29, _0xb16d4d) = _0x5e4311._0x2edd46(_0xb16d4d);\n\n          // Read signature size\n          uint256 _0xd9bf28;\n          {\n            uint256 _0x211f01 = uint8(_0x486b66 & 0x0c) >> 2;\n            (_0xd9bf28, _0xb16d4d) = _0x5e4311._0x3dcb48(_0xb16d4d, _0x211f01);\n          }\n\n          // Read dynamic size signature\n          uint256 _0xfd4493 = _0xb16d4d + _0xd9bf28;\n\n          // Call the ERC1271 contract to check if the signature is valid\n          bytes32 _0xdeac94 = ISapient(_0x208f29)._0x4ee4da(_0xa7c4e2, _0x5e4311[_0xb16d4d:_0xfd4493]);\n          _0xb16d4d = _0xfd4493;\n\n          // Add the weight and compute the merkle root\n          _0x771862 += _0x21b150;\n          bytes32 _0xfd524a = _0x09a750(_0x208f29, _0x21b150, _0xdeac94);\n          _0x8636bb = _0x8636bb != bytes32(0) ? LibOptim._0xf2f208(_0x8636bb, _0xfd524a) : _0xfd524a;\n          continue;\n        }\n\n        // Signature Sapient Compact (0x0A)\n        if (_0x34e945 == FLAG_SIGNATURE_SAPIENT_COMPACT) {\n          // Free bits layout:\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Read signer and weight\n          uint8 _0x21b150 = uint8(_0x486b66 & 0x03);\n          if (_0x21b150 == 0) {\n            (_0x21b150, _0xb16d4d) = _0x5e4311._0xe02997(_0xb16d4d);\n          }\n\n          address _0x208f29;\n          (_0x208f29, _0xb16d4d) = _0x5e4311._0x2edd46(_0xb16d4d);\n\n          // Read signature size\n          uint256 _0x211f01 = uint8(_0x486b66 & 0x0c) >> 2;\n          uint256 _0xd9bf28;\n          (_0xd9bf28, _0xb16d4d) = _0x5e4311._0x3dcb48(_0xb16d4d, _0x211f01);\n\n          // Read dynamic size signature\n          uint256 _0xfd4493 = _0xb16d4d + _0xd9bf28;\n\n          // Call the Sapient contract to check if the signature is valid\n          bytes32 _0xdeac94 =\n            ISapientCompact(_0x208f29)._0xf6edbd(_0x42164d, _0x5e4311[_0xb16d4d:_0xfd4493]);\n          _0xb16d4d = _0xfd4493;\n          // Add the weight and compute the merkle root\n          _0x771862 += _0x21b150;\n          bytes32 _0xfd524a = _0x09a750(_0x208f29, _0x21b150, _0xdeac94);\n          _0x8636bb = _0x8636bb != bytes32(0) ? LibOptim._0xf2f208(_0x8636bb, _0xfd524a) : _0xfd524a;\n          continue;\n        }\n\n        revert InvalidSignatureFlag(_0x34e945);\n      }\n    }\n  }\n\n}",
      "rename_map": {
        "recoverSapientSignatureCompact": "_0xf6edbd",
        "_leafForAnyAddressSubdigest": "_0x5f9234",
        "_leafForHardcodedSubdigest": "_0xe1e9e5",
        "_leafForAddressAndWeight": "_0xe502cd",
        "recoverSapientSignature": "_0x4ee4da",
        "checkpointerDataSize": "_0xe91c40",
        "_anyAddressSubdigest": "_0xe1ade6",
        "_ignoreCheckpointer": "_0x44fb97",
        "internalThreshold": "_0x45bad0",
        "isValidSignature": "_0x36a754",
        "checkpointerData": "_0x50e138",
        "sapientImageHash": "_0xdeac94",
        "anyAddressOpHash": "_0xe3146c",
        "_leafForSapient": "_0x09a750",
        "_nextCheckpoint": "_0x0634e6",
        "_leafForNested": "_0x8d96c6",
        "checkpointSize": "_0xdee3b4",
        "prevCheckpoint": "_0x2194fc",
        "internalWeight": "_0xbb487d",
        "recoverChained": "_0x67d80d",
        "readRSVCompact": "_0xa7181e",
        "readFirstUint8": "_0x884e3d",
        "externalWeight": "_0xc15bad",
        "_checkpointer": "_0xd49d0c",
        "signatureFlag": "_0x5e8106",
        "thresholdSize": "_0xc1db23",
        "linkedPayload": "_0x62ac50",
        "recoverBranch": "_0x3808cf",
        "internalRoot": "_0xa258b0",
        "encodePacked": "_0xa6265d",
        "checkpointer": "_0x40e96c",
        "readBytes32": "_0x80c542",
        "snapshotFor": "_0xb3433f",
        "readAddress": "_0x2edd46",
        "_checkpoint": "_0xd5a87f",
        "fkeccak256": "_0xf2f208",
        "readUint16": "_0xdcfe87",
        "addrWeight": "_0x21b150",
        "_signature": "_0x5e4311",
        "_imageHash": "_0x6a40d6",
        "readUint24": "_0xc58f74",
        "checkpoint": "_0x5fa4df",
        "_threshold": "_0xcd08cd",
        "_subdigest": "_0xa4c338",
        "threshold": "_0x304d06",
        "keccak256": "_0xa87ec2",
        "firstByte": "_0x486b66",
        "hardcoded": "_0xdcc809",
        "noChainId": "_0xee6193",
        "_snapshot": "_0xaffb01",
        "ecrecover": "_0x4e263e",
        "readUintX": "_0x3dcb48",
        "imageHash": "_0x2a3c49",
        "readUint8": "_0xe02997",
        "sizeSize": "_0x211f01",
        "_payload": "_0xa7c4e2",
        "snapshot": "_0x93bf79",
        "hashFor": "_0xedadcc",
        "nrindex": "_0xfd4493",
        "recover": "_0xeb607d",
        "_signer": "_0xe4af84",
        "sigSize": "_0x74ed7d",
        "_opHash": "_0x42164d",
        "_weight": "_0x5d82c6",
        "nweight": "_0xaa5ca8",
        "weight": "_0x771862",
        "rindex": "_0xb16d4d",
        "opHash": "_0xa8b3fb",
        "_node": "_0x4c3034",
        "_addr": "_0x753b07",
        "_flag": "_0xe3c9df",
        "root": "_0x8636bb",
        "hash": "_0xd94ebd",
        "node": "_0xfd524a",
        "addr": "_0x208f29",
        "size": "_0xd9bf28",
        "flag": "_0x34e945",
        "kind": "_0x1f529e",
        "max": "_0xf40cde"
      },
      "changes": [
        "Renamed 79 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_030",
      "transformed_id": "ss_l3_medium_sn_gs_030",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibOptim } from \"../utils/LibOptim.sol\";\nimport { Nonce } from \"./Nonce.sol\";\nimport { Payload } from \"./Payload.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { BaseAuth } from \"./auth/BaseAuth.sol\";\nimport { IDelegatedExtension } from \"./interfaces/IDelegatedExtension.sol\";\n\n/// @title Calls\n/// @author Agustin Aguilar, Michael Standen, William Hua\n/// @notice Contract for executing calls\nabstract contract Calls is ReentrancyGuard, BaseAuth, Nonce {\n\n  /// @notice Emitted when a call succeeds\n  event CallSucceeded(bytes32 _0xfceda8, uint256 _0x1442d0);\n  /// @notice Emitted when a call fails\n  event CallFailed(bytes32 _0xfceda8, uint256 _0x1442d0, bytes _0x445900);\n  /// @notice Emitted when a call is aborted\n  event CallAborted(bytes32 _0xfceda8, uint256 _0x1442d0, bytes _0x445900);\n  /// @notice Emitted when a call is skipped\n  event CallSkipped(bytes32 _0xfceda8, uint256 _0x1442d0);\n\n  /// @notice Error thrown when a call reverts\n  error Reverted(Payload.Decoded _0xa19381, uint256 _0x1442d0, bytes _0x445900);\n  /// @notice Error thrown when a signature is invalid\n  error InvalidSignature(Payload.Decoded _0xa19381, bytes _0xe01a65);\n  /// @notice Error thrown when there is not enough gas\n  error NotEnoughGas(Payload.Decoded _0xa19381, uint256 _0x1442d0, uint256 _0x71617b);\n\n  /// @notice Execute a call\n  /// @param _payload The payload\n  /// @param _signature The signature\n  function _0x1d96fe(bytes calldata _0xa19381, bytes calldata _0xe01a65) external payable virtual _0xfc2f5d {\n    uint256 _0xf4877c = _0x229f60();\n    Payload.Decoded memory _0x4d5267 = Payload._0x7e0b9c(_0xa19381);\n\n    _0x742a76(_0x4d5267._0xb00f80, _0x4d5267._0xa3c250);\n    (bool _0xc67043, bytes32 _0xe857fc) = _0x45953f(_0x4d5267, _0xe01a65);\n\n    if (!_0xc67043) {\n      revert InvalidSignature(_0x4d5267, _0xe01a65);\n    }\n\n    _0x1b64db(_0xf4877c, _0xe857fc, _0x4d5267);\n  }\n\n  /// @notice Execute a call\n  /// @dev Callable only by the contract itself\n  /// @param _payload The payload\n  function _0xdff47d(\n    bytes calldata _0xa19381\n  ) external payable virtual _0x8d7fd9 {\n    uint256 _0xf4877c = _0x229f60();\n    Payload.Decoded memory _0x4d5267 = Payload._0x7e0b9c(_0xa19381);\n    bytes32 _0xe857fc = Payload._0x0a4842(_0x4d5267);\n    _0x1b64db(_0xf4877c, _0xe857fc, _0x4d5267);\n  }\n\n  function _0x1b64db(uint256 _0x347340, bytes32 _0xfceda8, Payload.Decoded memory _0x02dee9) private {\n    bool _0x88b61b = false;\n\n    uint256 _0x1a2196 = _0x02dee9._0x041695.length;\n    for (uint256 i = 0; i < _0x1a2196; i++) {\n      Payload.Call memory call = _0x02dee9._0x041695[i];\n\n      // Skip onlyFallback calls if no error occurred\n      if (call._0x603bf6 && !_0x88b61b) {\n        emit CallSkipped(_0xfceda8, i);\n        continue;\n      }\n\n      // Reset the error flag\n      // onlyFallback calls only apply when the immediately preceding transaction fails\n      _0x88b61b = false;\n\n      uint256 gasLimit = call.gasLimit;\n      if (gasLimit != 0 && _0x229f60() < gasLimit) {\n        revert NotEnoughGas(_0x02dee9, i, _0x229f60());\n      }\n\n      bool _0xe2e6b0;\n      if (call.delegateCall) {\n        (_0xe2e6b0) = LibOptim.delegatecall(\n          call._0x416879,\n          gasLimit == 0 ? _0x229f60() : gasLimit,\n          abi._0x4f07ab(\n            IDelegatedExtension._0x6a402a.selector,\n            _0xfceda8,\n            _0x347340,\n            i,\n            _0x1a2196,\n            _0x02dee9._0xb00f80,\n            call.data\n          )\n        );\n      } else {\n        (_0xe2e6b0) = LibOptim.call(call._0x416879, call.value, gasLimit == 0 ? _0x229f60() : gasLimit, call.data);\n      }\n\n      if (!_0xe2e6b0) {\n        if (call.behaviorOnError == Payload.BEHAVIOR_IGNORE_ERROR) {\n          if (block.timestamp > 0) { _0x88b61b = true; }\n          emit CallFailed(_0xfceda8, i, LibOptim._0xb63130());\n          continue;\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_REVERT_ON_ERROR) {\n          revert Reverted(_0x02dee9, i, LibOptim._0xb63130());\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_ABORT_ON_ERROR) {\n          emit CallAborted(_0xfceda8, i, LibOptim._0xb63130());\n          break;\n        }\n      }\n\n      emit CallSucceeded(_0xfceda8, i);\n    }\n  }\n\n}",
      "rename_map": {
        "handleSequenceDelegateCall": "_0x6a402a",
        "signatureValidation": "_0x45953f",
        "encodeWithSelector": "_0x4f07ab",
        "fromPackedCalls": "_0x7e0b9c",
        "_consumeNonce": "_0x742a76",
        "nonReentrant": "_0xfc2f5d",
        "_startingGas": "_0x347340",
        "onlyFallback": "_0x603bf6",
        "selfExecute": "_0xdff47d",
        "_returnData": "_0x445900",
        "startingGas": "_0xf4877c",
        "_signature": "_0xe01a65",
        "returnData": "_0xb63130",
        "errorFlag": "_0x88b61b",
        "numCalls": "_0x1a2196",
        "_decoded": "_0x02dee9",
        "_payload": "_0xa19381",
        "_gasLeft": "_0x71617b",
        "_execute": "_0x1b64db",
        "onlySelf": "_0x8d7fd9",
        "execute": "_0x1d96fe",
        "_opHash": "_0xfceda8",
        "success": "_0xe2e6b0",
        "decoded": "_0x4d5267",
        "isValid": "_0xc67043",
        "gasleft": "_0x229f60",
        "opHash": "_0xe857fc",
        "_index": "_0x1442d0",
        "nonce": "_0xa3c250",
        "calls": "_0x041695",
        "space": "_0xb00f80",
        "hash": "_0x0a4842",
        "to": "_0x416879"
      },
      "changes": [
        "Renamed 33 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_031",
      "transformed_id": "ss_l3_medium_sn_gs_031",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from \"../../modules/Payload.sol\";\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { SessionErrors } from \"./SessionErrors.sol\";\nimport { SessionPermissions } from \"./explicit/IExplicitSessionManager.sol\";\nimport { LibPermission, Permission } from \"./explicit/Permission.sol\";\nimport { Attestation, LibAttestation } from \"./implicit/Attestation.sol\";\n\nusing LibBytes for bytes;\nusing LibAttestation for Attestation;\n\n/// @title SessionSig\n/// @author Michael Standen, Agustin Aguilar\n/// @notice Library for session signatures\nlibrary SessionSig {\n\n  uint256 internal constant FLAG_PERMISSIONS = 0;\n  uint256 internal constant FLAG_NODE = 1;\n  uint256 internal constant FLAG_BRANCH = 2;\n  uint256 internal constant FLAG_BLACKLIST = 3;\n  uint256 internal constant FLAG_IDENTITY_SIGNER = 4;\n\n  uint256 internal constant MIN_ENCODED_PERMISSION_SIZE = 94;\n\n  /// @notice Call signature for a specific session\n  /// @param isImplicit If the call is implicit\n  /// @param sessionSigner Address of the session signer\n  /// @param sessionPermission Session permission for explicit calls\n  /// @param attestation Attestation for implicit calls\n  struct CallSignature {\n    bool _0xc31676;\n    address _0x03befe;\n    uint8 _0x3cf356;\n    Attestation _0x4629e9;\n  }\n\n  /// @notice Decoded signature for a specific session\n  /// @param imageHash Derived configuration image hash\n  /// @param identitySigner Identity signer address\n  /// @param implicitBlacklist Implicit blacklist addresses\n  /// @param sessionPermissions Session permissions for each explicit signer\n  /// @param callSignatures Call signatures for each call in the payload\n  struct DecodedSignature {\n    bytes32 _0x809315;\n    address _0x51e578;\n    address[] _0x6f2809;\n    SessionPermissions[] _0xcdc877;\n    CallSignature[] _0x192d9f;\n  }\n\n  /// @notice Recovers the decoded signature from the encodedSignature bytes.\n  /// @dev The encoded layout is conceptually separated into three parts:\n  ///  1) Session Configuration\n  ///  2) A reusable list of Attestations + their identity signatures (if any implicit calls exist)\n  ///  3) Call Signatures (one per call in the payload)\n  ///\n  /// High-level layout:\n  ///  - session_configuration: [uint24 size, <Session Configuration encoded>]\n  ///  - attestation_list: [uint8 attestationCount, (Attestation + identitySig) * attestationCount]\n  ///    (new section to allow reusing the same Attestation across multiple calls)\n  ///  - call_signatures: [<CallSignature encoded>] - Size is payload.calls.length\n  ///    - call_signature: [uint8 call_flags, <session_signature>]\n  ///      - call_flags: [bool is_implicit (MSB), 7 bits encoded]\n  ///      - if call_flags.is_implicit.MSB == 1:\n  ///         - attestation_index: [uint8 index into the attestation list (7 bits of the call_flags)]\n  ///         - session_signature: [r, s, v (compact)]\n  ///      - if call_flags.is_implicit.MSB == 0:\n  ///         - session_permission: [uint8 (7 bits of the call_flags)]\n  ///         - session_signature: [r, s, v (compact)]\n  function _0x04ed19(\n    Payload.Decoded calldata _0x869304,\n    bytes calldata _0x497a6c\n  ) internal view returns (DecodedSignature memory sig) {\n    uint256 _0x8e70f2 = 0;\n    bool _0x48fa90;\n\n    // ----- Session Configuration -----\n    {\n      // First read the length of the session configuration bytes (uint24)\n      uint256 _0xdba23d;\n      (_0xdba23d, _0x8e70f2) = _0x497a6c._0x2870ab(_0x8e70f2);\n\n      // Recover the session configuration\n      (sig, _0x48fa90) = _0xb2a921(_0x497a6c[_0x8e70f2:_0x8e70f2 + _0xdba23d]);\n      _0x8e70f2 += _0xdba23d;\n\n      // Identity signer must be set\n      if (sig._0x51e578 == address(0)) {\n        revert SessionErrors.InvalidIdentitySigner();\n      }\n    }\n\n    // ----- Attestations for implicit calls -----\n    Attestation[] memory _0x228312;\n    {\n      uint8 _0xc53465;\n      (_0xc53465, _0x8e70f2) = _0x497a6c._0xb14c13(_0x8e70f2);\n      _0x228312 = new Attestation[](_0xc53465);\n      // Parse each attestation and its identity signature, store in memory\n      for (uint256 i = 0; i < _0xc53465; i++) {\n        Attestation memory _0xbabbae;\n        (_0xbabbae, _0x8e70f2) = LibAttestation._0x5dbb31(_0x497a6c, _0x8e70f2);\n\n        // Read the identity signature that approves this attestation\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0x8e70f2) = _0x497a6c._0x58437f(_0x8e70f2);\n\n          // Recover the identity signer from the attestation identity signature\n          bytes32 _0x857f58 = _0xbabbae._0xa058ba();\n          address _0xc47881 = _0x65bc99(_0x857f58, v, r, s);\n          if (_0xc47881 != sig._0x51e578) {\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n        }\n\n        _0x228312[i] = _0xbabbae;\n      }\n\n      // If we have any implicit calls, we must have a blacklist in the configuration\n      if (_0xc53465 > 0 && !_0x48fa90) {\n        revert SessionErrors.InvalidBlacklist();\n      }\n    }\n\n    // ----- Call Signatures -----\n    {\n      uint256 _0x6375dc = _0x869304._0x62f790.length;\n      sig._0x192d9f = new CallSignature[](_0x6375dc);\n\n      for (uint256 i = 0; i < _0x6375dc; i++) {\n        CallSignature memory _0x86d864;\n\n        // Determine signature type\n        {\n          uint8 _0x9082ad;\n          (_0x9082ad, _0x8e70f2) = _0x497a6c._0xb14c13(_0x8e70f2);\n          _0x86d864._0xc31676 = (_0x9082ad & 0x80) != 0;\n\n          if (_0x86d864._0xc31676) {\n            // Read attestation index from the call_flags\n            uint8 _0x76ef09 = uint8(_0x9082ad & 0x7f);\n\n            // Check if the attestation index is out of range\n            if (_0x76ef09 >= _0x228312.length) {\n              revert SessionErrors.InvalidAttestation();\n            }\n\n            // Set the attestation\n            _0x86d864._0x4629e9 = _0x228312[_0x76ef09];\n          } else {\n            // Session permission index is the entire byte, top bit is 0 => no conflict\n            _0x86d864._0x3cf356 = _0x9082ad;\n          }\n        }\n\n        // Read session signature and recover the signer\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0x8e70f2) = _0x497a6c._0x58437f(_0x8e70f2);\n\n          bytes32 _0x709661 = _0x8f7e75(_0x869304, i);\n          _0x86d864._0x03befe = _0x65bc99(_0x709661, v, r, s);\n          if (_0x86d864._0x03befe == address(0)) {\n            revert SessionErrors.InvalidSessionSigner(address(0));\n          }\n        }\n\n        sig._0x192d9f[i] = _0x86d864;\n      }\n    }\n\n    return sig;\n  }\n\n  /// @notice Recovers the session configuration from the encoded data.\n  function _0xb2a921(\n    bytes calldata _0xbaa2ca\n  ) internal pure returns (DecodedSignature memory sig, bool _0x458115) {\n    uint256 _0x8e70f2;\n    uint256 _0xf2f4e2;\n\n    // Guess maximum permissions size by bytes length\n    {\n      uint256 _0xb560e1 = _0xbaa2ca.length / MIN_ENCODED_PERMISSION_SIZE;\n      sig._0xcdc877 = new SessionPermissions[](_0xb560e1);\n    }\n\n    while (_0x8e70f2 < _0xbaa2ca.length) {\n      // First byte is the flag (top 4 bits) and additional data (bottom 4 bits)\n      uint256 _0x32187e;\n      (_0x32187e, _0x8e70f2) = _0xbaa2ca._0xb14c13(_0x8e70f2);\n      // The top 4 bits are the flag\n      uint256 _0x9082ad = (_0x32187e & 0xf0) >> 4;\n\n      // Permissions configuration (0x00)\n      if (_0x9082ad == FLAG_PERMISSIONS) {\n        SessionPermissions memory _0x4464f4;\n        uint256 _0x796084 = _0x8e70f2;\n\n        // Read signer\n        (_0x4464f4._0x9ddadc, _0x8e70f2) = _0xbaa2ca._0xa7d129(_0x8e70f2);\n\n        // Read chainId\n        (_0x4464f4.chainId, _0x8e70f2) = _0xbaa2ca._0x300be5(_0x8e70f2);\n\n        // Read value limit\n        (_0x4464f4._0x0464c4, _0x8e70f2) = _0xbaa2ca._0x300be5(_0x8e70f2);\n\n        // Read deadline\n        (_0x4464f4._0x5f9c39, _0x8e70f2) = _0xbaa2ca._0xea2ffd(_0x8e70f2);\n\n        // Read permissions array\n        (_0x4464f4._0x7fad06, _0x8e70f2) = _0xa70853(_0xbaa2ca, _0x8e70f2);\n\n        // Update root\n        {\n          bytes32 _0x61a3fe = _0x82f1d4(_0xbaa2ca[_0x796084:_0x8e70f2]);\n          sig._0x809315 =\n            sig._0x809315 != bytes32(0) ? LibOptim._0xd51331(sig._0x809315, _0x61a3fe) : _0x61a3fe;\n        }\n\n        // Push node permissions to the permissions array\n        sig._0xcdc877[_0xf2f4e2++] = _0x4464f4;\n        continue;\n      }\n\n      // Node (0x01)\n      if (_0x9082ad == FLAG_NODE) {\n        // Read pre-hashed node\n        bytes32 _0x8242cc;\n        (_0x8242cc, _0x8e70f2) = _0xbaa2ca._0xca508e(_0x8e70f2);\n\n        // Update root\n        sig._0x809315 = sig._0x809315 != bytes32(0) ? LibOptim._0xd51331(sig._0x809315, _0x8242cc) : _0x8242cc;\n\n        continue;\n      }\n\n      // Branch (0x02)\n      if (_0x9082ad == FLAG_BRANCH) {\n        // Read branch size\n        uint256 _0x539ba0;\n        {\n          uint256 _0xbc23d8 = uint8(_0x32187e & 0x0f);\n          (_0x539ba0, _0x8e70f2) = _0xbaa2ca._0xe66d4f(_0x8e70f2, _0xbc23d8);\n        }\n        // Process branch\n        uint256 _0x41187f = _0x8e70f2 + _0x539ba0;\n        (DecodedSignature memory _0x3933ca, bool _0x40a238) = _0xb2a921(_0xbaa2ca[_0x8e70f2:_0x41187f]);\n        _0x8e70f2 = _0x41187f;\n\n        // Store the branch blacklist\n        if (_0x40a238) {\n          if (_0x458115) {\n            // Blacklist already set\n            revert SessionErrors.InvalidBlacklist();\n          }\n          _0x458115 = true;\n          sig._0x6f2809 = _0x3933ca._0x6f2809;\n        }\n\n        // Store the branch identity signer\n        if (_0x3933ca._0x51e578 != address(0)) {\n          if (sig._0x51e578 != address(0)) {\n            // Identity signer already set\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n          sig._0x51e578 = _0x3933ca._0x51e578;\n        }\n\n        // Push all branch permissions to the permissions array\n        for (uint256 i = 0; i < _0x3933ca._0xcdc877.length; i++) {\n          sig._0xcdc877[_0xf2f4e2++] = _0x3933ca._0xcdc877[i];\n        }\n\n        // Update root\n        sig._0x809315 =\n          sig._0x809315 != bytes32(0) ? LibOptim._0xd51331(sig._0x809315, _0x3933ca._0x809315) : _0x3933ca._0x809315;\n\n        continue;\n      }\n\n      // Blacklist (0x03)\n      if (_0x9082ad == FLAG_BLACKLIST) {\n        if (_0x458115) {\n          // Blacklist already set\n          revert SessionErrors.InvalidBlacklist();\n        }\n        _0x458115 = true;\n\n        // Read the blacklist count from the first byte's lower 4 bits\n        uint256 _0xe09c0f = uint256(_0x32187e & 0x0f);\n        if (_0xe09c0f == 0x0f) {\n          // If it's max nibble, read the next 2 bytes for the actual size\n          (_0xe09c0f, _0x8e70f2) = _0xbaa2ca._0x90831a(_0x8e70f2);\n        }\n        uint256 _0x796084 = _0x8e70f2;\n\n        // Read the blacklist addresses\n        sig._0x6f2809 = new address[](_0xe09c0f);\n        address _0x17bf7d;\n        for (uint256 i = 0; i < _0xe09c0f; i++) {\n          (sig._0x6f2809[i], _0x8e70f2) = _0xbaa2ca._0xa7d129(_0x8e70f2);\n          if (sig._0x6f2809[i] < _0x17bf7d) {\n            revert SessionErrors.InvalidBlacklistUnsorted();\n          }\n          _0x17bf7d = sig._0x6f2809[i];\n        }\n\n        // Update the root\n        bytes32 _0xb64972 = _0xe6422f(_0xbaa2ca[_0x796084:_0x8e70f2]);\n        sig._0x809315 = sig._0x809315 != bytes32(0) ? LibOptim._0xd51331(sig._0x809315, _0xb64972) : _0xb64972;\n\n        continue;\n      }\n\n      // Identity signer (0x04)\n      if (_0x9082ad == FLAG_IDENTITY_SIGNER) {\n        if (sig._0x51e578 != address(0)) {\n          // Identity signer already set\n          revert SessionErrors.InvalidIdentitySigner();\n        }\n        (sig._0x51e578, _0x8e70f2) = _0xbaa2ca._0xa7d129(_0x8e70f2);\n\n        // Update the root\n        bytes32 _0xbc534e = _0x3cf41d(sig._0x51e578);\n        sig._0x809315 =\n          sig._0x809315 != bytes32(0) ? LibOptim._0xd51331(sig._0x809315, _0xbc534e) : _0xbc534e;\n\n        continue;\n      }\n\n      revert SessionErrors.InvalidNodeType(_0x9082ad);\n    }\n\n    {\n      // Update the permissions array length to the actual count\n      SessionPermissions[] memory _0x7fad06 = sig._0xcdc877;\n      assembly {\n        mstore(_0x7fad06, _0xf2f4e2)\n      }\n    }\n\n    return (sig, _0x458115);\n  }\n\n  /// @notice Decodes an array of Permission objects from the encoded data.\n  function _0xa70853(\n    bytes calldata _0xbaa2ca,\n    uint256 _0x8e70f2\n  ) internal pure returns (Permission[] memory _0x7fad06, uint256 _0x81e379) {\n    uint256 length;\n    (length, _0x8e70f2) = _0xbaa2ca._0xb14c13(_0x8e70f2);\n    _0x7fad06 = new Permission[](length);\n    for (uint256 i = 0; i < length; i++) {\n      (_0x7fad06[i], _0x8e70f2) = LibPermission._0x5c511c(_0xbaa2ca, _0x8e70f2);\n    }\n    return (_0x7fad06, _0x8e70f2);\n  }\n\n  /// @notice Hashes the encoded session permissions into a leaf node.\n  function _0x82f1d4(\n    bytes calldata _0x1cc549\n  ) internal pure returns (bytes32) {\n    return _0x3e9ac0(abi._0xbf1b41(uint8(FLAG_PERMISSIONS), _0x1cc549));\n  }\n\n  /// @notice Hashes the encoded blacklist into a leaf node.\n  function _0xe6422f(\n    bytes calldata _0xf9d634\n  ) internal pure returns (bytes32) {\n    return _0x3e9ac0(abi._0xbf1b41(uint8(FLAG_BLACKLIST), _0xf9d634));\n  }\n\n  /// @notice Hashes the identity signer into a leaf node.\n  function _0x3cf41d(\n    address _0x51e578\n  ) internal pure returns (bytes32) {\n    return _0x3e9ac0(abi._0xbf1b41(uint8(FLAG_IDENTITY_SIGNER), _0x51e578));\n  }\n\n  /// @notice Hashes a call with replay protection.\n  /// @dev The replay protection is based on the chainId, space, nonce and index in the payload.\n  /// @param payload The payload to hash\n  /// @param callIdx The index of the call to hash\n  /// @return callHash The hash of the call with replay protection\n  function _0x8f7e75(\n    Payload.Decoded calldata _0x869304,\n    uint256 _0x83e591\n  ) public view returns (bytes32 _0x709661) {\n    return _0x3e9ac0(\n      abi._0xbf1b41(\n        _0x869304._0x339adb ? 0 : block.chainid,\n        _0x869304._0x6815f6,\n        _0x869304._0x70809b,\n        _0x83e591,\n        Payload._0x22b14f(_0x869304._0x62f790[_0x83e591])\n      )\n    );\n  }\n\n}\n",
      "rename_map": {
        "hashCallWithReplayProtection": "_0x8f7e75",
        "_leafHashForIdentitySigner": "_0x3cf41d",
        "_leafHashForPermissions": "_0x82f1d4",
        "recoveredIdentitySigner": "_0xc47881",
        "_leafHashForBlacklist": "_0xe6422f",
        "recoverConfiguration": "_0xb2a921",
        "hasBlacklistInConfig": "_0x48fa90",
        "sessionPermissions": "_0xcdc877",
        "encodedPermissions": "_0x1cc549",
        "identitySignerHash": "_0xbc534e",
        "maxPermissionsSize": "_0xb560e1",
        "branchHasBlacklist": "_0x40a238",
        "_decodePermissions": "_0xa70853",
        "implicitBlacklist": "_0x6f2809",
        "sessionPermission": "_0x3cf356",
        "attestationIndex": "_0x76ef09",
        "encodedSignature": "_0x497a6c",
        "attestationCount": "_0xc53465",
        "recoverSignature": "_0x04ed19",
        "encodedBlacklist": "_0xf9d634",
        "permissionsCount": "_0xf2f4e2",
        "previousAddress": "_0x17bf7d",
        "attestationHash": "_0x857f58",
        "nodePermissions": "_0x4464f4",
        "attestationList": "_0x228312",
        "readPermission": "_0x5c511c",
        "blacklistCount": "_0xe09c0f",
        "readRSVCompact": "_0x58437f",
        "callSignatures": "_0x192d9f",
        "permissionHash": "_0x61a3fe",
        "identitySigner": "_0x51e578",
        "sessionSigner": "_0x03befe",
        "callSignature": "_0x86d864",
        "blacklistHash": "_0xb64972",
        "encodePacked": "_0xbf1b41",
        "pointerStart": "_0x796084",
        "hasBlacklist": "_0x458115",
        "readBytes32": "_0xca508e",
        "readUint256": "_0x300be5",
        "attestation": "_0x4629e9",
        "readAddress": "_0xa7d129",
        "permissions": "_0x7fad06",
        "fkeccak256": "_0xd51331",
        "callsCount": "_0x6375dc",
        "readUint16": "_0x90831a",
        "isImplicit": "_0xc31676",
        "fromPacked": "_0x5dbb31",
        "readUint24": "_0x2870ab",
        "newPointer": "_0x81e379",
        "readUint64": "_0xea2ffd",
        "valueLimit": "_0x0464c4",
        "keccak256": "_0x3e9ac0",
        "branchSig": "_0x3933ca",
        "firstByte": "_0x32187e",
        "noChainId": "_0x339adb",
        "ecrecover": "_0x65bc99",
        "readUintX": "_0xe66d4f",
        "imageHash": "_0x809315",
        "readUint8": "_0xb14c13",
        "hashCall": "_0x22b14f",
        "callHash": "_0x709661",
        "deadline": "_0x5f9c39",
        "dataSize": "_0xdba23d",
        "sizeSize": "_0xbc23d8",
        "nrindex": "_0x41187f",
        "callIdx": "_0x83e591",
        "pointer": "_0x8e70f2",
        "payload": "_0x869304",
        "encoded": "_0xbaa2ca",
        "toHash": "_0xa058ba",
        "signer": "_0x9ddadc",
        "nonce": "_0x70809b",
        "calls": "_0x62f790",
        "space": "_0x6815f6",
        "node": "_0x8242cc",
        "size": "_0x539ba0",
        "flag": "_0x9082ad",
        "att": "_0xbabbae"
      },
      "changes": [
        "Renamed 78 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_032",
      "transformed_id": "ss_l3_medium_sn_gs_032",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport { Calls } from \"./Calls.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { IAccount, PackedUserOperation } from \"./interfaces/IAccount.sol\";\nimport { IERC1271_MAGIC_VALUE_HASH } from \"./interfaces/IERC1271.sol\";\nimport { IEntryPoint } from \"./interfaces/IEntryPoint.sol\";\n\n/// @title ERC4337v07\n/// @author Agustin Aguilar, Michael Standen\n/// @notice ERC4337 v7 support\nabstract contract ERC4337v07 is ReentrancyGuard, IAccount, Calls {\n\n  uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n  address public immutable _0x1046f6;\n\n  error InvalidEntryPoint(address _0xd8dc2e);\n  error ERC4337Disabled();\n\n  constructor(\n    address _0xd8dc2e\n  ) {\n    _0x1046f6 = _0xd8dc2e;\n  }\n\n  /// @inheritdoc IAccount\n  function _0xdb1c1d(\n    PackedUserOperation calldata _0xb16c3c,\n    bytes32 _0xee5df8,\n    uint256 _0x05f900\n  ) external returns (uint256 _0x9130ad) {\n    if (_0x1046f6 == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != _0x1046f6) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n    // userOp.nonce is validated by the entrypoint\n\n    if (_0x05f900 != 0) {\n      IEntryPoint(_0x1046f6)._0x07a494{ value: _0x05f900 }(address(this));\n    }\n\n    if (this._0x5ee868(_0xee5df8, _0xb16c3c._0x1b292a) != IERC1271_MAGIC_VALUE_HASH) {\n      return SIG_VALIDATION_FAILED;\n    }\n\n    return 0;\n  }\n\n  /// @notice Execute a user operation\n  /// @param _payload The packed payload\n  /// @dev This is the execute function for the EntryPoint to call.\n  function _0x82709e(\n    bytes calldata _0x3249e8\n  ) external _0x7207f3 {\n    if (_0x1046f6 == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != _0x1046f6) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n    this._0x67ab69(_0x3249e8);\n  }\n\n}",
      "rename_map": {
        "missingAccountFunds": "_0x05f900",
        "isValidSignature": "_0x5ee868",
        "validateUserOp": "_0xdb1c1d",
        "validationData": "_0x9130ad",
        "executeUserOp": "_0x82709e",
        "nonReentrant": "_0x7207f3",
        "selfExecute": "_0x67ab69",
        "_entrypoint": "_0xd8dc2e",
        "entrypoint": "_0x1046f6",
        "userOpHash": "_0xee5df8",
        "depositTo": "_0x07a494",
        "signature": "_0x1b292a",
        "_payload": "_0x3249e8",
        "userOp": "_0xb16c3c"
      },
      "changes": [
        "Renamed 14 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_033",
      "transformed_id": "ss_l3_medium_sn_gs_033",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from \"../Payload.sol\";\n\nimport { Storage } from \"../Storage.sol\";\nimport { IAuth } from \"../interfaces/IAuth.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\n\nimport { IPartialAuth } from \"../interfaces/IPartialAuth.sol\";\nimport { ISapient } from \"../interfaces/ISapient.sol\";\nimport { BaseSig } from \"./BaseSig.sol\";\n\nimport { SelfAuth } from \"./SelfAuth.sol\";\n\nusing Payload for Payload.Decoded;\n\n/// @title BaseAuth\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Base contract for the auth module\nabstract contract BaseAuth is IAuth, IPartialAuth, ISapient, IERC1271, SelfAuth {\n\n  /// @dev keccak256(\"org.sequence.module.auth.static\")\n  bytes32 private constant STATIC_SIGNATURE_KEY =\n    bytes32(0xc852adf5e97c2fc3b38f405671e91b7af1697ef0287577f227ef10494c2a8e86);\n\n  /// @notice Error thrown when the sapient signature is invalid\n  error InvalidSapientSignature(Payload.Decoded _0x615669, bytes _0x66e4a3);\n  /// @notice Error thrown when the signature weight is invalid\n  error InvalidSignatureWeight(uint256 _0x813d69, uint256 _0xc55d4c);\n  /// @notice Error thrown when the static signature has expired\n  error InvalidStaticSignatureExpired(bytes32 _0xf32374, uint256 _0x4aa3a0);\n  /// @notice Error thrown when the static signature has the wrong caller\n  error InvalidStaticSignatureWrongCaller(bytes32 _0xf32374, address _0x58bec2, address _0x12c532);\n\n  /// @notice Event emitted when a static signature is set\n  event StaticSignatureSet(bytes32 _0x06318d, address _0x0aaded, uint96 _0x033dcb);\n\n  function _0xf090b0(\n    bytes32 _0x06318d\n  ) internal view returns (address, uint256) {\n    uint256 _0xe49bd2 = uint256(Storage._0x896965(STATIC_SIGNATURE_KEY, _0x06318d));\n    return (address(uint160(_0xe49bd2 >> 96)), uint256(uint96(_0xe49bd2)));\n  }\n\n  function _0xe5c96a(bytes32 _0x06318d, address _0x0aaded, uint256 _0x033dcb) internal {\n    Storage._0x0ae854(\n      STATIC_SIGNATURE_KEY, _0x06318d, bytes32(uint256(uint160(_0x0aaded)) << 96 | (_0x033dcb & 0xffffffffffffffffffffffff))\n    );\n  }\n\n  /// @notice Get the static signature for a specific hash\n  /// @param _hash The hash to get the static signature for\n  /// @return address The address associated with the static signature\n  /// @return timestamp The timestamp of the static signature\n  function _0x83b6b7(\n    bytes32 _0x06318d\n  ) external view returns (address, uint256) {\n    return _0xf090b0(_0x06318d);\n  }\n\n  /// @notice Set the static signature for a specific hash\n  /// @param _hash The hash to set the static signature for\n  /// @param _address The address to associate with the static signature\n  /// @param _timestamp The timestamp of the static signature\n  /// @dev Only callable by the wallet itself\n  function _0x07b5ca(bytes32 _0x06318d, address _0x0aaded, uint96 _0x033dcb) external _0x3a5e60 {\n    _0xe5c96a(_0x06318d, _0x0aaded, _0x033dcb);\n    emit StaticSignatureSet(_0x06318d, _0x0aaded, _0x033dcb);\n  }\n\n  /// @notice Update the image hash\n  /// @param _imageHash The new image hash\n  /// @dev Only callable by the wallet itself\n  function _0xa63514(\n    bytes32 _0x96fa80\n  ) external virtual _0x3a5e60 {\n    _0xfe02d5(_0x96fa80);\n  }\n\n  function _0xf69652(\n    Payload.Decoded memory _0x615669,\n    bytes calldata _0x66e4a3\n  ) internal view virtual returns (bool _0x764844, bytes32 _0x847370) {\n    // Read first bit to determine if static signature is used\n    bytes1 _0x274a76 = _0x66e4a3[0];\n\n    if (_0x274a76 & 0x80 == 0x80) {\n      _0x847370 = _0x615669._0x7bebb9();\n\n      (address _0xb2ff7c, uint256 timestamp) = _0xf090b0(_0x847370);\n      if (timestamp <= block.timestamp) {\n        revert InvalidStaticSignatureExpired(_0x847370, timestamp);\n      }\n\n      if (_0xb2ff7c != address(0) && _0xb2ff7c != msg.sender) {\n        revert InvalidStaticSignatureWrongCaller(_0x847370, msg.sender, _0xb2ff7c);\n      }\n\n      return (true, _0x847370);\n    }\n\n    // Static signature is not used, recover and validate imageHash\n\n    uint256 _0x4061d3;\n    uint256 _0x55af1d;\n    bytes32 _0x7dc020;\n\n    (_0x4061d3, _0x55af1d, _0x7dc020,, _0x847370) = BaseSig._0xb2db52(_0x615669, _0x66e4a3, false, address(0));\n\n    // Validate the weight\n    if (_0x55af1d < _0x4061d3) {\n      revert InvalidSignatureWeight(_0x4061d3, _0x55af1d);\n    }\n\n    _0x764844 = _0x61b129(_0x7dc020);\n  }\n\n  /// @inheritdoc ISapient\n  function _0xdb90a1(\n    Payload.Decoded memory _0x615669,\n    bytes calldata _0x66e4a3\n  ) external view returns (bytes32) {\n    // Copy parent wallets + add caller at the end\n    address[] memory _0xd8072d = new address[](_0x615669._0xd8072d.length + 1);\n\n    for (uint256 i = 0; i < _0x615669._0xd8072d.length; i++) {\n      _0xd8072d[i] = _0x615669._0xd8072d[i];\n    }\n\n    _0xd8072d[_0x615669._0xd8072d.length] = msg.sender;\n    _0x615669._0xd8072d = _0xd8072d;\n\n    (bool _0x764844,) = _0xf69652(_0x615669, _0x66e4a3);\n    if (!_0x764844) {\n      revert InvalidSapientSignature(_0x615669, _0x66e4a3);\n    }\n\n    return bytes32(uint256(1));\n  }\n\n  /// @inheritdoc IERC1271\n  function _0x0b1ab1(bytes32 _0x06318d, bytes calldata _0x66e4a3) external view returns (bytes4) {\n    Payload.Decoded memory _0x7113d3 = Payload._0x489f0d(_0x06318d);\n\n    (bool _0x764844,) = _0xf69652(_0x7113d3, _0x66e4a3);\n    if (!_0x764844) {\n      return bytes4(0);\n    }\n\n    return IERC1271_MAGIC_VALUE_HASH;\n  }\n\n  /// @inheritdoc IPartialAuth\n  function _0x492db2(\n    Payload.Decoded memory _0x615669,\n    bytes calldata _0x66e4a3\n  )\n    external\n    view\n    returns (\n      uint256 _0x4061d3,\n      uint256 _0x55af1d,\n      bool _0xc4d209,\n      bytes32 _0x7dc020,\n      uint256 _0xa575ea,\n      bytes32 _0x847370\n    )\n  {\n    (_0x4061d3, _0x55af1d, _0x7dc020, _0xa575ea, _0x847370) = BaseSig._0xb2db52(_0x615669, _0x66e4a3, false, address(0));\n    _0xc4d209 = _0x61b129(_0x7dc020);\n  }\n\n}",
      "rename_map": {
        "recoverPartialSignature": "_0x492db2",
        "recoverSapientSignature": "_0xdb90a1",
        "_getStaticSignature": "_0xf090b0",
        "signatureValidation": "_0xf69652",
        "_setStaticSignature": "_0xe5c96a",
        "getStaticSignature": "_0x83b6b7",
        "setStaticSignature": "_0x07b5ca",
        "_updateImageHash": "_0xfe02d5",
        "isValidSignature": "_0x0b1ab1",
        "_expectedCaller": "_0x12c532",
        "updateImageHash": "_0xa63514",
        "writeBytes32Map": "_0x0ae854",
        "readBytes32Map": "_0x896965",
        "_isValidImage": "_0x61b129",
        "signatureFlag": "_0x274a76",
        "parentWallets": "_0xd8072d",
        "isValidImage": "_0xc4d209",
        "fromDigest": "_0x489f0d",
        "_threshold": "_0x813d69",
        "checkpoint": "_0xa575ea",
        "_timestamp": "_0x033dcb",
        "_signature": "_0x66e4a3",
        "_imageHash": "_0x96fa80",
        "threshold": "_0x4061d3",
        "imageHash": "_0x7dc020",
        "_expires": "_0x4aa3a0",
        "_payload": "_0x615669",
        "_address": "_0x0aaded",
        "onlySelf": "_0x3a5e60",
        "recover": "_0xb2db52",
        "_opHash": "_0xf32374",
        "_weight": "_0xc55d4c",
        "_caller": "_0x58bec2",
        "isValid": "_0x764844",
        "payload": "_0x7113d3",
        "opHash": "_0x847370",
        "weight": "_0x55af1d",
        "_hash": "_0x06318d",
        "word": "_0xe49bd2",
        "hash": "_0x7bebb9",
        "addr": "_0xb2ff7c"
      },
      "changes": [
        "Renamed 41 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_034",
      "transformed_id": "ss_l3_medium_sn_gs_034",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport \"./Wallet.sol\";\n\n/// @title Factory\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Factory for deploying wallets\ncontract Factory {\n\n  /// @notice Error thrown when the deployment fails\n  error DeployFailed(address _0xe7f547, bytes32 _0xa0a14e);\n\n  /// @notice Deploy a new wallet instance\n  /// @param _mainModule Address of the main module to be used by the wallet\n  /// @param _salt Salt used to generate the wallet, which is the imageHash of the wallet's configuration.\n  /// @dev It is recommended to not have more than 200 signers as opcode repricing could make transactions impossible to execute as all the signers must be passed for each transaction.\n  function _0xa3c51d(address _0xe7f547, bytes32 _0xa0a14e) public payable returns (address _0x4ea8bf) {\n    bytes memory code = abi._0xb6d221(Wallet._0x45db90, uint256(uint160(_0xe7f547)));\n    assembly {\n      _0x4ea8bf := create2(callvalue(), add(code, 32), mload(code), _0xa0a14e)\n    }\n    if (_0x4ea8bf == address(0)) {\n      revert DeployFailed(_0xe7f547, _0xa0a14e);\n    }\n  }\n\n}",
      "rename_map": {
        "encodePacked": "_0xb6d221",
        "creationCode": "_0x45db90",
        "_mainModule": "_0xe7f547",
        "_contract": "_0x4ea8bf",
        "deploy": "_0xa3c51d",
        "_salt": "_0xa0a14e"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_035",
      "transformed_id": "ss_l3_medium_sn_gs_035",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19 <0.9.0;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IV2Pool} from \"../../external/IV2Pool.sol\";\nimport {IV2Router} from \"../../external/IV2Router.sol\";\nimport {IV2LockerFactory} from \"../../interfaces/extensions/v2/IV2LockerFactory.sol\";\nimport {IV2Locker} from \"../../interfaces/extensions/v2/IV2Locker.sol\";\nimport {ILocker} from \"../../interfaces/ILocker.sol\";\nimport {Locker} from \"../../Locker.sol\";\n\n/// @title V2Locker\n/// @author velodrome.finance\n/// @notice Manages locking liquidity, staking, and claiming rewards for V2 pools.\ncontract V2Locker is Locker, IV2Locker {\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc IV2Locker\n    address public immutable _0x8059be;\n\n    uint256 internal _0xe6f629;\n\n    constructor(\n        bool _0xfdcf57,\n        address _0x9df8af,\n        address _0xb8dcd0,\n        address _0x08842c,\n        uint256 _0x78055a,\n        uint32 _0xc0991d,\n        address _0x4fbeab,\n        uint16 _0xf5a051,\n        uint16 _0x418972\n    ) Locker(_0xfdcf57, _0x9df8af, _0xb8dcd0, _0xc0991d, _0x4fbeab, _0xf5a051, _0x418972) {\n        _0x8059be = _0x08842c;\n        _0xe6f629 = _0x78055a;\n        (_0xb6e158, _0xa5ee45) = IV2Pool(_0xb0561e)._0x6c4ff4();\n    }\n\n    /// @inheritdoc Locker\n    function _0x5aa38d(address _0x375c96) external override(Locker, ILocker) _0xe8fb1c _0x942d69 returns (uint256) {\n        if (msg.sender != _0x8bc67b) revert NotFactory();\n\n        delete _0x35ccf8;\n        delete _0xcb5630;\n\n        IERC20(_0xb0561e)._0x7c6a72({_0x7c4b9b: _0x375c96, value: _0xe6f629});\n\n        /// @dev Refund locked balances\n        uint256 _0x72ea2b = IERC20(_0xb6e158)._0xb2904e({_0xe65317: address(this)});\n        if (_0x72ea2b > 0) IERC20(_0xb6e158)._0x7c6a72({_0x7c4b9b: _0x375c96, value: _0x72ea2b});\n        _0x72ea2b = IERC20(_0xa5ee45)._0xb2904e({_0xe65317: address(this)});\n        if (_0x72ea2b > 0) IERC20(_0xa5ee45)._0x7c6a72({_0x7c4b9b: _0x375c96, value: _0x72ea2b});\n\n        emit Unlocked({_0xcb4542: _0x375c96});\n        return _0xe6f629;\n    }\n\n    /// @inheritdoc Locker\n    function _0xe4ffb5() external override(Locker, ILocker) _0x942d69 _0xf460cc _0xe8fb1c _0x29f63a {\n        if (_0x35ccf8) revert AlreadyStaked();\n        _0x35ccf8 = true;\n\n        _0x4b70c2({_0x375c96: _0x76d8e4()});\n\n        IERC20(_0xb0561e)._0xc9d31d({_0x70bb32: address(_0x198508), value: _0xe6f629});\n        _0x198508._0x6d957f({_0xb9030c: _0xe6f629});\n        emit Staked();\n    }\n\n    /// @inheritdoc Locker\n    function _0x0cf01f(uint256 _0xdcc873, uint256 _0x351b17, uint256 _0x954e43, uint256 _0xda44c0)\n        external\n        override(ILocker, Locker)\n        _0x942d69\n        _0xf460cc\n        _0xe8fb1c\n        returns (uint256)\n    {\n        if (_0xdcc873 == 0 && _0x351b17 == 0) revert ZeroAmount();\n\n        uint256 _0x95fd03 = _0x89cdbd({_0xa1a3b9: _0xb6e158, _0x8d5f46: _0xdcc873});\n        uint256 _0x131e67 = _0x89cdbd({_0xa1a3b9: _0xa5ee45, _0x8d5f46: _0x351b17});\n\n        IERC20(_0xb6e158)._0xa8a792({_0x70bb32: _0x8059be, value: _0xdcc873});\n        IERC20(_0xa5ee45)._0xa8a792({_0x70bb32: _0x8059be, value: _0x351b17});\n\n        (uint256 _0x448d64, uint256 _0x4f2793, uint256 _0x0cca21) = IV2Router(_0x8059be)._0x06d524({\n            _0xfd0650: _0xb6e158,\n            _0x422b4a: _0xa5ee45,\n            _0xcab807: IV2Pool(_0xb0561e)._0xcab807(),\n            _0xecacdb: _0xdcc873,\n            _0x76f8f7: _0x351b17,\n            _0x33f42b: _0x954e43,\n            _0x5804c8: _0xda44c0,\n            _0x7c4b9b: address(this),\n            _0x83731b: block.timestamp\n        });\n\n        IERC20(_0xb6e158)._0xa8a792({_0x70bb32: _0x8059be, value: 0});\n        IERC20(_0xa5ee45)._0xa8a792({_0x70bb32: _0x8059be, value: 0});\n\n        address _0xcb4542 = _0x76d8e4();\n        _0x9deb94({_0xa1a3b9: _0xb6e158, _0x375c96: _0xcb4542, _0x0f15bc: _0x95fd03});\n        _0x9deb94({_0xa1a3b9: _0xa5ee45, _0x375c96: _0xcb4542, _0x0f15bc: _0x131e67});\n\n        if (_0x35ccf8) {\n            IERC20(_0xb0561e)._0xc9d31d({_0x70bb32: address(_0x198508), value: _0x0cca21});\n            _0x198508._0x6d957f({_0xb9030c: _0x0cca21});\n        }\n\n        _0xe6f629 += _0x0cca21;\n\n        emit LiquidityIncreased({_0x3cba66: _0x448d64, _0x60f228: _0x4f2793, _0x0cca21: _0x0cca21});\n        return _0x0cca21;\n    }\n\n    function _0xc49f2b() internal override returns (uint256 _0x9f535b, uint256 _0x491141) {\n        (_0x9f535b, _0x491141) = IV2Pool(_0xb0561e)._0x1b429d();\n\n        uint256 _0x8a7636 = _0xf3c575({_0x1c0651: _0x9f535b, _0xa1a3b9: _0xb6e158});\n        uint256 _0x946582 = _0xf3c575({_0x1c0651: _0x491141, _0xa1a3b9: _0xa5ee45});\n        _0x9f535b -= _0x8a7636;\n        _0x491141 -= _0x946582;\n\n        if (_0x8a7636 > 0 || _0x946582 > 0) {\n            emit FeesClaimed({_0xcb4542: _0x73faa9, _0x9f535b: _0x8a7636, _0x491141: _0x946582});\n        }\n    }\n\n    function _0x593168() internal override returns (uint256 _0x57a0cb) {\n        uint256 _0x0d8fcf = IERC20(_0x9962a9)._0xb2904e({_0xe65317: address(this)});\n        _0x198508._0x2af2d0({_0xe65317: address(this)});\n        uint256 _0xc72224 = IERC20(_0x9962a9)._0xb2904e({_0xe65317: address(this)});\n\n        _0x57a0cb = _0xc72224 - _0x0d8fcf;\n        uint256 _0x311fc2 = _0xf3c575({_0x1c0651: _0x57a0cb, _0xa1a3b9: _0x9962a9});\n        _0x57a0cb -= _0x311fc2;\n\n        if (_0x311fc2 > 0) {\n            emit RewardsClaimed({_0xcb4542: _0x73faa9, _0x57a0cb: _0x311fc2});\n        }\n    }\n\n    function _0xb9030c() public view override(ILocker, Locker) returns (uint256) {\n        return _0xe6f629;\n    }\n}",
      "rename_map": {
        "safeIncreaseAllowance": "_0xc9d31d",
        "_beneficiaryShare": "_0xf5a051",
        "increaseLiquidity": "_0x0cf01f",
        "amount0Deposited": "_0x448d64",
        "amount1Deposited": "_0x4f2793",
        "_bribeableShare": "_0x418972",
        "_refundLeftover": "_0x9deb94",
        "_collectRewards": "_0x593168",
        "amountBDesired": "_0x76f8f7",
        "amountADesired": "_0xecacdb",
        "rewardsBefore": "_0x0d8fcf",
        "nonReentrant": "_0x942d69",
        "rewardsAfter": "_0xc72224",
        "_deductShare": "_0xf3c575",
        "_beneficiary": "_0x4fbeab",
        "_collectFees": "_0xc49f2b",
        "forceApprove": "_0xa8a792",
        "safeTransfer": "_0x7c6a72",
        "addLiquidity": "_0x06d524",
        "_lockedUntil": "_0xc0991d",
        "_fundLocker": "_0x89cdbd",
        "beneficiary": "_0x73faa9",
        "lockedUntil": "_0xcb5630",
        "ensureGauge": "_0x29f63a",
        "rewardToken": "_0x9962a9",
        "_amount0Min": "_0x954e43",
        "_amount1Min": "_0xda44c0",
        "onlyLocked": "_0xe8fb1c",
        "_maxAmount": "_0x0f15bc",
        "_recipient": "_0x375c96",
        "amountBMin": "_0x5804c8",
        "amountAMin": "_0x33f42b",
        "_claimFees": "_0x4b70c2",
        "balanceOf": "_0xb2904e",
        "supplied1": "_0x131e67",
        "supplied0": "_0x95fd03",
        "getReward": "_0x2af2d0",
        "_totalBal": "_0x8d5f46",
        "liquidity": "_0x0cca21",
        "onlyOwner": "_0xf460cc",
        "recipient": "_0xcb4542",
        "claimFees": "_0x1b429d",
        "leftover": "_0x72ea2b",
        "_amount0": "_0xdcc873",
        "deadline": "_0x83731b",
        "_amount1": "_0x351b17",
        "claimed0": "_0x9f535b",
        "claimed1": "_0x491141",
        "_amount": "_0x1c0651",
        "factory": "_0x8bc67b",
        "account": "_0xe65317",
        "amount0": "_0x3cba66",
        "claimed": "_0x57a0cb",
        "amount1": "_0x60f228",
        "deposit": "_0x6d957f",
        "_router": "_0x08842c",
        "spender": "_0x70bb32",
        "tokens": "_0x6c4ff4",
        "token1": "_0xa5ee45",
        "staked": "_0x35ccf8",
        "tokenB": "_0x422b4a",
        "unlock": "_0x5aa38d",
        "_token": "_0xa1a3b9",
        "share0": "_0x8a7636",
        "tokenA": "_0xfd0650",
        "share1": "_0x946582",
        "router": "_0x8059be",
        "token0": "_0xb6e158",
        "stable": "_0xcab807",
        "_owner": "_0x9df8af",
        "gauge": "_0x198508",
        "stake": "_0xe4ffb5",
        "share": "_0x311fc2",
        "owner": "_0x76d8e4",
        "_pool": "_0xb8dcd0",
        "_root": "_0xfdcf57",
        "pool": "_0xb0561e",
        "_lp_": "_0x78055a",
        "_lp": "_0xe6f629",
        "to": "_0x7c4b9b",
        "lp": "_0xb9030c"
      },
      "changes": [
        "Renamed 81 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_001",
      "transformed_id": "ss_l3_medium_sn_tc_001",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bridge Replica Contract\n * @notice Processes cross-chain messages from source chain to destination chain\n * @dev Validates and executes messages based on merkle proofs\n */\ncontract BridgeReplica {\n    // Message status enum\n    enum MessageStatus {\n        None,\n        Pending,\n        Processed\n    }\n\n    // Mapping of message hash to status\n    mapping(bytes32 => MessageStatus) public _0xbb30c7;\n\n    // The confirmed root for messages\n    bytes32 public _0x04e9fc;\n\n    // Bridge router that handles the actual token transfers\n    address public _0x2198f7;\n\n    // Nonce tracking\n    mapping(uint32 => uint32) public _0xa813d5;\n\n    event MessageProcessed(bytes32 indexed _0xfc6ec1, bool _0x3e8647);\n\n    constructor(address _0x37799e) {\n        _0x2198f7 = _0x37799e;\n    }\n\n    /**\n     * @notice Process a cross-chain message\n     * @param _message The formatted message to process\n     * @return success Whether the message was successfully processed\n     */\n    function _0x4be739(bytes memory _0x9f47b5) external returns (bool _0x3e8647) {\n        bytes32 _0xfc6ec1 = _0x2cb502(_0x9f47b5);\n\n        // Check if message has already been processed\n        require(\n            _0xbb30c7[_0xfc6ec1] != MessageStatus.Processed,\n            \"Already processed\"\n        );\n\n        // Validate message root\n        bytes32 _0x329a14 = _0x3b85ef(_0x9f47b5);\n        require(_0x329a14 == _0x04e9fc, \"Invalid root\");\n\n        // Mark as processed\n        _0xbb30c7[_0xfc6ec1] = MessageStatus.Processed;\n\n        // Forward to bridge router for token transfer\n        (bool _0x0961f7, ) = _0x2198f7.call(_0x9f47b5);\n\n        emit MessageProcessed(_0xfc6ec1, _0x0961f7);\n        return _0x0961f7;\n    }\n\n    /**\n     * @notice Derive the message root\n     * @dev Verifies message against merkle proof\n     */\n    function _0x3b85ef(\n        bytes memory _0x9f47b5\n    ) internal pure returns (bytes32) {\n        // Simplified merkle proof verification\n        if (_0x9f47b5.length > 32 && uint256(bytes32(_0x9f47b5)) == 0) {\n            return bytes32(0);\n        }\n\n        return _0x2cb502(_0x9f47b5);\n    }\n\n    /**\n     * @notice Set the accepted root (admin function)\n     */\n    function _0xbd1a94(bytes32 _0xda52a5) external {\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x04e9fc = _0xda52a5; }\n    }\n}\n",
      "rename_map": {
        "setAcceptedRoot": "_0xbd1a94",
        "_bridgeRouter": "_0x37799e",
        "routerSuccess": "_0x0961f7",
        "acceptedRoot": "_0x04e9fc",
        "bridgeRouter": "_0x2198f7",
        "_messageRoot": "_0x3b85ef",
        "messageHash": "_0xfc6ec1",
        "keccak256": "_0x2cb502",
        "_message": "_0x9f47b5",
        "messages": "_0xbb30c7",
        "_newRoot": "_0xda52a5",
        "process": "_0x4be739",
        "success": "_0x3e8647",
        "nonces": "_0xa813d5",
        "root": "_0x329a14"
      },
      "changes": [
        "Renamed 15 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_002",
      "transformed_id": "ss_l3_medium_sn_tc_002",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Governance System\n * @notice Manages protocol governance proposals and voting\n * @dev Allows token holders to propose and vote on protocol changes\n */\n\ninterface IDiamondCut {\n    struct FacetCut {\n        address _0xae3af0;\n        uint8 _0x11c39b;\n        bytes4[] _0x77e4b7;\n    }\n}\n\ncontract GovernanceSystem {\n    // Voting power based on deposits\n    mapping(address => uint256) public _0xcc6637;\n    mapping(address => uint256) public _0x3ded31;\n\n    // Proposal structure\n    struct Proposal {\n        address _0x166ea5;\n        address _0x482968;\n        bytes data;\n        uint256 _0x1da8d0;\n        uint256 _0x0ef500;\n        bool _0x470099;\n    }\n\n    mapping(uint256 => Proposal) public _0x05d053;\n    mapping(uint256 => mapping(address => bool)) public _0x02b278;\n    uint256 public _0xc92297;\n\n    uint256 public _0xcef9d4;\n\n    // Constants\n    uint256 constant EMERGENCY_THRESHOLD = 66;\n\n    event ProposalCreated(\n        uint256 indexed _0xf703bc,\n        address _0x166ea5,\n        address _0x482968\n    );\n    event Voted(uint256 indexed _0xf703bc, address _0xf1f9f7, uint256 _0x1abb20);\n    event ProposalExecuted(uint256 indexed _0xf703bc);\n\n    /**\n     * @notice Deposit tokens to gain voting power\n     * @param amount Amount to deposit\n     */\n    function _0xf37b15(uint256 _0x6fb08d) external {\n        _0xcc6637[msg.sender] += _0x6fb08d;\n        _0x3ded31[msg.sender] += _0x6fb08d;\n        _0xcef9d4 += _0x6fb08d;\n    }\n\n    /**\n     * @notice Create a governance proposal\n     * @param _target The contract to call\n     * @param _calldata The calldata to execute\n     */\n    function _0x0e63bb(\n        IDiamondCut.FacetCut[] calldata,\n        address _0x24ea86,\n        bytes calldata _0x20883e,\n        uint8\n    ) external returns (uint256) {\n        _0xc92297++;\n\n        Proposal storage _0xfcbb95 = _0x05d053[_0xc92297];\n        _0xfcbb95._0x166ea5 = msg.sender;\n        _0xfcbb95._0x482968 = _0x24ea86;\n        _0xfcbb95.data = _0x20883e;\n        _0xfcbb95._0x0ef500 = block.timestamp;\n        _0xfcbb95._0x470099 = false;\n\n        // Auto-vote with proposer's voting power\n        _0xfcbb95._0x1da8d0 = _0x3ded31[msg.sender];\n        _0x02b278[_0xc92297][msg.sender] = true;\n\n        emit ProposalCreated(_0xc92297, msg.sender, _0x24ea86);\n        return _0xc92297;\n    }\n\n    /**\n     * @notice Vote on a proposal\n     * @param proposalId The ID of the proposal\n     */\n    function _0x6f73f2(uint256 _0xf703bc) external {\n        require(!_0x02b278[_0xf703bc][msg.sender], \"Already voted\");\n        require(!_0x05d053[_0xf703bc]._0x470099, \"Already executed\");\n\n        _0x05d053[_0xf703bc]._0x1da8d0 += _0x3ded31[msg.sender];\n        _0x02b278[_0xf703bc][msg.sender] = true;\n\n        emit Voted(_0xf703bc, msg.sender, _0x3ded31[msg.sender]);\n    }\n\n    /**\n     * @notice Emergency commit - execute proposal immediately\n     * @param proposalId The ID of the proposal to execute\n     */\n    function _0x8d1ef5(uint256 _0xf703bc) external {\n        Proposal storage _0xfcbb95 = _0x05d053[_0xf703bc];\n        require(!_0xfcbb95._0x470099, \"Already executed\");\n\n        uint256 _0x2ca433 = (_0xfcbb95._0x1da8d0 * 100) / _0xcef9d4;\n        require(_0x2ca433 >= EMERGENCY_THRESHOLD, \"Insufficient votes\");\n\n        _0xfcbb95._0x470099 = true;\n\n        // Execute the proposal\n        (bool _0x943df2, ) = _0xfcbb95._0x482968.call(_0xfcbb95.data);\n        require(_0x943df2, \"Execution failed\");\n\n        emit ProposalExecuted(_0xf703bc);\n    }\n}\n",
      "rename_map": {
        "functionSelectors": "_0x77e4b7",
        "depositedBalance": "_0xcc6637",
        "totalVotingPower": "_0xcef9d4",
        "emergencyCommit": "_0x8d1ef5",
        "votePercentage": "_0x2ca433",
        "proposalCount": "_0xc92297",
        "facetAddress": "_0xae3af0",
        "votingPower": "_0x3ded31",
        "proposalId": "_0xf703bc",
        "_calldata": "_0x20883e",
        "startTime": "_0x0ef500",
        "proposals": "_0x05d053",
        "proposer": "_0x166ea5",
        "executed": "_0x470099",
        "forVotes": "_0x1da8d0",
        "hasVoted": "_0x02b278",
        "propose": "_0x0e63bb",
        "success": "_0x943df2",
        "deposit": "_0xf37b15",
        "_target": "_0x24ea86",
        "target": "_0x482968",
        "amount": "_0x6fb08d",
        "action": "_0x11c39b",
        "votes": "_0x1abb20",
        "voter": "_0xf1f9f7",
        "prop": "_0xfcbb95",
        "vote": "_0x6f73f2"
      },
      "changes": [
        "Renamed 27 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_003",
      "transformed_id": "ss_l3_medium_sn_tc_003",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Multi-Signature Wallet Library\n * @notice Shared library contract for multi-sig wallet functionality\n * @dev Used by wallet proxies via delegatecall\n */\ncontract WalletLibrary {\n    // Owner mapping\n    mapping(address => bool) public _0xb50a23;\n    address[] public _0x388b24;\n    uint256 public _0x137b25;\n\n    // Initialization state\n    bool public _0xa751e1;\n\n    event OwnerAdded(address indexed _0x58c441);\n    event WalletDestroyed(address indexed _0xd4ec78);\n\n    /**\n     * @notice Initialize the wallet with owners\n     * @param _owners Array of owner addresses\n     * @param _required Number of required signatures\n     * @param _daylimit Daily withdrawal limit\n     */\n    function _0xdf20cf(\n        address[] memory _0xf69692,\n        uint256 _0x441b96,\n        uint256 _0x7c1d4e\n    ) public {\n        // Clear existing owners\n        for (uint i = 0; i < _0x388b24.length; i++) {\n            _0xb50a23[_0x388b24[i]] = false;\n        }\n        delete _0x388b24;\n\n        // Set new owners\n        for (uint i = 0; i < _0xf69692.length; i++) {\n            address _0x58c441 = _0xf69692[i];\n            require(_0x58c441 != address(0), \"Invalid owner\");\n            require(!_0xb50a23[_0x58c441], \"Duplicate owner\");\n\n            _0xb50a23[_0x58c441] = true;\n            _0x388b24.push(_0x58c441);\n            emit OwnerAdded(_0x58c441);\n        }\n\n        _0x137b25 = _0x441b96;\n        _0xa751e1 = true;\n    }\n\n    /**\n     * @notice Check if an address is an owner\n     * @param _addr Address to check\n     * @return bool Whether the address is an owner\n     */\n    function _0xe638a1(address _0x791ce4) public view returns (bool) {\n        return _0xb50a23[_0x791ce4];\n    }\n\n    /**\n     * @notice Destroy the contract\n     * @param _to Address to send remaining funds to\n     */\n    function _0x91e149(address payable _0x985172) external {\n        require(_0xb50a23[msg.sender], \"Not an owner\");\n\n        emit WalletDestroyed(msg.sender);\n\n        selfdestruct(_0x985172);\n    }\n\n    /**\n     * @notice Execute a transaction\n     * @param to Target address\n     * @param value Amount of ETH to send\n     * @param data Transaction data\n     */\n    function _0x73ad70(address _0xfd573b, uint256 value, bytes memory data) external {\n        require(_0xb50a23[msg.sender], \"Not an owner\");\n\n        (bool _0x9b0c13, ) = _0xfd573b.call{value: value}(data);\n        require(_0x9b0c13, \"Execution failed\");\n    }\n}\n\n/**\n * @title Wallet Proxy\n * @notice Proxy contract that delegates to WalletLibrary\n */\ncontract WalletProxy {\n    address public _0x66d434;\n\n    constructor(address _0xd1bfba) {\n        _0x66d434 = _0xd1bfba;\n    }\n\n    fallback() external payable {\n        address _0x558b64 = _0x66d434;\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let _0xe40993 := delegatecall(gas(), _0x558b64, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n\n            switch _0xe40993\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "isOwnerAddress": "_0xe638a1",
        "libraryAddress": "_0x66d434",
        "initialized": "_0xa751e1",
        "initWallet": "_0xdf20cf",
        "destroyer": "_0xd4ec78",
        "_required": "_0x441b96",
        "_daylimit": "_0x7c1d4e",
        "required": "_0x137b25",
        "_library": "_0xd1bfba",
        "isOwner": "_0xb50a23",
        "execute": "_0x73ad70",
        "success": "_0x9b0c13",
        "_owners": "_0xf69692",
        "result": "_0xe40993",
        "owners": "_0x388b24",
        "owner": "_0x58c441",
        "_addr": "_0x791ce4",
        "kill": "_0x91e149",
        "lib": "_0x558b64",
        "_to": "_0x985172",
        "to": "_0xfd573b"
      },
      "changes": [
        "Renamed 21 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_004",
      "transformed_id": "ss_l3_medium_sn_tc_004",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Yield Aggregator Vault\n * @notice Vault contract that deploys funds to external yield strategies\n * @dev Users deposit tokens and receive vault shares representing their position\n */\n\ninterface ICurvePool {\n    function _0x41d2f6(\n        int128 i,\n        int128 j,\n        uint256 _0x328835,\n        uint256 _0x8b3129\n    ) external returns (uint256);\n\n    function _0x5157b2(\n        int128 i,\n        int128 j,\n        uint256 _0x328835\n    ) external view returns (uint256);\n}\n\ncontract YieldVault {\n    address public _0x34597f;\n    ICurvePool public _0xa743cb;\n\n    uint256 public _0x33035b;\n    mapping(address => uint256) public _0x95286e;\n\n    // Assets deployed to external protocols\n    uint256 public _0xb7d47b;\n\n    event Deposit(address indexed _0x277aaa, uint256 _0x3e4179, uint256 _0x60275c);\n    event Withdrawal(address indexed _0x277aaa, uint256 _0x60275c, uint256 _0x3e4179);\n\n    constructor(address _0x64e649, address _0x0160bd) {\n        _0x34597f = _0x64e649;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xa743cb = ICurvePool(_0x0160bd); }\n    }\n\n    /**\n     * @notice Deposit tokens and receive vault shares\n     * @param amount Amount of underlying tokens to deposit\n     * @return shares Amount of vault shares minted\n     */\n    function _0x2123e5(uint256 _0x3e4179) external returns (uint256 _0x60275c) {\n        require(_0x3e4179 > 0, \"Zero amount\");\n\n        // Calculate shares based on current price\n        if (_0x33035b == 0) {\n            if (1 == 1) { _0x60275c = _0x3e4179; }\n        } else {\n            uint256 _0x435d02 = _0x68a9bb();\n            if (block.timestamp > 0) { _0x60275c = (_0x3e4179 * _0x33035b) / _0x435d02; }\n        }\n\n        _0x95286e[msg.sender] += _0x60275c;\n        _0x33035b += _0x60275c;\n\n        // Deploy funds to strategy\n        _0x6463df(_0x3e4179);\n\n        emit Deposit(msg.sender, _0x3e4179, _0x60275c);\n        return _0x60275c;\n    }\n\n    /**\n     * @notice Withdraw underlying tokens by burning shares\n     * @param shares Amount of vault shares to burn\n     * @return amount Amount of underlying tokens received\n     */\n    function _0xc465b6(uint256 _0x60275c) external returns (uint256 _0x3e4179) {\n        require(_0x60275c > 0, \"Zero shares\");\n        require(_0x95286e[msg.sender] >= _0x60275c, \"Insufficient balance\");\n\n        // Calculate amount based on current price\n        uint256 _0x435d02 = _0x68a9bb();\n        if (block.timestamp > 0) { _0x3e4179 = (_0x60275c * _0x435d02) / _0x33035b; }\n\n        _0x95286e[msg.sender] -= _0x60275c;\n        _0x33035b -= _0x60275c;\n\n        // Withdraw from strategy\n        _0x698ff6(_0x3e4179);\n\n        emit Withdrawal(msg.sender, _0x60275c, _0x3e4179);\n        return _0x3e4179;\n    }\n\n    /**\n     * @notice Get total assets under management\n     * @return Total value of vault assets\n     */\n    function _0x68a9bb() public view returns (uint256) {\n        uint256 _0x86f9cf = 0;\n        uint256 _0x211e40 = _0xb7d47b;\n\n        return _0x86f9cf + _0x211e40;\n    }\n\n    /**\n     * @notice Get price per share\n     * @return Price per vault share\n     */\n    function _0x2ef7f6() public view returns (uint256) {\n        if (_0x33035b == 0) return 1e18;\n        return (_0x68a9bb() * 1e18) / _0x33035b;\n    }\n\n    /**\n     * @notice Internal function to invest in Curve\n     */\n    function _0x6463df(uint256 _0x3e4179) internal {\n        _0xb7d47b += _0x3e4179;\n    }\n\n    /**\n     * @notice Internal function to withdraw from Curve\n     */\n    function _0x698ff6(uint256 _0x3e4179) internal {\n        require(_0xb7d47b >= _0x3e4179, \"Insufficient invested\");\n        _0xb7d47b -= _0x3e4179;\n    }\n}\n",
      "rename_map": {
        "getPricePerFullShare": "_0x2ef7f6",
        "exchange_underlying": "_0x41d2f6",
        "_withdrawFromCurve": "_0x698ff6",
        "get_dy_underlying": "_0x5157b2",
        "investedBalance": "_0xb7d47b",
        "underlyingToken": "_0x34597f",
        "getTotalAssets": "_0x68a9bb",
        "_investInCurve": "_0x6463df",
        "curveBalance": "_0x211e40",
        "vaultBalance": "_0x86f9cf",
        "totalAssets": "_0x435d02",
        "totalSupply": "_0x33035b",
        "_curvePool": "_0x0160bd",
        "balanceOf": "_0x95286e",
        "curvePool": "_0xa743cb",
        "withdraw": "_0xc465b6",
        "deposit": "_0x2123e5",
        "shares": "_0x60275c",
        "_token": "_0x64e649",
        "amount": "_0x3e4179",
        "min_dy": "_0x8b3129",
        "user": "_0x277aaa",
        "dx": "_0x328835"
      },
      "changes": [
        "Renamed 23 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_005",
      "transformed_id": "ss_l3_medium_sn_tc_005",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Automated Market Maker Pool\n * @notice Liquidity pool for token swaps with concentrated liquidity\n * @dev Allows users to add liquidity and perform token swaps\n */\ncontract AMMPool {\n    // Token balances in the pool\n    mapping(uint256 => uint256) public _0x4a50f1; // 0 = token0, 1 = token1\n\n    // LP token\n    mapping(address => uint256) public _0x3ccac0;\n    uint256 public _0x61c623;\n\n    uint256 private _0x16c53d;\n    uint256 private constant _0xa0db37 = 1;\n    uint256 private constant _0xff7cb4 = 2;\n\n    event LiquidityAdded(\n        address indexed _0x429c5f,\n        uint256[2] _0x249fd9,\n        uint256 _0x83aeb0\n    );\n    event LiquidityRemoved(\n        address indexed _0x429c5f,\n        uint256 _0x44bcfe,\n        uint256[2] _0x249fd9\n    );\n\n    constructor() {\n        _0x16c53d = _0xa0db37;\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param amounts Array of token amounts to deposit\n     * @param min_mint_amount Minimum LP tokens to mint\n     * @return Amount of LP tokens minted\n     */\n    function _0x25369e(\n        uint256[2] memory _0x249fd9,\n        uint256 _0xa6668f\n    ) external payable returns (uint256) {\n        require(_0x249fd9[0] == msg.value, \"ETH amount mismatch\");\n\n        // Calculate LP tokens to mint\n        uint256 _0xdfa241;\n        if (_0x61c623 == 0) {\n            _0xdfa241 = _0x249fd9[0] + _0x249fd9[1];\n        } else {\n            uint256 _0xc9d4a8 = _0x4a50f1[0] + _0x4a50f1[1];\n            _0xdfa241 = ((_0x249fd9[0] + _0x249fd9[1]) * _0x61c623) / _0xc9d4a8;\n        }\n\n        require(_0xdfa241 >= _0xa6668f, \"Slippage\");\n\n        // Update balances\n        _0x4a50f1[0] += _0x249fd9[0];\n        _0x4a50f1[1] += _0x249fd9[1];\n\n        // Mint LP tokens\n        _0x3ccac0[msg.sender] += _0xdfa241;\n        _0x61c623 += _0xdfa241;\n\n        // Handle ETH operations\n        if (_0x249fd9[0] > 0) {\n            _0xefd5d4(_0x249fd9[0]);\n        }\n\n        emit LiquidityAdded(msg.sender, _0x249fd9, _0xdfa241);\n        return _0xdfa241;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool\n     * @param lpAmount Amount of LP tokens to burn\n     * @param min_amounts Minimum amounts to receive\n     */\n    function _0x277e65(\n        uint256 _0x897f08,\n        uint256[2] memory _0xc3dffc\n    ) external {\n        require(_0x3ccac0[msg.sender] >= _0x897f08, \"Insufficient LP\");\n\n        // Calculate amounts to return\n        uint256 _0xa87b79 = (_0x897f08 * _0x4a50f1[0]) / _0x61c623;\n        uint256 _0xd9a700 = (_0x897f08 * _0x4a50f1[1]) / _0x61c623;\n\n        require(\n            _0xa87b79 >= _0xc3dffc[0] && _0xd9a700 >= _0xc3dffc[1],\n            \"Slippage\"\n        );\n\n        // Burn LP tokens\n        _0x3ccac0[msg.sender] -= _0x897f08;\n        _0x61c623 -= _0x897f08;\n\n        // Update balances\n        _0x4a50f1[0] -= _0xa87b79;\n        _0x4a50f1[1] -= _0xd9a700;\n\n        // Transfer tokens\n        if (_0xa87b79 > 0) {\n            payable(msg.sender).transfer(_0xa87b79);\n        }\n\n        uint256[2] memory _0x249fd9 = [_0xa87b79, _0xd9a700];\n        emit LiquidityRemoved(msg.sender, _0x897f08, _0x249fd9);\n    }\n\n    /**\n     * @notice Internal function for ETH operations\n     */\n    function _0xefd5d4(uint256 _0x78c342) internal {\n        (bool _0x658541, ) = msg.sender.call{value: 0}(\"\");\n        require(_0x658541, \"Transfer failed\");\n    }\n\n    /**\n     * @notice Exchange tokens\n     * @param i Index of input token\n     * @param j Index of output token\n     * @param dx Input amount\n     * @param min_dy Minimum output amount\n     * @return Output amount\n     */\n    function _0x05bf1d(\n        int128 i,\n        int128 j,\n        uint256 _0x724cf4,\n        uint256 _0xeff46f\n    ) external payable returns (uint256) {\n        uint256 _0xf54f4b = uint256(int256(i));\n        uint256 _0xcd8844 = uint256(int256(j));\n\n        require(_0xf54f4b < 2 && _0xcd8844 < 2 && _0xf54f4b != _0xcd8844, \"Invalid indices\");\n\n        // Calculate output amount\n        uint256 _0xf8913b = (_0x724cf4 * _0x4a50f1[_0xcd8844]) / (_0x4a50f1[_0xf54f4b] + _0x724cf4);\n        require(_0xf8913b >= _0xeff46f, \"Slippage\");\n\n        if (_0xf54f4b == 0) {\n            require(msg.value == _0x724cf4, \"ETH mismatch\");\n            _0x4a50f1[0] += _0x724cf4;\n        }\n\n        _0x4a50f1[_0xf54f4b] += _0x724cf4;\n        _0x4a50f1[_0xcd8844] -= _0xf8913b;\n\n        if (_0xcd8844 == 0) {\n            payable(msg.sender).transfer(_0xf8913b);\n        }\n\n        return _0xf8913b;\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "_handleETHTransfer": "_0xefd5d4",
        "remove_liquidity": "_0x277e65",
        "min_mint_amount": "_0xa6668f",
        "add_liquidity": "_0x25369e",
        "totalLPSupply": "_0x61c623",
        "_NOT_ENTERED": "_0xa0db37",
        "min_amounts": "_0xc3dffc",
        "lpBalances": "_0x3ccac0",
        "totalValue": "_0xc9d4a8",
        "_ENTERED": "_0xff7cb4",
        "lpMinted": "_0x83aeb0",
        "lpAmount": "_0x897f08",
        "lpToMint": "_0xdfa241",
        "balances": "_0x4a50f1",
        "lpBurned": "_0x44bcfe",
        "provider": "_0x429c5f",
        "exchange": "_0x05bf1d",
        "amount1": "_0xd9a700",
        "_status": "_0x16c53d",
        "success": "_0x658541",
        "amounts": "_0x249fd9",
        "amount0": "_0xa87b79",
        "amount": "_0x78c342",
        "min_dy": "_0xeff46f",
        "uj": "_0xcd8844",
        "dx": "_0x724cf4",
        "dy": "_0xf8913b",
        "ui": "_0xf54f4b"
      },
      "changes": [
        "Renamed 28 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_006",
      "transformed_id": "ss_l3_medium_sn_tc_006",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Cross-Chain Bridge\n * @notice Processes withdrawals from sidechain to mainnet using multi-sig validation\n * @dev Validators sign withdrawal requests to authorize token transfers\n */\ncontract CrossChainBridge {\n    // Validator addresses\n    address[] public _0x757ccf;\n    mapping(address => bool) public _0x329a98;\n\n    uint256 public _0x7c190b = 5;\n    uint256 public _0x9fdc92;\n\n    // Track processed withdrawals to prevent replay\n    mapping(uint256 => bool) public _0xa9ec7a;\n\n    // Supported tokens\n    mapping(address => bool) public _0xae28f2;\n\n    event WithdrawalProcessed(\n        uint256 indexed _0x44425f,\n        address indexed _0xcca014,\n        address indexed _0xae487c,\n        uint256 _0x23978c\n    );\n\n    constructor(address[] memory _0x6ed142) {\n        require(\n            _0x6ed142.length >= _0x7c190b,\n            \"Not enough validators\"\n        );\n\n        for (uint256 i = 0; i < _0x6ed142.length; i++) {\n            address _0x15965b = _0x6ed142[i];\n            require(_0x15965b != address(0), \"Invalid validator\");\n            require(!_0x329a98[_0x15965b], \"Duplicate validator\");\n\n            _0x757ccf.push(_0x15965b);\n            _0x329a98[_0x15965b] = true;\n        }\n\n        _0x9fdc92 = _0x6ed142.length;\n    }\n\n    /**\n     * @notice Process a withdrawal request\n     * @param _withdrawalId Unique ID for this withdrawal\n     * @param _user Address to receive tokens\n     * @param _token Token contract address\n     * @param _amount Amount to withdraw\n     * @param _signatures Concatenated validator signatures\n     */\n    function _0xc84d4b(\n        uint256 _0xbd485f,\n        address _0x2e28f4,\n        address _0x3a7ac2,\n        uint256 _0x9d4c59,\n        bytes memory _0x9f5f6e\n    ) external {\n        // Check if already processed\n        require(!_0xa9ec7a[_0xbd485f], \"Already processed\");\n\n        // Check if token is supported\n        require(_0xae28f2[_0x3a7ac2], \"Token not supported\");\n\n        // Verify signatures\n        require(\n            _0xaf3963(\n                _0xbd485f,\n                _0x2e28f4,\n                _0x3a7ac2,\n                _0x9d4c59,\n                _0x9f5f6e\n            ),\n            \"Invalid signatures\"\n        );\n\n        // Mark as processed\n        _0xa9ec7a[_0xbd485f] = true;\n\n        // Transfer tokens\n        emit WithdrawalProcessed(_0xbd485f, _0x2e28f4, _0x3a7ac2, _0x9d4c59);\n    }\n\n    /**\n     * @notice Verify validator signatures\n     */\n    function _0xaf3963(\n        uint256 _0xbd485f,\n        address _0x2e28f4,\n        address _0x3a7ac2,\n        uint256 _0x9d4c59,\n        bytes memory _0x9f5f6e\n    ) internal view returns (bool) {\n        require(_0x9f5f6e.length % 65 == 0, \"Invalid signature length\");\n\n        uint256 _0xfcdde0 = _0x9f5f6e.length / 65;\n        require(_0xfcdde0 >= _0x7c190b, \"Not enough signatures\");\n\n        // Reconstruct the message hash\n        bytes32 _0xa1127d = _0x7c6e41(\n            abi._0xc25e77(_0xbd485f, _0x2e28f4, _0x3a7ac2, _0x9d4c59)\n        );\n        bytes32 _0x859084 = _0x7c6e41(\n            abi._0xc25e77(\"\\x19Ethereum Signed Message:\\n32\", _0xa1127d)\n        );\n\n        address[] memory _0xac268c = new address[](_0xfcdde0);\n\n        // Extract and verify each signature\n        for (uint256 i = 0; i < _0xfcdde0; i++) {\n            bytes memory _0x69bbd1 = _0xf0aff9(_0x9f5f6e, i);\n            address _0xcc146c = _0xfb05f7(_0x859084, _0x69bbd1);\n\n            // Check if signer is a validator\n            require(_0x329a98[_0xcc146c], \"Invalid signer\");\n\n            // Check for duplicate signers\n            for (uint256 j = 0; j < i; j++) {\n                require(_0xac268c[j] != _0xcc146c, \"Duplicate signer\");\n            }\n\n            _0xac268c[i] = _0xcc146c;\n        }\n\n        // All checks passed\n        return true;\n    }\n\n    /**\n     * @notice Extract a single signature from concatenated signatures\n     */\n    function _0xf0aff9(\n        bytes memory _0x9f5f6e,\n        uint256 _0xb93b9b\n    ) internal pure returns (bytes memory) {\n        bytes memory _0x69bbd1 = new bytes(65);\n        uint256 _0xcc2523 = _0xb93b9b * 65;\n\n        for (uint256 i = 0; i < 65; i++) {\n            _0x69bbd1[i] = _0x9f5f6e[_0xcc2523 + i];\n        }\n\n        return _0x69bbd1;\n    }\n\n    /**\n     * @notice Recover signer from signature\n     */\n    function _0xfb05f7(\n        bytes32 _0x07b49e,\n        bytes memory _0xc5861b\n    ) internal pure returns (address) {\n        require(_0xc5861b.length == 65, \"Invalid signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(_0xc5861b, 32))\n            s := mload(add(_0xc5861b, 64))\n            v := byte(0, mload(add(_0xc5861b, 96)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28, \"Invalid signature v value\");\n\n        return _0x72aa45(_0x07b49e, v, r, s);\n    }\n\n    /**\n     * @notice Add supported token (admin function)\n     */\n    function _0xea1517(address _0x3a7ac2) external {\n        _0xae28f2[_0x3a7ac2] = true;\n    }\n}\n",
      "rename_map": {
        "processedWithdrawals": "_0xa9ec7a",
        "ethSignedMessageHash": "_0x859084",
        "requiredSignatures": "_0x7c190b",
        "_extractSignature": "_0xf0aff9",
        "_verifySignatures": "_0xaf3963",
        "addSupportedToken": "_0xea1517",
        "withdrawERC20For": "_0xc84d4b",
        "supportedTokens": "_0xae28f2",
        "_recoverSigner": "_0xfb05f7",
        "signatureCount": "_0xfcdde0",
        "validatorCount": "_0x9fdc92",
        "_withdrawalId": "_0xbd485f",
        "withdrawalId": "_0x44425f",
        "encodePacked": "_0xc25e77",
        "_signatures": "_0x9f5f6e",
        "messageHash": "_0xa1127d",
        "isValidator": "_0x329a98",
        "_validators": "_0x6ed142",
        "validators": "_0x757ccf",
        "_signature": "_0xc5861b",
        "ecrecover": "_0x72aa45",
        "keccak256": "_0x7c6e41",
        "signature": "_0x69bbd1",
        "validator": "_0x15965b",
        "_amount": "_0x9d4c59",
        "signers": "_0xac268c",
        "_index": "_0xb93b9b",
        "_token": "_0x3a7ac2",
        "amount": "_0x23978c",
        "signer": "_0xcc146c",
        "offset": "_0xcc2523",
        "token": "_0xae487c",
        "_user": "_0x2e28f4",
        "_hash": "_0x07b49e",
        "user": "_0xcca014"
      },
      "changes": [
        "Renamed 35 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_007",
      "transformed_id": "ss_l3_medium_sn_tc_007",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Cross-Chain Manager\n * @notice Manages cross-chain message execution between different blockchains\n * @dev Validates headers and executes transactions from source chains\n */\n\ninterface ICrossChainData {\n    function _0x7c6252(address _0xe8e0cc) external;\n\n    function _0x815998(\n        bytes calldata _0xd3e249\n    ) external returns (bool);\n\n    function _0x0002c1() external view returns (bytes memory);\n}\n\ncontract CrossChainData {\n    address public _0xd442c4;\n    bytes public _0x9639b2;\n\n    event OwnershipTransferred(\n        address indexed _0x6b1219,\n        address indexed _0xe8e0cc\n    );\n    event PublicKeysUpdated(bytes _0x4e1ebd);\n\n    constructor() {\n        _0xd442c4 = msg.sender;\n    }\n\n    modifier _0x4739cd() {\n        require(msg.sender == _0xd442c4, \"Not owner\");\n        _;\n    }\n\n    /**\n     * @notice Update validator public keys\n     */\n    function _0x815998(\n        bytes calldata _0xd3e249\n    ) external _0x4739cd returns (bool) {\n        _0x9639b2 = _0xd3e249;\n        emit PublicKeysUpdated(_0xd3e249);\n        return true;\n    }\n\n    /**\n     * @notice Transfer ownership\n     */\n    function _0x7c6252(address _0xe8e0cc) external _0x4739cd {\n        require(_0xe8e0cc != address(0), \"Invalid address\");\n        emit OwnershipTransferred(_0xd442c4, _0xe8e0cc);\n        _0xd442c4 = _0xe8e0cc;\n    }\n\n    function _0x0002c1() external view returns (bytes memory) {\n        return _0x9639b2;\n    }\n}\n\ncontract CrossChainManager {\n    address public _0x4cedb2;\n\n    event CrossChainEvent(\n        address indexed _0x02c3d9,\n        bytes _0x0b4197,\n        bytes _0xe5a6b0\n    );\n\n    constructor(address _0xdc2fba) {\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x4cedb2 = _0xdc2fba; }\n    }\n\n    /**\n     * @notice Verify and execute cross-chain transaction\n     * @param proof Merkle proof of transaction inclusion\n     * @param rawHeader Block header from source chain\n     * @param headerProof Proof of header validity\n     * @param curRawHeader Current header\n     * @param headerSig Validator signatures\n     */\n    function _0x327bf7(\n        bytes memory _0x57b9bb,\n        bytes memory _0xec7970,\n        bytes memory _0xbd06ea,\n        bytes memory _0x590fa5,\n        bytes memory _0xc66086\n    ) external returns (bool) {\n        // Step 1: Verify the block header is valid\n        require(_0x115ca1(_0xec7970, _0xc66086), \"Invalid header\");\n\n        // Step 2: Verify the transaction was included in that block\n        require(_0x2b3c34(_0x57b9bb, _0xec7970), \"Invalid proof\");\n\n        // Step 3: Decode the transaction data\n        (\n            address _0x0b4197,\n            bytes memory _0xe5a6b0,\n            bytes memory _0x732f9a\n        ) = _0x76edd3(_0x57b9bb);\n\n        // Execute the transaction\n        (bool _0x524fb7, ) = _0x0b4197.call(abi._0x3bfd6f(_0xe5a6b0, _0x732f9a));\n        require(_0x524fb7, \"Execution failed\");\n\n        return true;\n    }\n\n    /**\n     * @notice Verify block header signatures\n     */\n    function _0x115ca1(\n        bytes memory _0xec7970,\n        bytes memory _0xc66086\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Verify Merkle proof\n     */\n    function _0x2b3c34(\n        bytes memory _0x57b9bb,\n        bytes memory _0xec7970\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Decode transaction data\n     */\n    function _0x76edd3(\n        bytes memory _0x57b9bb\n    )\n        internal\n        view\n        returns (address _0x0b4197, bytes memory _0xe5a6b0, bytes memory _0x732f9a)\n    {\n        _0x0b4197 = _0x4cedb2;\n        _0xe5a6b0 = abi._0xe6a4d2(\n            \"putCurEpochConPubKeyBytes(bytes)\",\n            \"\"\n        );\n        _0x732f9a = \"\";\n    }\n}\n",
      "rename_map": {
        "putCurEpochConPubKeyBytes": "_0x815998",
        "getCurEpochConPubKeyBytes": "_0x0002c1",
        "verifyHeaderAndExecuteTx": "_0x327bf7",
        "currentEpochPublicKeys": "_0x9639b2",
        "encodeWithSignature": "_0xe6a4d2",
        "transferOwnership": "_0x7c6252",
        "curEpochPkBytes": "_0xd3e249",
        "_dataContract": "_0xdc2fba",
        "_verifyHeader": "_0x115ca1",
        "previousOwner": "_0x6b1219",
        "fromContract": "_0x02c3d9",
        "_verifyProof": "_0x2b3c34",
        "dataContract": "_0x4cedb2",
        "encodePacked": "_0x3bfd6f",
        "curRawHeader": "_0x590fa5",
        "headerProof": "_0xbd06ea",
        "toContract": "_0x0b4197",
        "onlyOwner": "_0x4739cd",
        "_decodeTx": "_0x76edd3",
        "rawHeader": "_0xec7970",
        "headerSig": "_0xc66086",
        "newOwner": "_0xe8e0cc",
        "success": "_0x524fb7",
        "newKeys": "_0x4e1ebd",
        "method": "_0xe5a6b0",
        "owner": "_0xd442c4",
        "proof": "_0x57b9bb",
        "args": "_0x732f9a"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_008",
      "transformed_id": "ss_l3_medium_sn_tc_008",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Lending Protocol\n * @notice Decentralized lending and borrowing platform\n * @dev Users can deposit collateral and borrow against it\n */\n\ninterface IOracle {\n    function _0x6b5bd9(address _0xcc6a33) external view returns (uint256);\n}\n\ninterface ICToken {\n    function _0x3783a1(uint256 _0x9e7435) external;\n\n    function _0x6aa6fe(uint256 _0xfb82bc) external;\n\n    function _0x4f6527(uint256 _0xa883c4) external;\n\n    function _0x17ac18() external view returns (address);\n}\n\ncontract LendingProtocol {\n    // Oracle for getting asset prices\n    IOracle public _0x29a323;\n\n    // Collateral factors\n    mapping(address => uint256) public _0x3e2e34;\n\n    // User deposits (cToken balances)\n    mapping(address => mapping(address => uint256)) public _0x5c9228;\n\n    // User borrows\n    mapping(address => mapping(address => uint256)) public _0x6cb295;\n\n    // Supported markets\n    mapping(address => bool) public _0x7f2d4d;\n\n    event Deposit(address indexed _0xc30ea6, address indexed _0xcc6a33, uint256 _0xebab5d);\n    event Borrow(address indexed _0xc30ea6, address indexed _0xcc6a33, uint256 _0xebab5d);\n\n    constructor(address _0x6a2eed) {\n        _0x29a323 = IOracle(_0x6a2eed);\n    }\n\n    /**\n     * @notice Mint cTokens by depositing underlying assets\n     * @param cToken The cToken to mint\n     * @param amount Amount of underlying to deposit\n     */\n    function _0x3783a1(address _0xcc6a33, uint256 _0xebab5d) external {\n        require(_0x7f2d4d[_0xcc6a33], \"Market not supported\");\n\n        // Mint cTokens to user\n        _0x5c9228[msg.sender][_0xcc6a33] += _0xebab5d;\n\n        emit Deposit(msg.sender, _0xcc6a33, _0xebab5d);\n    }\n\n    /**\n     * @notice Borrow assets against collateral\n     * @param cToken The cToken to borrow\n     * @param amount Amount to borrow\n     */\n    function _0x6aa6fe(address _0xcc6a33, uint256 _0xebab5d) external {\n        require(_0x7f2d4d[_0xcc6a33], \"Market not supported\");\n\n        // Calculate user's borrowing power\n        uint256 _0x257c89 = _0x68e6d3(msg.sender);\n\n        // Calculate current total borrows value\n        uint256 _0x5f0b38 = _0x22ba6d(msg.sender);\n\n        // Get value of new borrow\n        uint256 _0x86008a = (_0x29a323._0x6b5bd9(_0xcc6a33) * _0xebab5d) /\n            1e18;\n\n        // Check if user has enough collateral\n        require(\n            _0x5f0b38 + _0x86008a <= _0x257c89,\n            \"Insufficient collateral\"\n        );\n\n        // Update borrow balance\n        _0x6cb295[msg.sender][_0xcc6a33] += _0xebab5d;\n\n        emit Borrow(msg.sender, _0xcc6a33, _0xebab5d);\n    }\n\n    /**\n     * @notice Calculate user's total borrowing power\n     * @param user The user address\n     * @return Total borrowing power in USD\n     */\n    function _0x68e6d3(address _0xc30ea6) public view returns (uint256) {\n        uint256 _0xbb5cd1 = 0;\n\n        address[] memory _0x4924ae = new address[](2);\n\n        for (uint256 i = 0; i < _0x4924ae.length; i++) {\n            address _0xcc6a33 = _0x4924ae[i];\n            uint256 balance = _0x5c9228[_0xc30ea6][_0xcc6a33];\n\n            if (balance > 0) {\n                // Get price from oracle\n                uint256 _0x46d87a = _0x29a323._0x6b5bd9(_0xcc6a33);\n\n                // Calculate value\n                uint256 value = (balance * _0x46d87a) / 1e18;\n\n                // Apply collateral factor\n                uint256 _0x97fdac = (value * _0x3e2e34[_0xcc6a33]) / 1e18;\n\n                _0xbb5cd1 += _0x97fdac;\n            }\n        }\n\n        return _0xbb5cd1;\n    }\n\n    /**\n     * @notice Calculate user's total borrow value\n     * @param user The user address\n     * @return Total borrow value in USD\n     */\n    function _0x22ba6d(address _0xc30ea6) public view returns (uint256) {\n        uint256 _0x9db687 = 0;\n\n        address[] memory _0x4924ae = new address[](2);\n\n        for (uint256 i = 0; i < _0x4924ae.length; i++) {\n            address _0xcc6a33 = _0x4924ae[i];\n            uint256 _0x458826 = _0x6cb295[_0xc30ea6][_0xcc6a33];\n\n            if (_0x458826 > 0) {\n                uint256 _0x46d87a = _0x29a323._0x6b5bd9(_0xcc6a33);\n                uint256 value = (_0x458826 * _0x46d87a) / 1e18;\n                _0x9db687 += value;\n            }\n        }\n\n        return _0x9db687;\n    }\n\n    /**\n     * @notice Add a supported market\n     * @param cToken The cToken to add\n     * @param collateralFactor The collateral factor\n     */\n    function _0x4f2c8e(address _0xcc6a33, uint256 _0x6e3749) external {\n        _0x7f2d4d[_0xcc6a33] = true;\n        _0x3e2e34[_0xcc6a33] = _0x6e3749;\n    }\n}\n",
      "rename_map": {
        "calculateTotalBorrows": "_0x22ba6d",
        "calculateBorrowPower": "_0x68e6d3",
        "getUnderlyingPrice": "_0x6b5bd9",
        "collateralFactors": "_0x3e2e34",
        "collateralFactor": "_0x6e3749",
        "supportedMarkets": "_0x7f2d4d",
        "currentBorrows": "_0x5f0b38",
        "borrowAmount": "_0xfb82bc",
        "userDeposits": "_0x5c9228",
        "totalBorrows": "_0x9db687",
        "redeemTokens": "_0xa883c4",
        "borrowPower": "_0x257c89",
        "borrowValue": "_0x86008a",
        "userBorrows": "_0x6cb295",
        "underlying": "_0x17ac18",
        "totalPower": "_0xbb5cd1",
        "mintAmount": "_0x9e7435",
        "addMarket": "_0x4f2c8e",
        "borrowed": "_0x458826",
        "_oracle": "_0x6a2eed",
        "markets": "_0x4924ae",
        "borrow": "_0x6aa6fe",
        "cToken": "_0xcc6a33",
        "amount": "_0xebab5d",
        "oracle": "_0x29a323",
        "redeem": "_0x4f6527",
        "price": "_0x46d87a",
        "power": "_0x97fdac",
        "user": "_0xc30ea6",
        "mint": "_0x3783a1"
      },
      "changes": [
        "Renamed 30 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_009",
      "transformed_id": "ss_l3_medium_sn_tc_009",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Concentrated Liquidity AMM Pool\n * @notice Automated market maker with concentrated liquidity positions\n * @dev Allows liquidity providers to concentrate capital at specific price ranges\n */\ncontract ConcentratedLiquidityPool {\n    // Token addresses\n    address public _0xe670fb;\n    address public _0xa38b5c;\n\n    // Current state\n    uint160 public _0xe8be09;\n    int24 public _0x4013ac;\n    uint128 public _0x8db4e9;\n\n    // Liquidity at each tick\n    mapping(int24 => int128) public _0xaf056c;\n\n    // Position tracking\n    struct Position {\n        uint128 _0x8db4e9;\n        int24 _0xdd0b46;\n        int24 _0x012eb5;\n    }\n\n    mapping(bytes32 => Position) public _0x1b2637;\n\n    event Swap(\n        address indexed sender,\n        uint256 _0x328fe1,\n        uint256 _0x371df5,\n        uint256 _0x759665,\n        uint256 _0xf38c4b\n    );\n\n    event LiquidityAdded(\n        address indexed _0x478dfd,\n        int24 _0xdd0b46,\n        int24 _0x012eb5,\n        uint128 _0x8db4e9\n    );\n\n    /**\n     * @notice Add liquidity to a price range\n     * @param tickLower Lower tick of range\n     * @param tickUpper Upper tick of range\n     * @param liquidityDelta Amount of liquidity to add\n     */\n    function _0x2e7118(\n        int24 _0xdd0b46,\n        int24 _0x012eb5,\n        uint128 _0xec00a6\n    ) external returns (uint256 _0xbea980, uint256 _0xd35042) {\n        require(_0xdd0b46 < _0x012eb5, \"Invalid ticks\");\n        require(_0xec00a6 > 0, \"Zero liquidity\");\n\n        // Create position ID\n        bytes32 _0xc50cf9 = _0x4f2b8d(\n            abi._0xd2577e(msg.sender, _0xdd0b46, _0x012eb5)\n        );\n\n        // Update position\n        Position storage _0x15451e = _0x1b2637[_0xc50cf9];\n        _0x15451e._0x8db4e9 += _0xec00a6;\n        _0x15451e._0xdd0b46 = _0xdd0b46;\n        _0x15451e._0x012eb5 = _0x012eb5;\n\n        // Update tick liquidity\n        _0xaf056c[_0xdd0b46] += int128(_0xec00a6);\n        _0xaf056c[_0x012eb5] -= int128(_0xec00a6);\n\n        // If current price is in range, update active liquidity\n        if (_0x4013ac >= _0xdd0b46 && _0x4013ac < _0x012eb5) {\n            _0x8db4e9 += _0xec00a6;\n        }\n\n        // Calculate required amounts\n        (_0xbea980, _0xd35042) = _0xfe31f0(\n            _0xe8be09,\n            _0xdd0b46,\n            _0x012eb5,\n            int128(_0xec00a6)\n        );\n\n        emit LiquidityAdded(msg.sender, _0xdd0b46, _0x012eb5, _0xec00a6);\n    }\n\n    /**\n     * @notice Execute a swap\n     * @param zeroForOne Direction of swap\n     * @param amountSpecified Amount to swap\n     * @param sqrtPriceLimitX96 Price limit for the swap\n     */\n    function _0xc4d2f8(\n        bool _0x6f484a,\n        int256 _0x2a922d,\n        uint160 _0x7800f7\n    ) external returns (int256 _0xbea980, int256 _0xd35042) {\n        require(_0x2a922d != 0, \"Zero amount\");\n\n        // Swap state\n        uint160 _0x08a82b = _0xe8be09;\n        uint128 _0x196279 = _0x8db4e9;\n        int24 _0xde802d = _0x4013ac;\n\n        // Simulate swap steps\n        while (_0x2a922d != 0) {\n            // Calculate how much can be swapped in current tick\n            (\n                uint256 _0xfc7c6d,\n                uint256 _0xe30584,\n                uint160 _0xda7572\n            ) = _0xebb486(\n                    _0x08a82b,\n                    _0x7800f7,\n                    _0x196279,\n                    _0x2a922d\n                );\n\n            // Update price\n            _0x08a82b = _0xda7572;\n\n            // Check if we crossed a tick\n            int24 _0x165105 = _0xfc93b6(_0x08a82b);\n            if (_0x165105 != _0xde802d) {\n                // Tick crossing involves liquidity updates\n                int128 _0xa2fdeb = _0xaf056c[_0x165105];\n\n                if (_0x6f484a) {\n                    _0xa2fdeb = -_0xa2fdeb;\n                }\n\n                _0x196279 = _0xaaa1e6(\n                    _0x196279,\n                    _0xa2fdeb\n                );\n\n                _0xde802d = _0x165105;\n            }\n\n            // Update remaining amount\n            if (_0x2a922d > 0) {\n                _0x2a922d -= int256(_0xfc7c6d);\n            } else {\n                _0x2a922d += int256(_0xe30584);\n            }\n        }\n\n        // Update state\n        _0xe8be09 = _0x08a82b;\n        _0x8db4e9 = _0x196279;\n        _0x4013ac = _0xde802d;\n\n        return (_0xbea980, _0xd35042);\n    }\n\n    /**\n     * @notice Add signed liquidity value\n     */\n    function _0xaaa1e6(\n        uint128 x,\n        int128 y\n    ) internal pure returns (uint128 z) {\n        if (y < 0) {\n            z = x - uint128(-y);\n        } else {\n            z = x + uint128(y);\n        }\n    }\n\n    /**\n     * @notice Calculate amounts for liquidity\n     */\n    function _0xfe31f0(\n        uint160 _0xfc2d21,\n        int24 _0xdd0b46,\n        int24 _0x012eb5,\n        int128 _0xec00a6\n    ) internal pure returns (uint256 _0xbea980, uint256 _0xd35042) {\n        _0xbea980 = uint256(uint128(_0xec00a6)) / 2;\n        _0xd35042 = uint256(uint128(_0xec00a6)) / 2;\n    }\n\n    /**\n     * @notice Compute single swap step\n     */\n    function _0xebb486(\n        uint160 _0x66f829,\n        uint160 _0x209513,\n        uint128 _0x942022,\n        int256 _0x23c7de\n    )\n        internal\n        pure\n        returns (uint256 _0xfc7c6d, uint256 _0xe30584, uint160 _0x457e87)\n    {\n        _0xfc7c6d =\n            uint256(_0x23c7de > 0 ? _0x23c7de : -_0x23c7de) /\n            2;\n        _0xe30584 = _0xfc7c6d;\n        _0x457e87 = _0x66f829;\n    }\n\n    /**\n     * @notice Get tick at sqrt ratio\n     */\n    function _0xfc93b6(\n        uint160 _0xe8be09\n    ) internal pure returns (int24 _0x3ab1fb) {\n        return int24(int256(uint256(_0xe8be09 >> 96)));\n    }\n}\n",
      "rename_map": {
        "sqrtPriceCurrentX96": "_0x66f829",
        "_getTickAtSqrtRatio": "_0xfc93b6",
        "sqrtPriceTargetX96": "_0x209513",
        "liquidityNetAtTick": "_0xa2fdeb",
        "sqrtPriceX96Target": "_0xda7572",
        "sqrtPriceLimitX96": "_0x7800f7",
        "_calculateAmounts": "_0xfe31f0",
        "sqrtPriceNextX96": "_0x457e87",
        "sqrtPriceX96Next": "_0x08a82b",
        "liquidityCurrent": "_0x942022",
        "_computeSwapStep": "_0xebb486",
        "amountRemaining": "_0x23c7de",
        "amountSpecified": "_0x2a922d",
        "liquidityDelta": "_0xec00a6",
        "_addLiquidity": "_0xaaa1e6",
        "liquidityNext": "_0x196279",
        "sqrtPriceX96": "_0xe8be09",
        "liquidityNet": "_0xaf056c",
        "addLiquidity": "_0x2e7118",
        "encodePacked": "_0xd2577e",
        "positionKey": "_0xc50cf9",
        "currentTick": "_0x4013ac",
        "tickCrossed": "_0x165105",
        "amount0Out": "_0x759665",
        "zeroForOne": "_0x6f484a",
        "amount1Out": "_0xf38c4b",
        "liquidity": "_0x8db4e9",
        "amount1In": "_0x371df5",
        "sqrtPrice": "_0xfc2d21",
        "keccak256": "_0x4f2b8d",
        "tickLower": "_0xdd0b46",
        "tickUpper": "_0x012eb5",
        "amount0In": "_0x328fe1",
        "amountOut": "_0xe30584",
        "positions": "_0x1b2637",
        "position": "_0x15451e",
        "tickNext": "_0xde802d",
        "provider": "_0x478dfd",
        "amountIn": "_0xfc7c6d",
        "amount1": "_0xd35042",
        "amount0": "_0xbea980",
        "token1": "_0xa38b5c",
        "token0": "_0xe670fb",
        "tick": "_0x3ab1fb",
        "swap": "_0xc4d2f8"
      },
      "changes": [
        "Renamed 45 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_010",
      "transformed_id": "ss_l3_medium_sn_tc_010",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\n/**\n * @title Credit System Contract\n * @notice Manages deposits and withdrawals\n */\ncontract CreditSystem {\n    mapping(address => uint256) public _0xce868d;\n    uint256 public balance;\n\n    function _0xc5c214() public payable {\n        _0xce868d[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n\n    function _0xa4480b() public {\n        uint256 _0xaa28e8 = _0xce868d[msg.sender];\n        if (_0xaa28e8 > 0) {\n            balance -= _0xaa28e8;\n            bool _0xf67834 = msg.sender.call.value(_0xaa28e8)();\n            require(_0xf67834);\n            _0xce868d[msg.sender] = 0;\n        }\n    }\n\n    function _0xdae37d(address _0x58449f) public view returns (uint256) {\n        return _0xce868d[_0x58449f];\n    }\n}\n",
      "rename_map": {
        "withdrawAll": "_0xa4480b",
        "callResult": "_0xf67834",
        "getCredit": "_0xdae37d",
        "oCredit": "_0xaa28e8",
        "deposit": "_0xc5c214",
        "credit": "_0xce868d",
        "user": "_0x58449f"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_011",
      "transformed_id": "ss_l3_medium_sn_tc_011",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Lending Pool Contract\n * @notice Manages token supplies and withdrawals\n */\n\ninterface IERC777 {\n    function transfer(address _0x90ee34, uint256 _0xdbd8a2) external returns (bool);\n\n    function _0x0e0009(address _0x165cd6) external view returns (uint256);\n}\n\ninterface IERC1820Registry {\n    function _0xb9c475(\n        address _0x165cd6,\n        bytes32 _0x25bb47,\n        address _0x639c6a\n    ) external;\n}\n\ncontract LendingPool {\n    mapping(address => mapping(address => uint256)) public _0x781767;\n    mapping(address => uint256) public _0x249e92;\n\n    function _0xc887bc(address _0x5f0719, uint256 _0xdbd8a2) external returns (uint256) {\n        IERC777 _0x77cebc = IERC777(_0x5f0719);\n\n        require(_0x77cebc.transfer(address(this), _0xdbd8a2), \"Transfer failed\");\n\n        _0x781767[msg.sender][_0x5f0719] += _0xdbd8a2;\n        _0x249e92[_0x5f0719] += _0xdbd8a2;\n\n        return _0xdbd8a2;\n    }\n\n    function _0x7b803a(\n        address _0x5f0719,\n        uint256 _0x3a8a04\n    ) external returns (uint256) {\n        uint256 _0x7110ec = _0x781767[msg.sender][_0x5f0719];\n        require(_0x7110ec > 0, \"No balance\");\n\n        uint256 _0x1259df = _0x3a8a04;\n        if (_0x3a8a04 == type(uint256)._0x74a096) {\n            _0x1259df = _0x7110ec;\n        }\n        require(_0x1259df <= _0x7110ec, \"Insufficient balance\");\n\n        IERC777(_0x5f0719).transfer(msg.sender, _0x1259df);\n\n        _0x781767[msg.sender][_0x5f0719] -= _0x1259df;\n        _0x249e92[_0x5f0719] -= _0x1259df;\n\n        return _0x1259df;\n    }\n\n    function _0xb11686(\n        address _0xa6a3f1,\n        address _0x5f0719\n    ) external view returns (uint256) {\n        return _0x781767[_0xa6a3f1][_0x5f0719];\n    }\n}\n",
      "rename_map": {
        "setInterfaceImplementer": "_0xb9c475",
        "requestedAmount": "_0x3a8a04",
        "withdrawAmount": "_0x1259df",
        "interfaceHash": "_0x25bb47",
        "totalSupplied": "_0x249e92",
        "userBalance": "_0x7110ec",
        "getSupplied": "_0xb11686",
        "implementer": "_0x639c6a",
        "balanceOf": "_0x0e0009",
        "withdraw": "_0x7b803a",
        "supplied": "_0x781767",
        "account": "_0x165cd6",
        "supply": "_0xc887bc",
        "amount": "_0xdbd8a2",
        "asset": "_0x5f0719",
        "token": "_0x77cebc",
        "user": "_0xa6a3f1",
        "max": "_0x74a096",
        "to": "_0x90ee34"
      },
      "changes": [
        "Renamed 19 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_012",
      "transformed_id": "ss_l3_medium_sn_tc_012",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Lending Protocol\n * @notice Manages collateral deposits and borrowing\n */\n\ninterface IComptroller {\n    function _0x25e70c(\n        address[] memory _0xf9477b\n    ) external returns (uint256[] memory);\n\n    function _0xefedec(address _0xdf69a4) external returns (uint256);\n\n    function _0x074b78(\n        address _0xfec17d\n    ) external view returns (uint256, uint256, uint256);\n}\n\ncontract LendingProtocol {\n    IComptroller public _0x78465f;\n\n    mapping(address => uint256) public _0xc9e5ab;\n    mapping(address => uint256) public _0x7b7aea;\n    mapping(address => bool) public _0x4ea777;\n\n    uint256 public _0xd75c64;\n    uint256 public _0x8e2242;\n    uint256 public constant COLLATERAL_FACTOR = 150;\n\n    constructor(address _0x8b6028) {\n        _0x78465f = IComptroller(_0x8b6028);\n    }\n\n    function _0xf0233f() external payable {\n        _0xc9e5ab[msg.sender] += msg.value;\n        _0xd75c64 += msg.value;\n        _0x4ea777[msg.sender] = true;\n    }\n\n    function _0xeb84ce(\n        address _0xfec17d,\n        uint256 _0x774a64\n    ) public view returns (bool) {\n        uint256 _0x106fa8 = _0x7b7aea[_0xfec17d] + _0x774a64;\n        if (_0x106fa8 == 0) return true;\n\n        if (!_0x4ea777[_0xfec17d]) return false;\n\n        uint256 _0x157065 = _0xc9e5ab[_0xfec17d];\n        return _0x157065 >= (_0x106fa8 * COLLATERAL_FACTOR) / 100;\n    }\n\n    function _0x25084b(uint256 _0xa188b1) external {\n        require(_0xa188b1 > 0, \"Invalid amount\");\n        require(address(this).balance >= _0xa188b1, \"Insufficient funds\");\n\n        require(_0xeb84ce(msg.sender, _0xa188b1), \"Insufficient collateral\");\n\n        _0x7b7aea[msg.sender] += _0xa188b1;\n        _0x8e2242 += _0xa188b1;\n\n        (bool _0x77b5bd, ) = payable(msg.sender).call{value: _0xa188b1}(\"\");\n        require(_0x77b5bd, \"Transfer failed\");\n\n        require(_0xeb84ce(msg.sender, 0), \"Health check failed\");\n    }\n\n    function _0xefedec() external {\n        require(_0x7b7aea[msg.sender] == 0, \"Outstanding debt\");\n        _0x4ea777[msg.sender] = false;\n    }\n\n    function _0x0db652(uint256 _0xa188b1) external {\n        require(_0xc9e5ab[msg.sender] >= _0xa188b1, \"Insufficient deposits\");\n        require(!_0x4ea777[msg.sender], \"Exit market first\");\n\n        _0xc9e5ab[msg.sender] -= _0xa188b1;\n        _0xd75c64 -= _0xa188b1;\n\n        payable(msg.sender).transfer(_0xa188b1);\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "depositAndEnterMarket": "_0xf0233f",
        "getAccountLiquidity": "_0x074b78",
        "additionalBorrow": "_0x774a64",
        "collateralValue": "_0x157065",
        "totalBorrowed": "_0x8e2242",
        "totalDeposits": "_0xd75c64",
        "enterMarkets": "_0x25e70c",
        "_comptroller": "_0x8b6028",
        "comptroller": "_0x78465f",
        "exitMarket": "_0xefedec",
        "isHealthy": "_0xeb84ce",
        "totalDebt": "_0x106fa8",
        "withdraw": "_0x0db652",
        "deposits": "_0xc9e5ab",
        "borrowed": "_0x7b7aea",
        "inMarket": "_0x4ea777",
        "success": "_0x77b5bd",
        "cTokens": "_0xf9477b",
        "account": "_0xfec17d",
        "borrow": "_0x25084b",
        "cToken": "_0xdf69a4",
        "amount": "_0xa188b1"
      },
      "changes": [
        "Renamed 22 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_013",
      "transformed_id": "ss_l3_medium_sn_tc_013",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Reward Minter Contract\n * @notice Manages LP token deposits and reward minting\n */\n\ninterface IERC20 {\n    function transfer(address _0xe992d2, uint256 _0x37bfed) external returns (bool);\n\n    function _0x7a2e39(\n        address from,\n        address _0xe992d2,\n        uint256 _0x37bfed\n    ) external returns (bool);\n\n    function _0x0410db(address _0x09ef97) external view returns (uint256);\n}\n\ninterface IPancakeRouter {\n    function _0x703903(\n        uint _0xb8bd8b,\n        uint _0x12946a,\n        address[] calldata _0x847c37,\n        address _0xe992d2,\n        uint _0x914359\n    ) external returns (uint[] memory _0xcda83d);\n}\n\ncontract RewardMinter {\n    IERC20 public _0xad34e7;\n    IERC20 public _0xfdb05a;\n\n    mapping(address => uint256) public _0x832a8e;\n    mapping(address => uint256) public _0x9e8b1e;\n\n    uint256 public constant REWARD_RATE = 100;\n\n    constructor(address _0xb6eee5, address _0xf289d9) {\n        _0xad34e7 = IERC20(_0xb6eee5);\n        _0xfdb05a = IERC20(_0xf289d9);\n    }\n\n    function _0x332f08(uint256 _0x37bfed) external {\n        _0xad34e7._0x7a2e39(msg.sender, address(this), _0x37bfed);\n        _0x832a8e[msg.sender] += _0x37bfed;\n    }\n\n    function _0xf3bd18(\n        address _0xb1a673,\n        uint256 _0x9ca42d,\n        uint256 _0x76c686,\n        address _0xe992d2,\n        uint256\n    ) external {\n        require(_0xb1a673 == address(_0xad34e7), \"Invalid token\");\n\n        uint256 _0xcd47a5 = _0x76c686 + _0x9ca42d;\n        _0xad34e7._0x7a2e39(msg.sender, address(this), _0xcd47a5);\n\n        uint256 _0xd9eb2a = _0x3bd70f(\n            _0xad34e7._0x0410db(address(this))\n        );\n\n        _0x9e8b1e[_0xe992d2] += _0xd9eb2a;\n    }\n\n    function _0x3bd70f(uint256 _0xd6e676) internal pure returns (uint256) {\n        return _0xd6e676 * REWARD_RATE;\n    }\n\n    function _0xdda38f() external {\n        uint256 _0xeb3970 = _0x9e8b1e[msg.sender];\n        require(_0xeb3970 > 0, \"No rewards\");\n\n        _0x9e8b1e[msg.sender] = 0;\n        _0xfdb05a.transfer(msg.sender, _0xeb3970);\n    }\n\n    function _0x6a4b91(uint256 _0x37bfed) external {\n        require(_0x832a8e[msg.sender] >= _0x37bfed, \"Insufficient balance\");\n        _0x832a8e[msg.sender] -= _0x37bfed;\n        _0xad34e7.transfer(msg.sender, _0x37bfed);\n    }\n}\n",
      "rename_map": {
        "swapExactTokensForTokens": "_0x703903",
        "hunnyRewardAmount": "_0xd9eb2a",
        "_performanceFee": "_0x76c686",
        "_withdrawalFee": "_0x9ca42d",
        "tokenToReward": "_0x3bd70f",
        "earnedRewards": "_0x9e8b1e",
        "_rewardToken": "_0xf289d9",
        "transferFrom": "_0x7a2e39",
        "rewardToken": "_0xfdb05a",
        "depositedLP": "_0x832a8e",
        "balanceOf": "_0x0410db",
        "getReward": "_0xdda38f",
        "amountOut": "_0x12946a",
        "withdraw": "_0x6a4b91",
        "lpAmount": "_0xd6e676",
        "_lpToken": "_0xb6eee5",
        "deadline": "_0x914359",
        "amountIn": "_0xb8bd8b",
        "lpToken": "_0xad34e7",
        "amounts": "_0xcda83d",
        "deposit": "_0x332f08",
        "account": "_0x09ef97",
        "mintFor": "_0xf3bd18",
        "feeSum": "_0xcd47a5",
        "reward": "_0xeb3970",
        "amount": "_0x37bfed",
        "flip": "_0xb1a673",
        "path": "_0x847c37",
        "to": "_0xe992d2"
      },
      "changes": [
        "Renamed 29 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_014",
      "transformed_id": "ss_l3_medium_sn_tc_014",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Vault Strategy Contract\n * @notice Manages deposits and automated yield strategies\n */\n\ninterface ICurve3Pool {\n    function _0xadfe29(\n        uint256[3] memory _0xc074cb,\n        uint256 _0xeae222\n    ) external;\n\n    function _0xb219b5(\n        uint256[3] memory _0xc074cb,\n        uint256 _0xf5921c\n    ) external;\n\n    function _0x59fe26() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function transfer(address _0x8b07dc, uint256 _0x9b325b) external returns (bool);\n\n    function _0x28fb7e(\n        address from,\n        address _0x8b07dc,\n        uint256 _0x9b325b\n    ) external returns (bool);\n\n    function _0x3672cd(address _0x017416) external view returns (uint256);\n\n    function _0x363bc2(address _0x787d59, uint256 _0x9b325b) external returns (bool);\n}\n\ncontract YieldVault {\n    IERC20 public _0x53389c;\n    IERC20 public _0xb40afa;\n    ICurve3Pool public _0x653f75;\n\n    mapping(address => uint256) public _0xdd8b3e;\n    uint256 public _0x18f9fb;\n    uint256 public _0x214b8f;\n\n    uint256 public constant MIN_EARN_THRESHOLD = 1000 ether;\n\n    constructor(address _0x62b66e, address _0xec9ff0, address _0xf0fc8f) {\n        if (gasleft() > 0) { _0x53389c = IERC20(_0x62b66e); }\n        _0xb40afa = IERC20(_0xec9ff0);\n        _0x653f75 = ICurve3Pool(_0xf0fc8f);\n    }\n\n    function _0xfdc963(uint256 _0x9b325b) external {\n        _0x53389c._0x28fb7e(msg.sender, address(this), _0x9b325b);\n\n        uint256 _0xed3889;\n        if (_0x18f9fb == 0) {\n            if (true) { _0xed3889 = _0x9b325b; }\n        } else {\n            _0xed3889 = (_0x9b325b * _0x18f9fb) / _0x214b8f;\n        }\n\n        _0xdd8b3e[msg.sender] += _0xed3889;\n        _0x18f9fb += _0xed3889;\n        _0x214b8f += _0x9b325b;\n    }\n\n    function _0x759392() external {\n        uint256 _0x31f942 = _0x53389c._0x3672cd(address(this));\n        require(\n            _0x31f942 >= MIN_EARN_THRESHOLD,\n            \"Insufficient balance to earn\"\n        );\n\n        uint256 _0x7f90f1 = _0x653f75._0x59fe26();\n\n        _0x53389c._0x363bc2(address(_0x653f75), _0x31f942);\n        uint256[3] memory _0xc074cb = [_0x31f942, 0, 0];\n        _0x653f75._0xadfe29(_0xc074cb, 0);\n    }\n\n    function _0xd670d1() external {\n        uint256 _0xa0c96d = _0xdd8b3e[msg.sender];\n        require(_0xa0c96d > 0, \"No shares\");\n\n        uint256 _0xae3fb8 = (_0xa0c96d * _0x214b8f) / _0x18f9fb;\n\n        _0xdd8b3e[msg.sender] = 0;\n        _0x18f9fb -= _0xa0c96d;\n        _0x214b8f -= _0xae3fb8;\n\n        _0x53389c.transfer(msg.sender, _0xae3fb8);\n    }\n\n    function balance() public view returns (uint256) {\n        return\n            _0x53389c._0x3672cd(address(this)) +\n            (_0xb40afa._0x3672cd(address(this)) * _0x653f75._0x59fe26()) /\n            1e18;\n    }\n}\n",
      "rename_map": {
        "remove_liquidity_imbalance": "_0xb219b5",
        "get_virtual_price": "_0x59fe26",
        "min_mint_amount": "_0xeae222",
        "max_burn_amount": "_0xf5921c",
        "withdrawAmount": "_0xae3fb8",
        "totalDeposits": "_0x214b8f",
        "add_liquidity": "_0xadfe29",
        "vaultBalance": "_0x31f942",
        "transferFrom": "_0x28fb7e",
        "virtualPrice": "_0x7f90f1",
        "_curve3Pool": "_0xf0fc8f",
        "withdrawAll": "_0xd670d1",
        "totalShares": "_0x18f9fb",
        "shareAmount": "_0xed3889",
        "curve3Pool": "_0x653f75",
        "userShares": "_0xa0c96d",
        "balanceOf": "_0x3672cd",
        "spender": "_0x787d59",
        "approve": "_0x363bc2",
        "amounts": "_0xc074cb",
        "deposit": "_0xfdc963",
        "account": "_0x017416",
        "shares": "_0xdd8b3e",
        "amount": "_0x9b325b",
        "_crv3": "_0xec9ff0",
        "crv3": "_0xb40afa",
        "_dai": "_0x62b66e",
        "earn": "_0x759392",
        "dai": "_0x53389c",
        "to": "_0x8b07dc"
      },
      "changes": [
        "Renamed 30 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_015",
      "transformed_id": "ss_l3_medium_sn_tc_015",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Compound Market Token\n * @notice Represents claims on supplied assets\n */\n\ninterface IERC20 {\n    function transfer(address _0x1eb978, uint256 _0x1ac53d) external returns (bool);\n\n    function _0xc7501e(address _0xa130ce) external view returns (uint256);\n}\n\ncontract CompoundMarket {\n    address public _0xad652d;\n    address public _0x0c7ace;\n\n    mapping(address => uint256) public _0x5a9cbc;\n    uint256 public _0x0bf88f;\n\n    address public constant OLD_TUSD =\n        0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;\n    address public constant NEW_TUSD =\n        0x0000000000085d4780B73119b644AE5ecd22b376;\n\n    constructor() {\n        _0x0c7ace = msg.sender;\n        _0xad652d = OLD_TUSD;\n    }\n\n    function _0xf1f997(uint256 _0x1ac53d) external {\n        IERC20(NEW_TUSD).transfer(address(this), _0x1ac53d);\n        _0x5a9cbc[msg.sender] += _0x1ac53d;\n        _0x0bf88f += _0x1ac53d;\n    }\n\n    function _0x25e9d0(address _0x6992d0) external {\n        require(_0x6992d0 != _0xad652d, \"Cannot sweep underlying token\");\n\n        uint256 balance = IERC20(_0x6992d0)._0xc7501e(address(this));\n        IERC20(_0x6992d0).transfer(msg.sender, balance);\n    }\n\n    function _0xb07c9d(uint256 _0x1ac53d) external {\n        require(_0x5a9cbc[msg.sender] >= _0x1ac53d, \"Insufficient balance\");\n\n        _0x5a9cbc[msg.sender] -= _0x1ac53d;\n        _0x0bf88f -= _0x1ac53d;\n\n        IERC20(NEW_TUSD).transfer(msg.sender, _0x1ac53d);\n    }\n}\n",
      "rename_map": {
        "accountTokens": "_0x5a9cbc",
        "totalSupply": "_0x0bf88f",
        "sweepToken": "_0x25e9d0",
        "underlying": "_0xad652d",
        "balanceOf": "_0xc7501e",
        "account": "_0xa130ce",
        "redeem": "_0xb07c9d",
        "amount": "_0x1ac53d",
        "admin": "_0x0c7ace",
        "token": "_0x6992d0",
        "mint": "_0xf1f997",
        "to": "_0x1eb978"
      },
      "changes": [
        "Renamed 12 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_016",
      "transformed_id": "ss_l3_medium_sn_tc_016",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Loan Token Contract\n * @notice Represents interest-bearing tokens for supplied assets\n */\n\ninterface IERC20 {\n    function transfer(address _0x7d5c82, uint256 _0x3e2d84) external returns (bool);\n\n    function _0xcc2449(address _0x6aee85) external view returns (uint256);\n}\n\ncontract LoanToken {\n    string public _0xae7228 = \"iETH\";\n    string public _0xa6324d = \"iETH\";\n\n    mapping(address => uint256) public _0xe22198;\n    uint256 public _0xb8109d;\n    uint256 public _0x1779df;\n    uint256 public _0x8113d7;\n\n    function _0x189b3c(\n        address _0x0e2f03\n    ) external payable returns (uint256 _0x32fc1a) {\n        uint256 _0x362a02 = _0x314afd();\n        _0x32fc1a = (msg.value * 1e18) / _0x362a02;\n\n        _0xe22198[_0x0e2f03] += _0x32fc1a;\n        _0xb8109d += _0x32fc1a;\n        _0x8113d7 += msg.value;\n\n        return _0x32fc1a;\n    }\n\n    function transfer(address _0x7d5c82, uint256 _0x3e2d84) external returns (bool) {\n        require(_0xe22198[msg.sender] >= _0x3e2d84, \"Insufficient balance\");\n\n        _0xe22198[msg.sender] -= _0x3e2d84;\n        _0xe22198[_0x7d5c82] += _0x3e2d84;\n\n        _0xdbbbf7(msg.sender, _0x7d5c82, _0x3e2d84);\n\n        return true;\n    }\n\n    function _0xdbbbf7(\n        address from,\n        address _0x7d5c82,\n        uint256 _0x3e2d84\n    ) internal {\n        if (_0x833d8f(_0x7d5c82)) {\n            (bool _0x2cb2f2, ) = _0x7d5c82.call(\"\");\n            _0x2cb2f2;\n        }\n    }\n\n    function _0xa497b5(\n        address _0x0e2f03,\n        uint256 _0x3e2d84\n    ) external returns (uint256 _0x9ae9d7) {\n        require(_0xe22198[msg.sender] >= _0x3e2d84, \"Insufficient balance\");\n\n        uint256 _0x362a02 = _0x314afd();\n        _0x9ae9d7 = (_0x3e2d84 * _0x362a02) / 1e18;\n\n        _0xe22198[msg.sender] -= _0x3e2d84;\n        _0xb8109d -= _0x3e2d84;\n        _0x8113d7 -= _0x9ae9d7;\n\n        payable(_0x0e2f03).transfer(_0x9ae9d7);\n\n        return _0x9ae9d7;\n    }\n\n    function _0x314afd() internal view returns (uint256) {\n        if (_0xb8109d == 0) {\n            return 1e18;\n        }\n        return (_0x8113d7 * 1e18) / _0xb8109d;\n    }\n\n    function _0x833d8f(address _0x6aee85) internal view returns (bool) {\n        uint256 _0xd15c94;\n        assembly {\n            _0xd15c94 := extcodesize(_0x6aee85)\n        }\n        return _0xd15c94 > 0;\n    }\n\n    function _0xcc2449(address _0x6aee85) external view returns (uint256) {\n        return _0xe22198[_0x6aee85];\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "totalAssetBorrow": "_0x1779df",
        "totalAssetSupply": "_0x8113d7",
        "_notifyTransfer": "_0xdbbbf7",
        "mintWithEther": "_0x189b3c",
        "currentPrice": "_0x362a02",
        "totalSupply": "_0xb8109d",
        "_tokenPrice": "_0x314afd",
        "_isContract": "_0x833d8f",
        "burnToEther": "_0xa497b5",
        "mintAmount": "_0x32fc1a",
        "balanceOf": "_0xcc2449",
        "ethAmount": "_0x9ae9d7",
        "balances": "_0xe22198",
        "receiver": "_0x0e2f03",
        "success": "_0x2cb2f2",
        "account": "_0x6aee85",
        "symbol": "_0xa6324d",
        "amount": "_0x3e2d84",
        "name": "_0xae7228",
        "size": "_0xd15c94",
        "to": "_0x7d5c82"
      },
      "changes": [
        "Renamed 21 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_017",
      "transformed_id": "ss_l3_medium_sn_tc_017",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Vault Controller Contract\n * @notice Manages vault strategies and token swaps\n */\n\ninterface IERC20 {\n    function transfer(address _0x404cc7, uint256 _0x73551c) external returns (bool);\n\n    function _0x348681(address _0xbeb016) external view returns (uint256);\n}\n\ninterface IJar {\n    function _0xeaea1a() external view returns (address);\n\n    function _0x3f8c57(uint256 _0x73551c) external;\n}\n\ninterface IStrategy {\n    function _0x4202f5() external;\n\n    function _0x3f8c57(address _0xeaea1a) external;\n}\n\ncontract VaultController {\n    address public _0xacbd4c;\n    mapping(address => address) public _0x6c96a7;\n\n    constructor() {\n        if (gasleft() > 0) { _0xacbd4c = msg.sender; }\n    }\n\n    function _0xd77ea6(\n        address _0xe65698,\n        address _0xf1d3af,\n        uint256 _0x9ce06d,\n        uint256 _0x775d1c,\n        address[] calldata _0x67d15a,\n        bytes[] calldata _0xa6c292\n    ) external {\n        require(_0x67d15a.length == _0xa6c292.length, \"Length mismatch\");\n\n        for (uint256 i = 0; i < _0x67d15a.length; i++) {\n            (bool _0xd98f58, ) = _0x67d15a[i].call(_0xa6c292[i]);\n            require(_0xd98f58, \"Call failed\");\n        }\n    }\n\n    function _0x8ce556(address _0x0762b7, address _0x6d1554) external {\n        require(msg.sender == _0xacbd4c, \"Not governance\");\n        _0x6c96a7[_0x0762b7] = _0x6d1554;\n    }\n}\n\ncontract Strategy {\n    address public _0x0dabd7;\n    address public _0x0b4236;\n\n    constructor(address _0x3f3957, address _0x4939be) {\n        _0x0dabd7 = _0x3f3957;\n        _0x0b4236 = _0x4939be;\n    }\n\n    function _0x4202f5() external {\n        uint256 balance = IERC20(_0x0b4236)._0x348681(address(this));\n        IERC20(_0x0b4236).transfer(_0x0dabd7, balance);\n    }\n\n    function _0x3f8c57(address _0xeaea1a) external {\n        uint256 balance = IERC20(_0xeaea1a)._0x348681(address(this));\n        IERC20(_0xeaea1a).transfer(_0x0dabd7, balance);\n    }\n}\n",
      "rename_map": {
        "swapExactJarForJar": "_0xd77ea6",
        "_toJarMinAmount": "_0x775d1c",
        "_fromJarAmount": "_0x9ce06d",
        "setStrategy": "_0x8ce556",
        "withdrawAll": "_0x4202f5",
        "_controller": "_0x3f3957",
        "controller": "_0x0dabd7",
        "strategies": "_0x6c96a7",
        "governance": "_0xacbd4c",
        "balanceOf": "_0x348681",
        "withdraw": "_0x3f8c57",
        "_targets": "_0x67d15a",
        "strategy": "_0x6d1554",
        "_fromJar": "_0xe65698",
        "success": "_0xd98f58",
        "account": "_0xbeb016",
        "_toJar": "_0xf1d3af",
        "amount": "_0x73551c",
        "_want": "_0x4939be",
        "token": "_0xeaea1a",
        "_data": "_0xa6c292",
        "want": "_0x0b4236",
        "jar": "_0x0762b7",
        "to": "_0x404cc7"
      },
      "changes": [
        "Renamed 24 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_018",
      "transformed_id": "ss_l3_medium_sn_tc_018",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x4fcf21(address _0x673e3d) external view returns (uint256);\n\n    function transfer(address _0x6f6bd8, uint256 _0xf18e28) external returns (bool);\n}\n\ncontract TokenPool {\n    struct Token {\n        address _0xe07574;\n        uint256 balance;\n        uint256 _0xbf766c;\n    }\n\n    mapping(address => Token) public _0x6e86b8;\n    address[] public _0xcf0f5a;\n    uint256 public _0xf54272;\n\n    constructor() {\n        _0xf54272 = 100;\n    }\n\n    function _0xa00609(address _0x0198b5, uint256 _0x9506db) external {\n        _0x6e86b8[_0x0198b5] = Token({_0xe07574: _0x0198b5, balance: 0, _0xbf766c: _0x9506db});\n        _0xcf0f5a.push(_0x0198b5);\n    }\n\n    function _0x1c9e57(\n        address _0x483290,\n        address _0xebd25b,\n        uint256 _0xb50946\n    ) external returns (uint256 _0xc5ed63) {\n        require(_0x6e86b8[_0x483290]._0xe07574 != address(0), \"Invalid token\");\n        require(_0x6e86b8[_0xebd25b]._0xe07574 != address(0), \"Invalid token\");\n\n        IERC20(_0x483290).transfer(address(this), _0xb50946);\n        _0x6e86b8[_0x483290].balance += _0xb50946;\n\n        _0xc5ed63 = _0x9ea37f(_0x483290, _0xebd25b, _0xb50946);\n\n        require(\n            _0x6e86b8[_0xebd25b].balance >= _0xc5ed63,\n            \"Insufficient liquidity\"\n        );\n        _0x6e86b8[_0xebd25b].balance -= _0xc5ed63;\n        IERC20(_0xebd25b).transfer(msg.sender, _0xc5ed63);\n\n        _0x2b51b5();\n\n        return _0xc5ed63;\n    }\n\n    function _0x9ea37f(\n        address _0x483290,\n        address _0xebd25b,\n        uint256 _0xb50946\n    ) public view returns (uint256) {\n        uint256 _0x7ceef4 = _0x6e86b8[_0x483290]._0xbf766c;\n        uint256 _0x471dfc = _0x6e86b8[_0xebd25b]._0xbf766c;\n        uint256 _0x8048e2 = _0x6e86b8[_0xebd25b].balance;\n\n        uint256 _0x0f8eab = _0x8048e2 * _0xb50946 * _0x471dfc;\n        uint256 _0x31de7a = _0x6e86b8[_0x483290].balance *\n            _0x7ceef4 +\n            _0xb50946 *\n            _0x471dfc;\n\n        return _0x0f8eab / _0x31de7a;\n    }\n\n    function _0x2b51b5() internal {\n        uint256 _0xac3b03 = 0;\n\n        for (uint256 i = 0; i < _0xcf0f5a.length; i++) {\n            address _0x0198b5 = _0xcf0f5a[i];\n            _0xac3b03 += _0x6e86b8[_0x0198b5].balance;\n        }\n\n        for (uint256 i = 0; i < _0xcf0f5a.length; i++) {\n            address _0x0198b5 = _0xcf0f5a[i];\n            _0x6e86b8[_0x0198b5]._0xbf766c = (_0x6e86b8[_0x0198b5].balance * 100) / _0xac3b03;\n        }\n    }\n\n    function _0x016c7d(address _0x0198b5) external view returns (uint256) {\n        return _0x6e86b8[_0x0198b5]._0xbf766c;\n    }\n\n    function _0xd6dbe6(address _0x0198b5, uint256 _0xf18e28) external {\n        require(_0x6e86b8[_0x0198b5]._0xe07574 != address(0), \"Invalid token\");\n        IERC20(_0x0198b5).transfer(address(this), _0xf18e28);\n        _0x6e86b8[_0x0198b5].balance += _0xf18e28;\n        _0x2b51b5();\n    }\n}\n",
      "rename_map": {
        "calculateSwapAmount": "_0x9ea37f",
        "_updateWeights": "_0x2b51b5",
        "initialWeight": "_0x9506db",
        "addLiquidity": "_0xd6dbe6",
        "denominator": "_0x31de7a",
        "totalWeight": "_0xf54272",
        "balanceOut": "_0x8048e2",
        "totalValue": "_0xac3b03",
        "balanceOf": "_0x4fcf21",
        "getWeight": "_0x016c7d",
        "numerator": "_0x0f8eab",
        "weightOut": "_0x471dfc",
        "tokenList": "_0xcf0f5a",
        "amountOut": "_0xc5ed63",
        "weightIn": "_0x7ceef4",
        "addToken": "_0xa00609",
        "tokenOut": "_0xebd25b",
        "amountIn": "_0xb50946",
        "account": "_0x673e3d",
        "tokenIn": "_0x483290",
        "tokens": "_0x6e86b8",
        "amount": "_0xf18e28",
        "weight": "_0xbf766c",
        "token": "_0x0198b5",
        "addr": "_0xe07574",
        "swap": "_0x1c9e57",
        "to": "_0x6f6bd8"
      },
      "changes": [
        "Renamed 27 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_019",
      "transformed_id": "ss_l3_medium_sn_tc_019",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0xb0940a(\n        address from,\n        address _0xccfda0,\n        uint256 _0x72c605\n    ) external returns (bool);\n\n    function _0x329246(address _0x511457) external view returns (uint256);\n}\n\ncontract CrossChainBridge {\n    address public _0x278cdd;\n\n    event Deposit(\n        uint8 _0x616662,\n        bytes32 _0xf5e69d,\n        uint64 _0xaa069a\n    );\n\n    uint64 public _0xaa069a;\n\n    constructor(address _0x41dd8f) {\n        _0x278cdd = _0x41dd8f;\n    }\n\n    function _0x8ddd26(\n        uint8 _0x616662,\n        bytes32 _0xf5e69d,\n        bytes calldata data\n    ) external payable {\n        _0xaa069a += 1;\n\n        BridgeHandler(_0x278cdd)._0x8ddd26(_0xf5e69d, msg.sender, data);\n\n        emit Deposit(_0x616662, _0xf5e69d, _0xaa069a);\n    }\n}\n\ncontract BridgeHandler {\n    mapping(bytes32 => address) public _0xc30d9d;\n    mapping(address => bool) public _0x552e4e;\n\n    function _0x8ddd26(\n        bytes32 _0xf5e69d,\n        address _0x16fa8f,\n        bytes calldata data\n    ) external {\n        address _0x8b3d8b = _0xc30d9d[_0xf5e69d];\n\n        uint256 _0x72c605;\n        (_0x72c605) = abi._0x56fbd9(data, (uint256));\n\n        IERC20(_0x8b3d8b)._0xb0940a(_0x16fa8f, address(this), _0x72c605);\n    }\n\n    function _0x1dc66c(bytes32 _0xf5e69d, address _0xd17e2f) external {\n        _0xc30d9d[_0xf5e69d] = _0xd17e2f;\n    }\n}\n",
      "rename_map": {
        "resourceIDToTokenContractAddress": "_0xc30d9d",
        "destinationDomainID": "_0x616662",
        "contractWhitelist": "_0x552e4e",
        "tokenContract": "_0x8b3d8b",
        "depositNonce": "_0xaa069a",
        "tokenAddress": "_0xd17e2f",
        "transferFrom": "_0xb0940a",
        "setResource": "_0x1dc66c",
        "resourceID": "_0xf5e69d",
        "depositer": "_0x16fa8f",
        "balanceOf": "_0x329246",
        "_handler": "_0x41dd8f",
        "account": "_0x511457",
        "handler": "_0x278cdd",
        "deposit": "_0x8ddd26",
        "decode": "_0x56fbd9",
        "amount": "_0x72c605",
        "to": "_0xccfda0"
      },
      "changes": [
        "Renamed 18 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_020",
      "transformed_id": "ss_l3_medium_sn_tc_020",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function _0x8f4f73()\n        external\n        view\n        returns (uint112 _0x08f6a4, uint112 _0x48c6b8, uint32 _0x200d6e);\n\n    function _0x8a352c() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function _0xe52a46(address _0xd0041a) external view returns (uint256);\n\n    function transfer(address _0xc9792e, uint256 _0x514932) external returns (bool);\n\n    function _0x74e916(\n        address from,\n        address _0xc9792e,\n        uint256 _0x514932\n    ) external returns (bool);\n}\n\ncontract LendingVault {\n    struct Position {\n        uint256 _0x547b05;\n        uint256 _0x13952a;\n    }\n\n    mapping(address => Position) public _0x010efb;\n\n    address public _0x7505db;\n    address public _0x43b392;\n    uint256 public constant COLLATERAL_RATIO = 150;\n\n    constructor(address _0xb94574, address _0x78004a) {\n        _0x7505db = _0xb94574;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x43b392 = _0x78004a; }\n    }\n\n    function _0x83b76c(uint256 _0x514932) external {\n        IERC20(_0x7505db)._0x74e916(msg.sender, address(this), _0x514932);\n        _0x010efb[msg.sender]._0x547b05 += _0x514932;\n    }\n\n    function _0xc5c114(uint256 _0x514932) external {\n        uint256 _0x14479d = _0xdc056f(\n            _0x010efb[msg.sender]._0x547b05\n        );\n        uint256 _0x755ed8 = (_0x14479d * 100) / COLLATERAL_RATIO;\n\n        require(\n            _0x010efb[msg.sender]._0x13952a + _0x514932 <= _0x755ed8,\n            \"Insufficient collateral\"\n        );\n\n        _0x010efb[msg.sender]._0x13952a += _0x514932;\n        IERC20(_0x43b392).transfer(msg.sender, _0x514932);\n    }\n\n    function _0xdc056f(uint256 _0x401425) public view returns (uint256) {\n        if (_0x401425 == 0) return 0;\n\n        IUniswapV2Pair _0x8cd58c = IUniswapV2Pair(_0x7505db);\n\n        (uint112 _0x08f6a4, uint112 _0x48c6b8, ) = _0x8cd58c._0x8f4f73();\n        uint256 _0x8a352c = _0x8cd58c._0x8a352c();\n\n        uint256 _0xb4f75f = (uint256(_0x08f6a4) * _0x401425) / _0x8a352c;\n        uint256 _0x31c503 = (uint256(_0x48c6b8) * _0x401425) / _0x8a352c;\n\n        uint256 _0x19455f = _0xb4f75f;\n        uint256 _0xf7107b = _0xb4f75f + _0x31c503;\n\n        return _0xf7107b;\n    }\n\n    function _0x7c0997(uint256 _0x514932) external {\n        require(_0x010efb[msg.sender]._0x13952a >= _0x514932, \"Repay exceeds debt\");\n\n        IERC20(_0x43b392)._0x74e916(msg.sender, address(this), _0x514932);\n        _0x010efb[msg.sender]._0x13952a -= _0x514932;\n    }\n\n    function _0x1dd6d8(uint256 _0x514932) external {\n        require(\n            _0x010efb[msg.sender]._0x547b05 >= _0x514932,\n            \"Insufficient balance\"\n        );\n\n        uint256 _0x93aeb1 = _0x010efb[msg.sender]._0x547b05 - _0x514932;\n        uint256 _0xaae476 = _0xdc056f(_0x93aeb1);\n        uint256 _0x755ed8 = (_0xaae476 * 100) / COLLATERAL_RATIO;\n\n        require(\n            _0x010efb[msg.sender]._0x13952a <= _0x755ed8,\n            \"Withdrawal would liquidate position\"\n        );\n\n        _0x010efb[msg.sender]._0x547b05 -= _0x514932;\n        IERC20(_0x7505db).transfer(msg.sender, _0x514932);\n    }\n}\n",
      "rename_map": {
        "blockTimestampLast": "_0x200d6e",
        "collateralValue": "_0x14479d",
        "getLPTokenValue": "_0xdc056f",
        "remainingValue": "_0xaae476",
        "lpTokenAmount": "_0x547b05",
        "transferFrom": "_0x74e916",
        "totalSupply": "_0x8a352c",
        "remainingLP": "_0x93aeb1",
        "getReserves": "_0x8f4f73",
        "_stablecoin": "_0x78004a",
        "totalValue": "_0xf7107b",
        "stablecoin": "_0x43b392",
        "balanceOf": "_0xe52a46",
        "maxBorrow": "_0x755ed8",
        "positions": "_0x010efb",
        "withdraw": "_0x1dd6d8",
        "lpAmount": "_0x401425",
        "_lpToken": "_0xb94574",
        "borrowed": "_0x13952a",
        "reserve1": "_0x48c6b8",
        "reserve0": "_0x08f6a4",
        "amount1": "_0x31c503",
        "lpToken": "_0x7505db",
        "deposit": "_0x83b76c",
        "account": "_0xd0041a",
        "amount0": "_0xb4f75f",
        "borrow": "_0xc5c114",
        "amount": "_0x514932",
        "value0": "_0x19455f",
        "repay": "_0x7c0997",
        "pair": "_0x8cd58c",
        "to": "_0xc9792e"
      },
      "changes": [
        "Renamed 32 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_021",
      "transformed_id": "ss_l3_medium_sn_tc_021",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x39a2c5(address _0x527b0a) external view returns (uint256);\n\n    function transfer(address _0x7af944, uint256 _0x0ee8c9) external returns (bool);\n\n    function _0x24035d(\n        address from,\n        address _0x7af944,\n        uint256 _0x0ee8c9\n    ) external returns (bool);\n}\n\ncontract LiquidityPool {\n    address public _0x72e3fa;\n    address public _0xab471e;\n    address public _0x15e27a;\n\n    uint256 public _0xa6163c;\n    uint256 public _0xaf2fe4;\n    uint256 public _0x146ce2;\n\n    bool public _0x739484;\n\n    event Initialized(address _0x72e3fa, address _0x7a239f, address _0x9041a3);\n\n    function _0xa4fba1(\n        address _0x9cee85,\n        address _0x7b59dd,\n        address _0x7aae4e,\n        uint256 _0x9725ae\n    ) external {\n        _0x72e3fa = _0x9cee85;\n        _0xab471e = _0x7b59dd;\n        _0x15e27a = _0x7aae4e;\n        _0xa6163c = _0x9725ae;\n\n        _0x739484 = true;\n\n        emit Initialized(_0x9cee85, _0x7b59dd, _0x7aae4e);\n    }\n\n    function _0x93e4c6(uint256 _0xb05426, uint256 _0xc81866) external {\n        require(_0x739484, \"Not initialized\");\n\n        IERC20(_0xab471e)._0x24035d(msg.sender, address(this), _0xb05426);\n        IERC20(_0x15e27a)._0x24035d(msg.sender, address(this), _0xc81866);\n\n        _0xaf2fe4 += _0xb05426;\n        _0x146ce2 += _0xc81866;\n    }\n\n    function _0x6d995c(\n        address _0x57eef2,\n        address _0xc062bf,\n        uint256 _0x2df628\n    ) external returns (uint256 _0x6c36d6) {\n        require(_0x739484, \"Not initialized\");\n        require(\n            (_0x57eef2 == _0xab471e && _0xc062bf == _0x15e27a) ||\n                (_0x57eef2 == _0x15e27a && _0xc062bf == _0xab471e),\n            \"Invalid token pair\"\n        );\n\n        IERC20(_0x57eef2)._0x24035d(msg.sender, address(this), _0x2df628);\n\n        if (_0x57eef2 == _0xab471e) {\n            _0x6c36d6 = (_0x146ce2 * _0x2df628) / (_0xaf2fe4 + _0x2df628);\n            _0xaf2fe4 += _0x2df628;\n            _0x146ce2 -= _0x6c36d6;\n        } else {\n            _0x6c36d6 = (_0xaf2fe4 * _0x2df628) / (_0x146ce2 + _0x2df628);\n            _0x146ce2 += _0x2df628;\n            _0xaf2fe4 -= _0x6c36d6;\n        }\n\n        uint256 _0x831d45 = (_0x6c36d6 * _0xa6163c) / 10000;\n        _0x6c36d6 -= _0x831d45;\n\n        IERC20(_0xc062bf).transfer(msg.sender, _0x6c36d6);\n        IERC20(_0xc062bf).transfer(_0x72e3fa, _0x831d45);\n\n        return _0x6c36d6;\n    }\n\n    function _0x8d9d5a() external {\n        require(msg.sender == _0x72e3fa, \"Only maintainer\");\n\n        uint256 _0xddbf39 = IERC20(_0xab471e)._0x39a2c5(address(this));\n        uint256 _0x58319d = IERC20(_0x15e27a)._0x39a2c5(address(this));\n\n        if (_0xddbf39 > _0xaf2fe4) {\n            uint256 _0xbffdb0 = _0xddbf39 - _0xaf2fe4;\n            IERC20(_0xab471e).transfer(_0x72e3fa, _0xbffdb0);\n        }\n\n        if (_0x58319d > _0x146ce2) {\n            uint256 _0xbffdb0 = _0x58319d - _0x146ce2;\n            IERC20(_0x15e27a).transfer(_0x72e3fa, _0xbffdb0);\n        }\n    }\n}\n",
      "rename_map": {
        "quoteTokenBalance": "_0x58319d",
        "baseTokenBalance": "_0xddbf39",
        "isInitialized": "_0x739484",
        "transferFrom": "_0x24035d",
        "addLiquidity": "_0x93e4c6",
        "quoteBalance": "_0x146ce2",
        "quoteAmount": "_0xc81866",
        "_quoteToken": "_0x7aae4e",
        "baseBalance": "_0xaf2fe4",
        "_maintainer": "_0x9cee85",
        "_lpFeeRate": "_0x9725ae",
        "quoteToken": "_0x15e27a",
        "_baseToken": "_0x7b59dd",
        "maintainer": "_0x72e3fa",
        "fromAmount": "_0x2df628",
        "baseAmount": "_0xb05426",
        "balanceOf": "_0x39a2c5",
        "baseToken": "_0xab471e",
        "fromToken": "_0x57eef2",
        "claimFees": "_0x8d9d5a",
        "lpFeeRate": "_0xa6163c",
        "toAmount": "_0x6c36d6",
        "account": "_0x527b0a",
        "toToken": "_0xc062bf",
        "amount": "_0x0ee8c9",
        "excess": "_0xbffdb0",
        "quote": "_0x9041a3",
        "base": "_0x7a239f",
        "swap": "_0x6d995c",
        "init": "_0xa4fba1",
        "fee": "_0x831d45",
        "to": "_0x7af944"
      },
      "changes": [
        "Renamed 32 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_022",
      "transformed_id": "ss_l3_medium_sn_tc_022",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x2f1975(address _0x1343af) external view returns (uint256);\n\n    function transfer(address _0x1db275, uint256 _0x1d4dd3) external returns (bool);\n\n    function _0xb15708(\n        address from,\n        address _0x1db275,\n        uint256 _0x1d4dd3\n    ) external returns (bool);\n}\n\ncontract TokenPair {\n    address public _0x8ac68a;\n    address public _0x812af2;\n\n    uint112 private _0x45159e;\n    uint112 private _0x76eaf2;\n\n    uint256 public constant TOTAL_FEE = 16;\n\n    constructor(address _0x11dd59, address _0x4cc15b) {\n        _0x8ac68a = _0x11dd59;\n        if (gasleft() > 0) { _0x812af2 = _0x4cc15b; }\n    }\n\n    function _0xcef7d1(address _0x1db275) external returns (uint256 _0x864b78) {\n        uint256 _0x5ab465 = IERC20(_0x8ac68a)._0x2f1975(address(this));\n        uint256 _0x12d1a2 = IERC20(_0x812af2)._0x2f1975(address(this));\n\n        uint256 _0x29190c = _0x5ab465 - _0x45159e;\n        uint256 _0x3e42aa = _0x12d1a2 - _0x76eaf2;\n\n        _0x864b78 = _0x127090(_0x29190c * _0x3e42aa);\n\n        _0x45159e = uint112(_0x5ab465);\n        _0x76eaf2 = uint112(_0x12d1a2);\n\n        return _0x864b78;\n    }\n\n    function _0x6300e0(\n        uint256 _0xec8215,\n        uint256 _0x0c7f63,\n        address _0x1db275,\n        bytes calldata data\n    ) external {\n        require(_0xec8215 > 0 || _0x0c7f63 > 0, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        uint112 _0x177875 = _0x45159e;\n        uint112 _0x555f91 = _0x76eaf2;\n\n        require(\n            _0xec8215 < _0x177875 && _0x0c7f63 < _0x555f91,\n            \"INSUFFICIENT_LIQUIDITY\"\n        );\n\n        if (_0xec8215 > 0) IERC20(_0x8ac68a).transfer(_0x1db275, _0xec8215);\n        if (_0x0c7f63 > 0) IERC20(_0x812af2).transfer(_0x1db275, _0x0c7f63);\n\n        uint256 _0x5ab465 = IERC20(_0x8ac68a)._0x2f1975(address(this));\n        uint256 _0x12d1a2 = IERC20(_0x812af2)._0x2f1975(address(this));\n\n        uint256 _0x3a3c68 = _0x5ab465 > _0x177875 - _0xec8215\n            ? _0x5ab465 - (_0x177875 - _0xec8215)\n            : 0;\n        uint256 _0x8df0ad = _0x12d1a2 > _0x555f91 - _0x0c7f63\n            ? _0x12d1a2 - (_0x555f91 - _0x0c7f63)\n            : 0;\n\n        require(_0x3a3c68 > 0 || _0x8df0ad > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\n        uint256 _0xb16115 = _0x5ab465 * 10000 - _0x3a3c68 * TOTAL_FEE;\n        uint256 _0x43a97b = _0x12d1a2 * 10000 - _0x8df0ad * TOTAL_FEE;\n\n        require(\n            _0xb16115 * _0x43a97b >=\n                uint256(_0x177875) * _0x555f91 * (1000 ** 2),\n            \"K\"\n        );\n\n        _0x45159e = uint112(_0x5ab465);\n        _0x76eaf2 = uint112(_0x12d1a2);\n    }\n\n    function _0x790a97() external view returns (uint112, uint112, uint32) {\n        return (_0x45159e, _0x76eaf2, 0);\n    }\n\n    function _0x127090(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n",
      "rename_map": {
        "balance0Adjusted": "_0xb16115",
        "balance1Adjusted": "_0x43a97b",
        "transferFrom": "_0xb15708",
        "getReserves": "_0x790a97",
        "amount0Out": "_0xec8215",
        "amount1Out": "_0x0c7f63",
        "liquidity": "_0x864b78",
        "balanceOf": "_0x2f1975",
        "amount1In": "_0x8df0ad",
        "_reserve0": "_0x177875",
        "amount0In": "_0x3a3c68",
        "_reserve1": "_0x555f91",
        "balance0": "_0x5ab465",
        "reserve1": "_0x76eaf2",
        "balance1": "_0x12d1a2",
        "reserve0": "_0x45159e",
        "amount1": "_0x3e42aa",
        "_token1": "_0x4cc15b",
        "_token0": "_0x11dd59",
        "account": "_0x1343af",
        "amount0": "_0x29190c",
        "amount": "_0x1d4dd3",
        "token1": "_0x812af2",
        "token0": "_0x8ac68a",
        "mint": "_0xcef7d1",
        "sqrt": "_0x127090",
        "swap": "_0x6300e0",
        "to": "_0x1db275"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_023",
      "transformed_id": "ss_l3_medium_sn_tc_023",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0xc09f49(address _0xf43553) external view returns (uint256);\n\n    function transfer(address _0x66f4c3, uint256 _0x54c789) external returns (bool);\n\n    function _0x86bcd0(\n        address from,\n        address _0x66f4c3,\n        uint256 _0x54c789\n    ) external returns (bool);\n}\n\ninterface ICErc20 {\n    function _0x322555(uint256 _0x54c789) external returns (uint256);\n\n    function _0xfa5123(address _0xf43553) external returns (uint256);\n}\n\ncontract LeveragedVault {\n    struct Position {\n        address _0xae3fb7;\n        uint256 _0x6e8eae;\n        uint256 _0x537473;\n    }\n\n    mapping(uint256 => Position) public _0x4f9e50;\n    uint256 public _0x028803;\n\n    address public _0xd907a1;\n    uint256 public _0x6c933b;\n    uint256 public _0x41f331;\n\n    constructor(address _0x914337) {\n        _0xd907a1 = _0x914337;\n        _0x028803 = 1;\n    }\n\n    function _0x04967e(\n        uint256 _0x193048,\n        uint256 _0xa09818\n    ) external returns (uint256 _0xfeefe9) {\n        _0xfeefe9 = _0x028803++;\n\n        _0x4f9e50[_0xfeefe9] = Position({\n            _0xae3fb7: msg.sender,\n            _0x6e8eae: _0x193048,\n            _0x537473: 0\n        });\n\n        _0x887a47(_0xfeefe9, _0xa09818);\n\n        return _0xfeefe9;\n    }\n\n    function _0x887a47(uint256 _0xfeefe9, uint256 _0x54c789) internal {\n        Position storage _0xf01e98 = _0x4f9e50[_0xfeefe9];\n\n        uint256 _0x9ce0fc;\n\n        if (_0x41f331 == 0) {\n            if (1 == 1) { _0x9ce0fc = _0x54c789; }\n        } else {\n            _0x9ce0fc = (_0x54c789 * _0x41f331) / _0x6c933b;\n        }\n\n        _0xf01e98._0x537473 += _0x9ce0fc;\n        _0x41f331 += _0x9ce0fc;\n        _0x6c933b += _0x54c789;\n\n        ICErc20(_0xd907a1)._0x322555(_0x54c789);\n    }\n\n    function _0x65c1e1(uint256 _0xfeefe9, uint256 _0x54c789) external {\n        Position storage _0xf01e98 = _0x4f9e50[_0xfeefe9];\n        require(msg.sender == _0xf01e98._0xae3fb7, \"Not position owner\");\n\n        uint256 _0x9e4d4c = (_0x54c789 * _0x41f331) / _0x6c933b;\n\n        require(_0xf01e98._0x537473 >= _0x9e4d4c, \"Excessive repayment\");\n\n        _0xf01e98._0x537473 -= _0x9e4d4c;\n        _0x41f331 -= _0x9e4d4c;\n        _0x6c933b -= _0x54c789;\n    }\n\n    function _0xc0850d(\n        uint256 _0xfeefe9\n    ) external view returns (uint256) {\n        Position storage _0xf01e98 = _0x4f9e50[_0xfeefe9];\n\n        if (_0x41f331 == 0) return 0;\n\n        return (_0xf01e98._0x537473 * _0x6c933b) / _0x41f331;\n    }\n\n    function _0x64c7ae(uint256 _0xfeefe9) external {\n        Position storage _0xf01e98 = _0x4f9e50[_0xfeefe9];\n\n        uint256 _0x5b34e7 = (_0xf01e98._0x537473 * _0x6c933b) / _0x41f331;\n\n        require(_0xf01e98._0x6e8eae * 100 < _0x5b34e7 * 150, \"Position is healthy\");\n\n        _0xf01e98._0x6e8eae = 0;\n        _0xf01e98._0x537473 = 0;\n    }\n}\n",
      "rename_map": {
        "borrowBalanceCurrent": "_0xfa5123",
        "collateralAmount": "_0x193048",
        "getPositionDebt": "_0xc0850d",
        "totalDebtShare": "_0x41f331",
        "nextPositionId": "_0x028803",
        "shareToRemove": "_0x9e4d4c",
        "borrowAmount": "_0xa09818",
        "openPosition": "_0x04967e",
        "transferFrom": "_0x86bcd0",
        "positionId": "_0xfeefe9",
        "collateral": "_0x6e8eae",
        "balanceOf": "_0xc09f49",
        "debtShare": "_0x537473",
        "totalDebt": "_0x6c933b",
        "liquidate": "_0x64c7ae",
        "positions": "_0x4f9e50",
        "_cToken": "_0x914337",
        "account": "_0xf43553",
        "_borrow": "_0x887a47",
        "borrow": "_0x322555",
        "cToken": "_0xd907a1",
        "amount": "_0x54c789",
        "share": "_0x9ce0fc",
        "owner": "_0xae3fb7",
        "repay": "_0x65c1e1",
        "debt": "_0x5b34e7",
        "pos": "_0xf01e98",
        "to": "_0x66f4c3"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_024",
      "transformed_id": "ss_l3_medium_sn_tc_024",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x881516(address _0x706ad4) external view returns (uint256);\n\n    function transfer(address _0x20c1ed, uint256 _0x53c998) external returns (bool);\n\n    function _0xcfaa43(\n        address from,\n        address _0x20c1ed,\n        uint256 _0x53c998\n    ) external returns (bool);\n}\n\ninterface ICurvePool {\n    function _0x9c3784() external view returns (uint256);\n\n    function _0xafa10f(\n        uint256[3] calldata _0xce053e,\n        uint256 _0x3515f2\n    ) external;\n}\n\ncontract PriceOracle {\n    ICurvePool public _0x9c2179;\n\n    constructor(address _0xb937e5) {\n        _0x9c2179 = ICurvePool(_0xb937e5);\n    }\n\n    function _0x1d608e() external view returns (uint256) {\n        return _0x9c2179._0x9c3784();\n    }\n}\n\ncontract LendingProtocol {\n    struct Position {\n        uint256 _0x4a35e3;\n        uint256 _0xc1026d;\n    }\n\n    mapping(address => Position) public _0x90f7ed;\n\n    address public _0x40fc96;\n    address public _0x87e661;\n    address public _0xbbf1ac;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(\n        address _0xbd4490,\n        address _0x199775,\n        address _0x09886c\n    ) {\n        _0x40fc96 = _0xbd4490;\n        _0x87e661 = _0x199775;\n        _0xbbf1ac = _0x09886c;\n    }\n\n    function _0x9b35b9(uint256 _0x53c998) external {\n        IERC20(_0x40fc96)._0xcfaa43(msg.sender, address(this), _0x53c998);\n        _0x90f7ed[msg.sender]._0x4a35e3 += _0x53c998;\n    }\n\n    function _0xff0442(uint256 _0x53c998) external {\n        uint256 _0x74daf9 = _0x2c98ea(msg.sender);\n        uint256 _0x6c2acd = (_0x74daf9 * COLLATERAL_FACTOR) / 100;\n\n        require(\n            _0x90f7ed[msg.sender]._0xc1026d + _0x53c998 <= _0x6c2acd,\n            \"Insufficient collateral\"\n        );\n\n        _0x90f7ed[msg.sender]._0xc1026d += _0x53c998;\n        IERC20(_0x87e661).transfer(msg.sender, _0x53c998);\n    }\n\n    function _0x2c98ea(address _0x6d4f97) public view returns (uint256) {\n        uint256 _0xd588f6 = _0x90f7ed[_0x6d4f97]._0x4a35e3;\n        uint256 _0xb26360 = PriceOracle(_0xbbf1ac)._0x1d608e();\n\n        return (_0xd588f6 * _0xb26360) / 1e18;\n    }\n}\n",
      "rename_map": {
        "getCollateralValue": "_0x2c98ea",
        "get_virtual_price": "_0x9c3784",
        "_collateralToken": "_0xbd4490",
        "collateralAmount": "_0xd588f6",
        "collateralToken": "_0x40fc96",
        "collateralValue": "_0x74daf9",
        "add_liquidity": "_0xafa10f",
        "minMintAmount": "_0x3515f2",
        "transferFrom": "_0xcfaa43",
        "_borrowToken": "_0x199775",
        "borrowToken": "_0x87e661",
        "collateral": "_0x4a35e3",
        "_curvePool": "_0xb937e5",
        "balanceOf": "_0x881516",
        "curvePool": "_0x9c2179",
        "maxBorrow": "_0x6c2acd",
        "positions": "_0x90f7ed",
        "getPrice": "_0x1d608e",
        "borrowed": "_0xc1026d",
        "_oracle": "_0x09886c",
        "amounts": "_0xce053e",
        "deposit": "_0x9b35b9",
        "account": "_0x706ad4",
        "borrow": "_0xff0442",
        "amount": "_0x53c998",
        "oracle": "_0xbbf1ac",
        "price": "_0xb26360",
        "user": "_0x6d4f97",
        "to": "_0x20c1ed"
      },
      "changes": [
        "Renamed 29 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_025",
      "transformed_id": "ss_l3_medium_sn_tc_025",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x14a00e, uint256 _0x05fe19) external returns (bool);\n    function _0x675f09(address from, address _0x14a00e, uint256 _0x05fe19) external returns (bool);\n}\n\ninterface ICompoundToken {\n    function _0xc8d25a(uint256 _0x05fe19) external;\n    function _0xeb4e15(uint256 _0x05fe19) external;\n    function _0x5a49eb(uint256 _0x467ead) external;\n    function _0x127374(uint256 _0x05fe19) external;\n}\n\ncontract LendingMarket {\n    mapping(address => uint256) public _0x39264f;\n    mapping(address => uint256) public _0xd5bf56;\n\n    address public _0x060239;\n    uint256 public _0x3b57a3;\n\n    constructor(address _0x2bf369) {\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x060239 = _0x2bf369; }\n    }\n\n    function _0xc8d25a(uint256 _0x05fe19) external {\n        _0x39264f[msg.sender] += _0x05fe19;\n        _0x3b57a3 += _0x05fe19;\n\n        IERC20(_0x060239).transfer(msg.sender, _0x05fe19);\n    }\n\n    function _0xeb4e15(uint256 _0x05fe19) external {\n        IERC20(_0x060239)._0x675f09(msg.sender, address(this), _0x05fe19);\n\n        _0x39264f[msg.sender] -= _0x05fe19;\n        _0x3b57a3 -= _0x05fe19;\n    }\n}\n",
      "rename_map": {
        "accountBorrows": "_0x39264f",
        "accountTokens": "_0xd5bf56",
        "transferFrom": "_0x675f09",
        "totalBorrows": "_0x3b57a3",
        "repayBorrow": "_0xeb4e15",
        "_underlying": "_0x2bf369",
        "underlying": "_0x060239",
        "redeem": "_0x5a49eb",
        "borrow": "_0xc8d25a",
        "amount": "_0x05fe19",
        "tokens": "_0x467ead",
        "mint": "_0x127374",
        "to": "_0x14a00e"
      },
      "changes": [
        "Renamed 13 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_026",
      "transformed_id": "ss_l3_medium_sn_tc_026",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20Permit {\n    function _0x38c422(address _0x0302f4, address _0xf1bed7, uint256 value, uint256 _0x7b02ed, uint8 v, bytes32 r, bytes32 s) external;\n}\n\ncontract BridgeRouter {\n\n    function _0xf65561(\n        address from,\n        address _0x3b9bb7,\n        address _0x82884e,\n        uint256 _0xaa5bc4,\n        uint256 _0x7b02ed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 _0x6796d2\n    ) external {\n\n        if (v != 0 || r != bytes32(0) || s != bytes32(0)) {\n            try IERC20Permit(_0x3b9bb7)._0x38c422(from, address(this), _0xaa5bc4, _0x7b02ed, v, r, s) {} catch {}\n        }\n\n        _0x077735(from, _0x3b9bb7, _0x82884e, _0xaa5bc4, _0x6796d2);\n    }\n\n    function _0x077735(address from, address _0x3b9bb7, address _0x82884e, uint256 _0xaa5bc4, uint256 _0x6796d2) internal {\n        // Bridge logic\n    }\n}\n",
      "rename_map": {
        "bridgeOutWithPermit": "_0xf65561",
        "_bridgeOut": "_0x077735",
        "toChainID": "_0x6796d2",
        "deadline": "_0x7b02ed",
        "spender": "_0xf1bed7",
        "permit": "_0x38c422",
        "amount": "_0xaa5bc4",
        "token": "_0x3b9bb7",
        "owner": "_0x0302f4",
        "to": "_0x82884e"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_027",
      "transformed_id": "ss_l3_medium_sn_tc_027",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPair {\n    function _0x0faaf8() external view returns (address);\n    function _0x5ebb54() external view returns (address);\n    function _0x95b8fa() external view returns (uint112, uint112, uint32);\n}\n\ncontract SwapRouter {\n\n    function _0xf57efe(\n        uint256 _0x1fd265,\n        uint256 _0x6e8596,\n        address[] calldata _0xf236d8,\n        address _0x7fabaa,\n        uint256 _0x20eae9\n    ) external returns (uint[] memory _0x2c3ac1) {\n\n        _0x2c3ac1 = new uint[](_0xf236d8.length);\n        _0x2c3ac1[0] = _0x1fd265;\n\n        for (uint i = 0; i < _0xf236d8.length - 1; i++) {\n            address _0x17b92e = _0x6c0e75(_0xf236d8[i], _0xf236d8[i+1]);\n\n            (uint112 _0x34dc58, uint112 _0xc590ae,) = IPair(_0x17b92e)._0x95b8fa();\n\n            _0x2c3ac1[i+1] = _0x73c2ac(_0x2c3ac1[i], _0x34dc58, _0xc590ae);\n        }\n\n        return _0x2c3ac1;\n    }\n\n    function _0x6c0e75(address _0xc2b47f, address _0x12a9b0) internal pure returns (address) {\n        return address(uint160(uint256(_0x430132(abi._0xd09748(_0xc2b47f, _0x12a9b0)))));\n    }\n\n    function _0x73c2ac(uint256 _0x1fd265, uint112 _0xf6abd5, uint112 _0x0489e5) internal pure returns (uint256) {\n        return (_0x1fd265 * uint256(_0x0489e5)) / uint256(_0xf6abd5);\n    }\n}\n",
      "rename_map": {
        "swapExactTokensForTokens": "_0xf57efe",
        "_getAmountOut": "_0x73c2ac",
        "amountOutMin": "_0x6e8596",
        "encodePacked": "_0xd09748",
        "getReserves": "_0x95b8fa",
        "reserveOut": "_0x0489e5",
        "reserveIn": "_0xf6abd5",
        "keccak256": "_0x430132",
        "_getPair": "_0x6c0e75",
        "reserve1": "_0xc590ae",
        "reserve0": "_0x34dc58",
        "deadline": "_0x20eae9",
        "amountIn": "_0x1fd265",
        "amounts": "_0x2c3ac1",
        "tokenA": "_0xc2b47f",
        "token1": "_0x5ebb54",
        "tokenB": "_0x12a9b0",
        "token0": "_0x0faaf8",
        "path": "_0xf236d8",
        "pair": "_0x17b92e",
        "to": "_0x7fabaa"
      },
      "changes": [
        "Renamed 21 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_028",
      "transformed_id": "ss_l3_medium_sn_tc_028",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x094642(address _0x4ffa69) external view returns (uint256);\n    function transfer(address _0xc7d3a3, uint256 _0xdb810b) external returns (bool);\n    function _0xd93cf2(address from, address _0xc7d3a3, uint256 _0xdb810b) external returns (bool);\n}\n\ncontract TokenVault {\n    address public _0x869f76;\n    mapping(address => uint256) public _0x79f17b;\n\n    constructor(address _0xebc97f) {\n        _0x869f76 = _0xebc97f;\n    }\n\n    function _0x2b9577(uint256 _0xdb810b) external {\n        IERC20(_0x869f76)._0xd93cf2(msg.sender, address(this), _0xdb810b);\n\n        _0x79f17b[msg.sender] += _0xdb810b;\n    }\n\n    function _0xe95949(uint256 _0xdb810b) external {\n        require(_0x79f17b[msg.sender] >= _0xdb810b, \"Insufficient\");\n\n        _0x79f17b[msg.sender] -= _0xdb810b;\n\n        IERC20(_0x869f76).transfer(msg.sender, _0xdb810b);\n    }\n}\n",
      "rename_map": {
        "transferFrom": "_0xd93cf2",
        "balanceOf": "_0x094642",
        "withdraw": "_0xe95949",
        "deposits": "_0x79f17b",
        "account": "_0x4ffa69",
        "deposit": "_0x2b9577",
        "_token": "_0xebc97f",
        "amount": "_0xdb810b",
        "token": "_0x869f76",
        "to": "_0xc7d3a3"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_029",
      "transformed_id": "ss_l3_medium_sn_tc_029",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x478e08(address _0x7cffb1) external view returns (uint256);\n    function transfer(address _0x112d8b, uint256 _0x30b600) external returns (bool);\n    function _0x8d8aba(address from, address _0x112d8b, uint256 _0x30b600) external returns (bool);\n}\n\ninterface IPriceOracle {\n    function _0x5c8707(address _0x8a5f0a) external view returns (uint256);\n}\n\ncontract VaultStrategy {\n    address public _0x9592ac;\n    address public _0xa1410c;\n    uint256 public _0xd4fe1f;\n\n    mapping(address => uint256) public _0xd2acf9;\n\n    constructor(address _0xd042c7, address _0xc6d812) {\n        _0x9592ac = _0xd042c7;\n        _0xa1410c = _0xc6d812;\n    }\n\n    function _0x1c61a2(uint256 _0x30b600) external returns (uint256 _0x8d246c) {\n        uint256 _0x3169a1 = IERC20(_0x9592ac)._0x478e08(address(this));\n\n        if (_0xd4fe1f == 0) {\n            _0x8d246c = _0x30b600;\n        } else {\n            uint256 _0x2a2cb8 = IPriceOracle(_0xa1410c)._0x5c8707(_0x9592ac);\n            if (true) { _0x8d246c = (_0x30b600 * _0xd4fe1f * 1e18) / (_0x3169a1 * _0x2a2cb8); }\n        }\n\n        _0xd2acf9[msg.sender] += _0x8d246c;\n        _0xd4fe1f += _0x8d246c;\n\n        IERC20(_0x9592ac)._0x8d8aba(msg.sender, address(this), _0x30b600);\n        return _0x8d246c;\n    }\n\n    function _0xd58b64(uint256 _0x4e2350) external {\n        uint256 _0x3169a1 = IERC20(_0x9592ac)._0x478e08(address(this));\n\n        uint256 _0x2a2cb8 = IPriceOracle(_0xa1410c)._0x5c8707(_0x9592ac);\n        uint256 _0x30b600 = (_0x4e2350 * _0x3169a1 * _0x2a2cb8) / (_0xd4fe1f * 1e18);\n\n        _0xd2acf9[msg.sender] -= _0x4e2350;\n        _0xd4fe1f -= _0x4e2350;\n\n        IERC20(_0x9592ac).transfer(msg.sender, _0x30b600);\n    }\n}\n",
      "rename_map": {
        "sharesAmount": "_0x4e2350",
        "transferFrom": "_0x8d8aba",
        "sharesAdded": "_0x8d246c",
        "totalShares": "_0xd4fe1f",
        "balanceOf": "_0x478e08",
        "wantToken": "_0x9592ac",
        "getPrice": "_0x5c8707",
        "withdraw": "_0xd58b64",
        "_oracle": "_0xc6d812",
        "deposit": "_0x1c61a2",
        "account": "_0x7cffb1",
        "shares": "_0xd2acf9",
        "amount": "_0x30b600",
        "oracle": "_0xa1410c",
        "_want": "_0xd042c7",
        "token": "_0x8a5f0a",
        "price": "_0x2a2cb8",
        "pool": "_0x3169a1",
        "to": "_0x112d8b"
      },
      "changes": [
        "Renamed 19 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_030",
      "transformed_id": "ss_l3_medium_sn_tc_030",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract LiquidityPool {\n    uint256 public _0x11e645;\n    uint256 public _0x033db0;\n    uint256 public _0x33e1ee;\n\n    mapping(address => uint256) public _0x31979b;\n\n    function _0x6181fe(uint256 _0xc75d46, uint256 _0xe50b49) external returns (uint256 _0xb95b9d) {\n\n        if (_0x33e1ee == 0) {\n            _0xb95b9d = _0xc75d46;\n        } else {\n            uint256 _0xd8765f = (_0xc75d46 * _0x33e1ee) / _0x11e645;\n            uint256 _0xfccd2e = (_0xe50b49 * _0x33e1ee) / _0x033db0;\n\n            _0xb95b9d = (_0xd8765f + _0xfccd2e) / 2;\n        }\n\n        _0x31979b[msg.sender] += _0xb95b9d;\n        _0x33e1ee += _0xb95b9d;\n\n        _0x11e645 += _0xc75d46;\n        _0x033db0 += _0xe50b49;\n\n        return _0xb95b9d;\n    }\n\n    function _0x7203a5(uint256 _0xb95b9d) external returns (uint256, uint256) {\n        uint256 _0x03e60c = (_0xb95b9d * _0x11e645) / _0x33e1ee;\n        uint256 _0x6bb29f = (_0xb95b9d * _0x033db0) / _0x33e1ee;\n\n        _0x31979b[msg.sender] -= _0xb95b9d;\n        _0x33e1ee -= _0xb95b9d;\n\n        _0x11e645 -= _0x03e60c;\n        _0x033db0 -= _0x6bb29f;\n\n        return (_0x03e60c, _0x6bb29f);\n    }\n}\n",
      "rename_map": {
        "removeLiquidity": "_0x7203a5",
        "liquidityUnits": "_0xb95b9d",
        "addLiquidity": "_0x6181fe",
        "outputToken": "_0x6bb29f",
        "tokenAmount": "_0x033db0",
        "outputBase": "_0x03e60c",
        "inputToken": "_0xe50b49",
        "tokenRatio": "_0xfccd2e",
        "totalUnits": "_0x33e1ee",
        "baseAmount": "_0x11e645",
        "inputBase": "_0xc75d46",
        "baseRatio": "_0xd8765f",
        "units": "_0x31979b"
      },
      "changes": [
        "Renamed 13 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_031",
      "transformed_id": "ss_l3_medium_sn_tc_031",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xd2c8c4, uint256 _0xe82b9e) external returns (bool);\n\n    function _0x8a35f9(address _0x0c1d06) external view returns (uint256);\n}\n\ncontract OrbitBridge {\n    mapping(bytes32 => bool) public _0xe0efe8;\n    uint256 public constant REQUIRED_SIGNATURES = 5;\n    uint256 public constant TOTAL_VALIDATORS = 7;\n\n    mapping(address => bool) public _0x8de301;\n    address[] public _0x35f6e6;\n\n    event WithdrawalProcessed(\n        bytes32 _0xa776ef,\n        address _0xf40968,\n        address _0xae32ee,\n        uint256 _0xe82b9e\n    );\n\n    constructor() {\n        _0x35f6e6 = new address[](TOTAL_VALIDATORS);\n    }\n\n    function _0x032106(\n        address _0x1ff181,\n        string memory _0x4f5da9,\n        bytes memory _0x1576be,\n        address _0x651700,\n        address _0xf40968,\n        bytes32[] memory _0x164b73,\n        uint256[] memory _0x7d03ac,\n        bytes memory data,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) external {\n        bytes32 _0xa776ef = _0x164b73[1];\n\n        require(\n            !_0xe0efe8[_0xa776ef],\n            \"Transaction already processed\"\n        );\n\n        require(v.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n        require(\n            v.length == r.length && r.length == s.length,\n            \"Signature length mismatch\"\n        );\n\n        uint256 _0xe82b9e = _0x7d03ac[0];\n\n        _0xe0efe8[_0xa776ef] = true;\n\n        IERC20(_0xf40968).transfer(_0x651700, _0xe82b9e);\n\n        emit WithdrawalProcessed(_0xa776ef, _0xf40968, _0x651700, _0xe82b9e);\n    }\n\n    function _0x1eeca5(address _0x31b5e1) external {\n        _0x8de301[_0x31b5e1] = true;\n    }\n}\n",
      "rename_map": {
        "processedTransactions": "_0xe0efe8",
        "validatorList": "_0x35f6e6",
        "addValidator": "_0x1eeca5",
        "hubContract": "_0x1ff181",
        "validators": "_0x8de301",
        "balanceOf": "_0x8a35f9",
        "fromChain": "_0x4f5da9",
        "recipient": "_0xae32ee",
        "validator": "_0x31b5e1",
        "withdraw": "_0x032106",
        "fromAddr": "_0x1576be",
        "bytes32s": "_0x164b73",
        "account": "_0x0c1d06",
        "amount": "_0xe82b9e",
        "txHash": "_0xa776ef",
        "toAddr": "_0x651700",
        "uints": "_0x7d03ac",
        "token": "_0xf40968",
        "to": "_0xd2c8c4"
      },
      "changes": [
        "Renamed 19 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_032",
      "transformed_id": "ss_l3_medium_sn_tc_032",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xa07b85, uint256 _0xd7799e) external returns (bool);\n\n    function _0x96f41f(\n        address from,\n        address _0xa07b85,\n        uint256 _0xd7799e\n    ) external returns (bool);\n\n    function _0x2d0687(address _0xb284f6) external view returns (uint256);\n\n    function _0x943765(address _0xdb9494, uint256 _0xd7799e) external returns (bool);\n}\n\ninterface IFlashLoanReceiver {\n    function _0x1ffa4d(\n        address[] calldata _0x3a05b9,\n        uint256[] calldata _0x68212b,\n        uint256[] calldata _0x3993e8,\n        address _0x49d402,\n        bytes calldata _0xf33544\n    ) external returns (bool);\n}\n\ncontract RadiantLendingPool {\n    uint256 public constant RAY = 1e27;\n\n    struct ReserveData {\n        uint256 _0xbad296;\n        uint256 _0x3308a3;\n        address _0x467130;\n    }\n\n    mapping(address => ReserveData) public _0x928023;\n\n    function _0x305314(\n        address _0x23138d,\n        uint256 _0xd7799e,\n        address _0x4bc1db,\n        uint16 _0xb60b18\n    ) external {\n        IERC20(_0x23138d)._0x96f41f(msg.sender, address(this), _0xd7799e);\n\n        ReserveData storage _0x27b94f = _0x928023[_0x23138d];\n\n        uint256 _0x31c58c = _0x27b94f._0xbad296;\n        if (_0x31c58c == 0) {\n            _0x31c58c = RAY;\n        }\n\n        _0x27b94f._0xbad296 =\n            _0x31c58c +\n            (_0xd7799e * RAY) /\n            (_0x27b94f._0x3308a3 + 1);\n        _0x27b94f._0x3308a3 += _0xd7799e;\n\n        uint256 _0x655bc4 = _0x51024c(_0xd7799e, _0x27b94f._0xbad296);\n        _0xda1634(_0x27b94f._0x467130, _0x4bc1db, _0x655bc4);\n    }\n\n    function _0x3c07dc(\n        address _0x23138d,\n        uint256 _0xd7799e,\n        address _0xa07b85\n    ) external returns (uint256) {\n        ReserveData storage _0x27b94f = _0x928023[_0x23138d];\n\n        uint256 _0xf748ee = _0x51024c(_0xd7799e, _0x27b94f._0xbad296);\n\n        _0xc279c9(_0x27b94f._0x467130, msg.sender, _0xf748ee);\n\n        _0x27b94f._0x3308a3 -= _0xd7799e;\n        IERC20(_0x23138d).transfer(_0xa07b85, _0xd7799e);\n\n        return _0xd7799e;\n    }\n\n    function _0x33d7d9(\n        address _0x23138d,\n        uint256 _0xd7799e,\n        uint256 _0x4b1737,\n        uint16 _0xb60b18,\n        address _0x4bc1db\n    ) external {\n        IERC20(_0x23138d).transfer(_0x4bc1db, _0xd7799e);\n    }\n\n    function _0xe1f6d8(\n        address _0xdd2690,\n        address[] calldata _0x3a05b9,\n        uint256[] calldata _0x68212b,\n        uint256[] calldata _0xa699be,\n        address _0x4bc1db,\n        bytes calldata _0xf33544,\n        uint16 _0xb60b18\n    ) external {\n        for (uint256 i = 0; i < _0x3a05b9.length; i++) {\n            IERC20(_0x3a05b9[i]).transfer(_0xdd2690, _0x68212b[i]);\n        }\n\n        require(\n            IFlashLoanReceiver(_0xdd2690)._0x1ffa4d(\n                _0x3a05b9,\n                _0x68212b,\n                new uint256[](_0x3a05b9.length),\n                msg.sender,\n                _0xf33544\n            ),\n            \"Flashloan callback failed\"\n        );\n\n        for (uint256 i = 0; i < _0x3a05b9.length; i++) {\n            IERC20(_0x3a05b9[i])._0x96f41f(\n                _0xdd2690,\n                address(this),\n                _0x68212b[i]\n            );\n        }\n    }\n\n    function _0x51024c(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 _0xfeaf2c = b / 2;\n        require(b != 0, \"Division by zero\");\n        return (a * RAY + _0xfeaf2c) / b;\n    }\n\n    function _0xda1634(address _0xc159df, address _0xa07b85, uint256 _0xd7799e) internal {}\n\n    function _0xc279c9(\n        address _0xc159df,\n        address from,\n        uint256 _0xd7799e\n    ) internal {}\n}\n",
      "rename_map": {
        "currentLiquidityIndex": "_0x31c58c",
        "interestRateMode": "_0x4b1737",
        "executeOperation": "_0x1ffa4d",
        "receiverAddress": "_0xdd2690",
        "totalLiquidity": "_0x3308a3",
        "liquidityIndex": "_0xbad296",
        "rTokensToBurn": "_0xf748ee",
        "rTokenAddress": "_0x467130",
        "referralCode": "_0xb60b18",
        "transferFrom": "_0x96f41f",
        "rTokenAmount": "_0x655bc4",
        "_burnRToken": "_0xc279c9",
        "_mintRToken": "_0xda1634",
        "onBehalfOf": "_0x4bc1db",
        "balanceOf": "_0x2d0687",
        "flashLoan": "_0xe1f6d8",
        "initiator": "_0x49d402",
        "withdraw": "_0x3c07dc",
        "reserves": "_0x928023",
        "premiums": "_0x3993e8",
        "spender": "_0xdb9494",
        "approve": "_0x943765",
        "amounts": "_0x68212b",
        "deposit": "_0x305314",
        "account": "_0xb284f6",
        "reserve": "_0x27b94f",
        "borrow": "_0x33d7d9",
        "params": "_0xf33544",
        "amount": "_0xd7799e",
        "rayDiv": "_0x51024c",
        "rToken": "_0xc159df",
        "assets": "_0x3a05b9",
        "asset": "_0x23138d",
        "modes": "_0xa699be",
        "halfB": "_0xfeaf2c",
        "to": "_0xa07b85"
      },
      "changes": [
        "Renamed 36 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_033",
      "transformed_id": "ss_l3_medium_sn_tc_033",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xe5cb40, uint256 _0x769859) external returns (bool);\n\n    function _0x9777e4(\n        address from,\n        address _0xe5cb40,\n        uint256 _0x769859\n    ) external returns (bool);\n\n    function _0xf79930(address _0x6ac545) external view returns (uint256);\n\n    function _0x1880c3(address _0x4abad4, uint256 _0x769859) external returns (bool);\n}\n\ncontract SocketGateway {\n    mapping(uint32 => address) public _0x156133;\n    mapping(address => bool) public _0x5b13df;\n\n    event RouteExecuted(uint32 _0x46f4da, address _0x407d24, bytes _0x950f61);\n\n    function _0x02172c(\n        uint32 _0x46f4da,\n        bytes calldata _0xc22c0a\n    ) external payable returns (bytes memory) {\n        address _0x5ce519 = _0x156133[_0x46f4da];\n        require(_0x5ce519 != address(0), \"Invalid route\");\n        require(_0x5b13df[_0x5ce519], \"Route not approved\");\n\n        (bool _0x1de6e1, bytes memory _0x950f61) = _0x5ce519.call(_0xc22c0a);\n        require(_0x1de6e1, \"Route execution failed\");\n\n        emit RouteExecuted(_0x46f4da, msg.sender, _0x950f61);\n        return _0x950f61;\n    }\n\n    function _0xfa4532(uint32 _0x46f4da, address _0x5ce519) external {\n        _0x156133[_0x46f4da] = _0x5ce519;\n        _0x5b13df[_0x5ce519] = true;\n    }\n}\n\ncontract BasicRoute {\n    function _0xfa721c(\n        address _0x211898,\n        address _0x56e5e3,\n        uint256 _0x769859,\n        address _0x2a7155,\n        bytes32 _0x37ce08,\n        bytes calldata _0x2d31fa\n    ) external payable returns (uint256) {\n        if (_0x2d31fa.length > 0) {\n            (bool _0x1de6e1, ) = _0x211898.call(_0x2d31fa);\n            require(_0x1de6e1, \"Swap failed\");\n        }\n\n        return _0x769859;\n    }\n}\n",
      "rename_map": {
        "receiverAddress": "_0x2a7155",
        "approvedRoutes": "_0x5b13df",
        "performAction": "_0xfa721c",
        "swapExtraData": "_0x2d31fa",
        "transferFrom": "_0x9777e4",
        "routeAddress": "_0x5ce519",
        "executeRoute": "_0x02172c",
        "balanceOf": "_0xf79930",
        "routeData": "_0xc22c0a",
        "fromToken": "_0x211898",
        "metadata": "_0x37ce08",
        "addRoute": "_0xfa4532",
        "spender": "_0x4abad4",
        "approve": "_0x1880c3",
        "success": "_0x1de6e1",
        "account": "_0x6ac545",
        "toToken": "_0x56e5e3",
        "routeId": "_0x46f4da",
        "result": "_0x950f61",
        "routes": "_0x156133",
        "amount": "_0x769859",
        "user": "_0x407d24",
        "to": "_0xe5cb40"
      },
      "changes": [
        "Renamed 23 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_034",
      "transformed_id": "ss_l3_medium_sn_tc_034",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x50bde7, uint256 _0x045cf9) external returns (bool);\n\n    function _0xbf7238(\n        address from,\n        address _0x50bde7,\n        uint256 _0x045cf9\n    ) external returns (bool);\n\n    function _0x60dcea(address _0x4b8814) external view returns (uint256);\n\n    function _0x1a10f9(address _0x1aee99, uint256 _0x045cf9) external returns (bool);\n}\n\ninterface IUniswapV3Pool {\n    function _0x70991b(\n        address _0xd0a709,\n        bool _0x3c4236,\n        int256 _0xcda5a9,\n        uint160 _0xae42ec,\n        bytes calldata data\n    ) external returns (int256 _0xf38416, int256 _0x5d96d8);\n\n    function _0x9bef80(\n        address _0xd0a709,\n        uint256 _0xf38416,\n        uint256 _0x5d96d8,\n        bytes calldata data\n    ) external;\n}\n\ncontract GammaHypervisor {\n    IERC20 public _0x8cb825;\n    IERC20 public _0x8ce752;\n    IUniswapV3Pool public _0xb85386;\n\n    uint256 public _0x0573d1;\n    mapping(address => uint256) public _0x60dcea;\n\n    struct Position {\n        uint128 _0x9a6706;\n        int24 _0x0a04cf;\n        int24 _0x3d06a0;\n    }\n\n    Position public _0x04c1a1;\n    Position public _0x194c65;\n\n    function _0x04d0f8(\n        uint256 _0xd31c8e,\n        uint256 _0x2cf705,\n        address _0x50bde7\n    ) external returns (uint256 _0xca1721) {\n        uint256 _0x9a2cdd = _0x8cb825._0x60dcea(address(this));\n        uint256 _0xaeee76 = _0x8ce752._0x60dcea(address(this));\n\n        _0x8cb825._0xbf7238(msg.sender, address(this), _0xd31c8e);\n        _0x8ce752._0xbf7238(msg.sender, address(this), _0x2cf705);\n\n        if (_0x0573d1 == 0) {\n            _0xca1721 = _0xd31c8e + _0x2cf705;\n        } else {\n            uint256 _0x783385 = _0x9a2cdd + _0xd31c8e;\n            uint256 _0x17a228 = _0xaeee76 + _0x2cf705;\n\n            _0xca1721 = (_0x0573d1 * (_0xd31c8e + _0x2cf705)) / (_0x9a2cdd + _0xaeee76);\n        }\n\n        _0x60dcea[_0x50bde7] += _0xca1721;\n        _0x0573d1 += _0xca1721;\n\n        _0x93ed4d(_0xd31c8e, _0x2cf705);\n    }\n\n    function _0x6fe308(\n        uint256 _0xca1721,\n        address _0x50bde7\n    ) external returns (uint256 _0xf38416, uint256 _0x5d96d8) {\n        require(_0x60dcea[msg.sender] >= _0xca1721, \"Insufficient balance\");\n\n        uint256 _0x9a2cdd = _0x8cb825._0x60dcea(address(this));\n        uint256 _0xaeee76 = _0x8ce752._0x60dcea(address(this));\n\n        _0xf38416 = (_0xca1721 * _0x9a2cdd) / _0x0573d1;\n        _0x5d96d8 = (_0xca1721 * _0xaeee76) / _0x0573d1;\n\n        _0x60dcea[msg.sender] -= _0xca1721;\n        _0x0573d1 -= _0xca1721;\n\n        _0x8cb825.transfer(_0x50bde7, _0xf38416);\n        _0x8ce752.transfer(_0x50bde7, _0x5d96d8);\n    }\n\n    function _0xeee86f() external {\n        _0x28b8f1(_0x04c1a1._0x9a6706);\n\n        _0x93ed4d(\n            _0x8cb825._0x60dcea(address(this)),\n            _0x8ce752._0x60dcea(address(this))\n        );\n    }\n\n    function _0x93ed4d(uint256 _0xf38416, uint256 _0x5d96d8) internal {}\n\n    function _0x28b8f1(uint128 _0x9a6706) internal {}\n}\n",
      "rename_map": {
        "sqrtPriceLimitX96": "_0xae42ec",
        "_removeLiquidity": "_0x28b8f1",
        "amountSpecified": "_0xcda5a9",
        "amount0Current": "_0x783385",
        "amount1Current": "_0x17a228",
        "_addLiquidity": "_0x93ed4d",
        "limitPosition": "_0x194c65",
        "basePosition": "_0x04c1a1",
        "transferFrom": "_0xbf7238",
        "totalSupply": "_0x0573d1",
        "zeroForOne": "_0x3c4236",
        "liquidity": "_0x9a6706",
        "balanceOf": "_0x60dcea",
        "rebalance": "_0xeee86f",
        "recipient": "_0xd0a709",
        "tickLower": "_0x0a04cf",
        "tickUpper": "_0x3d06a0",
        "withdraw": "_0x6fe308",
        "deposit1": "_0x2cf705",
        "deposit0": "_0xd31c8e",
        "amount1": "_0x5d96d8",
        "spender": "_0x1aee99",
        "approve": "_0x1a10f9",
        "deposit": "_0x04d0f8",
        "account": "_0x4b8814",
        "amount0": "_0xf38416",
        "shares": "_0xca1721",
        "total1": "_0xaeee76",
        "amount": "_0x045cf9",
        "token1": "_0x8ce752",
        "total0": "_0x9a2cdd",
        "token0": "_0x8cb825",
        "flash": "_0x9bef80",
        "pool": "_0xb85386",
        "swap": "_0x70991b",
        "to": "_0x50bde7"
      },
      "changes": [
        "Renamed 36 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_035",
      "transformed_id": "ss_l3_medium_sn_tc_035",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x900aa6, uint256 _0xa92f31) external returns (bool);\n\n    function _0xc97266(\n        address from,\n        address _0x900aa6,\n        uint256 _0xa92f31\n    ) external returns (bool);\n\n    function _0xfc5bac(address _0xa9187d) external view returns (uint256);\n\n    function _0x2dac12(address _0xddd6e0, uint256 _0xa92f31) external returns (bool);\n}\n\ninterface IERC721 {\n    function _0xc97266(address from, address _0x900aa6, uint256 _0x83c8ce) external;\n\n    function _0x771f76(uint256 _0x83c8ce) external view returns (address);\n}\n\ncontract WiseLending {\n    struct PoolData {\n        uint256 _0x443195;\n        uint256 _0x318792;\n        uint256 _0x2d1e47;\n        uint256 _0x18a471;\n    }\n\n    mapping(address => PoolData) public _0x3f1d96;\n    mapping(uint256 => mapping(address => uint256)) public _0x27e78e;\n    mapping(uint256 => mapping(address => uint256)) public _0x327a7e;\n\n    IERC721 public _0x486cf3;\n    uint256 public _0x47d01b;\n\n    function _0x0c2df0() external returns (uint256) {\n        uint256 _0xe76609 = ++_0x47d01b;\n        return _0xe76609;\n    }\n\n    function _0xbd6473(\n        uint256 _0x13dff2,\n        address _0x633665,\n        uint256 _0xde7f5a\n    ) external returns (uint256 _0x31fc28) {\n        IERC20(_0x633665)._0xc97266(msg.sender, address(this), _0xde7f5a);\n\n        PoolData storage _0xbae547 = _0x3f1d96[_0x633665];\n\n        if (_0xbae547._0x318792 == 0) {\n            _0x31fc28 = _0xde7f5a;\n            _0xbae547._0x318792 = _0xde7f5a;\n        } else {\n            _0x31fc28 =\n                (_0xde7f5a * _0xbae547._0x318792) /\n                _0xbae547._0x443195;\n            _0xbae547._0x318792 += _0x31fc28;\n        }\n\n        _0xbae547._0x443195 += _0xde7f5a;\n        _0x27e78e[_0x13dff2][_0x633665] += _0x31fc28;\n\n        return _0x31fc28;\n    }\n\n    function _0x9f3967(\n        uint256 _0x13dff2,\n        address _0x633665,\n        uint256 _0xf89207\n    ) external returns (uint256 _0x4fe56e) {\n        require(\n            _0x27e78e[_0x13dff2][_0x633665] >= _0xf89207,\n            \"Insufficient shares\"\n        );\n\n        PoolData storage _0xbae547 = _0x3f1d96[_0x633665];\n\n        _0x4fe56e =\n            (_0xf89207 * _0xbae547._0x443195) /\n            _0xbae547._0x318792;\n\n        _0x27e78e[_0x13dff2][_0x633665] -= _0xf89207;\n        _0xbae547._0x318792 -= _0xf89207;\n        _0xbae547._0x443195 -= _0x4fe56e;\n\n        IERC20(_0x633665).transfer(msg.sender, _0x4fe56e);\n\n        return _0x4fe56e;\n    }\n\n    function _0xfdacb3(\n        uint256 _0x13dff2,\n        address _0x633665,\n        uint256 _0x3133aa\n    ) external returns (uint256 _0xd92b3b) {\n        PoolData storage _0xbae547 = _0x3f1d96[_0x633665];\n\n        _0xd92b3b =\n            (_0x3133aa * _0xbae547._0x318792) /\n            _0xbae547._0x443195;\n\n        require(\n            _0x27e78e[_0x13dff2][_0x633665] >= _0xd92b3b,\n            \"Insufficient shares\"\n        );\n\n        _0x27e78e[_0x13dff2][_0x633665] -= _0xd92b3b;\n        _0xbae547._0x318792 -= _0xd92b3b;\n        _0xbae547._0x443195 -= _0x3133aa;\n\n        IERC20(_0x633665).transfer(msg.sender, _0x3133aa);\n\n        return _0xd92b3b;\n    }\n\n    function _0xdbad45(\n        uint256 _0x13dff2,\n        address _0x633665\n    ) external view returns (uint256) {\n        return _0x27e78e[_0x13dff2][_0x633665];\n    }\n\n    function _0x91b4c4(address _0x633665) external view returns (uint256) {\n        return _0x3f1d96[_0x633665]._0x443195;\n    }\n}\n",
      "rename_map": {
        "getPositionLendingShares": "_0xdbad45",
        "withdrawExactShares": "_0x9f3967",
        "withdrawExactAmount": "_0xfdacb3",
        "depositExactAmount": "_0xbd6473",
        "totalDepositShares": "_0x318792",
        "totalBorrowShares": "_0x2d1e47",
        "userLendingShares": "_0x27e78e",
        "collateralFactor": "_0x18a471",
        "userBorrowShares": "_0x327a7e",
        "pseudoTotalPool": "_0x443195",
        "_withdrawAmount": "_0x3133aa",
        "lendingPoolData": "_0x3f1d96",
        "withdrawAmount": "_0x4fe56e",
        "mintPosition": "_0x0c2df0",
        "transferFrom": "_0xc97266",
        "nftIdCounter": "_0x47d01b",
        "positionNFTs": "_0x486cf3",
        "getTotalPool": "_0x91b4c4",
        "shareBurned": "_0xd92b3b",
        "shareAmount": "_0x31fc28",
        "_poolToken": "_0x633665",
        "balanceOf": "_0xfc5bac",
        "_amount": "_0xde7f5a",
        "_shares": "_0xf89207",
        "spender": "_0xddd6e0",
        "ownerOf": "_0x771f76",
        "approve": "_0x2dac12",
        "tokenId": "_0x83c8ce",
        "account": "_0xa9187d",
        "_nftId": "_0x13dff2",
        "amount": "_0xa92f31",
        "nftId": "_0xe76609",
        "pool": "_0xbae547",
        "to": "_0x900aa6"
      },
      "changes": [
        "Renamed 34 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_036",
      "transformed_id": "ss_l3_medium_sn_tc_036",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x22a2a6, uint256 _0x8796c3) external returns (bool);\n\n    function _0x9fa666(\n        address from,\n        address _0x22a2a6,\n        uint256 _0x8796c3\n    ) external returns (bool);\n\n    function _0xe88278(address _0xc3f084) external view returns (uint256);\n\n    function _0x5a4b25(address _0xe86933, uint256 _0x8796c3) external returns (bool);\n}\n\ninterface IBorrowerOperations {\n    function _0x7c3a6a(address _0xcfab23, bool _0x15400d) external;\n\n    function _0xe4f802(\n        address _0x1c4a74,\n        address _0xc3f084,\n        uint256 _0x937613,\n        uint256 _0x502d8f,\n        uint256 _0x6b6cc9,\n        address _0x4b8e99,\n        address _0x4ae99d\n    ) external;\n\n    function _0x3d3db5(address _0x1c4a74, address _0xc3f084) external;\n}\n\ninterface ITroveManager {\n    function _0x94a174(\n        address _0x39d641\n    ) external view returns (uint256 _0x2ab614, uint256 _0x6b1edf);\n\n    function _0xe3e7bb(address _0x39d641) external;\n}\n\ncontract MigrateTroveZap {\n    IBorrowerOperations public _0x72bd9b;\n    address public _0x48258a;\n    address public _0xb157db;\n\n    constructor(address _0x1e9def, address _0xe19c2a, address _0xc5d643) {\n        _0x72bd9b = _0x1e9def;\n        _0x48258a = _0xe19c2a;\n        _0xb157db = _0xc5d643;\n    }\n\n    function _0x5b081d(\n        address _0x1c4a74,\n        address _0xc3f084,\n        uint256 _0x08caf6,\n        uint256 _0x4f130f,\n        uint256 _0xa3187e,\n        address _0x992dab,\n        address _0xdcaa07\n    ) external {\n        IERC20(_0x48258a)._0x9fa666(\n            msg.sender,\n            address(this),\n            _0x4f130f\n        );\n\n        IERC20(_0x48258a)._0x5a4b25(address(_0x72bd9b), _0x4f130f);\n\n        _0x72bd9b._0xe4f802(\n            _0x1c4a74,\n            _0xc3f084,\n            _0x08caf6,\n            _0x4f130f,\n            _0xa3187e,\n            _0x992dab,\n            _0xdcaa07\n        );\n\n        IERC20(_0xb157db).transfer(msg.sender, _0xa3187e);\n    }\n\n    function _0xe2ba3b(address _0x1c4a74, address _0xc3f084) external {\n        _0x72bd9b._0x3d3db5(_0x1c4a74, _0xc3f084);\n    }\n}\n\ncontract BorrowerOperations {\n    mapping(address => mapping(address => bool)) public _0x335762;\n    ITroveManager public _0x1c4a74;\n\n    function _0x7c3a6a(address _0xcfab23, bool _0x15400d) external {\n        _0x335762[msg.sender][_0xcfab23] = _0x15400d;\n    }\n\n    function _0xe4f802(\n        address _0xcd27da,\n        address _0xc3f084,\n        uint256 _0x937613,\n        uint256 _0x502d8f,\n        uint256 _0x6b6cc9,\n        address _0x4b8e99,\n        address _0x4ae99d\n    ) external {\n        require(\n            msg.sender == _0xc3f084 || _0x335762[_0xc3f084][msg.sender],\n            \"Not authorized\"\n        );\n    }\n\n    function _0x3d3db5(address _0xcd27da, address _0xc3f084) external {\n        require(\n            msg.sender == _0xc3f084 || _0x335762[_0xc3f084][msg.sender],\n            \"Not authorized\"\n        );\n    }\n}\n",
      "rename_map": {
        "getTroveCollAndDebt": "_0x94a174",
        "openTroveAndMigrate": "_0x5b081d",
        "_borrowerOperations": "_0x1e9def",
        "setDelegateApproval": "_0x7c3a6a",
        "borrowerOperations": "_0x72bd9b",
        "_maxFeePercentage": "_0x937613",
        "_collateralAmount": "_0x502d8f",
        "maxFeePercentage": "_0x08caf6",
        "collateralAmount": "_0x4f130f",
        "_troveManager": "_0xcd27da",
        "closeTroveFor": "_0xe2ba3b",
        "troveManager": "_0x1c4a74",
        "transferFrom": "_0x9fa666",
        "_debtAmount": "_0x6b6cc9",
        "_isApproved": "_0x15400d",
        "_upperHint": "_0x4b8e99",
        "closeTrove": "_0x3d3db5",
        "_lowerHint": "_0x4ae99d",
        "debtAmount": "_0xa3187e",
        "balanceOf": "_0xe88278",
        "_delegate": "_0xcfab23",
        "_borrower": "_0x39d641",
        "upperHint": "_0x992dab",
        "openTrove": "_0xe4f802",
        "liquidate": "_0xe3e7bb",
        "delegates": "_0x335762",
        "lowerHint": "_0xdcaa07",
        "_wstETH": "_0xe19c2a",
        "spender": "_0xe86933",
        "approve": "_0x5a4b25",
        "account": "_0xc3f084",
        "_mkUSD": "_0xc5d643",
        "amount": "_0x8796c3",
        "wstETH": "_0x48258a",
        "mkUSD": "_0xb157db",
        "coll": "_0x2ab614",
        "debt": "_0x6b1edf",
        "to": "_0x22a2a6"
      },
      "changes": [
        "Renamed 38 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_037",
      "transformed_id": "ss_l3_medium_sn_tc_037",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x12e31c, uint256 _0xacbbad) external returns (bool);\n\n    function _0x326756(\n        address from,\n        address _0x12e31c,\n        uint256 _0xacbbad\n    ) external returns (bool);\n\n    function _0x175e73(address _0x6f8713) external view returns (uint256);\n\n    function _0x9432ab(address _0x7172e1, uint256 _0xacbbad) external returns (bool);\n}\n\ninterface IAaveOracle {\n    function _0x5edcb7(address _0x74628a) external view returns (uint256);\n\n    function _0x4770a4(\n        address[] calldata _0x61fc12,\n        address[] calldata _0x4b5432\n    ) external;\n}\n\ninterface ICurvePool {\n    function _0x80f2c2(\n        int128 i,\n        int128 j,\n        uint256 _0xe9468e,\n        uint256 _0x9fd863\n    ) external returns (uint256);\n\n    function _0x88162a(\n        int128 i,\n        int128 j,\n        uint256 _0xe9468e\n    ) external view returns (uint256);\n\n    function _0x78bd13(uint256 i) external view returns (uint256);\n}\n\ninterface ILendingPool {\n    function _0x772135(\n        address _0x74628a,\n        uint256 _0xacbbad,\n        address _0xd1aa8e,\n        uint16 _0x8915ae\n    ) external;\n\n    function _0x53ca02(\n        address _0x74628a,\n        uint256 _0xacbbad,\n        uint256 _0x90de7c,\n        uint16 _0x8915ae,\n        address _0xd1aa8e\n    ) external;\n\n    function _0xe3f89c(\n        address _0x74628a,\n        uint256 _0xacbbad,\n        address _0x12e31c\n    ) external returns (uint256);\n}\n\ncontract UwuLendingPool is ILendingPool {\n    IAaveOracle public _0x4db192;\n    mapping(address => uint256) public _0x491cfe;\n    mapping(address => uint256) public _0x6785a1;\n    uint256 public constant LTV = 8500;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    function _0x772135(\n        address _0x74628a,\n        uint256 _0xacbbad,\n        address _0xd1aa8e,\n        uint16 _0x8915ae\n    ) external override {\n        IERC20(_0x74628a)._0x326756(msg.sender, address(this), _0xacbbad);\n        _0x491cfe[_0xd1aa8e] += _0xacbbad;\n    }\n\n    function _0x53ca02(\n        address _0x74628a,\n        uint256 _0xacbbad,\n        uint256 _0x90de7c,\n        uint16 _0x8915ae,\n        address _0xd1aa8e\n    ) external override {\n        uint256 _0x9b01ad = _0x4db192._0x5edcb7(msg.sender);\n        uint256 _0xbaadd9 = _0x4db192._0x5edcb7(_0x74628a);\n\n        uint256 _0x9e9555 = (_0x491cfe[msg.sender] * _0x9b01ad) /\n            1e18;\n        uint256 _0x007590 = (_0x9e9555 * LTV) / BASIS_POINTS;\n\n        uint256 _0xe937c5 = (_0xacbbad * _0xbaadd9) / 1e18;\n\n        require(_0xe937c5 <= _0x007590, \"Insufficient collateral\");\n\n        _0x6785a1[msg.sender] += _0xacbbad;\n        IERC20(_0x74628a).transfer(_0xd1aa8e, _0xacbbad);\n    }\n\n    function _0xe3f89c(\n        address _0x74628a,\n        uint256 _0xacbbad,\n        address _0x12e31c\n    ) external override returns (uint256) {\n        require(_0x491cfe[msg.sender] >= _0xacbbad, \"Insufficient balance\");\n        _0x491cfe[msg.sender] -= _0xacbbad;\n        IERC20(_0x74628a).transfer(_0x12e31c, _0xacbbad);\n        return _0xacbbad;\n    }\n}\n\ncontract CurveOracle {\n    ICurvePool public _0x7fed22;\n\n    constructor(address _0x9e3edb) {\n        _0x7fed22 = _0x9e3edb;\n    }\n\n    function _0x5edcb7(address _0x74628a) external view returns (uint256) {\n        uint256 _0x442641 = _0x7fed22._0x78bd13(0);\n        uint256 _0xb7ea31 = _0x7fed22._0x78bd13(1);\n\n        uint256 _0xb9d877 = (_0xb7ea31 * 1e18) / _0x442641;\n\n        return _0xb9d877;\n    }\n}\n",
      "rename_map": {
        "interestRateMode": "_0x90de7c",
        "collateralPrice": "_0x9b01ad",
        "setAssetSources": "_0x4770a4",
        "collateralValue": "_0x9e9555",
        "getAssetPrice": "_0x5edcb7",
        "referralCode": "_0x8915ae",
        "transferFrom": "_0x326756",
        "borrowPrice": "_0xbaadd9",
        "borrowValue": "_0xe937c5",
        "onBehalfOf": "_0xd1aa8e",
        "balanceOf": "_0x175e73",
        "curvePool": "_0x7fed22",
        "maxBorrow": "_0x007590",
        "withdraw": "_0xe3f89c",
        "deposits": "_0x491cfe",
        "balance0": "_0x442641",
        "balances": "_0x78bd13",
        "balance1": "_0xb7ea31",
        "exchange": "_0x80f2c2",
        "spender": "_0x7172e1",
        "approve": "_0x9432ab",
        "borrows": "_0x6785a1",
        "deposit": "_0x772135",
        "account": "_0x6f8713",
        "sources": "_0x4b5432",
        "borrow": "_0x53ca02",
        "get_dy": "_0x88162a",
        "amount": "_0xacbbad",
        "oracle": "_0x4db192",
        "min_dy": "_0x9fd863",
        "assets": "_0x61fc12",
        "asset": "_0x74628a",
        "_pool": "_0x9e3edb",
        "price": "_0xb9d877",
        "to": "_0x12e31c",
        "dx": "_0xe9468e"
      },
      "changes": [
        "Renamed 36 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_038",
      "transformed_id": "ss_l3_medium_sn_tc_038",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x0da3db, uint256 _0xfb5802) external returns (bool);\n\n    function _0x0ed7d5(\n        address from,\n        address _0x0da3db,\n        uint256 _0xfb5802\n    ) external returns (bool);\n\n    function _0x6ce656(address _0xf5df28) external view returns (uint256);\n\n    function _0x1740c2(address _0x437bfb, uint256 _0xfb5802) external returns (bool);\n}\n\ninterface IPriceOracle {\n    function _0x711060(address _0x3ed061) external view returns (uint256);\n}\n\ncontract BlueberryLending {\n    struct Market {\n        bool _0x159137;\n        uint256 _0xadd19f;\n        mapping(address => uint256) _0x84fac8;\n        mapping(address => uint256) _0xd5e7b9;\n    }\n\n    mapping(address => Market) public _0x84ff46;\n    IPriceOracle public _0x7d162f;\n\n    uint256 public constant COLLATERAL_FACTOR = 75;\n    uint256 public constant BASIS_POINTS = 100;\n\n    function _0x0b8b40(\n        address[] calldata _0x9d7b33\n    ) external returns (uint256[] memory) {\n        uint256[] memory _0x293e33 = new uint256[](_0x9d7b33.length);\n        for (uint256 i = 0; i < _0x9d7b33.length; i++) {\n            _0x84ff46[_0x9d7b33[i]]._0x159137 = true;\n            _0x293e33[i] = 0;\n        }\n        return _0x293e33;\n    }\n\n    function _0x70c37c(address _0x3ed061, uint256 _0xfb5802) external returns (uint256) {\n        IERC20(_0x3ed061)._0x0ed7d5(msg.sender, address(this), _0xfb5802);\n\n        uint256 _0xc358b2 = _0x7d162f._0x711060(_0x3ed061);\n\n        _0x84ff46[_0x3ed061]._0x84fac8[msg.sender] += _0xfb5802;\n        return 0;\n    }\n\n    function _0xf87221(\n        address _0x22b3ca,\n        uint256 _0xfd980e\n    ) external returns (uint256) {\n        uint256 _0x8c3d5a = 0;\n\n        uint256 _0xae7572 = _0x7d162f._0x711060(_0x22b3ca);\n        uint256 _0xcf464f = (_0xfd980e * _0xae7572) / 1e18;\n\n        uint256 _0x6007e4 = (_0x8c3d5a * COLLATERAL_FACTOR) /\n            BASIS_POINTS;\n\n        require(_0xcf464f <= _0x6007e4, \"Insufficient collateral\");\n\n        _0x84ff46[_0x22b3ca]._0xd5e7b9[msg.sender] += _0xfd980e;\n        IERC20(_0x22b3ca).transfer(msg.sender, _0xfd980e);\n\n        return 0;\n    }\n\n    function _0x0a50c9(\n        address _0x745516,\n        address _0xc02da3,\n        uint256 _0xbbb330,\n        address _0x1adaf7\n    ) external {}\n}\n\ncontract ManipulableOracle is IPriceOracle {\n    mapping(address => uint256) public _0xc439b6;\n\n    function _0x711060(address _0x3ed061) external view override returns (uint256) {\n        return _0xc439b6[_0x3ed061];\n    }\n\n    function _0x3ffac7(address _0x3ed061, uint256 _0xc358b2) external {\n        _0xc439b6[_0x3ed061] = _0xc358b2;\n    }\n}\n",
      "rename_map": {
        "totalCollateralValue": "_0x8c3d5a",
        "accountCollateral": "_0x84fac8",
        "collateralFactor": "_0xadd19f",
        "collateralToken": "_0x1adaf7",
        "accountBorrows": "_0xd5e7b9",
        "maxBorrowValue": "_0x6007e4",
        "borrowAmount": "_0xfd980e",
        "transferFrom": "_0x0ed7d5",
        "enterMarkets": "_0x0b8b40",
        "borrowPrice": "_0xae7572",
        "borrowToken": "_0x22b3ca",
        "borrowValue": "_0xcf464f",
        "repayAmount": "_0xbbb330",
        "repayToken": "_0xc02da3",
        "balanceOf": "_0x6ce656",
        "liquidate": "_0x0a50c9",
        "getPrice": "_0x711060",
        "isListed": "_0x159137",
        "borrower": "_0x745516",
        "setPrice": "_0x3ffac7",
        "results": "_0x293e33",
        "spender": "_0x437bfb",
        "approve": "_0x1740c2",
        "markets": "_0x84ff46",
        "account": "_0xf5df28",
        "vTokens": "_0x9d7b33",
        "borrow": "_0xf87221",
        "amount": "_0xfb5802",
        "oracle": "_0x7d162f",
        "prices": "_0xc439b6",
        "token": "_0x3ed061",
        "price": "_0xc358b2",
        "mint": "_0x70c37c",
        "to": "_0x0da3db"
      },
      "changes": [
        "Renamed 34 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_039",
      "transformed_id": "ss_l3_medium_sn_tc_039",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x987233, uint256 _0x7edd68) external returns (bool);\n\n    function _0x702a09(\n        address from,\n        address _0x987233,\n        uint256 _0x7edd68\n    ) external returns (bool);\n\n    function _0xb12a2e(address _0x80a3a8) external view returns (uint256);\n\n    function _0x574975(address _0xcfb48c, uint256 _0x7edd68) external returns (bool);\n}\n\ninterface IWETH {\n    function _0x40153c() external payable;\n\n    function _0xbc364b(uint256 _0x7edd68) external;\n\n    function _0xb12a2e(address _0x80a3a8) external view returns (uint256);\n}\n\ncontract CowSolver {\n    IWETH public immutable WETH;\n    address public immutable _0x8291cf;\n\n    constructor(address _0x9fee9e, address _0xde51ed) {\n        WETH = IWETH(_0x9fee9e);\n        _0x8291cf = _0xde51ed;\n    }\n\n    function _0x2a7b24(\n        int256 _0x5b4b5a,\n        int256 _0xf3e074,\n        bytes calldata data\n    ) external payable {\n        (\n            uint256 _0xe66aa2,\n            address _0x2394eb,\n            address _0x323ddd,\n            address _0x047c86\n        ) = abi._0x2e4cc4(data, (uint256, address, address, address));\n\n        uint256 _0x7ca7cd;\n        if (_0x5b4b5a > 0) {\n            _0x7ca7cd = uint256(_0x5b4b5a);\n        } else {\n            _0x7ca7cd = uint256(_0xf3e074);\n        }\n\n        if (_0x323ddd == address(WETH)) {\n            WETH._0xbc364b(_0x7ca7cd);\n            payable(_0x047c86).transfer(_0x7ca7cd);\n        } else {\n            IERC20(_0x323ddd).transfer(_0x047c86, _0x7ca7cd);\n        }\n    }\n\n    function _0x023c72(bytes calldata _0xc489bc) external {\n        require(msg.sender == _0x8291cf, \"Only settlement\");\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "uniswapV3SwapCallback": "_0x2a7b24",
        "executeSettlement": "_0x023c72",
        "settlementData": "_0xc489bc",
        "amount1Delta": "_0xf3e074",
        "transferFrom": "_0x702a09",
        "amount0Delta": "_0x5b4b5a",
        "_settlement": "_0xde51ed",
        "amountToPay": "_0x7ca7cd",
        "settlement": "_0x8291cf",
        "balanceOf": "_0xb12a2e",
        "recipient": "_0x047c86",
        "withdraw": "_0xbc364b",
        "spender": "_0xcfb48c",
        "approve": "_0x574975",
        "deposit": "_0x40153c",
        "account": "_0x80a3a8",
        "tokenIn": "_0x323ddd",
        "amount": "_0x7edd68",
        "solver": "_0x2394eb",
        "decode": "_0x2e4cc4",
        "price": "_0xe66aa2",
        "_weth": "_0x9fee9e",
        "to": "_0x987233"
      },
      "changes": [
        "Renamed 23 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_040",
      "transformed_id": "ss_l3_medium_sn_tc_040",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xaecfee, uint256 _0x63ab0f) external returns (bool);\n\n    function _0x92b228(\n        address from,\n        address _0xaecfee,\n        uint256 _0x63ab0f\n    ) external returns (bool);\n\n    function _0x61be23(address _0xd6e7af) external view returns (uint256);\n\n    function _0x7cb45f(address _0x93dccc, uint256 _0x63ab0f) external returns (bool);\n}\n\ninterface IUniswapV3Router {\n    struct ExactInputSingleParams {\n        address _0x71adb7;\n        address _0x551d5f;\n        uint24 _0xfe3c35;\n        address _0x2f9708;\n        uint256 _0x45f5f6;\n        uint256 _0x17f475;\n        uint256 _0xf1c578;\n        uint160 _0x1738af;\n    }\n\n    function _0xfec688(\n        ExactInputSingleParams calldata _0xd64ccd\n    ) external payable returns (uint256 _0x7fbbb0);\n}\n\ncontract BedrockVault {\n    IERC20 public immutable _0x929ccb;\n    IERC20 public immutable WBTC;\n    IUniswapV3Router public immutable _0xe19355;\n\n    uint256 public _0xc9b8c6;\n    uint256 public _0x916723;\n\n    constructor(address _0xbbc91c, address _0x6d5eb7, address _0xc6a674) {\n        _0x929ccb = IERC20(_0xbbc91c);\n        if (gasleft() > 0) { WBTC = IERC20(_0x6d5eb7); }\n        _0xe19355 = IUniswapV3Router(_0xc6a674);\n    }\n\n    function _0x4a86ae() external payable {\n        require(msg.value > 0, \"No ETH sent\");\n\n        uint256 _0x95da5c = msg.value;\n\n        _0xc9b8c6 += msg.value;\n        _0x916723 += _0x95da5c;\n\n        _0x929ccb.transfer(msg.sender, _0x95da5c);\n    }\n\n    function _0x8920c2(uint256 _0x63ab0f) external {\n        require(_0x63ab0f > 0, \"No amount specified\");\n        require(_0x929ccb._0x61be23(msg.sender) >= _0x63ab0f, \"Insufficient balance\");\n\n        _0x929ccb._0x92b228(msg.sender, address(this), _0x63ab0f);\n\n        uint256 _0xfc86d1 = _0x63ab0f;\n        require(address(this).balance >= _0xfc86d1, \"Insufficient ETH\");\n\n        payable(msg.sender).transfer(_0xfc86d1);\n    }\n\n    function _0x17af49() external pure returns (uint256) {\n        return 1e18;\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "totalUniBTCMinted": "_0x916723",
        "totalETHDeposited": "_0xc9b8c6",
        "sqrtPriceLimitX96": "_0x1738af",
        "exactInputSingle": "_0xfec688",
        "amountOutMinimum": "_0xf1c578",
        "getExchangeRate": "_0x17af49",
        "transferFrom": "_0x92b228",
        "uniBTCAmount": "_0x95da5c",
        "balanceOf": "_0x61be23",
        "ethAmount": "_0xfc86d1",
        "recipient": "_0x2f9708",
        "amountOut": "_0x7fbbb0",
        "tokenOut": "_0x551d5f",
        "deadline": "_0x45f5f6",
        "amountIn": "_0x17f475",
        "spender": "_0x93dccc",
        "approve": "_0x7cb45f",
        "_uniBTC": "_0xbbc91c",
        "account": "_0xd6e7af",
        "tokenIn": "_0x71adb7",
        "_router": "_0xc6a674",
        "params": "_0xd64ccd",
        "uniBTC": "_0x929ccb",
        "amount": "_0x63ab0f",
        "redeem": "_0x8920c2",
        "router": "_0xe19355",
        "_wbtc": "_0x6d5eb7",
        "mint": "_0x4a86ae",
        "fee": "_0xfe3c35",
        "to": "_0xaecfee"
      },
      "changes": [
        "Renamed 30 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_041",
      "transformed_id": "ss_l3_medium_sn_tc_041",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x41ba3a, uint256 _0xbb9b6e) external returns (bool);\n\n    function _0x184294(\n        address from,\n        address _0x41ba3a,\n        uint256 _0xbb9b6e\n    ) external returns (bool);\n\n    function _0x786c9f(address _0x22c9fd) external view returns (uint256);\n\n    function _0x8535eb(address _0x79c8fa, uint256 _0xbb9b6e) external returns (bool);\n}\n\ncontract ShezmuCollateralToken is IERC20 {\n    string public _0x42a4fb = \"Shezmu Collateral Token\";\n    string public _0x253b05 = \"SCT\";\n    uint8 public _0xe35a07 = 18;\n\n    mapping(address => uint256) public _0x786c9f;\n    mapping(address => mapping(address => uint256)) public _0x513b59;\n    uint256 public _0x44e627;\n\n    function _0x2dfe4a(address _0x41ba3a, uint256 _0xbb9b6e) external {\n        _0x786c9f[_0x41ba3a] += _0xbb9b6e;\n        _0x44e627 += _0xbb9b6e;\n    }\n\n    function transfer(\n        address _0x41ba3a,\n        uint256 _0xbb9b6e\n    ) external override returns (bool) {\n        require(_0x786c9f[msg.sender] >= _0xbb9b6e, \"Insufficient balance\");\n        _0x786c9f[msg.sender] -= _0xbb9b6e;\n        _0x786c9f[_0x41ba3a] += _0xbb9b6e;\n        return true;\n    }\n\n    function _0x184294(\n        address from,\n        address _0x41ba3a,\n        uint256 _0xbb9b6e\n    ) external override returns (bool) {\n        require(_0x786c9f[from] >= _0xbb9b6e, \"Insufficient balance\");\n        require(\n            _0x513b59[from][msg.sender] >= _0xbb9b6e,\n            \"Insufficient allowance\"\n        );\n        _0x786c9f[from] -= _0xbb9b6e;\n        _0x786c9f[_0x41ba3a] += _0xbb9b6e;\n        _0x513b59[from][msg.sender] -= _0xbb9b6e;\n        return true;\n    }\n\n    function _0x8535eb(\n        address _0x79c8fa,\n        uint256 _0xbb9b6e\n    ) external override returns (bool) {\n        _0x513b59[msg.sender][_0x79c8fa] = _0xbb9b6e;\n        return true;\n    }\n}\n\ncontract ShezmuVault {\n    IERC20 public _0x92319e;\n    IERC20 public _0x08cdfa;\n\n    mapping(address => uint256) public _0x5d990f;\n    mapping(address => uint256) public _0x85692f;\n\n    uint256 public constant COLLATERAL_RATIO = 150;\n    uint256 public constant BASIS_POINTS = 100;\n\n    constructor(address _0xb62d13, address _0xac6928) {\n        _0x92319e = IERC20(_0xb62d13);\n        _0x08cdfa = IERC20(_0xac6928);\n    }\n\n    function _0xad5b64(uint256 _0xbb9b6e) external {\n        _0x92319e._0x184294(msg.sender, address(this), _0xbb9b6e);\n        _0x5d990f[msg.sender] += _0xbb9b6e;\n    }\n\n    function _0x22a21f(uint256 _0xbb9b6e) external {\n        uint256 _0x872843 = (_0x5d990f[msg.sender] * BASIS_POINTS) /\n            COLLATERAL_RATIO;\n\n        require(\n            _0x85692f[msg.sender] + _0xbb9b6e <= _0x872843,\n            \"Insufficient collateral\"\n        );\n\n        _0x85692f[msg.sender] += _0xbb9b6e;\n\n        _0x08cdfa.transfer(msg.sender, _0xbb9b6e);\n    }\n\n    function _0x3f345d(uint256 _0xbb9b6e) external {\n        require(_0x85692f[msg.sender] >= _0xbb9b6e, \"Excessive repayment\");\n        _0x08cdfa._0x184294(msg.sender, address(this), _0xbb9b6e);\n        _0x85692f[msg.sender] -= _0xbb9b6e;\n    }\n\n    function _0x4b3365(uint256 _0xbb9b6e) external {\n        require(\n            _0x5d990f[msg.sender] >= _0xbb9b6e,\n            \"Insufficient collateral\"\n        );\n        uint256 _0xb20cdd = _0x5d990f[msg.sender] - _0xbb9b6e;\n        uint256 _0xb4a3ea = (_0xb20cdd * BASIS_POINTS) /\n            COLLATERAL_RATIO;\n        require(\n            _0x85692f[msg.sender] <= _0xb4a3ea,\n            \"Would be undercollateralized\"\n        );\n\n        _0x5d990f[msg.sender] -= _0xbb9b6e;\n        _0x92319e.transfer(msg.sender, _0xbb9b6e);\n    }\n}\n",
      "rename_map": {
        "remainingCollateral": "_0xb20cdd",
        "withdrawCollateral": "_0x4b3365",
        "collateralBalance": "_0x5d990f",
        "_collateralToken": "_0xb62d13",
        "collateralToken": "_0x92319e",
        "addCollateral": "_0xad5b64",
        "transferFrom": "_0x184294",
        "totalSupply": "_0x44e627",
        "debtBalance": "_0x85692f",
        "balanceOf": "_0x786c9f",
        "maxBorrow": "_0x872843",
        "allowance": "_0x513b59",
        "_shezUSD": "_0xac6928",
        "decimals": "_0xe35a07",
        "spender": "_0x79c8fa",
        "approve": "_0x8535eb",
        "shezUSD": "_0x08cdfa",
        "maxDebt": "_0xb4a3ea",
        "account": "_0x22c9fd",
        "borrow": "_0x22a21f",
        "amount": "_0xbb9b6e",
        "symbol": "_0x253b05",
        "repay": "_0x3f345d",
        "name": "_0x42a4fb",
        "mint": "_0x2dfe4a",
        "to": "_0x41ba3a"
      },
      "changes": [
        "Renamed 26 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_042",
      "transformed_id": "ss_l3_medium_sn_tc_042",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x44e4ec, uint256 _0xddea38) external returns (bool);\n\n    function _0x2b01a1(\n        address from,\n        address _0x44e4ec,\n        uint256 _0xddea38\n    ) external returns (bool);\n\n    function _0xf31820(address _0x5ad34c) external view returns (uint256);\n\n    function _0x23c1e2(address _0xdc18c5, uint256 _0xddea38) external returns (bool);\n}\n\nenum TokenLockup {\n    Unlocked,\n    Locked,\n    Vesting\n}\n\nstruct Campaign {\n    address _0x0722ba;\n    address _0x79c728;\n    uint256 _0xddea38;\n    uint256 _0xe3900f;\n    TokenLockup _0xf9726e;\n    bytes32 _0x42ba4a;\n}\n\nstruct ClaimLockup {\n    address _0x7162b4;\n    uint256 _0x95f168;\n    uint256 _0x39d7bb;\n    uint256 _0x498ea5;\n    uint256 _0x12b900;\n}\n\nstruct Donation {\n    address _0x7162b4;\n    uint256 _0xddea38;\n    uint256 _0x5a2df1;\n    uint256 _0x95f168;\n    uint256 _0x39d7bb;\n    uint256 _0x498ea5;\n}\n\ncontract HedgeyClaimCampaigns {\n    mapping(bytes16 => Campaign) public _0xa1ae12;\n\n    function _0xa20137(\n        bytes16 _0xee2cd9,\n        Campaign memory _0xef7d79,\n        ClaimLockup memory _0x638d69,\n        Donation memory _0x398010\n    ) external {\n        require(_0xa1ae12[_0xee2cd9]._0x0722ba == address(0), \"Campaign exists\");\n\n        _0xa1ae12[_0xee2cd9] = _0xef7d79;\n\n        if (_0x398010._0xddea38 > 0 && _0x398010._0x7162b4 != address(0)) {\n            (bool _0xd47b0a, ) = _0x398010._0x7162b4.call(\n                abi._0xab74e9(\n                    \"createTokenLock(address,uint256,uint256,uint256,uint256,uint256)\",\n                    _0xef7d79._0x79c728,\n                    _0x398010._0xddea38,\n                    _0x398010._0x95f168,\n                    _0x398010._0x39d7bb,\n                    _0x398010._0x5a2df1,\n                    _0x398010._0x498ea5\n                )\n            );\n\n            require(_0xd47b0a, \"Token lock failed\");\n        }\n    }\n\n    function _0x96b12b(bytes16 _0x6b6683) external {\n        require(_0xa1ae12[_0x6b6683]._0x0722ba == msg.sender, \"Not manager\");\n        delete _0xa1ae12[_0x6b6683];\n    }\n}\n",
      "rename_map": {
        "createLockedCampaign": "_0xa20137",
        "encodeWithSignature": "_0xab74e9",
        "cancelCampaign": "_0x96b12b",
        "transferFrom": "_0x2b01a1",
        "tokenLocker": "_0x7162b4",
        "tokenLockup": "_0xf9726e",
        "claimLockup": "_0x638d69",
        "campaignId": "_0x6b6683",
        "balanceOf": "_0xf31820",
        "campaigns": "_0xa1ae12",
        "campaign": "_0xef7d79",
        "donation": "_0x398010",
        "manager": "_0x0722ba",
        "spender": "_0xdc18c5",
        "approve": "_0x23c1e2",
        "periods": "_0x12b900",
        "success": "_0xd47b0a",
        "account": "_0x5ad34c",
        "amount": "_0xddea38",
        "period": "_0x498ea5",
        "token": "_0x79c728",
        "start": "_0x95f168",
        "cliff": "_0x39d7bb",
        "root": "_0x42ba4a",
        "rate": "_0x5a2df1",
        "end": "_0xe3900f",
        "to": "_0x44e4ec",
        "id": "_0xee2cd9"
      },
      "changes": [
        "Renamed 28 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_043",
      "transformed_id": "ss_l3_medium_sn_tc_043",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xf56c41, uint256 _0x6802fa) external returns (bool);\n\n    function _0x97026d(\n        address from,\n        address _0xf56c41,\n        uint256 _0x6802fa\n    ) external returns (bool);\n\n    function _0x621e6e(address _0x8d2ea2) external view returns (uint256);\n\n    function _0xb121ce(address _0x227580, uint256 _0x6802fa) external returns (bool);\n}\n\ncontract SenecaChamber {\n    uint8 public constant OPERATION_CALL = 30;\n    uint8 public constant OPERATION_DELEGATECALL = 31;\n\n    mapping(address => bool) public _0xbbfd05;\n\n    function _0x0048d7(\n        uint8[] memory _0xebf9f5,\n        uint256[] memory _0xa87f8e,\n        bytes[] memory _0x7d2904\n    ) external payable returns (uint256 _0x4c26c9, uint256 _0x8d8329) {\n        require(\n            _0xebf9f5.length == _0xa87f8e.length && _0xa87f8e.length == _0x7d2904.length,\n            \"Length mismatch\"\n        );\n\n        for (uint256 i = 0; i < _0xebf9f5.length; i++) {\n            if (_0xebf9f5[i] == OPERATION_CALL) {\n                (address _0xd28b4a, bytes memory callData, , , ) = abi._0x8bcdda(\n                    _0x7d2904[i],\n                    (address, bytes, uint256, uint256, uint256)\n                );\n\n                (bool _0xe04574, ) = _0xd28b4a.call{value: _0xa87f8e[i]}(callData);\n                require(_0xe04574, \"Call failed\");\n            }\n        }\n\n        return (0, 0);\n    }\n}\n",
      "rename_map": {
        "performOperations": "_0x0048d7",
        "transferFrom": "_0x97026d",
        "vaultOwners": "_0xbbfd05",
        "balanceOf": "_0x621e6e",
        "account": "_0x8d2ea2",
        "spender": "_0x227580",
        "approve": "_0xb121ce",
        "success": "_0xe04574",
        "actions": "_0xebf9f5",
        "target": "_0xd28b4a",
        "values": "_0xa87f8e",
        "value1": "_0x4c26c9",
        "value2": "_0x8d8329",
        "decode": "_0x8bcdda",
        "amount": "_0x6802fa",
        "datas": "_0x7d2904",
        "to": "_0xf56c41"
      },
      "changes": [
        "Renamed 17 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_044",
      "transformed_id": "ss_l3_medium_sn_tc_044",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xc63011, uint256 _0x031920) external returns (bool);\n\n    function _0x6687c8(\n        address from,\n        address _0xc63011,\n        uint256 _0x031920\n    ) external returns (bool);\n\n    function _0x527dfe(address _0xa05d55) external view returns (uint256);\n\n    function _0x73dda7(address _0xded5a3, uint256 _0x031920) external returns (bool);\n}\n\ninterface ISmartLoan {\n    function _0xc58988(\n        bytes32 _0x815a7e,\n        bytes32 _0x919afa,\n        uint256 _0x9acad2,\n        uint256 _0x315451,\n        bytes4 selector,\n        bytes memory data\n    ) external;\n\n    function _0xf53cff(address _0x438c39, uint256[] calldata _0xc6cb12) external;\n}\n\ncontract SmartLoansFactory {\n    address public _0xf7808e;\n\n    constructor() {\n        if (block.timestamp > 0) { _0xf7808e = msg.sender; }\n    }\n\n    function _0xda9dbc() external returns (address) {\n        SmartLoan _0x45606b = new SmartLoan();\n        return address(_0x45606b);\n    }\n\n    function _0xd7b2e2(\n        address _0x4141ca,\n        address _0xeff903\n    ) external {\n        require(msg.sender == _0xf7808e, \"Not admin\");\n    }\n}\n\ncontract SmartLoan is ISmartLoan {\n    mapping(bytes32 => uint256) public _0xa8b840;\n    mapping(bytes32 => uint256) public _0xb5cec1;\n\n    function _0xc58988(\n        bytes32 _0x815a7e,\n        bytes32 _0x919afa,\n        uint256 _0x9acad2,\n        uint256 _0x315451,\n        bytes4 selector,\n        bytes memory data\n    ) external override {}\n\n    function _0xf53cff(\n        address _0x438c39,\n        uint256[] calldata _0xc6cb12\n    ) external override {\n        (bool _0x846999, ) = _0x438c39.call(\n            abi._0x9bcee2(\"claimRewards(address)\", msg.sender)\n        );\n    }\n}\n",
      "rename_map": {
        "encodeWithSignature": "_0x9bcee2",
        "newImplementation": "_0xeff903",
        "swapDebtParaSwap": "_0xc58988",
        "_borrowAmount": "_0x315451",
        "_repayAmount": "_0x9acad2",
        "transferFrom": "_0x6687c8",
        "claimReward": "_0xf53cff",
        "upgradePool": "_0xd7b2e2",
        "_fromAsset": "_0x815a7e",
        "createLoan": "_0xda9dbc",
        "balanceOf": "_0x527dfe",
        "poolProxy": "_0x4141ca",
        "_toAsset": "_0x919afa",
        "deposits": "_0xa8b840",
        "spender": "_0xded5a3",
        "approve": "_0x73dda7",
        "success": "_0x846999",
        "account": "_0xa05d55",
        "amount": "_0x031920",
        "debts": "_0xb5cec1",
        "admin": "_0xf7808e",
        "loan": "_0x45606b",
        "pair": "_0x438c39",
        "ids": "_0xc6cb12",
        "to": "_0xc63011"
      },
      "changes": [
        "Renamed 25 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_045",
      "transformed_id": "ss_l3_medium_sn_tc_045",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xa7f6e3, uint256 _0x014c62) external returns (bool);\n\n    function _0x248b7e(\n        address from,\n        address _0xa7f6e3,\n        uint256 _0x014c62\n    ) external returns (bool);\n\n    function _0xd8da4d(address _0xceb860) external view returns (uint256);\n\n    function _0xf4b8a3(address _0xdca4e8, uint256 _0x014c62) external returns (bool);\n}\n\ninterface IPendleMarket {\n    function _0x238ab0() external view returns (address[] memory);\n\n    function _0x31ef4d() external returns (uint256[] memory);\n\n    function _0xf88f07(address _0x9bc562) external returns (uint256[] memory);\n}\n\ncontract PenpieStaking {\n    mapping(address => mapping(address => uint256)) public _0x488d1d;\n    mapping(address => uint256) public _0x2a0617;\n\n    function _0xf3bdf8(address _0x382d97, uint256 _0x014c62) external {\n        IERC20(_0x382d97)._0x248b7e(msg.sender, address(this), _0x014c62);\n        _0x488d1d[_0x382d97][msg.sender] += _0x014c62;\n        _0x2a0617[_0x382d97] += _0x014c62;\n    }\n\n    function _0xf88f07(address _0x382d97, address _0x9bc562) external {\n        uint256[] memory _0xd2fd20 = IPendleMarket(_0x382d97)._0xf88f07(_0x9bc562);\n\n        for (uint256 i = 0; i < _0xd2fd20.length; i++) {}\n    }\n\n    function _0xc3d72b(address _0x382d97, uint256 _0x014c62) external {\n        require(\n            _0x488d1d[_0x382d97][msg.sender] >= _0x014c62,\n            \"Insufficient balance\"\n        );\n\n        _0x488d1d[_0x382d97][msg.sender] -= _0x014c62;\n        _0x2a0617[_0x382d97] -= _0x014c62;\n\n        IERC20(_0x382d97).transfer(msg.sender, _0x014c62);\n    }\n}\n\ncontract PendleMarketRegister {\n    mapping(address => bool) public _0xe2ab3a;\n\n    function _0x2698ae(address _0x382d97) external {\n        _0xe2ab3a[_0x382d97] = true;\n    }\n}\n",
      "rename_map": {
        "rewardIndexesCurrent": "_0x31ef4d",
        "registeredMarkets": "_0xe2ab3a",
        "getRewardTokens": "_0x238ab0",
        "registerMarket": "_0x2698ae",
        "transferFrom": "_0x248b7e",
        "userBalances": "_0x488d1d",
        "claimRewards": "_0xf88f07",
        "totalStaked": "_0x2a0617",
        "balanceOf": "_0xd8da4d",
        "withdraw": "_0xc3d72b",
        "spender": "_0xdca4e8",
        "rewards": "_0xd2fd20",
        "approve": "_0xf4b8a3",
        "deposit": "_0xf3bdf8",
        "account": "_0xceb860",
        "amount": "_0x014c62",
        "market": "_0x382d97",
        "user": "_0x9bc562",
        "to": "_0xa7f6e3"
      },
      "changes": [
        "Renamed 19 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_046",
      "transformed_id": "ss_l3_medium_sn_tc_046",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x8a57ac, uint256 _0x99d4a5) external returns (bool);\n\n    function _0x9c18a7(address _0x95c227) external view returns (uint256);\n}\n\ncontract FloatHotWalletV2 {\n    address public _0xf8d56d;\n\n    mapping(address => bool) public _0x54a1a9;\n\n    event Withdrawal(address _0x3d7e19, address _0x8a57ac, uint256 _0x99d4a5);\n\n    constructor() {\n        _0xf8d56d = msg.sender;\n    }\n\n    modifier _0xf23390() {\n        require(msg.sender == _0xf8d56d, \"Not owner\");\n        _;\n    }\n\n    function _0x822812(\n        address _0x3d7e19,\n        address _0x8a57ac,\n        uint256 _0x99d4a5\n    ) external _0xf23390 {\n        if (_0x3d7e19 == address(0)) {\n            payable(_0x8a57ac).transfer(_0x99d4a5);\n        } else {\n            IERC20(_0x3d7e19).transfer(_0x8a57ac, _0x99d4a5);\n        }\n\n        emit Withdrawal(_0x3d7e19, _0x8a57ac, _0x99d4a5);\n    }\n\n    function _0x1d4a4c(address _0x3d7e19) external _0xf23390 {\n        uint256 balance;\n        if (_0x3d7e19 == address(0)) {\n            balance = address(this).balance;\n            payable(_0xf8d56d).transfer(balance);\n        } else {\n            balance = IERC20(_0x3d7e19)._0x9c18a7(address(this));\n            IERC20(_0x3d7e19).transfer(_0xf8d56d, balance);\n        }\n\n        emit Withdrawal(_0x3d7e19, _0xf8d56d, balance);\n    }\n\n    function _0xbe6b2b(address _0x617c7c) external _0xf23390 {\n        _0xf8d56d = _0x617c7c;\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "authorizedOperators": "_0x54a1a9",
        "emergencyWithdraw": "_0x1d4a4c",
        "transferOwnership": "_0xbe6b2b",
        "balanceOf": "_0x9c18a7",
        "onlyOwner": "_0xf23390",
        "withdraw": "_0x822812",
        "newOwner": "_0x617c7c",
        "account": "_0x95c227",
        "amount": "_0x99d4a5",
        "token": "_0x3d7e19",
        "owner": "_0xf8d56d",
        "to": "_0x8a57ac"
      },
      "changes": [
        "Renamed 12 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_047",
      "transformed_id": "ss_l3_medium_sn_tc_047",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xf45ac2, uint256 _0x55e1a8) external returns (bool);\n\n    function _0xc9e424(address _0x0ec9f8) external view returns (uint256);\n}\n\ncontract PlayDappToken {\n    string public _0xa05867 = \"PlayDapp Token\";\n    string public _0xf653ff = \"PLA\";\n    uint8 public _0x94da43 = 18;\n\n    uint256 public _0x7dffb0;\n\n    address public _0x03dd0e;\n\n    mapping(address => uint256) public _0xc9e424;\n    mapping(address => mapping(address => uint256)) public _0x4e72e8;\n\n    event Transfer(address indexed from, address indexed _0xf45ac2, uint256 value);\n    event Approval(\n        address indexed _0xcd1111,\n        address indexed _0xb31e78,\n        uint256 value\n    );\n    event Minted(address indexed _0xf45ac2, uint256 _0x55e1a8);\n\n    constructor() {\n        if (block.timestamp > 0) { _0x03dd0e = msg.sender; }\n        _0x53a391(msg.sender, 700_000_000 * 10 ** 18);\n    }\n\n    modifier _0xf2b0df() {\n        require(msg.sender == _0x03dd0e, \"Not minter\");\n        _;\n    }\n\n    function _0xb61751(address _0xf45ac2, uint256 _0x55e1a8) external _0xf2b0df {\n        _0x53a391(_0xf45ac2, _0x55e1a8);\n        emit Minted(_0xf45ac2, _0x55e1a8);\n    }\n\n    function _0x53a391(address _0xf45ac2, uint256 _0x55e1a8) internal {\n        require(_0xf45ac2 != address(0), \"Mint to zero address\");\n\n        _0x7dffb0 += _0x55e1a8;\n        _0xc9e424[_0xf45ac2] += _0x55e1a8;\n\n        emit Transfer(address(0), _0xf45ac2, _0x55e1a8);\n    }\n\n    function _0xf7a245(address _0xa386ec) external _0xf2b0df {\n        _0x03dd0e = _0xa386ec;\n    }\n\n    function transfer(address _0xf45ac2, uint256 _0x55e1a8) external returns (bool) {\n        require(_0xc9e424[msg.sender] >= _0x55e1a8, \"Insufficient balance\");\n        _0xc9e424[msg.sender] -= _0x55e1a8;\n        _0xc9e424[_0xf45ac2] += _0x55e1a8;\n        emit Transfer(msg.sender, _0xf45ac2, _0x55e1a8);\n        return true;\n    }\n\n    function _0xec6aaa(address _0xb31e78, uint256 _0x55e1a8) external returns (bool) {\n        _0x4e72e8[msg.sender][_0xb31e78] = _0x55e1a8;\n        emit Approval(msg.sender, _0xb31e78, _0x55e1a8);\n        return true;\n    }\n\n    function _0x536009(\n        address from,\n        address _0xf45ac2,\n        uint256 _0x55e1a8\n    ) external returns (bool) {\n        require(_0xc9e424[from] >= _0x55e1a8, \"Insufficient balance\");\n        require(\n            _0x4e72e8[from][msg.sender] >= _0x55e1a8,\n            \"Insufficient allowance\"\n        );\n\n        _0xc9e424[from] -= _0x55e1a8;\n        _0xc9e424[_0xf45ac2] += _0x55e1a8;\n        _0x4e72e8[from][msg.sender] -= _0x55e1a8;\n\n        emit Transfer(from, _0xf45ac2, _0x55e1a8);\n        return true;\n    }\n}\n",
      "rename_map": {
        "transferFrom": "_0x536009",
        "totalSupply": "_0x7dffb0",
        "onlyMinter": "_0xf2b0df",
        "balanceOf": "_0xc9e424",
        "newMinter": "_0xa386ec",
        "setMinter": "_0xf7a245",
        "allowance": "_0x4e72e8",
        "decimals": "_0x94da43",
        "spender": "_0xb31e78",
        "approve": "_0xec6aaa",
        "account": "_0x0ec9f8",
        "amount": "_0x55e1a8",
        "minter": "_0x03dd0e",
        "symbol": "_0xf653ff",
        "owner": "_0xcd1111",
        "_mint": "_0x53a391",
        "name": "_0xa05867",
        "mint": "_0xb61751",
        "to": "_0xf45ac2"
      },
      "changes": [
        "Renamed 19 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_048",
      "transformed_id": "ss_l3_medium_sn_tc_048",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x1d5597, uint256 _0x1d39ff) external returns (bool);\n\n    function _0x1d01b1(\n        address from,\n        address _0x1d5597,\n        uint256 _0x1d39ff\n    ) external returns (bool);\n\n    function _0x498e08(address _0xc2ff90) external view returns (uint256);\n}\n\ncontract SonneMarket {\n    IERC20 public _0x7e86ea;\n\n    string public _0x3a23e0 = \"Sonne WETH\";\n    string public _0x8a8e29 = \"soWETH\";\n    uint8 public _0xfc2c8d = 8;\n\n    uint256 public _0xf6fcd9;\n    mapping(address => uint256) public _0x498e08;\n\n    uint256 public _0x9498ce;\n    uint256 public _0x66c858;\n\n    event Mint(address _0x3e6ab1, uint256 _0xae288f, uint256 _0x781b64);\n    event Redeem(address _0x6f7eda, uint256 _0xf931d9, uint256 _0xdc3bfb);\n\n    constructor(address _0xc1f9de) {\n        _0x7e86ea = IERC20(_0xc1f9de);\n    }\n\n    function _0xbd363e() public view returns (uint256) {\n        if (_0xf6fcd9 == 0) {\n            return 1e18;\n        }\n\n        uint256 _0x419ac6 = _0x7e86ea._0x498e08(address(this));\n\n        uint256 _0xf83c1e = _0x419ac6 + _0x9498ce - _0x66c858;\n\n        return (_0xf83c1e * 1e18) / _0xf6fcd9;\n    }\n\n    function _0xbafdf8(uint256 _0xae288f) external returns (uint256) {\n        require(_0xae288f > 0, \"Zero mint\");\n\n        uint256 _0x39c43f = _0xbd363e();\n\n        uint256 _0x781b64 = (_0xae288f * 1e18) / _0x39c43f;\n\n        _0xf6fcd9 += _0x781b64;\n        _0x498e08[msg.sender] += _0x781b64;\n\n        _0x7e86ea._0x1d01b1(msg.sender, address(this), _0xae288f);\n\n        emit Mint(msg.sender, _0xae288f, _0x781b64);\n        return _0x781b64;\n    }\n\n    function _0x2b21e3(uint256 _0xdc3bfb) external returns (uint256) {\n        require(_0x498e08[msg.sender] >= _0xdc3bfb, \"Insufficient balance\");\n\n        uint256 _0x39c43f = _0xbd363e();\n\n        uint256 _0xf931d9 = (_0xdc3bfb * _0x39c43f) / 1e18;\n\n        _0x498e08[msg.sender] -= _0xdc3bfb;\n        _0xf6fcd9 -= _0xdc3bfb;\n\n        _0x7e86ea.transfer(msg.sender, _0xf931d9);\n\n        emit Redeem(msg.sender, _0xf931d9, _0xdc3bfb);\n        return _0xf931d9;\n    }\n\n    function _0x7299d3(\n        address _0xc2ff90\n    ) external view returns (uint256) {\n        uint256 _0x39c43f = _0xbd363e();\n\n        return (_0x498e08[_0xc2ff90] * _0x39c43f) / 1e18;\n    }\n}\n",
      "rename_map": {
        "exchangeRateMantissa": "_0x39c43f",
        "balanceOfUnderlying": "_0x7299d3",
        "totalUnderlying": "_0xf83c1e",
        "totalReserves": "_0x66c858",
        "transferFrom": "_0x1d01b1",
        "exchangeRate": "_0xbd363e",
        "totalBorrows": "_0x9498ce",
        "redeemAmount": "_0xf931d9",
        "redeemTokens": "_0xdc3bfb",
        "totalSupply": "_0xf6fcd9",
        "_underlying": "_0xc1f9de",
        "underlying": "_0x7e86ea",
        "mintAmount": "_0xae288f",
        "mintTokens": "_0x781b64",
        "balanceOf": "_0x498e08",
        "redeemer": "_0x6f7eda",
        "decimals": "_0xfc2c8d",
        "account": "_0xc2ff90",
        "symbol": "_0x8a8e29",
        "amount": "_0x1d39ff",
        "minter": "_0x3e6ab1",
        "redeem": "_0x2b21e3",
        "name": "_0x3a23e0",
        "cash": "_0x419ac6",
        "mint": "_0xbafdf8",
        "to": "_0x1d5597"
      },
      "changes": [
        "Renamed 26 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_049",
      "transformed_id": "ss_l3_medium_sn_tc_049",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xd43dd8, uint256 _0xd42a91) external returns (bool);\n\n    function _0x4d122e(\n        address from,\n        address _0xd43dd8,\n        uint256 _0xd42a91\n    ) external returns (bool);\n\n    function _0xf050e9(address _0x83ffcc) external view returns (uint256);\n}\n\ninterface IMarket {\n    function _0x23473f(\n        address _0x83ffcc\n    )\n        external\n        view\n        returns (uint256 _0x37e7e0, uint256 _0x068fe4, uint256 _0x4fc2f0);\n}\n\ncontract DebtPreviewer {\n    function _0xe95f02(\n        address _0x51bdea,\n        address _0x83ffcc\n    )\n        external\n        view\n        returns (\n            uint256 _0xb5b141,\n            uint256 _0x37cdc5,\n            uint256 _0xcd1523\n        )\n    {\n        (uint256 _0x37e7e0, uint256 _0x068fe4, uint256 _0x4fc2f0) = IMarket(\n            _0x51bdea\n        )._0x23473f(_0x83ffcc);\n\n        _0xb5b141 = (_0x37e7e0 * _0x4fc2f0) / 1e18;\n        _0x37cdc5 = _0x068fe4;\n\n        if (_0x37cdc5 == 0) {\n            _0xcd1523 = type(uint256)._0xcc9ad9;\n        } else {\n            _0xcd1523 = (_0xb5b141 * 1e18) / _0x37cdc5;\n        }\n\n        return (_0xb5b141, _0x37cdc5, _0xcd1523);\n    }\n\n    function _0xc4c9c4(\n        address[] calldata _0x750dae,\n        address _0x83ffcc\n    )\n        external\n        view\n        returns (\n            uint256 _0xef7823,\n            uint256 _0xf6f5a1,\n            uint256 _0xac4167\n        )\n    {\n        for (uint256 i = 0; i < _0x750dae.length; i++) {\n            (uint256 _0x37e7e0, uint256 _0xe4d452, ) = this._0xe95f02(\n                _0x750dae[i],\n                _0x83ffcc\n            );\n\n            _0xef7823 += _0x37e7e0;\n            _0xf6f5a1 += _0xe4d452;\n        }\n\n        if (_0xf6f5a1 == 0) {\n            _0xac4167 = type(uint256)._0xcc9ad9;\n        } else {\n            _0xac4167 = (_0xef7823 * 1e18) / _0xf6f5a1;\n        }\n\n        return (_0xef7823, _0xf6f5a1, _0xac4167);\n    }\n}\n\ncontract ExactlyMarket {\n    IERC20 public _0x7fa789;\n    DebtPreviewer public _0x6ef423;\n\n    mapping(address => uint256) public _0x5c44a3;\n    mapping(address => uint256) public _0x068fe4;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(address _0x1bc43f, address _0x9df4d4) {\n        _0x7fa789 = IERC20(_0x1bc43f);\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x6ef423 = DebtPreviewer(_0x9df4d4); }\n    }\n\n    function _0xa1b452(uint256 _0xd42a91) external {\n        _0x7fa789._0x4d122e(msg.sender, address(this), _0xd42a91);\n        _0x5c44a3[msg.sender] += _0xd42a91;\n    }\n\n    function _0xba9026(uint256 _0xd42a91, address[] calldata _0x750dae) external {\n        (uint256 _0xef7823, uint256 _0xf6f5a1, ) = _0x6ef423\n            ._0xc4c9c4(_0x750dae, msg.sender);\n\n        uint256 _0xf53ca3 = _0xf6f5a1 + _0xd42a91;\n\n        uint256 _0xeaeabd = (_0xef7823 * COLLATERAL_FACTOR) / 100;\n        require(_0xf53ca3 <= _0xeaeabd, \"Insufficient collateral\");\n\n        _0x068fe4[msg.sender] += _0xd42a91;\n        _0x7fa789.transfer(msg.sender, _0xd42a91);\n    }\n\n    function _0x23473f(\n        address _0x83ffcc\n    )\n        external\n        view\n        returns (uint256 _0x37e7e0, uint256 _0x8e9956, uint256 _0x4fc2f0)\n    {\n        return (_0x5c44a3[_0x83ffcc], _0x068fe4[_0x83ffcc], 1e18);\n    }\n}\n",
      "rename_map": {
        "previewMultipleMarkets": "_0xc4c9c4",
        "getAccountSnapshot": "_0x23473f",
        "totalCollateral": "_0xef7823",
        "collateralValue": "_0xb5b141",
        "overallHealth": "_0xac4167",
        "healthFactor": "_0xcd1523",
        "transferFrom": "_0x4d122e",
        "exchangeRate": "_0x4fc2f0",
        "previewDebt": "_0xe95f02",
        "_previewer": "_0x9df4d4",
        "collateral": "_0x37e7e0",
        "balanceOf": "_0xf050e9",
        "debtValue": "_0x37cdc5",
        "totalDebt": "_0xf6f5a1",
        "maxBorrow": "_0xeaeabd",
        "previewer": "_0x6ef423",
        "deposits": "_0x5c44a3",
        "borrowed": "_0x8e9956",
        "borrows": "_0x068fe4",
        "markets": "_0x750dae",
        "deposit": "_0xa1b452",
        "account": "_0x83ffcc",
        "newDebt": "_0xf53ca3",
        "borrow": "_0xba9026",
        "_asset": "_0x1bc43f",
        "amount": "_0xd42a91",
        "market": "_0x51bdea",
        "asset": "_0x7fa789",
        "debt": "_0xe4d452",
        "max": "_0xcc9ad9",
        "to": "_0xd43dd8"
      },
      "changes": [
        "Renamed 31 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_050",
      "transformed_id": "ss_l3_medium_sn_tc_050",
      "level": "l3",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x8ba85b, uint256 _0xc1c3d2) external returns (bool);\n\n    function _0xb88703(\n        address from,\n        address _0x8ba85b,\n        uint256 _0xc1c3d2\n    ) external returns (bool);\n\n    function _0xfd05ec(address _0x4f3255) external view returns (uint256);\n}\n\ncontract MunchablesLockManager {\n    address public _0xa2aba3;\n    address public _0xc8fa8f;\n\n    struct PlayerSettings {\n        uint256 _0x7a4ef4;\n        address _0xe17c02;\n        uint256 _0x3792f5;\n        uint256 _0x62ef99;\n    }\n\n    mapping(address => PlayerSettings) public _0x1faf1c;\n    mapping(address => uint256) public _0x8c07ca;\n\n    IERC20 public immutable _0xe3bec4;\n\n    event Locked(address _0x95d81a, uint256 _0xc1c3d2, address _0xbc3bf6);\n    event ConfigUpdated(address _0xe38453, address _0x2a949e);\n\n    constructor(address _0x9911ba) {\n        _0xa2aba3 = msg.sender;\n        _0xe3bec4 = IERC20(_0x9911ba);\n    }\n\n    modifier _0xc90f83() {\n        require(msg.sender == _0xa2aba3, \"Not admin\");\n        _;\n    }\n\n    function _0xb7d7cf(uint256 _0xc1c3d2, uint256 _0xb16d38) external {\n        require(_0xc1c3d2 > 0, \"Zero amount\");\n\n        _0xe3bec4._0xb88703(msg.sender, address(this), _0xc1c3d2);\n\n        _0x8c07ca[msg.sender] += _0xc1c3d2;\n        _0x1faf1c[msg.sender] = PlayerSettings({\n            _0x7a4ef4: _0xc1c3d2,\n            _0xe17c02: msg.sender,\n            _0x3792f5: _0xb16d38,\n            _0x62ef99: block.timestamp\n        });\n\n        emit Locked(msg.sender, _0xc1c3d2, msg.sender);\n    }\n\n    function _0x9939f4(address _0x05dd60) external _0xc90f83 {\n        address _0xe38453 = _0xc8fa8f;\n        _0xc8fa8f = _0x05dd60;\n\n        emit ConfigUpdated(_0xe38453, _0x05dd60);\n    }\n\n    function _0x825e61(\n        address _0x95d81a,\n        address _0xa50cff\n    ) external _0xc90f83 {\n        _0x1faf1c[_0x95d81a]._0xe17c02 = _0xa50cff;\n    }\n\n    function _0xd22013() external {\n        PlayerSettings memory _0x4cfe2b = _0x1faf1c[msg.sender];\n\n        require(_0x4cfe2b._0x7a4ef4 > 0, \"No locked tokens\");\n        require(\n            block.timestamp >= _0x4cfe2b._0x62ef99 + _0x4cfe2b._0x3792f5,\n            \"Still locked\"\n        );\n\n        uint256 _0xc1c3d2 = _0x4cfe2b._0x7a4ef4;\n\n        address _0xbc3bf6 = _0x4cfe2b._0xe17c02;\n\n        delete _0x1faf1c[msg.sender];\n        _0x8c07ca[msg.sender] = 0;\n\n        _0xe3bec4.transfer(_0xbc3bf6, _0xc1c3d2);\n    }\n\n    function _0x2c72e4(address _0x95d81a) external _0xc90f83 {\n        PlayerSettings memory _0x4cfe2b = _0x1faf1c[_0x95d81a];\n        uint256 _0xc1c3d2 = _0x4cfe2b._0x7a4ef4;\n        address _0xbc3bf6 = _0x4cfe2b._0xe17c02;\n\n        delete _0x1faf1c[_0x95d81a];\n        _0x8c07ca[_0x95d81a] = 0;\n\n        _0xe3bec4.transfer(_0xbc3bf6, _0xc1c3d2);\n    }\n\n    function _0x6d1943(address _0xa51f37) external _0xc90f83 {\n        _0xa2aba3 = _0xa51f37;\n    }\n}\n",
      "rename_map": {
        "setConfigStorage": "_0x9939f4",
        "setLockRecipient": "_0x825e61",
        "emergencyUnlock": "_0x2c72e4",
        "_configStorage": "_0x05dd60",
        "playerSettings": "_0x1faf1c",
        "playerBalances": "_0x8c07ca",
        "configStorage": "_0xc8fa8f",
        "transferAdmin": "_0x6d1943",
        "lockStartTime": "_0x62ef99",
        "lockRecipient": "_0xe17c02",
        "transferFrom": "_0xb88703",
        "lockedAmount": "_0x7a4ef4",
        "newRecipient": "_0xa50cff",
        "lockDuration": "_0x3792f5",
        "balanceOf": "_0xfd05ec",
        "newConfig": "_0x2a949e",
        "oldConfig": "_0xe38453",
        "recipient": "_0xbc3bf6",
        "onlyAdmin": "_0xc90f83",
        "settings": "_0x4cfe2b",
        "newAdmin": "_0xa51f37",
        "duration": "_0xb16d38",
        "account": "_0x4f3255",
        "unlock": "_0xd22013",
        "player": "_0x95d81a",
        "amount": "_0xc1c3d2",
        "_weth": "_0x9911ba",
        "admin": "_0xa2aba3",
        "weth": "_0xe3bec4",
        "lock": "_0xb7d7cf",
        "to": "_0x8ba85b"
      },
      "changes": [
        "Renamed 31 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    }
  ]
}