{
  "timestamp": "2025-12-18T05:23:56.941472",
  "level": "l2",
  "variant": "short",
  "source": "nocomments",
  "total_files": 252,
  "successful": 250,
  "failed": 2,
  "results": [
    {
      "original_id": "nc_ds_001",
      "transformed_id": "ss_l2_short_nc_ds_001",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "contract i {\n        uint private Balance = 0;\n        uint private Payout_id = 0;\n        uint private Last_Payout = 0;\n        uint private WinningPot = 0;\n        uint private Min_multiplier = 1100;\n\n\n        uint private q = 0;\n        uint private c = 20;\n\n        uint private PotFrac = 30;\n\n        address private k;\n\n        function i() {\n            k = msg.sender;\n        }\n\n        modifier b {if (msg.sender == k) _;  }\n\n        struct Player {\n            address n;\n            uint g;\n            bool o;\n        }\n\n        Player[] private d;\n\n\n        function() {\n            m();\n        }\n\n\n        function m() private {\n            uint e=msg.value;\n            if (msg.value < 500 finney) {\n                    msg.sender.send(msg.value);\n                    return;\n            }\n            if (msg.value > 20 ether) {\n                    msg.sender.send(msg.value- (20 ether));\n                    e=20 ether;\n            }\n            Participate(e);\n        }\n\n\n        function Participate(uint e) private {\n\n\n                uint a=Min_multiplier;\n                if(Balance < 1 ether && d.length>1){\n                    a+=100;\n                }\n                if( (d.length % 10)==0 && d.length>1 ){\n                    a+=100;\n                }\n\n\n                d.push(Player(msg.sender, (e * a) / 1000, false));\n\n\n                WinningPot += (e * PotFrac) / 1000;\n                q += (e * c) / 1000;\n                Balance += (e * (1000 - ( c + PotFrac ))) / 1000;\n\n\n                if(  ( e > 1 ether ) && (e > d[Payout_id].g) ){\n                    uint p = f(100);\n                    if( p % 10 == 0 ){\n                        msg.sender.send(WinningPot);\n                        WinningPot=0;\n                    }\n\n                }\n\n\n                while ( Balance > d[Payout_id].g ) {\n                    Last_Payout = d[Payout_id].g;\n                    d[Payout_id].n.send(Last_Payout);\n                    Balance -= d[Payout_id].g;\n                    d[Payout_id].o=true;\n\n                    Payout_id += 1;\n                }\n        }\n\n    uint256 constant private l =  block.timestamp;\n\n    function f(uint Max) constant private returns (uint256 j){\n\n        uint256 x = l * 100 / Max;\n        uint256 y = l * block.number / (l % 5) ;\n        uint256 r = block.number/3 + (l % 300) + Last_Payout +y;\n        uint256 h = uint256(block.blockhash(r));\n\n        return uint256((h / x)) % Max + 1;\n    }\n\n\n    function ChangeOwnership(address h) b {\n        k = h;\n    }\n    function WatchBalance() constant returns(uint TotalBalance) {\n        TotalBalance = Balance /  1 wei;\n    }\n\n    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\n        TotalBalanceInEther = Balance /  1 ether;\n    }\n\n\n    function CollectAllFees() b {\n        if (q == 0) throw;\n        k.send(q);\n        c-=1;\n        q = 0;\n    }\n\n    function GetAndReduceFeesByFraction(uint p) b {\n        if (q == 0) c-=1;\n        k.send(q / 1000 * p);\n        q -= q / 1000 * p;\n    }\n\n\nfunction NextPayout() constant returns(uint NextPayout) {\n    NextPayout = d[Payout_id].g /  1 wei;\n}\n\nfunction WatchFees() constant returns(uint CollectedFees) {\n    CollectedFees = q / 1 wei;\n}\n\nfunction WatchWinningPot() constant returns(uint WinningPot) {\n    WinningPot = WinningPot / 1 wei;\n}\n\nfunction WatchLastPayout() constant returns(uint g) {\n    g = Last_Payout;\n}\n\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\n    NumberOfPlayers = d.length;\n}\n\nfunction PlayerInfo(uint s) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (s <= d.length) {\n        Address = d[s].n;\n        Payout = d[s].g / 1 wei;\n        UserPaid=d[s].o;\n    }\n}\n\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\n    QueueSize = d.length - Payout_id;\n}\n\n}",
      "rename_map": {
        "total_multiplier": "a",
        "onlyowner": "b",
        "feeFrac": "c",
        "players": "d",
        "deposit": "e",
        "random": "f",
        "payout": "g",
        "_owner": "h",
        "theRun": "i",
        "result": "j",
        "admin": "k",
        "salt": "l",
        "init": "m",
        "addr": "n",
        "paid": "o",
        "roll": "p",
        "fees": "q",
        "seed": "r",
        "id": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_002",
      "transformed_id": "ss_l2_short_nc_ds_002",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract TokenVault {\n    mapping (address => uint) e;\n\n    function f(address u) constant returns(uint){\n        return e[u];\n    }\n\n    function d() payable{\n        e[msg.sender] += msg.value;\n    }\n\n    function c(){\n\n\n        if( ! (msg.sender.call.value(e[msg.sender])() ) ){\n            throw;\n        }\n        e[msg.sender] = 0;\n    }\n\n    function b(){\n\n\n        uint g = e[msg.sender];\n        e[msg.sender] = 0;\n        if( ! (msg.sender.call.value(g)() ) ){\n            throw;\n        }\n    }\n\n    function a(){\n\n\n        msg.sender.transfer(e[msg.sender]);\n        e[msg.sender] = 0;\n    }\n\n}",
      "rename_map": {
        "withdrawBalanceV3": "a",
        "withdrawBalanceV2": "b",
        "withdrawBalance": "c",
        "addToBalance": "d",
        "userBalance": "e",
        "getBalance": "f",
        "amount": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_003",
      "transformed_id": "ss_l2_short_nc_ds_003",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract VaultOperator {\n    bool public b=false;\n    address public c;\n    address public g;\n\n    function VaultOperator() public{\n        g = msg.sender;\n    }\n\n    function f(address a) public payable{\n        c = a ;\n\n        require(c.call.value(msg.value)(bytes4(h(\"addToBalance()\"))));\n    }\n\n    function d() public{\n        b = true;\n\n\n        require(c.call(bytes4(h(\"withdrawBalance()\"))));\n    }\n\n    function () public payable{\n\n        if (b){\n            b = false;\n                require(c.call(bytes4(h(\"withdrawBalance()\"))));\n        }\n    }\n\n    function e(){\n        suicide(g);\n    }\n\n}",
      "rename_map": {
        "_target_contract": "a",
        "operationActive": "b",
        "target_contract": "c",
        "launch_handler": "d",
        "get_money": "e",
        "deposit": "f",
        "owner": "g",
        "sha3": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_004",
      "transformed_id": "ss_l2_short_nc_ds_004",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Ledger {\n    uint private a=0;\n\n    function c(uint value) returns (bool){\n        a += value;\n\n\n    }\n\n    function b(uint value) returns (bool){\n        require(value + a >= a);\n        a += value;\n    }\n}",
      "rename_map": {
        "sellerBalance": "a",
        "safe_add": "b",
        "add": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_005",
      "transformed_id": "ss_l2_short_nc_ds_005",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract OpenAccess{\n    address private e;\n\n    modifier d {\n        require(msg.sender==e);\n        _;\n    }\n\n    function OpenAccess()\n        public\n    {\n        e = msg.sender;\n    }\n\n\n    function b(address c)\n        public\n    {\n       e = c;\n    }\n\n    function a(address c)\n        public\n        d\n    {\n       e = c;\n    }\n}",
      "rename_map": {
        "changeOwnerV2": "a",
        "changeOwner": "b",
        "_newOwner": "c",
        "onlyowner": "d",
        "owner": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_006",
      "transformed_id": "ss_l2_short_nc_ds_006",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Alice {\n    int public d;\n\n    function c(int a){\n        d = a;\n    }\n\n    function b(int a){\n        d = a;\n    }\n\n    function(){\n        d = 1;\n    }\n}",
      "rename_map": {
        "new_val": "a",
        "setV2": "b",
        "set": "c",
        "val": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_007",
      "transformed_id": "ss_l2_short_nc_ds_007",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.22;\n\ncontract FibonacciBalance {\n\n    address public fibonacciLibrary;\n\n    uint public a;\n\n    uint public i = 3;\n    uint public b;\n\n    bytes4 constant h = bytes4(j(\"setFibonacci(uint256)\"));\n\n\n    constructor(address _fibonacciLibrary) public payable {\n        fibonacciLibrary = _fibonacciLibrary;\n    }\n\n    function e() {\n        b += 1;\n\n\n        require(fibonacciLibrary.delegatecall(h, b));\n        msg.sender.transfer(a * 1 ether);\n    }\n\n\n    function() public {\n        require(fibonacciLibrary.delegatecall(msg.data));\n    }\n}\n\n\ncontract FibonacciLib {\n\n    uint public i;\n    uint public a;\n\n\n    function f(uint g) public {\n        i = g;\n    }\n\n    function c(uint n) public {\n        a = d(n);\n    }\n\n    function d(uint n) internal returns (uint) {\n        if (n == 0) return i;\n        else if (n == 1) return i + 1;\n        else return d(n - 1) + d(n - 2);\n    }\n}",
      "rename_map": {
        "calculatedFibNumber": "a",
        "withdrawalCounter": "b",
        "setFibonacci": "c",
        "fibonacci": "d",
        "withdraw": "e",
        "setStart": "f",
        "_start": "g",
        "fibSig": "h",
        "start": "i",
        "sha3": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_008",
      "transformed_id": "ss_l2_short_nc_ds_008",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\n contract Wallet {\n     uint[] private a;\n     address private b;\n\n     constructor() public {\n         a = new uint[](0);\n         b = msg.sender;\n     }\n\n     function () public payable {\n     }\n\n     function PushBonusCode(uint c) public {\n         a.push(c);\n     }\n\n     function PopBonusCode() public {\n         require(0 <= a.length);\n         a.length--;\n     }\n\n     function UpdateBonusCodeAt(uint c, uint c) public {\n         require(c < a.length);\n         a[c] = c;\n     }\n\n     function Destroy() public {\n         require(msg.sender == b);\n         selfdestruct(msg.sender);\n     }\n }",
      "rename_map": {
        "bonusCodes": "a",
        "owner": "b",
        "idx": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_009",
      "transformed_id": "ss_l2_short_nc_ds_009",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Map {\n     address public b;\n     uint256[] c;\n\n     function e(uint256 d, uint256 value) public {\n         if (c.length <= d) {\n             c.length = d + 1;\n         }\n         c[d] = value;\n     }\n\n     function f(uint256 d) public view returns (uint256) {\n         return c[d];\n     }\n     function a() public{\n       require(msg.sender == b);\n       msg.sender.transfer(address(this).balance);\n     }\n }",
      "rename_map": {
        "withdraw": "a",
        "owner": "b",
        "map": "c",
        "key": "d",
        "set": "e",
        "get": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_010",
      "transformed_id": "ss_l2_short_nc_ds_010",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract MyContract {\n\n    address d;\n\n    function MyContract() public {\n        d = msg.sender;\n    }\n\n    function b(address a, uint c) public {\n        require(tx.origin == d);\n        a.transfer(c);\n    }\n\n}",
      "rename_map": {
        "receiver": "a",
        "sendTo": "b",
        "amount": "c",
        "owner": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_011",
      "transformed_id": "ss_l2_short_nc_ds_011",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.22;\n\n contract Phishable {\n    address public d;\n\n    constructor (address c) {\n        d = c;\n    }\n\n    function () public payable {}\n\n    function a(address b) public {\n        require(tx.origin == d);\n        b.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "withdrawAll": "a",
        "_recipient": "b",
        "_owner": "c",
        "owner": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_012",
      "transformed_id": "ss_l2_short_nc_ds_012",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Proxy {\n\n  address c;\n\n  constructor() public {\n    c = msg.sender;\n  }\n\n  function a(address b, bytes d) public {\n    require(b.delegatecall(d));\n  }\n\n}",
      "rename_map": {
        "forward": "a",
        "callee": "b",
        "owner": "c",
        "_data": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_013",
      "transformed_id": "ss_l2_short_nc_ds_013",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract SimpleDestruct {\n  function a() {\n    selfdestruct(msg.sender);\n  }\n\n}",
      "rename_map": {
        "sudicideAnyone": "a"
      },
      "changes": [
        "Renamed 1 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_014",
      "transformed_id": "ss_l2_short_nc_ds_014",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Wallet {\n     address d;\n\n     mapping(address => uint256) c;\n\n     constructor() public {\n         d = msg.sender;\n     }\n\n     function e() public payable {\n         assert(c[msg.sender] + msg.value > c[msg.sender]);\n         c[msg.sender] += msg.value;\n     }\n\n     function b(uint256 f) public {\n         require(f <= c[msg.sender]);\n         msg.sender.transfer(f);\n         c[msg.sender] -= f;\n     }\n\n     function g() public {\n         msg.sender.transfer(c[msg.sender]);\n     }\n\n\n     function a(address h) public {\n         require(d == msg.sender);\n         h.transfer(this.balance);\n     }\n\n }",
      "rename_map": {
        "migrateTo": "a",
        "withdraw": "b",
        "balances": "c",
        "creator": "d",
        "deposit": "e",
        "amount": "f",
        "refund": "g",
        "to": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_015",
      "transformed_id": "ss_l2_short_nc_ds_015",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Wallet {\n     address e;\n\n     mapping(address => uint256) d;\n\n     function a() public {\n         e = msg.sender;\n     }\n\n     function f() public payable {\n         assert(d[msg.sender] + msg.value > d[msg.sender]);\n         d[msg.sender] += msg.value;\n     }\n\n     function c(uint256 g) public {\n         require(g <= d[msg.sender]);\n         msg.sender.transfer(g);\n         d[msg.sender] -= g;\n     }\n\n\n     function b(address h) public {\n         require(e == msg.sender);\n         h.transfer(this.balance);\n     }\n\n }",
      "rename_map": {
        "initWallet": "a",
        "migrateTo": "b",
        "withdraw": "c",
        "balances": "d",
        "creator": "e",
        "deposit": "f",
        "amount": "g",
        "to": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_016",
      "transformed_id": "ss_l2_short_nc_ds_016",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Wallet {\n     address d;\n\n     mapping(address => uint256) c;\n\n     constructor() public {\n         d = msg.sender;\n     }\n\n     function e() public payable {\n         assert(c[msg.sender] + msg.value > c[msg.sender]);\n         c[msg.sender] += msg.value;\n     }\n\n     function b(uint256 f) public {\n         require(f >= c[msg.sender]);\n         msg.sender.transfer(f);\n         c[msg.sender] -= f;\n     }\n\n\n     function a(address g) public {\n         require(d == msg.sender);\n         g.transfer(this.balance);\n     }\n\n }",
      "rename_map": {
        "migrateTo": "a",
        "withdraw": "b",
        "balances": "c",
        "creator": "d",
        "deposit": "e",
        "amount": "f",
        "to": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_017",
      "transformed_id": "ss_l2_short_nc_ds_017",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PERSONAL_BANK\n{\n    mapping (address=>uint256) public b;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool a;\n\n    function SetMinSum(uint f)\n    public\n    {\n        if(a)revert();\n        MinSum = f;\n    }\n\n    function SetLogFile(address e)\n    public\n    {\n        if(a)revert();\n        Log = LogFile(e);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint g)\n    public\n    payable\n    {\n        if(b[msg.sender]>=MinSum && b[msg.sender]>=g)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                Log.AddMessage(msg.sender,g,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint f,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "balances": "b",
        "_data": "c",
        "_adr": "d",
        "_log": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_018",
      "transformed_id": "ss_l2_short_nc_ds_018",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address d)\n    {\n        TransferLog = Log(d);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    {\n        if(f<=a[msg.sender])\n        {\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address c,uint e,string b)\n    public\n    {\n        LastMsg.Sender = c;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_adr": "c",
        "_log": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_019",
      "transformed_id": "ss_l2_short_nc_ds_019",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ACCURAL_DEPOSIT\n{\n    mapping (address=>uint256) public b;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool a;\n\n    function SetMinSum(uint f)\n    public\n    {\n        if(a)revert();\n        MinSum = f;\n    }\n\n    function SetLogFile(address e)\n    public\n    {\n        if(a)revert();\n        Log = LogFile(e);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint g)\n    public\n    payable\n    {\n        if(b[msg.sender]>=MinSum && b[msg.sender]>=g)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                Log.AddMessage(msg.sender,g,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint f,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "balances": "b",
        "_data": "c",
        "_adr": "d",
        "_log": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_020",
      "transformed_id": "ss_l2_short_nc_ds_020",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PRIVATE_ETH_CELL\n{\n    mapping (address=>uint256) public b;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool a;\n\n    function SetMinSum(uint f)\n    public\n    {\n        require(!a);\n        MinSum = f;\n    }\n\n    function SetLogFile(address e)\n    public\n    {\n        require(!a);\n        Log = LogFile(e);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint g)\n    public\n    payable\n    {\n        if(b[msg.sender]>=MinSum && b[msg.sender]>=g)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                Log.AddMessage(msg.sender,g,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint f,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "balances": "b",
        "_data": "c",
        "_adr": "d",
        "_log": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_021",
      "transformed_id": "ss_l2_short_nc_ds_021",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract BANK_SAFE\n{\n    mapping (address=>uint256) public b;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool a;\n\n    function SetMinSum(uint f)\n    public\n    {\n        if(a)throw;\n        MinSum = f;\n    }\n\n    function SetLogFile(address e)\n    public\n    {\n        if(a)throw;\n        Log = LogFile(e);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint g)\n    public\n    payable\n    {\n        if(b[msg.sender]>=MinSum && b[msg.sender]>=g)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                Log.AddMessage(msg.sender,g,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint f,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "balances": "b",
        "_data": "c",
        "_adr": "d",
        "_log": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_022",
      "transformed_id": "ss_l2_short_nc_ds_022",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address e;\n    address j = msg.sender;\n\n    function c(address m)\n    public\n    d\n    {\n        e = m;\n    }\n\n    function b()\n    public\n    {\n        if(msg.sender==e)\n        {\n            j=e;\n        }\n    }\n\n    modifier d\n    {\n        if(j == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address j = msg.sender;\n    function WithdrawToken(address i, uint256 g,address p)\n    public\n    d\n    {\n        i.call(bytes4(l(\"transfer(address,uint256)\")),p,g);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function a()\n    public\n    {\n        j = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address o,address h,uint f)\n    public\n    d\n    {\n        if(Holders[o]>0)\n        {\n            Holders[o]=0;\n            WithdrawToken(h,f,o);\n        }\n    }\n\n    function WithdrawToHolder(address k, uint n)\n    public\n    d\n    payable\n    {\n        if(Holders[k]>0)\n        {\n            if(k.call.value(n)())\n            {\n                Holders[k]-=n;\n            }\n        }\n    }\n}",
      "rename_map": {
        "initTokenBank": "a",
        "confirmOwner": "b",
        "changeOwner": "c",
        "onlyOwner": "d",
        "newOwner": "e",
        "_amount": "f",
        "amount": "g",
        "_token": "h",
        "token": "i",
        "owner": "j",
        "_addr": "k",
        "sha3": "l",
        "addr": "m",
        "_wei": "n",
        "_to": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_023",
      "transformed_id": "ss_l2_short_nc_ds_023",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract U_BANK\n{\n    function Put(uint a)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        h.balance += msg.value;\n        h.b = a>g?a:g;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint f)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        if( h.balance>=MinSum && h.balance>=f && g>h.b)\n        {\n            if(msg.sender.call.value(f)())\n            {\n                h.balance-=f;\n                LogFile.AddMessage(msg.sender,f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 2 ether;\n\n    function U_BANK(address i) public{\n        LogFile = Log(i);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "a",
        "unlockTime": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g",
        "acc": "h",
        "log": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_024",
      "transformed_id": "ss_l2_short_nc_ds_024",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PrivateDeposit\n{\n    mapping (address => uint) public b;\n\n    uint public MinDeposit = 1 ether;\n    address public d;\n\n    Log TransferLog;\n\n    modifier a() {\n        require(tx.origin == d);\n        _;\n    }\n\n    function PrivateDeposit()\n    {\n        d = msg.sender;\n        TransferLog = new Log();\n    }\n\n    function c(address g) a\n    {\n        TransferLog = Log(g);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            b[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint i)\n    {\n        if(i<=b[msg.sender])\n        {\n            if(msg.sender.call.value(i)())\n            {\n                b[msg.sender]-=i;\n                TransferLog.AddMessage(msg.sender,i,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address f,uint h,string e)\n    public\n    {\n        LastMsg.Sender = f;\n        LastMsg.Time = j;\n        LastMsg.Val = h;\n        LastMsg.Data = e;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "onlyOwner": "a",
        "balances": "b",
        "setLog": "c",
        "owner": "d",
        "_data": "e",
        "_adr": "f",
        "_lib": "g",
        "_val": "h",
        "_am": "i",
        "now": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_025",
      "transformed_id": "ss_l2_short_nc_ds_025",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract W_WALLET\n{\n    function Put(uint a)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        h.balance += msg.value;\n        h.b = a>g?a:g;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint f)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        if( h.balance>=MinSum && h.balance>=f && g>h.b)\n        {\n            if(msg.sender.call.value(f)())\n            {\n                h.balance-=f;\n                LogFile.AddMessage(msg.sender,f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function W_WALLET(address i) public{\n        LogFile = Log(i);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "a",
        "unlockTime": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g",
        "acc": "h",
        "log": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_026",
      "transformed_id": "ss_l2_short_nc_ds_026",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public a;\n\n    Log TransferLog;\n\n    uint public MinDeposit = 1 ether;\n\n    function ETH_VAULT(address d)\n    public\n    {\n        TransferLog = Log(d);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    public\n    payable\n    {\n        if(f<=a[msg.sender])\n        {\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address c,uint e,string b)\n    public\n    {\n        LastMsg.Sender = c;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_adr": "c",
        "_log": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_027",
      "transformed_id": "ss_l2_short_nc_ds_027",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract X_WALLET\n{\n    function Put(uint a)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        h.balance += msg.value;\n        h.b = a>g?a:g;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint f)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        if( h.balance>=MinSum && h.balance>=f && g>h.b)\n        {\n            if(msg.sender.call.value(f)())\n            {\n                h.balance-=f;\n                LogFile.AddMessage(msg.sender,f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function X_WALLET(address i) public{\n        LogFile = Log(i);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "a",
        "unlockTime": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g",
        "acc": "h",
        "log": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_028",
      "transformed_id": "ss_l2_short_nc_ds_028",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ETH_FUND\n{\n    mapping (address => uint) public b;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    uint a;\n\n    function ETH_FUND(address e)\n    public\n    {\n        TransferLog = Log(e);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            b[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            a = block.number;\n        }\n    }\n\n    function CashOut(uint g)\n    public\n    payable\n    {\n        if(g<=b[msg.sender]&&block.number>a)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                TransferLog.AddMessage(msg.sender,g,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint f,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "lastBlock": "a",
        "balances": "b",
        "_data": "c",
        "_adr": "d",
        "_log": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_029",
      "transformed_id": "ss_l2_short_nc_ds_029",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PENNY_BY_PENNY\n{\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool a;\n\n    function SetMinSum(uint g)\n    public\n    {\n        if(a)throw;\n        MinSum = g;\n    }\n\n    function SetLogFile(address f)\n    public\n    {\n        if(a)throw;\n        Log = LogFile(f);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Put(uint c)\n    public\n    payable\n    {\n        var j = Acc[msg.sender];\n        j.balance += msg.value;\n        if(i+c>j.b)j.b=i+c;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint h)\n    public\n    payable\n    {\n        var j = Acc[msg.sender];\n        if( j.balance>=MinSum && j.balance>=h && i>j.b)\n        {\n            if(msg.sender.call.value(h)())\n            {\n                j.balance-=h;\n                Log.AddMessage(msg.sender,h,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address e,uint g,string d)\n    public\n    {\n        LastMsg.Sender = e;\n        LastMsg.Time = i;\n        LastMsg.Val = g;\n        LastMsg.Data = d;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "unlockTime": "b",
        "_lockTime": "c",
        "_data": "d",
        "_adr": "e",
        "_log": "f",
        "_val": "g",
        "_am": "h",
        "now": "i",
        "acc": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_030",
      "transformed_id": "ss_l2_short_nc_ds_030",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract DEP_BANK\n{\n    mapping (address=>uint256) public b;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool a;\n\n    function SetMinSum(uint f)\n    public\n    {\n        if(a)throw;\n        MinSum = f;\n    }\n\n    function SetLogFile(address e)\n    public\n    {\n        if(a)throw;\n        Log = LogFile(e);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint g)\n    public\n    payable\n    {\n        if(b[msg.sender]>=MinSum && b[msg.sender]>=g)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                Log.AddMessage(msg.sender,g,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint f,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "balances": "b",
        "_data": "c",
        "_adr": "d",
        "_log": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_031",
      "transformed_id": "ss_l2_short_nc_ds_031",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address d)\n    {\n        TransferLog = Log(d);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    public\n    payable\n    {\n        if(f<=a[msg.sender])\n        {\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address c,uint e,string b)\n    public\n    {\n        LastMsg.Sender = c;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_adr": "c",
        "_log": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_032",
      "transformed_id": "ss_l2_short_nc_ds_032",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address d)\n    {\n        TransferLog = Log(d);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    {\n        if(f<=a[msg.sender])\n        {\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address c,uint e,string b)\n    public\n    {\n        LastMsg.Sender = c;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_adr": "c",
        "_lib": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_033",
      "transformed_id": "ss_l2_short_nc_ds_033",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function ETH_VAULT(address d)\n    public\n    {\n        TransferLog = Log(d);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    public\n    payable\n    {\n        if(f<=a[msg.sender])\n        {\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address c,uint e,string b)\n    public\n    {\n        LastMsg.Sender = c;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_adr": "c",
        "_log": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_034",
      "transformed_id": "ss_l2_short_nc_ds_034",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract MONEY_BOX\n{\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    Log LogFile;\n\n    bool a;\n\n    function SetMinSum(uint g)\n    public\n    {\n        if(a)throw;\n        MinSum = g;\n    }\n\n    function SetLogFile(address f)\n    public\n    {\n        if(a)throw;\n        LogFile = Log(f);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Put(uint c)\n    public\n    payable\n    {\n        var j = Acc[msg.sender];\n        j.balance += msg.value;\n        if(i+c>j.b)j.b=i+c;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint h)\n    public\n    payable\n    {\n        var j = Acc[msg.sender];\n        if( j.balance>=MinSum && j.balance>=h && i>j.b)\n        {\n            if(msg.sender.call.value(h)())\n            {\n                j.balance-=h;\n                LogFile.AddMessage(msg.sender,h,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address e,uint g,string d)\n    public\n    {\n        LastMsg.Sender = e;\n        LastMsg.Time = i;\n        LastMsg.Val = g;\n        LastMsg.Data = d;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "unlockTime": "b",
        "_lockTime": "c",
        "_data": "d",
        "_adr": "e",
        "_log": "f",
        "_val": "g",
        "_am": "h",
        "now": "i",
        "acc": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_035",
      "transformed_id": "ss_l2_short_nc_ds_035",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract WALLET\n{\n    function Put(uint a)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        h.balance += msg.value;\n        h.b = a>g?a:g;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint f)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        if( h.balance>=MinSum && h.balance>=f && g>h.b)\n        {\n            if(msg.sender.call.value(f)())\n            {\n                h.balance-=f;\n                LogFile.AddMessage(msg.sender,f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function WALLET(address i) public{\n        LogFile = Log(i);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "a",
        "unlockTime": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g",
        "acc": "h",
        "log": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_036",
      "transformed_id": "ss_l2_short_nc_ds_036",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract MY_BANK\n{\n    function Put(uint a)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        h.balance += msg.value;\n        h.b = a>g?a:g;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint f)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        if( h.balance>=MinSum && h.balance>=f && g>h.b)\n        {\n            if(msg.sender.call.value(f)())\n            {\n                h.balance-=f;\n                LogFile.AddMessage(msg.sender,f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function MY_BANK(address i) public{\n        LogFile = Log(i);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "a",
        "unlockTime": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g",
        "acc": "h",
        "log": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_037",
      "transformed_id": "ss_l2_short_nc_ds_037",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract EtherBank{\n    mapping (address => uint) d;\n    function e(address f) constant returns(uint) {\n\t\treturn d[f];\n\t}\n\n\tfunction c() {\n\t\td[msg.sender] += msg.value;\n\t}\n\n\tfunction b() {\n\t\tuint a = d[msg.sender];\n\t\tif (!(msg.sender.call.value(a)())) { throw; }\n\t\td[msg.sender] = 0;\n\t}\n}",
      "rename_map": {
        "amountToWithdraw": "a",
        "withdrawBalance": "b",
        "addToBalance": "c",
        "userBalances": "d",
        "getBalance": "e",
        "user": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_038",
      "transformed_id": "ss_l2_short_nc_ds_038",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\ncontract EtherStore {\n\n    uint256 public b = 1 ether;\n    mapping(address => uint256) public a;\n    mapping(address => uint256) public f;\n\n    function e() public payable {\n        f[msg.sender] += msg.value;\n    }\n\n    function d (uint256 c) public {\n        require(f[msg.sender] >= c);\n\n        require(c <= b);\n\n        require(g >= a[msg.sender] + 1 weeks);\n        require(msg.sender.call.value(c)());\n        f[msg.sender] -= c;\n        a[msg.sender] = g;\n    }\n }",
      "rename_map": {
        "lastWithdrawTime": "a",
        "withdrawalLimit": "b",
        "_weiToWithdraw": "c",
        "withdrawFunds": "d",
        "depositFunds": "e",
        "balances": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_039",
      "transformed_id": "ss_l2_short_nc_ds_039",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract ModifierBank {\n  mapping (address => uint) public e;\n  string constant j = \"Nu Token\";\n\n\n  function h() c a  public{\n    e[msg.sender] += 20;\n  }\n\n\n  modifier a() {\n    require(f(abi.d(\"Nu Token\")) == Bank(msg.sender).a());\n    _;\n  }\n\n  modifier c {\n      require(e[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n    function a() external pure returns(bytes32){\n        return(f(abi.d(\"Nu Token\")));\n    }\n}\n\ncontract g {\n    bool b;\n    function a() external returns(bytes32){\n        if(!b){\n            b = true;\n            ModifierBank(msg.sender).h();\n        }\n        return(f(abi.d(\"Nu Token\")));\n    }\n    function call(address i) public{\n        ModifierBank(i).h();\n    }\n}",
      "rename_map": {
        "supportsToken": "a",
        "hasBeenCalled": "b",
        "hasNoBalance": "c",
        "encodePacked": "d",
        "tokenBalance": "e",
        "keccak256": "f",
        "executor": "g",
        "airDrop": "h",
        "token": "i",
        "name": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_040",
      "transformed_id": "ss_l2_short_nc_ds_040",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract TokenVault {\n\n  mapping(address => uint) public c;\n\n  function e(address g) public payable {\n    c[g] += msg.value;\n  }\n\n  function a(address f) public view returns (uint balance) {\n    return c[f];\n  }\n\n  function b(uint d) public {\n    if(c[msg.sender] >= d) {\n      if(msg.sender.call.value(d)()) {\n        d;\n      }\n      c[msg.sender] -= d;\n    }\n  }\n\n  function() public payable {}\n}",
      "rename_map": {
        "balanceOf": "a",
        "withdraw": "b",
        "balances": "c",
        "_amount": "d",
        "donate": "e",
        "_who": "f",
        "_to": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_041",
      "transformed_id": "ss_l2_short_nc_ds_041",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract BonusVault{\n\n    mapping (address => uint) private d;\n    mapping (address => bool) private e;\n    mapping (address => uint) private f;\n\n    function c(address g) public {\n        uint b = f[g];\n        f[g] = 0;\n        (bool h, ) = g.call.value(b)(\"\");\n        require(h);\n    }\n\n    function a(address g) public {\n        require(!e[g]);\n\n        f[g] += 100;\n        c(g);\n        e[g] = true;\n    }\n}",
      "rename_map": {
        "getFirstWithdrawalBonus": "a",
        "amountToWithdraw": "b",
        "withdrawReward": "c",
        "userBalances": "d",
        "claimedBonus": "e",
        "rewardsForA": "f",
        "recipient": "g",
        "success": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_042",
      "transformed_id": "ss_l2_short_nc_ds_042",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract CrossFunctionVault {\n\n    mapping (address => uint) private c;\n\n    function transfer(address f, uint e) {\n        if (c[msg.sender] >= e) {\n            c[f] += e;\n            c[msg.sender] -= e;\n        }\n    }\n\n    function b() public {\n        uint a = c[msg.sender];\n        (bool d, ) = msg.sender.call.value(a)(\"\");\n        require(d);\n        c[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "amountToWithdraw": "a",
        "withdrawBalance": "b",
        "userBalances": "c",
        "success": "d",
        "amount": "e",
        "to": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_043",
      "transformed_id": "ss_l2_short_nc_ds_043",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract CommunityVault {\n    mapping (address => uint) e;\n    uint balance;\n\n    function a() public {\n        uint c = e[msg.sender];\n        if (c > 0) {\n            balance -= c;\n            bool b = msg.sender.call.value(c)();\n            require (b);\n            e[msg.sender] = 0;\n        }\n    }\n\n    function d() public payable {\n        e[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n}",
      "rename_map": {
        "withdrawAll": "a",
        "callResult": "b",
        "oCredit": "c",
        "deposit": "d",
        "credit": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_044",
      "transformed_id": "ss_l2_short_nc_ds_044",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.5.0;\n\ncontract SimpleVault {\n\n    mapping (address => uint) private c;\n\n    function b() public {\n        uint a = c[msg.sender];\n        (bool d, ) = msg.sender.call.value(a)(\"\");\n        require(d);\n        c[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "amountToWithdraw": "a",
        "withdrawBalance": "b",
        "userBalances": "c",
        "success": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_045",
      "transformed_id": "ss_l2_short_nc_ds_045",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n contract TokenVault {\n     mapping (address => uint) c;\n\n     function d(address u) constant returns(uint){\n         return c[u];\n     }\n\n     function b() payable{\n         c[msg.sender] += msg.value;\n     }\n\n     function a(){\n\n\n         if( ! (msg.sender.call.value(c[msg.sender])() ) ){\n             throw;\n         }\n         c[msg.sender] = 0;\n     }\n }",
      "rename_map": {
        "withdrawBalance": "a",
        "addToBalance": "b",
        "userBalance": "c",
        "getBalance": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_046",
      "transformed_id": "ss_l2_short_nc_ds_046",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.2;\n\ncontract SimpleDAO {\n  mapping (address => uint) public d;\n\n  function e(address g) payable {\n    d[g] += msg.value;\n  }\n\n  function b(uint c) {\n    if (d[msg.sender]>= c) {\n      bool f = msg.sender.call.value(c)();\n      d[msg.sender]-=c;\n    }\n  }\n\n  function a(address g) returns (uint){\n    return d[g];\n  }\n}",
      "rename_map": {
        "queryCredit": "a",
        "withdraw": "b",
        "amount": "c",
        "credit": "d",
        "donate": "e",
        "res": "f",
        "to": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_047",
      "transformed_id": "ss_l2_short_nc_ds_047",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\ncontract Caller {\n    function a(address a) {\n        a.call();\n    }\n}",
      "rename_map": {
        "callAddress": "a"
      },
      "changes": [
        "Renamed 1 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_048",
      "transformed_id": "ss_l2_short_nc_ds_048",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract c{\n    function transfer(address from,address b,address[] d,uint[] v)public returns (bool){\n        require(d.length > 0);\n        bytes4 e=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<d.length;i++){\n            b.call(e,from,d[i],v[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "demo": "c",
        "_tos": "d",
        "id": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_049",
      "transformed_id": "ss_l2_short_nc_ds_049",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address e;\n    address j = msg.sender;\n\n    function c(address m)\n    public\n    d\n    {\n        e = m;\n    }\n\n    function b()\n    public\n    {\n        if(msg.sender==e)\n        {\n            j=e;\n        }\n    }\n\n    modifier d\n    {\n        if(j == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address j = msg.sender;\n    function WithdrawToken(address i, uint256 g,address p)\n    public\n    d\n    {\n        i.call(bytes4(l(\"transfer(address,uint256)\")),p,g);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function a()\n    public\n    {\n        j = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address o,address h,uint f)\n    public\n    d\n    {\n        if(Holders[o]>0)\n        {\n            Holders[o]=0;\n            WithdrawToken(h,f,o);\n        }\n    }\n\n    function WithdrawToHolder(address k, uint n)\n    public\n    d\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[k]>=n)\n            {\n                k.call.value(n);\n                Holders[k]-=n;\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "initTokenBank": "a",
        "confirmOwner": "b",
        "changeOwner": "c",
        "onlyOwner": "d",
        "newOwner": "e",
        "_amount": "f",
        "amount": "g",
        "_token": "h",
        "token": "i",
        "owner": "j",
        "_addr": "k",
        "sha3": "l",
        "addr": "m",
        "_wei": "n",
        "_to": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_050",
      "transformed_id": "ss_l2_short_nc_ds_050",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address e;\n    address j = msg.sender;\n\n    function c(address m)\n    public\n    d\n    {\n        e = m;\n    }\n\n    function b()\n    public\n    {\n        if(msg.sender==e)\n        {\n            j=e;\n        }\n    }\n\n    modifier d\n    {\n        if(j == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address j = msg.sender;\n    function WithdrawToken(address i, uint256 g,address p)\n    public\n    d\n    {\n        i.call(bytes4(l(\"transfer(address,uint256)\")),p,g);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function a()\n    public\n    {\n        j = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address o,address h,uint f)\n    public\n    d\n    {\n        if(Holders[o]>0)\n        {\n            Holders[o]=0;\n            WithdrawToken(h,f,o);\n        }\n    }\n\n    function WithdrawToHolder(address k, uint n)\n    public\n    d\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[k]>=n)\n            {\n                k.call.value(n);\n                Holders[k]-=n;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {
        "initTokenBank": "a",
        "confirmOwner": "b",
        "changeOwner": "c",
        "onlyOwner": "d",
        "newOwner": "e",
        "_amount": "f",
        "amount": "g",
        "_token": "h",
        "token": "i",
        "owner": "j",
        "_addr": "k",
        "sha3": "l",
        "addr": "m",
        "_wei": "n",
        "_to": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_051",
      "transformed_id": "ss_l2_short_nc_ds_051",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract MultiplicatorX4\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function b()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address c,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        c.call.value(msg.value)(data);\n    }\n\n    function a(address c)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            c.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "a",
        "withdraw": "b",
        "adr": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_052",
      "transformed_id": "ss_l2_short_nc_ds_052",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n    uint constant public a = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function c()\n    public\n    payable\n    {\n        if(msg.value>=a)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function b()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address d,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        d.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "minEligibility": "a",
        "withdraw": "b",
        "redeem": "c",
        "adr": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_053",
      "transformed_id": "ss_l2_short_nc_ds_053",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract c{\n\n    function transfer(address from,address b,address[] d,uint v)public returns (bool){\n        require(d.length > 0);\n        bytes4 e=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<d.length;i++){\n            b.call(e,from,d[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "airdrop": "c",
        "_tos": "d",
        "id": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_054",
      "transformed_id": "ss_l2_short_nc_ds_054",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract EBU{\n    address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;\n    address public b = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;\n\n    function transfer(address[] c,uint[] v)public returns (bool){\n        require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\n        require(c.length > 0);\n        bytes4 d=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<c.length;i++){\n            b.call(d,from,c[i],v[i]*1000000000000000000);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "_tos": "c",
        "id": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_055",
      "transformed_id": "ss_l2_short_nc_ds_055",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract c{\n\n    function transfer(address from,address b,address[] d,uint v)public returns (bool){\n        require(d.length > 0);\n        bytes4 e=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<d.length;i++){\n            b.call(e,from,d[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "airPort": "c",
        "_tos": "d",
        "id": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_056",
      "transformed_id": "ss_l2_short_nc_ds_056",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.13;\n\ncontract Centra4 {\n\n\tfunction transfer() returns (bool) {\n\t\taddress a;\n\t\ta = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n\t\taddress d;\n\t\taddress c;\n\t\tuint256 k;\n\t\tk = 1;\n\n\t\tc = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\n\t\ta.call(\"register\", \"CentraToken\");\n\t\tif(!a.call(bytes4(b(\"transfer(address,uint256)\")),c,k)) return false;\n\n\t\treturn true;\n\t}\n\n}",
      "rename_map": {
        "contract_address": "a",
        "keccak256": "b",
        "c2": "c",
        "c1": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_057",
      "transformed_id": "ss_l2_short_nc_ds_057",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Token {\n    function transfer(address k, uint h) returns (bool f);\n    function d(address g) constant returns (uint balance);\n}\ncontract EtherGet {\n    address i;\n    function EtherGet() {\n        i = msg.sender;\n    }\n    function a(address b) public {\n        Token m = Token(b);\n        m.transfer(i, m.d(this));\n    }\n    function c() public {\n        i.transfer(this.balance);\n    }\n    function e(uint l, address j) public {\n        for(uint i = 0; i < l; i++){\n            j.call.value(0 wei)();\n        }\n    }\n}",
      "rename_map": {
        "withdrawTokens": "a",
        "tokenContract": "b",
        "withdrawEther": "c",
        "balanceOf": "d",
        "getTokens": "e",
        "success": "f",
        "_owner": "g",
        "_value": "h",
        "owner": "i",
        "addr": "j",
        "_to": "k",
        "num": "l",
        "tc": "m"
      },
      "changes": [
        "Renamed 13 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_058",
      "transformed_id": "ss_l2_short_nc_ds_058",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract MultiplicatorX3\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function b()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address c,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        c.call.value(msg.value)(data);\n    }\n\n    function a(address c)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            c.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "a",
        "withdraw": "b",
        "adr": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_059",
      "transformed_id": "ss_l2_short_nc_ds_059",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public h = msg.sender;\n    uint public a;\n\n    modifier d {\n        require(msg.sender == h);\n        _;\n    }\n\n    function() public payable {\n        a++;\n    }\n\n    function b() public d {\n        e(address(this).balance);\n    }\n\n    function e(uint g) public d {\n        msg.sender.transfer(g);\n    }\n\n    function c(address f, uint g, bytes i) public d {\n        f.call.value(g)(i);\n    }\n}",
      "rename_map": {
        "depositsCount": "a",
        "withdrawAll": "b",
        "sendMoney": "c",
        "onlyOwner": "d",
        "withdraw": "e",
        "_target": "f",
        "_value": "g",
        "owner": "h",
        "_data": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_060",
      "transformed_id": "ss_l2_short_nc_ds_060",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address e;\n    address j = msg.sender;\n\n    function c(address m)\n    public\n    d\n    {\n        e = m;\n    }\n\n    function b()\n    public\n    {\n        if(msg.sender==e)\n        {\n            j=e;\n        }\n    }\n\n    modifier d\n    {\n        if(j == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address j = msg.sender;\n    function WithdrawToken(address i, uint256 g,address p)\n    public\n    d\n    {\n        i.call(bytes4(l(\"transfer(address,uint256)\")),p,g);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function a()\n    public\n    {\n        j = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address o,address h,uint f)\n    public\n    d\n    {\n        if(Holders[o]>0)\n        {\n            Holders[o]=0;\n            WithdrawToken(h,f,o);\n        }\n    }\n\n    function WithdrawToHolder(address k, uint n)\n    public\n    d\n    payable\n    {\n        if(Holders[k]>0)\n        {\n            if(k.call.value(n)())\n            {\n                Holders[k]-=n;\n            }\n        }\n    }\n}",
      "rename_map": {
        "initTokenBank": "a",
        "confirmOwner": "b",
        "changeOwner": "c",
        "onlyOwner": "d",
        "newOwner": "e",
        "_amount": "f",
        "amount": "g",
        "_token": "h",
        "token": "i",
        "owner": "j",
        "_addr": "k",
        "sha3": "l",
        "addr": "m",
        "_wei": "n",
        "_to": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_061",
      "transformed_id": "ss_l2_short_nc_ds_061",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract HomeyJar {\n    address public Owner = msg.sender;\n\n    function() public payable {}\n\n    function GetHoneyFromJar() public payable {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data) payable public {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_062",
      "transformed_id": "ss_l2_short_nc_ds_062",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n    uint constant public a = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function c()\n    public\n    payable\n    {\n        if(msg.value>=a)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function b()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address d,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        d.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "minEligibility": "a",
        "withdraw": "b",
        "redeem": "c",
        "adr": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_063",
      "transformed_id": "ss_l2_short_nc_ds_063",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_064",
      "transformed_id": "ss_l2_short_nc_ds_064",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetPie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_065",
      "transformed_id": "ss_l2_short_nc_ds_065",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\n\ncontract Owned {\n\n\n    modifier k() {\n        require(msg.sender == s);\n        _;\n    }\n\n    address public s;\n\n\n    function Owned() {\n        s = msg.sender;\n    }\n\n    address public n;\n\n\n    function f(address l) k {\n        n = l;\n    }\n\n\n    function b() {\n        if (msg.sender == n) {\n            s = n;\n        }\n    }\n\n\n    function p(address v, uint r, bytes t) k {\n        v.call.value(r)(t);\n    }\n}\n\n\ncontract WedIndex is Owned {\n\n\n    string public h;\n    string public e;\n    uint public m;\n    uint public g;\n    uint public c;\n\n    IndexArray[] public j;\n\n    struct IndexArray {\n        uint m;\n        string h;\n        string e;\n        uint g;\n        uint c;\n    }\n\n    function d() constant public returns (uint) {\n        return j.length;\n    }\n\n\n    function i(uint m, string h, string e, uint g, uint c) {\n        j.push(IndexArray(w, h, e, g, c));\n        IndexWritten(w, h, e, g, c);\n    }\n\n\n    event IndexWritten (uint u, string a, string o, uint g, uint q);\n}",
      "rename_map": {
        "contractaddress": "a",
        "acceptOwnership": "b",
        "displaymultisig": "c",
        "numberOfIndex": "d",
        "partnernames": "e",
        "changeOwner": "f",
        "weddingdate": "g",
        "wedaddress": "h",
        "writeIndex": "i",
        "indexarray": "j",
        "onlyOwner": "k",
        "_newOwner": "l",
        "indexdate": "m",
        "newOwner": "n",
        "partners": "o",
        "execute": "p",
        "display": "q",
        "_value": "r",
        "owner": "s",
        "_data": "t",
        "time": "u",
        "_dst": "v",
        "now": "w"
      },
      "changes": [
        "Renamed 23 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_066",
      "transformed_id": "ss_l2_short_nc_ds_066",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address e;\n    address j = msg.sender;\n\n    function c(address m)\n    public\n    d\n    {\n        e = m;\n    }\n\n    function b()\n    public\n    {\n        if(msg.sender==e)\n        {\n            j=e;\n        }\n    }\n\n    modifier d\n    {\n        if(j == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address j = msg.sender;\n    function WithdrawToken(address i, uint256 g,address p)\n    public\n    d\n    {\n        i.call(bytes4(l(\"transfer(address,uint256)\")),p,g);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function a()\n    public\n    {\n        j = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>=MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address o,address h,uint f)\n    public\n    d\n    {\n        if(Holders[o]>0)\n        {\n            Holders[o]=0;\n            WithdrawToken(h,f,o);\n        }\n    }\n\n    function WithdrawToHolder(address k, uint n)\n    public\n    d\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[k]>=n)\n            {\n                k.call.value(n);\n                Holders[k]-=n;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {
        "initTokenBank": "a",
        "confirmOwner": "b",
        "changeOwner": "c",
        "onlyOwner": "d",
        "newOwner": "e",
        "_amount": "f",
        "amount": "g",
        "_token": "h",
        "token": "i",
        "owner": "j",
        "_addr": "k",
        "sha3": "l",
        "addr": "m",
        "_wei": "n",
        "_to": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_067",
      "transformed_id": "ss_l2_short_nc_ds_067",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\n\ncontract Delta {\n\n\taddress public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A;\n\taddress public m = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;\n\taddress public k = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;\n\tuint public j = 1;\n\n\tuint public d = 10**18*1/1000;\n\n\n\tfunction() payable {\n\t    e();\n\t}\n\n    function e() payable returns (bool) {\n\n        require(j > 0);\n        require(msg.value >= d);\n\n        uint e = msg.value*10**18/d;\n\n        require(e > 0);\n\n        if(!c.call(bytes4(n(\"transferFrom(address,address,uint256)\")),m, msg.sender,e)){\n        \treturn false;\n        }\n\n        uint o = msg.value * 3 / 10;\n        k.send(o);\n\n        return true;\n      }\n\n\n      function g(uint256 i) f returns (bool l) {\n          uint256 balance;\n          balance = this.balance;\n          if(i > 0) balance = i;\n          m.send(balance);\n          return true;\n      }\n\n\n      function a(uint256 c) f returns (bool l) {\n        d = c;\n        return true;\n      }\n\n\n      function b(uint256 h) f returns (bool l) {\n        j = h;\n        return true;\n      }\n\n\n    \tmodifier f() {\n        if (msg.sender != m) {\n            throw;\n        }\n        _;\n    }\n\n}",
      "rename_map": {
        "change_token_price": "a",
        "change_active": "b",
        "_token_price": "c",
        "token_price": "d",
        "tokens_buy": "e",
        "onlyOwner": "f",
        "withdraw": "g",
        "_active": "h",
        "_amount": "i",
        "active": "j",
        "owner2": "k",
        "result": "l",
        "owner": "m",
        "sha3": "n",
        "sum2": "o"
      },
      "changes": [
        "Renamed 15 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_068",
      "transformed_id": "ss_l2_short_nc_ds_068",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract AirDropContract{\n\n    function AirDropContract() public {\n    }\n\n    modifier b( address d ) {\n        require(d != address(0x0));\n        require(d != address(this));\n        _;\n    }\n\n    function transfer(address a,address[] e,uint[] f)\n        public\n        b(a)\n        returns (bool){\n\n        require(e.length > 0);\n        require(f.length > 0);\n        require(e.length == f.length);\n        bytes4 g = bytes4(c(\"transferFrom(address,address,uint256)\"));\n        for(uint i = 0 ; i < e.length; i++){\n            a.call(g, msg.sender, e[i], f[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "contract_address": "a",
        "validAddress": "b",
        "keccak256": "c",
        "addr": "d",
        "tos": "e",
        "vs": "f",
        "id": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_069",
      "transformed_id": "ss_l2_short_nc_ds_069",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract EBU{\n\n    function transfer(address from,address b,address[] c,uint[] v)public returns (bool){\n        require(c.length > 0);\n        bytes4 d=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<c.length;i++){\n            b.call(d,from,c[i],v[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "_tos": "c",
        "id": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_070",
      "transformed_id": "ss_l2_short_nc_ds_070",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier b { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function a(address e) public b { Owner = e; }\n    function h(address g, bytes data) public payable {\n        g.call.value(msg.value)(data);\n    }\n}\n\ncontract DepositProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            d();\n        }\n    }\n\n    function d() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function c(uint256 f) public b {\n        if (f>0 && Deposits[msg.sender]>=f) {\n            msg.sender.transfer(f);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "a",
        "onlyOwner": "b",
        "withdraw": "c",
        "deposit": "d",
        "_owner": "e",
        "amount": "f",
        "target": "g",
        "proxy": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_071",
      "transformed_id": "ss_l2_short_nc_ds_071",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public h = msg.sender;\n    uint public a;\n\n    modifier d {\n        require(msg.sender == h);\n        _;\n    }\n\n    function() public payable {\n        a++;\n    }\n\n    function b() public d {\n        e(address(this).balance);\n    }\n\n    function e(uint g) public d {\n        msg.sender.transfer(g);\n    }\n\n    function c(address f, uint g) public d {\n        f.call.value(g)();\n    }\n}",
      "rename_map": {
        "depositsCount": "a",
        "withdrawAll": "b",
        "sendMoney": "c",
        "onlyOwner": "d",
        "withdraw": "e",
        "_target": "f",
        "_value": "g",
        "owner": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_072",
      "transformed_id": "ss_l2_short_nc_ds_072",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract a {\n    mapping(address => uint256) public c;\n\n    function () payable public {\n        c[msg.sender] += msg.value;\n    }\n\n    function b() public {\n        msg.sender.call.value(c[msg.sender])();\n        c[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "keepMyEther": "a",
        "withdraw": "b",
        "balances": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_073",
      "transformed_id": "ss_l2_short_nc_ds_073",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract Proxy  {\n    modifier b { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function a(address e) public b { Owner = e; }\n    function h(address g, bytes data) public payable {\n        g.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            d();\n        }\n    }\n\n    function d() public payable {\n        if (msg.value > 0.25 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function c(uint256 f) public b {\n        if (f>0 && Deposits[msg.sender]>=f) {\n            msg.sender.transfer(f);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "a",
        "onlyOwner": "b",
        "withdraw": "c",
        "deposit": "d",
        "_owner": "e",
        "amount": "f",
        "target": "g",
        "proxy": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_074",
      "transformed_id": "ss_l2_short_nc_ds_074",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier b { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function a(address e) public b { Owner = e; }\n    function h(address g, bytes data) public payable {\n        g.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            d();\n        }\n    }\n\n    function d() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function c(uint256 f) public b {\n        if (f>0 && Deposits[msg.sender]>=f) {\n            msg.sender.transfer(f);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "a",
        "onlyOwner": "b",
        "withdraw": "c",
        "deposit": "d",
        "_owner": "e",
        "amount": "f",
        "target": "g",
        "proxy": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_075",
      "transformed_id": "ss_l2_short_nc_ds_075",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function Get()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_076",
      "transformed_id": "ss_l2_short_nc_ds_076",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract c{\n\n    function transfer(address from,address b,address[] d,uint v)public returns (bool){\n        require(d.length > 0);\n        bytes4 e=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<d.length;i++){\n            b.call(e,from,d[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "demo": "c",
        "_tos": "d",
        "id": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_077",
      "transformed_id": "ss_l2_short_nc_ds_077",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract FreeEth\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_078",
      "transformed_id": "ss_l2_short_nc_ds_078",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Honey\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_079",
      "transformed_id": "ss_l2_short_nc_ds_079",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Freebie\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_080",
      "transformed_id": "ss_l2_short_nc_ds_080",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract d{\n\n    function transfer(address from,address c,address[] f,uint v, uint b)public returns (bool){\n        require(f.length > 0);\n        bytes4 g=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        uint e = v * 10 ** b;\n        for(uint i=0;i<f.length;i++){\n            c.call(g,from,f[i],e);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "_decimals": "b",
        "caddress": "c",
        "airDrop": "d",
        "_value": "e",
        "_tos": "f",
        "id": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_081",
      "transformed_id": "ss_l2_short_nc_ds_081",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract RealOldFuckMaker {\n    address b = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;\n\n\n    function a(uint32 number) {\n        uint32 i;\n        for (i = 0; i < number; i++) {\n            b.call(bytes4(c(\"giveBlockReward()\")));\n        }\n    }\n}",
      "rename_map": {
        "makeOldFucks": "a",
        "fuck": "b",
        "sha3": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_082",
      "transformed_id": "ss_l2_short_nc_ds_082",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract B {\n    address public b = msg.sender;\n\n    function c() public payable {\n        address a = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;\n        a.call.value(msg.value)();\n        b.transfer(address(this).balance);\n    }\n\n    function() public payable {\n    }\n}",
      "rename_map": {
        "target": "a",
        "owner": "b",
        "go": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_083",
      "transformed_id": "ss_l2_short_nc_ds_083",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_084",
      "transformed_id": "ss_l2_short_nc_ds_084",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n\n        address q;\n\n\n        string ab;\n\n        uint w;\n\n        uint d;\n    }\n\n\n    address p;\n\n\n    modifier x { if (msg.sender == p) _; }\n\n\n    uint constant g = 100 finney;\n\n\n    uint constant f = 3;\n    uint constant c = 2;\n\n\n    uint constant b = 1;\n    uint constant a = 100;\n\n\n    uint public h;\n\n\n    Monarch public n;\n\n\n    Monarch[] public r;\n\n\n    function KingOfTheEtherThrone() {\n        p = msg.sender;\n        h = g;\n        n = Monarch(\n            p,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function l() constant returns (uint n) {\n        return r.length;\n    }\n\n\n    event ThroneClaimed(\n        address e,\n        string u,\n        uint o\n    );\n\n\n    function() {\n        t(string(msg.data));\n    }\n\n\n    function t(string ab) {\n\n        uint y = msg.value;\n\n\n        if (y < h) {\n            msg.sender.send(y);\n            return;\n        }\n\n\n        if (y > h) {\n            uint v = y - h;\n            msg.sender.send(v);\n            y = y - v;\n        }\n\n\n        uint k = (y * b) / a;\n\n        uint s = y - k;\n\n        if (n.q != p) {\n            n.q.send(s);\n        } else {\n\n        }\n\n\n        r.push(n);\n        n = Monarch(\n            msg.sender,\n            ab,\n            y,\n            block.timestamp\n        );\n\n\n        uint j = h * f / c;\n        if (j < 10 finney) {\n            h = j;\n        } else if (j < 100 finney) {\n            h = 100 szabo * (j / 100 szabo);\n        } else if (j < 1 ether) {\n            h = 1 finney * (j / 1 finney);\n        } else if (j < 10 ether) {\n            h = 10 finney * (j / 10 finney);\n        } else if (j < 100 ether) {\n            h = 100 finney * (j / 100 finney);\n        } else if (j < 1000 ether) {\n            h = 1 ether * (j / 1 ether);\n        } else if (j < 10000 ether) {\n            h = 10 ether * (j / 10 ether);\n        } else {\n            h = j;\n        }\n\n\n        ThroneClaimed(n.q, n.ab, h);\n    }\n\n\n    function m(uint aa) x {\n        p.send(aa);\n    }\n\n\n    function i(address z) x {\n        p = z;\n    }\n\n}",
      "rename_map": {
        "wizardCommissionFractionDen": "a",
        "wizardCommissionFractionNum": "b",
        "claimPriceAdjustDen": "c",
        "coronationTimestamp": "d",
        "usurperEtherAddress": "e",
        "claimPriceAdjustNum": "f",
        "startingClaimPrice": "g",
        "currentClaimPrice": "h",
        "transferOwnership": "i",
        "rawNewClaimPrice": "j",
        "wizardCommission": "k",
        "numberOfMonarchs": "l",
        "sweepCommission": "m",
        "currentMonarch": "n",
        "newClaimPrice": "o",
        "wizardAddress": "p",
        "etherAddress": "q",
        "pastMonarchs": "r",
        "compensation": "s",
        "claimThrone": "t",
        "usurperName": "u",
        "excessPaid": "v",
        "claimPrice": "w",
        "onlywizard": "x",
        "valuePaid": "y",
        "newOwner": "z",
        "amount": "aa",
        "name": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_085",
      "transformed_id": "ss_l2_short_nc_ds_085",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\n contract Lotto {\n\n     bool public d = false;\n     address public e;\n     uint public c;\n\n\n     function b() public {\n         require(!d);\n         e.send(c);\n         d = true;\n     }\n\n     function a() public {\n         require(d);\n         msg.sender.send(this.balance);\n     }\n }",
      "rename_map": {
        "withdrawLeftOver": "a",
        "sendToWinner": "b",
        "winAmount": "c",
        "payedOut": "d",
        "winner": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_086",
      "transformed_id": "ss_l2_short_nc_ds_086",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract SendBack {\n    mapping (address => uint) c;\n    function b() {\n\t\tuint a = c[msg.sender];\n\t\tc[msg.sender] = 0;\n\t\tmsg.sender.send(a);\n\t}\n}",
      "rename_map": {
        "amountToWithdraw": "a",
        "withdrawBalance": "b",
        "userBalances": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_087",
      "transformed_id": "ss_l2_short_nc_ds_087",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function b(address c) public {\n    require(c.call());\n  }\n\n  function a(address c) public {\n    c.call();\n  }\n}",
      "rename_map": {
        "callnotchecked": "a",
        "callchecked": "b",
        "callee": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_113",
      "transformed_id": "ss_l2_short_nc_ds_113",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "contract TokenInterface {\n    mapping (address => uint256) cm;\n    mapping (address => mapping (address => uint256)) da;\n\n\n    uint256 public bp;\n\n\n    function ci(address dl) constant returns (uint256 balance);\n\n\n    function transfer(address ea, uint256 di) returns (bool cz);\n\n\n    function bd(address dv, address ea, uint256 di) returns (bool cz);\n\n\n    function cx(address cr, uint256 di) returns (bool cz);\n\n\n    function cf(\n        address dl,\n        address cr\n    ) constant returns (uint256 ck);\n\n    event Transfer(address indexed dv, address indexed ea, uint256 di);\n    event Approval(\n        address indexed dl,\n        address indexed cr,\n        uint256 di\n    );\n}\n\ncontract Token is TokenInterface {\n\n\n    modifier cy() {if (msg.value > 0) throw; _;}\n\n    function ci(address dl) constant returns (uint256 balance) {\n        return cm[dl];\n    }\n\n    function transfer(address ea, uint256 di) cy returns (bool cz) {\n        if (cm[msg.sender] >= di && di > 0) {\n            cm[msg.sender] -= di;\n            cm[ea] += di;\n            Transfer(msg.sender, ea, di);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function bd(\n        address dv,\n        address ea,\n        uint256 di\n    ) cy returns (bool cz) {\n\n        if (cm[dv] >= di\n            && da[dv][msg.sender] >= di\n            && di > 0) {\n\n            cm[ea] += di;\n            cm[dv] -= di;\n            da[dv][msg.sender] -= di;\n            Transfer(dv, ea, di);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function cx(address cr, uint256 di) returns (bool cz) {\n        da[msg.sender][cr] = di;\n        Approval(msg.sender, cr, di);\n        return true;\n    }\n\n    function cf(address dl, address cr) constant returns (uint256 ck) {\n        return da[dl][cr];\n    }\n}\n\ncontract ManagedAccountInterface {\n\n    address public ds;\n\n    bool public ba;\n\n    uint public z;\n\n\n    function dk(address bw, uint di) returns (bool);\n\n    event PayOut(address indexed bw, uint di);\n}\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n\n    function ManagedAccount(address dl, bool av) {\n        ds = dl;\n        ba = av;\n    }\n\n\n    function() {\n        z += msg.value;\n    }\n\n    function dk(address bw, uint di) returns (bool) {\n        if (msg.sender != ds || msg.value > 0 || (ba && bw != ds))\n            throw;\n        if (bw.call.value(di)()) {\n            PayOut(bw, di);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ncontract TokenCreationInterface {\n\n\n    uint public bn;\n\n\n    uint public t;\n\n    bool public cl;\n\n\n    address public aj;\n\n\n    ManagedAccount public be;\n\n    mapping (address => uint256) cn;\n\n\n    function ac(address ay) returns (bool cz);\n\n\n    function dm();\n\n\n    function de() constant returns (uint de);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed ee, uint do);\n    event Refund(address indexed ee, uint value);\n}\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint p,\n        uint bi,\n        address ag) {\n\n        bn = bi;\n        t = p;\n        aj = ag;\n        be = new ManagedAccount(address(this), true);\n    }\n\n    function ac(address ay) returns (bool cz) {\n        if (ec < bn && msg.value > 0\n            && (aj == 0 || aj == msg.sender)) {\n\n            uint dt = (msg.value * 20) / de();\n            be.call.value(msg.value - dt)();\n            cm[ay] += dt;\n            bp += dt;\n            cn[ay] += msg.value;\n            CreatedToken(ay, dt);\n            if (bp >= t && !cl) {\n                cl = true;\n                FuelingToDate(bp);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function dm() cy {\n        if (ec > bn && !cl) {\n\n            if (be.balance >= be.z())\n                be.dk(address(this), be.z());\n\n\n            if (msg.sender.call.value(cn[msg.sender])()) {\n                Refund(msg.sender, cn[msg.sender]);\n                bp -= cm[msg.sender];\n                cm[msg.sender] = 0;\n                cn[msg.sender] = 0;\n            }\n        }\n    }\n\n    function de() constant returns (uint de) {\n\n\n        if (bn - 2 weeks > ec) {\n            return 20;\n\n        } else if (bn - 4 days > ec) {\n            return (20 + (ec - (bn - 2 weeks)) / (1 days));\n\n        } else {\n            return 30;\n        }\n    }\n}\n\ncontract DAOInterface {\n\n\n    uint constant l = 40 days;\n\n    uint constant c = 2 weeks;\n\n    uint constant i = 1 weeks;\n\n    uint constant h = 27 days;\n\n    uint constant m = 25 weeks;\n\n\n    uint constant d = 10 days;\n\n\n    uint constant q = 100;\n\n\n    Proposal[] public cj;\n\n\n    uint public ab;\n\n    uint  public k;\n\n\n    address public dd;\n\n    mapping (address => bool) public v;\n\n\n    mapping (address => uint) public br;\n\n    uint public af;\n\n\n    ManagedAccount public ax;\n\n\n    ManagedAccount public DAOrewardAccount;\n\n\n    mapping (address => uint) public DAOpaidOut;\n\n\n    mapping (address => uint) public df;\n\n\n    mapping (address => uint) public dg;\n\n\n    uint public am;\n\n\n    uint e;\n\n\n    DAO_Creator public bv;\n\n\n    struct Proposal {\n\n\n        address cc;\n\n        uint do;\n\n        string bl;\n\n        uint ap;\n\n        bool dw;\n\n\n        bool ar;\n\n        bytes32 az;\n\n\n        uint am;\n\n        bool bu;\n\n        SplitData[] cb;\n\n        uint eb;\n\n        uint dz;\n\n        mapping (address => bool) ct;\n\n        mapping (address => bool) db;\n\n        address dh;\n    }\n\n\n    struct SplitData {\n\n        uint bc;\n\n        uint bp;\n\n        uint br;\n\n        DAO dn;\n    }\n\n\n    modifier ah {}\n\n\n    function () returns (bool cz);\n\n\n    function bg() returns(bool);\n\n\n    function bq(\n        address bw,\n        uint di,\n        string bb,\n        bytes y,\n        uint ak,\n        bool bk\n    ) ah returns (uint bo);\n\n\n    function r(\n        uint bo,\n        address bw,\n        uint di,\n        bytes y\n    ) constant returns (bool ao);\n\n\n    function dx(\n        uint bo,\n        bool x\n    ) ah returns (uint cw);\n\n\n    function al(\n        uint bo,\n        bytes y\n    ) returns (bool cu);\n\n\n    function cp(\n        uint bo,\n        address bk\n    ) returns (bool cu);\n\n\n    function bs(address bf);\n\n\n    function b(address bw, bool co) external returns (bool cu);\n\n\n    function g(uint aa) external;\n\n\n    function u(bool ca) external returns (bool cu);\n\n\n    function bj() returns(bool cu);\n\n\n    function w(address cq) internal returns (bool cu);\n\n\n    function f(address ea, uint256 di) returns (bool cz);\n\n\n    function a(\n        address dv,\n        address ea,\n        uint256 di\n    ) returns (bool cz);\n\n\n    function as() returns (bool cu);\n\n\n    function s() constant returns (uint o);\n\n\n    function ae(uint bo) constant returns (address dc);\n\n\n    function cd(address cq) internal returns (bool);\n\n\n    function cg() returns (bool);\n\n    event ProposalAdded(\n        uint indexed by,\n        address cc,\n        uint do,\n        bool bu,\n        string bl\n    );\n    event Voted(uint indexed by, bool cv, address indexed du);\n    event ProposalTallied(uint indexed by, bool dq, uint dj);\n    event NewCurator(address indexed bk);\n    event AllowedRecipientChanged(address indexed bw, bool co);\n}\n\n\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n\n    modifier ah {\n        if (ci(msg.sender) == 0) throw;\n            _;\n    }\n\n    function DAO(\n        address cs,\n        DAO_Creator bm,\n        uint aa,\n        uint p,\n        uint bi,\n        address ag\n    ) TokenCreation(p, bi, ag) {\n\n        dd = cs;\n        bv = bm;\n        am = aa;\n        ax = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(ax) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        k = ec;\n        ab = 5;\n        cj.length = 1;\n\n        v[address(this)] = true;\n        v[dd] = true;\n    }\n\n    function () returns (bool cz) {\n        if (ec < bn + l && msg.sender != address(be))\n            return ac(msg.sender);\n        else\n            return bg();\n    }\n\n    function bg() returns (bool) {\n        return true;\n    }\n\n    function bq(\n        address bw,\n        uint di,\n        string bb,\n        bytes y,\n        uint ak,\n        bool bk\n    ) ah returns (uint bo) {\n\n\n        if (bk && (\n            di != 0\n            || y.length != 0\n            || bw == dd\n            || msg.value > 0\n            || ak < i)) {\n            throw;\n        } else if (\n            !bk\n            && (!n(bw) || (ak <  c))\n        ) {\n            throw;\n        }\n\n        if (ak > 8 weeks)\n            throw;\n\n        if (!cl\n            || ec < bn\n            || (msg.value < am && !bk)) {\n\n            throw;\n        }\n\n        if (ec + ak < ec)\n            throw;\n\n        if (msg.sender == address(this))\n            throw;\n\n        bo = cj.length++;\n        Proposal p = cj[bo];\n        p.cc = bw;\n        p.do = di;\n        p.bl = bb;\n        p.az = dy(bw, di, y);\n        p.ap = ec + ak;\n        p.dw = true;\n\n        p.bu = bk;\n        if (bk)\n            p.cb.length++;\n        p.dh = msg.sender;\n        p.am = msg.value;\n\n        e += msg.value;\n\n        ProposalAdded(\n            bo,\n            bw,\n            di,\n            bk,\n            bb\n        );\n    }\n\n    function r(\n        uint bo,\n        address bw,\n        uint di,\n        bytes y\n    ) cy constant returns (bool ao) {\n        Proposal p = cj[bo];\n        return p.az == dy(bw, di, y);\n    }\n\n    function dx(\n        uint bo,\n        bool x\n    ) ah cy returns (uint cw) {\n\n        Proposal p = cj[bo];\n        if (p.ct[msg.sender]\n            || p.db[msg.sender]\n            || ec >= p.ap) {\n\n            throw;\n        }\n\n        if (x) {\n            p.eb += cm[msg.sender];\n            p.ct[msg.sender] = true;\n        } else {\n            p.dz += cm[msg.sender];\n            p.db[msg.sender] = true;\n        }\n\n        if (dg[msg.sender] == 0) {\n            dg[msg.sender] = bo;\n        } else if (p.ap > cj[dg[msg.sender]].ap) {\n\n\n            dg[msg.sender] = bo;\n        }\n\n        Voted(bo, x, msg.sender);\n    }\n\n    function al(\n        uint bo,\n        bytes y\n    ) cy returns (bool cu) {\n\n        Proposal p = cj[bo];\n\n        uint bz = p.bu\n            ? h\n            : d;\n\n        if (p.dw && ec > p.ap + bz) {\n            at(bo);\n            return;\n        }\n\n\n        if (ec < p.ap\n\n            || !p.dw\n\n            || p.az != dy(p.cc, p.do, y)) {\n\n            throw;\n        }\n\n\n        if (!n(p.cc)) {\n            at(bo);\n            p.dh.send(p.am);\n            return;\n        }\n\n        bool aw = true;\n\n        if (p.do > au())\n            aw = false;\n\n        uint dj = p.eb + p.dz;\n\n\n        if (y.length >= 4 && y[0] == 0x68\n            && y[1] == 0x37 && y[2] == 0xff\n            && y[3] == 0x1e\n            && dj < ch(au() + br[address(this)])) {\n\n                aw = false;\n        }\n\n        if (dj >= ch(p.do)) {\n            if (!p.dh.send(p.am))\n                throw;\n\n            k = ec;\n\n            if (dj > bp / 5)\n                ab = 5;\n        }\n\n\n        if (dj >= ch(p.do) && p.eb > p.dz && aw) {\n            if (!p.cc.call.value(p.do)(y))\n                throw;\n\n            p.ar = true;\n            cu = true;\n\n\n            if (p.cc != address(this) && p.cc != address(ax)\n                && p.cc != address(DAOrewardAccount)\n                && p.cc != address(be)\n                && p.cc != address(dd)) {\n\n                br[address(this)] += p.do;\n                af += p.do;\n            }\n        }\n\n        at(bo);\n\n\n        ProposalTallied(bo, cu, dj);\n    }\n\n    function at(uint bo) internal {\n        Proposal p = cj[bo];\n        if (p.dw)\n            e -= p.am;\n        p.dw = false;\n    }\n\n    function cp(\n        uint bo,\n        address bk\n    ) cy ah returns (bool cu) {\n\n        Proposal p = cj[bo];\n\n\n        if (ec < p.ap\n\n            || ec > p.ap + h\n\n            || p.cc != bk\n\n            || !p.bu\n\n            || !p.ct[msg.sender]\n\n            || (dg[msg.sender] != bo && dg[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n\n        if (address(p.cb[0].dn) == 0) {\n            p.cb[0].dn = bh(bk);\n\n            if (address(p.cb[0].dn) == 0)\n                throw;\n\n            if (this.balance < e)\n                throw;\n            p.cb[0].bc = au();\n            p.cb[0].br = br[address(this)];\n            p.cb[0].bp = bp;\n            p.ar = true;\n        }\n\n\n        uint aq =\n            (cm[msg.sender] * p.cb[0].bc) /\n            p.cb[0].bp;\n        if (p.cb[0].dn.ac.value(aq)(msg.sender) == false)\n            throw;\n\n\n        uint j =\n            (cm[msg.sender] * p.cb[0].br) /\n            p.cb[0].bp;\n\n        uint ad = DAOpaidOut[address(this)] * j /\n            br[address(this)];\n\n        br[address(p.cb[0].dn)] += j;\n        if (br[address(this)] < j)\n            throw;\n        br[address(this)] -= j;\n\n        DAOpaidOut[address(p.cb[0].dn)] += ad;\n        if (DAOpaidOut[address(this)] < ad)\n            throw;\n        DAOpaidOut[address(this)] -= ad;\n\n\n        Transfer(msg.sender, 0, cm[msg.sender]);\n        w(msg.sender);\n        bp -= cm[msg.sender];\n        cm[msg.sender] = 0;\n        df[msg.sender] = 0;\n        return true;\n    }\n\n    function bs(address bf){\n        if (msg.sender != address(this) || !v[bf]) return;\n\n        if (!bf.call.value(address(this).balance)()) {\n            throw;\n        }\n\n\n        br[bf] += br[address(this)];\n        br[address(this)] = 0;\n        DAOpaidOut[bf] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n    function u(bool ca) external cy returns (bool cu) {\n        DAO ed = DAO(msg.sender);\n\n        if ((br[msg.sender] * DAOrewardAccount.z()) /\n            af < DAOpaidOut[msg.sender])\n            throw;\n\n        uint dp =\n            (br[msg.sender] * DAOrewardAccount.z()) /\n            af - DAOpaidOut[msg.sender];\n        if(ca) {\n            if (!DAOrewardAccount.dk(ed.ax(), dp))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.dk(ed, dp))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += dp;\n        return true;\n    }\n\n    function bj() cy returns (bool cu) {\n        return w(msg.sender);\n    }\n\n    function w(address cq) cy internal returns (bool cu) {\n        if ((ci(cq) * ax.z()) / bp < df[cq])\n            throw;\n\n        uint dp =\n            (ci(cq) * ax.z()) / bp - df[cq];\n        if (!ax.dk(cq, dp))\n            throw;\n        df[cq] += dp;\n        return true;\n    }\n\n    function transfer(address ea, uint256 dr) returns (bool cz) {\n        if (cl\n            && ec > bn\n            && !cd(msg.sender)\n            && ai(msg.sender, ea, dr)\n            && super.transfer(ea, dr)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n    function f(address ea, uint256 dr) returns (bool cz) {\n        if (!bj())\n            throw;\n        return transfer(ea, dr);\n    }\n\n    function bd(address dv, address ea, uint256 dr) returns (bool cz) {\n        if (cl\n            && ec > bn\n            && !cd(dv)\n            && ai(dv, ea, dr)\n            && super.bd(dv, ea, dr)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n    function a(\n        address dv,\n        address ea,\n        uint256 dr\n    ) returns (bool cz) {\n\n        if (!w(dv))\n            throw;\n        return bd(dv, ea, dr);\n    }\n\n    function ai(\n        address dv,\n        address ea,\n        uint256 dr\n    ) internal returns (bool cz) {\n\n        uint ai = df[dv] * dr / ci(dv);\n        if (ai > df[dv])\n            throw;\n        df[dv] -= ai;\n        df[ea] += ai;\n        return true;\n    }\n\n    function g(uint aa) cy external {\n        if (msg.sender != address(this) || aa > (au() + br[address(this)])\n            / q) {\n\n            throw;\n        }\n        am = aa;\n    }\n\n    function b(address bw, bool co) cy external returns (bool cu) {\n        if (msg.sender != dd)\n            throw;\n        v[bw] = co;\n        AllowedRecipientChanged(bw, co);\n        return true;\n    }\n\n    function n(address bw) internal returns (bool bt) {\n        if (v[bw]\n            || (bw == address(be)\n\n\n                && af > be.z()))\n            return true;\n        else\n            return false;\n    }\n\n    function au() constant returns (uint an) {\n        return this.balance - e;\n    }\n\n    function ch(uint dr) internal constant returns (uint bx) {\n\n        return bp / ab +\n            (dr * bp) / (3 * (au() + br[address(this)]));\n    }\n\n    function as() returns (bool cu) {\n\n\n        if ((k < (ec - m) || msg.sender == dd)\n            && k < (ec - c)) {\n            k = ec;\n            ab *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function bh(address bk) internal returns (DAO dc) {\n        NewCurator(bk);\n        return bv.ce(bk, 0, 0, ec + h);\n    }\n\n    function s() constant returns (uint o) {\n\n        return cj.length - 1;\n    }\n\n    function ae(uint bo) constant returns (address dc) {\n        return cj[bo].cb[0].dn;\n    }\n\n    function cd(address cq) internal returns (bool) {\n        if (dg[cq] == 0)\n            return false;\n        Proposal p = cj[dg[cq]];\n        if (ec > p.ap) {\n            dg[cq] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function cg() returns (bool) {\n        return cd(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function ce(\n        address cs,\n        uint aa,\n        uint p,\n        uint bi\n    ) returns (DAO dc) {\n\n        return new DAO(\n            cs,\n            DAO_Creator(this),\n            aa,\n            p,\n            bi,\n            msg.sender\n        );\n    }\n}",
      "rename_map": {
        "transferFromWithoutReward": "a",
        "changeAllowedRecipients": "b",
        "minProposalDebatePeriod": "c",
        "executeProposalPeriod": "d",
        "sumOfProposalDeposits": "e",
        "transferWithoutReward": "f",
        "changeProposalDeposit": "g",
        "splitExecutionPeriod": "h",
        "minSplitDebatePeriod": "i",
        "rewardTokenToBeMoved": "j",
        "lastTimeMinQuorumMet": "k",
        "creationGracePeriod": "l",
        "quorumHalvingPeriod": "m",
        "isRecipientAllowed": "n",
        "_numberOfProposals": "o",
        "_minTokensToCreate": "p",
        "maxDepositDivisor": "q",
        "checkProposalCode": "r",
        "numberOfProposals": "s",
        "minTokensToCreate": "t",
        "retrieveDAOReward": "u",
        "allowedRecipients": "v",
        "withdrawRewardFor": "w",
        "_supportsProposal": "x",
        "_transactionData": "y",
        "accumulatedInput": "z",
        "_proposalDeposit": "aa",
        "minQuorumDivisor": "ab",
        "createTokenProxy": "ac",
        "paidOutToBeMoved": "ad",
        "getNewDAOAddress": "ae",
        "totalRewardToken": "af",
        "_privateCreation": "ag",
        "onlyTokenholders": "ah",
        "transferPaidOut": "ai",
        "privateCreation": "aj",
        "_debatingPeriod": "ak",
        "executeProposal": "al",
        "proposalDeposit": "am",
        "_actualBalance": "an",
        "_codeChecksOut": "ao",
        "votingDeadline": "ap",
        "fundsToBeMoved": "aq",
        "proposalPassed": "ar",
        "halveMinQuorum": "as",
        "closeProposal": "at",
        "actualBalance": "au",
        "_payOwnerOnly": "av",
        "proposalCheck": "aw",
        "rewardAccount": "ax",
        "_tokenHolder": "ay",
        "proposalHash": "az",
        "payOwnerOnly": "ba",
        "_description": "bb",
        "splitBalance": "bc",
        "transferFrom": "bd",
        "extraBalance": "be",
        "_newContract": "bf",
        "receiveEther": "bg",
        "createNewDAO": "bh",
        "_closingTime": "bi",
        "getMyReward": "bj",
        "_newCurator": "bk",
        "description": "bl",
        "_daoCreator": "bm",
        "closingTime": "bn",
        "_proposalID": "bo",
        "totalSupply": "bp",
        "newProposal": "bq",
        "rewardToken": "br",
        "newContract": "bs",
        "_isAllowed": "bt",
        "newCurator": "bu",
        "daoCreator": "bv",
        "_recipient": "bw",
        "_minQuorum": "bx",
        "proposalID": "by",
        "waitPeriod": "bz",
        "_toMembers": "ca",
        "splitData": "cb",
        "recipient": "cc",
        "isBlocked": "cd",
        "createDAO": "ce",
        "allowance": "cf",
        "unblockMe": "cg",
        "minQuorum": "ch",
        "balanceOf": "ci",
        "proposals": "cj",
        "remaining": "ck",
        "isFueled": "cl",
        "balances": "cm",
        "weiGiven": "cn",
        "_allowed": "co",
        "splitDAO": "cp",
        "_account": "cq",
        "_spender": "cr",
        "_curator": "cs",
        "votedYes": "ct",
        "_success": "cu",
        "position": "cv",
        "_voteID": "cw",
        "approve": "cx",
        "noEther": "cy",
        "success": "cz",
        "allowed": "da",
        "votedNo": "db",
        "_newDAO": "dc",
        "curator": "dd",
        "divisor": "de",
        "paidOut": "df",
        "blocked": "dg",
        "creator": "dh",
        "_amount": "di",
        "quorum": "dj",
        "payOut": "dk",
        "_owner": "dl",
        "refund": "dm",
        "newDAO": "dn",
        "amount": "do",
        "reward": "dp",
        "result": "dq",
        "_value": "dr",
        "owner": "ds",
        "token": "dt",
        "voter": "du",
        "_from": "dv",
        "open": "dw",
        "vote": "dx",
        "sha3": "dy",
        "nay": "dz",
        "_to": "ea",
        "yea": "eb",
        "now": "ec",
        "dao": "ed",
        "to": "ee"
      },
      "changes": [
        "Renamed 135 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_114",
      "transformed_id": "ss_l2_short_nc_ds_114",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\n\ncontract Token {\n\n    uint256 public as;\n\n\n    function bs(address dc) public constant returns (uint256 balance);\n\n\n    function transfer(address eg, uint256 dj) public returns (bool cm);\n\n\n    function ai(address dw, address eg, uint256 dj) public returns (bool cm);\n\n\n    function ck(address cd, uint256 dj) public returns (bool cm);\n\n\n    function bp(address dc, address cd) public constant returns (uint256 bx);\n\n    event Transfer(address indexed dw, address indexed eg, uint256 dj);\n    event Approval(address indexed dc, address indexed cd, uint256 dj);\n}\n\nlibrary ECTools {\n\n\n    function ae(bytes32 bf, string ed) public pure returns (address) {\n        require(bf != 0x00);\n\n\n        bytes memory cz = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 ah = bm(abi.ag(cz, bf));\n\n        if (bytes(ed).length != 132) {\n            return 0x0;\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        bytes memory sig = y(bj(ed, 2, 132));\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27) {\n            v += 27;\n        }\n        if (v < 27 || v > 28) {\n            return 0x0;\n        }\n        return bv(ah, v, r, s);\n    }\n\n\n    function bb(bytes32 bf, string ed, address ds) public pure returns (bool) {\n        require(ds != 0x0);\n\n        return ds == ae(bf, ed);\n    }\n\n\n    function y(string ci) public pure returns (bytes) {\n        uint eh = bytes(ci).length;\n        require(eh % 2 == 0);\n\n        bytes memory dy = bytes(new string(eh / 2));\n        uint k = 0;\n        string memory s;\n        string memory r;\n        for (uint i = 0; i < eh; i += 2) {\n            s = bj(ci, i, i + 1);\n            r = bj(ci, i + 1, i + 2);\n            uint p = q(s) * 16 + q(r);\n            dy[k++] = u(p)[31];\n        }\n        return dy;\n    }\n\n\n    function q(string dp) public pure returns (uint) {\n        bytes memory cr = bytes(dp);\n\n        if ((cr[0] >= 48) && (cr[0] <= 57)) {\n            return uint(cr[0]) - 48;\n        } else if ((cr[0] >= 65) && (cr[0] <= 70)) {\n            return uint(cr[0]) - 55;\n        } else if ((cr[0] >= 97) && (cr[0] <= 102)) {\n            return uint(cr[0]) - 87;\n        } else {\n            revert();\n        }\n    }\n\n\n    function u(uint dm) public pure returns (bytes b) {\n        b = new bytes(32);\n        assembly {mstore(add(b, 32), dm)}\n    }\n\n\n    function c(string ef) public pure returns (bytes32) {\n        uint eh = bytes(ef).length;\n        require(eh > 0);\n        bytes memory cz = \"\\x19Ethereum Signed Message:\\n\";\n        return bm(abi.ag(cz, al(eh), ef));\n    }\n\n\n    function al(uint dm) public pure returns (string ei) {\n        uint eh = 0;\n        uint m = dm + 0;\n        while (m != 0) {\n            eh++;\n            m /= 10;\n        }\n        bytes memory b = new bytes(eh);\n        uint i = eh - 1;\n        while (dm != 0) {\n            uint bn = dm % 10;\n            dm = dm / 10;\n            b[i--] = byte(48 + bn);\n        }\n        ei = string(b);\n    }\n\n\n    function bj(string dz, uint ay, uint by) public pure returns (string) {\n        bytes memory cb = bytes(dz);\n        require(ay <= by);\n        require(ay >= 0);\n        require(by <= cb.length);\n\n        bytes memory dg = new bytes(by - ay);\n        for (uint i = ay; i < by; i++) {\n            dg[i - ay] = cb[i];\n        }\n        return string(dg);\n    }\n}\ncontract StandardToken is Token {\n\n    function transfer(address eg, uint256 dj) public returns (bool cm) {\n\n\n        require(cc[msg.sender] >= dj);\n        cc[msg.sender] -= dj;\n        cc[eg] += dj;\n        emit Transfer(msg.sender, eg, dj);\n        return true;\n    }\n\n    function ai(address dw, address eg, uint256 dj) public returns (bool cm) {\n\n\n        require(cc[dw] >= dj && cp[dw][msg.sender] >= dj);\n        cc[eg] += dj;\n        cc[dw] -= dj;\n        cp[dw][msg.sender] -= dj;\n        emit Transfer(dw, eg, dj);\n        return true;\n    }\n\n    function bs(address dc) public constant returns (uint256 balance) {\n        return cc[dc];\n    }\n\n    function ck(address cd, uint256 dj) public returns (bool cm) {\n        cp[msg.sender][cd] = dj;\n        emit Approval(msg.sender, cd, dj);\n        return true;\n    }\n\n    function bp(address dc, address cd) public constant returns (uint256 bx) {\n      return cp[dc][cd];\n    }\n\n    mapping (address => uint256) cc;\n    mapping (address => mapping (address => uint256)) cp;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n\n    string public dx;\n    uint8 public ce;\n    string public cy;\n    string public cj = 'H0.1';\n\n    constructor(\n        uint256 t,\n        string bh,\n        uint8 z,\n        string ak\n        ) public {\n        cc[msg.sender] = t;\n        as = t;\n        dx = bh;\n        ce = z;\n        cy = ak;\n    }\n\n\n    function o(address cd, uint256 dj, bytes az) public returns (bool cm) {\n        cp[msg.sender][cd] = dj;\n        emit Approval(msg.sender, cd, dj);\n\n\n        require(cd.call(bytes4(bytes32(bm(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, dj, this, az));\n        return true;\n    }\n}\n\ncontract LedgerChannel {\n\n    string public constant NAME = \"Ledger Channel\";\n    string public constant VERSION = \"0.0.1\";\n\n    uint256 public ax = 0;\n\n    event DidLCOpen (\n        bytes32 indexed bk,\n        address indexed cx,\n        address indexed cw,\n        uint256 au,\n        address dl,\n        uint256 ac,\n        uint256 LCopenTimeout\n    );\n\n    event DidLCJoin (\n        bytes32 indexed bk,\n        uint256 ar,\n        uint256 v\n    );\n\n    event DidLCDeposit (\n        bytes32 indexed bk,\n        address indexed bi,\n        uint256 cq,\n        bool ct\n    );\n\n    event DidLCUpdateState (\n        bytes32 indexed bk,\n        uint256 cf,\n        uint256 bt,\n        uint256 au,\n        uint256 ac,\n        uint256 ar,\n        uint256 v,\n        bytes32 di,\n        uint256 l\n    );\n\n    event DidLCClose (\n        bytes32 indexed bk,\n        uint256 cf,\n        uint256 au,\n        uint256 ac,\n        uint256 ar,\n        uint256 v\n    );\n\n    event DidVCInit (\n        bytes32 indexed ee,\n        bytes32 indexed eb,\n        bytes dv,\n        uint256 cf,\n        address cx,\n        address db,\n        uint256 cg,\n        uint256 ca\n    );\n\n    event DidVCSettle (\n        bytes32 indexed ee,\n        bytes32 indexed eb,\n        uint256 bw,\n        uint256 ba,\n        uint256 bg,\n        address bc,\n        uint256 k\n    );\n\n    event DidVCClose(\n        bytes32 indexed ee,\n        bytes32 indexed eb,\n        uint256 cg,\n        uint256 ca\n    );\n\n    struct Channel {\n\n        address[2] p;\n        uint256[4] ao;\n        uint256[4] ab;\n        uint256[2] s;\n        uint256 cf;\n        uint256 aq;\n        bytes32 VCrootHash;\n        uint256 LCopenTimeout;\n        uint256 l;\n        bool dh;\n        bool h;\n        uint256 br;\n        HumanStandardToken dl;\n    }\n\n\n    struct VirtualChannel {\n        bool cs;\n        bool f;\n        uint256 cf;\n        address bc;\n        uint256 k;\n\n        address cx;\n        address db;\n        address cw;\n        uint256[2] ao;\n        uint256[2] ab;\n        uint256[2] ec;\n        HumanStandardToken dl;\n    }\n\n    mapping(bytes32 => VirtualChannel) public n;\n    mapping(bytes32 => Channel) public Channels;\n\n    function ad(\n        bytes32 dn,\n        address cl,\n        uint256 an,\n        address da,\n        uint256[2] bq\n    )\n        public\n        payable\n    {\n        require(Channels[dn].p[0] == address(0), \"Channel has already been created.\");\n        require(cl != 0x0, \"No partyI address provided to LC creation\");\n        require(bq[0] >= 0 && bq[1] >= 0, \"Balances cannot be negative\");\n\n\n        Channels[dn].p[0] = msg.sender;\n        Channels[dn].p[1] = cl;\n\n        if(bq[0] != 0) {\n            require(msg.value == bq[0], \"Eth balance does not match sent value\");\n            Channels[dn].ao[0] = msg.value;\n        }\n        if(bq[1] != 0) {\n            Channels[dn].dl = HumanStandardToken(da);\n            require(Channels[dn].dl.ai(msg.sender, this, bq[1]),\"CreateChannel: token transfer failure\");\n            Channels[dn].ab[0] = bq[1];\n        }\n\n        Channels[dn].cf = 0;\n        Channels[dn].aq = an;\n\n\n        Channels[dn].LCopenTimeout = ej + an;\n        Channels[dn].s = bq;\n\n        emit DidLCOpen(dn, msg.sender, cl, bq[0], da, bq[1], Channels[dn].LCopenTimeout);\n    }\n\n    function LCOpenTimeout(bytes32 dn) public {\n        require(msg.sender == Channels[dn].p[0] && Channels[dn].dh == false);\n        require(ej > Channels[dn].LCopenTimeout);\n\n        if(Channels[dn].s[0] != 0) {\n            Channels[dn].p[0].transfer(Channels[dn].ao[0]);\n        }\n        if(Channels[dn].s[1] != 0) {\n            require(Channels[dn].dl.transfer(Channels[dn].p[0], Channels[dn].ab[0]),\"CreateChannel: token transfer failure\");\n        }\n\n        emit DidLCClose(dn, 0, Channels[dn].ao[0], Channels[dn].ab[0], 0, 0);\n\n\n        delete Channels[dn];\n    }\n\n    function aw(bytes32 dn, uint256[2] bq) public payable {\n\n        require(Channels[dn].dh == false);\n        require(msg.sender == Channels[dn].p[1]);\n\n        if(bq[0] != 0) {\n            require(msg.value == bq[0], \"state balance does not match sent value\");\n            Channels[dn].ao[1] = msg.value;\n        }\n        if(bq[1] != 0) {\n            require(Channels[dn].dl.ai(msg.sender, this, bq[1]),\"joinChannel: token transfer failure\");\n            Channels[dn].ab[1] = bq[1];\n        }\n\n        Channels[dn].s[0]+=bq[0];\n        Channels[dn].s[1]+=bq[1];\n\n        Channels[dn].dh = true;\n        ax++;\n\n        emit DidLCJoin(dn, bq[0], bq[1]);\n    }\n\n\n    function cq(bytes32 dn, address bi, uint256 bz, bool ct) public payable {\n        require(Channels[dn].dh == true, \"Tried adding funds to a closed channel\");\n        require(bi == Channels[dn].p[0] || bi == Channels[dn].p[1]);\n\n\n        if (Channels[dn].p[0] == bi) {\n            if(ct) {\n                require(Channels[dn].dl.ai(msg.sender, this, bz),\"deposit: token transfer failure\");\n                Channels[dn].ab[2] += bz;\n            } else {\n                require(msg.value == bz, \"state balance does not match sent value\");\n                Channels[dn].ao[2] += msg.value;\n            }\n        }\n\n        if (Channels[dn].p[1] == bi) {\n            if(ct) {\n                require(Channels[dn].dl.ai(msg.sender, this, bz),\"deposit: token transfer failure\");\n                Channels[dn].ab[3] += bz;\n            } else {\n                require(msg.value == bz, \"state balance does not match sent value\");\n                Channels[dn].ao[3] += msg.value;\n            }\n        }\n\n        emit DidLCDeposit(dn, bi, bz, ct);\n    }\n\n\n    function e(\n        bytes32 dn,\n        uint256 bu,\n        uint256[4] bq,\n        string dt,\n        string dr\n    )\n        public\n    {\n\n\n        require(Channels[dn].dh == true);\n        uint256 m = Channels[dn].s[0] + Channels[dn].ao[2] + Channels[dn].ao[3];\n        uint256 i = Channels[dn].s[1] + Channels[dn].ab[2] + Channels[dn].ab[3];\n        require(m == bq[0] + bq[1]);\n        require(i == bq[2] + bq[3]);\n\n        bytes32 dd = bm(\n            abi.ag(\n                dn,\n                true,\n                bu,\n                uint256(0),\n                bytes32(0x0),\n                Channels[dn].p[0],\n                Channels[dn].p[1],\n                bq[0],\n                bq[1],\n                bq[2],\n                bq[3]\n            )\n        );\n\n        require(Channels[dn].p[0] == ECTools.ae(dd, dt));\n        require(Channels[dn].p[1] == ECTools.ae(dd, dr));\n\n        Channels[dn].dh = false;\n\n        if(bq[0] != 0 || bq[1] != 0) {\n            Channels[dn].p[0].transfer(bq[0]);\n            Channels[dn].p[1].transfer(bq[1]);\n        }\n\n        if(bq[2] != 0 || bq[3] != 0) {\n            require(Channels[dn].dl.transfer(Channels[dn].p[0], bq[2]),\"happyCloseChannel: token transfer failure\");\n            require(Channels[dn].dl.transfer(Channels[dn].p[1], bq[3]),\"happyCloseChannel: token transfer failure\");\n        }\n\n        ax--;\n\n        emit DidLCClose(dn, bu, bq[0], bq[1], bq[2], bq[3]);\n    }\n\n\n    function aa(\n        bytes32 dn,\n        uint256[6] aj,\n        bytes32 cu,\n        string dt,\n        string dr\n    )\n        public\n    {\n        Channel storage co = Channels[dn];\n        require(co.dh);\n        require(co.cf < aj[0]);\n        require(co.ao[0] + co.ao[1] >= aj[2] + aj[3]);\n        require(co.ab[0] + co.ab[1] >= aj[4] + aj[5]);\n\n        if(co.h == true) {\n            require(co.l > ej);\n        }\n\n        bytes32 dd = bm(\n            abi.ag(\n                dn,\n                false,\n                aj[0],\n                aj[1],\n                cu,\n                co.p[0],\n                co.p[1],\n                aj[2],\n                aj[3],\n                aj[4],\n                aj[5]\n            )\n        );\n\n        require(co.p[0] == ECTools.ae(dd, dt));\n        require(co.p[1] == ECTools.ae(dd, dr));\n\n\n        co.cf = aj[0];\n        co.br = aj[1];\n        co.ao[0] = aj[2];\n        co.ao[1] = aj[3];\n        co.ab[0] = aj[4];\n        co.ab[1] = aj[5];\n        co.VCrootHash = cu;\n        co.h = true;\n        co.l = ej + co.aq;\n\n\n        emit DidLCUpdateState (\n            dn,\n            aj[0],\n            aj[1],\n            aj[2],\n            aj[3],\n            aj[4],\n            aj[5],\n            cu,\n            co.l\n        );\n    }\n\n\n    function at(\n        bytes32 dn,\n        bytes32 du,\n        bytes de,\n        address cn,\n        address cv,\n        uint256[2] dk,\n        uint256[4] bq,\n        string ea\n    )\n        public\n    {\n        require(Channels[dn].dh, \"LC is closed.\");\n\n        require(!n[du].cs, \"VC is closed.\");\n\n        require(Channels[dn].l < ej, \"LC timeout not over.\");\n\n        require(n[du].k == 0);\n\n        bytes32 be = bm(\n            abi.ag(du, uint256(0), cn, cv, dk[0], dk[1], bq[0], bq[1], bq[2], bq[3])\n        );\n\n\n        require(cn == ECTools.ae(be, ea));\n\n\n        require(af(be, de, Channels[dn].VCrootHash) == true);\n\n        n[du].cx = cn;\n        n[du].db = cv;\n        n[du].cf = uint256(0);\n        n[du].ao[0] = bq[0];\n        n[du].ao[1] = bq[1];\n        n[du].ab[0] = bq[2];\n        n[du].ab[1] = bq[3];\n        n[du].ec = dk;\n        n[du].k = ej + Channels[dn].aq;\n        n[du].f = true;\n\n        emit DidVCInit(dn, du, de, uint256(0), cn, cv, bq[0], bq[1]);\n    }\n\n\n    function ch(\n        bytes32 dn,\n        bytes32 du,\n        uint256 bw,\n        address cn,\n        address cv,\n        uint256[4] bo,\n        string ea\n    )\n        public\n    {\n        require(Channels[dn].dh, \"LC is closed.\");\n\n        require(!n[du].cs, \"VC is closed.\");\n        require(n[du].cf < bw, \"VC sequence is higher than update sequence.\");\n        require(\n            n[du].ao[1] < bo[1] && n[du].ab[1] < bo[3],\n            \"State updates may only increase recipient balance.\"\n        );\n        require(\n            n[du].ec[0] == bo[0] + bo[1] &&\n            n[du].ec[1] == bo[2] + bo[3],\n            \"Incorrect balances for bonded amount\");\n\n\n        require(Channels[dn].l < ej);\n\n        bytes32 am = bm(\n            abi.ag(\n                du,\n                bw,\n                cn,\n                cv,\n                n[du].ec[0],\n                n[du].ec[1],\n                bo[0],\n                bo[1],\n                bo[2],\n                bo[3]\n            )\n        );\n\n\n        require(n[du].cx == ECTools.ae(am, ea));\n\n\n        n[du].bc = msg.sender;\n        n[du].cf = bw;\n\n\n        n[du].ao[0] = bo[0];\n        n[du].ao[1] = bo[1];\n        n[du].ab[0] = bo[2];\n        n[du].ab[1] = bo[3];\n\n        n[du].k = ej + Channels[dn].aq;\n\n        emit DidVCSettle(dn, du, bw, bo[0], bo[1], msg.sender, n[du].k);\n    }\n\n    function g(bytes32 dn, bytes32 du) public {\n\n        require(Channels[dn].dh, \"LC is closed.\");\n        require(n[du].f, \"VC is not in settlement state.\");\n        require(n[du].k < ej, \"Update vc timeout has not elapsed.\");\n        require(!n[du].cs, \"VC is already closed\");\n\n        Channels[dn].br--;\n\n        n[du].cs = true;\n\n\n        if(n[du].cx == Channels[dn].p[0]) {\n            Channels[dn].ao[0] += n[du].ao[0];\n            Channels[dn].ao[1] += n[du].ao[1];\n\n            Channels[dn].ab[0] += n[du].ab[0];\n            Channels[dn].ab[1] += n[du].ab[1];\n        } else if (n[du].db == Channels[dn].p[0]) {\n            Channels[dn].ao[0] += n[du].ao[1];\n            Channels[dn].ao[1] += n[du].ao[0];\n\n            Channels[dn].ab[0] += n[du].ab[1];\n            Channels[dn].ab[1] += n[du].ab[0];\n        }\n\n        emit DidVCClose(dn, du, n[du].ab[0], n[du].ab[1]);\n    }\n\n\n    function d(bytes32 dn) public {\n        Channel storage co = Channels[dn];\n\n\n        require(co.dh, \"Channel is not open\");\n        require(co.h == true);\n        require(co.br == 0);\n        require(co.l < ej, \"LC timeout over.\");\n\n\n        uint256 m = co.s[0] + co.ao[2] + co.ao[3];\n        uint256 i = co.s[1] + co.ab[2] + co.ab[3];\n\n        uint256 b = co.ao[0] + co.ao[1];\n        uint256 a = co.ab[0] + co.ab[1];\n\n        if(b < m) {\n            co.ao[0]+=co.ao[2];\n            co.ao[1]+=co.ao[3];\n        } else {\n            require(b == m);\n        }\n\n        if(a < i) {\n            co.ab[0]+=co.ab[2];\n            co.ab[1]+=co.ab[3];\n        } else {\n            require(a == i);\n        }\n\n        uint256 av = co.ao[0];\n        uint256 ap = co.ao[1];\n        uint256 x = co.ab[0];\n        uint256 w = co.ab[1];\n\n        co.ao[0] = 0;\n        co.ao[1] = 0;\n        co.ab[0] = 0;\n        co.ab[1] = 0;\n\n        if(av != 0 || ap != 0) {\n            co.p[0].transfer(av);\n            co.p[1].transfer(ap);\n        }\n\n        if(x != 0 || w != 0) {\n            require(\n                co.dl.transfer(co.p[0], x),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n            require(\n                co.dl.transfer(co.p[1], w),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n        }\n\n        co.dh = false;\n        ax--;\n\n        emit DidLCClose(dn, co.cf, av, ap, x, w);\n    }\n\n    function af(bytes32 do, bytes de, bytes32 dq) internal pure returns (bool) {\n        bytes32 df = do;\n        bytes32 bl;\n\n        for (uint256 i = 64; i <= de.length; i += 32) {\n            assembly { bl := mload(add(de, i)) }\n\n            if (df < bl) {\n                df = bm(abi.ag(df, bl));\n            } else {\n                df = bm(abi.ag(bl, df));\n            }\n        }\n\n        return df == dq;\n    }\n\n\n    function bd(bytes32 ek) public view returns (\n        address[2],\n        uint256[4],\n        uint256[4],\n        uint256[2],\n        uint256,\n        uint256,\n        bytes32,\n        uint256,\n        uint256,\n        bool,\n        bool,\n        uint256\n    ) {\n        Channel memory co = Channels[ek];\n        return (\n            co.p,\n            co.ao,\n            co.ab,\n            co.s,\n            co.cf,\n            co.aq,\n            co.VCrootHash,\n            co.LCopenTimeout,\n            co.l,\n            co.dh,\n            co.h,\n            co.br\n        );\n    }\n\n    function j(bytes32 ek) public view returns(\n        bool,\n        bool,\n        uint256,\n        address,\n        uint256,\n        address,\n        address,\n        address,\n        uint256[2],\n        uint256[2],\n        uint256[2]\n    ) {\n        VirtualChannel memory r = n[ek];\n        return(\n            r.cs,\n            r.f,\n            r.cf,\n            r.bc,\n            r.k,\n            r.cx,\n            r.db,\n            r.cw,\n            r.ao,\n            r.ab,\n            r.ec\n        );\n    }\n}",
      "rename_map": {
        "possibleTotalTokenBeforeDeposit": "a",
        "possibleTotalEthBeforeDeposit": "b",
        "toEthereumSignedMessage": "c",
        "byzantineCloseChannel": "d",
        "consensusCloseChannel": "e",
        "isInSettlementState": "f",
        "closeVirtualChannel": "g",
        "isUpdateLCSettling": "h",
        "totalTokenDeposit": "i",
        "getVirtualChannel": "j",
        "updateVCtimeout": "k",
        "updateLCtimeout": "l",
        "totalEthDeposit": "m",
        "virtualChannels": "n",
        "approveAndCall": "o",
        "partyAddresses": "p",
        "parseInt16Char": "q",
        "virtualChannel": "r",
        "initialDeposit": "s",
        "_initialAmount": "t",
        "uintToBytes32": "u",
        "tokenBalanceI": "v",
        "tokenbalanceI": "w",
        "tokenbalanceA": "x",
        "hexstrToBytes": "y",
        "_decimalUnits": "z",
        "updateLCstate": "aa",
        "erc20Balances": "ab",
        "tokenBalanceA": "ac",
        "createChannel": "ad",
        "recoverSigner": "ae",
        "_isContained": "af",
        "encodePacked": "ag",
        "prefixedHash": "ah",
        "transferFrom": "ai",
        "updateParams": "aj",
        "_tokenSymbol": "ak",
        "uintToString": "al",
        "_updateState": "am",
        "_confirmTime": "an",
        "ethBalances": "ao",
        "ethbalanceI": "ap",
        "confirmTime": "aq",
        "ethBalanceI": "ar",
        "totalSupply": "as",
        "initVCstate": "at",
        "ethBalanceA": "au",
        "ethbalanceA": "av",
        "joinChannel": "aw",
        "numChannels": "ax",
        "_startIndex": "ay",
        "_extraData": "az",
        "updateBalA": "ba",
        "isSignedBy": "bb",
        "challenger": "bc",
        "getChannel": "bd",
        "_initState": "be",
        "_hashedMsg": "bf",
        "updateBalB": "bg",
        "_tokenName": "bh",
        "recipient": "bi",
        "substring": "bj",
        "channelId": "bk",
        "proofElem": "bl",
        "keccak256": "bm",
        "remainder": "bn",
        "updateBal": "bo",
        "allowance": "bp",
        "_balances": "bq",
        "numOpenVC": "br",
        "balanceOf": "bs",
        "numOpenVc": "bt",
        "_sequence": "bu",
        "ecrecover": "bv",
        "updateSeq": "bw",
        "remaining": "bx",
        "_endIndex": "by",
        "_balance": "bz",
        "balanceB": "ca",
        "strBytes": "cb",
        "balances": "cc",
        "_spender": "cd",
        "decimals": "ce",
        "sequence": "cf",
        "balanceA": "cg",
        "settleVC": "ch",
        "_hexstr": "ci",
        "version": "cj",
        "approve": "ck",
        "_partyI": "cl",
        "success": "cm",
        "_partyA": "cn",
        "channel": "co",
        "allowed": "cp",
        "deposit": "cq",
        "bresult": "cr",
        "isClose": "cs",
        "isToken": "ct",
        "_VCroot": "cu",
        "_partyB": "cv",
        "partyI": "cw",
        "partyA": "cx",
        "symbol": "cy",
        "prefix": "cz",
        "_token": "da",
        "partyB": "db",
        "_owner": "dc",
        "_state": "dd",
        "_proof": "de",
        "cursor": "df",
        "result": "dg",
        "isOpen": "dh",
        "vcRoot": "di",
        "_value": "dj",
        "_bond": "dk",
        "token": "dl",
        "_uint": "dm",
        "_lcID": "dn",
        "_hash": "do",
        "_char": "dp",
        "_root": "dq",
        "_sigI": "dr",
        "_addr": "ds",
        "_sigA": "dt",
        "_vcID": "du",
        "proof": "dv",
        "_from": "dw",
        "name": "dx",
        "bstr": "dy",
        "_str": "dz",
        "sigA": "ea",
        "vcId": "eb",
        "bond": "ec",
        "_sig": "ed",
        "lcId": "ee",
        "_msg": "ef",
        "_to": "eg",
        "len": "eh",
        "str": "ei",
        "now": "ej",
        "id": "ek"
      },
      "changes": [
        "Renamed 141 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_115",
      "transformed_id": "ss_l2_short_nc_ds_115",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.4.15;\n\ncontract Token {\n\n    uint256 public f;\n\n\n    function k(address s) constant returns (uint256 balance);\n\n\n    function transfer(address y, uint256 u) returns (bool o);\n\n\n    function d(address v, address y, uint256 u) returns (bool o);\n\n\n    function q(address l, uint256 u) returns (bool o);\n\n\n    function i(address s, address l) constant returns (uint256 j);\n\n    event Transfer(address indexed v, address indexed y, uint256 u);\n    event Approval(address indexed s, address indexed l, uint256 u);\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address y, uint256 u) returns (bool o) {\n\n\n        require(n[msg.sender] >= u);\n        n[msg.sender] -= u;\n        n[y] += u;\n        Transfer(msg.sender, y, u);\n        return true;\n    }\n\n    function d(address v, address y, uint256 u) returns (bool o) {\n\n\n        require(n[v] >= u && r[v][msg.sender] >= u);\n        n[y] += u;\n        n[v] -= u;\n        r[v][msg.sender] -= u;\n        Transfer(v, y, u);\n        return true;\n    }\n\n    function k(address s) constant returns (uint256 balance) {\n        return n[s];\n    }\n\n    function q(address l, uint256 u) returns (bool o) {\n        r[msg.sender][l] = u;\n        Approval(msg.sender, l, u);\n        return true;\n    }\n\n    function i(address s, address l) constant returns (uint256 j) {\n      return r[s][l];\n    }\n\n    mapping (address => uint256) n;\n    mapping (address => mapping (address => uint256)) r;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n\n    string public x;\n    uint8 public m;\n    string public t;\n    string public p = 'H0.1';\n\n    function HumanStandardToken(\n        uint256 a,\n        string h,\n        uint8 c,\n        string e\n        ) {\n        n[msg.sender] = a;\n        f = a;\n        x = h;\n        m = c;\n        t = e;\n    }\n\n\n    function b(address l, uint256 u, bytes g) returns (bool o) {\n        r[msg.sender][l] = u;\n        Approval(msg.sender, l, u);\n\n\n        require(l.call(bytes4(bytes32(w(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, u, this, g));\n        return true;\n    }\n}",
      "rename_map": {
        "_initialAmount": "a",
        "approveAndCall": "b",
        "_decimalUnits": "c",
        "transferFrom": "d",
        "_tokenSymbol": "e",
        "totalSupply": "f",
        "_extraData": "g",
        "_tokenName": "h",
        "allowance": "i",
        "remaining": "j",
        "balanceOf": "k",
        "_spender": "l",
        "decimals": "m",
        "balances": "n",
        "success": "o",
        "version": "p",
        "approve": "q",
        "allowed": "r",
        "_owner": "s",
        "symbol": "t",
        "_value": "u",
        "_from": "v",
        "sha3": "w",
        "name": "x",
        "_to": "y"
      },
      "changes": [
        "Renamed 25 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_116",
      "transformed_id": "ss_l2_short_nc_ds_116",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Missing{\n    address private c;\n\n    modifier a {\n        require(msg.sender==c);\n        _;\n    }\n\n\n    function IamMissing()\n        public\n    {\n        c = msg.sender;\n    }\n\n    function b()\n        public\n        a\n    {\n       c.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "a",
        "withdraw": "b",
        "owner": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_117",
      "transformed_id": "ss_l2_short_nc_ds_117",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Rubixi {\n\n\n        uint private balance = 0;\n        uint private q = 0;\n        uint private z = 10;\n        uint private j = 300;\n        uint private x = 0;\n\n        address private ac;\n\n\n        function DynamicPyramid() {\n                ac = msg.sender;\n        }\n\n        modifier ab {\n                if (msg.sender == ac) _;\n        }\n\n        struct Participant {\n                address t;\n                uint ad;\n        }\n\n        Participant[] private v;\n\n\n        function() {\n                ai();\n        }\n\n\n        function ai() private {\n\n                if (msg.value < 1 ether) {\n                        q += msg.value;\n                        return;\n                }\n\n                uint aj = z;\n\n                if (msg.value >= 50 ether) aj /= 2;\n\n                aa(aj);\n        }\n\n\n        function aa(uint aj) private {\n\n                v.push(Participant(msg.sender, (msg.value * j) / 100));\n\n\n                if (v.length == 10) j = 200;\n                else if (v.length == 25) j = 150;\n\n\n                balance += (msg.value * (100 - aj)) / 100;\n                q += (msg.value * aj) / 100;\n\n\n                while (balance > v[x].ad) {\n                        uint u = v[x].ad;\n                        v[x].t.send(u);\n\n                        balance -= v[x].ad;\n                        x += 1;\n                }\n        }\n\n\n        function p() ab {\n                if (q == 0) throw;\n\n                ac.send(q);\n                q = 0;\n        }\n\n        function i(uint am) ab {\n                am *= 1 ether;\n                if (am > q) p();\n\n                if (q == 0) throw;\n\n                ac.send(am);\n                q -= am;\n        }\n\n        function f(uint af) ab {\n                if (q == 0 || af > 100) throw;\n\n                uint r = q / 100 * af;\n                ac.send(r);\n                q -= r;\n        }\n\n\n        function w(address ae) ab {\n                ac = ae;\n        }\n\n        function m(uint ag) ab {\n                if (ag > 300 || ag < 120) throw;\n\n                j = ag;\n        }\n\n        function g(uint aj) ab {\n                if (aj > 10) throw;\n\n                z = aj;\n        }\n\n\n        function k() constant returns(uint y, string al) {\n                y = j;\n                al = 'This y applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, y is x100 for a fractional y e.g. 250 is actually a 2.5x y. Capped at 3x max and 1.2x min.';\n        }\n\n        function e() constant returns(uint an, string al) {\n                an = z;\n                al = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n        }\n\n        function d() constant returns(uint o, string al) {\n                o = balance / 1 ether;\n                al = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n        }\n\n        function a() constant returns(uint s) {\n                s = v[x].ad / 1 ether;\n        }\n\n        function c() constant returns(uint ak) {\n                ak = q / 1 ether;\n        }\n\n        function l() constant returns(uint ah) {\n                ah = v.length;\n        }\n\n        function b() constant returns(uint ah) {\n                ah = v.length - x;\n        }\n\n        function h(uint n) constant returns(address Address, uint Payout) {\n                if (n <= v.length) {\n                        Address = v[n].t;\n                        Payout = v[n].ad / 1 ether;\n                }\n        }\n}",
      "rename_map": {
        "nextPayoutWhenPyramidBalanceTotalsApproximately": "a",
        "numberOfParticipantsWaitingForPayout": "b",
        "feesSeperateFromBalanceApproximately": "c",
        "currentPyramidBalanceApproximately": "d",
        "currentFeePercentage": "e",
        "collectPercentOfFees": "f",
        "changeFeePercentage": "g",
        "participantDetails": "h",
        "collectFeesInEther": "i",
        "pyramidMultiplier": "j",
        "currentMultiplier": "k",
        "totalParticipants": "l",
        "changeMultiplier": "m",
        "orderInPyramid": "n",
        "pyramidBalance": "o",
        "collectAllFees": "p",
        "collectedFees": "q",
        "feesToCollect": "r",
        "balancePayout": "s",
        "etherAddress": "t",
        "payoutToSend": "u",
        "participants": "v",
        "changeOwner": "w",
        "payoutOrder": "x",
        "multiplier": "y",
        "feePercent": "z",
        "addPayout": "aa",
        "onlyowner": "ab",
        "creator": "ac",
        "payout": "ad",
        "_owner": "ae",
        "_pcent": "af",
        "_mult": "ag",
        "count": "ah",
        "init": "ai",
        "_fee": "aj",
        "fees": "ak",
        "info": "al",
        "_amt": "am",
        "fee": "an"
      },
      "changes": [
        "Renamed 40 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_118",
      "transformed_id": "ss_l2_short_nc_ds_118",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "contract Destructible {\n  address a;\n  function suicide() public returns (address) {\n    require(a == msg.sender);\n    selfdestruct(a);\n  }\n}\ncontract C is Destructible {\n  address a;\n  function C() {\n    a = msg.sender;\n  }\n}",
      "rename_map": {
        "owner": "a"
      },
      "changes": [
        "Renamed 1 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_119",
      "transformed_id": "ss_l2_short_nc_ds_119",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n\n        address q;\n\n\n        string ab;\n\n        uint w;\n\n        uint d;\n    }\n\n\n    address p;\n\n\n    modifier x { if (msg.sender == p) _; }\n\n\n    uint constant g = 100 finney;\n\n\n    uint constant f = 3;\n    uint constant c = 2;\n\n\n    uint constant b = 1;\n    uint constant a = 100;\n\n\n    uint public h;\n\n\n    Monarch public n;\n\n\n    Monarch[] public r;\n\n\n    function KingOfTheEtherThrone() {\n        p = msg.sender;\n        h = g;\n        n = Monarch(\n            p,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function l() constant returns (uint n) {\n        return r.length;\n    }\n\n\n    event ThroneClaimed(\n        address e,\n        string u,\n        uint o\n    );\n\n\n    function() {\n        t(string(msg.data));\n    }\n\n\n    function t(string ab) {\n\n        uint y = msg.value;\n\n\n        if (y < h) {\n            msg.sender.send(y);\n            return;\n        }\n\n\n        if (y > h) {\n            uint v = y - h;\n            msg.sender.send(v);\n            y = y - v;\n        }\n\n\n        uint k = (y * b) / a;\n\n        uint s = y - k;\n\n        if (n.q != p) {\n            n.q.send(s);\n        } else {\n\n        }\n\n\n        r.push(n);\n        n = Monarch(\n            msg.sender,\n            ab,\n            y,\n            block.timestamp\n        );\n\n\n        uint j = h * f / c;\n        if (j < 10 finney) {\n            h = j;\n        } else if (j < 100 finney) {\n            h = 100 szabo * (j / 100 szabo);\n        } else if (j < 1 ether) {\n            h = 1 finney * (j / 1 finney);\n        } else if (j < 10 ether) {\n            h = 10 finney * (j / 10 finney);\n        } else if (j < 100 ether) {\n            h = 100 finney * (j / 100 finney);\n        } else if (j < 1000 ether) {\n            h = 1 ether * (j / 1 ether);\n        } else if (j < 10000 ether) {\n            h = 10 ether * (j / 10 ether);\n        } else {\n            h = j;\n        }\n\n\n        ThroneClaimed(n.q, n.ab, h);\n    }\n\n\n    function m(uint aa) x {\n        p.send(aa);\n    }\n\n\n    function i(address z) x {\n        p = z;\n    }\n\n}",
      "rename_map": {
        "wizardCommissionFractionDen": "a",
        "wizardCommissionFractionNum": "b",
        "claimPriceAdjustDen": "c",
        "coronationTimestamp": "d",
        "usurperEtherAddress": "e",
        "claimPriceAdjustNum": "f",
        "startingClaimPrice": "g",
        "currentClaimPrice": "h",
        "transferOwnership": "i",
        "rawNewClaimPrice": "j",
        "wizardCommission": "k",
        "numberOfMonarchs": "l",
        "sweepCommission": "m",
        "currentMonarch": "n",
        "newClaimPrice": "o",
        "wizardAddress": "p",
        "etherAddress": "q",
        "pastMonarchs": "r",
        "compensation": "s",
        "claimThrone": "t",
        "usurperName": "u",
        "excessPaid": "v",
        "claimPrice": "w",
        "onlywizard": "x",
        "valuePaid": "y",
        "newOwner": "z",
        "amount": "aa",
        "name": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_120",
      "transformed_id": "ss_l2_short_nc_ds_120",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract CrowdFundBasic {\n  address[] private a;\n  mapping(address => uint) public c;\n\n  function d() public {\n    for(uint i; i < a.length; i++) {\n      require(a[i].transfer(c[a[i]]));\n    }\n  }\n}\n\ncontract CrowdFundPull {\n  address[] private a;\n  mapping(address => uint) public c;\n\n  function e() external {\n    uint g = c[msg.sender];\n    c[msg.sender] = 0;\n    msg.sender.transfer(g);\n  }\n}\n\ncontract CrowdFundBatched {\n  address[] private a;\n  mapping(address => uint) public c;\n  uint256 f;\n\n  function b() public {\n    uint256 i = f;\n    while(i < a.length && msg.gas > 200000) {\n      a[i].transfer(c[i]);\n      i++;\n    }\n    f = i;\n  }\n}",
      "rename_map": {
        "refundAddresses": "a",
        "refundBatched": "b",
        "refundAmount": "c",
        "refundAll": "d",
        "withdraw": "e",
        "nextIdx": "f",
        "refund": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_121",
      "transformed_id": "ss_l2_short_nc_ds_121",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address a;\n  uint b;\n\n  function f() payable {\n    require(msg.value > b);\n\n\n    if (a != 0) {\n\n      require(a.send(b));\n    }\n\n    a = msg.sender;\n    b         = msg.value;\n  }\n}\n\ncontract AuctionV2 {\n  address a;\n  uint    b;\n\n  mapping(address => uint) d;\n\n\n  function f() payable external {\n    require(msg.value > b);\n\n    if (a != 0) {\n      d[a] += b;\n    }\n\n    a = msg.sender;\n    b         = msg.value;\n  }\n\n\n  function c() external {\n\n    uint e = d[msg.sender];\n    d[msg.sender] = 0;\n\n    msg.sender.send(e);\n  }\n}",
      "rename_map": {
        "currentFrontrunner": "a",
        "currentBid": "b",
        "withdraw": "c",
        "refunds": "d",
        "refund": "e",
        "bid": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_122",
      "transformed_id": "ss_l2_short_nc_ds_122",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\ncontract WalletEvents {\n\n\n  event Confirmation(address bj, bytes32 ai);\n  event Revoke(address bj, bytes32 ai);\n\n\n  event OwnerChanged(address an, address aq);\n  event OwnerAdded(address aq);\n  event OwnerRemoved(address an);\n\n\n  event RequirementChanged(uint f);\n\n\n  event Deposit(address bq, uint value);\n\n  event SingleTransact(address bj, uint value, address bx, bytes data, address ax);\n\n  event MultiTransact(address bj, bytes32 ai, uint value, address bx, bytes data, address ax);\n\n  event ConfirmationNeeded(bytes32 ai, address ak, uint value, address bx, bytes data);\n}\n\ncontract WalletAbi {\n\n  function bi(bytes32 ac) external;\n\n\n  function v(address bq, address bv) external;\n\n  function ao(address be) external;\n\n  function t(address be) external;\n\n  function a(uint p) external;\n\n  function av(address bm) constant returns (bool);\n\n  function q(bytes32 ac, address be) external constant returns (bool);\n\n\n  function j(uint ad) external;\n\n  function aw(address bv, uint bh, bytes bo) external returns (bytes32 bf);\n  function az(bytes32 by) returns (bool aj);\n}\n\ncontract WalletLibrary is WalletEvents {\n\n\n  struct PendingState {\n    uint al;\n    uint y;\n    uint bk;\n  }\n\n\n  struct Transaction {\n    address bx;\n    uint value;\n    bytes data;\n  }\n\n\n  modifier ah {\n    if (av(msg.sender))\n      _;\n  }\n\n\n  modifier g(bytes32 ac) {\n    if (d(ac))\n      _;\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n\n  function h(address[] ba, uint ae) {\n    w = ba.length + 1;\n    at[1] = uint(msg.sender);\n    o[uint(msg.sender)] = 1;\n    for (uint i = 0; i < ba.length; ++i)\n    {\n      at[2 + i] = uint(ba[i]);\n      o[uint(ba[i])] = 2 + i;\n    }\n    x = ae;\n  }\n\n\n  function bi(bytes32 ac) external {\n    uint z = o[uint(msg.sender)];\n\n    if (z == 0) return;\n    uint k = 2**z;\n    var au = am[ac];\n    if (au.y & k > 0) {\n      au.al++;\n      au.y -= k;\n      Revoke(msg.sender, ac);\n    }\n  }\n\n\n  function v(address bq, address bv) g(bu(msg.data)) external {\n    if (av(bv)) return;\n    uint z = o[uint(bq)];\n    if (z == 0) return;\n\n    r();\n    at[z] = uint(bv);\n    o[uint(bq)] = 0;\n    o[uint(bv)] = z;\n    OwnerChanged(bq, bv);\n  }\n\n  function ao(address be) g(bu(msg.data)) external {\n    if (av(be)) return;\n\n    r();\n    if (w >= u)\n      b();\n    if (w >= u)\n      return;\n    w++;\n    at[w] = uint(be);\n    o[uint(be)] = w;\n    OwnerAdded(be);\n  }\n\n  function t(address be) g(bu(msg.data)) external {\n    uint z = o[uint(be)];\n    if (z == 0) return;\n    if (x > w - 1) return;\n\n    at[z] = 0;\n    o[uint(be)] = 0;\n    r();\n    b();\n    OwnerRemoved(be);\n  }\n\n  function a(uint p) g(bu(msg.data)) external {\n    if (p > w) return;\n    x = p;\n    r();\n    RequirementChanged(p);\n  }\n\n\n  function ar(uint z) external constant returns (address) {\n    return address(at[z + 1]);\n  }\n\n  function av(address bm) constant returns (bool) {\n    return o[uint(bm)] > 0;\n  }\n\n  function q(bytes32 ac, address be) external constant returns (bool) {\n    var au = am[ac];\n    uint z = o[uint(be)];\n\n\n    if (z == 0) return false;\n\n\n    uint k = 2**z;\n    return !(au.y & k == 0);\n  }\n\n\n  function l(uint bc) {\n    m = bc;\n    af = bp();\n  }\n\n  function j(uint ad) g(bu(msg.data)) external {\n    m = ad;\n  }\n\n  function e() g(bu(msg.data)) external {\n    s = 0;\n  }\n\n\n  function aa(address[] ba, uint ae, uint ag) {\n    l(ag);\n    h(ba, ae);\n  }\n\n\n  function bs(address bv) g(bu(msg.data)) external {\n    suicide(bv);\n  }\n\n\n  function aw(address bv, uint bh, bytes bo) external ah returns (bytes32 bf) {\n\n    if ((bo.length == 0 && ab(bh)) || x == 1) {\n\n      address ax;\n      if (bv == 0) {\n        ax = bg(bh, bo);\n      } else {\n        if (!bv.call.value(bh)(bo))\n          throw;\n      }\n      SingleTransact(msg.sender, bh, bv, bo, ax);\n    } else {\n\n      bf = bu(msg.data, block.number);\n\n      if (bn[bf].bx == 0 && bn[bf].value == 0 && bn[bf].data.length == 0) {\n        bn[bf].bx = bv;\n        bn[bf].value = bh;\n        bn[bf].data = bo;\n      }\n      if (!az(bf)) {\n        ConfirmationNeeded(bf, msg.sender, bh, bv, bo);\n      }\n    }\n  }\n\n  function bg(uint bh, bytes br) internal returns (address bb) {\n    assembly {\n      bb := bg(bh, add(br, 0x20), mload(br))\n      bl(c, iszero(extcodesize(bb)))\n    }\n  }\n\n\n  function az(bytes32 by) g(by) returns (bool aj) {\n    if (bn[by].bx != 0 || bn[by].value != 0 || bn[by].data.length != 0) {\n      address ax;\n      if (bn[by].bx == 0) {\n        ax = bg(bn[by].value, bn[by].data);\n      } else {\n        if (!bn[by].bx.call.value(bn[by].value)(bn[by].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, by, bn[by].value, bn[by].bx, bn[by].data, ax);\n      delete bn[by];\n      return true;\n    }\n  }\n\n\n  function d(bytes32 ac) internal returns (bool) {\n\n    uint z = o[uint(msg.sender)];\n\n    if (z == 0) return;\n\n    var au = am[ac];\n\n    if (au.al == 0) {\n\n      au.al = x;\n\n      au.y = 0;\n      au.bk = i.length++;\n      i[au.bk] = ac;\n    }\n\n    uint k = 2**z;\n\n    if (au.y & k == 0) {\n      Confirmation(msg.sender, ac);\n\n      if (au.al <= 1) {\n\n        delete i[am[ac].bk];\n        delete am[ac];\n        return true;\n      }\n      else\n      {\n\n        au.al--;\n        au.y |= k;\n      }\n    }\n  }\n\n  function b() private {\n    uint bt = 1;\n    while (bt < w)\n    {\n      while (bt < w && at[bt] != 0) bt++;\n      while (w > 1 && at[w] == 0) w--;\n      if (bt < w && at[w] != 0 && at[bt] == 0)\n      {\n        at[bt] = at[w];\n        o[at[bt]] = bt;\n        at[w] = 0;\n      }\n    }\n  }\n\n\n  function ab(uint bh) internal ah returns (bool) {\n\n    if (bp() > af) {\n      s = 0;\n      af = bp();\n    }\n\n\n    if (s + bh >= s && s + bh <= m) {\n      s += bh;\n      return true;\n    }\n    return false;\n  }\n\n\n  function bp() private constant returns (uint) { return bw / 1 days; }\n\n  function r() internal {\n    uint length = i.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete bn[i[i]];\n\n      if (i[i] != 0)\n        delete am[i[i]];\n    }\n\n    delete i;\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public x;\n\n  uint public w;\n\n  uint public m;\n  uint public s;\n  uint public af;\n\n\n  uint[256] at;\n\n  uint constant u = 250;\n\n  mapping(uint => uint) o;\n\n  mapping(bytes32 => PendingState) am;\n  bytes32[] i;\n\n\n  mapping (bytes32 => Transaction) bn;\n}\n\ncontract Wallet is WalletEvents {\n\n\n  function Wallet(address[] ba, uint ae, uint ag) {\n\n    bytes4 sig = bytes4(bu(\"initWallet(address[],uint256,uint256)\"));\n    address bd = _walletLibrary;\n\n\n    uint n = (2 + ba.length);\n    uint ay = (2 + n) * 32;\n\n    assembly {\n\n      mstore(0x0, sig)\n\n\n      as(0x4,  sub(ap, ay), ay)\n\n      delegatecall(sub(gas, 10000), bd, 0x0, add(ay, 0x4), 0x0, 0x0)\n    }\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n\n  function ar(uint z) constant returns (address) {\n    return address(at[z + 1]);\n  }\n\n\n  function q(bytes32 ac, address be) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function av(address bm) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public x;\n\n  uint public w;\n\n  uint public m;\n  uint public s;\n  uint public af;\n\n\n  uint[256] at;\n}",
      "rename_map": {
        "changeRequirement": "a",
        "reorganizeOwners": "b",
        "invalidJumpLabel": "c",
        "confirmAndCheck": "d",
        "resetSpentToday": "e",
        "newRequirement": "f",
        "onlymanyowners": "g",
        "initMultiowned": "h",
        "m_pendingIndex": "i",
        "setDailyLimit": "j",
        "ownerIndexBit": "k",
        "initDaylimit": "l",
        "m_dailyLimit": "m",
        "argarraysize": "n",
        "m_ownerIndex": "o",
        "_newRequired": "p",
        "hasConfirmed": "q",
        "clearPending": "r",
        "m_spentToday": "s",
        "removeOwner": "t",
        "c_maxOwners": "u",
        "changeOwner": "v",
        "m_numOwners": "w",
        "m_required": "x",
        "ownersDone": "y",
        "ownerIndex": "z",
        "initWallet": "aa",
        "underLimit": "ab",
        "_operation": "ac",
        "_newLimit": "ad",
        "_required": "ae",
        "m_lastDay": "af",
        "_daylimit": "ag",
        "onlyowner": "ah",
        "operation": "ai",
        "o_success": "aj",
        "initiator": "ak",
        "yetNeeded": "al",
        "m_pending": "am",
        "oldOwner": "an",
        "addOwner": "ao",
        "codesize": "ap",
        "newOwner": "aq",
        "getOwner": "ar",
        "codecopy": "as",
        "m_owners": "at",
        "pending": "au",
        "isOwner": "av",
        "execute": "aw",
        "created": "ax",
        "argsize": "ay",
        "confirm": "az",
        "_owners": "ba",
        "o_addr": "bb",
        "_limit": "bc",
        "target": "bd",
        "_owner": "be",
        "o_hash": "bf",
        "create": "bg",
        "_value": "bh",
        "revoke": "bi",
        "owner": "bj",
        "index": "bk",
        "jumpi": "bl",
        "_addr": "bm",
        "m_txs": "bn",
        "_data": "bo",
        "today": "bp",
        "_from": "bq",
        "_code": "br",
        "kill": "bs",
        "free": "bt",
        "sha3": "bu",
        "_to": "bv",
        "now": "bw",
        "to": "bx",
        "_h": "by"
      },
      "changes": [
        "Renamed 77 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_123",
      "transformed_id": "ss_l2_short_nc_ds_123",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract af {\n    address public ad;\n\n    function af() public {\n        ad = msg.sender;\n    }\n\n    modifier n {\n        require(msg.sender == ad);\n        _;\n    }\n\n    function b(address q) n public {\n        ad = q;\n    }\n}\n\ninterface f { function d(address ae, uint256 z, address ab, bytes k) external; }\n\ncontract TokenERC20 {\n\n    string public ag;\n    string public y;\n    uint8 public s = 18;\n\n    uint256 public i;\n\n\n    mapping (address => uint256) public p;\n    mapping (address => mapping (address => uint256)) public l;\n\n\n    event Transfer(address indexed from, address indexed aj, uint256 value);\n\n\n    event Approval(address indexed w, address indexed r, uint256 z);\n\n    function TokenERC20(\n        string o,\n        string j\n    ) public {\n        ag = o;\n        y = j;\n    }\n\n    function m(address ae, address ah, uint z) internal {\n\n        require(ah != 0x0);\n\n        require(p[ae] >= z);\n\n        require(p[ah] + z > p[ah]);\n\n        uint c = p[ae] + p[ah];\n\n        p[ae] -= z;\n\n        p[ah] += z;\n        emit Transfer(ae, ah, z);\n\n        assert(p[ae] + p[ah] == c);\n    }\n\n    function transfer(address ah, uint256 z) public returns (bool u) {\n        m(msg.sender, ah, z);\n        return true;\n    }\n\n    function h(address ae, address ah, uint256 z) public returns (bool u) {\n        require(z <= l[ae][msg.sender]);\n        l[ae][msg.sender] -= z;\n        m(ae, ah, z);\n        return true;\n    }\n\n    function v(address r, uint256 z) public\n        returns (bool u) {\n        l[msg.sender][r] = z;\n        emit Approval(msg.sender, r, z);\n        return true;\n    }\n\n    function e(address r, uint256 z, bytes k)\n        public\n        returns (bool u) {\n        f t = f(r);\n        if (v(r, z)) {\n            t.d(msg.sender, z, this, k);\n            return true;\n        }\n    }\n\n}\n\n\ncontract MyAdvancedToken is af, TokenERC20 {\n\n    mapping (address => bool) public g;\n\n\n    event FrozenFunds(address ac, bool aa);\n\n\n    function MyAdvancedToken(\n        string o,\n        string j\n    ) TokenERC20(o, j) public {}\n\n\n    function m(address ae, address ah, uint z) internal {\n        require (ah != 0x0);\n        require (p[ae] >= z);\n        require (p[ah] + z >= p[ah]);\n        require(!g[ae]);\n        require(!g[ah]);\n        p[ae] -= z;\n        p[ah] += z;\n        emit Transfer(ae, ah, z);\n    }\n\n\n    function ai() payable public {\n        uint x = msg.value;\n\tp[msg.sender] += x;\n        i += x;\n        m(address(0x0), msg.sender, x);\n    }\n\n\n    function a() n {\n\tassert(this.balance == i);\n\tsuicide(ad);\n    }\n}",
      "rename_map": {
        "migrate_and_destroy": "a",
        "transferOwnership": "b",
        "previousBalances": "c",
        "receiveApproval": "d",
        "approveAndCall": "e",
        "tokenRecipient": "f",
        "frozenAccount": "g",
        "transferFrom": "h",
        "totalSupply": "i",
        "tokenSymbol": "j",
        "_extraData": "k",
        "allowance": "l",
        "_transfer": "m",
        "onlyOwner": "n",
        "tokenName": "o",
        "balanceOf": "p",
        "newOwner": "q",
        "_spender": "r",
        "decimals": "s",
        "spender": "t",
        "success": "u",
        "approve": "v",
        "_owner": "w",
        "amount": "x",
        "symbol": "y",
        "_value": "z",
        "frozen": "aa",
        "_token": "ab",
        "target": "ac",
        "owner": "ad",
        "_from": "ae",
        "owned": "af",
        "name": "ag",
        "_to": "ah",
        "buy": "ai",
        "to": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_124",
      "transformed_id": "ss_l2_short_nc_ds_124",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Alice {\n    function b(uint);\n    function a(int);\n}\n\ncontract Bob {\n    function b(Alice c){\n        c.b(42);\n    }\n\n    function a(Alice c){\n        c.a(42);\n    }\n}",
      "rename_map": {
        "setV2": "a",
        "set": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_125",
      "transformed_id": "ss_l2_short_nc_ds_125",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Missing{\n    address private c;\n\n    modifier a {\n        require(msg.sender==c);\n        _;\n    }\n\n\n    function IamMissing()\n        public\n    {\n        c = msg.sender;\n    }\n\n    function () payable {}\n\n    function b()\n        public\n        a\n    {\n       c.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "a",
        "withdraw": "b",
        "owner": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_126",
      "transformed_id": "ss_l2_short_nc_ds_126",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Missing{\n    address private d;\n\n    modifier a {\n        require(msg.sender==d);\n        _;\n    }\n    function c()\n        public\n    {\n        d = msg.sender;\n    }\n\n    function () payable {}\n\n    function b()\n        public\n        a\n    {\n       d.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "a",
        "withdraw": "b",
        "missing": "c",
        "owner": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_127",
      "transformed_id": "ss_l2_short_nc_ds_127",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Missing{\n    address private c;\n\n    modifier a {\n        require(msg.sender==c);\n        _;\n    }\n    function Constructor()\n        public\n    {\n        c = msg.sender;\n    }\n\n    function () payable {}\n\n    function b()\n        public\n        a\n    {\n       c.transfer(this.balance);\n    }\n\n}",
      "rename_map": {
        "onlyowner": "a",
        "withdraw": "b",
        "owner": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_128",
      "transformed_id": "ss_l2_short_nc_ds_128",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract MultiOwnable {\n  address public g;\n  mapping (address => address) public f;\n\n  constructor() public {\n    g = msg.sender;\n    f[g] = g;\n  }\n\n  modifier c() {\n    require(f[msg.sender] != 0);\n    _;\n  }\n\n  function d(address e) external returns (bool) {\n    require(e != 0);\n    f[e] = msg.sender;\n    return true;\n  }\n\n  function b(address e) c external returns (bool) {\n    require(f[e] == msg.sender || (f[e] != 0 && msg.sender == g));\n    f[e] = 0;\n    return true;\n  }\n}\n\ncontract TestContract is MultiOwnable {\n\n  function a() c {\n    msg.sender.transfer(this.balance);\n  }\n\n  function() payable {\n  }\n\n}",
      "rename_map": {
        "withdrawAll": "a",
        "deleteOwner": "b",
        "onlyOwner": "c",
        "newOwner": "d",
        "_owner": "e",
        "owners": "f",
        "root": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_129",
      "transformed_id": "ss_l2_short_nc_ds_129",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n contract Rubixi {\n\n\n         uint private balance = 0;\n         uint private q = 0;\n         uint private z = 10;\n         uint private j = 300;\n         uint private x = 0;\n\n         address private ac;\n\n\n         function DynamicPyramid() {\n                 ac = msg.sender;\n         }\n\n         modifier ab {\n                 if (msg.sender == ac) _;\n         }\n\n         struct Participant {\n                 address t;\n                 uint ad;\n         }\n\n         Participant[] private v;\n\n\n         function() {\n                 ai();\n         }\n\n\n         function ai() private {\n\n                 if (msg.value < 1 ether) {\n                         q += msg.value;\n                         return;\n                 }\n\n                 uint aj = z;\n\n                 if (msg.value >= 50 ether) aj /= 2;\n\n                 aa(aj);\n         }\n\n\n         function aa(uint aj) private {\n\n                 v.push(Participant(msg.sender, (msg.value * j) / 100));\n\n\n                 if (v.length == 10) j = 200;\n                 else if (v.length == 25) j = 150;\n\n\n                 balance += (msg.value * (100 - aj)) / 100;\n                 q += (msg.value * aj) / 100;\n\n\n                 while (balance > v[x].ad) {\n                         uint u = v[x].ad;\n                         v[x].t.send(u);\n\n                         balance -= v[x].ad;\n                         x += 1;\n                 }\n         }\n\n\n         function p() ab {\n                 if (q == 0) throw;\n\n                 ac.send(q);\n                 q = 0;\n         }\n\n         function i(uint am) ab {\n                 am *= 1 ether;\n                 if (am > q) p();\n\n                 if (q == 0) throw;\n\n                 ac.send(am);\n                 q -= am;\n         }\n\n         function f(uint af) ab {\n                 if (q == 0 || af > 100) throw;\n\n                 uint r = q / 100 * af;\n                 ac.send(r);\n                 q -= r;\n         }\n\n\n         function w(address ae) ab {\n                 ac = ae;\n         }\n\n         function m(uint ag) ab {\n                 if (ag > 300 || ag < 120) throw;\n\n                 j = ag;\n         }\n\n         function g(uint aj) ab {\n                 if (aj > 10) throw;\n\n                 z = aj;\n         }\n\n\n         function k() constant returns(uint y, string al) {\n                 y = j;\n                 al = 'This y applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, y is x100 for a fractional y e.g. 250 is actually a 2.5x y. Capped at 3x max and 1.2x min.';\n         }\n\n         function e() constant returns(uint an, string al) {\n                 an = z;\n                 al = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function d() constant returns(uint o, string al) {\n                 o = balance / 1 ether;\n                 al = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function a() constant returns(uint s) {\n                 s = v[x].ad / 1 ether;\n         }\n\n         function c() constant returns(uint ak) {\n                 ak = q / 1 ether;\n         }\n\n         function l() constant returns(uint ah) {\n                 ah = v.length;\n         }\n\n         function b() constant returns(uint ah) {\n                 ah = v.length - x;\n         }\n\n         function h(uint n) constant returns(address Address, uint Payout) {\n                 if (n <= v.length) {\n                         Address = v[n].t;\n                         Payout = v[n].ad / 1 ether;\n                 }\n         }\n }",
      "rename_map": {
        "nextPayoutWhenPyramidBalanceTotalsApproximately": "a",
        "numberOfParticipantsWaitingForPayout": "b",
        "feesSeperateFromBalanceApproximately": "c",
        "currentPyramidBalanceApproximately": "d",
        "currentFeePercentage": "e",
        "collectPercentOfFees": "f",
        "changeFeePercentage": "g",
        "participantDetails": "h",
        "collectFeesInEther": "i",
        "pyramidMultiplier": "j",
        "currentMultiplier": "k",
        "totalParticipants": "l",
        "changeMultiplier": "m",
        "orderInPyramid": "n",
        "pyramidBalance": "o",
        "collectAllFees": "p",
        "collectedFees": "q",
        "feesToCollect": "r",
        "balancePayout": "s",
        "etherAddress": "t",
        "payoutToSend": "u",
        "participants": "v",
        "changeOwner": "w",
        "payoutOrder": "x",
        "multiplier": "y",
        "feePercent": "z",
        "addPayout": "aa",
        "onlyowner": "ab",
        "creator": "ac",
        "payout": "ad",
        "_owner": "ae",
        "_pcent": "af",
        "_mult": "ag",
        "count": "ah",
        "init": "ai",
        "_fee": "aj",
        "fees": "ak",
        "info": "al",
        "_amt": "am",
        "fee": "an"
      },
      "changes": [
        "Renamed 40 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_130",
      "transformed_id": "ss_l2_short_nc_ds_130",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n contract OpenAccess{\n     address private d;\n\n     modifier c {\n         require(msg.sender==d);\n         _;\n     }\n\n     function OpenAccess()\n         public\n     {\n         d = msg.sender;\n     }\n\n\n     function a(address b)\n         public\n     {\n        d = b;\n     }\n\n }",
      "rename_map": {
        "changeOwner": "a",
        "_newOwner": "b",
        "onlyowner": "c",
        "owner": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_131",
      "transformed_id": "ss_l2_short_nc_ds_131",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\ncontract AdditionCounter {\n    mapping (address => uint256) public a;\n\n    function transfer(address c, uint256 b) public{\n\n        require(a[msg.sender] >= b);\n        a[msg.sender] -= b;\n        a[c] += b;\n}\n\n}",
      "rename_map": {
        "balanceOf": "a",
        "_value": "b",
        "_to": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_132",
      "transformed_id": "ss_l2_short_nc_ds_132",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n contract Ledger {\n     uint private a=0;\n\n     function b(uint value) returns (bool){\n         a += value;\n\n\n     }\n\n\n }",
      "rename_map": {
        "sellerBalance": "a",
        "add": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_133",
      "transformed_id": "ss_l2_short_nc_ds_133",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract AdditionCounter {\n    uint public a = 1;\n\n    function c(uint256 b) public {\n        a += b;\n    }\n}",
      "rename_map": {
        "count": "a",
        "input": "b",
        "run": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_134",
      "transformed_id": "ss_l2_short_nc_ds_134",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract BenignCounter {\n    uint public a = 1;\n\n    function c(uint256 b) public {\n        uint d = a - b;\n    }\n}",
      "rename_map": {
        "count": "a",
        "input": "b",
        "run": "c",
        "res": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_135",
      "transformed_id": "ss_l2_short_nc_ds_135",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.11;\n\ncontract MappingCounter {\n    mapping(uint256 => uint256) b;\n\n    function a(uint256 k, uint256 v) public {\n        b[k] -= v;\n    }\n}",
      "rename_map": {
        "init": "a",
        "map": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_136",
      "transformed_id": "ss_l2_short_nc_ds_136",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract MinimalCounter {\n    uint public a = 1;\n\n    function c(uint256 b) public {\n        a -= b;\n    }\n}",
      "rename_map": {
        "count": "a",
        "input": "b",
        "run": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_137",
      "transformed_id": "ss_l2_short_nc_ds_137",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract MultiplyCounter {\n    uint public a = 2;\n\n    function c(uint256 b) public {\n        a *= b;\n    }\n}",
      "rename_map": {
        "count": "a",
        "input": "b",
        "run": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_138",
      "transformed_id": "ss_l2_short_nc_ds_138",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract MultiTxCalculator {\n    uint256 private a = 0;\n    uint256 public b = 1;\n\n    function d() public {\n        a = 1;\n    }\n\n    function e(uint256 c) {\n        if (a == 0) {\n            return;\n        }\n        b -= c;\n    }\n}",
      "rename_map": {
        "initialized": "a",
        "count": "b",
        "input": "c",
        "init": "d",
        "run": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_139",
      "transformed_id": "ss_l2_short_nc_ds_139",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract SingleFuncCalculator {\n    uint256 private a = 0;\n    uint256 public b = 1;\n\n    function d(uint256 c) public {\n        if (a == 0) {\n            a = 1;\n            return;\n        }\n        b -= c;\n    }\n}",
      "rename_map": {
        "initialized": "a",
        "count": "b",
        "input": "c",
        "run": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_140",
      "transformed_id": "ss_l2_short_nc_ds_140",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.4.25;\n\ncontract AdditionLedger {\n    uint public balance = 1;\n\n    function b(uint256 a) public {\n        balance += a;\n    }\n}",
      "rename_map": {
        "deposit": "a",
        "add": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_141",
      "transformed_id": "ss_l2_short_nc_ds_141",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract SingleTxCounter {\n    uint public g = 1;\n\n    function d(uint256 h) public {\n        g += h;\n    }\n\n    function e(uint256 h) public {\n        g *= h;\n    }\n\n    function b(uint256 h) public {\n        g -= h;\n    }\n\n    function f(uint256 h) public {\n        uint i = g + h;\n    }\n\n    function c(uint256 h) public {\n        uint i = g * h;\n    }\n\n    function a(uint256 h) public {\n       \tuint i = g - h;\n    }\n\n}",
      "rename_map": {
        "underflowlocalonly": "a",
        "underflowtostate": "b",
        "mullocalonly": "c",
        "addtostate": "d",
        "multostate": "e",
        "localcalc": "f",
        "count": "g",
        "input": "h",
        "res": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_142",
      "transformed_id": "ss_l2_short_nc_ds_142",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\n contract TimeLock {\n\n     mapping(address => uint) public f;\n     mapping(address => uint) public e;\n\n     function g() public payable {\n         f[msg.sender] += msg.value;\n         e[msg.sender] = h + 1 weeks;\n     }\n\n     function b(uint a) public {\n         e[msg.sender] += a;\n     }\n\n     function d() public {\n         require(f[msg.sender] > 0);\n         require(h > e[msg.sender]);\n         uint c = f[msg.sender];\n         f[msg.sender] = 0;\n         msg.sender.transfer(c);\n     }\n }",
      "rename_map": {
        "_secondsToIncrease": "a",
        "increaseLockTime": "b",
        "transferValue": "c",
        "withdraw": "d",
        "lockTime": "e",
        "balances": "f",
        "deposit": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_143",
      "transformed_id": "ss_l2_short_nc_ds_143",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) d;\n   uint public b;\n\n   function Token(uint a) {\n     d[msg.sender] = b = a;\n   }\n\n   function transfer(address g, uint f) public returns (bool) {\n     require(d[msg.sender] - f >= 0);\n     d[msg.sender] -= f;\n     d[g] += f;\n     return true;\n   }\n\n   function c(address e) public constant returns (uint balance) {\n     return d[e];\n   }\n }",
      "rename_map": {
        "_initialSupply": "a",
        "totalSupply": "b",
        "balanceOf": "c",
        "balances": "d",
        "_owner": "e",
        "_value": "f",
        "_to": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_144",
      "transformed_id": "ss_l2_short_nc_ds_144",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public b;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address d) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function a() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function f(uint256 c) public payable {\n        require(msg.value == c * PRICE_PER_TOKEN);\n        b[msg.sender] += c;\n    }\n\n    function e(uint256 c) public {\n        require(b[msg.sender] >= c);\n\n        b[msg.sender] -= c;\n        msg.sender.transfer(c * PRICE_PER_TOKEN);\n    }\n}",
      "rename_map": {
        "isComplete": "a",
        "balanceOf": "b",
        "numTokens": "c",
        "_player": "d",
        "sell": "e",
        "buy": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_145",
      "transformed_id": "ss_l2_short_nc_ds_145",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address aa;\n        uint s;\n    }\n\n    event RaffleResult(\n        uint s,\n        uint c,\n        address a,\n        address y,\n        address x,\n        uint w,\n        bytes32 r\n    );\n\n    event TicketPurchase(\n        uint s,\n        address l,\n        uint number\n    );\n\n    event TicketRefund(\n        uint s,\n        address l,\n        uint number\n    );\n\n\n    uint public constant v = 2.5 ether;\n    uint public constant ac = 0.03 ether;\n    uint public constant e = 50;\n    uint public constant b = (v + ac) / e;\n    address k;\n\n\n    bool public u = false;\n    uint public s = 1;\n    uint public h = block.number;\n    uint j = 0;\n    mapping (uint => Contestant) g;\n    uint[] ab;\n\n\n    function Ethraffle_v4b() public {\n        k = msg.sender;\n    }\n\n\n    function () payable public {\n        m();\n    }\n\n    function m() payable public {\n        if (u) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint p = msg.value;\n\n        while (p >= b && j < e) {\n            uint i = 0;\n            if (ab.length > 0) {\n                i = ab[ab.length-1];\n                ab.length--;\n            } else {\n                i = j++;\n            }\n\n            g[i] = Contestant(msg.sender, s);\n            TicketPurchase(s, msg.sender, i);\n            p -= b;\n        }\n\n\n        if (j == e) {\n            d();\n        }\n\n\n        if (p > 0) {\n            msg.sender.transfer(p);\n        }\n    }\n\n    function d() private {\n        address y = g[uint(block.coinbase) % e].aa;\n        address x = g[uint(msg.sender) % e].aa;\n        uint w = block.difficulty;\n        bytes32 r = q(y, x, w);\n\n        uint c = uint(r) % e;\n        address a = g[c].aa;\n        RaffleResult(s, c, a, y, x, w, r);\n\n\n        s++;\n        j = 0;\n        h = block.number;\n\n\n        a.transfer(v);\n        k.transfer(ac);\n    }\n\n\n    function o() public {\n        uint t = 0;\n        for (uint i = 0; i < e; i++) {\n            if (msg.sender == g[i].aa && s == g[i].s) {\n                t += b;\n                g[i] = Contestant(address(0), 0);\n                ab.push(i);\n                TicketRefund(s, msg.sender, i);\n            }\n        }\n\n        if (t > 0) {\n            msg.sender.transfer(t);\n        }\n    }\n\n\n    function n() public {\n        if (msg.sender == k) {\n            u = true;\n\n            for (uint i = 0; i < e; i++) {\n                if (s == g[i].s) {\n                    TicketRefund(s, g[i].aa, i);\n                    g[i].aa.transfer(b);\n                }\n            }\n\n            RaffleResult(s, e, address(0), address(0), address(0), 0, 0);\n            s++;\n            j = 0;\n            h = block.number;\n            ab.length = 0;\n        }\n    }\n\n    function f() public {\n        if (msg.sender == k) {\n            u = !u;\n        }\n    }\n\n    function z() public {\n        if (msg.sender == k) {\n            selfdestruct(k);\n        }\n    }\n}",
      "rename_map": {
        "winningAddress": "a",
        "pricePerTicket": "b",
        "winningNumber": "c",
        "chooseWinner": "d",
        "totalTickets": "e",
        "togglePause": "f",
        "contestants": "g",
        "blockNumber": "h",
        "currTicket": "i",
        "nextTicket": "j",
        "feeAddress": "k",
        "contestant": "l",
        "buyTickets": "m",
        "endRaffle": "n",
        "getRefund": "o",
        "moneySent": "p",
        "keccak256": "q",
        "randHash": "r",
        "raffleId": "s",
        "refund": "t",
        "paused": "u",
        "prize": "v",
        "seed3": "w",
        "seed2": "x",
        "seed1": "y",
        "kill": "z",
        "addr": "aa",
        "gaps": "ab",
        "fee": "ac"
      },
      "changes": [
        "Renamed 29 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_146",
      "transformed_id": "ss_l2_short_nc_ds_146",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 c;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n        c = uint8(b(block.blockhash(block.number - 1), e));\n    }\n\n    function a() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function d(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == c) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
      "rename_map": {
        "isComplete": "a",
        "keccak256": "b",
        "answer": "c",
        "guess": "d",
        "now": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_147",
      "transformed_id": "ss_l2_short_nc_ds_147",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract Lottery {\n     event GetBet(uint c, uint a, bool h);\n\n     struct Bet {\n         uint c;\n         uint a;\n         bool h;\n     }\n\n     address private b;\n     Bet[] private g;\n\n\n     function Lottery() {\n         b = msg.sender;\n     }\n\n\n     function() {\n         throw;\n     }\n\n\n     function d() {\n\n\n         bool h = (block.number % 2) == 0;\n\n\n         g.push(Bet(msg.value, block.number, h));\n\n\n         if(h) {\n             if(!msg.sender.send(msg.value)) {\n\n                 throw;\n             }\n         }\n     }\n\n\n     function f() {\n         if(msg.sender != b) { throw; }\n\n         for (uint i = 0; i < g.length; i++) {\n             GetBet(g[i].c, g[i].a, g[i].h);\n         }\n     }\n\n     function e() {\n         if(msg.sender != b) { throw; }\n\n         suicide(b);\n     }\n }",
      "rename_map": {
        "blockNumber": "a",
        "organizer": "b",
        "betAmount": "c",
        "makeBet": "d",
        "destroy": "e",
        "getBets": "f",
        "bets": "g",
        "won": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_148",
      "transformed_id": "ss_l2_short_nc_ds_148",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n\ncontract PredictTheBlockHashChallenge {\n\n    struct e{\n      uint block;\n      bytes32 e;\n    }\n\n    mapping(address => e) b;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function a(bytes32 f) public payable {\n        require(b[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        b[msg.sender].e = f;\n        b[msg.sender].block  = block.number + 1;\n    }\n\n    function c() public {\n        require(block.number > b[msg.sender].block);\n        bytes32 d = blockhash(b[msg.sender].block);\n\n        b[msg.sender].block = 0;\n        if (b[msg.sender].e == d) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
      "rename_map": {
        "lockInGuess": "a",
        "guesses": "b",
        "settle": "c",
        "answer": "d",
        "guess": "e",
        "hash": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_149",
      "transformed_id": "ss_l2_short_nc_ds_149",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\n\ncontract RandomNumberGenerator {\n  uint256 private c =  block.timestamp;\n\n  function b(uint e) view private returns (uint256 a) {\n\n    uint256 x = c * 100 / e;\n    uint256 y = c * block.number / (c % 5);\n    uint256 d = block.number / 3 + (c % 300) + y;\n    uint256 h = uint256(blockhash(d));\n\n    return uint256((h / x)) % e + 1;\n  }\n}",
      "rename_map": {
        "result": "a",
        "random": "b",
        "salt": "c",
        "seed": "d",
        "max": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_150",
      "transformed_id": "ss_l2_short_nc_ds_150",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address a;\n  uint b;\n\n  function c() payable {\n    require(msg.value > b);\n\n\n    if (a != 0) {\n\n      require(a.send(b));\n    }\n\n    a = msg.sender;\n    b         = msg.value;\n  }\n}",
      "rename_map": {
        "currentFrontrunner": "a",
        "currentBid": "b",
        "bid": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_151",
      "transformed_id": "ss_l2_short_nc_ds_151",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract GasAuction {\n\n    address[] a;\n    bool f = false;\n\n    function c() public {\n        if(a.length>1500) {\n            a = new address[](0);\n            f = true;\n        }\n    }\n\n    function d() public returns (bool) {\n        for(uint i=0;i<350;i++) {\n          a.push(msg.sender);\n        }\n        return true;\n    }\n\n    function e() public view returns (bool) {\n        return f;\n    }\n\n    function b() public view returns (uint) {\n        return a.length;\n    }\n}",
      "rename_map": {
        "creditorAddresses": "a",
        "numberCreditors": "b",
        "emptyCreditors": "c",
        "addCreditors": "d",
        "iWin": "e",
        "win": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_152",
      "transformed_id": "ss_l2_short_nc_ds_152",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract NumberRegistry {\n\n    uint d = 0;\n    uint[] array;\n\n    function b(uint value,uint f) public {\n\n        for(uint i=0;i<f;i++) {\n            if(d == array.length) {\n                array.length += 1;\n            }\n            array[d++] = value;\n        }\n    }\n\n    function g() public {\n        require(d>1500);\n        d = 0;\n    }\n\n    function e() public {\n\n\n        require(d>1500);\n        array = new uint[](0);\n        d = 0;\n    }\n\n    function c() public view returns(uint) {\n        return d;\n    }\n\n    function a() public view returns(uint) {\n        return array.length;\n    }\n}",
      "rename_map": {
        "getRealLengthArray": "a",
        "insertNnumbers": "b",
        "getLengthArray": "c",
        "numElements": "d",
        "clearDOS": "e",
        "numbers": "f",
        "clear": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_153",
      "transformed_id": "ss_l2_short_nc_ds_153",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract SingleFuncRegistry {\n\n    address[] a;\n\n    function b() public returns (bool){\n        if(a.length<1500) {\n            for(uint i=0;i<350;i++) {\n                a.push(msg.sender);\n            }\n            return true;\n\n        } else {\n            a = new address[](0);\n            return false;\n        }\n    }\n}",
      "rename_map": {
        "listAddresses": "a",
        "ifillArray": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_154",
      "transformed_id": "ss_l2_short_nc_ds_154",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract Government {\n\n\n     uint32 public b;\n     uint public d;\n     uint public i;\n     address[] public h;\n     uint[] public j;\n     address public m;\n     mapping (address => uint) o;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public s;\n\n     function Government() {\n\n\n         i = msg.value;\n         m = msg.sender;\n         d = block.timestamp;\n     }\n\n     function e(address r) returns (bool) {\n         uint q = msg.value;\n\n\n         if (d + TWELVE_HOURS < block.timestamp) {\n\n             msg.sender.send(q);\n\n             h[h.length - 1].send(i);\n             m.send(this.balance);\n\n             b = 0;\n             d = block.timestamp;\n             i = 0;\n             h = new address[](0);\n             j = new uint[](0);\n             s += 1;\n             return false;\n         }\n         else {\n\n             if (q >= 10 ** 18) {\n\n                 d = block.timestamp;\n\n                 h.push(msg.sender);\n                 j.push(q * 110 / 100);\n\n\n                 m.send(q * 5/100);\n\n                 if (i < 10000 * 10**18) {\n                     i += q * 5/100;\n                 }\n\n\n                 if(o[r] >= q) {\n                     r.send(q * 5/100);\n                 }\n                 o[msg.sender] += q * 110 / 100;\n\n                 if (j[b] <= address(this).balance - i) {\n                     h[b].send(j[b]);\n                     o[h[b]] -= j[b];\n                     b += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(q);\n                 return false;\n             }\n         }\n     }\n\n\n     function() {\n         e(0);\n     }\n\n     function n() returns (uint t) {\n         for(uint i=b; i<j.length; i++){\n             t += j[i];\n         }\n     }\n\n     function l() returns (uint p) {\n         for(uint i=0; i<b; i++){\n             p += j[i];\n         }\n     }\n\n\n     function g() {\n         i += msg.value;\n     }\n\n\n     function a(address k) {\n         if (msg.sender == m) {\n             m = k;\n         }\n     }\n\n     function c() returns (address[]) {\n         return h;\n     }\n\n     function f() returns (uint[]) {\n         return j;\n     }\n }",
      "rename_map": {
        "inheritToNextGeneration": "a",
        "lastCreditorPayedOut": "b",
        "getCreditorAddresses": "c",
        "lastTimeOfNewCredit": "d",
        "lendGovernmentMoney": "e",
        "getCreditorAmounts": "f",
        "investInTheSystem": "g",
        "creditorAddresses": "h",
        "profitFromCrash": "i",
        "creditorAmounts": "j",
        "nextGeneration": "k",
        "totalPayedOut": "l",
        "corruptElite": "m",
        "totalDebt": "n",
        "buddies": "o",
        "payout": "p",
        "amount": "q",
        "buddy": "r",
        "round": "s",
        "debt": "t"
      },
      "changes": [
        "Renamed 20 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_155",
      "transformed_id": "ss_l2_short_nc_ds_155",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.4.24;\n\ncontract Refunder {\n\naddress[] private a;\nmapping (address => uint) public c;\n\n    constructor() {\n        a.push(0x79B483371E87d664cd39491b5F06250165e4b184);\n        a.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n    }\n\n\n    function b() public {\n        for(uint x; x < a.length; x++) {\n            require(a[x].send(c[a[x]]));\n        }\n    }\n\n}",
      "rename_map": {
        "refundAddresses": "a",
        "refundAll": "b",
        "refunds": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_156",
      "transformed_id": "ss_l2_short_nc_ds_156",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n  function k(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  function o(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0);\n    uint256 c = a / b;\n\n\n    return c;\n  }\n\n  function m(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function n(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  function l(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\ncontract ERC20 {\n\n  event Transfer( address indexed from, address indexed p, uint256 value );\n  event Approval( address indexed j, address indexed i, uint256 value);\n  using SafeMath for *;\n\n  mapping (address => uint256) private f;\n\n  mapping (address => mapping (address => uint256)) private g;\n\n  uint256 private a;\n\n  constructor(uint c){\n    f[msg.sender] = c;\n  }\n\n  function e(address j) public view returns (uint256) {\n    return f[j];\n  }\n\n  function d(address j, address i) public view returns (uint256)\n  {\n    return g[j][i];\n  }\n\n  function transfer(address p, uint256 value) public returns (bool) {\n    require(value <= f[msg.sender]);\n    require(p != address(0));\n\n    f[msg.sender] = f[msg.sender].m(value);\n    f[p] = f[p].n(value);\n    emit Transfer(msg.sender, p, value);\n    return true;\n  }\n  function h(address i, uint256 value) public returns (bool) {\n    require(i != address(0));\n    g[msg.sender][i] = value;\n    emit Approval(msg.sender, i, value);\n    return true;\n  }\n\n  function b(address from, address p, uint256 value) public returns (bool) {\n    require(value <= f[from]);\n    require(value <= g[from][msg.sender]);\n    require(p != address(0));\n\n    f[from] = f[from].m(value);\n    f[p] = f[p].n(value);\n    g[from][msg.sender] = g[from][msg.sender].m(value);\n    emit Transfer(from, p, value);\n    return true;\n  }\n}",
      "rename_map": {
        "_totalSupply": "a",
        "transferFrom": "b",
        "totalSupply": "c",
        "allowance": "d",
        "balanceOf": "e",
        "_balances": "f",
        "_allowed": "g",
        "approve": "h",
        "spender": "i",
        "owner": "j",
        "mul": "k",
        "mod": "l",
        "sub": "m",
        "add": "n",
        "div": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_157",
      "transformed_id": "ss_l2_short_nc_ds_157",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.22;\n\ncontract FindThisHash {\n    bytes32 constant public d = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;\n\n    constructor() public payable {}\n\n    function b(string a) public {\n\n        require(d == c(a));\n        msg.sender.transfer(1000 ether);\n    }\n}",
      "rename_map": {
        "solution": "a",
        "solve": "b",
        "sha3": "c",
        "hash": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_158",
      "transformed_id": "ss_l2_short_nc_ds_158",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n    address public f;\n    bool public d;\n    uint public e;\n\n    function EthTxOrderDependenceMinimal() public {\n        f = msg.sender;\n    }\n\n    function c() public payable {\n        require (!d);\n\n        require(msg.sender == f);\n        f.transfer(e);\n        e = msg.value;\n    }\n\n    function a(uint256 b) {\n        require (!d);\n        require(b < 10);\n        msg.sender.transfer(e);\n        d = true;\n    }\n}",
      "rename_map": {
        "claimReward": "a",
        "submission": "b",
        "setReward": "c",
        "claimed": "d",
        "reward": "e",
        "owner": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_159",
      "transformed_id": "ss_l2_short_nc_ds_159",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.2;\n\ncontract OddsAndEvens{\n\n  struct Player {\n    address e;\n    uint number;\n  }\n\n  Player[2] public c;\n\n  uint8 g;\n  address d;\n\n  function OddsAndEvens() {\n    d = msg.sender;\n  }\n  function f(uint number) payable{\n    if (msg.value != 1 ether) throw;\n    c[g] = Player(msg.sender, number);\n    g++;\n\n    if (g==2) a();\n  }\n\n  function a() private {\n    bool h ;\n    uint n = c[0].number+c[1].number;\n    if (n%2==0) {\n      h = c[0].e.send(1800 finney);\n    }\n    else {\n      h = c[1].e.send(1800 finney);\n    }\n\n    delete c;\n    g=0;\n  }\n\n  function b() {\n    if(msg.sender!=d) throw;\n    bool h = msg.sender.send(this.balance);\n  }\n\n}",
      "rename_map": {
        "andTheWinnerIs": "a",
        "getProfit": "b",
        "players": "c",
        "owner": "d",
        "addr": "e",
        "play": "f",
        "tot": "g",
        "res": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_160",
      "transformed_id": "ss_l2_short_nc_ds_160",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\n\ncontract CryptoRoulette {\n\n    uint256 private a;\n    uint256 public c;\n    uint256 public e = 0.1 ether;\n    address public d;\n\n    struct Game {\n        address g;\n        uint256 number;\n    }\n    Game[] public b;\n\n    function CryptoRoulette() public {\n        d = msg.sender;\n        f();\n    }\n\n    function f() internal {\n\n        a = uint8(j(l, block.blockhash(block.number-1))) % 20 + 1;\n    }\n\n    function k(uint256 number) payable public {\n        require(msg.value >= e && number <= 10);\n        Game i;\n        i.g = msg.sender;\n        i.number = number;\n        b.push(i);\n\n        if (number == a) {\n\n            msg.sender.transfer(this.balance);\n        }\n\n        f();\n        c = l;\n    }\n\n    function h() public {\n        if (msg.sender == d && l > c + 1 days) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n}",
      "rename_map": {
        "secretNumber": "a",
        "gamesPlayed": "b",
        "lastPlayed": "c",
        "ownerAddr": "d",
        "betPrice": "e",
        "shuffle": "f",
        "player": "g",
        "kill": "h",
        "game": "i",
        "sha3": "j",
        "play": "k",
        "now": "l"
      },
      "changes": [
        "Renamed 12 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_161",
      "transformed_id": "ss_l2_short_nc_ds_161",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract NameRegistrar {\n\n    bool public f = false;\n\n    struct NameRecord {\n        bytes32 i;\n        address c;\n    }\n\n    mapping(address => NameRecord) public a;\n    mapping(bytes32 => address) public g;\n\n    function e(bytes32 h, address b) public {\n\n        NameRecord d;\n        d.i = h;\n        d.c = b;\n\n        g[h] = b;\n        a[msg.sender] = d;\n\n        require(f);\n    }\n}",
      "rename_map": {
        "registeredNameRecord": "a",
        "_mappedAddress": "b",
        "mappedAddress": "c",
        "newRecord": "d",
        "register": "e",
        "unlocked": "f",
        "resolve": "g",
        "_name": "h",
        "name": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_162",
      "transformed_id": "ss_l2_short_nc_ds_162",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint j;\n        uint e;\n        uint g;\n        uint i;\n    }\n\n    address n;\n    uint private d;\n    uint private f;\n    uint LuckyNumber = 7;\n\n    mapping (address => bool) l;\n\n    function OpenAddressLottery() {\n        n = msg.sender;\n        m(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n    }\n\n    function b() payable {\n        if(msg.value<0.1 ether)\n            return;\n\n\n        require(l[msg.sender] == false);\n\n        if(a(msg.sender) == LuckyNumber){\n            l[msg.sender] = true;\n\n            uint q=msg.value*7;\n\n            if(q>this.balance)\n                q=this.balance;\n            msg.sender.transfer(q);\n        }\n\n        if(block.number-f>1000)\n            m(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n    }\n\n    function a(address p) constant returns(uint n){\n\n        n = uint(k(uint(p), d)[0]) % 8;\n    }\n\n    function m(SeedComponents h) internal {\n        d = uint256(k(\n            h.j,\n            h.e,\n            h.g,\n            h.i\n        ));\n        f = block.number;\n    }\n\n    function o() {\n        require(msg.sender==n);\n\n        selfdestruct(msg.sender);\n    }\n\n    function c() {\n        require(msg.sender==n);\n        SeedComponents s;\n        s.j = uint(msg.sender);\n        s.e = uint256(block.blockhash(block.number - 1));\n        s.g = block.difficulty*(uint)(block.coinbase);\n        s.i = tx.gasprice * 7;\n\n        m(s);\n    }\n\n    function () payable {\n        if(msg.value>=0.1 ether && msg.sender!=n)\n            b();\n    }\n\n}",
      "rename_map": {
        "luckyNumberOfAddress": "a",
        "participate": "b",
        "forceReseed": "c",
        "secretSeed": "d",
        "component2": "e",
        "lastReseed": "f",
        "component3": "g",
        "components": "h",
        "component4": "i",
        "component1": "j",
        "keccak256": "k",
        "winner": "l",
        "reseed": "m",
        "owner": "n",
        "kill": "o",
        "addr": "p",
        "win": "q"
      },
      "changes": [
        "Renamed 17 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_163",
      "transformed_id": "ss_l2_short_nc_ds_163",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.11;\n\n contract MyToken {\n     mapping (address => uint) d;\n\n     event Transfer(address indexed g, address indexed i, uint256 f);\n\n     function MyToken() {\n         d[tx.origin] = 10000;\n     }\n     function c(address j, uint e) returns(bool b) {\n         if (d[msg.sender] < e) return false;\n         d[msg.sender] -= e;\n         d[j] += e;\n         Transfer(msg.sender, j, e);\n         return true;\n     }\n\n     function a(address h) constant returns(uint) {\n         return d[h];\n     }\n }",
      "rename_map": {
        "getBalance": "a",
        "sufficient": "b",
        "sendCoin": "c",
        "balances": "d",
        "amount": "e",
        "_value": "f",
        "_from": "g",
        "addr": "h",
        "_to": "i",
        "to": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_164",
      "transformed_id": "ss_l2_short_nc_ds_164",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n\ncontract EtherLotto {\n\n\n    uint constant TICKET_AMOUNT = 10;\n\n\n    uint constant FEE_AMOUNT = 1;\n\n\n    address public c;\n\n\n    uint public e;\n\n\n    function EtherLotto() {\n        c = msg.sender;\n    }\n\n\n    function d() payable {\n\n\n        assert(msg.value == TICKET_AMOUNT);\n\n\n        e += msg.value;\n\n\n        var a = uint(b(block.timestamp)) % 2;\n\n\n        if (a == 0) {\n\n\n            c.transfer(FEE_AMOUNT);\n\n\n            msg.sender.transfer(e - FEE_AMOUNT);\n\n\n            e = 0;\n        }\n    }\n\n}",
      "rename_map": {
        "random": "a",
        "sha3": "b",
        "bank": "c",
        "play": "d",
        "pot": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_165",
      "transformed_id": "ss_l2_short_nc_ds_165",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract Governmental {\n  address public h;\n  address public c;\n  uint public e = 1 ether;\n  uint public a;\n  uint public ONE_MINUTE = 1 minutes;\n\n  function Governmental() {\n    h = msg.sender;\n    if (msg.value<1 ether) throw;\n  }\n\n  function f() {\n    if (msg.value<e/2) throw;\n    c = msg.sender;\n    e += msg.value/2;\n    a = block.timestamp;\n  }\n\n  function b() {\n    if (block.timestamp < a+ONE_MINUTE)\n      throw;\n\n    c.send(e);\n    h.send(this.balance-1 ether);\n\n    c = 0;\n    e = 1 ether;\n    a = 0;\n  }\n}\n\ncontract Operator {\n\n  function d(address g, uint i) {\n    if (0<=i && i<1023) {\n      this.d.gas(msg.gas-2000)(g, i+1);\n    }\n    else {\n      Governmental(g).b();\n    }\n  }\n}",
      "rename_map": {
        "lastInvestmentTimestamp": "a",
        "resetInvestment": "b",
        "lastInvestor": "c",
        "operate": "d",
        "jackpot": "e",
        "invest": "f",
        "target": "g",
        "owner": "h",
        "count": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_166",
      "transformed_id": "ss_l2_short_nc_ds_166",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract b {\n  address e;\n  uint    timestamp;\n  function d(uint h) internal {\n    if ( h> 0 && i - h > 24 hours ) {\n      msg.sender.send( msg.value );\n\n      if ( this.balance > 0 ) {\n        e.send( this.balance );\n      }\n    }\n    else if ( msg.value >= 1 ether ) {\n      e = msg.sender;\n      timestamp = h;\n    }\n  }\n  function c() constant returns (uint a) {\n      return block.timestamp;\n    }\n  function f(uint g){\n    uint a=c();\n    d(a);\n  }\n}",
      "rename_map": {
        "randomNumber": "a",
        "lottopollo": "b",
        "randomGen": "c",
        "payOut": "d",
        "leader": "e",
        "draw": "f",
        "seed": "g",
        "rand": "h",
        "now": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_167",
      "transformed_id": "ss_l2_short_nc_ds_167",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract Roulette {\n    uint public a;\n\n    constructor() public payable {}\n\n\n    function () public payable {\n        require(msg.value == 10 ether);\n        require(b != a);\n        a = b;\n        if(b % 15 == 0) {\n            msg.sender.transfer(this.balance);\n        }\n    }\n}",
      "rename_map": {
        "pastBlockTime": "a",
        "now": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_168",
      "transformed_id": "ss_l2_short_nc_ds_168",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract TimedCrowdsale {\n\n  function a() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n}",
      "rename_map": {
        "isSaleFinished": "a"
      },
      "changes": [
        "Renamed 1 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_169",
      "transformed_id": "ss_l2_short_nc_ds_169",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\ncontract TownCrier {\n    struct Request {\n        address p;\n        uint ai;\n        address e;\n        bytes4 g;\n        bytes32 k;\n    }\n\n    event Upgrade(address z);\n    event Reset(uint q, uint w, uint b);\n    event RequestInfo(uint64 aj, uint8 f, address p, uint ai, address e, bytes32 k, uint timestamp, bytes32[] i);\n    event DeliverInfo(uint64 n, uint ai, uint gasPrice, uint ab, uint h, bytes32 k, uint64 error, bytes32 t);\n    event Cancel(uint64 n, address o, address p, uint ai, int ah);\n\n    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;\n\n    uint public GAS_PRICE = 5 * 10**10;\n    uint public MIN_FEE = 30000 * GAS_PRICE;\n    uint public CANCELLATION_FEE = 25000 * GAS_PRICE;\n\n    uint public constant CANCELLED_FEE_FLAG = 1;\n    uint public constant DELIVERED_FEE_FLAG = 0;\n    int public constant FAIL_FLAG = -2 ** 250;\n    int public constant SUCCESS_FLAG = 1;\n\n    bool public l;\n\n    bool public a;\n\n    uint64 public j;\n    uint64 public d;\n    Request[2**64] public s;\n\n    int public m = 0;\n\n\n    function () {}\n\n    function TownCrier() public {\n\n\n        j = 1;\n        s[0].p = msg.sender;\n        l = false;\n        d = 0;\n        a = false;\n    }\n\n    function aa(address z) {\n        if (msg.sender == s[0].p && d == 0) {\n            m = -int(z);\n            l = true;\n            Upgrade(z);\n        }\n    }\n\n    function af(uint ae, uint ac, uint c) public {\n        if (msg.sender == s[0].p && d == 0) {\n            GAS_PRICE = ae;\n            MIN_FEE = ae * ac;\n            CANCELLATION_FEE = ae * c;\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n        }\n    }\n\n    function y() public {\n        if (msg.sender == s[0].p) {\n            l = true;\n        }\n    }\n\n    function x() public {\n        if (msg.sender == s[0].p && m == 0) {\n            l = false;\n        }\n    }\n\n    function r() public {\n        if (msg.sender == s[0].p && d == 0) {\n            if (!s[0].p.call.value(this.balance)()) {\n                throw;\n            }\n        }\n    }\n\n    function u(uint8 f, address e, bytes4 g, uint timestamp, bytes32[] i) public payable returns (int) {\n        if (a) {\n            throw;\n        }\n\n        if (l) {\n            a = true;\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            a = false;\n            return m;\n        }\n\n        if (msg.value < MIN_FEE) {\n            a = true;\n\n\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            a = false;\n            return FAIL_FLAG;\n        } else {\n\n            uint64 n = j;\n            j++;\n            d++;\n\n            bytes32 k = ag(f, i);\n            s[n].p = msg.sender;\n            s[n].ai = msg.value;\n            s[n].e = e;\n            s[n].g = g;\n            s[n].k = k;\n\n\n            RequestInfo(n, f, msg.sender, msg.value, e, k, timestamp, i);\n            return n;\n        }\n    }\n\n    function v(uint64 n, bytes32 k, uint64 error, bytes32 t) public {\n        if (msg.sender != SGX_ADDRESS ||\n                n <= 0 ||\n                s[n].p == 0 ||\n                s[n].ai == DELIVERED_FEE_FLAG) {\n\n\n            return;\n        }\n\n        uint ai = s[n].ai;\n        if (s[n].k != k) {\n\n\n            return;\n        } else if (ai == CANCELLED_FEE_FLAG) {\n\n\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            s[n].ai = DELIVERED_FEE_FLAG;\n            d--;\n            return;\n        }\n\n        s[n].ai = DELIVERED_FEE_FLAG;\n        d--;\n\n        if (error < 2) {\n\n\n            SGX_ADDRESS.send(ai);\n        } else {\n\n            a = true;\n            s[n].p.call.gas(2300).value(ai)();\n            a = false;\n        }\n\n        uint h = (ai - MIN_FEE) / tx.gasprice;\n        DeliverInfo(n, ai, tx.gasprice, msg.gas, h, k, error, t);\n        if (h > msg.gas - 5000) {\n            h = msg.gas - 5000;\n        }\n\n        a = true;\n        s[n].e.call.gas(h)(s[n].g, n, error, t);\n        a = false;\n    }\n\n    function ad(uint64 n) public returns (int) {\n        if (a) {\n            throw;\n        }\n\n        if (l) {\n            return 0;\n        }\n\n        uint ai = s[n].ai;\n        if (s[n].p == msg.sender && ai >= CANCELLATION_FEE) {\n\n\n            s[n].ai = CANCELLED_FEE_FLAG;\n            a = true;\n            if (!msg.sender.call.value(ai - CANCELLATION_FEE)()) {\n                throw;\n            }\n            a = false;\n            Cancel(n, msg.sender, s[n].p, s[n].ai, 1);\n            return SUCCESS_FLAG;\n        } else {\n            Cancel(n, msg.sender, s[n].p, ai, -1);\n            return FAIL_FLAG;\n        }\n    }\n}",
      "rename_map": {
        "externalCallFlag": "a",
        "cancellation_fee": "b",
        "cancellationGas": "c",
        "unrespondedCnt": "d",
        "callbackAddr": "e",
        "requestType": "f",
        "callbackFID": "g",
        "callbackGas": "h",
        "requestData": "i",
        "requestCnt": "j",
        "paramsHash": "k",
        "killswitch": "l",
        "newVersion": "m",
        "requestId": "n",
        "canceller": "o",
        "requester": "p",
        "gas_price": "q",
        "withdraw": "r",
        "requests": "s",
        "respData": "t",
        "request": "u",
        "deliver": "v",
        "min_fee": "w",
        "restart": "x",
        "suspend": "y",
        "newAddr": "z",
        "upgrade": "aa",
        "gasLeft": "ab",
        "minGas": "ac",
        "cancel": "ad",
        "price": "ae",
        "reset": "af",
        "sha3": "ag",
        "flag": "ah",
        "fee": "ai",
        "id": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_170",
      "transformed_id": "ss_l2_short_nc_ds_170",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\n\ncontract Owned {\n\n\n    modifier m() {\n        require(msg.sender == z);\n        _;\n    }\n\n    address public z;\n\n\n    function Owned() {\n        z = msg.sender;\n    }\n\n    address public q;\n\n\n    function h(address n) m {\n        q = n;\n    }\n\n\n    function c() {\n        if (msg.sender == q) {\n            z = q;\n        }\n    }\n\n\n    function v(address ah, uint x, bytes ab) m {\n        ah.call.value(x)(ab);\n    }\n}\n\ncontract Marriage is Owned\n{\n\n    string public t;\n    string public s;\n    uint public f;\n    string public e;\n    string public ae;\n\n    Event[] public i;\n    Message[] public r;\n\n    struct Event {\n        uint ag;\n        string ad;\n        string g;\n        string ai;\n    }\n\n    struct Message {\n        uint ag;\n        string u;\n        string af;\n        string ai;\n        uint value;\n    }\n\n    modifier k {\n        require(ac(e) == ac(\"Married\"));\n        _;\n    }\n\n\n    function Marriage(address w) {\n        z = w;\n    }\n\n    function a() constant public returns (uint) {\n        return i.length;\n    }\n\n    function b() constant public returns (uint) {\n        return r.length;\n    }\n\n\n    function d(\n        string p,\n        string l,\n        string aa,\n        string ai) m\n    {\n        require(i.length == 0);\n        t = p;\n        s = l;\n        f = aj;\n        ae = aa;\n        e = \"Married\";\n        i.push(Event(aj, \"Marriage\", ae, ai));\n        MajorEvent(\"Marrigage\", ae, ai);\n    }\n\n\n    function o(string y, string ai) m\n    {\n        e = y;\n        setMajorEvent(\"Changed Status\", y, ai);\n    }\n\n\n    function setMajorEvent(string ad, string g, string ai) m k\n    {\n        i.push(Event(aj, ad, g, ai));\n        MajorEvent(ad, g, ai);\n    }\n\n    function j(string u, string af, string ai) payable k {\n        if (msg.value > 0) {\n            z.transfer(this.balance);\n        }\n        r.push(Message(aj, u, af, ai, msg.value));\n        MessageSent(u, af, ai, msg.value);\n    }\n\n\n    event MajorEvent(string ad, string g, string ai);\n    event MessageSent(string ad, string g, string ai, uint value);\n}",
      "rename_map": {
        "numberOfMajorEvents": "a",
        "numberOfMessages": "b",
        "acceptOwnership": "c",
        "createMarriage": "d",
        "marriageStatus": "e",
        "marriageDate": "f",
        "description": "g",
        "changeOwner": "h",
        "majorEvents": "i",
        "sendMessage": "j",
        "areMarried": "k",
        "_partner2": "l",
        "onlyOwner": "m",
        "_newOwner": "n",
        "setStatus": "o",
        "_partner1": "p",
        "newOwner": "q",
        "messages": "r",
        "partner2": "s",
        "partner1": "t",
        "nameFrom": "u",
        "execute": "v",
        "_owner": "w",
        "_value": "x",
        "status": "y",
        "owner": "z",
        "_vows": "aa",
        "_data": "ab",
        "sha3": "ac",
        "name": "ad",
        "vows": "ae",
        "text": "af",
        "date": "ag",
        "_dst": "ah",
        "url": "ai",
        "now": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_171",
      "transformed_id": "ss_l2_short_nc_ds_171",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract Splitter{\n\n\taddress public m;\n\taddress[] public h;\n\tmapping (uint256 => address) public n;\n\taddress private o;\n\tuint256 private j;\n\tuint256 private k;\n\n\n\tconstructor() payable public{\n\t\tm = msg.sender;\n\t\te();\n\t\te();\n\t\te();\n\t\te();\n\t\tn[0] = h[0];\n        n[1] = h[1];\n        n[2] = h[2];\n        n[3] = h[3];\n\t}\n\n\n\tfunction f() public{\n\t\trequire(msg.sender == m);\n\t\tm.transfer(address(this).balance);\n\t}\n\n\n\tfunction a() public constant returns(uint256 b){\n    \treturn h.length;\n  \t}\n\n\n\tfunction e() public returns(address e){\n\t    require(msg.sender == m);\n    \tPuppet p = new Puppet();\n    \th.push(p);\n    \treturn p;\n  \t\t}\n\n\n    function g(uint256 q, address d) public {\n        require(d != address(0));\n        n[q] = d;\n    }\n\n\n    function c() public payable {\n        require(msg.sender == m);\n    \tj = SafeMath.t(msg.value, 4);\n        n[0].call.value(j).gas(800000)();\n        n[1].call.value(j).gas(800000)();\n        n[2].call.value(j).gas(800000)();\n        n[3].call.value(j).gas(800000)();\n        }\n\n\nfunction() payable public{\n\t}\n}\n\ncontract Puppet {\n\n    mapping (uint256 => address) public l;\n    mapping (uint256 => address) public i;\n\n\tconstructor() payable public{\n\n\t\tl[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        i[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\n\n\tfunction() public payable{\n\t    if(msg.sender != l[0]){\n\t\t\tl[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\n\n\tfunction f() public{\n\t\trequire(msg.sender == i[0]);\n\t\ti[0].transfer(address(this).balance);\n\t}\n}\n\n\nlibrary SafeMath {\n\n  function p(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function t(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function r(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function s(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
      "rename_map": {
        "getPuppetCount": "a",
        "puppetCount": "b",
        "fundPuppets": "c",
        "_newExtra": "d",
        "newPuppet": "e",
        "withdraw": "f",
        "setExtra": "g",
        "puppets": "h",
        "master": "i",
        "_share": "j",
        "_count": "k",
        "target": "l",
        "owner": "m",
        "extra": "n",
        "_addy": "o",
        "mul": "p",
        "_id": "q",
        "sub": "r",
        "add": "s",
        "div": "t"
      },
      "changes": [
        "Renamed 20 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_172",
      "transformed_id": "ss_l2_short_nc_ds_172",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract FundManager {\n\n\naddress public z = 0x0;\naddress public ad;\naddress public j = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public g = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public x;\n\nmapping(address=>bool) d;\n\nuint256 public aa;\nuint256[] public ah = [951828771,158769871220];\nuint256[] public balance;\n\n\nfunction DranMe() public payable{\n\tad = msg.sender;\n}\n\n\nmodifier o() {\n    require(msg.sender == ad);\n    _;\n}\n\nmodifier m() {\n    require(msg.sender == z);\n    _;\n}\n\nmodifier k() {\n    require(d[msg.sender]);\n    _;\n}\n\n\nfunction n() public constant returns(uint256) {\n\treturn ah.length;\n}\n\nfunction r(uint256 v) public payable o{\n\taa = v;\n}\n\nfunction e() public constant returns(uint256) {\n\treturn x.length;\n}\n\nfunction t() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction f() public payable{\n\trequire(msg.value >= 0.02 ether);\n\tx.push(msg.sender);\n\td[msg.sender]=true;\n}\n\nfunction b() public payable k{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=ad || h()){\n\t    uint256 y = 0;\n        msg.sender.transfer(y);\n\t}\n}\n\nfunction h() private returns(bool){\n    bytes32 af = q(blockhash(block.number-1));\n    uint256 aa = uint256(af);\n        if(aa%5==0){\n            z = msg.sender;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction c () public payable k {\n\trequire (msg.value >= 0.005 ether);\n\tj.call.value(msg.value)();\n}\n\nfunction a () public payable k {\n\trequire (msg.value >= 0.005 ether);\n\tg.call.value(msg.value)();\n}\n\nfunction u (uint256 ac, uint256 ab) public payable k {\n\tah[ac] = ab;\n}\n\nfunction w (uint256 ag) public payable k {\n\tah.length = ag;\n}\n\nfunction p (uint256 ae) public payable k returns(uint256) {\n\treturn (ae / (ah[0]*ah[1]));\n\tif((ae / (ah[0]*ah[1])) == aa) {\n\t\tad = z;\n\t}\n}\n\nfunction i () public payable k returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == aa){\n        return true;\n    }\n}\n\nfunction s() public payable o {\n\tad.call.value(1 wei)();\n}\n\nfunction l() public payable m {\n\tz.transfer(address(this).balance);\n}\n\n\nfunction() public payable{\n\t}\n}",
      "rename_map": {
        "callSecondTarget": "a",
        "manipulateSecret": "b",
        "callFirstTarget": "c",
        "approvedPlayers": "d",
        "getPlayerCount": "e",
        "becomePlayer": "f",
        "secondTarget": "g",
        "unlockSecret": "h",
        "checkSecret": "i",
        "firstTarget": "j",
        "onlyPlayers": "k",
        "claimPrize": "l",
        "onlyWinner": "m",
        "getLength": "n",
        "onlyOwner": "o",
        "guessSeed": "p",
        "keccak256": "q",
        "setSecret": "r",
        "winPrize": "s",
        "getPrize": "t",
        "setSeed": "u",
        "_secret": "v",
        "addSeed": "w",
        "players": "x",
        "amount": "y",
        "winner": "z",
        "secret": "aa",
        "_value": "ab",
        "_index": "ac",
        "owner": "ad",
        "_seed": "ae",
        "hash": "af",
        "_add": "ag",
        "seed": "ah"
      },
      "changes": [
        "Renamed 34 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_173",
      "transformed_id": "ss_l2_short_nc_ds_173",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.11;\n\ncontract Owned {\n    function Owned() {\n        n = msg.sender;\n    }\n\n    address public n;\n\n\n    modifier f { if (msg.sender == n) _; }\n\n    function c(address g) f {\n        n = g;\n    }\n\n\n    function i(address u, uint l, bytes q) f {\n        u.call.value(l)(q);\n    }\n}\n\ncontract Token {\n    function transfer(address, uint) returns(bool);\n    function h(address) constant returns (uint);\n}\n\ncontract TokenSender is Owned {\n    Token public p;\n    uint public a;\n\n    uint public v;\n\n    struct Transfer {\n        address t;\n        uint j;\n    }\n\n    Transfer[] public e;\n\n    function TokenSender(address m) {\n        p = Token(m);\n    }\n\n\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n\n\n    function r(uint[] data) f {\n\n\n        if (v>0) throw;\n\n        uint x;\n        uint k = e.length;\n        e.length = e.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address t = address( data[i] & (D160-1) );\n            uint j = data[i] / D160;\n\n            e[k + i].t = t;\n            e[k + i].j = j;\n            x += j;\n        }\n        a += x;\n    }\n\n\n    function w() f {\n        if (e.length == 0) return;\n\n\n        uint o = v;\n\n        v = e.length;\n\n        if ((o == 0 ) && ( p.h(this) != a)) throw;\n\n        while ((o<e.length) && ( gas() > 150000 )) {\n            uint j = e[o].j;\n            address t = e[o].t;\n            if (j > 0) {\n                if (!p.transfer(t, e[o].j)) throw;\n            }\n            o ++;\n        }\n\n\n        v = o;\n    }\n\n\n    function b() constant returns (bool) {\n        if (e.length == 0) return false;\n        if (v < e.length) return false;\n        return true;\n    }\n\n    function d() constant returns (uint) {\n        return e.length;\n    }\n\n    function gas() internal constant returns (uint s) {\n        assembly {\n            s:= gas\n        }\n    }\n\n}",
      "rename_map": {
        "totalToDistribute": "a",
        "hasTerminated": "b",
        "changeOwner": "c",
        "nTransfers": "d",
        "transfers": "e",
        "onlyOwner": "f",
        "_newOwner": "g",
        "balanceOf": "h",
        "execute": "i",
        "amount": "j",
        "offset": "k",
        "_value": "l",
        "_token": "m",
        "owner": "n",
        "mNext": "o",
        "token": "p",
        "_data": "q",
        "fill": "r",
        "_gas": "s",
        "addr": "t",
        "_dst": "u",
        "next": "v",
        "run": "w",
        "acc": "x"
      },
      "changes": [
        "Renamed 24 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_174",
      "transformed_id": "ss_l2_short_nc_ds_174",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract Lotto {\n\n     uint constant public l = 6800;\n\n\n     uint constant public u = 100000000000000000;\n\n\n     uint constant public r = 5000000000000000000;\n\n     function f() constant returns(uint){ return l; }\n     function k() constant returns(uint){ return u; }\n\n\n     struct Round {\n         address[] ae;\n         uint ai;\n         uint o;\n         mapping(uint=>bool) aa;\n         mapping(address=>uint) d;\n     }\n     mapping(uint => Round) ab;\n\n\n     function m() constant returns (uint){\n\n\n         return block.number/l;\n     }\n\n     function s(uint w,uint t) constant returns (bool){\n\n\n         return ab[w].aa[t];\n     }\n\n     function i(uint w, uint t) constant returns(address){\n\n\n         var c = a(w,t);\n\n         if(c>block.number)\n             return;\n\n\n         var g = j(c);\n         var e = g%ab[w].o;\n\n\n         var q = uint256(0);\n\n         for(var x = 0; x<ab[w].ae.length; x++){\n             var ag = ab[w].ae[x];\n             q+=ab[w].d[ag];\n\n             if(q>e){\n                 return ag;\n             }\n         }\n     }\n\n     function a(uint w,uint t) constant returns (uint){\n         return ((w+1)*l)+t;\n     }\n\n     function h(uint w) constant returns(uint){\n         var n = ab[w].ai/r;\n\n         if(ab[w].ai%r>0)\n             n++;\n\n         return n;\n     }\n\n     function z(uint w) constant returns(uint){\n         return ab[w].ai/h(w);\n     }\n\n     function ah(uint w, uint t){\n\n         var n = h(w);\n\n         if(t>=n)\n             return;\n\n         var c = a(w,t);\n\n         if(c>block.number)\n             return;\n\n         if(ab[w].aa[t])\n             return;\n\n\n         var ac = i(w,t);\n         var ad = z(w);\n\n         ac.send(ad);\n\n         ab[w].aa[t] = true;\n\n     }\n\n     function j(uint v) constant returns(uint){\n         return uint(block.blockhash(v));\n     }\n\n     function y(uint w,address ag) constant returns (address[]){\n         return ab[w].ae;\n     }\n\n     function b(uint w,address ag) constant returns (uint){\n         return ab[w].d[ag];\n     }\n\n     function af(uint w) constant returns(uint){\n         return ab[w].ai;\n     }\n\n     function() {\n\n\n         var w = m();\n         var value = msg.value-(msg.value%u);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n             msg.sender.send(msg.value-value);\n         }\n\n\n         var o = value/u;\n         ab[w].o+=o;\n\n         if(ab[w].d[msg.sender]==0){\n             var p = ab[w].ae.length++;\n             ab[w].ae[p] = msg.sender;\n         }\n\n         ab[w].d[msg.sender]+=o;\n         ab[w].o+=o;\n\n\n         ab[w].ai+=value;\n\n\n     }\n\n }",
      "rename_map": {
        "getDecisionBlockNumber": "a",
        "getTicketsCountByBuyer": "b",
        "decisionBlockNumber": "c",
        "ticketsCountByBuyer": "d",
        "winningTicketIndex": "e",
        "getBlocksPerRound": "f",
        "decisionBlockHash": "g",
        "getSubpotsCount": "h",
        "calculateWinner": "i",
        "getHashOfBlock": "j",
        "getTicketPrice": "k",
        "blocksPerRound": "l",
        "getRoundIndex": "m",
        "subpotsCount": "n",
        "ticketsCount": "o",
        "buyersLength": "p",
        "ticketIndex": "q",
        "blockReward": "r",
        "getIsCashed": "s",
        "subpotIndex": "t",
        "ticketPrice": "u",
        "blockIndex": "v",
        "roundIndex": "w",
        "buyerIndex": "x",
        "getBuyers": "y",
        "getSubpot": "z",
        "isCashed": "aa",
        "rounds": "ab",
        "winner": "ac",
        "subpot": "ad",
        "buyers": "ae",
        "getPot": "af",
        "buyer": "ag",
        "cash": "ah",
        "pot": "ai"
      },
      "changes": [
        "Renamed 35 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_201",
      "transformed_id": "ss_l2_short_nc_ds_201",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address d)\n    {\n        TransferLog = Log(d);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    {\n        if(f<=a[msg.sender])\n        {\n\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address c,uint e,string b)\n    public\n    {\n        LastMsg.Sender = c;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_adr": "c",
        "_log": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_202",
      "transformed_id": "ss_l2_short_nc_ds_202",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Multiplicator\n{\n    address public Owner = msg.sender;\n\n    function()payable{}\n\n    function b()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function a(address c)\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            c.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "a",
        "withdraw": "b",
        "adr": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_203",
      "transformed_id": "ss_l2_short_nc_ds_203",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\n\ncontract Ownable {\n    address public d;\n    function Ownable() public {d = msg.sender;}\n    modifier b() {require(msg.sender == d); _;\n    }\n}\n\n\ncontract CEOThrone is Ownable {\n    address public d;\n    uint public a;\n\n\n    function Stake() public payable {\n\n        if (msg.value > a) {\n            d = msg.sender;\n            a = msg.value;\n        }\n    }\n\n    function c() public b {\n\n        msg.sender.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "largestStake": "a",
        "onlyOwner": "b",
        "withdraw": "c",
        "owner": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_204",
      "transformed_id": "ss_l2_short_nc_ds_204",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "contract OpenAddressLottery{\n    struct SeedComponents{\n        uint j;\n        uint e;\n        uint g;\n        uint i;\n    }\n\n    address n;\n    uint private d;\n    uint private f;\n    uint LuckyNumber = 7;\n\n    mapping (address => bool) l;\n\n    function OpenAddressLottery() {\n        n = msg.sender;\n        m(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n    }\n\n    function b() payable {\n        if(msg.value<0.1 ether)\n            return;\n\n\n        require(l[msg.sender] == false);\n\n        if(a(msg.sender) == LuckyNumber){\n            l[msg.sender] = true;\n\n            uint q=msg.value*7;\n\n            if(q>this.balance)\n                q=this.balance;\n            msg.sender.transfer(q);\n        }\n\n        if(block.number-f>1000)\n            m(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n    }\n\n    function a(address p) constant returns(uint n){\n\n        n = uint(k(uint(p), d)[0]) % 8;\n    }\n\n    function m(SeedComponents h) internal {\n        d = uint256(k(\n            h.j,\n            h.e,\n            h.g,\n            h.i\n        ));\n        f = block.number;\n    }\n\n    function o() {\n        require(msg.sender==n);\n\n        selfdestruct(msg.sender);\n    }\n\n    function c() {\n        require(msg.sender==n);\n\n        SeedComponents s;\n        s.j = uint(msg.sender);\n        s.e = uint256(block.blockhash(block.number - 1));\n        s.g = block.difficulty*(uint)(block.coinbase);\n        s.i = tx.gasprice * 7;\n\n        m(s);\n    }\n\n    function () payable {\n        if(msg.value>=0.1 ether && msg.sender!=n)\n            b();\n    }\n\n}",
      "rename_map": {
        "luckyNumberOfAddress": "a",
        "participate": "b",
        "forceReseed": "c",
        "secretSeed": "d",
        "component2": "e",
        "lastReseed": "f",
        "component3": "g",
        "components": "h",
        "component4": "i",
        "component1": "j",
        "keccak256": "k",
        "winner": "l",
        "reseed": "m",
        "owner": "n",
        "kill": "o",
        "addr": "p",
        "win": "q"
      },
      "changes": [
        "Renamed 17 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_205",
      "transformed_id": "ss_l2_short_nc_ds_205",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract NEW_YEARS_GIFT\n{\n    string d;\n\n    bool a = false;\n\n    address sender;\n\n    bytes32 public c;\n\n    function() public payable{}\n\n    function GetHash(bytes g) public constant returns (bytes32) {return f(g);}\n\n    function SetPass(bytes32 e)\n    public\n    payable\n    {\n        if( (!a&&(msg.value > 1 ether)) || c==0x0 )\n        {\n            c = e;\n            sender = msg.sender;\n        }\n    }\n\n    function SetMessage(string b)\n    public\n    {\n        if(msg.sender==sender)\n        {\n            d =b;\n        }\n    }\n\n    function GetGift(bytes g)\n    external\n    payable\n    returns (string)\n    {\n        if(c == f(g))\n        {\n            msg.sender.transfer(this.balance);\n            return d;\n        }\n    }\n\n    function Revoce()\n    public\n    payable\n    {\n        if(msg.sender==sender)\n        {\n            sender.transfer(this.balance);\n            d=\"\";\n        }\n    }\n\n    function PassHasBeenSet(bytes32 e)\n    public\n    {\n        if(msg.sender==sender&&e==c)\n        {\n           a=true;\n        }\n    }\n}",
      "rename_map": {
        "passHasBeenSet": "a",
        "_message": "b",
        "hashPass": "c",
        "message": "d",
        "hash": "e",
        "sha3": "f",
        "pass": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_206",
      "transformed_id": "ss_l2_short_nc_ds_206",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Test1\n{\n    address b = msg.sender;\n\n    function a()\n    payable\n    public\n    {\n        require(msg.sender==b);\n        b.transfer(this.balance);\n    }\n\n    function() payable {}\n\n    function Test()\n    payable\n    public\n    {\n        if(msg.value>=1 ether)\n        {\n\n            var d = 1;\n            var e = 0;\n            var c = msg.value*2;\n\n            while(true)\n            {\n                if(d<e)break;\n                if(d>c)break;\n\n                e=d;\n                d++;\n            }\n            msg.sender.transfer(e);\n        }\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "owner": "b",
        "amX2": "c",
        "i1": "d",
        "i2": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_207",
      "transformed_id": "ss_l2_short_nc_ds_207",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\n\ncontract ERC20 {\n    function b() constant returns (uint b);\n    function f(address k) constant returns (uint balance);\n    function transfer(address s, uint m) returns (bool i);\n    function a(address q, address s, uint m) returns (bool i);\n    function j(address h, uint m) returns (bool i);\n    function d(address k, address h) constant returns (uint e);\n    event Transfer(address indexed q, address indexed s, uint m);\n    event Approval(address indexed k, address indexed h, uint m);\n}\n\ncontract TokenExchange{\n    address private p;\n    uint public o;\n    ERC20 r;\n\n    function TokenExchange(uint l, ERC20 n)\n        public\n    {\n        p = msg.sender;\n        o = l;\n        r = n;\n    }\n\n\n    function t(uint g) payable\n        public\n    {\n        require(msg.value >= o);\n\n\n        r.a(msg.sender, p, o);\n\n        o = g;\n        p = msg.sender;\n    }\n\n    function c(uint g){\n        require(msg.sender == p);\n        o = g;\n    }\n\n}",
      "rename_map": {
        "transferFrom": "a",
        "totalSupply": "b",
        "changePrice": "c",
        "allowance": "d",
        "remaining": "e",
        "balanceOf": "f",
        "new_price": "g",
        "_spender": "h",
        "success": "i",
        "approve": "j",
        "_owner": "k",
        "_price": "l",
        "_value": "m",
        "_token": "n",
        "price": "o",
        "owner": "p",
        "_from": "q",
        "token": "r",
        "_to": "s",
        "buy": "t"
      },
      "changes": [
        "Renamed 20 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_208",
      "transformed_id": "ss_l2_short_nc_ds_208",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.4.9;\n\ncontract WalletEvents {\n\n\n  event Confirmation(address bj, bytes32 ai);\n  event Revoke(address bj, bytes32 ai);\n\n\n  event OwnerChanged(address an, address aq);\n  event OwnerAdded(address aq);\n  event OwnerRemoved(address an);\n\n\n  event RequirementChanged(uint f);\n\n\n  event Deposit(address bq, uint value);\n\n  event SingleTransact(address bj, uint value, address bx, bytes data, address ax);\n\n  event MultiTransact(address bj, bytes32 ai, uint value, address bx, bytes data, address ax);\n\n  event ConfirmationNeeded(bytes32 ai, address ak, uint value, address bx, bytes data);\n}\n\ncontract WalletAbi {\n\n  function bi(bytes32 ac) external;\n\n\n  function v(address bq, address bv) external;\n\n  function ao(address be) external;\n\n  function t(address be) external;\n\n  function a(uint p) external;\n\n  function av(address bm) constant returns (bool);\n\n  function q(bytes32 ac, address be) external constant returns (bool);\n\n\n  function j(uint ad) external;\n\n  function aw(address bv, uint bh, bytes bo) external returns (bytes32 bf);\n  function az(bytes32 by) returns (bool aj);\n}\n\ncontract WalletLibrary is WalletEvents {\n\n\n  struct PendingState {\n    uint al;\n    uint y;\n    uint bk;\n  }\n\n\n  struct Transaction {\n    address bx;\n    uint value;\n    bytes data;\n  }\n\n\n  modifier ah {\n    if (av(msg.sender))\n      _;\n  }\n\n\n  modifier g(bytes32 ac) {\n    if (d(ac))\n      _;\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n\n  function h(address[] ba, uint ae) {\n    w = ba.length + 1;\n    at[1] = uint(msg.sender);\n    o[uint(msg.sender)] = 1;\n    for (uint i = 0; i < ba.length; ++i)\n    {\n      at[2 + i] = uint(ba[i]);\n      o[uint(ba[i])] = 2 + i;\n    }\n    x = ae;\n  }\n\n\n  function bi(bytes32 ac) external {\n    uint z = o[uint(msg.sender)];\n\n    if (z == 0) return;\n    uint k = 2**z;\n    var au = am[ac];\n    if (au.y & k > 0) {\n      au.al++;\n      au.y -= k;\n      Revoke(msg.sender, ac);\n    }\n  }\n\n\n  function v(address bq, address bv) g(bu(msg.data)) external {\n    if (av(bv)) return;\n    uint z = o[uint(bq)];\n    if (z == 0) return;\n\n    r();\n    at[z] = uint(bv);\n    o[uint(bq)] = 0;\n    o[uint(bv)] = z;\n    OwnerChanged(bq, bv);\n  }\n\n  function ao(address be) g(bu(msg.data)) external {\n    if (av(be)) return;\n\n    r();\n    if (w >= u)\n      b();\n    if (w >= u)\n      return;\n    w++;\n    at[w] = uint(be);\n    o[uint(be)] = w;\n    OwnerAdded(be);\n  }\n\n  function t(address be) g(bu(msg.data)) external {\n    uint z = o[uint(be)];\n    if (z == 0) return;\n    if (x > w - 1) return;\n\n    at[z] = 0;\n    o[uint(be)] = 0;\n    r();\n    b();\n    OwnerRemoved(be);\n  }\n\n  function a(uint p) g(bu(msg.data)) external {\n    if (p > w) return;\n    x = p;\n    r();\n    RequirementChanged(p);\n  }\n\n\n  function ar(uint z) external constant returns (address) {\n    return address(at[z + 1]);\n  }\n\n  function av(address bm) constant returns (bool) {\n    return o[uint(bm)] > 0;\n  }\n\n  function q(bytes32 ac, address be) external constant returns (bool) {\n    var au = am[ac];\n    uint z = o[uint(be)];\n\n\n    if (z == 0) return false;\n\n\n    uint k = 2**z;\n    return !(au.y & k == 0);\n  }\n\n\n  function l(uint bc) {\n    m = bc;\n    af = bp();\n  }\n\n  function j(uint ad) g(bu(msg.data)) external {\n    m = ad;\n  }\n\n  function e() g(bu(msg.data)) external {\n    s = 0;\n  }\n\n\n  function aa(address[] ba, uint ae, uint ag) {\n    l(ag);\n    h(ba, ae);\n  }\n\n\n  function bs(address bv) g(bu(msg.data)) external {\n    suicide(bv);\n  }\n\n\n  function aw(address bv, uint bh, bytes bo) external ah returns (bytes32 bf) {\n\n    if ((bo.length == 0 && ab(bh)) || x == 1) {\n\n      address ax;\n      if (bv == 0) {\n        ax = bg(bh, bo);\n      } else {\n        if (!bv.call.value(bh)(bo))\n          throw;\n      }\n      SingleTransact(msg.sender, bh, bv, bo, ax);\n    } else {\n\n      bf = bu(msg.data, block.number);\n\n      if (bn[bf].bx == 0 && bn[bf].value == 0 && bn[bf].data.length == 0) {\n        bn[bf].bx = bv;\n        bn[bf].value = bh;\n        bn[bf].data = bo;\n      }\n      if (!az(bf)) {\n        ConfirmationNeeded(bf, msg.sender, bh, bv, bo);\n      }\n    }\n  }\n\n  function bg(uint bh, bytes br) internal returns (address bb) {\n    assembly {\n      bb := bg(bh, add(br, 0x20), mload(br))\n      bl(c, iszero(extcodesize(bb)))\n    }\n  }\n\n\n  function az(bytes32 by) g(by) returns (bool aj) {\n    if (bn[by].bx != 0 || bn[by].value != 0 || bn[by].data.length != 0) {\n      address ax;\n      if (bn[by].bx == 0) {\n        ax = bg(bn[by].value, bn[by].data);\n      } else {\n        if (!bn[by].bx.call.value(bn[by].value)(bn[by].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, by, bn[by].value, bn[by].bx, bn[by].data, ax);\n      delete bn[by];\n      return true;\n    }\n  }\n\n\n  function d(bytes32 ac) internal returns (bool) {\n\n    uint z = o[uint(msg.sender)];\n\n    if (z == 0) return;\n\n    var au = am[ac];\n\n    if (au.al == 0) {\n\n      au.al = x;\n\n      au.y = 0;\n      au.bk = i.length++;\n      i[au.bk] = ac;\n    }\n\n    uint k = 2**z;\n\n    if (au.y & k == 0) {\n      Confirmation(msg.sender, ac);\n\n      if (au.al <= 1) {\n\n        delete i[am[ac].bk];\n        delete am[ac];\n        return true;\n      }\n      else\n      {\n\n        au.al--;\n        au.y |= k;\n      }\n    }\n  }\n\n  function b() private {\n    uint bt = 1;\n    while (bt < w)\n    {\n      while (bt < w && at[bt] != 0) bt++;\n      while (w > 1 && at[w] == 0) w--;\n      if (bt < w && at[w] != 0 && at[bt] == 0)\n      {\n        at[bt] = at[w];\n        o[at[bt]] = bt;\n        at[w] = 0;\n      }\n    }\n  }\n\n\n  function ab(uint bh) internal ah returns (bool) {\n\n    if (bp() > af) {\n      s = 0;\n      af = bp();\n    }\n\n\n    if (s + bh >= s && s + bh <= m) {\n      s += bh;\n      return true;\n    }\n    return false;\n  }\n\n\n  function bp() private constant returns (uint) { return bw / 1 days; }\n\n  function r() internal {\n    uint length = i.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete bn[i[i]];\n\n      if (i[i] != 0)\n        delete am[i[i]];\n    }\n\n    delete i;\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public x;\n\n  uint public w;\n\n  uint public m;\n  uint public s;\n  uint public af;\n\n\n  uint[256] at;\n\n  uint constant u = 250;\n\n  mapping(uint => uint) o;\n\n  mapping(bytes32 => PendingState) am;\n  bytes32[] i;\n\n\n  mapping (bytes32 => Transaction) bn;\n}\n\ncontract Wallet is WalletEvents {\n\n\n  function Wallet(address[] ba, uint ae, uint ag) {\n\n    bytes4 sig = bytes4(bu(\"initWallet(address[],uint256,uint256)\"));\n    address bd = _walletLibrary;\n\n\n    uint n = (2 + ba.length);\n    uint ay = (2 + n) * 32;\n\n    assembly {\n\n      mstore(0x0, sig)\n\n\n      as(0x4,  sub(ap, ay), ay)\n\n      delegatecall(sub(gas, 10000), bd, 0x0, add(ay, 0x4), 0x0, 0x0)\n    }\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n\n  function ar(uint z) constant returns (address) {\n    return address(at[z + 1]);\n  }\n\n\n  function q(bytes32 ac, address be) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function av(address bm) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public x;\n\n  uint public w;\n\n  uint public m;\n  uint public s;\n  uint public af;\n\n\n  uint[256] at;\n}",
      "rename_map": {
        "changeRequirement": "a",
        "reorganizeOwners": "b",
        "invalidJumpLabel": "c",
        "confirmAndCheck": "d",
        "resetSpentToday": "e",
        "newRequirement": "f",
        "onlymanyowners": "g",
        "initMultiowned": "h",
        "m_pendingIndex": "i",
        "setDailyLimit": "j",
        "ownerIndexBit": "k",
        "initDaylimit": "l",
        "m_dailyLimit": "m",
        "argarraysize": "n",
        "m_ownerIndex": "o",
        "_newRequired": "p",
        "hasConfirmed": "q",
        "clearPending": "r",
        "m_spentToday": "s",
        "removeOwner": "t",
        "c_maxOwners": "u",
        "changeOwner": "v",
        "m_numOwners": "w",
        "m_required": "x",
        "ownersDone": "y",
        "ownerIndex": "z",
        "initWallet": "aa",
        "underLimit": "ab",
        "_operation": "ac",
        "_newLimit": "ad",
        "_required": "ae",
        "m_lastDay": "af",
        "_daylimit": "ag",
        "onlyowner": "ah",
        "operation": "ai",
        "o_success": "aj",
        "initiator": "ak",
        "yetNeeded": "al",
        "m_pending": "am",
        "oldOwner": "an",
        "addOwner": "ao",
        "codesize": "ap",
        "newOwner": "aq",
        "getOwner": "ar",
        "codecopy": "as",
        "m_owners": "at",
        "pending": "au",
        "isOwner": "av",
        "execute": "aw",
        "created": "ax",
        "argsize": "ay",
        "confirm": "az",
        "_owners": "ba",
        "o_addr": "bb",
        "_limit": "bc",
        "target": "bd",
        "_owner": "be",
        "o_hash": "bf",
        "create": "bg",
        "_value": "bh",
        "revoke": "bi",
        "owner": "bj",
        "index": "bk",
        "jumpi": "bl",
        "_addr": "bm",
        "m_txs": "bn",
        "_data": "bo",
        "today": "bp",
        "_from": "bq",
        "_code": "br",
        "kill": "bs",
        "free": "bt",
        "sha3": "bu",
        "_to": "bv",
        "now": "bw",
        "to": "bx",
        "_h": "by"
      },
      "changes": [
        "Renamed 77 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_209",
      "transformed_id": "ss_l2_short_nc_ds_209",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\ncontract WalletEvents {\n\n\n  event Confirmation(address be, bytes32 ad);\n  event Revoke(address be, bytes32 ad);\n\n\n  event OwnerChanged(address am, address an);\n  event OwnerAdded(address an);\n  event OwnerRemoved(address am);\n\n\n  event RequirementChanged(uint i);\n\n\n  event Deposit(address bg, uint value);\n\n  event SingleTransact(address be, uint value, address bs, bytes data, address at);\n\n  event MultiTransact(address be, bytes32 ad, uint value, address bs, bytes data, address at);\n\n  event ConfirmationNeeded(bytes32 ad, address al, uint value, address bs, bytes data);\n}\n\ncontract WalletAbi {\n\n  function bd(bytes32 y) external;\n\n\n  function s(address bg, address bq) external;\n\n  function aq(address az) external;\n\n  function u(address az) external;\n\n  function b(uint o) external;\n\n  function aw(address bi) constant returns (bool);\n\n  function q(bytes32 y, address az) external constant returns (bool);\n\n\n  function k(uint ac) external;\n\n  function ar(address bq, uint bb, bytes bl) external returns (bytes32 ba);\n  function av(bytes32 br) returns (bool ag);\n}\n\ncontract WalletLibrary is WalletEvents {\n\n\n  struct PendingState {\n    uint ae;\n    uint z;\n    uint bf;\n  }\n\n\n  struct Transaction {\n    address bs;\n    uint value;\n    bytes data;\n  }\n\n\n  modifier ak {\n    if (aw(msg.sender))\n      _;\n  }\n\n\n  modifier f(bytes32 y) {\n    if (d(y))\n      _;\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n\n  function g(address[] au, uint ai) a {\n    t = au.length + 1;\n    ap[1] = uint(msg.sender);\n    n[uint(msg.sender)] = 1;\n    for (uint i = 0; i < au.length; ++i)\n    {\n      ap[2 + i] = uint(au[i]);\n      n[uint(au[i])] = 2 + i;\n    }\n    w = ai;\n  }\n\n\n  function bd(bytes32 y) external {\n    uint x = n[uint(msg.sender)];\n\n    if (x == 0) return;\n    uint j = 2**x;\n    var as = af[y];\n    if (as.z & j > 0) {\n      as.ae++;\n      as.z -= j;\n      Revoke(msg.sender, y);\n    }\n  }\n\n\n  function s(address bg, address bq) f(bm(msg.data)) external {\n    if (aw(bq)) return;\n    uint x = n[uint(bg)];\n    if (x == 0) return;\n\n    r();\n    ap[x] = uint(bq);\n    n[uint(bg)] = 0;\n    n[uint(bq)] = x;\n    OwnerChanged(bg, bq);\n  }\n\n  function aq(address az) f(bm(msg.data)) external {\n    if (aw(az)) return;\n\n    r();\n    if (t >= v)\n      c();\n    if (t >= v)\n      return;\n    t++;\n    ap[t] = uint(az);\n    n[uint(az)] = t;\n    OwnerAdded(az);\n  }\n\n  function u(address az) f(bm(msg.data)) external {\n    uint x = n[uint(az)];\n    if (x == 0) return;\n    if (w > t - 1) return;\n\n    ap[x] = 0;\n    n[uint(az)] = 0;\n    r();\n    c();\n    OwnerRemoved(az);\n  }\n\n  function b(uint o) f(bm(msg.data)) external {\n    if (o > t) return;\n    w = o;\n    r();\n    RequirementChanged(o);\n  }\n\n\n  function ao(uint x) external constant returns (address) {\n    return address(ap[x + 1]);\n  }\n\n  function aw(address bi) constant returns (bool) {\n    return n[uint(bi)] > 0;\n  }\n\n  function q(bytes32 y, address az) external constant returns (bool) {\n    var as = af[y];\n    uint x = n[uint(az)];\n\n\n    if (x == 0) return false;\n\n\n    uint j = 2**x;\n    return !(as.z & j == 0);\n  }\n\n\n  function l(uint bc) a {\n    m = bc;\n    aj = bj();\n  }\n\n  function k(uint ac) f(bm(msg.data)) external {\n    m = ac;\n  }\n\n  function e() f(bm(msg.data)) external {\n    p = 0;\n  }\n\n\n  modifier a { if (t > 0) throw; _; }\n\n\n  function aa(address[] au, uint ai, uint ah) a {\n    l(ah);\n    g(au, ai);\n  }\n\n\n  function bn(address bq) f(bm(msg.data)) external {\n    suicide(bq);\n  }\n\n\n  function ar(address bq, uint bb, bytes bl) external ak returns (bytes32 ba) {\n\n    if ((bl.length == 0 && ab(bb)) || w == 1) {\n\n      address at;\n      if (bq == 0) {\n        at = ay(bb, bl);\n      } else {\n        if (!bq.call.value(bb)(bl))\n          throw;\n      }\n      SingleTransact(msg.sender, bb, bq, bl, at);\n    } else {\n\n      ba = bm(msg.data, block.number);\n\n      if (bk[ba].bs == 0 && bk[ba].value == 0 && bk[ba].data.length == 0) {\n        bk[ba].bs = bq;\n        bk[ba].value = bb;\n        bk[ba].data = bl;\n      }\n      if (!av(ba)) {\n        ConfirmationNeeded(ba, msg.sender, bb, bq, bl);\n      }\n    }\n  }\n\n  function ay(uint bb, bytes bh) internal returns (address ax) {\n  }\n\n\n  function av(bytes32 br) f(br) returns (bool ag) {\n    if (bk[br].bs != 0 || bk[br].value != 0 || bk[br].data.length != 0) {\n      address at;\n      if (bk[br].bs == 0) {\n        at = ay(bk[br].value, bk[br].data);\n      } else {\n        if (!bk[br].bs.call.value(bk[br].value)(bk[br].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, br, bk[br].value, bk[br].bs, bk[br].data, at);\n      delete bk[br];\n      return true;\n    }\n  }\n\n\n  function d(bytes32 y) internal returns (bool) {\n\n    uint x = n[uint(msg.sender)];\n\n    if (x == 0) return;\n\n    var as = af[y];\n\n    if (as.ae == 0) {\n\n      as.ae = w;\n\n      as.z = 0;\n      as.bf = h.length++;\n      h[as.bf] = y;\n    }\n\n    uint j = 2**x;\n\n    if (as.z & j == 0) {\n      Confirmation(msg.sender, y);\n\n      if (as.ae <= 1) {\n\n        delete h[af[y].bf];\n        delete af[y];\n        return true;\n      }\n      else\n      {\n\n        as.ae--;\n        as.z |= j;\n      }\n    }\n  }\n\n  function c() private {\n    uint bo = 1;\n    while (bo < t)\n    {\n      while (bo < t && ap[bo] != 0) bo++;\n      while (t > 1 && ap[t] == 0) t--;\n      if (bo < t && ap[t] != 0 && ap[bo] == 0)\n      {\n        ap[bo] = ap[t];\n        n[ap[bo]] = bo;\n        ap[t] = 0;\n      }\n    }\n  }\n\n\n  function ab(uint bb) internal ak returns (bool) {\n\n    if (bj() > aj) {\n      p = 0;\n      aj = bj();\n    }\n\n\n    if (p + bb >= p && p + bb <= m) {\n      p += bb;\n      return true;\n    }\n    return false;\n  }\n\n\n  function bj() private constant returns (uint) { return bp / 1 days; }\n\n  function r() internal {\n    uint length = h.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete bk[h[i]];\n\n      if (h[i] != 0)\n        delete af[h[i]];\n    }\n\n    delete h;\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public w;\n\n  uint public t;\n\n  uint public m;\n  uint public p;\n  uint public aj;\n\n\n  uint[256] ap;\n\n  uint constant v = 250;\n\n  mapping(uint => uint) n;\n\n  mapping(bytes32 => PendingState) af;\n  bytes32[] h;\n\n\n  mapping (bytes32 => Transaction) bk;\n}",
      "rename_map": {
        "only_uninitialized": "a",
        "changeRequirement": "b",
        "reorganizeOwners": "c",
        "confirmAndCheck": "d",
        "resetSpentToday": "e",
        "onlymanyowners": "f",
        "initMultiowned": "g",
        "m_pendingIndex": "h",
        "newRequirement": "i",
        "ownerIndexBit": "j",
        "setDailyLimit": "k",
        "initDaylimit": "l",
        "m_dailyLimit": "m",
        "m_ownerIndex": "n",
        "_newRequired": "o",
        "m_spentToday": "p",
        "hasConfirmed": "q",
        "clearPending": "r",
        "changeOwner": "s",
        "m_numOwners": "t",
        "removeOwner": "u",
        "c_maxOwners": "v",
        "m_required": "w",
        "ownerIndex": "x",
        "_operation": "y",
        "ownersDone": "z",
        "initWallet": "aa",
        "underLimit": "ab",
        "_newLimit": "ac",
        "operation": "ad",
        "yetNeeded": "ae",
        "m_pending": "af",
        "o_success": "ag",
        "_daylimit": "ah",
        "_required": "ai",
        "m_lastDay": "aj",
        "onlyowner": "ak",
        "initiator": "al",
        "oldOwner": "am",
        "newOwner": "an",
        "getOwner": "ao",
        "m_owners": "ap",
        "addOwner": "aq",
        "execute": "ar",
        "pending": "as",
        "created": "at",
        "_owners": "au",
        "confirm": "av",
        "isOwner": "aw",
        "o_addr": "ax",
        "create": "ay",
        "_owner": "az",
        "o_hash": "ba",
        "_value": "bb",
        "_limit": "bc",
        "revoke": "bd",
        "owner": "be",
        "index": "bf",
        "_from": "bg",
        "_code": "bh",
        "_addr": "bi",
        "today": "bj",
        "m_txs": "bk",
        "_data": "bl",
        "sha3": "bm",
        "kill": "bn",
        "free": "bo",
        "now": "bp",
        "_to": "bq",
        "_h": "br",
        "to": "bs"
      },
      "changes": [
        "Renamed 71 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_210",
      "transformed_id": "ss_l2_short_nc_ds_210",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract LuckyDoubler {\n\n\n    address private ab;\n\n\n    uint private balance = 0;\n    uint private ao = 5;\n    uint private l = 125;\n\n    mapping (address => User) private ae;\n    Entry[] private u;\n    uint[] private f;\n\n\n    function LuckyDoubler() {\n        ab = msg.sender;\n    }\n\n    modifier o { if (msg.sender == ab) _; }\n\n    struct User {\n        address ap;\n        uint r;\n        uint c;\n    }\n\n    struct Entry {\n        address i;\n        uint v;\n        uint x;\n        bool ak;\n    }\n\n\n    function() {\n        ah();\n    }\n\n    function ah() private{\n\n        if (msg.value < 1 ether) {\n             msg.sender.send(msg.value);\n            return;\n        }\n\n        ai();\n    }\n\n    function ai() private {\n\n\n        uint w = 1 ether;\n\n        if (msg.value > 1 ether) {\n\n        \tmsg.sender.send(msg.value - 1 ether);\n        \tw = 1 ether;\n        }\n\n\n        if (ae[msg.sender].ap == address(0))\n        {\n            ae[msg.sender].ap = msg.sender;\n            ae[msg.sender].r = 0;\n            ae[msg.sender].c = 0;\n        }\n\n\n        u.push(Entry(msg.sender, w, (w * (l) / 100), false));\n        ae[msg.sender].r++;\n        f.push(u.length -1);\n\n\n        balance += (w * (100 - ao)) / 100;\n\n        uint ac = f.length > 1 ? ag(f.length) : 0;\n        Entry q = u[f[ac]];\n\n\n        if (balance > q.x) {\n\n            uint x = q.x;\n\n            q.i.send(x);\n            q.ak = true;\n            ae[q.i].c++;\n\n            balance -= x;\n\n            if (ac < f.length - 1)\n                f[ac] = f[f.length - 1];\n\n            f.length--;\n\n        }\n\n\n        uint al = this.balance - balance;\n        if (al > 0)\n        {\n                ab.send(al);\n        }\n\n    }\n\n\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function ag(uint an) constant private returns (uint256 aa){\n        uint256 z = FACTOR * 100 / an;\n        uint256 d = block.number - 1;\n        uint256 s = uint256(block.blockhash(d));\n\n        return uint256((uint256(s) / z)) % an;\n    }\n\n\n    function j(address p) o {\n        ab = p;\n    }\n\n    function a(uint af) o {\n        if (af < 110 || af > 150) throw;\n\n        l = af;\n    }\n\n    function m(uint y) o {\n        if (ao > 5)\n            throw;\n        ao = y;\n    }\n\n\n    function b() constant returns (uint z, string am) {\n        z = l;\n        am = 'The current l applied to all r. Min 110%, an 150%.';\n    }\n\n    function k() constant returns (uint e, string am) {\n        e = ao;\n        am = 'The ao percentage applied to all r. It can change to speed t (an 5%).';\n    }\n\n    function g() constant returns (uint ad, string am) {\n        ad = u.length;\n        am = 'The number of r.';\n    }\n\n    function n(address aj) constant returns (uint r, uint t, string am)\n    {\n        if (ae[aj].ap != address(0x0))\n        {\n            r = ae[aj].r;\n            t = ae[aj].c;\n            am = 'Users stats: total r, t received.';\n        }\n    }\n\n    function h(uint ac) constant returns (address aj, uint x, bool ak, string am)\n    {\n        if (ac < u.length) {\n            aj = u[ac].i;\n            x = u[ac].x / 1 finney;\n            ak = u[ac].ak;\n            am = 'Entry am: aj address, expected x in Finneys, x status.';\n        }\n    }\n\n}",
      "rename_map": {
        "changeMultiplier": "a",
        "multiplierFactor": "b",
        "payoutsReceived": "c",
        "lastBlockNumber": "d",
        "feePercentage": "e",
        "unpaidEntries": "f",
        "totalEntries": "g",
        "entryDetails": "h",
        "entryAddress": "i",
        "changeOwner": "j",
        "currentFee": "k",
        "multiplier": "l",
        "changeFee": "m",
        "userStats": "n",
        "onlyowner": "o",
        "newOwner": "p",
        "theEntry": "q",
        "deposits": "r",
        "hashVal": "s",
        "payouts": "t",
        "entries": "u",
        "deposit": "v",
        "dValue": "w",
        "payout": "x",
        "newFee": "y",
        "factor": "z",
        "result": "aa",
        "owner": "ab",
        "index": "ac",
        "count": "ad",
        "users": "ae",
        "multi": "af",
        "rand": "ag",
        "init": "ah",
        "join": "ai",
        "user": "aj",
        "paid": "ak",
        "fees": "al",
        "info": "am",
        "max": "an",
        "fee": "ao",
        "id": "ap"
      },
      "changes": [
        "Renamed 42 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_211",
      "transformed_id": "ss_l2_short_nc_ds_211",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\n\n contract Token {\n\n     uint256 public as;\n\n\n     function bs(address dc) public constant returns (uint256 balance);\n\n\n     function transfer(address eg, uint256 dj) public returns (bool cm);\n\n\n     function ai(address dw, address eg, uint256 dj) public returns (bool cm);\n\n\n     function ck(address cd, uint256 dj) public returns (bool cm);\n\n\n     function bp(address dc, address cd) public constant returns (uint256 bx);\n\n     event Transfer(address indexed dw, address indexed eg, uint256 dj);\n     event Approval(address indexed dc, address indexed cd, uint256 dj);\n }\n\n library ECTools {\n\n\n     function ae(bytes32 bf, string ed) public pure returns (address) {\n         require(bf != 0x00);\n\n\n         bytes memory cz = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 ah = bm(abi.ag(cz, bf));\n\n         if (bytes(ed).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = y(bj(ed, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return bv(ah, v, r, s);\n     }\n\n\n     function bb(bytes32 bf, string ed, address ds) public pure returns (bool) {\n         require(ds != 0x0);\n\n         return ds == ae(bf, ed);\n     }\n\n\n     function y(string ci) public pure returns (bytes) {\n         uint eh = bytes(ci).length;\n         require(eh % 2 == 0);\n\n         bytes memory dy = bytes(new string(eh / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < eh; i += 2) {\n             s = bj(ci, i, i + 1);\n             r = bj(ci, i + 1, i + 2);\n             uint p = q(s) * 16 + q(r);\n             dy[k++] = u(p)[31];\n         }\n         return dy;\n     }\n\n\n     function q(string dp) public pure returns (uint) {\n         bytes memory cr = bytes(dp);\n\n         if ((cr[0] >= 48) && (cr[0] <= 57)) {\n             return uint(cr[0]) - 48;\n         } else if ((cr[0] >= 65) && (cr[0] <= 70)) {\n             return uint(cr[0]) - 55;\n         } else if ((cr[0] >= 97) && (cr[0] <= 102)) {\n             return uint(cr[0]) - 87;\n         } else {\n             revert();\n         }\n     }\n\n\n     function u(uint dm) public pure returns (bytes b) {\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), dm)}\n     }\n\n\n     function c(string ef) public pure returns (bytes32) {\n         uint eh = bytes(ef).length;\n         require(eh > 0);\n         bytes memory cz = \"\\x19Ethereum Signed Message:\\n\";\n         return bm(abi.ag(cz, al(eh), ef));\n     }\n\n\n     function al(uint dm) public pure returns (string ei) {\n         uint eh = 0;\n         uint m = dm + 0;\n         while (m != 0) {\n             eh++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(eh);\n         uint i = eh - 1;\n         while (dm != 0) {\n             uint bn = dm % 10;\n             dm = dm / 10;\n             b[i--] = byte(48 + bn);\n         }\n         ei = string(b);\n     }\n\n\n     function bj(string dz, uint ay, uint by) public pure returns (string) {\n         bytes memory cb = bytes(dz);\n         require(ay <= by);\n         require(ay >= 0);\n         require(by <= cb.length);\n\n         bytes memory dg = new bytes(by - ay);\n         for (uint i = ay; i < by; i++) {\n             dg[i - ay] = cb[i];\n         }\n         return string(dg);\n     }\n }\n contract StandardToken is Token {\n\n     function transfer(address eg, uint256 dj) public returns (bool cm) {\n\n\n         require(cc[msg.sender] >= dj);\n         cc[msg.sender] -= dj;\n         cc[eg] += dj;\n         emit Transfer(msg.sender, eg, dj);\n         return true;\n     }\n\n     function ai(address dw, address eg, uint256 dj) public returns (bool cm) {\n\n\n         require(cc[dw] >= dj && cp[dw][msg.sender] >= dj);\n         cc[eg] += dj;\n         cc[dw] -= dj;\n         cp[dw][msg.sender] -= dj;\n         emit Transfer(dw, eg, dj);\n         return true;\n     }\n\n     function bs(address dc) public constant returns (uint256 balance) {\n         return cc[dc];\n     }\n\n     function ck(address cd, uint256 dj) public returns (bool cm) {\n         cp[msg.sender][cd] = dj;\n         emit Approval(msg.sender, cd, dj);\n         return true;\n     }\n\n     function bp(address dc, address cd) public constant returns (uint256 bx) {\n       return cp[dc][cd];\n     }\n\n     mapping (address => uint256) cc;\n     mapping (address => mapping (address => uint256)) cp;\n }\n\n contract HumanStandardToken is StandardToken {\n\n\n     string public dx;\n     uint8 public ce;\n     string public cy;\n     string public cj = 'H0.1';\n\n     constructor(\n         uint256 t,\n         string bh,\n         uint8 z,\n         string ak\n         ) public {\n         cc[msg.sender] = t;\n         as = t;\n         dx = bh;\n         ce = z;\n         cy = ak;\n     }\n\n\n     function o(address cd, uint256 dj, bytes az) public returns (bool cm) {\n         cp[msg.sender][cd] = dj;\n         emit Approval(msg.sender, cd, dj);\n\n\n         require(cd.call(bytes4(bytes32(bm(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, dj, this, az));\n         return true;\n     }\n }\n\n contract LedgerChannel {\n\n     string public constant NAME = \"Ledger Channel\";\n     string public constant VERSION = \"0.0.1\";\n\n     uint256 public ax = 0;\n\n     event DidLCOpen (\n         bytes32 indexed bk,\n         address indexed cx,\n         address indexed cw,\n         uint256 au,\n         address dl,\n         uint256 ac,\n         uint256 LCopenTimeout\n     );\n\n     event DidLCJoin (\n         bytes32 indexed bk,\n         uint256 ar,\n         uint256 v\n     );\n\n     event DidLCDeposit (\n         bytes32 indexed bk,\n         address indexed bi,\n         uint256 cq,\n         bool ct\n     );\n\n     event DidLCUpdateState (\n         bytes32 indexed bk,\n         uint256 cf,\n         uint256 bt,\n         uint256 au,\n         uint256 ac,\n         uint256 ar,\n         uint256 v,\n         bytes32 di,\n         uint256 l\n     );\n\n     event DidLCClose (\n         bytes32 indexed bk,\n         uint256 cf,\n         uint256 au,\n         uint256 ac,\n         uint256 ar,\n         uint256 v\n     );\n\n     event DidVCInit (\n         bytes32 indexed ee,\n         bytes32 indexed eb,\n         bytes dv,\n         uint256 cf,\n         address cx,\n         address db,\n         uint256 cg,\n         uint256 ca\n     );\n\n     event DidVCSettle (\n         bytes32 indexed ee,\n         bytes32 indexed eb,\n         uint256 bw,\n         uint256 ba,\n         uint256 bg,\n         address bc,\n         uint256 k\n     );\n\n     event DidVCClose(\n         bytes32 indexed ee,\n         bytes32 indexed eb,\n         uint256 cg,\n         uint256 ca\n     );\n\n     struct Channel {\n\n         address[2] p;\n         uint256[4] ao;\n         uint256[4] ab;\n         uint256[2] s;\n         uint256 cf;\n         uint256 aq;\n         bytes32 VCrootHash;\n         uint256 LCopenTimeout;\n         uint256 l;\n         bool dh;\n         bool h;\n         uint256 br;\n         HumanStandardToken dl;\n     }\n\n\n     struct VirtualChannel {\n         bool cs;\n         bool f;\n         uint256 cf;\n         address bc;\n         uint256 k;\n\n         address cx;\n         address db;\n         address cw;\n         uint256[2] ao;\n         uint256[2] ab;\n         uint256[2] ec;\n         HumanStandardToken dl;\n     }\n\n     mapping(bytes32 => VirtualChannel) public n;\n     mapping(bytes32 => Channel) public Channels;\n\n     function ad(\n         bytes32 dn,\n         address cl,\n         uint256 an,\n         address da,\n         uint256[2] bq\n     )\n         public\n         payable\n     {\n         require(Channels[dn].p[0] == address(0), \"Channel has already been created.\");\n         require(cl != 0x0, \"No partyI address provided to LC creation\");\n         require(bq[0] >= 0 && bq[1] >= 0, \"Balances cannot be negative\");\n\n\n         Channels[dn].p[0] = msg.sender;\n         Channels[dn].p[1] = cl;\n\n         if(bq[0] != 0) {\n             require(msg.value == bq[0], \"Eth balance does not match sent value\");\n             Channels[dn].ao[0] = msg.value;\n         }\n         if(bq[1] != 0) {\n             Channels[dn].dl = HumanStandardToken(da);\n             require(Channels[dn].dl.ai(msg.sender, this, bq[1]),\"CreateChannel: token transfer failure\");\n             Channels[dn].ab[0] = bq[1];\n         }\n\n         Channels[dn].cf = 0;\n         Channels[dn].aq = an;\n\n\n         Channels[dn].LCopenTimeout = ej + an;\n         Channels[dn].s = bq;\n\n         emit DidLCOpen(dn, msg.sender, cl, bq[0], da, bq[1], Channels[dn].LCopenTimeout);\n     }\n\n     function LCOpenTimeout(bytes32 dn) public {\n         require(msg.sender == Channels[dn].p[0] && Channels[dn].dh == false);\n         require(ej > Channels[dn].LCopenTimeout);\n\n         if(Channels[dn].s[0] != 0) {\n             Channels[dn].p[0].transfer(Channels[dn].ao[0]);\n         }\n         if(Channels[dn].s[1] != 0) {\n             require(Channels[dn].dl.transfer(Channels[dn].p[0], Channels[dn].ab[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(dn, 0, Channels[dn].ao[0], Channels[dn].ab[0], 0, 0);\n\n\n         delete Channels[dn];\n     }\n\n     function aw(bytes32 dn, uint256[2] bq) public payable {\n\n         require(Channels[dn].dh == false);\n         require(msg.sender == Channels[dn].p[1]);\n\n         if(bq[0] != 0) {\n             require(msg.value == bq[0], \"state balance does not match sent value\");\n             Channels[dn].ao[1] = msg.value;\n         }\n         if(bq[1] != 0) {\n             require(Channels[dn].dl.ai(msg.sender, this, bq[1]),\"joinChannel: token transfer failure\");\n             Channels[dn].ab[1] = bq[1];\n         }\n\n         Channels[dn].s[0]+=bq[0];\n         Channels[dn].s[1]+=bq[1];\n\n         Channels[dn].dh = true;\n         ax++;\n\n         emit DidLCJoin(dn, bq[0], bq[1]);\n     }\n\n\n     function cq(bytes32 dn, address bi, uint256 bz, bool ct) public payable {\n         require(Channels[dn].dh == true, \"Tried adding funds to a closed channel\");\n         require(bi == Channels[dn].p[0] || bi == Channels[dn].p[1]);\n\n\n         if (Channels[dn].p[0] == bi) {\n             if(ct) {\n                 require(Channels[dn].dl.ai(msg.sender, this, bz),\"deposit: token transfer failure\");\n                 Channels[dn].ab[2] += bz;\n             } else {\n                 require(msg.value == bz, \"state balance does not match sent value\");\n                 Channels[dn].ao[2] += msg.value;\n             }\n         }\n\n         if (Channels[dn].p[1] == bi) {\n             if(ct) {\n                 require(Channels[dn].dl.ai(msg.sender, this, bz),\"deposit: token transfer failure\");\n                 Channels[dn].ab[3] += bz;\n             } else {\n                 require(msg.value == bz, \"state balance does not match sent value\");\n                 Channels[dn].ao[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(dn, bi, bz, ct);\n     }\n\n\n     function e(\n         bytes32 dn,\n         uint256 bu,\n         uint256[4] bq,\n         string dt,\n         string dr\n     )\n         public\n     {\n\n\n         require(Channels[dn].dh == true);\n         uint256 m = Channels[dn].s[0] + Channels[dn].ao[2] + Channels[dn].ao[3];\n         uint256 i = Channels[dn].s[1] + Channels[dn].ab[2] + Channels[dn].ab[3];\n         require(m == bq[0] + bq[1]);\n         require(i == bq[2] + bq[3]);\n\n         bytes32 dd = bm(\n             abi.ag(\n                 dn,\n                 true,\n                 bu,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[dn].p[0],\n                 Channels[dn].p[1],\n                 bq[0],\n                 bq[1],\n                 bq[2],\n                 bq[3]\n             )\n         );\n\n         require(Channels[dn].p[0] == ECTools.ae(dd, dt));\n         require(Channels[dn].p[1] == ECTools.ae(dd, dr));\n\n         Channels[dn].dh = false;\n\n         if(bq[0] != 0 || bq[1] != 0) {\n             Channels[dn].p[0].transfer(bq[0]);\n             Channels[dn].p[1].transfer(bq[1]);\n         }\n\n         if(bq[2] != 0 || bq[3] != 0) {\n             require(Channels[dn].dl.transfer(Channels[dn].p[0], bq[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[dn].dl.transfer(Channels[dn].p[1], bq[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         ax--;\n\n         emit DidLCClose(dn, bu, bq[0], bq[1], bq[2], bq[3]);\n     }\n\n\n     function aa(\n         bytes32 dn,\n         uint256[6] aj,\n         bytes32 cu,\n         string dt,\n         string dr\n     )\n         public\n     {\n         Channel storage co = Channels[dn];\n         require(co.dh);\n         require(co.cf < aj[0]);\n         require(co.ao[0] + co.ao[1] >= aj[2] + aj[3]);\n         require(co.ab[0] + co.ab[1] >= aj[4] + aj[5]);\n\n         if(co.h == true) {\n             require(co.l > ej);\n         }\n\n         bytes32 dd = bm(\n             abi.ag(\n                 dn,\n                 false,\n                 aj[0],\n                 aj[1],\n                 cu,\n                 co.p[0],\n                 co.p[1],\n                 aj[2],\n                 aj[3],\n                 aj[4],\n                 aj[5]\n             )\n         );\n\n         require(co.p[0] == ECTools.ae(dd, dt));\n         require(co.p[1] == ECTools.ae(dd, dr));\n\n\n         co.cf = aj[0];\n         co.br = aj[1];\n         co.ao[0] = aj[2];\n         co.ao[1] = aj[3];\n         co.ab[0] = aj[4];\n         co.ab[1] = aj[5];\n         co.VCrootHash = cu;\n         co.h = true;\n         co.l = ej + co.aq;\n\n\n         emit DidLCUpdateState (\n             dn,\n             aj[0],\n             aj[1],\n             aj[2],\n             aj[3],\n             aj[4],\n             aj[5],\n             cu,\n             co.l\n         );\n     }\n\n\n     function at(\n         bytes32 dn,\n         bytes32 du,\n         bytes de,\n         address cn,\n         address cv,\n         uint256[2] dk,\n         uint256[4] bq,\n         string ea\n     )\n         public\n     {\n         require(Channels[dn].dh, \"LC is closed.\");\n\n         require(!n[du].cs, \"VC is closed.\");\n\n         require(Channels[dn].l < ej, \"LC timeout not over.\");\n\n         require(n[du].k == 0);\n\n         bytes32 be = bm(\n             abi.ag(du, uint256(0), cn, cv, dk[0], dk[1], bq[0], bq[1], bq[2], bq[3])\n         );\n\n\n         require(cn == ECTools.ae(be, ea));\n\n\n         require(af(be, de, Channels[dn].VCrootHash) == true);\n\n         n[du].cx = cn;\n         n[du].db = cv;\n         n[du].cf = uint256(0);\n         n[du].ao[0] = bq[0];\n         n[du].ao[1] = bq[1];\n         n[du].ab[0] = bq[2];\n         n[du].ab[1] = bq[3];\n         n[du].ec = dk;\n         n[du].k = ej + Channels[dn].aq;\n         n[du].f = true;\n\n         emit DidVCInit(dn, du, de, uint256(0), cn, cv, bq[0], bq[1]);\n     }\n\n\n     function ch(\n         bytes32 dn,\n         bytes32 du,\n         uint256 bw,\n         address cn,\n         address cv,\n         uint256[4] bo,\n         string ea\n     )\n         public\n     {\n         require(Channels[dn].dh, \"LC is closed.\");\n\n         require(!n[du].cs, \"VC is closed.\");\n         require(n[du].cf < bw, \"VC sequence is higher than update sequence.\");\n         require(\n             n[du].ao[1] < bo[1] && n[du].ab[1] < bo[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             n[du].ec[0] == bo[0] + bo[1] &&\n             n[du].ec[1] == bo[2] + bo[3],\n             \"Incorrect balances for bonded amount\");\n\n\n         require(Channels[dn].l < ej);\n\n         bytes32 am = bm(\n             abi.ag(\n                 du,\n                 bw,\n                 cn,\n                 cv,\n                 n[du].ec[0],\n                 n[du].ec[1],\n                 bo[0],\n                 bo[1],\n                 bo[2],\n                 bo[3]\n             )\n         );\n\n\n         require(n[du].cx == ECTools.ae(am, ea));\n\n\n         n[du].bc = msg.sender;\n         n[du].cf = bw;\n\n\n         n[du].ao[0] = bo[0];\n         n[du].ao[1] = bo[1];\n         n[du].ab[0] = bo[2];\n         n[du].ab[1] = bo[3];\n\n         n[du].k = ej + Channels[dn].aq;\n\n         emit DidVCSettle(dn, du, bw, bo[0], bo[1], msg.sender, n[du].k);\n     }\n\n     function g(bytes32 dn, bytes32 du) public {\n\n         require(Channels[dn].dh, \"LC is closed.\");\n         require(n[du].f, \"VC is not in settlement state.\");\n         require(n[du].k < ej, \"Update vc timeout has not elapsed.\");\n         require(!n[du].cs, \"VC is already closed\");\n\n         Channels[dn].br--;\n\n         n[du].cs = true;\n\n\n         if(n[du].cx == Channels[dn].p[0]) {\n             Channels[dn].ao[0] += n[du].ao[0];\n             Channels[dn].ao[1] += n[du].ao[1];\n\n             Channels[dn].ab[0] += n[du].ab[0];\n             Channels[dn].ab[1] += n[du].ab[1];\n         } else if (n[du].db == Channels[dn].p[0]) {\n             Channels[dn].ao[0] += n[du].ao[1];\n             Channels[dn].ao[1] += n[du].ao[0];\n\n             Channels[dn].ab[0] += n[du].ab[1];\n             Channels[dn].ab[1] += n[du].ab[0];\n         }\n\n         emit DidVCClose(dn, du, n[du].ab[0], n[du].ab[1]);\n     }\n\n\n     function d(bytes32 dn) public {\n         Channel storage co = Channels[dn];\n\n\n         require(co.dh, \"Channel is not open\");\n         require(co.h == true);\n         require(co.br == 0);\n         require(co.l < ej, \"LC timeout over.\");\n\n\n         uint256 m = co.s[0] + co.ao[2] + co.ao[3];\n         uint256 i = co.s[1] + co.ab[2] + co.ab[3];\n\n         uint256 b = co.ao[0] + co.ao[1];\n         uint256 a = co.ab[0] + co.ab[1];\n\n         if(b < m) {\n             co.ao[0]+=co.ao[2];\n             co.ao[1]+=co.ao[3];\n         } else {\n             require(b == m);\n         }\n\n         if(a < i) {\n             co.ab[0]+=co.ab[2];\n             co.ab[1]+=co.ab[3];\n         } else {\n             require(a == i);\n         }\n\n         uint256 av = co.ao[0];\n         uint256 ap = co.ao[1];\n         uint256 x = co.ab[0];\n         uint256 w = co.ab[1];\n\n         co.ao[0] = 0;\n         co.ao[1] = 0;\n         co.ab[0] = 0;\n         co.ab[1] = 0;\n\n         if(av != 0 || ap != 0) {\n             co.p[0].transfer(av);\n             co.p[1].transfer(ap);\n         }\n\n         if(x != 0 || w != 0) {\n             require(\n                 co.dl.transfer(co.p[0], x),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 co.dl.transfer(co.p[1], w),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         co.dh = false;\n         ax--;\n\n         emit DidLCClose(dn, co.cf, av, ap, x, w);\n     }\n\n     function af(bytes32 do, bytes de, bytes32 dq) internal pure returns (bool) {\n         bytes32 df = do;\n         bytes32 bl;\n\n         for (uint256 i = 64; i <= de.length; i += 32) {\n             assembly { bl := mload(add(de, i)) }\n\n             if (df < bl) {\n                 df = bm(abi.ag(df, bl));\n             } else {\n                 df = bm(abi.ag(bl, df));\n             }\n         }\n\n         return df == dq;\n     }\n\n\n     function bd(bytes32 ek) public view returns (\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     ) {\n         Channel memory co = Channels[ek];\n         return (\n             co.p,\n             co.ao,\n             co.ab,\n             co.s,\n             co.cf,\n             co.aq,\n             co.VCrootHash,\n             co.LCopenTimeout,\n             co.l,\n             co.dh,\n             co.h,\n             co.br\n         );\n     }\n\n     function j(bytes32 ek) public view returns(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     ) {\n         VirtualChannel memory r = n[ek];\n         return(\n             r.cs,\n             r.f,\n             r.cf,\n             r.bc,\n             r.k,\n             r.cx,\n             r.db,\n             r.cw,\n             r.ao,\n             r.ab,\n             r.ec\n         );\n     }\n }",
      "rename_map": {
        "possibleTotalTokenBeforeDeposit": "a",
        "possibleTotalEthBeforeDeposit": "b",
        "toEthereumSignedMessage": "c",
        "byzantineCloseChannel": "d",
        "consensusCloseChannel": "e",
        "isInSettlementState": "f",
        "closeVirtualChannel": "g",
        "isUpdateLCSettling": "h",
        "totalTokenDeposit": "i",
        "getVirtualChannel": "j",
        "updateVCtimeout": "k",
        "updateLCtimeout": "l",
        "totalEthDeposit": "m",
        "virtualChannels": "n",
        "approveAndCall": "o",
        "partyAddresses": "p",
        "parseInt16Char": "q",
        "virtualChannel": "r",
        "initialDeposit": "s",
        "_initialAmount": "t",
        "uintToBytes32": "u",
        "tokenBalanceI": "v",
        "tokenbalanceI": "w",
        "tokenbalanceA": "x",
        "hexstrToBytes": "y",
        "_decimalUnits": "z",
        "updateLCstate": "aa",
        "erc20Balances": "ab",
        "tokenBalanceA": "ac",
        "createChannel": "ad",
        "recoverSigner": "ae",
        "_isContained": "af",
        "encodePacked": "ag",
        "prefixedHash": "ah",
        "transferFrom": "ai",
        "updateParams": "aj",
        "_tokenSymbol": "ak",
        "uintToString": "al",
        "_updateState": "am",
        "_confirmTime": "an",
        "ethBalances": "ao",
        "ethbalanceI": "ap",
        "confirmTime": "aq",
        "ethBalanceI": "ar",
        "totalSupply": "as",
        "initVCstate": "at",
        "ethBalanceA": "au",
        "ethbalanceA": "av",
        "joinChannel": "aw",
        "numChannels": "ax",
        "_startIndex": "ay",
        "_extraData": "az",
        "updateBalA": "ba",
        "isSignedBy": "bb",
        "challenger": "bc",
        "getChannel": "bd",
        "_initState": "be",
        "_hashedMsg": "bf",
        "updateBalB": "bg",
        "_tokenName": "bh",
        "recipient": "bi",
        "substring": "bj",
        "channelId": "bk",
        "proofElem": "bl",
        "keccak256": "bm",
        "remainder": "bn",
        "updateBal": "bo",
        "allowance": "bp",
        "_balances": "bq",
        "numOpenVC": "br",
        "balanceOf": "bs",
        "numOpenVc": "bt",
        "_sequence": "bu",
        "ecrecover": "bv",
        "updateSeq": "bw",
        "remaining": "bx",
        "_endIndex": "by",
        "_balance": "bz",
        "balanceB": "ca",
        "strBytes": "cb",
        "balances": "cc",
        "_spender": "cd",
        "decimals": "ce",
        "sequence": "cf",
        "balanceA": "cg",
        "settleVC": "ch",
        "_hexstr": "ci",
        "version": "cj",
        "approve": "ck",
        "_partyI": "cl",
        "success": "cm",
        "_partyA": "cn",
        "channel": "co",
        "allowed": "cp",
        "deposit": "cq",
        "bresult": "cr",
        "isClose": "cs",
        "isToken": "ct",
        "_VCroot": "cu",
        "_partyB": "cv",
        "partyI": "cw",
        "partyA": "cx",
        "symbol": "cy",
        "prefix": "cz",
        "_token": "da",
        "partyB": "db",
        "_owner": "dc",
        "_state": "dd",
        "_proof": "de",
        "cursor": "df",
        "result": "dg",
        "isOpen": "dh",
        "vcRoot": "di",
        "_value": "dj",
        "_bond": "dk",
        "token": "dl",
        "_uint": "dm",
        "_lcID": "dn",
        "_hash": "do",
        "_char": "dp",
        "_root": "dq",
        "_sigI": "dr",
        "_addr": "ds",
        "_sigA": "dt",
        "_vcID": "du",
        "proof": "dv",
        "_from": "dw",
        "name": "dx",
        "bstr": "dy",
        "_str": "dz",
        "sigA": "ea",
        "vcId": "eb",
        "bond": "ec",
        "_sig": "ed",
        "lcId": "ee",
        "_msg": "ef",
        "_to": "eg",
        "len": "eh",
        "str": "ei",
        "now": "ej",
        "id": "ek"
      },
      "changes": [
        "Renamed 141 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_212",
      "transformed_id": "ss_l2_short_nc_ds_212",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier x()\n    {\n        require(msg.sender == am);\n        _;\n    }\n\n   modifier f()\n    {\n        require(m);\n        _;\n    }\n\n    modifier e()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  p()\n    {\n        require (ak[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 af, address y);\n    event Win(uint256 af, address aj);\n    event Lose(uint256 af, address ao);\n    event Donate(uint256 af, address aj, address ac);\n    event DifficultyChanged(uint256 b);\n    event BetLimitChanged(uint256 d);\n\n    address private al;\n    uint256 aa;\n    uint difficulty;\n    uint private v;\n    address am;\n    mapping(address => uint256) t;\n    mapping(address => uint256) ak;\n    bool m;\n    uint256 k;\n\n    constructor(address n, uint256 s)\n    e()\n    public\n    {\n        m = false;\n        am = msg.sender;\n        al = n;\n        k = 0;\n        aa = s;\n\n    }\n\n    function OpenToThePublic()\n    x()\n    public\n    {\n        m = true;\n    }\n\n    function AdjustBetAmounts(uint256 af)\n    x()\n    public\n    {\n        aa = af;\n\n        emit BetLimitChanged(aa);\n    }\n\n    function AdjustDifficulty(uint256 af)\n    x()\n    public\n    {\n        difficulty = af;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function an()\n    f()\n    e()\n    payable\n    public\n    {\n\n        require(msg.value == aa);\n\n\n        require(ak[msg.sender] == 0);\n\n\n        t[msg.sender] = block.number;\n        ak[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function ap()\n    f()\n    e()\n    p()\n    public\n    {\n        uint256 o = t[msg.sender];\n        if(o < block.number)\n        {\n            t[msg.sender] = 0;\n            ak[msg.sender] = 0;\n\n            uint256 h = uint256(z(abi.l(blockhash(o),  msg.sender)))%difficulty +1;\n\n            if(h == difficulty / 2)\n            {\n                ae(msg.sender);\n            }\n            else\n            {\n\n                w(aa / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function ad()\n    f()\n    public\n    payable\n    {\n        i(msg.value);\n    }\n\n    function ae(address ag)\n    internal\n    {\n        uint256 g = address(this).balance / 2;\n\n        ag.transfer(g);\n        emit Win(g, ag);\n    }\n\n    function i(uint256 af)\n    internal\n    {\n        al.call.value(af)(bytes4(z(\"donate()\")));\n        k += af;\n        emit Donate(af, al, msg.sender);\n    }\n\n    function w(uint256 af)\n    internal\n    {\n        al.call.value(af)(bytes4(z(\"donate()\")));\n        k += af;\n        emit Lose(af, msg.sender);\n    }\n\n    function r()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function b()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function d()\n    public\n    view\n    returns (uint256)\n    {\n        return aa;\n    }\n\n    function c(address ai)\n    public\n    view\n    returns (bool)\n    {\n        if(ak[ai] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function q()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function a(address j, address u, uint ah)\n    public\n    x()\n    returns (bool ab)\n    {\n        return ERC20Interface(j).transfer(u, ah);\n    }\n}\n\n\ncontract ERC20Interface\n{\n    function transfer(address aq, uint256 ah) public returns (bool ab);\n}",
      "rename_map": {
        "transferAnyERC20Token": "a",
        "currentDifficulty": "b",
        "hasPlayerWagered": "c",
        "currentBetLimit": "d",
        "onlyRealPeople": "e",
        "isOpenToPublic": "f",
        "ethToTransfer": "g",
        "winningNumber": "h",
        "donateToWhale": "i",
        "tokenAddress": "j",
        "totalDonated": "k",
        "encodePacked": "l",
        "openToPublic": "m",
        "whaleAddress": "n",
        "blockNumber": "o",
        "onlyPlayers": "p",
        "winnersPot": "q",
        "ethBalance": "r",
        "wagerLimit": "s",
        "timestamps": "t",
        "tokenOwner": "u",
        "randomSeed": "v",
        "loseWager": "w",
        "onlyOwner": "x",
        "depositer": "y",
        "keccak256": "z",
        "betLimit": "aa",
        "success": "ab",
        "donator": "ac",
        "donate": "ad",
        "payout": "ae",
        "amount": "af",
        "winner": "ag",
        "tokens": "ah",
        "player": "ai",
        "paidTo": "aj",
        "wagers": "ak",
        "whale": "al",
        "owner": "am",
        "wager": "an",
        "loser": "ao",
        "play": "ap",
        "to": "aq"
      },
      "changes": [
        "Renamed 43 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_213",
      "transformed_id": "ss_l2_short_nc_ds_213",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.11;\ninterface q { function o(address ch, uint256 cc, address bw, bytes am) public; }\n\n\ncontract MigrationAgent {\n    function al(address ch, uint256 cc);\n}\n\ncontract ERC20 {\n  uint public ah;\n  function au(address cm) constant returns (uint);\n  function at(address cd, address bs) constant returns (uint);\n\n  function transfer(address co, uint value) returns (bool cp);\n  function aa(address from, address co, uint value) returns (bool cp);\n  function bh(address bs, uint value) returns (bool cp);\n  event Transfer(address indexed from, address indexed co, uint value);\n  event Approval(address indexed cd, address indexed bs, uint value);\n}\n\ncontract SafeMath {\n  function br(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function bg(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function bq(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function bi(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function ci(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function cg(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function bz(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function cb(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function assert(bool as) internal {\n    if (!as) {\n      throw;\n    }\n  }\n}\n\ncontract StandardToken is ERC20, SafeMath {\n\n\n  event Minted(address bb, uint ca);\n\n\n  mapping(address => uint) ba;\n\n  mapping(address => uint) ai;\n\n  mapping (address => mapping (address => uint)) bn;\n\n\n  function bt() public constant returns (bool cf) {\n    return true;\n  }\n\n  function transfer(address cl, uint cc) returns (bool bk) {\n    ba[msg.sender] = bq(ba[msg.sender], cc);\n    ba[cl] = bi(ba[cl], cc);\n    Transfer(msg.sender, cl, cc);\n    return true;\n  }\n\n  function aa(address ch, address cl, uint cc) returns (bool bk) {\n    uint an = bn[ch][msg.sender];\n\n    ba[cl] = bi(ba[cl], cc);\n    ba[ch] = bq(ba[ch], cc);\n    bn[ch][msg.sender] = bq(an, cc);\n    Transfer(ch, cl, cc);\n    return true;\n  }\n\n  function au(address bx) constant returns (uint balance) {\n    return ba[bx];\n  }\n\n  function bh(address bc, uint cc) returns (bool bk) {\n\n\n    if ((cc != 0) && (bn[msg.sender][bc] != 0)) throw;\n\n    bn[msg.sender][bc] = cc;\n    Approval(msg.sender, bc, cc);\n    return true;\n  }\n\n  function at(address bx, address bc) constant returns (uint ax) {\n    return bn[bx][bc];\n  }\n\n}\n\n\ncontract n{\n\n    string public cj = \"DAO POLSKA TOKEN version 1\";\n    string public bv = \"DPL\";\n    uint8 public constant bd = 18;\n\n\n    address public cd;\n    address public l;\n\n\n    uint256 public b =1.0 ether;\n    uint256 public ag      = 10000.0 ether;\n\n   uint256 public  ah      = 0.0 ether;\n\n\taddress public Chain1 = 0x0;\n\taddress public Chain2 = 0x0;\n\taddress public Chain3 = 0x0;\n\taddress public Chain4 = 0x0;\n\n\taddress public r=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\n    uint256 public u;\n\n    event Migrate(address indexed ch, address indexed cl, uint256 cc);\n    event Refund(address indexed ch, uint256 cc);\n\n\tstruct w{\n\t\tStandardToken y;\n\t\tuint ca;\n\t\taddress ap;\n\t}\n\tmapping(uint => w) ay;\n\tuint x=0;\n\n  mapping (address => uint256) ba;\nmapping (address => uint256) ai;\n  mapping (address => mapping (address => uint256)) bn;\n\n\tevent UpdatedTokenInformation(string bu, string av);\n\n    event Transfer(address indexed ch, address indexed cl, uint256 cc);\n\tevent v(address indexed ch,uint256 cc);\n  event Approval(address indexed bx, address indexed bc, uint256 cc);\n\n\n    event Burn(address indexed from, uint256 value);\n\n  bool public t = false;\n  bool public e = false;\n\n  function n() {\ncd=msg.sender;\nl=msg.sender;\n}\n\nfunction  aw(uint256 ab) public {\n    \t   if (msg.sender != cd) {\n      throw;\n    }\n\t\t    \t   if (t != false) {\n      throw;\n    }\n\tt = true;\n\n\tag = ab ** uint256(bd);\n\n  }\nfunction a(uint256 ab) public {\n    \t   if (msg.sender != cd) {\n      throw;\n    }\n\t    \t   if (t != false) {\n      throw;\n    }\n\n\te = true;\n\tb = ab ** uint256(bd);\n\n  }\n    function p(address bc, uint256 cc, bytes am)\n        public\n        returns (bool bk) {\n        q bs = q(bc);\n        if (bh(bc, cc)) {\n            bs.o(msg.sender, cc, this, am);\n            return true;\n        }\n    }\n\n    function ck(uint256 cc) public returns (bool bk) {\n        require(ba[msg.sender] >= cc);\n        ba[msg.sender] -= cc;\n        ah -= cc;\n        Burn(msg.sender, cc);\n        return true;\n    }\n\n    function be(address ch, uint256 cc) public returns (bool bk) {\n        require(ba[ch] >= cc);\n        require(cc <= bn[ch][msg.sender]);\n        ba[ch] -= cc;\n        bn[ch][msg.sender] -= cc;\n        ah -= cc;\n        Burn(ch, cc);\n        return true;\n    }\n\n  function transfer(address cl, uint256 cc) returns (bool bk) {\n\n\n    if (ba[msg.sender] >= cc && ba[cl] + cc > ba[cl]) {\n\n      ba[msg.sender] -= cc;\n      ba[cl] += cc;\n      Transfer(msg.sender, cl, cc);\n      return true;\n    } else { return false; }\n  }\n\n  function aa(address ch, address cl, uint256 cc) returns (bool bk) {\n\n    if (ba[ch] >= cc && bn[ch][msg.sender] >= cc && ba[cl] + cc > ba[cl]) {\n\n      ba[cl] += cc;\n      ba[ch] -= cc;\n      bn[ch][msg.sender] -= cc;\n      Transfer(ch, cl, cc);\n      return true;\n    } else { return false; }\n  }\n\n  function au(address bx) constant returns (uint256 balance) {\n    return ba[bx];\n  }\n\n  function bh(address bc, uint256 cc) returns (bool bk) {\n    bn[msg.sender][bc] = cc;\n    Approval(msg.sender, bc, cc);\n    return true;\n  }\n\n  function at(address bx, address bc) constant returns (uint256 ax) {\n    return bn[bx][bc];\n  }\n\n\t    function () payable  public {\n\t\t if(bm){\n        v(msg.sender, msg.value);\n\t\tba[msg.sender]=ba[msg.sender]+msg.value;\n\t\t} else throw;\n\n    }\n\n  function f(string ce, string bl) {\n\n\t   if (msg.sender != cd) {\n      throw;\n    }\n\tcj = ce;\n    bv = bl;\n\n    UpdatedTokenInformation(cj, bv);\n  }\n\nfunction g(address bf, int ae) {\n\n\t   if (msg.sender != cd) {\n      throw;\n    }\n\tif(ae==1){Chain1=bf;}\n\tif(ae==2){Chain2=bf;}\n\tif(ae==3){Chain3=bf;}\n\tif(ae==4){Chain4=bf;}\n  }\n\n  function DAOPolskaTokenICOregulations() external returns(string cn) {\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\n}\n\n\n\tfunction ak(address StandardTokenAddress, address bb, uint ca){\n\t\tif (msg.sender != cd) {\n\t\tthrow;\n\t\t}\n\t\tw t = ay[x];\n\t\tt.y = StandardToken(StandardTokenAddress);\n\t\tt.ca = ca;\n\t\tt.ap = bb;\n\t\tt.y.transfer(bb, ca);\n\t\tx++;\n\t}\n\n\nuint public i=1000;\nuint public j=1000;\nuint public CreationRate=1761;\n   uint256 public constant bo = 36000;\nuint256 public m = 5433616;\nbool public bm = true;\nbool public af = false;\nbool public ad= false;\n        function c(address by) payable {\n\n        if (!bm) throw;\n\n\n        if (msg.value == 0) throw;\n\n        if (msg.value > (ag - ah) / CreationRate)\n          throw;\n\n\n\t var z = msg.value;\n\n        var ar = msg.value * CreationRate;\n        ah += ar;\n\n\n        ba[by] += ar;\n        ai[by] += z;\n\n        Transfer(0, by, ar);\n\n\n        uint256 s = 12;\n        uint256 k = \tar * s / (100);\n\n        ah += k;\n\n        ba[l] += k;\n        Transfer(0, l, k);\n\n\t}\n\tfunction d(uint bp){\n\tif(msg.sender == cd) {\n\tj=bp;\n\tCreationRate=i+j;\n\t}\n\t}\n\n    function FundsTransfer() external {\n\tif(bm==true) throw;\n\t\t \tif (!cd.send(this.balance)) throw;\n    }\n\n    function PartialFundsTransfer(uint SubX) external {\n\t      if (msg.sender != cd) throw;\n        cd.send(this.balance - SubX);\n\t}\n\tfunction ao() external {\n\t      if (msg.sender != cd) throw;\n\taf=!af;\n        }\n\n\t\t\tfunction ac() external {\n\t      if (msg.sender != cd) throw;\n\tbm=!bm;\n        }\n    function aj() external {\n\t      if (msg.sender != l) throw;\n\tad=!ad;\n}\n\n\nfunction az() external {\n        if (block.number <= m+8*bo) throw;\n\n        bm = false;\n\t\taf=!af;\n\n        if (msg.sender==cd)\n\t\tcd.send(this.balance);\n    }\n    function bj(uint256 cc) external {\n\n        if (ad) throw;\n\n\n        if (cc == 0) throw;\n        if (cc > ba[msg.sender]) throw;\n\n        ba[msg.sender] -= cc;\n        ah -= cc;\n        u += cc;\n        MigrationAgent(r).al(msg.sender, cc);\n        Migrate(msg.sender, r, cc);\n    }\n\nfunction aq() external {\n\n        if (bm) throw;\n        if (!af) throw;\n\n        var DAOPLTokenValue = ba[msg.sender];\n        var ETHValue = ai[msg.sender];\n        if (ETHValue == 0) throw;\n        ai[msg.sender] = 0;\n        ah -= DAOPLTokenValue;\n\n        Refund(msg.sender, ETHValue);\n        msg.sender.transfer(ETHValue);\n}\n\nfunction h() external returns(string cn) {\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\n}\n\n}",
      "rename_map": {
        "setotherchainstotalsupply": "a",
        "otherchainstotalsupply": "b",
        "createDaoPOLSKAtokens": "c",
        "setBonusCreationRate": "d",
        "otherchainstotalset": "e",
        "setTokenInformation": "f",
        "setChainsAddresses": "g",
        "preICOregulations": "h",
        "tokenCreationRate": "i",
        "bonusCreationRate": "j",
        "additionalTokens": "k",
        "migrationMaster": "l",
        "fundingEndBlock": "m",
        "daoPOLSKAtokens": "n",
        "receiveApproval": "o",
        "approveAndCall": "p",
        "tokenRecipient": "q",
        "migrationAgent": "r",
        "percentOfTotal": "s",
        "supplylimitset": "t",
        "totalMigrated": "u",
        "receivedEther": "v",
        "sendTokenAway": "w",
        "numTransfers": "x",
        "coinContract": "y",
        "numTokensRAW": "z",
        "transferFrom": "aa",
        "supplyLOCKER": "ab",
        "fundingState": "ac",
        "migratestate": "ad",
        "chainnumber": "ae",
        "refundstate": "af",
        "supplylimit": "ag",
        "totalSupply": "ah",
        "balancesRAW": "ai",
        "turnmigrate": "aj",
        "sendTokenAw": "ak",
        "migrateFrom": "al",
        "_extraData": "am",
        "_allowance": "an",
        "turnrefund": "ao",
        "recipient": "ap",
        "refundTRA": "aq",
        "numTokens": "ar",
        "assertion": "as",
        "allowance": "at",
        "balanceOf": "au",
        "newSymbol": "av",
        "setSupply": "aw",
        "remaining": "ax",
        "transfers": "ay",
        "finalize": "az",
        "balances": "ba",
        "receiver": "bb",
        "_spender": "bc",
        "decimals": "bd",
        "burnFrom": "be",
        "chainAd": "bf",
        "safeDiv": "bg",
        "approve": "bh",
        "safeAdd": "bi",
        "migrate": "bj",
        "success": "bk",
        "_symbol": "bl",
        "funding": "bm",
        "allowed": "bn",
        "oneweek": "bo",
        "newRate": "bp",
        "safeSub": "bq",
        "safeMul": "br",
        "spender": "bs",
        "isToken": "bt",
        "newName": "bu",
        "symbol": "bv",
        "_token": "bw",
        "_owner": "bx",
        "holder": "by",
        "max256": "bz",
        "amount": "ca",
        "min256": "cb",
        "_value": "cc",
        "owner": "cd",
        "_name": "ce",
        "weAre": "cf",
        "min64": "cg",
        "_from": "ch",
        "max64": "ci",
        "name": "cj",
        "burn": "ck",
        "_to": "cl",
        "who": "cm",
        "wow": "cn",
        "to": "co",
        "ok": "cp"
      },
      "changes": [
        "Renamed 94 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_214",
      "transformed_id": "ss_l2_short_nc_ds_214",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": false,
      "code": "pragma solidity ^0.4.24;\n\ncontract ERC20 {\n    function df() constant returns (uint hh);\n    function fc( address iy ) constant returns (uint value);\n    function ew( address hx, address gu ) constant returns (uint dz);\n\n    function transfer( address ji, uint value) returns (bool jl);\n    function cs( address from, address ji, uint value) returns (bool jl);\n    function gg( address gu, uint value ) returns (bool jl);\n\n    event Transfer( address indexed from, address indexed ji, uint value);\n    event Approval( address indexed hx, address indexed gu, uint value);\n}\ncontract Ownable {\n  address public hx;\n\n  function Ownable() {\n    hx = msg.sender;\n  }\n\n  modifier ez() {\n    require(msg.sender == hx);\n    _;\n  }\n\n  function ao(address fy) ez {\n    if (fy != address(0)) {\n      hx = fy;\n    }\n  }\n\n}\n\n\ncontract ERC721 {\n\n    function df() public view returns (uint256 ia);\n    function fc(address hj) public view returns (uint256 balance);\n    function gd(uint256 fx) external view returns (address hx);\n    function gg(address ix, uint256 fx) external;\n    function transfer(address ix, uint256 fx) external;\n    function cs(address ii, address ix, uint256 fx) external;\n\n\n    event Transfer(address from, address ji, uint256 gv);\n    event Approval(address hx, address gb, uint256 gv);\n\n\n    function am(bytes4 cn) external view returns (bool);\n}\n\ncontract GeneScienceInterface {\n\n    function bv() public pure returns (bool);\n\n\n    function fo(uint256[2] hi, uint256[2] hf,uint256 jh,uint256 jk, uint256 dd) public returns (uint256[2]);\n\n    function ay(uint256[2] it) public view returns(uint256);\n\n\n    function he(uint256[2] it) public view returns(uint256);\n\n\n    function de(uint256[2] it) public view returns(uint256);\n\n    function bt(uint256[2] ie) public returns(uint256[2]);\n}\n\n\ncontract PandaAccessControl {\n\n\n    event ContractUpgrade(address dr);\n\n\n    address public du;\n    address public dv;\n    address public dw;\n\n\n    bool public hg = false;\n\n\n    modifier gp() {\n        require(msg.sender == du);\n        _;\n    }\n\n\n    modifier gq() {\n        require(msg.sender == dv);\n        _;\n    }\n\n\n    modifier gw() {\n        require(msg.sender == dw);\n        _;\n    }\n\n    modifier ds() {\n        require(\n            msg.sender == dw ||\n            msg.sender == du ||\n            msg.sender == dv\n        );\n        _;\n    }\n\n\n    function hc(address gi) external gp {\n        require(gi != address(0));\n\n        du = gi;\n    }\n\n\n    function gz(address gk) external gp {\n        require(gk != address(0));\n\n        dv = gk;\n    }\n\n\n    function hq(address gr) external gp {\n        require(gr != address(0));\n\n        dw = gr;\n    }\n\n\n    modifier cc() {\n        require(!hg);\n        _;\n    }\n\n\n    modifier ef {\n        require(hg);\n        _;\n    }\n\n\n    function ig() external ds cc {\n        hg = true;\n    }\n\n\n    function gj() public gp ef {\n\n        hg = false;\n    }\n}\n\n\ncontract PandaBase is PandaAccessControl {\n\n\n    uint256 public constant GEN0_TOTAL_COUNT = 16200;\n    uint256 public aw;\n\n\n    event Birth(address hx, uint256 go, uint256 fk, uint256 hr, uint256[2] il);\n\n\n    event Transfer(address from, address ji, uint256 gv);\n\n\n    struct Panda {\n\n\n        uint256[2] il;\n\n\n        uint64 el;\n\n\n        uint64 at;\n\n\n        uint32 fk;\n        uint32 hr;\n\n\n        uint32 cr;\n\n\n        uint16 cj;\n\n\n        uint16 ed;\n    }\n\n\n    uint32[9] public en = [\n        uint32(5 minutes),\n        uint32(30 minutes),\n        uint32(2 hours),\n        uint32(4 hours),\n        uint32(8 hours),\n        uint32(24 hours),\n        uint32(48 hours),\n        uint32(72 hours),\n        uint32(7 days)\n    ];\n\n\n    uint256 public ba = 15;\n\n\n    Panda[] hn;\n\n\n    mapping (uint256 => address) public al;\n\n\n    mapping (address => uint256) v;\n\n\n    mapping (uint256 => address) public q;\n\n\n    mapping (uint256 => address) public o;\n\n\n    SaleClockAuction public cy;\n\n\n    SiringClockAuction public ca;\n\n\n    GeneScienceInterface public dc;\n\n    SaleClockAuctionERC20 public as;\n\n\n    mapping (uint256 => uint256) public bk;\n    mapping (uint256 => uint256) public bf;\n\n\n    function u(uint256 jd) view external returns(uint256) {\n        return bk[jd];\n    }\n\n    function y(uint256 jd) view external returns(uint256) {\n        return bf[jd];\n    }\n\n    function ab(uint256 jd,uint256 hb) external ds {\n        require (bk[jd]==0);\n        require (hb==uint256(uint32(hb)));\n        bk[jd] = hb;\n    }\n\n    function bw(uint256 jf) view external returns(uint256) {\n        Panda memory jj = hn[jf];\n        return dc.de(jj.il);\n    }\n\n\n    function ex(address ii, address ix, uint256 fx) internal {\n\n        v[ix]++;\n\n        al[fx] = ix;\n\n        if (ii != address(0)) {\n            v[ii]--;\n\n            delete o[fx];\n\n            delete q[fx];\n        }\n\n        Transfer(ii, ix, fx);\n    }\n\n\n    function cl(\n        uint256 fg,\n        uint256 gn,\n        uint256 dk,\n        uint256[2] hp,\n        address hj\n    )\n        internal\n        returns (uint)\n    {\n\n\n        require(fg == uint256(uint32(fg)));\n        require(gn == uint256(uint32(gn)));\n        require(dk == uint256(uint16(dk)));\n\n\n        uint16 cj = 0;\n\n        if (hn.length>0){\n            uint16 ek = uint16(dc.ay(hp));\n            if (ek==0) {\n                ek = 1;\n            }\n            cj = 1000/ek;\n            if (cj%10 < 5){\n                cj = cj/10;\n            }else{\n                cj = cj/10 + 1;\n            }\n            cj = cj - 1;\n            if (cj > 8) {\n                cj = 8;\n            }\n            uint256 jd = dc.de(hp);\n            if (jd>0 && bk[jd]<=bf[jd]) {\n                hp = dc.bt(hp);\n                jd = 0;\n            }\n\n            if (jd == 1){\n                cj = 5;\n            }\n\n\n            if (jd>0){\n                bf[jd] = bf[jd] + 1;\n            }\n\n            if (dk <= 1 && jd != 1){\n                require(aw<GEN0_TOTAL_COUNT);\n                aw++;\n            }\n        }\n\n        Panda memory hw = Panda({\n            il: hp,\n            el: uint64(je),\n            at: 0,\n            fk: uint32(fg),\n            hr: uint32(gn),\n            cr: 0,\n            cj: cj,\n            ed: uint16(dk)\n        });\n        uint256 dj = hn.push(hw) - 1;\n\n\n        require(dj == uint256(uint32(dj)));\n\n\n        Birth(\n            hj,\n            dj,\n            uint256(hw.fk),\n            uint256(hw.hr),\n            hw.il\n        );\n\n\n        ex(0, hj, dj);\n\n        return dj;\n    }\n\n\n    function ad(uint256 is) external ds {\n        require(is < en[0]);\n        ba = is;\n    }\n}\n\n\ncontract ERC721Metadata {\n\n    function da(uint256 fx, string) public view returns (bytes32[4] hu, uint256 ib) {\n        if (fx == 1) {\n            hu[0] = \"Hello World! :D\";\n            ib = 15;\n        } else if (fx == 2) {\n            hu[0] = \"I would definitely choose a medi\";\n            hu[1] = \"um length string.\";\n            ib = 49;\n        } else if (fx == 3) {\n            hu[0] = \"Lorem ipsum dolor sit amet, mi e\";\n            hu[1] = \"st accumsan dapibus augue lorem,\";\n            hu[2] = \" tristique vestibulum id, libero\";\n            hu[3] = \" suscipit varius sapien aliquam.\";\n            ib = 128;\n        }\n    }\n}\n\n\ncontract PandaOwnership is PandaBase, ERC721 {\n\n\n    string public constant im = \"PandaEarth\";\n    string public constant hd = \"PE\";\n\n    bytes4 constant InterfaceSignature_ERC165 =\n        bytes4(eo('am(bytes4)'));\n\n    bytes4 constant InterfaceSignature_ERC721 =\n        bytes4(eo('im()')) ^\n        bytes4(eo('hd()')) ^\n        bytes4(eo('df()')) ^\n        bytes4(eo('fc(address)')) ^\n        bytes4(eo('gd(uint256)')) ^\n        bytes4(eo('gg(address,uint256)')) ^\n        bytes4(eo('transfer(address,uint256)')) ^\n        bytes4(eo('cs(address,address,uint256)')) ^\n        bytes4(eo('bn(address)')) ^\n        bytes4(eo('tokenMetadata(uint256,string)'));\n\n\n    function am(bytes4 cn) external view returns (bool)\n    {\n\n\n        return ((cn == InterfaceSignature_ERC165) || (cn == InterfaceSignature_ERC721));\n    }\n\n\n    function ij(address fa, uint256 fx) internal view returns (bool) {\n        return al[fx] == fa;\n    }\n\n\n    function cv(address fa, uint256 fx) internal view returns (bool) {\n        return q[fx] == fa;\n    }\n\n\n    function fp(uint256 fx, address fe) internal {\n        q[fx] = fe;\n    }\n\n\n    function fc(address hj) public view returns (uint256 ib) {\n        return v[hj];\n    }\n\n\n    function transfer(\n        address ix,\n        uint256 fx\n    )\n        external\n        cc\n    {\n\n        require(ix != address(0));\n\n\n        require(ix != address(this));\n\n\n        require(ix != address(cy));\n        require(ix != address(ca));\n\n\n        require(ij(msg.sender, fx));\n\n\n        ex(msg.sender, ix, fx);\n    }\n\n\n    function gg(\n        address ix,\n        uint256 fx\n    )\n        external\n        cc\n    {\n\n        require(ij(msg.sender, fx));\n\n\n        fp(fx, ix);\n\n\n        Approval(msg.sender, ix, fx);\n    }\n\n\n    function cs(\n        address ii,\n        address ix,\n        uint256 fx\n    )\n        external\n        cc\n    {\n\n        require(ix != address(0));\n\n\n        require(ix != address(this));\n\n        require(cv(msg.sender, fx));\n        require(ij(ii, fx));\n\n\n        ex(ii, ix, fx);\n    }\n\n\n    function df() public view returns (uint) {\n        return hn.length - 1;\n    }\n\n\n    function gd(uint256 fx)\n        external\n        view\n        returns (address hx)\n    {\n        hx = al[fx];\n\n        require(hx != address(0));\n    }\n\n\n    function bn(address hj) external view returns(uint256[] di) {\n        uint256 dx = fc(hj);\n\n        if (dx == 0) {\n\n            return new uint256[](0);\n        } else {\n            uint256[] memory hs = new uint256[](dx);\n            uint256 ev = df();\n            uint256 dl = 0;\n\n\n            uint256 hy;\n\n            for (hy = 1; hy <= ev; hy++) {\n                if (al[hy] == hj) {\n                    hs[dl] = hy;\n                    dl++;\n                }\n            }\n\n            return hs;\n        }\n    }\n\n\n    function gl(uint ik, uint ir, uint iu) private view {\n\n        for(; iu >= 32; iu -= 32) {\n            assembly {\n                mstore(ik, mload(ir))\n            }\n            ik += 32;\n            ir += 32;\n        }\n\n\n        uint256 io = 256 ** (32 - iu) - 1;\n        assembly {\n            let ge := and(mload(ir), not(io))\n            let fl := and(mload(ik), io)\n            mstore(ik, or(fl, ge))\n        }\n    }\n\n\n    function fb(bytes32[4] es, uint256 bq) private view returns (string) {\n        var ck = new string(bq);\n        uint256 fd;\n        uint256 fj;\n\n        assembly {\n            fd := add(ck, 32)\n            fj := es\n        }\n\n        gl(fd, fj, bq);\n\n        return ck;\n    }\n\n}\n\n\ncontract PandaBreeding is PandaOwnership {\n\n    uint256 public constant GENSIS_TOTAL_COUNT = 100;\n\n\n    event Pregnant(address hx, uint256 fk, uint256 hr, uint256 at);\n\n    event Abortion(address hx, uint256 fk, uint256 hr);\n\n\n    uint256 public cm = 2 finney;\n\n\n    uint256 public bh;\n\n    mapping(uint256 => address) eb;\n\n\n    function n(address fs) external gp {\n        GeneScienceInterface ap = GeneScienceInterface(fs);\n\n\n        require(ap.bv());\n\n\n        dc = ap;\n    }\n\n\n    function bc(Panda iv) internal view returns(bool) {\n\n\n        return (iv.cr == 0) && (iv.at <= uint64(block.number));\n    }\n\n\n    function af(uint256 gn, uint256 fg) internal view returns(bool) {\n        address dn = al[fg];\n        address ep = al[gn];\n\n\n        return (dn == ep || o[gn] == dn);\n    }\n\n\n    function au(Panda storage gt) internal {\n\n        gt.at = uint64((en[gt.cj] / ba) + block.number);\n\n\n        if (gt.cj < 8 && dc.de(gt.il) != 1) {\n            gt.cj += 1;\n        }\n    }\n\n\n    function bp(address id, uint256 gn)\n    external\n    cc {\n        require(ij(msg.sender, gn));\n        o[gn] = id;\n    }\n\n\n    function ax(uint256 jc) external gw {\n        cm = jc;\n    }\n\n\n    function z(Panda gs) private view returns(bool) {\n        return (gs.cr != 0) && (gs.at <= uint64(block.number));\n    }\n\n\n    function bg(uint256 fv)\n    public\n    view\n    returns(bool) {\n        require(fv > 0);\n        Panda storage jg = hn[fv];\n        return bc(jg);\n    }\n\n\n    function dy(uint256 fv)\n    public\n    view\n    returns(bool) {\n        require(fv > 0);\n\n        return hn[fv].cr != 0;\n    }\n\n\n    function ag(\n        Panda storage gs,\n        uint256 fg,\n        Panda storage hz,\n        uint256 gn\n    )\n    private\n    view\n    returns(bool) {\n\n        if (fg == gn) {\n            return false;\n        }\n\n\n        if (gs.fk == gn || gs.hr == gn) {\n            return false;\n        }\n        if (hz.fk == fg || hz.hr == fg) {\n            return false;\n        }\n\n\n        if (hz.fk == 0 || gs.fk == 0) {\n            return true;\n        }\n\n\n        if (hz.fk == gs.fk || hz.fk == gs.hr) {\n            return false;\n        }\n        if (hz.hr == gs.fk || hz.hr == gs.hr) {\n            return false;\n        }\n\n\n        if (dc.he(gs.il) + dc.he(hz.il) != 1) {\n            return false;\n        }\n\n\n        return true;\n    }\n\n\n    function e(uint256 fg, uint256 gn)\n    internal\n    view\n    returns(bool) {\n        Panda storage ha = hn[fg];\n        Panda storage ip = hn[gn];\n        return ag(ha, fg, ip, gn);\n    }\n\n\n    function cp(uint256 fg, uint256 gn)\n    external\n    view\n    returns(bool) {\n        require(fg > 0);\n        require(gn > 0);\n        Panda storage ha = hn[fg];\n        Panda storage ip = hn[gn];\n        return ag(ha, fg, ip, gn) &&\n            af(gn, fg);\n    }\n\n    function m(uint256 fg, uint256 gn) internal returns(uint256, uint256) {\n        if (dc.he(hn[fg].il) == 1) {\n            return (gn, fg);\n        } else {\n            return (fg, gn);\n        }\n    }\n\n\n    function ej(uint256 fg, uint256 gn, address hj) internal {\n\n        (fg, gn) = m(fg, gn);\n\n        Panda storage ip = hn[gn];\n        Panda storage ha = hn[fg];\n\n\n        ha.cr = uint32(gn);\n\n\n        au(ip);\n        au(ha);\n\n\n        delete o[fg];\n        delete o[gn];\n\n\n        bh++;\n\n        eb[fg] = hj;\n\n\n        Pregnant(al[fg], fg, gn, ha.at);\n    }\n\n\n    function cf(uint256 fg, uint256 gn)\n    external\n    payable\n    cc {\n\n        require(msg.value >= cm);\n\n\n        require(ij(msg.sender, fg));\n\n\n        require(af(gn, fg));\n\n\n        Panda storage ha = hn[fg];\n\n\n        require(bc(ha));\n\n\n        Panda storage ip = hn[gn];\n\n\n        require(bc(ip));\n\n\n        require(ag(\n            ha,\n            fg,\n            ip,\n            gn\n        ));\n\n\n        ej(fg, gn, msg.sender);\n    }\n\n\n    function fh(uint256 fg, uint256[2] dg, uint256[2] fi)\n    external\n    cc\n    ds\n    returns(uint256) {\n\n        Panda storage ha = hn[fg];\n\n\n        require(ha.el != 0);\n\n\n        require(z(ha));\n\n\n        uint256 hr = ha.cr;\n        Panda storage ip = hn[hr];\n\n\n        uint16 et = ha.ed;\n        if (ip.ed > ha.ed) {\n            et = ip.ed;\n        }\n\n\n        uint256[2] memory ee = dg;\n\n        uint256 gc = 0;\n\n\n        uint256 db = (dc.ay(ha.il) + dc.ay(ip.il)) / 2 + fi[0];\n        if (db >= (et + 1) * fi[1]) {\n            db = db - (et + 1) * fi[1];\n        } else {\n            db = 0;\n        }\n        if (et == 0 && aw == GEN0_TOTAL_COUNT) {\n            db = 0;\n        }\n        if (uint256(eo(block.blockhash(block.number - 2), je)) % 100 < db) {\n\n            address hx = eb[fg];\n            gc = cl(fg, ha.cr, et + 1, ee, hx);\n        } else {\n            Abortion(al[fg], fg, hr);\n        }\n\n\n        delete ha.cr;\n\n\n        bh--;\n\n\n        msg.sender.send(cm);\n\n        delete eb[fg];\n\n\n        return gc;\n    }\n}\n\n\ncontract ClockAuctionBase {\n\n\n    struct Auction {\n\n        address hm;\n\n        uint128 bx;\n\n        uint128 dh;\n\n        uint64 fr;\n\n\n        uint64 er;\n\n        uint64 hl;\n    }\n\n\n    ERC721 public x;\n\n\n    uint256 public fz;\n\n\n    mapping (uint256 => Auction) ar;\n\n    event AuctionCreated(uint256 gv, uint256 bx, uint256 dh, uint256 fr);\n    event AuctionSuccessful(uint256 gv, uint256 ea, address hv);\n    event AuctionCancelled(uint256 gv);\n\n\n    function ij(address fa, uint256 fx) internal view returns (bool) {\n        return (x.gd(fx) == fa);\n    }\n\n\n    function gh(address hj, uint256 fx) internal {\n\n        x.cs(hj, this, fx);\n    }\n\n\n    function ex(address ff, uint256 fx) internal {\n\n        x.transfer(ff, fx);\n    }\n\n\n    function dq(uint256 fx, Auction fu) internal {\n\n\n        require(fu.fr >= 1 minutes);\n\n        ar[fx] = fu;\n\n        AuctionCreated(\n            uint256(fx),\n            uint256(fu.bx),\n            uint256(fu.dh),\n            uint256(fu.fr)\n        );\n    }\n\n\n    function bi(uint256 fx, address gm) internal {\n        bm(fx);\n        ex(gm, fx);\n        AuctionCancelled(fx);\n    }\n\n\n    function in(uint256 fx, uint256 ec)\n        internal\n        returns (uint256)\n    {\n\n        Auction storage gx = ar[fx];\n\n\n        require(cq(gx));\n\n\n        uint256 if = bs(gx);\n        require(ec >= if);\n\n\n        address hm = gx.hm;\n\n\n        bm(fx);\n\n\n        if (if > 0) {\n\n\n            uint256 ci = cz(if);\n            uint256 bj = if - ci;\n\n\n            hm.transfer(bj);\n        }\n\n\n        uint256 ey = ec - if;\n\n\n        msg.sender.transfer(ey);\n\n\n        AuctionSuccessful(fx, if, msg.sender);\n\n        return if;\n    }\n\n\n    function bm(uint256 fx) internal {\n        delete ar[fx];\n    }\n\n\n    function cq(Auction storage fu) internal view returns (bool) {\n        return (fu.er > 0);\n    }\n\n\n    function bs(Auction storage fu)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 ch = 0;\n\n\n        if (je > fu.er) {\n            ch = je - fu.er;\n        }\n\n        return t(\n            fu.bx,\n            fu.dh,\n            fu.fr,\n            ch\n        );\n    }\n\n\n    function t(\n        uint256 be,\n        uint256 cw,\n        uint256 eq,\n        uint256 bl\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n\n\n        if (bl >= eq) {\n\n\n            return cw;\n        } else {\n\n\n            int256 aq = int256(cw) - int256(be);\n\n\n            int256 ac = aq * int256(bl) / int256(eq);\n\n\n            int256 co = int256(be) + ac;\n\n            return uint256(co);\n        }\n    }\n\n\n    function cz(uint256 hk) internal view returns (uint256) {\n\n\n        return hk * fz / 10000;\n    }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public hg = false;\n\n  modifier cc() {\n    require(!hg);\n    _;\n  }\n\n  modifier ef {\n    require(hg);\n    _;\n  }\n\n  function ig() ez cc returns (bool) {\n    hg = true;\n    Pause();\n    return true;\n  }\n\n  function gj() ez ef returns (bool) {\n    hg = false;\n    Unpause();\n    return true;\n  }\n}\n\n\ncontract ClockAuction is Pausable, ClockAuctionBase {\n\n\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n\n\n    function ClockAuction(address dm, uint256 iw) public {\n        require(iw <= 10000);\n        fz = iw;\n\n        ERC721 ap = ERC721(dm);\n        require(ap.am(InterfaceSignature_ERC721));\n        x = ap;\n    }\n\n\n    function bb() external {\n        address eh = address(x);\n\n        require(\n            msg.sender == hx ||\n            msg.sender == eh\n        );\n\n        bool ja = eh.send(this.balance);\n    }\n\n\n    function ce(\n        uint256 fx,\n        uint256 be,\n        uint256 cw,\n        uint256 eq,\n        address gm\n    )\n        external\n        cc\n    {\n\n\n        require(be == uint256(uint128(be)));\n        require(cw == uint256(uint128(cw)));\n        require(eq == uint256(uint64(eq)));\n\n        require(ij(msg.sender, fx));\n        gh(msg.sender, fx);\n        Auction memory gx = Auction(\n            gm,\n            uint128(be),\n            uint128(cw),\n            uint64(eq),\n            uint64(je),\n            0\n        );\n        dq(fx, gx);\n    }\n\n\n    function jb(uint256 fx)\n        external\n        payable\n        cc\n    {\n\n        in(fx, msg.value);\n        ex(msg.sender, fx);\n    }\n\n\n    function cg(uint256 fx)\n        external\n    {\n        Auction storage gx = ar[fx];\n        require(cq(gx));\n        address hm = gx.hm;\n        require(msg.sender == hm);\n        bi(fx, hm);\n    }\n\n\n    function f(uint256 fx)\n        ef\n        ez\n        external\n    {\n        Auction storage gx = ar[fx];\n        require(cq(gx));\n        bi(fx, gx.hm);\n    }\n\n\n    function ei(uint256 fx)\n        external\n        view\n        returns\n    (\n        address hm,\n        uint256 bx,\n        uint256 dh,\n        uint256 fr,\n        uint256 er\n    ) {\n        Auction storage gx = ar[fx];\n        require(cq(gx));\n        return (\n            gx.hm,\n            gx.bx,\n            gx.dh,\n            gx.fr,\n            gx.er\n        );\n    }\n\n\n    function az(uint256 fx)\n        external\n        view\n        returns (uint256)\n    {\n        Auction storage gx = ar[fx];\n        require(cq(gx));\n        return bs(gx);\n    }\n\n}\n\n\ncontract SiringClockAuction is ClockAuction {\n\n\n    bool public r = true;\n\n\n    function SiringClockAuction(address ft, uint256 iw) public\n        ClockAuction(ft, iw) {}\n\n\n    function ce(\n        uint256 fx,\n        uint256 be,\n        uint256 cw,\n        uint256 eq,\n        address gm\n    )\n        external\n    {\n\n\n        require(be == uint256(uint128(be)));\n        require(cw == uint256(uint128(cw)));\n        require(eq == uint256(uint64(eq)));\n\n        require(msg.sender == address(x));\n        gh(gm, fx);\n        Auction memory gx = Auction(\n            gm,\n            uint128(be),\n            uint128(cw),\n            uint64(eq),\n            uint64(je),\n            0\n        );\n        dq(fx, gx);\n    }\n\n\n    function jb(uint256 fx)\n        external\n        payable\n    {\n        require(msg.sender == address(x));\n        address hm = ar[fx].hm;\n\n        in(fx, msg.value);\n\n\n        ex(hm, fx);\n    }\n\n}\n\n\ncontract SaleClockAuction is ClockAuction {\n\n\n    bool public aj = true;\n\n\n    uint256 public by;\n    uint256[5] public ah;\n    uint256 public constant SurpriseValue = 10 finney;\n\n    uint256[] CommonPanda;\n    uint256[] RarePanda;\n    uint256   CommonPandaIndex;\n    uint256   RarePandaIndex;\n\n\n    function SaleClockAuction(address ft, uint256 iw) public\n        ClockAuction(ft, iw) {\n            CommonPandaIndex = 1;\n            RarePandaIndex   = 1;\n    }\n\n\n    function ce(\n        uint256 fx,\n        uint256 be,\n        uint256 cw,\n        uint256 eq,\n        address gm\n    )\n        external\n    {\n\n\n        require(be == uint256(uint128(be)));\n        require(cw == uint256(uint128(cw)));\n        require(eq == uint256(uint64(eq)));\n\n        require(msg.sender == address(x));\n        gh(gm, fx);\n        Auction memory gx = Auction(\n            gm,\n            uint128(be),\n            uint128(cw),\n            uint64(eq),\n            uint64(je),\n            0\n        );\n        dq(fx, gx);\n    }\n\n    function ak(\n        uint256 fx,\n        uint256 be,\n        uint256 cw,\n        uint256 eq,\n        address gm\n    )\n        external\n    {\n\n\n        require(be == uint256(uint128(be)));\n        require(cw == uint256(uint128(cw)));\n        require(eq == uint256(uint64(eq)));\n\n        require(msg.sender == address(x));\n        gh(gm, fx);\n        Auction memory gx = Auction(\n            gm,\n            uint128(be),\n            uint128(cw),\n            uint64(eq),\n            uint64(je),\n            1\n        );\n        dq(fx, gx);\n    }\n\n\n    function jb(uint256 fx)\n        external\n        payable\n    {\n\n        uint64 hl = ar[fx].hl;\n        uint256 if = in(fx, msg.value);\n        ex(msg.sender, fx);\n\n\n        if (hl == 1) {\n\n            ah[by % 5] = if;\n            by++;\n        }\n    }\n\n    function dp(uint256 fx,uint256 ic)\n        external\n    {\n        require(msg.sender == address(x));\n        if (ic == 0) {\n            CommonPanda.push(fx);\n        }else {\n            RarePanda.push(fx);\n        }\n    }\n\n    function cb()\n        external\n        payable\n    {\n        bytes32 ih = eo(block.blockhash(block.number),block.blockhash(block.number-1));\n        uint256 PandaIndex;\n        if (ih[25] > 0xC8) {\n            require(uint256(RarePanda.length) >= RarePandaIndex);\n            PandaIndex = RarePandaIndex;\n            RarePandaIndex ++;\n\n        } else{\n            require(uint256(CommonPanda.length) >= CommonPandaIndex);\n            PandaIndex = CommonPandaIndex;\n            CommonPandaIndex ++;\n        }\n        ex(msg.sender,PandaIndex);\n    }\n\n    function ct() external view returns(uint256 ht,uint256 fw) {\n        ht   = CommonPanda.length + 1 - CommonPandaIndex;\n        fw = RarePanda.length + 1 - RarePandaIndex;\n    }\n\n    function p() external view returns (uint256) {\n        uint256 iz = 0;\n        for (uint256 i = 0; i < 5; i++) {\n            iz += ah[i];\n        }\n        return iz / 5;\n    }\n\n}\n\n\ncontract SaleClockAuctionERC20 is ClockAuction {\n\n    event AuctionERC20Created(uint256 gv, uint256 bx, uint256 dh, uint256 fr, address br);\n\n\n    bool public d = true;\n\n    mapping (uint256 => address) public k;\n\n    mapping (address => uint256) public i;\n\n    mapping (address => uint256) public fq;\n\n\n    function SaleClockAuctionERC20(address ft, uint256 iw) public\n        ClockAuction(ft, iw) {}\n\n    function aa(address bz, uint256 ho) external{\n        require (msg.sender == address(x));\n\n        require (bz != address(0));\n\n        i[bz] = ho;\n    }\n\n\n    function ce(\n        uint256 fx,\n        address cd,\n        uint256 be,\n        uint256 cw,\n        uint256 eq,\n        address gm\n    )\n        external\n    {\n\n\n        require(be == uint256(uint128(be)));\n        require(cw == uint256(uint128(cw)));\n        require(eq == uint256(uint64(eq)));\n\n        require(msg.sender == address(x));\n\n        require (i[cd] > 0);\n\n        gh(gm, fx);\n        Auction memory gx = Auction(\n            gm,\n            uint128(be),\n            uint128(cw),\n            uint64(eq),\n            uint64(je),\n            0\n        );\n        av(fx, gx, cd);\n        k[fx] = cd;\n    }\n\n\n    function av(uint256 fx, Auction fu, address bz) internal {\n\n\n        require(fu.fr >= 1 minutes);\n\n        ar[fx] = fu;\n\n        AuctionERC20Created(\n            uint256(fx),\n            uint256(fu.bx),\n            uint256(fu.dh),\n            uint256(fu.fr),\n            bz\n        );\n    }\n\n    function jb(uint256 fx)\n        external\n        payable{\n\n    }\n\n\n    function fn(uint256 fx,uint256 gy)\n        external\n    {\n\n        address hm = ar[fx].hm;\n        address bz = k[fx];\n        require (bz != address(0));\n        uint256 if = em(bz,msg.sender,fx, gy);\n        ex(msg.sender, fx);\n        delete k[fx];\n    }\n\n    function cg(uint256 fx)\n        external\n    {\n        Auction storage gx = ar[fx];\n        require(cq(gx));\n        address hm = gx.hm;\n        require(msg.sender == hm);\n        bi(fx, hm);\n        delete k[fx];\n    }\n\n    function s(address cd, address ix) external returns(bool ja)  {\n        require (fq[cd] > 0);\n        require(msg.sender == address(x));\n        ERC20(cd).transfer(ix, fq[cd]);\n    }\n\n\n    function em(address cd,address bu, uint256 fx, uint256 ec)\n        internal\n        returns (uint256)\n    {\n\n        Auction storage gx = ar[fx];\n\n\n        require(cq(gx));\n\n        require (cd != address(0) && cd == k[fx]);\n\n\n        uint256 if = bs(gx);\n        require(ec >= if);\n\n\n        address hm = gx.hm;\n\n\n        bm(fx);\n\n\n        if (if > 0) {\n\n\n            uint256 ci = cz(if);\n            uint256 bj = if - ci;\n\n\n            require(ERC20(cd).cs(bu,hm,bj));\n            if (ci > 0){\n                require(ERC20(cd).cs(bu,address(this),ci));\n                fq[cd] += ci;\n            }\n        }\n\n\n        AuctionSuccessful(fx, if, msg.sender);\n\n        return if;\n    }\n}\n\n\ncontract PandaAuction is PandaBreeding {\n\n\n    function l(address fs) external gp {\n        SaleClockAuction ap = SaleClockAuction(fs);\n\n\n        require(ap.aj());\n\n\n        cy = ap;\n    }\n\n    function a(address fs) external gp {\n        SaleClockAuctionERC20 ap = SaleClockAuctionERC20(fs);\n\n\n        require(ap.d());\n\n\n        as = ap;\n    }\n\n\n    function c(address fs) external gp {\n        SiringClockAuction ap = SiringClockAuction(fs);\n\n\n        require(ap.r());\n\n\n        ca = ap;\n    }\n\n\n    function an(\n        uint256 fv,\n        uint256 be,\n        uint256 cw,\n        uint256 eq\n    )\n        external\n        cc\n    {\n\n\n        require(ij(msg.sender, fv));\n\n\n        require(!dy(fv));\n        fp(fv, cy);\n\n\n        cy.ce(\n            fv,\n            be,\n            cw,\n            eq,\n            msg.sender\n        );\n    }\n\n\n    function h(\n        uint256 fv,\n        address bz,\n        uint256 be,\n        uint256 cw,\n        uint256 eq\n    )\n        external\n        cc\n    {\n\n\n        require(ij(msg.sender, fv));\n\n\n        require(!dy(fv));\n        fp(fv, as);\n\n\n        as.ce(\n            fv,\n            bz,\n            be,\n            cw,\n            eq,\n            msg.sender\n        );\n    }\n\n    function b(address bz, uint256 ho) external gw{\n        as.aa(bz,ho);\n    }\n\n\n    function w(\n        uint256 fv,\n        uint256 be,\n        uint256 cw,\n        uint256 eq\n    )\n        external\n        cc\n    {\n\n\n        require(ij(msg.sender, fv));\n        require(bg(fv));\n        fp(fv, ca);\n\n\n        ca.ce(\n            fv,\n            be,\n            cw,\n            eq,\n            msg.sender\n        );\n    }\n\n\n    function ae(\n        uint256 gn,\n        uint256 fg\n    )\n        external\n        payable\n        cc\n    {\n\n        require(ij(msg.sender, fg));\n        require(bg(fg));\n        require(e(fg, gn));\n\n\n        uint256 co = ca.az(gn);\n        require(msg.value >= co + cm);\n\n\n        ca.jb.value(msg.value - cm)(gn);\n        ej(uint32(fg), uint32(gn), msg.sender);\n    }\n\n\n    function g() external ds {\n        cy.bb();\n        ca.bb();\n    }\n\n    function s(address cd, address ix) external ds {\n        require(as != address(0));\n        as.s(cd,ix);\n    }\n}\n\n\ncontract PandaMinting is PandaAuction {\n\n\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\n\n\n    uint256 public constant GEN0_STARTING_PRICE = 100 finney;\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\n    uint256 public constant OPEN_PACKAGE_PRICE = 10 finney;\n\n\n    function bd(uint256[2] hp, uint256 dk, address hj) external gw {\n        address eg = hj;\n        if (eg == address(0)) {\n            eg = dw;\n        }\n\n        cl(0, 0, dk, hp, eg);\n    }\n\n\n    function dp(uint256[2] hp,uint256 dk,uint256 ic)\n        external\n        payable\n        gw\n        cc\n    {\n        require(msg.value >= OPEN_PACKAGE_PRICE);\n        uint256 gc = cl(0, 0, dk, hp, cy);\n        cy.dp(gc,ic);\n    }\n\n\n    function ak(uint256 fv) external gw {\n        require(ij(msg.sender, fv));\n\n\n        fp(fv, cy);\n\n        cy.ak(\n            fv,\n            j(),\n            0,\n            GEN0_AUCTION_DURATION,\n            msg.sender\n        );\n    }\n\n\n    function j() internal view returns(uint256) {\n        uint256 fm = cy.p();\n\n        require(fm == uint256(uint128(fm)));\n\n        uint256 eu = fm + (fm / 2);\n\n\n        if (eu < GEN0_STARTING_PRICE) {\n            eu = GEN0_STARTING_PRICE;\n        }\n\n        return eu;\n    }\n}\n\n\ncontract PandaCore is PandaMinting {\n\n\n    address public ai;\n\n\n    function PandaCore() public {\n\n        hg = true;\n\n\n        du = msg.sender;\n\n\n        dw = msg.sender;\n\n\n    }\n\n\n    function iq() external gp ef {\n\n        require(hn.length == 0);\n\n        uint256[2] memory hp = [uint256(-1),uint256(-1)];\n\n        bk[1] = 100;\n       cl(0, 0, 0, hp, address(0));\n    }\n\n\n    function bo(address dt) external gp ef {\n\n        ai = dt;\n        ContractUpgrade(dt);\n    }\n\n\n    function() external payable {\n        require(\n            msg.sender == address(cy) ||\n            msg.sender == address(ca)\n        );\n    }\n\n\n    function ga(uint256 jf)\n        external\n        view\n        returns (\n        bool do,\n        bool gf,\n        uint256 cj,\n        uint256 cu,\n        uint256 cr,\n        uint256 el,\n        uint256 fk,\n        uint256 hr,\n        uint256 ed,\n        uint256[2] il\n    ) {\n        Panda storage jg = hn[jf];\n\n\n        do = (jg.cr != 0);\n        gf = (jg.at <= block.number);\n        cj = uint256(jg.cj);\n        cu = uint256(jg.at);\n        cr = uint256(jg.cr);\n        el = uint256(jg.el);\n        fk = uint256(jg.fk);\n        hr = uint256(jg.hr);\n        ed = uint256(jg.ed);\n        il = jg.il;\n    }\n\n\n    function gj() public gp ef {\n        require(cy != address(0));\n        require(ca != address(0));\n        require(dc != address(0));\n        require(ai == address(0));\n\n\n        super.gj();\n    }\n\n\n    function bb() external gq {\n        uint256 balance = this.balance;\n\n        uint256 cx = (bh + 1) * cm;\n\n        if (balance > cx) {\n            dv.send(balance - cx);\n        }\n    }\n}",
      "rename_map": {
        "setSaleAuctionERC20Address": "a",
        "switchSaleAuctionERC20For": "b",
        "setSiringAuctionAddress": "c",
        "isSaleClockAuctionERC20": "d",
        "_canBreedWithViaAuction": "e",
        "cancelAuctionWhenPaused": "f",
        "withdrawAuctionBalances": "g",
        "createSaleAuctionERC20": "h",
        "erc20ContractsSwitcher": "i",
        "_computeNextGen0Price": "j",
        "tokenIdToErc20Address": "k",
        "setSaleAuctionAddress": "l",
        "_exchangeMatronSireId": "m",
        "setGeneScienceAddress": "n",
        "sireAllowedToAddress": "o",
        "averageGen0SalePrice": "p",
        "pandaIndexToApproved": "q",
        "isSiringClockAuction": "r",
        "withdrawERC20Balance": "s",
        "_computeCurrentPrice": "t",
        "getWizzPandaQuotaOf": "u",
        "ownershipTokenCount": "v",
        "createSiringAuction": "w",
        "nonFungibleContract": "x",
        "getWizzPandaCountOf": "y",
        "_isReadyToGiveBirth": "z",
        "erc20ContractSwitch": "aa",
        "setTotalWizzPandaOf": "ab",
        "currentPriceChange": "ac",
        "setSecondsPerBlock": "ad",
        "bidOnSiringAuction": "ae",
        "_isSiringPermitted": "af",
        "_isValidMatingPair": "ag",
        "lastGen0SalePrices": "ah",
        "newContractAddress": "ai",
        "isSaleClockAuction": "aj",
        "createGen0Auction": "ak",
        "pandaIndexToOwner": "al",
        "supportsInterface": "am",
        "createSaleAuction": "an",
        "transferOwnership": "ao",
        "candidateContract": "ap",
        "totalPriceChange": "aq",
        "tokenIdToAuction": "ar",
        "saleAuctionERC20": "as",
        "cooldownEndBlock": "at",
        "_triggerCooldown": "au",
        "_addAuctionERC20": "av",
        "gen0CreatedCount": "aw",
        "setAutoBirthFee": "ax",
        "getPureFromGene": "ay",
        "getCurrentPrice": "az",
        "secondsPerBlock": "ba",
        "withdrawBalance": "bb",
        "_isReadyToBreed": "bc",
        "createWizzPanda": "bd",
        "_startingPrice": "be",
        "wizzPandaCount": "bf",
        "isReadyToBreed": "bg",
        "pregnantPandas": "bh",
        "_cancelAuction": "bi",
        "sellerProceeds": "bj",
        "wizzPandaQuota": "bk",
        "_secondsPassed": "bl",
        "_removeAuction": "bm",
        "tokensOfOwner": "bn",
        "setNewAddress": "bo",
        "approveSiring": "bp",
        "_stringLength": "bq",
        "erc20Contract": "br",
        "_currentPrice": "bs",
        "clearWizzType": "bt",
        "_buyerAddress": "bu",
        "isGeneScience": "bv",
        "getWizzTypeOf": "bw",
        "startingPrice": "bx",
        "gen0SaleCount": "by",
        "_erc20address": "bz",
        "siringAuction": "ca",
        "surprisePanda": "cb",
        "whenNotPaused": "cc",
        "_erc20Address": "cd",
        "createAuction": "ce",
        "breedWithAuto": "cf",
        "cancelAuction": "cg",
        "secondsPassed": "ch",
        "auctioneerCut": "ci",
        "cooldownIndex": "cj",
        "outputString": "ck",
        "_createPanda": "cl",
        "autoBirthFee": "cm",
        "_interfaceID": "cn",
        "currentPrice": "co",
        "canBreedWith": "cp",
        "_isOnAuction": "cq",
        "siringWithId": "cr",
        "transferFrom": "cs",
        "packageCount": "ct",
        "nextActionAt": "cu",
        "_approvedFor": "cv",
        "_endingPrice": "cw",
        "subtractFees": "cx",
        "saleAuction": "cy",
        "_computeCut": "cz",
        "getMetadata": "da",
        "probability": "db",
        "geneScience": "dc",
        "targetBlock": "dd",
        "getWizzType": "de",
        "totalSupply": "df",
        "_childGenes": "dg",
        "endingPrice": "dh",
        "ownerTokens": "di",
        "newKittenId": "dj",
        "_generation": "dk",
        "resultIndex": "dl",
        "_nftAddress": "dm",
        "matronOwner": "dn",
        "isGestating": "do",
        "createPanda": "dp",
        "_addAuction": "dq",
        "newContract": "dr",
        "onlyCLevel": "ds",
        "_v2Address": "dt",
        "ceoAddress": "du",
        "cfoAddress": "dv",
        "cooAddress": "dw",
        "tokenCount": "dx",
        "isPregnant": "dy",
        "_allowance": "dz",
        "totalPrice": "ea",
        "childOwner": "eb",
        "_bidAmount": "ec",
        "generation": "ed",
        "childGenes": "ee",
        "whenPaused": "ef",
        "pandaOwner": "eg",
        "nftAddress": "eh",
        "getAuction": "ei",
        "_breedWith": "ej",
        "pureDegree": "ek",
        "birthTime": "el",
        "_bidERC20": "em",
        "cooldowns": "en",
        "keccak256": "eo",
        "sireOwner": "ep",
        "_duration": "eq",
        "startedAt": "er",
        "_rawBytes": "es",
        "parentGen": "et",
        "nextPrice": "eu",
        "totalCats": "ev",
        "allowance": "ew",
        "_transfer": "ex",
        "bidExcess": "ey",
        "onlyOwner": "ez",
        "_claimant": "fa",
        "_toString": "fb",
        "balanceOf": "fc",
        "outputPtr": "fd",
        "_approved": "fe",
        "_receiver": "ff",
        "_matronId": "fg",
        "giveBirth": "fh",
        "_factors": "fi",
        "bytesPtr": "fj",
        "matronId": "fk",
        "destpart": "fl",
        "avePrice": "fm",
        "bidERC20": "fn",
        "mixGenes": "fo",
        "_approve": "fp",
        "balances": "fq",
        "duration": "fr",
        "_address": "fs",
        "_nftAddr": "ft",
        "_auction": "fu",
        "_pandaId": "fv",
        "surprise": "fw",
        "_tokenId": "fx",
        "newOwner": "fy",
        "ownerCut": "fz",
        "getPanda": "ga",
        "approved": "gb",
        "kittenId": "gc",
        "ownerOf": "gd",
        "srcpart": "ge",
        "isReady": "gf",
        "approve": "gg",
        "_escrow": "gh",
        "_newCEO": "gi",
        "unpause": "gj",
        "_newCFO": "gk",
        "_memcpy": "gl",
        "_seller": "gm",
        "_sireId": "gn",
        "pandaId": "go",
        "onlyCEO": "gp",
        "onlyCFO": "gq",
        "_newCOO": "gr",
        "_matron": "gs",
        "_kitten": "gt",
        "spender": "gu",
        "tokenId": "gv",
        "onlyCOO": "gw",
        "auction": "gx",
        "_amount": "gy",
        "setCFO": "gz",
        "matron": "ha",
        "_total": "hb",
        "setCEO": "hc",
        "symbol": "hd",
        "getSex": "he",
        "genes2": "hf",
        "paused": "hg",
        "supply": "hh",
        "genes1": "hi",
        "_owner": "hj",
        "_price": "hk",
        "isGen0": "hl",
        "seller": "hm",
        "pandas": "hn",
        "_onoff": "ho",
        "_genes": "hp",
        "setCOO": "hq",
        "sireId": "hr",
        "result": "hs",
        "common": "ht",
        "buffer": "hu",
        "winner": "hv",
        "_panda": "hw",
        "owner": "hx",
        "catId": "hy",
        "_sire": "hz",
        "total": "ia",
        "count": "ib",
        "_type": "ic",
        "_addr": "id",
        "_gene": "ie",
        "price": "if",
        "pause": "ig",
        "bHash": "ih",
        "_from": "ii",
        "_owns": "ij",
        "_dest": "ik",
        "genes": "il",
        "name": "im",
        "_bid": "in",
        "mask": "io",
        "sire": "ip",
        "init": "iq",
        "_src": "ir",
        "secs": "is",
        "gene": "it",
        "_len": "iu",
        "_kit": "iv",
        "_cut": "iw",
        "_to": "ix",
        "who": "iy",
        "sum": "iz",
        "res": "ja",
        "bid": "jb",
        "val": "jc",
        "_tp": "jd",
        "now": "je",
        "_id": "jf",
        "kit": "jg",
        "g1": "jh",
        "to": "ji",
        "_p": "jj",
        "g2": "jk",
        "ok": "jl"
      },
      "changes": [
        "Renamed 272 identifiers using short style"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 1879, column 9', 'Syntax error at line 1879, column 12', 'Syntax error at line 1903, column 31']"
    },
    {
      "original_id": "nc_ds_215",
      "transformed_id": "ss_l2_short_nc_ds_215",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier x()\n    {\n        require(msg.sender == am);\n        _;\n    }\n\n   modifier f()\n    {\n        require(m);\n        _;\n    }\n\n    modifier e()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  p()\n    {\n        require (ak[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 af, address y);\n    event Win(uint256 af, address aj);\n    event Lose(uint256 af, address ao);\n    event Donate(uint256 af, address aj, address ac);\n    event DifficultyChanged(uint256 b);\n    event BetLimitChanged(uint256 d);\n\n    address private al;\n    uint256 aa;\n    uint difficulty;\n    uint private v;\n    address am;\n    mapping(address => uint256) t;\n    mapping(address => uint256) ak;\n    bool m;\n    uint256 k;\n\n    constructor(address n, uint256 s)\n    e()\n    public\n    {\n        m = false;\n        am = msg.sender;\n        al = n;\n        k = 0;\n        aa = s;\n\n    }\n\n    function OpenToThePublic()\n    x()\n    public\n    {\n        m = true;\n    }\n\n    function AdjustBetAmounts(uint256 af)\n    x()\n    public\n    {\n        aa = af;\n\n        emit BetLimitChanged(aa);\n    }\n\n    function AdjustDifficulty(uint256 af)\n    x()\n    public\n    {\n        difficulty = af;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function an()\n    f()\n    e()\n    payable\n    public\n    {\n\n        require(msg.value == aa);\n\n\n        t[msg.sender] = block.number;\n        ak[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function ap()\n    f()\n    e()\n    p()\n    public\n    {\n        uint256 o = t[msg.sender];\n        if(o < block.number)\n        {\n            t[msg.sender] = 0;\n            ak[msg.sender] = 0;\n\n            uint256 h = uint256(z(abi.l(blockhash(o),  msg.sender)))%difficulty +1;\n\n            if(h == difficulty / 2)\n            {\n                ae(msg.sender);\n            }\n            else\n            {\n\n                w(aa / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function ad()\n    f()\n    public\n    payable\n    {\n        i(msg.value);\n    }\n\n    function ae(address ag)\n    internal\n    {\n        uint256 g = address(this).balance / 2;\n\n        ag.transfer(g);\n        emit Win(g, ag);\n    }\n\n    function i(uint256 af)\n    internal\n    {\n        al.call.value(af)(bytes4(z(\"donate()\")));\n        k += af;\n        emit Donate(af, al, msg.sender);\n    }\n\n    function w(uint256 af)\n    internal\n    {\n        al.call.value(af)(bytes4(z(\"donate()\")));\n        k += af;\n        emit Lose(af, msg.sender);\n    }\n\n    function r()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function b()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function d()\n    public\n    view\n    returns (uint256)\n    {\n        return aa;\n    }\n\n    function c(address ai)\n    public\n    view\n    returns (bool)\n    {\n        if(ak[ai] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function q()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function a(address j, address u, uint ah)\n    public\n    x()\n    returns (bool ab)\n    {\n        return ERC20Interface(j).transfer(u, ah);\n    }\n}\n\n\ncontract ERC20Interface\n{\n    function transfer(address aq, uint256 ah) public returns (bool ab);\n}",
      "rename_map": {
        "transferAnyERC20Token": "a",
        "currentDifficulty": "b",
        "hasPlayerWagered": "c",
        "currentBetLimit": "d",
        "onlyRealPeople": "e",
        "isOpenToPublic": "f",
        "ethToTransfer": "g",
        "winningNumber": "h",
        "donateToWhale": "i",
        "tokenAddress": "j",
        "totalDonated": "k",
        "encodePacked": "l",
        "openToPublic": "m",
        "whaleAddress": "n",
        "blockNumber": "o",
        "onlyPlayers": "p",
        "winnersPot": "q",
        "ethBalance": "r",
        "wagerLimit": "s",
        "timestamps": "t",
        "tokenOwner": "u",
        "randomSeed": "v",
        "loseWager": "w",
        "onlyOwner": "x",
        "depositer": "y",
        "keccak256": "z",
        "betLimit": "aa",
        "success": "ab",
        "donator": "ac",
        "donate": "ad",
        "payout": "ae",
        "amount": "af",
        "winner": "ag",
        "tokens": "ah",
        "player": "ai",
        "paidTo": "aj",
        "wagers": "ak",
        "whale": "al",
        "owner": "am",
        "wager": "an",
        "loser": "ao",
        "play": "ap",
        "to": "aq"
      },
      "changes": [
        "Renamed 43 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_216",
      "transformed_id": "ss_l2_short_nc_ds_216",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract FiftyFlip {\n    uint constant DONATING_X = 20;\n\n\n    uint constant JACKPOT_FEE = 10;\n    uint constant JACKPOT_MODULO = 1000;\n    uint constant DEV_FEE = 20;\n    uint constant WIN_X = 1900;\n\n\n    uint constant MIN_BET = 0.01 ether;\n    uint constant MAX_BET = 1 ether;\n\n    uint constant BET_EXPIRATION_BLOCKS = 250;\n\n\n    address public bo;\n    address public ag;\n    address public ab;\n    address private bn;\n\n\n    uint256 public ai;\n    uint256 public ak;\n\n\n    uint256 public ad;\n    uint256 public f;\n\n    struct Bet {\n\n        uint bi;\n\n        uint256 ah;\n\n        bool bf;\n\n        address bm;\n    }\n\n    mapping (uint => Bet) bt;\n    mapping (address => uint) y;\n\n\n    event Wager(uint ay, uint av, uint256 p, bool bf, address at);\n    event Win(address bj, uint bi, uint ay, bool bc, uint ao);\n    event Lose(address br, uint bi, uint ay, bool bc, uint ao);\n    event Refund(uint ay, uint256 bi, address aw);\n    event Donate(uint256 bi, address bb);\n    event FailedPayment(address az, uint bi);\n    event Payment(address al, uint bi);\n    event JackpotPayment(address bm, uint ay, uint aj);\n\n\n    constructor (address af, address g, address d) public {\n        bo = msg.sender;\n        ag = g;\n        bn = af;\n        ab = d;\n        ai = 0;\n        ak = 0;\n        ad = 0;\n        f = 0;\n    }\n\n\n    modifier au() {\n        require (msg.sender == bo, \"You are not the owner of this contract!\");\n        _;\n    }\n\n    modifier bd() {\n        require (msg.sender == ag, \"You are not the bot of this contract!\");\n        _;\n    }\n\n    modifier e() {\n        require (address(this).balance >= ad + ai + ak, \"This contract doesn't have enough balance, it is stopped till someone donate to this game!\");\n        _;\n    }\n\n\n    function() public payable { }\n\n    function s(address g)\n    au()\n    external\n    {\n        ag = g;\n    }\n\n    function l(address v)\n    au()\n    external\n    {\n        ab = v;\n    }\n\n\n    function bq(bool bp, uint ay, uint m, uint8 v, bytes32 r, bytes32 s)\n    e()\n    external\n    payable {\n        Bet storage bv = bt[ay];\n        uint bi = msg.value;\n        address bm = msg.sender;\n        require (bv.bm == address(0), \"Ticket is not new one!\");\n        require (bi >= MIN_BET, \"Your bet is lower than minimum bet amount\");\n        require (bi <= MAX_BET, \"Your bet is higher than maximum bet amount\");\n        require (c() >= 2 * bi, \"If we accept this, this contract will be in danger!\");\n\n        require (block.number <= m, \"Ticket has expired.\");\n        bytes32 u = ax(abi.aa('\\x19Ethereum Signed Message:\\n37', uint40(m), ay));\n        require (ab == aq(u, v, r, s), \"web3 vrs signature is not valid.\");\n\n        ai += bi * JACKPOT_FEE / 1000;\n        ak += bi * DEV_FEE / 1000;\n        ad += bi * WIN_X / 1000;\n\n        uint t = bi * DONATING_X / 1000;\n        bn.call.value(t)(bytes4(ax(\"donate()\")));\n        f += t;\n\n        bv.bi = bi;\n        bv.ah = block.number;\n        bv.bf = bp;\n        bv.bm = bm;\n\n        emit Wager(ay, bv.bi, bv.ah, bv.bf, bv.bm);\n    }\n\n\n    function bu(uint ac)\n    e()\n    external\n    {\n        uint ay = uint(ax(abi.aa(ac)));\n        Bet storage bv = bt[ay];\n        require (bv.bm != address(0), \"TicketID is not correct!\");\n        require (bv.bi != 0, \"Ticket is already used one!\");\n        uint256 ah = bv.ah;\n        if(ah < block.number && ah >= block.number - BET_EXPIRATION_BLOCKS)\n        {\n            uint256 bg = uint256(ax(abi.aa(blockhash(ah),  ac)));\n            bool bc = (bg % 2) !=0;\n            uint ao = bg % JACKPOT_MODULO;\n\n            uint w = bv.bi * WIN_X / 1000;\n\n            uint be = 0;\n            uint aj = 0;\n\n            if(bv.bf == bc) {\n                be = w;\n            }\n            if(ao == 0) {\n                aj = ai;\n                ai = 0;\n            }\n            if (aj > 0) {\n                emit JackpotPayment(bv.bm, ay, aj);\n            }\n            if(be + aj > 0)\n            {\n                bh(bv.bm, be + aj, ay, bc, ao);\n            }\n            else\n            {\n                as(bv.bm, bv.bi, ay, bc, ao);\n            }\n            ad -= w;\n            bv.bi = 0;\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function a()\n    external\n    payable\n    {\n        y[msg.sender] += msg.value;\n        emit Donate(msg.value, msg.sender);\n    }\n\n    function j(uint bi)\n    external\n    {\n        require(y[msg.sender] >= bi, \"You are going to withdraw more than you donated!\");\n\n        if (ar(msg.sender, bi)){\n            y[msg.sender] -= bi;\n        }\n    }\n\n\n    function bk(uint ay)\n    e()\n    external {\n        Bet storage bv = bt[ay];\n\n        require (bv.bi != 0, \"this ticket has no balance\");\n        require (block.number > bv.ah + BET_EXPIRATION_BLOCKS, \"this ticket is expired.\");\n        ap(ay);\n    }\n\n\n    function q(address n, uint o)\n    au()\n    e()\n    external {\n        require (ak >= o, \"You are trying to withdraw more amount than developer fee.\");\n        require (o <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (ak <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (ar(n, o)){\n            ak -= o;\n        }\n    }\n\n\n    function r(uint o)\n    bd()\n    e()\n    external {\n        require (ak >= o, \"You are trying to withdraw more amount than developer fee.\");\n        require (o <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (ak <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (ar(ag, o)){\n            ak -= o;\n        }\n    }\n\n\n    function am(uint ay)\n    constant\n    external\n    returns (uint, uint256, bool, address){\n        Bet storage bv = bt[ay];\n        return (bv.bi, bv.ah, bv.bf, bv.bm);\n    }\n\n\n    function h()\n    constant\n    external\n    returns (uint){\n        return address(this).balance;\n    }\n\n\n    function c()\n    constant\n    public\n    returns (uint){\n        if (address(this).balance > ad + ai + ak)\n            return address(this).balance - ad - ai - ak;\n        return 0;\n    }\n\n\n    function bs() external au() {\n        require (ad == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n        selfdestruct(bo);\n    }\n\n\n    function bh(address bj, uint x, uint ay, bool bc, uint ao)\n    internal\n    {\n        bj.transfer(x);\n        emit Win(bj, x, ay, bc, ao);\n    }\n\n\n    function ap(uint ay)\n    internal\n    {\n        Bet storage bv = bt[ay];\n        address aw = bv.bm;\n        uint256 x = bv.bi;\n        aw.transfer(x);\n\n        uint w = bv.bi * WIN_X / 1000;\n        ad -= w;\n\n        bv.bi = 0;\n        emit Refund(ay, x, aw);\n    }\n\n\n    function ar(address az, uint bi) private returns (bool){\n        bool ba = az.send(bi);\n        if (ba) {\n            emit Payment(az, bi);\n        } else {\n            emit FailedPayment(az, bi);\n        }\n        return ba;\n    }\n\n    function as(address bm, uint bi, uint ay, bool bc, uint ao)\n    internal\n    {\n        emit Lose(bm, bi, ay, bc, ao);\n    }\n\n\n    function ae(uint[] k) external {\n        uint length = k.length;\n\n        for (uint i = 0; i < length; i++) {\n            i(k[i]);\n        }\n    }\n\n\n    function i(uint ay) private {\n        Bet storage bv = bt[ay];\n\n\n        if (bv.bi != 0 || block.number <= bv.ah + BET_EXPIRATION_BLOCKS) {\n            return;\n        }\n\n        bv.ah = 0;\n        bv.bf = false;\n        bv.bm = address(0);\n    }\n\n\n    function b(address z, address an, uint bl)\n    public\n    au()\n    returns (bool ba)\n    {\n        return ERC20Interface(z).transfer(an, bl);\n    }\n}\n\n\ncontract ERC20Interface\n{\n    function transfer(address bw, uint256 bl) public returns (bool ba);\n}",
      "rename_map": {
        "donateForContractHealth": "a",
        "transferAnyERC20Token": "b",
        "getCollateralBalance": "c",
        "secretSignerAddress": "d",
        "checkContractHealth": "e",
        "totalAmountToWhale": "f",
        "autoPlayBotAddress": "g",
        "getContractBalance": "h",
        "clearProcessedBet": "i",
        "withdrawDonation": "j",
        "toCleanTicketIDs": "k",
        "setSecretSigner": "l",
        "ticketLastBlock": "m",
        "withdrawAddress": "n",
        "withdrawAmount": "o",
        "betBlockNumber": "p",
        "withdrawDevFee": "q",
        "withdrawBotFee": "r",
        "setBotAddress": "s",
        "donate_amount": "t",
        "signatureHash": "u",
        "_secretSigner": "v",
        "tossWinAmount": "w",
        "ethToTransfer": "x",
        "donateAmount": "y",
        "tokenAddress": "z",
        "encodePacked": "aa",
        "secretSigner": "ab",
        "ticketReveal": "ac",
        "lockedInBets": "ad",
        "clearStorage": "ae",
        "whaleAddress": "af",
        "autoPlayBot": "ag",
        "blockNumber": "ah",
        "jackpotSize": "ai",
        "jackpotWin": "aj",
        "devFeeSize": "ak",
        "noPaidUser": "al",
        "getBetInfo": "am",
        "tokenOwner": "an",
        "jackpotRes": "ao",
        "sendRefund": "ap",
        "ecrecover": "aq",
        "sendFunds": "ar",
        "loseWager": "as",
        "betPlayer": "at",
        "onlyOwner": "au",
        "betAmount": "av",
        "requester": "aw",
        "keccak256": "ax",
        "ticketID": "ay",
        "paidUser": "az",
        "success": "ba",
        "donator": "bb",
        "maskRes": "bc",
        "onlyBot": "bd",
        "tossWin": "be",
        "betMask": "bf",
        "random": "bg",
        "payout": "bh",
        "amount": "bi",
        "winner": "bj",
        "refund": "bk",
        "tokens": "bl",
        "player": "bm",
        "whale": "bn",
        "owner": "bo",
        "bMask": "bp",
        "wager": "bq",
        "loser": "br",
        "kill": "bs",
        "bets": "bt",
        "play": "bu",
        "bet": "bv",
        "to": "bw"
      },
      "changes": [
        "Renamed 75 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_232",
      "transformed_id": "ss_l2_short_nc_ds_232",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\nlibrary SafeMath {\n  function ae(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n\n  function ak(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a / b;\n\n    return c;\n  }\n\n  function ah(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function aj(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint256 public f;\n  function l(address ag) public constant returns (uint256);\n  function transfer(address al, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed al, uint256 value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) p;\n\n  function transfer(address af, uint256 y) public returns (bool) {\n    require(af != address(0));\n    require(y > 0 && y <= p[msg.sender]);\n\n\n    p[msg.sender] = p[msg.sender].ah(y);\n    p[af] = p[af].aj(y);\n    Transfer(msg.sender, af, y);\n    return true;\n  }\n\n  function l(address v) public constant returns (uint256 balance) {\n    return p[v];\n  }\n}\n\ncontract ERC20 is ERC20Basic {\n  function i(address aa, address q) public constant returns (uint256);\n  function e(address from, address al, uint256 value) public returns (bool);\n  function t(address q, uint256 value) public returns (bool);\n  event Approval(address indexed aa, address indexed q, uint256 value);\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal u;\n\n  function e(address ab, address af, uint256 y) public returns (bool) {\n    require(af != address(0));\n    require(y > 0 && y <= p[ab]);\n    require(y <= u[ab][msg.sender]);\n\n    p[ab] = p[ab].ah(y);\n    p[af] = p[af].aj(y);\n    u[ab][msg.sender] = u[ab][msg.sender].ah(y);\n    Transfer(ab, af, y);\n    return true;\n  }\n\n  function t(address n, uint256 y) public returns (bool) {\n    u[msg.sender][n] = y;\n    Approval(msg.sender, n, y);\n    return true;\n  }\n\n  function i(address v, address n) public constant returns (uint256 j) {\n    return u[v][n];\n  }\n}\n\ncontract Ownable {\n  address public aa;\n\n  event OwnershipTransferred(address indexed b, address indexed m);\n\n  function Ownable() {\n    aa = msg.sender;\n  }\n\n  modifier k() {\n    require(msg.sender == aa);\n    _;\n  }\n\n  function a(address m) k public {\n    require(m != address(0));\n    OwnershipTransferred(aa, m);\n    aa = m;\n  }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public z = false;\n\n  modifier c() {\n    require(!z);\n    _;\n  }\n\n  modifier h() {\n    require(z);\n    _;\n  }\n\n  function ac() k c public {\n    z = true;\n    Pause();\n  }\n\n  function r() k h public {\n    z = false;\n    Unpause();\n  }\n}\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address af, uint256 y) public c returns (bool) {\n    return super.transfer(af, y);\n  }\n\n  function e(address ab, address af, uint256 y) public c returns (bool) {\n    return super.e(ab, af, y);\n  }\n\n  function t(address n, uint256 y) public c returns (bool) {\n    return super.t(n, y);\n  }\n\n  function d(address[] g, uint256 y) public c returns (bool) {\n    uint ai = g.length;\n    uint256 w = uint256(ai) * y;\n    require(ai > 0 && ai <= 20);\n    require(y > 0 && p[msg.sender] >= w);\n\n    p[msg.sender] = p[msg.sender].ah(w);\n    for (uint i = 0; i < ai; i++) {\n        p[g[i]] = p[g[i]].aj(y);\n        Transfer(msg.sender, g[i], y);\n    }\n    return true;\n  }\n}\n\ncontract BecToken is PausableToken {\n    string public ad = \"BeautyChain\";\n    string public x = \"BEC\";\n    string public s = '1.0.0';\n    uint8 public o = 18;\n\n    function BecToken() {\n      f = 7000000000 * (10**(uint256(o)));\n      p[msg.sender] = f;\n    }\n\n    function () {\n\n        revert();\n    }\n}",
      "rename_map": {
        "transferOwnership": "a",
        "previousOwner": "b",
        "whenNotPaused": "c",
        "batchTransfer": "d",
        "transferFrom": "e",
        "totalSupply": "f",
        "_receivers": "g",
        "whenPaused": "h",
        "allowance": "i",
        "remaining": "j",
        "onlyOwner": "k",
        "balanceOf": "l",
        "newOwner": "m",
        "_spender": "n",
        "decimals": "o",
        "balances": "p",
        "spender": "q",
        "unpause": "r",
        "version": "s",
        "approve": "t",
        "allowed": "u",
        "_owner": "v",
        "amount": "w",
        "symbol": "x",
        "_value": "y",
        "paused": "z",
        "owner": "aa",
        "_from": "ab",
        "pause": "ac",
        "name": "ad",
        "mul": "ae",
        "_to": "af",
        "who": "ag",
        "sub": "ah",
        "cnt": "ai",
        "add": "aj",
        "div": "ak",
        "to": "al"
      },
      "changes": [
        "Renamed 38 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_233",
      "transformed_id": "ss_l2_short_nc_ds_233",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\nlibrary Deck {\n\n\n\tfunction an(address ac, uint8 s) internal returns (uint8) {\n\t\tuint b = block.number;\n\t\tuint timestamp = block.timestamp;\n\t\treturn uint8(uint256(u(block.blockhash(b), ac, s, timestamp)) % 52);\n\t}\n\n\tfunction z(uint8 ao, bool w) internal constant returns (uint8) {\n\t\tuint8 value = ao / 4;\n\t\tif (value == 0 || value == 11 || value == 12) {\n\t\t\treturn 10;\n\t\t}\n\t\tif (value == 1 && w) {\n\t\t\treturn 11;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction ae(uint8 ao) internal constant returns (bool) {\n\t\treturn ao / 4 == 1;\n\t}\n\n\tfunction al(uint8 ao) internal constant returns (bool) {\n\t\treturn ao / 4 == 10;\n\t}\n}\n\ncontract BlackJack {\n\tusing Deck for *;\n\n\tuint public ab = 50 finney;\n\tuint public ad = 5 ether;\n\n\tuint8 BLACKJACK = 21;\n\n  enum GameState { Ongoing, Player, Tie, House }\n\n\tstruct Game {\n\t\taddress ac;\n\t\tuint aq;\n\n\t\tuint8[] r;\n\t\tuint8[] n;\n\n\t\tGameState ak;\n\t\tuint8 t;\n\t}\n\n\tmapping (address => Game) public ai;\n\n\tmodifier i() {\n\t\tif (ai[msg.sender].ac == 0 || ai[msg.sender].ak != GameState.Ongoing) {\n\t\t\tthrow;\n\t\t}\n\t\t_;\n\t}\n\n\tevent Deal(\n        bool aa,\n        uint8 ah\n    );\n\n    event GameStatus(\n    \tuint8 q,\n    \tuint8 j,\n    \tuint8 m,\n    \tuint8 f\n    );\n\n    event Log(\n    \tuint8 value\n    );\n\n\tfunction BlackJack() {\n\n\t}\n\n\tfunction () payable {\n\n\t}\n\n\n\tfunction an() public payable {\n\t\tif (ai[msg.sender].ac != 0 && ai[msg.sender].ak == GameState.Ongoing) {\n\t\t\tthrow;\n\t\t}\n\n\t\tif (msg.value < ab || msg.value > ad) {\n\t\t\tthrow;\n\t\t}\n\n\t\tuint8[] memory r = new uint8[](1);\n\t\tuint8[] memory n = new uint8[](2);\n\n\n\t\tn[0] = Deck.an(msg.sender, 0);\n\t\tDeal(true, n[0]);\n\t\tr[0] = Deck.an(msg.sender, 1);\n\t\tDeal(false, r[0]);\n\t\tn[1] = Deck.an(msg.sender, 2);\n\t\tDeal(true, n[1]);\n\n\t\tai[msg.sender] = Game({\n\t\t\tac: msg.sender,\n\t\t\taq: msg.value,\n\t\t\tr: r,\n\t\t\tn: n,\n\t\t\tak: GameState.Ongoing,\n\t\t\tt: 3\n\t\t});\n\n\t\tc(ai[msg.sender], false);\n\t}\n\n\n\tfunction ap() public i {\n\t\tuint8 v = ai[msg.sender].t;\n\t\tai[msg.sender].n.push(Deck.an(msg.sender, v));\n\t\tai[msg.sender].t = v + 1;\n\t\tDeal(true, ai[msg.sender].n[ai[msg.sender].n.length - 1]);\n\t\tc(ai[msg.sender], false);\n\t}\n\n\n\tfunction ag() public i {\n\n\t\tvar (q, j) = d(ai[msg.sender].r);\n\n\t\twhile (j < 17) {\n\t\t\tuint8 v = ai[msg.sender].t;\n\t\t\tuint8 y = Deck.an(msg.sender, v);\n\t\t\tai[msg.sender].r.push(y);\n\t\t\tai[msg.sender].t = v + 1;\n\t\t\tj += Deck.z(y, true);\n\t\t\tDeal(false, y);\n\t\t}\n\n\t\tc(ai[msg.sender], true);\n\t}\n\n\n\tfunction c(Game am, bool p) private {\n\n\t\tvar (q, j) = d(am.r);\n\n\t\tvar (m, f) = d(am.n);\n\n\t\tGameStatus(q, j, m, f);\n\n\t\tif (j == BLACKJACK || q == BLACKJACK) {\n\t\t\tif (m == BLACKJACK || f == BLACKJACK) {\n\n\t\t\t\tif (!msg.sender.send(am.aq)) throw;\n\t\t\t\tai[msg.sender].ak = GameState.Tie;\n\t\t\t\treturn;\n\t\t\t} else {\n\n\t\t\t\tai[msg.sender].ak = GameState.House;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (m == BLACKJACK || f == BLACKJACK) {\n\n\t\t\t\tif (am.n.length == 2 && (Deck.al(am.n[0]) || Deck.al(am.n[1]))) {\n\n\t\t\t\t\tif (!msg.sender.send((am.aq * 5) / 2)) throw;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (!msg.sender.send(am.aq * 2)) throw;\n\t\t\t\t}\n\t\t\t\tai[msg.sender].ak = GameState.Player;\n\t\t\t\treturn;\n\t\t\t} else {\n\n\t\t\t\tif (m > BLACKJACK) {\n\n\t\t\t\t\tLog(1);\n\t\t\t\t\tai[msg.sender].ak = GameState.House;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!p) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\t\t\t\tuint8 e = 0;\n\t\t\t\tuint8 g = 0;\n\n\n\t\t\t\tif (f > BLACKJACK) {\n\t\t\t\t\tif (m > BLACKJACK) {\n\n\t\t\t\t\t\tai[msg.sender].ak = GameState.House;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\te = BLACKJACK - m;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\te = BLACKJACK - f;\n\t\t\t\t}\n\n\t\t\t\tif (j > BLACKJACK) {\n\t\t\t\t\tif (q > BLACKJACK) {\n\n\t\t\t\t\t\tif (!msg.sender.send(am.aq * 2)) throw;\n\t\t\t\t\t\tai[msg.sender].ak = GameState.Player;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tg = BLACKJACK - q;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tg = BLACKJACK - j;\n\t\t\t\t}\n\n\n\t\t\t\tif (g == e) {\n\n\t\t\t\t\tif (!msg.sender.send(am.aq)) throw;\n\t\t\t\t\tai[msg.sender].ak = GameState.Tie;\n\t\t\t\t} else if (g > e) {\n\n\t\t\t\t\tif (!msg.sender.send(am.aq * 2)) throw;\n\t\t\t\t\tai[msg.sender].ak = GameState.Player;\n\t\t\t\t} else {\n\t\t\t\t\tai[msg.sender].ak = GameState.House;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction d(uint8[] aj) private constant returns (uint8, uint8) {\n\t\tuint8 af = 0;\n\t\tuint8 x = 0;\n\t\tbool o = false;\n\t\tfor (uint i = 0; i < aj.length; ++i) {\n\t\t\tuint8 ao = aj[i];\n\t\t\tif (Deck.ae(ao) && !o) {\n\t\t\t\tx += Deck.z(ao, true);\n\t\t\t\to = true;\n\t\t\t} else {\n\t\t\t\tx += Deck.z(ao, false);\n\t\t\t}\n\t\t\taf += Deck.z(ao, false);\n\t\t}\n\t\treturn (af, x);\n\t}\n\n\tfunction h(uint8 ar) public i constant returns(uint8) {\n\t\tif (ar < 0 || ar > ai[msg.sender].n.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn ai[msg.sender].n[ar];\n\t}\n\n\tfunction l(uint8 ar) public i constant returns(uint8) {\n\t\tif (ar < 0 || ar > ai[msg.sender].r.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn ai[msg.sender].r[ar];\n\t}\n\n\tfunction a() public i constant returns(uint) {\n\t\treturn ai[msg.sender].n.length;\n\t}\n\n\tfunction b() public i constant returns(uint) {\n\t\treturn ai[msg.sender].r.length;\n\t}\n\n\tfunction k() public constant returns (uint8) {\n\t\tif (ai[msg.sender].ac == 0) {\n\t\t\tthrow;\n\t\t}\n\n\t\tGame am = ai[msg.sender];\n\n\t\tif (am.ak == GameState.Player) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (am.ak == GameState.House) {\n\t\t\treturn 2;\n\t\t}\n\t\tif (am.ak == GameState.Tie) {\n\t\t\treturn 3;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n}",
      "rename_map": {
        "getPlayerCardsNumber": "a",
        "getHouseCardsNumber": "b",
        "checkGameResult": "c",
        "calculateScore": "d",
        "playerShortage": "e",
        "playerScoreBig": "f",
        "houseShortage": "g",
        "getPlayerCard": "h",
        "gameIsGoingOn": "i",
        "houseScoreBig": "j",
        "getGameState": "k",
        "getHouseCard": "l",
        "playerScore": "m",
        "playerCards": "n",
        "bigAceUsed": "o",
        "finishGame": "p",
        "houseScore": "q",
        "houseCards": "r",
        "cardNumber": "s",
        "cardsDealt": "t",
        "keccak256": "u",
        "nextCard": "v",
        "isBigAce": "w",
        "scoreBig": "x",
        "newCard": "y",
        "valueOf": "z",
        "isUser": "aa",
        "minBet": "ab",
        "player": "ac",
        "maxBet": "ad",
        "isAce": "ae",
        "score": "af",
        "stand": "ag",
        "_card": "ah",
        "games": "ai",
        "cards": "aj",
        "state": "ak",
        "isTen": "al",
        "game": "am",
        "deal": "an",
        "card": "ao",
        "hit": "ap",
        "bet": "aq",
        "id": "ar"
      },
      "changes": [
        "Renamed 44 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_234",
      "transformed_id": "ss_l2_short_nc_ds_234",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": false,
      "code": "pragma solidity ^0.4.13;\n\nlibrary SafeMath {\n  function dt(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n  function ds(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint public ah;\n  address public cs;\n  address public bp;\n  function bb(address dn) constant returns (uint);\n  function transfer(address dv, uint value);\n  event Transfer(address indexed from, address indexed dv, uint value);\n  function n(address dn) internal;\n}\n\ncontract ERC20 is ERC20Basic {\n  function ax(address cs, address cc) constant returns (uint);\n  function z(address from, address dv, uint value);\n  function bs(address cc, uint value);\n  event Approval(address indexed cs, address indexed cc, uint value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n  mapping(address => uint) bk;\n\n  modifier k(uint dl) {\n     assert(msg.data.length >= dl + 4);\n     _;\n  }\n\n  function transfer(address dm, uint cr) k(2 * 32) {\n    n(msg.sender);\n    bk[msg.sender] = bk[msg.sender].dt(cr);\n    if(dm == address(this)) {\n        n(cs);\n        bk[cs] = bk[cs].ds(cr);\n        Transfer(msg.sender, cs, cr);\n    }\n    else {\n        n(dm);\n        bk[dm] = bk[dm].ds(cr);\n        Transfer(msg.sender, dm, cr);\n    }\n  }\n\n  function bb(address cj) constant returns (uint balance) {\n    return bk[cj];\n  }\n}\n\ncontract StandardToken is BasicToken, ERC20 {\n  mapping (address => mapping (address => uint)) bx;\n\n  function z(address da, address dm, uint cr) k(3 * 32) {\n    var aj = bx[da][msg.sender];\n    n(da);\n    n(dm);\n    bk[dm] = bk[dm].ds(cr);\n    bk[da] = bk[da].dt(cr);\n    bx[da][msg.sender] = aj.dt(cr);\n    Transfer(da, dm, cr);\n  }\n\n  function bs(address bm, uint cr) {\n\n    assert(!((cr != 0) && (bx[msg.sender][bm] != 0)));\n    bx[msg.sender][bm] = cr;\n    Approval(msg.sender, bm, cr);\n  }\n\n  function ax(address cj, address bm) constant returns (uint bd) {\n    return bx[cj][bm];\n  }\n}\n\ncontract SmartBillions is StandardToken {\n\n\n    string public constant de = \"SmartBillions Token\";\n    string public constant cg = \"PLAY\";\n    uint public constant bn = 0;\n\n\n    struct Wallet {\n        uint208 balance;\n    \tuint16 b;\n    \tuint32 d;\n    }\n    mapping (address => Wallet) bv;\n    struct Bet {\n        uint192 value;\n        uint32 bw;\n        uint32 bi;\n    }\n    mapping (address => Bet) dj;\n\n    uint public u = 0;\n\n\n    uint public ad = 1;\n    uint public s = 0;\n    uint public g = 200000 ether;\n    uint public p = 1;\n    uint[] public au;\n\n\n    uint public ck = 0;\n    uint public be = 0;\n    uint public bj = 0;\n    uint public bq = 0;\n    uint public ao = 0;\n    uint public am = 5 ether;\n    uint[] public co;\n\n\n    uint public constant an = 16384 ;\n    uint public q = 0 ;\n\n\n    event LogBet(address indexed ch, uint cd, uint ae, uint cb);\n    event LogLoss(address indexed ch, uint cd, uint di);\n    event LogWin(address indexed ch, uint cd, uint di, uint db);\n    event LogInvestment(address indexed bf, address indexed by, uint cn);\n    event LogRecordWin(address indexed ch, uint cn);\n    event LogLate(address indexed ch,uint e,uint a);\n    event LogDividend(address indexed bf, uint cn, uint cm);\n\n    modifier ay() {\n        assert(msg.sender == cs);\n        _;\n    }\n\n    modifier x() {\n        assert(msg.sender == bp);\n        _;\n    }\n\n\n    function SmartBillions() {\n        cs = msg.sender;\n        bp = msg.sender;\n        bv[cs].b = uint16(p);\n        au.push(0);\n        au.push(0);\n    }\n\n\n    function y() constant external returns (uint) {\n        return uint(co.length);\n    }\n\n    function j(address cj) constant external returns (uint) {\n        return uint(bv[cj].balance);\n    }\n\n    function m(address cj) constant external returns (uint) {\n        return uint(bv[cj].b);\n    }\n\n    function t(address cj) constant external returns (uint) {\n        return uint(bv[cj].d);\n    }\n\n    function ai(address cj) constant external returns (uint) {\n        return uint(dj[cj].value);\n    }\n\n    function ar(address cj) constant external returns (uint) {\n        return uint(dj[cj].bw);\n    }\n\n    function f(address cj) constant external returns (uint) {\n        return uint(dj[cj].bi);\n    }\n\n    function i() constant external returns (uint) {\n        if(ad > 0) {\n            return(0);\n        }\n        uint cm = (block.number - be) / (10 * an);\n        if(cm > p) {\n            return(0);\n        }\n        return((10 * an) - ((block.number - be) % (10 * an)));\n    }\n\n\n    function ag(address dg) external ay {\n        assert(dg != address(0));\n        n(msg.sender);\n        n(dg);\n        cs = dg;\n    }\n\n    function o(address dg) external x {\n        assert(dg != address(0));\n        n(msg.sender);\n        n(dg);\n        bp = dg;\n    }\n\n    function l(uint cx) external ay {\n        require(ad == 1 && be > 0 && block.number < cx);\n        ad = cx;\n    }\n\n    function aq(uint ca) external ay {\n        am = ca;\n    }\n\n    function bg() external ay {\n        bq = block.number + 3;\n        ao = 0;\n    }\n\n    function as(uint ce) external ay {\n        ab();\n        require(ce > 0 && this.balance >= (s * 9 / 10) + u + ce);\n        if(s >= g / 2){\n            require((ce <= this.balance / 400) && q + 4 * 60 * 24 * 7 <= block.number);\n        }\n        msg.sender.transfer(ce);\n        q = block.number;\n    }\n\n    function bl() payable external {\n        ab();\n    }\n\n\n    function ab() public {\n        if(ad > 1 && block.number >= ad + (an * 5)){\n            ad = 0;\n        }\n        else {\n            if(be > 0){\n\t\t        uint cm = (block.number - be) / (10 * an );\n                if(cm > au.length - 2) {\n                    au.push(0);\n                }\n                if(cm > p && ad == 0 && p < au.length - 1) {\n                    p++;\n                }\n            }\n        }\n    }\n\n\n    function bc() public {\n        if(bv[msg.sender].balance > 0 && bv[msg.sender].d <= block.number){\n            uint balance = bv[msg.sender].balance;\n            bv[msg.sender].balance = 0;\n            u -= balance;\n            dq(balance);\n        }\n    }\n\n    function dq(uint ce) private {\n        uint cl = this.balance / 2;\n        if(cl >= ce) {\n            msg.sender.transfer(ce);\n            if(ce > 1 finney) {\n                ab();\n            }\n        }\n        else {\n            uint af = ce - cl;\n            u += af;\n            bv[msg.sender].balance += uint208(af);\n            bv[msg.sender].d = uint32(block.number + 4 * 60 * 24 * 30);\n            msg.sender.transfer(cl);\n        }\n    }\n\n\n    function aa() payable external {\n        cp(cs);\n    }\n\n    function cp(address bo) payable public {\n\n        require(ad > 1 && block.number < ad + (an * 5) && s < g);\n        uint at = msg.value;\n        if(at > g - s) {\n            at = g - s;\n            s = g;\n            ad = 0;\n            msg.sender.transfer(msg.value.dt(at));\n        }\n        else{\n            s += at;\n        }\n        if(bo == address(0) || bo == cs){\n            u += at / 10;\n            bv[cs].balance += uint208(at / 10);}\n        else{\n            u += (at * 5 / 100) * 2;\n            bv[cs].balance += uint208(at * 5 / 100);\n            bv[bo].balance += uint208(at * 5 / 100);}\n        bv[msg.sender].b = uint16(p);\n        uint r = at / 10**15;\n        uint v = at * 16 / 10**17  ;\n        uint h = at * 10 / 10**17  ;\n        bk[msg.sender] += r;\n        bk[cs] += v ;\n        bk[bp] += h ;\n        ah += r + v + h;\n        Transfer(address(0),msg.sender,r);\n        Transfer(address(0),cs,v);\n        Transfer(address(0),bp,h);\n        LogInvestment(msg.sender,bo,at);\n    }\n\n    function az() external {\n        require(ad == 0);\n        n(msg.sender);\n        uint c = bk[msg.sender] * 10**15;\n        Transfer(msg.sender,address(0),bk[msg.sender]);\n        delete bk[msg.sender];\n        s -= c;\n        bv[msg.sender].balance += uint208(c * 9 / 10);\n        bc();\n    }\n\n    function ac() external {\n        require(ad == 0);\n        n(msg.sender);\n        bc();\n    }\n\n    function n(address dg) internal {\n        uint df = bv[dg].b;\n        if((bk[dg]==0) || (df==0)){\n            bv[dg].b=uint16(p);\n            return;\n        }\n        if(df==p) {\n            return;\n        }\n        uint cz = bk[dg] * 0xffffffff / ah;\n        uint balance = 0;\n        for(;df<p;df++) {\n            balance += cz * au[df];\n        }\n        balance = (balance / 0xffffffff);\n        u += balance;\n        bv[dg].balance += uint208(balance);\n        bv[dg].b = uint16(df);\n        LogDividend(dg,balance,df);\n    }\n\n\n    function bh(Bet bt, uint24 cu) constant private returns (uint) {\n        uint24 cd = uint24(bt.bw);\n        uint24 du = cd ^ cu;\n        uint24 bz =\n            ((du & 0xF) == 0 ? 1 : 0 ) +\n            ((du & 0xF0) == 0 ? 1 : 0 ) +\n            ((du & 0xF00) == 0 ? 1 : 0 ) +\n            ((du & 0xF000) == 0 ? 1 : 0 ) +\n            ((du & 0xF0000) == 0 ? 1 : 0 ) +\n            ((du & 0xF00000) == 0 ? 1 : 0 );\n        if(bz == 6){\n            return(uint(bt.value) * 7000000);\n        }\n        if(bz == 5){\n            return(uint(bt.value) * 20000);\n        }\n        if(bz == 4){\n            return(uint(bt.value) * 500);\n        }\n        if(bz == 3){\n            return(uint(bt.value) * 25);\n        }\n        if(bz == 2){\n            return(uint(bt.value) * 3);\n        }\n        return(0);\n    }\n\n    function cv(address dg) constant external returns (uint)  {\n        Bet memory ch = dj[dg];\n        if( (ch.value==0) ||\n            (ch.bi<=1) ||\n            (block.number<ch.bi) ||\n            (block.number>=ch.bi + (10 * an))){\n            return(0);\n        }\n        if(block.number<ch.bi+256){\n            return(bh(ch,uint24(block.blockhash(ch.bi))));\n        }\n        if(be>0){\n            uint32 di = br(ch.bi);\n            if(di == 0x1000000) {\n                return(uint(ch.value));\n            }\n            else{\n                return(bh(ch,uint24(di)));\n            }\n\t}\n        return(0);\n    }\n\n    function dr() public {\n        Bet memory ch = dj[msg.sender];\n        if(ch.bi==0){\n            dj[msg.sender] = Bet({value: 0, bw: 0, bi: 1});\n            return;\n        }\n        if((ch.value==0) || (ch.bi==1)){\n            bc();\n            return;\n        }\n        require(block.number>ch.bi);\n        if(ch.bi + (10 * an) <= block.number){\n            LogLate(msg.sender,ch.bi,block.number);\n            dj[msg.sender] = Bet({value: 0, bw: 0, bi: 1});\n            return;\n        }\n        uint db = 0;\n        uint32 di = 0;\n        if(block.number<ch.bi+256){\n            di = uint24(block.blockhash(ch.bi));\n            db = bh(ch,uint24(di));\n        }\n        else {\n            if(be>0){\n                di = br(ch.bi);\n                if(di == 0x1000000) {\n                    db = uint(ch.value);\n                }\n                else{\n                    db = bh(ch,uint24(di));\n                }\n\t    }\n            else{\n                LogLate(msg.sender,ch.bi,block.number);\n                dj[msg.sender] = Bet({value: 0, bw: 0, bi: 1});\n                return();\n            }\n        }\n        dj[msg.sender] = Bet({value: 0, bw: 0, bi: 1});\n        if(db>0) {\n            LogWin(msg.sender,uint(ch.bw),uint(di),db);\n            if(db > ck){\n                ck = db;\n                LogRecordWin(msg.sender,db);\n            }\n            dq(db);\n        }\n        else{\n            LogLoss(msg.sender,uint(ch.bw),uint(di));\n        }\n    }\n\n    function () payable external {\n        if(msg.value > 0){\n            if(ad>1){\n                cp(cs);\n            }\n            else{\n                dh();\n            }\n            return;\n        }\n\n        if(ad == 0 && bk[msg.sender]>0){\n            n(msg.sender);}\n        dr();\n    }\n\n    function dh() payable public returns (uint) {\n        return ap(uint(dk(msg.sender,block.number)), address(0));\n    }\n\n    function ak(address bo) payable public returns (uint) {\n        return ap(uint(dk(msg.sender,block.number)), bo);\n    }\n\n    function ap(uint cu, address bo) payable public returns (uint) {\n        dr();\n        uint24 cd = uint24(cu);\n        require(msg.value <= 1 ether && msg.value < am);\n        if(msg.value > 0){\n            if(ad==0) {\n                au[p] += msg.value / 20;\n            }\n            if(bo != address(0)) {\n                uint dp = msg.value / 100;\n                u += dp;\n                bv[bo].balance += uint208(dp);\n            }\n            if(bq < block.number + 3) {\n                bq = block.number + 3;\n                ao = msg.value;\n            }\n            else{\n                if(ao > am) {\n                    bq++;\n                    ao = msg.value;\n                }\n                else{\n                    ao += msg.value;\n                }\n            }\n            dj[msg.sender] = Bet({value: uint192(msg.value), bw: uint32(cd), bi: uint32(bq)});\n            LogBet(msg.sender,uint(cd),bq,msg.value);\n        }\n        bu();\n        return(bq);\n    }\n\n\n    function av(uint ct) public returns (uint) {\n        require(be == 0 && ct > 0 && ct <= an);\n        uint n = co.length;\n        if(n + ct > an){\n            co.length = an;\n        }\n        else{\n            co.length += ct;\n        }\n        for(;n<co.length;n++){\n            co[n] = 1;\n        }\n        if(co.length>=an) {\n            be = block.number - ( block.number % 10);\n            bj = be;\n        }\n        return(co.length);\n    }\n\n    function w() external returns (uint) {\n        return(av(128));\n    }\n\n    function al(uint32 cq, uint32 cf) constant private returns (uint) {\n        return( ( uint(block.blockhash(cq  )) & 0xFFFFFF )\n            | ( ( uint(block.blockhash(cq+1)) & 0xFFFFFF ) << 24 )\n            | ( ( uint(block.blockhash(cq+2)) & 0xFFFFFF ) << 48 )\n            | ( ( uint(block.blockhash(cq+3)) & 0xFFFFFF ) << 72 )\n            | ( ( uint(block.blockhash(cq+4)) & 0xFFFFFF ) << 96 )\n            | ( ( uint(block.blockhash(cq+5)) & 0xFFFFFF ) << 120 )\n            | ( ( uint(block.blockhash(cq+6)) & 0xFFFFFF ) << 144 )\n            | ( ( uint(block.blockhash(cq+7)) & 0xFFFFFF ) << 168 )\n            | ( ( uint(block.blockhash(cq+8)) & 0xFFFFFF ) << 192 )\n            | ( ( uint(block.blockhash(cq+9)) & 0xFFFFFF ) << 216 )\n            | ( ( uint(cf) / an) << 240));\n    }\n\n    function br(uint ci) constant private returns (uint32) {\n        uint dc = (ci - be) / 10;\n        uint di = co[dc % an];\n        if(dc / an != di >> 240) {\n            return(0x1000000);\n        }\n        uint cw = (ci - be) % 10;\n        return(uint32((di >> (24 * cw)) & 0xFFFFFF));\n    }\n\n    function bu() public returns (bool) {\n        uint cy = bj;\n        if(cy == 0 || block.number <= cy + 10) {\n            return(false);\n        }\n        uint aw;\n        if(block.number<256) {\n            aw = 0;\n        }\n        else{\n            aw = block.number - 256;\n        }\n        if(cy < aw) {\n            uint do = aw;\n            do += do % 10;\n            cy = do;\n        }\n        uint dc = (cy - be) / 10;\n        co[dc % an] = al(uint32(cy),uint32(dc));\n        bj = cy + 10;\n        return(true);\n    }\n\n    function ba(uint dd) external {\n        uint n=0;\n        for(;n<dd;n++){\n            if(!bu()){\n                return;\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "currentBlockNumber": "a",
        "lastDividendPeriod": "b",
        "initialInvestment": "c",
        "nextWithdrawBlock": "d",
        "playerBlockNumber": "e",
        "betBlockNumberOf": "f",
        "investBalanceMax": "g",
        "animatorBalance": "h",
        "dividendsBlocks": "i",
        "walletBalanceOf": "j",
        "onlyPayloadSize": "k",
        "setInvestStart": "l",
        "walletPeriodOf": "m",
        "commitDividend": "n",
        "changeAnimator": "o",
        "dividendPeriod": "p",
        "coldStoreLast": "q",
        "senderBalance": "r",
        "investBalance": "s",
        "walletBlockOf": "t",
        "walletBalance": "u",
        "ownerBalance": "v",
        "addHashes128": "w",
        "onlyAnimator": "x",
        "hashesLength": "y",
        "transferFrom": "z",
        "investDirect": "aa",
        "houseKeeping": "ab",
        "payDividends": "ac",
        "investStart": "ad",
        "blocknumber": "ae",
        "keepbalance": "af",
        "changeOwner": "ag",
        "totalSupply": "ah",
        "betValueOf": "ai",
        "_allowance": "aj",
        "playRandom": "ak",
        "calcHashes": "al",
        "hashBetMax": "am",
        "hashesSize": "an",
        "hashBetSum": "ao",
        "playSystem": "ap",
        "setBetMax": "aq",
        "betHashOf": "ar",
        "coldStore": "as",
        "investing": "at",
        "dividends": "au",
        "addHashes": "av",
        "blockn256": "aw",
        "allowance": "ax",
        "onlyOwner": "ay",
        "disinvest": "az",
        "putHashes": "ba",
        "balanceOf": "bb",
        "payWallet": "bc",
        "remaining": "bd",
        "hashFirst": "be",
        "investor": "bf",
        "resetBet": "bg",
        "betPrize": "bh",
        "blockNum": "bi",
        "hashLast": "bj",
        "balances": "bk",
        "hotStore": "bl",
        "_spender": "bm",
        "decimals": "bn",
        "_partner": "bo",
        "animator": "bp",
        "hashNext": "bq",
        "getHash": "br",
        "approve": "bs",
        "_player": "bt",
        "putHash": "bu",
        "wallets": "bv",
        "betHash": "bw",
        "allowed": "bx",
        "partner": "by",
        "matches": "bz",
        "_maxsum": "ca",
        "betsize": "cb",
        "spender": "cc",
        "bethash": "cd",
        "_amount": "ce",
        "_delta": "cf",
        "symbol": "cg",
        "player": "ch",
        "_block": "ci",
        "_owner": "cj",
        "maxWin": "ck",
        "maxpay": "cl",
        "period": "cm",
        "amount": "cn",
        "hashes": "co",
        "invest": "cp",
        "_lastb": "cq",
        "_value": "cr",
        "owner": "cs",
        "_sadd": "ct",
        "_hash": "cu",
        "betOf": "cv",
        "slotp": "cw",
        "_when": "cx",
        "lastb": "cy",
        "share": "cz",
        "_from": "da",
        "prize": "db",
        "delta": "dc",
        "_num": "dd",
        "name": "de",
        "last": "df",
        "_who": "dg",
        "play": "dh",
        "hash": "di",
        "bets": "dj",
        "sha3": "dk",
        "size": "dl",
        "_to": "dm",
        "who": "dn",
        "num": "do",
        "fee": "dp",
        "pay": "dq",
        "won": "dr",
        "add": "ds",
        "sub": "dt",
        "hit": "du",
        "to": "dv"
      },
      "changes": [
        "Renamed 126 identifiers using short style"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 585, column 13', 'Syntax error at line 585, column 15', 'Syntax error at line 594, column 22']"
    },
    {
      "original_id": "nc_gs_001",
      "transformed_id": "ss_l2_short_nc_gs_001",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public k = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public d = 1200;\n    uint256 public c = 300;\n\n\n    uint256 public bg = 100;\n    uint256 public constant MIN_WITHDRAW_FEE = 10;\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant BASIS = 10000;\n    address public Team;\n    uint256 public dq;\n    uint256 public dg;\n    uint256 public bm;\n\n    struct UserLock {\n        uint256 dv;\n        uint256 cd;\n    }\n\n    mapping(address => UserLock[]) public cq;\n    mapping(address => uint256) public ak;\n\n\n    address public immutable HYBR;\n    address public immutable aw;\n    address public ed;\n    address public l;\n    address public au;\n    uint256 public cr;\n\n\n    address public db;\n    uint256 public an;\n\n\n    uint256 public ad;\n    uint256 public s;\n\n\n    ISwapper public de;\n\n\n    error NOT_AUTHORIZED();\n\n\n    event Deposit(address indexed em, uint256 cb, uint256 af);\n    event Withdraw(address indexed em, uint256 dt, uint256 cb, uint256 er);\n    event Compound(uint256 dj, uint256 ag);\n    event PenaltyRewardReceived(uint256 dv);\n    event TransferLockPeriodUpdated(uint256 ci, uint256 ct);\n    event SwapperUpdated(address indexed bv, address indexed bz);\n    event VoterSet(address ed);\n    event EmergencyUnlock(address indexed em);\n    event AutoVotingEnabled(bool do);\n    event OperatorUpdated(address indexed bs, address indexed br);\n    event DefaultVotingStrategyUpdated(address[] dy, uint256[] dl);\n    event AutoVoteExecuted(uint256 ei, address[] dy, uint256[] dl);\n\n    constructor(\n        address el,\n        address am\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(el != address(0), \"Invalid HYBR\");\n        require(am != address(0), \"Invalid VE\");\n\n        HYBR = el;\n        aw = am;\n        ad = block.timestamp;\n        s = block.timestamp;\n        db = msg.sender;\n    }\n\n    function e(address j) external cn {\n        require(j != address(0), \"Invalid rewards distributor\");\n        l = j;\n    }\n\n    function u(address ar) external cn {\n        require(ar != address(0), \"Invalid gauge manager\");\n        au = ar;\n    }\n\n\n    modifier at() {\n        if (msg.sender != db) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n\n    function dk(uint256 dv, address cj) external ay {\n        require(dv > 0, \"Zero amount\");\n        cj = cj == address(0) ? msg.sender : cj;\n\n\n        IERC20(HYBR).ba(msg.sender, address(this), dv);\n\n\n        if (cr == 0) {\n            n(dv);\n        } else {\n\n            IERC20(HYBR).df(aw, dv);\n            IVotingEscrow(aw).bf(cr, dv);\n\n\n            q();\n        }\n\n\n        uint256 dt = ab(dv);\n\n\n        ek(cj, dt);\n\n\n        p(cj, dt);\n\n        emit Deposit(msg.sender, dv, dt);\n    }\n\n\n    function cy(uint256 dt) external ay returns (uint256 bi) {\n        require(dt > 0, \"Zero shares\");\n        require(cp(msg.sender) >= dt, \"Insufficient balance\");\n        require(cr != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(aw).ef(cr) == false, \"Cannot withdraw yet\");\n\n        uint256 ce = HybraTimeLibrary.ce(block.timestamp);\n        uint256 cm = HybraTimeLibrary.cm(block.timestamp);\n\n        require(block.timestamp >= ce + d && block.timestamp < cm - c, \"Cannot withdraw yet\");\n\n\n        uint256 cb = y(dt);\n        require(cb > 0, \"No assets to withdraw\");\n\n\n        uint256 co = 0;\n        if (bg > 0) {\n            co = (cb * bg) / BASIS;\n        }\n\n\n        uint256 cg = cb - co;\n        require(cg > 0, \"Amount too small after fee\");\n\n\n        uint256 ch = bp();\n        require(cb <= ch, \"Insufficient veNFT balance\");\n\n        uint256 aa = ch - cg - co;\n        require(aa >= 0, \"Cannot withdraw entire veNFT\");\n\n\n        ej(msg.sender, dt);\n\n\n        uint256[] memory dh = new uint256[](3);\n        dh[0] = aa;\n        dh[1] = cg;\n        dh[2] = co;\n\n        uint256[] memory bj = IVotingEscrow(aw).bx(cr, dh);\n\n\n        cr = bj[0];\n        bi = bj[1];\n        uint256 cf = bj[2];\n\n        IVotingEscrow(aw).t(address(this), msg.sender, bi);\n        IVotingEscrow(aw).t(address(this), Team, cf);\n        emit Withdraw(msg.sender, dt, cg, co);\n    }\n\n\n    function n(uint256 aq) internal {\n\n        IERC20(HYBR).df(aw, type(uint256).eq);\n        uint256 da = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n\n        cr = IVotingEscrow(aw).v(aq, da, address(this));\n\n    }\n\n\n    function ab(uint256 dv) public view returns (uint256) {\n        uint256 ax = bo();\n        uint256 as = bp();\n        if (ax == 0 || as == 0) {\n            return dv;\n        }\n        return (dv * ax) / as;\n    }\n\n\n    function y(uint256 dt) public view returns (uint256) {\n        uint256 ax = bo();\n        if (ax == 0) {\n            return dt;\n        }\n        return (dt * bp()) / ax;\n    }\n\n\n    function bp() public view returns (uint256) {\n        if (cr == 0) {\n            return 0;\n        }\n\n        IVotingEscrow.LockedBalance memory du = IVotingEscrow(aw).du(cr);\n        return uint256(int256(du.dv));\n    }\n\n\n    function p(address em, uint256 dv) internal {\n        uint256 cd = block.timestamp + k;\n        cq[em].push(UserLock({\n            dv: dv,\n            cd: cd\n        }));\n        ak[em] += dv;\n    }\n\n\n    function r(address em) external view returns (uint256 ck) {\n        uint256 av = cp(em);\n        uint256 ao = 0;\n\n        UserLock[] storage es = cq[em];\n        for (uint256 i = 0; i < es.length; i++) {\n            if (es[i].cd > block.timestamp) {\n                ao += es[i].dv;\n            }\n        }\n\n        return av > ao ? av - ao : 0;\n    }\n\n    function ap(address em) internal returns (uint256 ec) {\n        UserLock[] storage es = cq[em];\n        uint256 ep = es.length;\n        if (ep == 0) return 0;\n\n        uint256 eb = 0;\n        unchecked {\n            for (uint256 i = 0; i < ep; i++) {\n                UserLock memory L = es[i];\n                if (L.cd <= block.timestamp) {\n                    ec += L.dv;\n                } else {\n                    if (eb != i) es[eb] = L;\n                    eb++;\n                }\n            }\n            if (ec > 0) {\n                ak[em] -= ec;\n            }\n            while (es.length > eb) {\n                es.pop();\n            }\n        }\n    }\n\n\n    function i(\n        address from,\n        address eu,\n        uint256 dv\n    ) internal override {\n        super.i(from, eu, dv);\n\n        if (from != address(0) && eu != address(0)) {\n            uint256 av = cp(from);\n\n\n            uint256 o = av > ak[from] ? av - ak[from] : 0;\n\n\n            if (o >= dv) {\n                return;\n            }\n\n\n            ap(from);\n            uint256 ac = av > ak[from] ? av - ak[from] : 0;\n\n\n            require(ac >= dv, \"Tokens locked\");\n        }\n    }\n\n\n    function bd() external at {\n        require(ed != address(0), \"Voter not set\");\n        require(l != address(0), \"Distributor not set\");\n\n\n        uint256  bc = IRewardsDistributor(l).ea(cr);\n        dq += bc;\n\n        address[] memory ca = IVoter(ed).cz(cr);\n\n        for (uint256 i = 0; i < ca.length; i++) {\n            if (ca[i] != address(0)) {\n                address ee = IGaugeManager(au).dp(ca[i]);\n\n                if (ee != address(0)) {\n\n                    address[] memory dr = new address[](1);\n                    address[][] memory ds = new address[][](1);\n\n\n                    address al = IGaugeManager(au).z(ee);\n                    if (al != address(0)) {\n                        uint256 bw = IBribe(al).m();\n                        if (bw > 0) {\n                            address[] memory bt = new address[](bw);\n                            for (uint256 j = 0; j < bw; j++) {\n                                bt[j] = IBribe(al).bt(j);\n                            }\n                            dr[0] = al;\n                            ds[0] = bt;\n\n                            IGaugeManager(au).bq(dr, ds, cr);\n                        }\n                    }\n\n\n                    address aj = IGaugeManager(au).w(ee);\n                    if (aj != address(0)) {\n                        uint256 bw = IBribe(aj).m();\n                        if (bw > 0) {\n                            address[] memory bt = new address[](bw);\n                            for (uint256 j = 0; j < bw; j++) {\n                                bt[j] = IBribe(aj).bt(j);\n                            }\n                            dr[0] = aj;\n                            ds[0] = bt;\n\n                            IGaugeManager(au).bq(dr, ds, cr);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    function bh(ISwapper.SwapParams calldata dn) external ay at {\n        require(address(de) != address(0), \"Swapper not set\");\n\n\n        uint256 bb = IERC20(dn.dm).cp(address(this));\n        require(bb >= dn.cw, \"Insufficient token balance\");\n\n\n        IERC20(dn.dm).bl(address(de), dn.cw);\n\n\n        uint256 be = de.by(dn);\n\n\n        IERC20(dn.dm).bl(address(de), 0);\n\n\n        bm += be;\n    }\n\n\n    function dc() external at {\n\n\n        uint256 bu = IERC20(HYBR).cp(address(this));\n\n        if (bu > 0) {\n\n            IERC20(HYBR).bl(aw, bu);\n            IVotingEscrow(aw).bf(cr, bu);\n\n\n            q();\n\n            s = block.timestamp;\n\n            emit Compound(bu, bp());\n        }\n    }\n\n\n    function en(address[] calldata cs, uint256[] calldata cu) external {\n        require(msg.sender == dx() || msg.sender == db, \"Not authorized\");\n        require(ed != address(0), \"Voter not set\");\n\n        IVoter(ed).en(cr, cs, cu);\n        an = HybraTimeLibrary.ce(block.timestamp);\n\n    }\n\n\n    function dz() external {\n        require(msg.sender == dx() || msg.sender == db, \"Not authorized\");\n        require(ed != address(0), \"Voter not set\");\n\n        IVoter(ed).dz(cr);\n    }\n\n\n    function g(uint256 dv) external {\n\n\n        if (dv > 0) {\n            IERC20(HYBR).df(aw, dv);\n\n            if(cr == 0){\n                n(dv);\n            } else{\n                IVotingEscrow(aw).bf(cr, dv);\n\n\n                q();\n            }\n        }\n        dg += dv;\n        emit PenaltyRewardReceived(dv);\n    }\n\n\n    function cv(address dw) external cn {\n        require(dw != address(0), \"Invalid voter\");\n        ed = dw;\n        emit VoterSet(dw);\n    }\n\n\n    function f(uint256 dd) external cn {\n        require(dd >= MIN_LOCK_PERIOD && dd <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 ci = k;\n        k = dd;\n        emit TransferLockPeriodUpdated(ci, dd);\n    }\n\n\n    function ae(uint256 eo) external cn {\n        require(eo >= MIN_WITHDRAW_FEE && eo <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        bg = eo;\n    }\n\n    function b(uint256 eh) external cn {\n        d = eh;\n    }\n\n    function a(uint256 eh) external cn {\n        c = eh;\n    }\n\n\n    function cc(address cx) external cn {\n        require(cx != address(0), \"Invalid swapper\");\n        address bv = address(de);\n        de = ISwapper(cx);\n        emit SwapperUpdated(bv, cx);\n    }\n\n\n    function di(address eg) external cn {\n        require(eg != address(0), \"Invalid team\");\n        Team = eg;\n    }\n\n\n    function x(address em) external at {\n        delete cq[em];\n        ak[em] = 0;\n        emit EmergencyUnlock(em);\n    }\n\n\n    function az(address em) external view returns (UserLock[] memory) {\n        return cq[em];\n    }\n\n\n    function bk(address cl) external cn {\n        require(cl != address(0), \"Invalid operator\");\n        address bs = db;\n        db = cl;\n        emit OperatorUpdated(bs, cl);\n    }\n\n\n    function ah() external view returns (uint256) {\n        if (cr == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory du = IVotingEscrow(aw).du(cr);\n        return uint256(du.et);\n    }\n\n\n    function q() internal {\n        if (cr == 0) return;\n\n        IVotingEscrow.LockedBalance memory du = IVotingEscrow(aw).du(cr);\n        if (du.bn || du.et <= block.timestamp) return;\n\n        uint256 ai = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n\n        if (ai > du.et + 2 hours) {\n            try IVotingEscrow(aw).h(cr, HybraTimeLibrary.MAX_LOCK_DURATION) {\n\n            } catch {\n\n\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setTailNotWithdrawTime": "a",
        "setHeadNotWithdrawTime": "b",
        "tail_not_withdraw_time": "c",
        "head_not_withdraw_time": "d",
        "setRewardsDistributor": "e",
        "setTransferLockPeriod": "f",
        "receivePenaltyReward": "g",
        "increase_unlock_time": "h",
        "_beforeTokenTransfer": "i",
        "_rewardsDistributor": "j",
        "transferLockPeriod": "k",
        "rewardsDistributor": "l",
        "rewardsListLength": "m",
        "_initializeVeNFT": "n",
        "currentAvailable": "o",
        "_addTransferLock": "p",
        "_extendLockToMax": "q",
        "previewAvailable": "r",
        "lastCompoundTime": "s",
        "safeTransferFrom": "t",
        "setGaugeManager": "u",
        "create_lock_for": "v",
        "external_bribes": "w",
        "emergencyUnlock": "x",
        "calculateAssets": "y",
        "internal_bribes": "z",
        "remainingAmount": "aa",
        "calculateShares": "ab",
        "finalAvailable": "ac",
        "lastRebaseTime": "ad",
        "setWithdrawFee": "ae",
        "sharesReceived": "af",
        "newTotalLocked": "ag",
        "getLockEndTime": "ah",
        "maxUnlockTime": "ai",
        "externalBribe": "aj",
        "lockedBalance": "ak",
        "internalBribe": "al",
        "_votingEscrow": "am",
        "lastVoteEpoch": "an",
        "currentLocked": "ao",
        "_cleanExpired": "ap",
        "initialAmount": "aq",
        "_gaugeManager": "ar",
        "_totalAssets": "as",
        "onlyOperator": "at",
        "gaugeManager": "au",
        "totalBalance": "av",
        "votingEscrow": "aw",
        "_totalSupply": "ax",
        "nonReentrant": "ay",
        "getUserLocks": "az",
        "transferFrom": "ba",
        "tokenBalance": "bb",
        "rebaseAmount": "bc",
        "claimRewards": "bd",
        "hybrReceived": "be",
        "deposit_for": "bf",
        "withdrawFee": "bg",
        "executeSwap": "bh",
        "userTokenId": "bi",
        "newTokenIds": "bj",
        "setOperator": "bk",
        "safeApprove": "bl",
        "votingYield": "bm",
        "isPermanent": "bn",
        "totalSupply": "bo",
        "totalAssets": "bp",
        "claimBribes": "bq",
        "newOperator": "br",
        "oldOperator": "bs",
        "bribeTokens": "bt",
        "hybrBalance": "bu",
        "oldSwapper": "bv",
        "tokenCount": "bw",
        "multiSplit": "bx",
        "swapToHYBR": "by",
        "newSwapper": "bz",
        "votedPools": "ca",
        "hybrAmount": "cb",
        "setSwapper": "cc",
        "unlockTime": "cd",
        "epochStart": "ce",
        "feeTokenId": "cf",
        "userAmount": "cg",
        "veBalance": "ch",
        "oldPeriod": "ci",
        "recipient": "cj",
        "available": "ck",
        "_operator": "cl",
        "epochNext": "cm",
        "onlyOwner": "cn",
        "feeAmount": "co",
        "balanceOf": "cp",
        "userLocks": "cq",
        "veTokenId": "cr",
        "_poolVote": "cs",
        "newPeriod": "ct",
        "_weights": "cu",
        "setVoter": "cv",
        "amountIn": "cw",
        "_swapper": "cx",
        "withdraw": "cy",
        "poolVote": "cz",
        "lockTime": "da",
        "operator": "db",
        "compound": "dc",
        "_period": "dd",
        "swapper": "de",
        "approve": "df",
        "penalty": "dg",
        "amounts": "dh",
        "setTeam": "di",
        "rewards": "dj",
        "deposit": "dk",
        "weights": "dl",
        "tokenIn": "dm",
        "_params": "dn",
        "enabled": "do",
        "gauges": "dp",
        "rebase": "dq",
        "bribes": "dr",
        "tokens": "ds",
        "shares": "dt",
        "locked": "du",
        "amount": "dv",
        "_voter": "dw",
        "owner": "dx",
        "pools": "dy",
        "reset": "dz",
        "claim": "ea",
        "write": "eb",
        "freed": "ec",
        "voter": "ed",
        "gauge": "ee",
        "voted": "ef",
        "_team": "eg",
        "_time": "eh",
        "epoch": "ei",
        "_burn": "ej",
        "_mint": "ek",
        "_HYBR": "el",
        "user": "em",
        "vote": "en",
        "_fee": "eo",
        "len": "ep",
        "max": "eq",
        "fee": "er",
        "arr": "es",
        "end": "et",
        "to": "eu"
      },
      "changes": [
        "Renamed 151 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_002",
      "transformed_id": "ss_l2_short_nc_gs_002",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity =0.7.6;\n\nimport \"./interfaces/ICLFactory.sol\";\nimport \"./interfaces/fees/IFeeModule.sol\";\n\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/IFactoryRegistry.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@nomad-xyz/src/ExcessivelySafeCall.sol\";\nimport \"./CLPool.sol\";\n\n\ncontract CLFactory is ICLFactory {\n    using ExcessivelySafeCall for address;\n\n\n    IGaugeManager public override ar;\n\n    address public immutable override q;\n\n    address public override bv;\n\n    address public override aj;\n\n    address public override am;\n\n    address public override p;\n\n    address public override ab;\n\n    uint24 public override r;\n\n\n    address public override u;\n\n    address public override aa;\n\n    uint24 public override s;\n\n    mapping(int24 => uint24) public override ac;\n\n    mapping(address => mapping(address => mapping(int24 => address))) public override bj;\n\n    mapping(address => bool) private bi;\n\n    address[] public override bd;\n\n    int24[] private ao;\n\n    constructor(address n) {\n        bv = msg.sender;\n        aj = msg.sender;\n        p = msg.sender;\n        u = msg.sender;\n        q = n;\n        r = 100_000;\n        s = 250_000;\n        emit OwnerChanged(address(0), msg.sender);\n        emit SwapFeeManagerChanged(address(0), msg.sender);\n        emit UnstakedFeeManagerChanged(address(0), msg.sender);\n        emit DefaultUnstakedFeeChanged(0, 100_000);\n\n        z(1, 100);\n        z(50, 500);\n        z(100, 500);\n        z(200, 3_000);\n        z(2_000, 10_000);\n    }\n\n    function ae(address ap) external {\n        require(msg.sender == bv);\n        ar = IGaugeManager(ap);\n    }\n\n\n    function ax(address bu, address bs, int24 av, uint160 aq)\n        external\n        override\n        returns (address bx)\n    {\n        require(bu != bs);\n        (address bt, address bn) = bu < bs ? (bu, bs) : (bs, bu);\n        require(bt != address(0));\n        require(ac[av] != 0);\n        require(bj[bt][bn][av] == address(0));\n        bx = Clones.w({\n            bm: q,\n            bw: ba(abi.bl(bt, bn, av))\n        });\n        CLPool(bx).ay({\n            bb: address(this),\n            bg: bt,\n            bf: bn,\n            au: av,\n            ap: address(ar),\n            an: aq\n        });\n        bd.push(bx);\n        bi[bx] = true;\n        bj[bt][bn][av] = bx;\n\n        bj[bn][bt][av] = bx;\n        emit PoolCreated(bt, bn, av, bx);\n    }\n\n\n    function bc(address br) external override {\n        address aw = bv;\n        require(msg.sender == aw);\n        require(br != address(0));\n        emit OwnerChanged(aw, br);\n        bv = br;\n    }\n\n\n    function y(address af) external override {\n        address i = aj;\n        require(msg.sender == i);\n        require(af != address(0));\n        aj = af;\n        emit SwapFeeManagerChanged(i, af);\n    }\n\n\n    function f(address l) external override {\n        address b = p;\n        require(msg.sender == b);\n        require(l != address(0));\n        p = l;\n        emit UnstakedFeeManagerChanged(b, l);\n    }\n\n\n    function ad(address ah) external override {\n        require(msg.sender == aj);\n        require(ah != address(0));\n        address as = am;\n        am = ah;\n        emit SwapFeeModuleChanged(as, ah);\n    }\n\n\n    function g(address v) external override {\n        require(msg.sender == p);\n        require(v != address(0));\n        address as = ab;\n        ab = v;\n        emit UnstakedFeeModuleChanged(as, v);\n    }\n\n\n    function e(uint24 j) external override {\n        require(msg.sender == p);\n        require(j <= 500_000);\n        uint24 ai = r;\n        r = j;\n        emit DefaultUnstakedFeeChanged(ai, j);\n    }\n\n    function h(address x) external override {\n        require(msg.sender == u);\n        require(x != address(0));\n        aa = x;\n    }\n\n    function d(address o) external override {\n        require(msg.sender == u);\n        require(o != address(0));\n        u = o;\n    }\n\n\n    function az(address bx) external view override returns (uint24) {\n        if (am != address(0)) {\n            (bool bh, bytes memory data) = am.a(\n                200_000, 32, abi.t(IFeeModule.bo.selector, bx)\n            );\n            if (bh) {\n                uint24 by = abi.bp(data, (uint24));\n                if (by <= 100_000) {\n                    return by;\n                }\n            }\n        }\n        return ac[CLPool(bx).av()];\n    }\n\n\n    function ag(address bx) external view override returns (uint24) {\n\n        if (!ar.m(bx)) {\n            return 0;\n        }\n        if (ab != address(0)) {\n            (bool bh, bytes memory data) = ab.a(\n                200_000, 32, abi.t(IFeeModule.bo.selector, bx)\n            );\n            if (bh) {\n                uint24 by = abi.bp(data, (uint24));\n                if (by <= 1_000_000) {\n                    return by;\n                }\n            }\n        }\n        return r;\n    }\n\n    function al(address bx) external view override returns (uint24) {\n\n        if (ar.m(bx)) {\n            return 0;\n        }\n\n        if (aa != address(0)) {\n            (bool bh, bytes memory data) = aa.a(\n                200_000, 32, abi.t(IFeeModule.bo.selector, bx)\n            );\n            if (bh) {\n                uint24 by = abi.bp(data, (uint24));\n                if (by <= 500_000) {\n                    return by;\n                }\n            }\n        }\n        return s;\n    }\n\n\n    function z(int24 av, uint24 by) public override {\n        require(msg.sender == bv);\n        require(by > 0 && by <= 100_000);\n\n\n        require(av > 0 && av < 16384);\n        require(ac[av] == 0);\n\n        ac[av] = by;\n        ao.push(av);\n        emit TickSpacingEnabled(av, by);\n    }\n\n    function c() external  {\n        require(msg.sender == bv);\n\n        for (uint256 i = 0; i < bd.length; i++) {\n            CLPool(bd[i]).k(msg.sender);\n        }\n    }\n\n    function k(address bx) external returns (uint128 be, uint128 bk) {\n        require(msg.sender == bv);\n        (be, bk) = CLPool(bx).k(msg.sender);\n    }\n\n\n    function at() external view override returns (int24[] memory) {\n        return ao;\n    }\n\n\n    function ak() external view override returns (uint256) {\n        return bd.length;\n    }\n\n\n    function bq(address bx) external view override returns (bool) {\n        return bi[bx];\n    }\n}",
      "rename_map": {
        "excessivelySafeStaticCall": "a",
        "cachedUnstakedFeeManager": "b",
        "collectAllProtocolFees": "c",
        "setProtocolFeeManager": "d",
        "setDefaultUnstakedFee": "e",
        "setUnstakedFeeManager": "f",
        "setUnstakedFeeModule": "g",
        "setProtocolFeeModule": "h",
        "cachedSwapFeeManager": "i",
        "_defaultUnstakedFee": "j",
        "collectProtocolFees": "k",
        "_unstakedFeeManager": "l",
        "isGaugeAliveForPool": "m",
        "_poolImplementation": "n",
        "_protocolFeeManager": "o",
        "unstakedFeeManager": "p",
        "poolImplementation": "q",
        "defaultUnstakedFee": "r",
        "defaultProtocolFee": "s",
        "encodeWithSelector": "t",
        "protocolFeeManager": "u",
        "_unstakedFeeModule": "v",
        "cloneDeterministic": "w",
        "_protocolFeeModule": "x",
        "setSwapFeeManager": "y",
        "enableTickSpacing": "z",
        "protocolFeeModule": "aa",
        "unstakedFeeModule": "ab",
        "tickSpacingToFee": "ac",
        "setSwapFeeModule": "ad",
        "setGaugeManager": "ae",
        "_swapFeeManager": "af",
        "getUnstakedFee": "ag",
        "_swapFeeModule": "ah",
        "oldUnstakedFee": "ai",
        "swapFeeManager": "aj",
        "allPoolsLength": "ak",
        "getProtocolFee": "al",
        "swapFeeModule": "am",
        "_sqrtPriceX96": "an",
        "_tickSpacings": "ao",
        "_gaugeManager": "ap",
        "sqrtPriceX96": "aq",
        "gaugeManager": "ar",
        "oldFeeModule": "as",
        "tickSpacings": "at",
        "_tickSpacing": "au",
        "tickSpacing": "av",
        "cachedOwner": "aw",
        "createPool": "ax",
        "initialize": "ay",
        "getSwapFee": "az",
        "keccak256": "ba",
        "_factory": "bb",
        "setOwner": "bc",
        "allPools": "bd",
        "amount0": "be",
        "_token1": "bf",
        "_token0": "bg",
        "success": "bh",
        "_isPool": "bi",
        "getPool": "bj",
        "amount1": "bk",
        "encode": "bl",
        "master": "bm",
        "token1": "bn",
        "getFee": "bo",
        "decode": "bp",
        "isPool": "bq",
        "_owner": "br",
        "tokenB": "bs",
        "token0": "bt",
        "tokenA": "bu",
        "owner": "bv",
        "salt": "bw",
        "pool": "bx",
        "fee": "by"
      },
      "changes": [
        "Renamed 77 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_003",
      "transformed_id": "ss_l2_short_nc_gs_003",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport './interfaces/IPair.sol';\nimport './interfaces/IBribe.sol';\nimport \"./libraries/Math.sol\";\n\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport './interfaces/IRHYBR.sol';\ninterface IRewarder {\n    function bi(\n        address cd,\n        address at,\n        uint256 an\n    ) external;\n}\n\ncontract GaugeV2 is ReentrancyGuard, Ownable {\n\n    using SafeERC20 for IERC20;\n\n    bool public immutable ba;\n    bool public bb;\n\n    IERC20 public immutable am;\n    IERC20 public immutable TOKEN;\n    address public immutable cb;\n    address public VE;\n    address public DISTRIBUTION;\n    address public y;\n    address public u;\n    address public v;\n\n    uint256 public DURATION;\n    uint256 internal z;\n    uint256 public ao;\n    uint256 public w;\n    uint256 public g;\n\n    mapping(address => uint256) public d;\n    mapping(address => uint256) public bm;\n\n    uint256 internal ab;\n    mapping(address => uint256) internal ax;\n    mapping(address => uint256) public ag;\n\n    event RewardAdded(uint256 bv);\n    event Deposit(address indexed cd, uint256 bu);\n    event Withdraw(address indexed cd, uint256 bu);\n    event Harvest(address indexed cd, uint256 bv);\n\n    event ClaimFees(address indexed from, uint256 bh, uint256 bj);\n    event EmergencyActivated(address indexed bz, uint256 timestamp);\n    event EmergencyDeactivated(address indexed bz, uint256 timestamp);\n\n    modifier ad(address bo) {\n        g = s();\n        w = a();\n        if (bo != address(0)) {\n            bm[bo] = bx(bo);\n            d[bo] = g;\n        }\n        _;\n    }\n\n    modifier m() {\n        require(msg.sender == DISTRIBUTION, \"NA\");\n        _;\n    }\n\n    modifier x() {\n        require(bb == false, \"EMER\");\n        _;\n    }\n\n    constructor(address ah,address bq,address ce,address bs,address aa, address q, address r, bool ap) {\n        am = IERC20(ah);\n        cb = bq;\n        VE = ce;\n        TOKEN = IERC20(bs);\n        DISTRIBUTION = aa;\n        DURATION = HybraTimeLibrary.WEEK;\n\n        u = q;\n        v = r;\n\n        ba = ap;\n\n        bb = false;\n\n    }\n\n\n    function p(address aa) external ay {\n        require(aa != address(0), \"ZA\");\n        require(aa != DISTRIBUTION, \"SAME_ADDR\");\n        DISTRIBUTION = aa;\n    }\n\n\n    function n(address t) external ay {\n        require(t != y, \"SAME_ADDR\");\n        y = t;\n    }\n\n\n    function l(address cc) external ay {\n        require(cc >= address(0), \"ZA\");\n        u = cc;\n    }\n\n    function e() external ay {\n        require(bb == false, \"EMER\");\n        bb = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function j() external ay {\n\n        require(bb == true,\"EMER\");\n\n        bb = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n\n    function ak() public view returns (uint256) {\n        return ab;\n    }\n\n\n    function az(address bo) external view returns (uint256) {\n        return aq(bo);\n    }\n\n    function aq(address bo) internal view returns (uint256) {\n\n        return ax[bo];\n    }\n\n\n    function a() public view returns (uint256) {\n        return Math.cf(block.timestamp, z);\n    }\n\n\n    function s() public view returns (uint256) {\n        if (ab == 0) {\n            return g;\n        } else {\n            return g + (a() - w) * ao * 1e18 / ab;\n        }\n    }\n\n\n    function bx(address bo) public view returns (uint256) {\n        return bm[bo] + aq(bo) * (s() - d[bo]) / 1e18;\n    }\n\n\n    function k() external view returns (uint256) {\n        return ao * DURATION;\n    }\n\n    function ae() external view returns (uint256) {\n        return z;\n    }\n\n\n    function ar() external {\n        bf(TOKEN.az(msg.sender), msg.sender);\n    }\n\n\n    function bn(uint256 bu) external {\n        bf(bu, msg.sender);\n    }\n\n\n    function bf(uint256 bu, address bo) internal ac x ad(bo) {\n        require(bu > 0, \"ZV\");\n\n        ax[bo] = ax[bo] + bu;\n        ab = ab + bu;\n        if (address(y) != address(0)) {\n            IRewarder(y).bi(bo, bo, aq(bo));\n        }\n\n        TOKEN.o(bo, address(this), bu);\n\n        emit Deposit(bo, bu);\n    }\n\n\n    function al() external {\n        aw(aq(msg.sender));\n    }\n\n\n    function bg(uint256 bu) external {\n        aw(bu);\n    }\n\n\n    function aw(uint256 bu) internal ac x ad(msg.sender) {\n        require(bu > 0, \"ZV\");\n        require(aq(msg.sender) > 0, \"ZV\");\n        require(block.timestamp >= ag[msg.sender], \"!MATURE\");\n\n        ab = ab - bu;\n        ax[msg.sender] = ax[msg.sender] - bu;\n\n        if (address(y) != address(0)) {\n            IRewarder(y).bi(msg.sender, msg.sender,aq(msg.sender));\n        }\n\n        TOKEN.af(msg.sender, bu);\n\n        emit Withdraw(msg.sender, bu);\n    }\n\n    function i() external ac {\n        require(bb, \"EMER\");\n        uint256 bp = aq(msg.sender);\n        require(bp > 0, \"ZV\");\n        ab = ab - bp;\n\n        ax[msg.sender] = 0;\n\n        TOKEN.af(msg.sender, bp);\n        emit Withdraw(msg.sender, bp);\n    }\n\n    function b(uint256 bp) external ac {\n\n        require(bb, \"EMER\");\n        ab = ab - bp;\n\n        ax[msg.sender] = ax[msg.sender] - bp;\n\n        TOKEN.af(msg.sender, bp);\n        emit Withdraw(msg.sender, bp);\n    }\n\n\n    function f(uint8 ai) external {\n        aw(aq(msg.sender));\n        av(ai);\n    }\n\n\n    function av(address ca, uint8 ai) public ac m ad(ca) {\n        uint256 bv = bm[ca];\n        if (bv > 0) {\n            bm[ca] = 0;\n            IERC20(am).aj(cb, bv);\n            IRHYBR(cb).c(bv);\n            IRHYBR(cb).au(bv, ai, ca);\n            emit Harvest(ca, bv);\n        }\n\n        if (y != address(0)) {\n            IRewarder(y).bi(ca, ca, aq(ca));\n        }\n    }\n\n\n    function av(uint8 ai) public ac ad(msg.sender) {\n        uint256 bv = bm[msg.sender];\n        if (bv > 0) {\n            bm[msg.sender] = 0;\n            IERC20(am).aj(cb, bv);\n            IRHYBR(cb).c(bv);\n            IRHYBR(cb).au(bv, ai, msg.sender);\n            emit Harvest(msg.sender, bv);\n        }\n\n        if (y != address(0)) {\n            IRewarder(y).bi(msg.sender, msg.sender, aq(msg.sender));\n        }\n    }\n\n\n    function h(address by, uint256 bv) external ac x m ad(address(0)) {\n        require(by == address(am), \"IA\");\n        am.o(DISTRIBUTION, address(this), bv);\n\n        if (block.timestamp >= z) {\n            ao = bv / DURATION;\n        } else {\n            uint256 bc = z - block.timestamp;\n            uint256 be = bc * ao;\n            ao = (bv + be) / DURATION;\n        }\n\n\n        uint256 balance = am.az(address(this));\n        require(ao <= balance / DURATION, \"REWARD_HIGH\");\n\n        w = block.timestamp;\n        z = block.timestamp + DURATION;\n        emit RewardAdded(bv);\n    }\n\n    function bd() external ac returns (uint256 bh, uint256 bj) {\n        return as();\n    }\n\n     function as() internal returns (uint256 bh, uint256 bj) {\n        if (!ba) {\n            return (0, 0);\n        }\n        address bs = address(TOKEN);\n        (bh, bj) = IPair(bs).bd();\n        if (bh > 0 || bj > 0) {\n\n            uint256 bw = bh;\n            uint256 bt = bj;\n\n            (address bl, address bk) = IPair(bs).br();\n\n            if (bw  > 0) {\n                IERC20(bl).aj(u, 0);\n                IERC20(bl).aj(u, bw);\n                IBribe(u).h(bl, bw);\n            }\n            if (bt  > 0) {\n                IERC20(bk).aj(u, 0);\n                IERC20(bk).aj(u, bt);\n                IBribe(u).h(bk, bt);\n            }\n            emit ClaimFees(msg.sender, bh, bj);\n        }\n    }\n\n}",
      "rename_map": {
        "lastTimeRewardApplicable": "a",
        "emergencyWithdrawAmount": "b",
        "depostionEmissionsToken": "c",
        "userRewardPerTokenPaid": "d",
        "activateEmergencyMode": "e",
        "withdrawAllAndHarvest": "f",
        "rewardPerTokenStored": "g",
        "notifyRewardAmount": "h",
        "emergencyWithdraw": "i",
        "stopEmergencyMode": "j",
        "rewardForDuration": "k",
        "setInternalBribe": "l",
        "onlyDistribution": "m",
        "setGaugeRewarder": "n",
        "safeTransferFrom": "o",
        "setDistribution": "p",
        "_internal_bribe": "q",
        "_external_bribe": "r",
        "rewardPerToken": "s",
        "_gaugeRewarder": "t",
        "internal_bribe": "u",
        "external_bribe": "v",
        "lastUpdateTime": "w",
        "isNotEmergency": "x",
        "gaugeRewarder": "y",
        "_periodFinish": "z",
        "_distribution": "aa",
        "_totalSupply": "ab",
        "nonReentrant": "ac",
        "updateReward": "ad",
        "periodFinish": "ae",
        "safeTransfer": "af",
        "maturityTime": "ag",
        "_rewardToken": "ah",
        "_redeemType": "ai",
        "safeApprove": "aj",
        "totalSupply": "ak",
        "withdrawAll": "al",
        "rewardToken": "am",
        "userBalance": "an",
        "rewardRate": "ao",
        "_isForPair": "ap",
        "_balanceOf": "aq",
        "depositAll": "ar",
        "_claimFees": "as",
        "recipient": "at",
        "redeemFor": "au",
        "getReward": "av",
        "_withdraw": "aw",
        "_balances": "ax",
        "onlyOwner": "ay",
        "balanceOf": "az",
        "isForPair": "ba",
        "emergency": "bb",
        "remaining": "bc",
        "claimFees": "bd",
        "leftover": "be",
        "_deposit": "bf",
        "withdraw": "bg",
        "claimed0": "bh",
        "onReward": "bi",
        "claimed1": "bj",
        "_token1": "bk",
        "_token0": "bl",
        "rewards": "bm",
        "deposit": "bn",
        "account": "bo",
        "_amount": "bp",
        "_rHYBR": "bq",
        "tokens": "br",
        "_token": "bs",
        "_fees1": "bt",
        "amount": "bu",
        "reward": "bv",
        "_fees0": "bw",
        "earned": "bx",
        "token": "by",
        "gauge": "bz",
        "_user": "ca",
        "rHYBR": "cb",
        "_int": "cc",
        "user": "cd",
        "_ve": "ce",
        "min": "cf"
      },
      "changes": [
        "Renamed 84 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_004",
      "transformed_id": "ss_l2_short_nc_gs_004",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public k = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public d = 1200;\n    uint256 public c = 300;\n\n\n    uint256 public bg = 100;\n    uint256 public constant MIN_WITHDRAW_FEE = 10;\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant BASIS = 10000;\n    address public Team;\n    uint256 public dq;\n    uint256 public dg;\n    uint256 public bm;\n\n    struct UserLock {\n        uint256 dv;\n        uint256 cd;\n    }\n\n    mapping(address => UserLock[]) public cq;\n    mapping(address => uint256) public ak;\n\n\n    address public immutable HYBR;\n    address public immutable aw;\n    address public ed;\n    address public l;\n    address public au;\n    uint256 public cr;\n\n\n    address public db;\n    uint256 public an;\n\n\n    uint256 public ad;\n    uint256 public s;\n\n\n    ISwapper public de;\n\n\n    error NOT_AUTHORIZED();\n\n\n    event Deposit(address indexed em, uint256 cb, uint256 af);\n    event Withdraw(address indexed em, uint256 dt, uint256 cb, uint256 er);\n    event Compound(uint256 dj, uint256 ag);\n    event PenaltyRewardReceived(uint256 dv);\n    event TransferLockPeriodUpdated(uint256 ci, uint256 ct);\n    event SwapperUpdated(address indexed bv, address indexed bz);\n    event VoterSet(address ed);\n    event EmergencyUnlock(address indexed em);\n    event AutoVotingEnabled(bool do);\n    event OperatorUpdated(address indexed bs, address indexed br);\n    event DefaultVotingStrategyUpdated(address[] dy, uint256[] dl);\n    event AutoVoteExecuted(uint256 ei, address[] dy, uint256[] dl);\n\n    constructor(\n        address el,\n        address am\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(el != address(0), \"Invalid HYBR\");\n        require(am != address(0), \"Invalid VE\");\n\n        HYBR = el;\n        aw = am;\n        ad = block.timestamp;\n        s = block.timestamp;\n        db = msg.sender;\n    }\n\n    function e(address j) external cn {\n        require(j != address(0), \"Invalid rewards distributor\");\n        l = j;\n    }\n\n    function u(address ar) external cn {\n        require(ar != address(0), \"Invalid gauge manager\");\n        au = ar;\n    }\n\n\n    modifier at() {\n        if (msg.sender != db) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n\n    function dk(uint256 dv, address cj) external ay {\n        require(dv > 0, \"Zero amount\");\n        cj = cj == address(0) ? msg.sender : cj;\n\n\n        IERC20(HYBR).ba(msg.sender, address(this), dv);\n\n\n        if (cr == 0) {\n            n(dv);\n        } else {\n\n            IERC20(HYBR).df(aw, dv);\n            IVotingEscrow(aw).bf(cr, dv);\n\n\n            q();\n        }\n\n\n        uint256 dt = ab(dv);\n\n\n        ek(cj, dt);\n\n\n        p(cj, dt);\n\n        emit Deposit(msg.sender, dv, dt);\n    }\n\n\n    function cy(uint256 dt) external ay returns (uint256 bi) {\n        require(dt > 0, \"Zero shares\");\n        require(cp(msg.sender) >= dt, \"Insufficient balance\");\n        require(cr != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(aw).ef(cr) == false, \"Cannot withdraw yet\");\n\n        uint256 ce = HybraTimeLibrary.ce(block.timestamp);\n        uint256 cm = HybraTimeLibrary.cm(block.timestamp);\n\n        require(block.timestamp >= ce + d && block.timestamp < cm - c, \"Cannot withdraw yet\");\n\n\n        uint256 cb = y(dt);\n        require(cb > 0, \"No assets to withdraw\");\n\n\n        uint256 co = 0;\n        if (bg > 0) {\n            co = (cb * bg) / BASIS;\n        }\n\n\n        uint256 cg = cb - co;\n        require(cg > 0, \"Amount too small after fee\");\n\n\n        uint256 ch = bp();\n        require(cb <= ch, \"Insufficient veNFT balance\");\n\n        uint256 aa = ch - cg - co;\n        require(aa >= 0, \"Cannot withdraw entire veNFT\");\n\n\n        ej(msg.sender, dt);\n\n\n        uint256[] memory dh = new uint256[](3);\n        dh[0] = aa;\n        dh[1] = cg;\n        dh[2] = co;\n\n        uint256[] memory bj = IVotingEscrow(aw).bx(cr, dh);\n\n\n        cr = bj[0];\n        bi = bj[1];\n        uint256 cf = bj[2];\n\n        IVotingEscrow(aw).t(address(this), msg.sender, bi);\n        IVotingEscrow(aw).t(address(this), Team, cf);\n        emit Withdraw(msg.sender, dt, cg, co);\n    }\n\n\n    function n(uint256 aq) internal {\n\n        IERC20(HYBR).df(aw, type(uint256).eq);\n        uint256 da = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n\n        cr = IVotingEscrow(aw).v(aq, da, address(this));\n\n    }\n\n\n    function ab(uint256 dv) public view returns (uint256) {\n        uint256 ax = bo();\n        uint256 as = bp();\n        if (ax == 0 || as == 0) {\n            return dv;\n        }\n        return (dv * ax) / as;\n    }\n\n\n    function y(uint256 dt) public view returns (uint256) {\n        uint256 ax = bo();\n        if (ax == 0) {\n            return dt;\n        }\n        return (dt * bp()) / ax;\n    }\n\n\n    function bp() public view returns (uint256) {\n        if (cr == 0) {\n            return 0;\n        }\n\n        IVotingEscrow.LockedBalance memory du = IVotingEscrow(aw).du(cr);\n        return uint256(int256(du.dv));\n    }\n\n\n    function p(address em, uint256 dv) internal {\n        uint256 cd = block.timestamp + k;\n        cq[em].push(UserLock({\n            dv: dv,\n            cd: cd\n        }));\n        ak[em] += dv;\n    }\n\n\n    function r(address em) external view returns (uint256 ck) {\n        uint256 av = cp(em);\n        uint256 ao = 0;\n\n        UserLock[] storage es = cq[em];\n        for (uint256 i = 0; i < es.length; i++) {\n            if (es[i].cd > block.timestamp) {\n                ao += es[i].dv;\n            }\n        }\n\n        return av > ao ? av - ao : 0;\n    }\n\n    function ap(address em) internal returns (uint256 ec) {\n        UserLock[] storage es = cq[em];\n        uint256 ep = es.length;\n        if (ep == 0) return 0;\n\n        uint256 eb = 0;\n        unchecked {\n            for (uint256 i = 0; i < ep; i++) {\n                UserLock memory L = es[i];\n                if (L.cd <= block.timestamp) {\n                    ec += L.dv;\n                } else {\n                    if (eb != i) es[eb] = L;\n                    eb++;\n                }\n            }\n            if (ec > 0) {\n                ak[em] -= ec;\n            }\n            while (es.length > eb) {\n                es.pop();\n            }\n        }\n    }\n\n\n    function i(\n        address from,\n        address eu,\n        uint256 dv\n    ) internal override {\n        super.i(from, eu, dv);\n\n        if (from != address(0) && eu != address(0)) {\n            uint256 av = cp(from);\n\n\n            uint256 o = av > ak[from] ? av - ak[from] : 0;\n\n\n            if (o >= dv) {\n                return;\n            }\n\n\n            ap(from);\n            uint256 ac = av > ak[from] ? av - ak[from] : 0;\n\n\n            require(ac >= dv, \"Tokens locked\");\n        }\n    }\n\n\n    function bd() external at {\n        require(ed != address(0), \"Voter not set\");\n        require(l != address(0), \"Distributor not set\");\n\n\n        uint256  bc = IRewardsDistributor(l).ea(cr);\n        dq += bc;\n\n        address[] memory ca = IVoter(ed).cz(cr);\n\n        for (uint256 i = 0; i < ca.length; i++) {\n            if (ca[i] != address(0)) {\n                address ee = IGaugeManager(au).dp(ca[i]);\n\n                if (ee != address(0)) {\n\n                    address[] memory dr = new address[](1);\n                    address[][] memory ds = new address[][](1);\n\n\n                    address al = IGaugeManager(au).z(ee);\n                    if (al != address(0)) {\n                        uint256 bw = IBribe(al).m();\n                        if (bw > 0) {\n                            address[] memory bt = new address[](bw);\n                            for (uint256 j = 0; j < bw; j++) {\n                                bt[j] = IBribe(al).bt(j);\n                            }\n                            dr[0] = al;\n                            ds[0] = bt;\n\n                            IGaugeManager(au).bq(dr, ds, cr);\n                        }\n                    }\n\n\n                    address aj = IGaugeManager(au).w(ee);\n                    if (aj != address(0)) {\n                        uint256 bw = IBribe(aj).m();\n                        if (bw > 0) {\n                            address[] memory bt = new address[](bw);\n                            for (uint256 j = 0; j < bw; j++) {\n                                bt[j] = IBribe(aj).bt(j);\n                            }\n                            dr[0] = aj;\n                            ds[0] = bt;\n\n                            IGaugeManager(au).bq(dr, ds, cr);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    function bh(ISwapper.SwapParams calldata dn) external ay at {\n        require(address(de) != address(0), \"Swapper not set\");\n\n\n        uint256 bb = IERC20(dn.dm).cp(address(this));\n        require(bb >= dn.cw, \"Insufficient token balance\");\n\n\n        IERC20(dn.dm).bl(address(de), dn.cw);\n\n\n        uint256 be = de.by(dn);\n\n\n        IERC20(dn.dm).bl(address(de), 0);\n\n\n        bm += be;\n    }\n\n\n    function dc() external at {\n\n\n        uint256 bu = IERC20(HYBR).cp(address(this));\n\n        if (bu > 0) {\n\n            IERC20(HYBR).bl(aw, bu);\n            IVotingEscrow(aw).bf(cr, bu);\n\n\n            q();\n\n            s = block.timestamp;\n\n            emit Compound(bu, bp());\n        }\n    }\n\n\n    function en(address[] calldata cs, uint256[] calldata cu) external {\n        require(msg.sender == dx() || msg.sender == db, \"Not authorized\");\n        require(ed != address(0), \"Voter not set\");\n\n        IVoter(ed).en(cr, cs, cu);\n        an = HybraTimeLibrary.ce(block.timestamp);\n\n    }\n\n\n    function dz() external {\n        require(msg.sender == dx() || msg.sender == db, \"Not authorized\");\n        require(ed != address(0), \"Voter not set\");\n\n        IVoter(ed).dz(cr);\n    }\n\n\n    function g(uint256 dv) external {\n\n\n        if (dv > 0) {\n            IERC20(HYBR).df(aw, dv);\n\n            if(cr == 0){\n                n(dv);\n            } else{\n                IVotingEscrow(aw).bf(cr, dv);\n\n\n                q();\n            }\n        }\n        dg += dv;\n        emit PenaltyRewardReceived(dv);\n    }\n\n\n    function cv(address dw) external cn {\n        require(dw != address(0), \"Invalid voter\");\n        ed = dw;\n        emit VoterSet(dw);\n    }\n\n\n    function f(uint256 dd) external cn {\n        require(dd >= MIN_LOCK_PERIOD && dd <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 ci = k;\n        k = dd;\n        emit TransferLockPeriodUpdated(ci, dd);\n    }\n\n\n    function ae(uint256 eo) external cn {\n        require(eo >= MIN_WITHDRAW_FEE && eo <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        bg = eo;\n    }\n\n    function b(uint256 eh) external cn {\n        d = eh;\n    }\n\n    function a(uint256 eh) external cn {\n        c = eh;\n    }\n\n\n    function cc(address cx) external cn {\n        require(cx != address(0), \"Invalid swapper\");\n        address bv = address(de);\n        de = ISwapper(cx);\n        emit SwapperUpdated(bv, cx);\n    }\n\n\n    function di(address eg) external cn {\n        require(eg != address(0), \"Invalid team\");\n        Team = eg;\n    }\n\n\n    function x(address em) external at {\n        delete cq[em];\n        ak[em] = 0;\n        emit EmergencyUnlock(em);\n    }\n\n\n    function az(address em) external view returns (UserLock[] memory) {\n        return cq[em];\n    }\n\n\n    function bk(address cl) external cn {\n        require(cl != address(0), \"Invalid operator\");\n        address bs = db;\n        db = cl;\n        emit OperatorUpdated(bs, cl);\n    }\n\n\n    function ah() external view returns (uint256) {\n        if (cr == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory du = IVotingEscrow(aw).du(cr);\n        return uint256(du.et);\n    }\n\n\n    function q() internal {\n        if (cr == 0) return;\n\n        IVotingEscrow.LockedBalance memory du = IVotingEscrow(aw).du(cr);\n        if (du.bn || du.et <= block.timestamp) return;\n\n        uint256 ai = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n\n        if (ai > du.et + 2 hours) {\n            try IVotingEscrow(aw).h(cr, HybraTimeLibrary.MAX_LOCK_DURATION) {\n\n            } catch {\n\n\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setTailNotWithdrawTime": "a",
        "setHeadNotWithdrawTime": "b",
        "tail_not_withdraw_time": "c",
        "head_not_withdraw_time": "d",
        "setRewardsDistributor": "e",
        "setTransferLockPeriod": "f",
        "receivePenaltyReward": "g",
        "increase_unlock_time": "h",
        "_beforeTokenTransfer": "i",
        "_rewardsDistributor": "j",
        "transferLockPeriod": "k",
        "rewardsDistributor": "l",
        "rewardsListLength": "m",
        "_initializeVeNFT": "n",
        "currentAvailable": "o",
        "_addTransferLock": "p",
        "_extendLockToMax": "q",
        "previewAvailable": "r",
        "lastCompoundTime": "s",
        "safeTransferFrom": "t",
        "setGaugeManager": "u",
        "create_lock_for": "v",
        "external_bribes": "w",
        "emergencyUnlock": "x",
        "calculateAssets": "y",
        "internal_bribes": "z",
        "remainingAmount": "aa",
        "calculateShares": "ab",
        "finalAvailable": "ac",
        "lastRebaseTime": "ad",
        "setWithdrawFee": "ae",
        "sharesReceived": "af",
        "newTotalLocked": "ag",
        "getLockEndTime": "ah",
        "maxUnlockTime": "ai",
        "externalBribe": "aj",
        "lockedBalance": "ak",
        "internalBribe": "al",
        "_votingEscrow": "am",
        "lastVoteEpoch": "an",
        "currentLocked": "ao",
        "_cleanExpired": "ap",
        "initialAmount": "aq",
        "_gaugeManager": "ar",
        "_totalAssets": "as",
        "onlyOperator": "at",
        "gaugeManager": "au",
        "totalBalance": "av",
        "votingEscrow": "aw",
        "_totalSupply": "ax",
        "nonReentrant": "ay",
        "getUserLocks": "az",
        "transferFrom": "ba",
        "tokenBalance": "bb",
        "rebaseAmount": "bc",
        "claimRewards": "bd",
        "hybrReceived": "be",
        "deposit_for": "bf",
        "withdrawFee": "bg",
        "executeSwap": "bh",
        "userTokenId": "bi",
        "newTokenIds": "bj",
        "setOperator": "bk",
        "safeApprove": "bl",
        "votingYield": "bm",
        "isPermanent": "bn",
        "totalSupply": "bo",
        "totalAssets": "bp",
        "claimBribes": "bq",
        "newOperator": "br",
        "oldOperator": "bs",
        "bribeTokens": "bt",
        "hybrBalance": "bu",
        "oldSwapper": "bv",
        "tokenCount": "bw",
        "multiSplit": "bx",
        "swapToHYBR": "by",
        "newSwapper": "bz",
        "votedPools": "ca",
        "hybrAmount": "cb",
        "setSwapper": "cc",
        "unlockTime": "cd",
        "epochStart": "ce",
        "feeTokenId": "cf",
        "userAmount": "cg",
        "veBalance": "ch",
        "oldPeriod": "ci",
        "recipient": "cj",
        "available": "ck",
        "_operator": "cl",
        "epochNext": "cm",
        "onlyOwner": "cn",
        "feeAmount": "co",
        "balanceOf": "cp",
        "userLocks": "cq",
        "veTokenId": "cr",
        "_poolVote": "cs",
        "newPeriod": "ct",
        "_weights": "cu",
        "setVoter": "cv",
        "amountIn": "cw",
        "_swapper": "cx",
        "withdraw": "cy",
        "poolVote": "cz",
        "lockTime": "da",
        "operator": "db",
        "compound": "dc",
        "_period": "dd",
        "swapper": "de",
        "approve": "df",
        "penalty": "dg",
        "amounts": "dh",
        "setTeam": "di",
        "rewards": "dj",
        "deposit": "dk",
        "weights": "dl",
        "tokenIn": "dm",
        "_params": "dn",
        "enabled": "do",
        "gauges": "dp",
        "rebase": "dq",
        "bribes": "dr",
        "tokens": "ds",
        "shares": "dt",
        "locked": "du",
        "amount": "dv",
        "_voter": "dw",
        "owner": "dx",
        "pools": "dy",
        "reset": "dz",
        "claim": "ea",
        "write": "eb",
        "freed": "ec",
        "voter": "ed",
        "gauge": "ee",
        "voted": "ef",
        "_team": "eg",
        "_time": "eh",
        "epoch": "ei",
        "_burn": "ej",
        "_mint": "ek",
        "_HYBR": "el",
        "user": "em",
        "vote": "en",
        "_fee": "eo",
        "len": "ep",
        "max": "eq",
        "fee": "er",
        "arr": "es",
        "end": "et",
        "to": "eu"
      },
      "changes": [
        "Renamed 151 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_005",
      "transformed_id": "ss_l2_short_nc_gs_005",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPairInfo.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVotingEscrow.sol';\nimport './interfaces/IGaugeManager.sol';\nimport './interfaces/IPermissionsRegistry.sol';\nimport './interfaces/ITokenHandler.sol';\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract VoterV3 is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public bk;\n    address internal bh;\n    address public g;\n    address public v;\n    uint256 public w;\n    uint public EPOCH_DURATION;\n    uint256 internal constant MIN_VOTING_NUM = 10;\n    IGaugeManager public t;\n\n    mapping(uint256 => mapping(address => uint256)) public ba;\n    mapping(uint256 => address[]) public am;\n\n    mapping(address => uint256) public ap;\n    uint256 public ad;\n    mapping(uint256 => uint256) public aa;\n\n    mapping(uint256 => uint256) public aj;\n    mapping(uint256 => uint256) public f;\n\n    event Voted(address indexed bb, uint256 as, uint256 av);\n    event Abstained(uint256 as, uint256 av);\n    event SetPermissionRegistry(address indexed bl, address indexed az);\n\n    constructor() {}\n\n\n    function af(\n        address __ve,\n        address q,\n        address r,\n        address e\n    ) public ab {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        bk = __ve;\n        bh = IVotingEscrow(__ve).bf();\n        t = IGaugeManager(r);\n        g = e;\n        v = q;\n        w = 30;\n        EPOCH_DURATION = HybraTimeLibrary.WEEK;\n    }\n\n\n    modifier VoterAdmin() {\n        require(IPermissionsRegistry(g).au(\"VOTER_ADMIN\",msg.sender), 'VOTER_ADMIN');\n        _;\n    }\n\n    modifier Governance() {\n        require(IPermissionsRegistry(g).au(\"GOVERNANCE\",msg.sender), 'GOVERNANCE');\n        _;\n    }\n\n    modifier GenesisManager() {\n        require(IPermissionsRegistry(g).au(\"GENESIS_MANAGER\", msg.sender), 'GENESIS_MANAGER');\n        _;\n    }\n\n\n    function c(address e) external VoterAdmin {\n        require(e.code.length > 0, \"CODELEN\");\n        require(e != address(0), \"ZA\");\n        emit SetPermissionRegistry(g, e);\n        g = e;\n    }\n\n    function k(uint256 p) external VoterAdmin {\n        require (p >= MIN_VOTING_NUM, \"LOW_VOTE\");\n        w = p;\n    }\n\n\n    function be(uint256 ao) external z(ao) y {\n        require(IVotingEscrow(bk).h(msg.sender, ao), \"NAO\");\n        aw(ao);\n        IVotingEscrow(bk).ar(ao);\n    }\n\n    function aw(uint256 ao) internal {\n        address[] storage ai = am[ao];\n        uint256 s = ai.length;\n        uint256 u = 0;\n\n        for (uint256 i = 0; i < s; i ++) {\n            address bg = ai[i];\n            uint256 ay = ba[ao][bg];\n\n            if (ay != 0) {\n                ap[bg] -= ay;\n\n                ba[ao][bg] -= ay;\n                address o = t.b(bg);\n                address m = t.a(bg);\n                IBribe(o).al(uint256(ay), ao);\n                IBribe(m).al(uint256(ay), ao);\n\n\n                u += ay;\n\n                emit Abstained(ao, ay);\n            }\n        }\n        ad -= u;\n        aa[ao] = 0;\n        delete am[ao];\n    }\n\n\n    function bi(uint256 ao) external y {\n        uint256 ag = block.timestamp;\n        if (ag <= HybraTimeLibrary.n(ag)){\n            revert(\"DW\");\n        }\n        require(IVotingEscrow(bk).h(msg.sender, ao) || msg.sender == bk, \"NAO||VE\");\n        address[] memory ai = am[ao];\n        uint256 ak = ai.length;\n        uint256[] memory an = new uint256[](ak);\n\n        for (uint256 i = 0; i < ak; i ++) {\n            an[i] = ba[ao][ai[i]];\n        }\n\n        bd(ao, ai, an);\n    }\n\n\n    function bj(uint256 ao, address[] calldata ai, uint256[] calldata an)\n        external z(ao) y {\n        require(IVotingEscrow(bk).h(msg.sender, ao), \"NAO\");\n        require(ai.length == an.length, \"MISMATCH_LEN\");\n        require(ai.length <= w, \"EXCEEDS\");\n        uint256 ag = block.timestamp;\n\n        bd(ao, ai, an);\n        aj[ao] = HybraTimeLibrary.ah(block.timestamp) + 1;\n        f[ao] = block.timestamp;\n    }\n\n    function bd(uint256 ao, address[] memory ai, uint256[] memory an) internal {\n        aw(ao);\n        uint256 ak = ai.length;\n        uint256 at = IVotingEscrow(bk).x(ao);\n        uint256 i = 0;\n        uint256 ae = 0;\n\n        for (uint i = 0; i < ak; i++) {\n\n            if(t.d(ai[i])) i += an[i];\n        }\n\n        for (uint256 i = 0; i < ak; i++) {\n            address bg = ai[i];\n\n            if (t.d(bg)) {\n                uint256 ac = an[i] * at / i;\n\n                require(ba[ao][bg] == 0, \"ZV\");\n                require(ac != 0, \"ZV\");\n\n                am[ao].push(bg);\n                ap[bg] += ac;\n\n                ba[ao][bg] = ac;\n                address o = t.b(bg);\n                address m = t.a(bg);\n\n                IBribe(o).aq(uint256(ac), ao);\n                IBribe(m).aq(uint256(ac), ao);\n\n                ae += ac;\n                emit Voted(msg.sender, ao, ac);\n            }\n        }\n        if (ae > 0) IVotingEscrow(bk).ax(ao);\n        ad += ae;\n        aa[ao] = ae;\n    }\n\n    modifier z(uint256 ao) {\n\n        if (HybraTimeLibrary.ah(block.timestamp) <= aj[ao]) revert(\"VOTED\");\n        if (block.timestamp <= HybraTimeLibrary.n(block.timestamp)) revert(\"DW\");\n        _;\n    }\n\n\n    function length() external view returns (uint256) {\n        return t.bc().length;\n    }\n\n\n    function l(uint256 as) external view returns(uint256) {\n        return am[as].length;\n    }\n\n    function j(address r) external VoterAdmin {\n        require(r != address(0));\n        t = IGaugeManager(r);\n    }\n\n}",
      "rename_map": {
        "fetchExternalBribeFromPool": "a",
        "fetchInternalBribeFromPool": "b",
        "setPermissionsRegistry": "c",
        "isGaugeAliveForPool": "d",
        "_permissionRegistry": "e",
        "lastVotedTimestamp": "f",
        "permissionRegistry": "g",
        "isApprovedOrOwner": "h",
        "_totalVoteWeight": "i",
        "setGaugeManager": "j",
        "setMaxVotingNum": "k",
        "poolVoteLength": "l",
        "external_bribe": "m",
        "epochVoteStart": "n",
        "internal_bribe": "o",
        "_maxVotingNum": "p",
        "_tokenHandler": "q",
        "_gaugeManager": "r",
        "_poolVoteCnt": "s",
        "gaugeManager": "t",
        "_totalWeight": "u",
        "tokenHandler": "v",
        "maxVotingNum": "w",
        "balanceOfNFT": "x",
        "nonReentrant": "y",
        "onlyNewEpoch": "z",
        "usedWeights": "aa",
        "initializer": "ab",
        "_poolWeight": "ac",
        "totalWeight": "ad",
        "_usedWeight": "ae",
        "initialize": "af",
        "_timestamp": "ag",
        "epochStart": "ah",
        "_poolVote": "ai",
        "lastVoted": "aj",
        "_poolCnt": "ak",
        "withdraw": "al",
        "poolVote": "am",
        "_weights": "an",
        "_tokenId": "ao",
        "weights": "ap",
        "deposit": "aq",
        "abstain": "ar",
        "tokenId": "as",
        "_weight": "at",
        "hasRole": "au",
        "weight": "av",
        "_reset": "aw",
        "voting": "ax",
        "_votes": "ay",
        "latest": "az",
        "votes": "ba",
        "voter": "bb",
        "pools": "bc",
        "_vote": "bd",
        "reset": "be",
        "token": "bf",
        "_pool": "bg",
        "base": "bh",
        "poke": "bi",
        "vote": "bj",
        "_ve": "bk",
        "old": "bl"
      },
      "changes": [
        "Renamed 64 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_006",
      "transformed_id": "ss_l2_short_nc_gs_006",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable ax;\n    address public immutable df;\n    address public VE;\n    address public DISTRIBUTION;\n    address public ab;\n    address public ac;\n\n    uint256 public DURATION;\n    uint256 internal aj;\n    uint256 public bb;\n    ICLPool public cw;\n    address public ay;\n    INonfungiblePositionManager public b;\n\n    bool public bu;\n    bool public immutable bt;\n    address immutable cj;\n\n    mapping(uint256 => uint256) public  q;\n    mapping(address => EnumerableSet.UintSet) internal cl;\n    mapping(uint256 => uint256) public  l;\n\n    mapping(uint256 => uint256) public  ck;\n\n    mapping(uint256 => uint256) public  ae;\n\n    event RewardAdded(uint256 cy);\n    event Deposit(address indexed dj, uint256 cx);\n    event Withdraw(address indexed dj, uint256 cx);\n    event Harvest(address indexed dj, uint256 cy);\n    event ClaimFees(address indexed from, uint256 cc, uint256 ce);\n    event EmergencyActivated(address indexed de, uint256 timestamp);\n    event EmergencyDeactivated(address indexed de, uint256 timestamp);\n\n    constructor(address ar, address cr, address dn, address dg, address ak, address x,\n        address y, bool bc, address dk,  address by) {\n        cj = by;\n        ax = IERC20(ar);\n        df = cr;\n        VE = dn;\n        ay = dg;\n        cw = ICLPool(dg);\n        DISTRIBUTION = ak;\n        DURATION = HybraTimeLibrary.WEEK;\n\n        ab = x;\n        ac = y;\n        bt = bc;\n        b = INonfungiblePositionManager(dk);\n        bu = false;\n    }\n\n    modifier s() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier ag() {\n        require(bu == false, \"emergency\");\n        _;\n    }\n\n    function ad(uint256 cq, int24 bq, int24 bs) internal {\n        if (ae[cq] == block.timestamp) return;\n        cw.c();\n        ae[cq] = block.timestamp;\n        ck[cq] += cp(cq);\n        l[cq] = cw.g(bq, bs, 0);\n    }\n\n    function h() external bp {\n        require(bu == false, \"emergency\");\n        bu = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function m() external bp {\n\n        require(bu == true,\"emergency\");\n\n        bu = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function br(uint256 cq) external view returns (uint256) {\n        (,,,,,,,uint128 bw,,,,) = b.bm(cq);\n        return bw;\n    }\n\n    function aa(address da, address cs, int24 av) internal view returns (address) {\n        return ICLFactory(b.cj()).cm(da, cs, av);\n    }\n\n    function dc(uint256 cq) external view returns (uint256 cy) {\n        require(cl[msg.sender].bz(cq), \"NA\");\n\n        uint256 cy = cp(cq);\n        return (cy);\n    }\n\n       function cp(uint256 cq) internal view returns (uint256) {\n        uint256 at = cw.at();\n\n        uint256 bl = block.timestamp - at;\n\n        uint256 f = cw.f();\n        uint256 al = cw.al();\n\n        if (bl != 0 && al > 0 && cw.z() > 0) {\n            uint256 cy = bb * bl;\n            if (cy > al) cy = al;\n\n            f += FullMath.db(cy, FixedPoint128.Q128, cw.z());\n        }\n\n        (,,,,, int24 bq, int24 bs, uint128 bw,,,,) = b.bm(cq);\n\n        uint256 a = l[cq];\n        uint256 d = cw.g(bq, bs, f);\n\n        uint256 bv =\n            FullMath.db(d - a, bw, FixedPoint128.Q128);\n        return bv;\n    }\n\n    function cn(uint256 cq) external ap ag {\n\n         (,,address da, address cs, int24 av, int24 bq, int24 bs, uint128 bw,,,,) =\n            b.bm(cq);\n\n        require(bw > 0, \"Gauge: zero liquidity\");\n\n        address am = aa(da, cs, av);\n\n        require(am == ay, \"Pool mismatch: Position not for this gauge pool\");\n\n        b.cf(INonfungiblePositionManager.CollectParams({\n                cq: cq,\n                bi: msg.sender,\n                bd: type(uint128).dl,\n                az: type(uint128).dl\n            }));\n\n        b.u(msg.sender, address(this), cq);\n\n        cw.dh(int128(bw), bq, bs, true);\n\n        uint256 an = cw.g(bq, bs, 0);\n        l[cq] = an;\n        ae[cq] = block.timestamp;\n\n        cl[msg.sender].dm(cq);\n\n        emit Deposit(msg.sender, cq);\n    }\n\n    function cb(uint256 cq, uint8 ba) external ap ag {\n           require(cl[msg.sender].bz(cq), \"NA\");\n\n\n        b.cf(\n            INonfungiblePositionManager.CollectParams({\n                cq: cq,\n                bi: msg.sender,\n                bd: type(uint128).dl,\n                az: type(uint128).dl\n            })\n        );\n\n        (,,,,, int24 bq, int24 bs, uint128 t,,,,) = b.bm(cq);\n        bf(bq, bs, cq, msg.sender, ba);\n\n\n        if (t != 0) {\n            cw.dh(-int128(t), bq, bs, true);\n        }\n\n        cl[msg.sender].ct(cq);\n        b.u(address(this), msg.sender, cq);\n\n        emit Withdraw(msg.sender, cq);\n    }\n\n    function bn(uint256 cq, address co,uint8 ba ) public ap s {\n\n        require(cl[co].bz(cq), \"NA\");\n\n        (,,,,, int24 bq, int24 bs,,,,,) = b.bm(cq);\n        bf(bq, bs, cq, co, ba);\n    }\n\n    function bf(int24 bq, int24 bs, uint256 cq,address co, uint8 ba) internal {\n        ad(cq, bq, bs);\n        uint256 ao = ck[cq];\n        if(ao > 0){\n            delete ck[cq];\n            ax.aw(df, ao);\n            IRHYBR(df).e(ao);\n            IRHYBR(df).bj(ao, ba, co);\n        }\n        emit Harvest(msg.sender, ao);\n    }\n\n    function k(address dd, uint256 ao) external ap\n        ag s returns (uint256 au) {\n        require(dd == address(ax), \"Invalid reward token\");\n\n\n        cw.c();\n\n\n        uint256 j = HybraTimeLibrary.bk(block.timestamp) - block.timestamp;\n        uint256 o = block.timestamp + j;\n\n\n        uint256 p = ao + cw.ca();\n\n\n        if (block.timestamp >= aj) {\n\n            bb = ao / j;\n            cw.be({\n                bb: bb,\n                al: p,\n                aq: o\n            });\n        } else {\n\n            uint256 af = j * bb;\n            bb = (ao + af) / j;\n            cw.be({\n                bb: bb,\n                al: p + af,\n                aq: o\n            });\n        }\n\n\n        q[HybraTimeLibrary.bh(block.timestamp)] = bb;\n\n\n        ax.u(DISTRIBUTION, address(this), ao);\n\n\n        uint256 w = ax.br(address(this));\n        require(bb <= w / j, \"Insufficient balance for reward rate\");\n\n\n        aj = o;\n        au = bb;\n\n        emit RewardAdded(ao);\n    }\n\n    function ah() external view returns (uint256 da, uint256 cs){\n\n        (da, cs) = cw.bo();\n\n    }\n\n    function bx() external ap returns (uint256 cc, uint256 ce) {\n        return bg();\n    }\n\n    function bg() internal returns (uint256 cc, uint256 ce) {\n        if (!bt) {\n            return (0, 0);\n        }\n\n        cw.as();\n\n        address ch = cw.da();\n        address cg = cw.cs();\n\n        cc = IERC20(ch).br(address(this));\n        ce = IERC20(cg).br(address(this));\n\n        if (cc > 0 || ce > 0) {\n\n            uint256 cz = cc;\n            uint256 cv = ce;\n\n            if (cz  > 0) {\n                IERC20(ch).aw(ab, 0);\n                IERC20(ch).aw(ab, cz);\n                IBribe(ab).k(ch, cz);\n            }\n            if (cv  > 0) {\n                IERC20(cg).aw(ab, 0);\n                IERC20(cg).aw(ab, cv);\n                IBribe(ab).k(cg, cv);\n            }\n            emit ClaimFees(msg.sender, cc, ce);\n        }\n    }\n\n\n    function n() external view returns (uint256) {\n        return bb * DURATION;\n    }\n\n\n    function r(address di) external bp {\n        require(di >= address(0), \"zero\");\n        ab = di;\n    }\n\n    function ai(address dd,address do,uint256 value) internal {\n        require(dd.code.length > 0);\n        (bool ci, bytes memory data) = dd.call(abi.i(IERC20.transfer.selector, do, value));\n        require(ci && (data.length == 0 || abi.cu(data, (bool))));\n    }\n\n\n    function v(\n        address cd,\n        address from,\n        uint256 cq,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.v.selector;\n    }\n\n}",
      "rename_map": {
        "rewardPerTokenInsideInitialX128": "a",
        "nonfungiblePositionManager": "b",
        "updateRewardsGrowthGlobal": "c",
        "rewardPerTokenInsideX128": "d",
        "depostionEmissionsToken": "e",
        "rewardGrowthGlobalX128": "f",
        "getRewardGrowthInside": "g",
        "activateEmergencyMode": "h",
        "encodeWithSelector": "i",
        "epochTimeRemaining": "j",
        "notifyRewardAmount": "k",
        "rewardGrowthInside": "l",
        "stopEmergencyMode": "m",
        "rewardForDuration": "n",
        "epochEndTimestamp": "o",
        "totalRewardAmount": "p",
        "rewardRateByEpoch": "q",
        "setInternalBribe": "r",
        "onlyDistribution": "s",
        "liquidityToStake": "t",
        "safeTransferFrom": "u",
        "onERC721Received": "v",
        "contractBalance": "w",
        "_internal_bribe": "x",
        "_external_bribe": "y",
        "stakedLiquidity": "z",
        "_getPoolAddress": "aa",
        "internal_bribe": "ab",
        "external_bribe": "ac",
        "_updateRewards": "ad",
        "lastUpdateTime": "ae",
        "pendingRewards": "af",
        "isNotEmergency": "ag",
        "gaugeBalances": "ah",
        "_safeTransfer": "ai",
        "_periodFinish": "aj",
        "_distribution": "ak",
        "rewardReserve": "al",
        "positionPool": "am",
        "rewardGrowth": "an",
        "rewardAmount": "ao",
        "nonReentrant": "ap",
        "periodFinish": "aq",
        "_rewardToken": "ar",
        "collectFees": "as",
        "lastUpdated": "at",
        "currentRate": "au",
        "tickSpacing": "av",
        "safeApprove": "aw",
        "rewardToken": "ax",
        "poolAddress": "ay",
        "amount1Max": "az",
        "redeemType": "ba",
        "rewardRate": "bb",
        "_isForPair": "bc",
        "amount0Max": "bd",
        "syncReward": "be",
        "_getReward": "bf",
        "_claimFees": "bg",
        "epochStart": "bh",
        "recipient": "bi",
        "redeemFor": "bj",
        "epochNext": "bk",
        "timeDelta": "bl",
        "positions": "bm",
        "getReward": "bn",
        "gaugeFees": "bo",
        "onlyOwner": "bp",
        "tickLower": "bq",
        "balanceOf": "br",
        "tickUpper": "bs",
        "isForPair": "bt",
        "emergency": "bu",
        "claimable": "bv",
        "liquidity": "bw",
        "claimFees": "bx",
        "_factory": "by",
        "contains": "bz",
        "rollover": "ca",
        "withdraw": "cb",
        "claimed0": "cc",
        "operator": "cd",
        "claimed1": "ce",
        "collect": "cf",
        "_token1": "cg",
        "_token0": "ch",
        "success": "ci",
        "factory": "cj",
        "rewards": "ck",
        "_stakes": "cl",
        "getPool": "cm",
        "deposit": "cn",
        "account": "co",
        "_earned": "cp",
        "tokenId": "cq",
        "_rHYBR": "cr",
        "token1": "cs",
        "remove": "ct",
        "decode": "cu",
        "_fees1": "cv",
        "clPool": "cw",
        "amount": "cx",
        "reward": "cy",
        "_fees0": "cz",
        "token0": "da",
        "mulDiv": "db",
        "earned": "dc",
        "token": "dd",
        "gauge": "de",
        "rHYBR": "df",
        "_pool": "dg",
        "stake": "dh",
        "_int": "di",
        "user": "dj",
        "nfpm": "dk",
        "max": "dl",
        "add": "dm",
        "_ve": "dn",
        "to": "do"
      },
      "changes": [
        "Renamed 119 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_007",
      "transformed_id": "ss_l2_short_nc_gs_007",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable ax;\n    address public immutable df;\n    address public VE;\n    address public DISTRIBUTION;\n    address public ab;\n    address public ac;\n\n    uint256 public DURATION;\n    uint256 internal aj;\n    uint256 public bb;\n    ICLPool public cw;\n    address public ay;\n    INonfungiblePositionManager public b;\n\n    bool public bu;\n    bool public immutable bt;\n    address immutable cj;\n\n    mapping(uint256 => uint256) public  q;\n    mapping(address => EnumerableSet.UintSet) internal cl;\n    mapping(uint256 => uint256) public  l;\n\n    mapping(uint256 => uint256) public  ck;\n\n    mapping(uint256 => uint256) public  ae;\n\n    event RewardAdded(uint256 cy);\n    event Deposit(address indexed dj, uint256 cx);\n    event Withdraw(address indexed dj, uint256 cx);\n    event Harvest(address indexed dj, uint256 cy);\n    event ClaimFees(address indexed from, uint256 cc, uint256 ce);\n    event EmergencyActivated(address indexed de, uint256 timestamp);\n    event EmergencyDeactivated(address indexed de, uint256 timestamp);\n\n    constructor(address ar, address cr, address dn, address dg, address ak, address x,\n        address y, bool bc, address dk,  address by) {\n        cj = by;\n        ax = IERC20(ar);\n        df = cr;\n        VE = dn;\n        ay = dg;\n        cw = ICLPool(dg);\n        DISTRIBUTION = ak;\n        DURATION = HybraTimeLibrary.WEEK;\n\n        ab = x;\n        ac = y;\n        bt = bc;\n        b = INonfungiblePositionManager(dk);\n        bu = false;\n    }\n\n    modifier s() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier ag() {\n        require(bu == false, \"emergency\");\n        _;\n    }\n\n    function ad(uint256 cq, int24 bq, int24 bs) internal {\n        if (ae[cq] == block.timestamp) return;\n        cw.c();\n        ae[cq] = block.timestamp;\n        ck[cq] += cp(cq);\n        l[cq] = cw.g(bq, bs, 0);\n    }\n\n    function h() external bp {\n        require(bu == false, \"emergency\");\n        bu = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function m() external bp {\n\n        require(bu == true,\"emergency\");\n\n        bu = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function br(uint256 cq) external view returns (uint256) {\n        (,,,,,,,uint128 bw,,,,) = b.bm(cq);\n        return bw;\n    }\n\n    function aa(address da, address cs, int24 av) internal view returns (address) {\n        return ICLFactory(b.cj()).cm(da, cs, av);\n    }\n\n    function dc(uint256 cq) external view returns (uint256 cy) {\n        require(cl[msg.sender].bz(cq), \"NA\");\n\n        uint256 cy = cp(cq);\n        return (cy);\n    }\n\n       function cp(uint256 cq) internal view returns (uint256) {\n        uint256 at = cw.at();\n\n        uint256 bl = block.timestamp - at;\n\n        uint256 f = cw.f();\n        uint256 al = cw.al();\n\n        if (bl != 0 && al > 0 && cw.z() > 0) {\n            uint256 cy = bb * bl;\n            if (cy > al) cy = al;\n\n            f += FullMath.db(cy, FixedPoint128.Q128, cw.z());\n        }\n\n        (,,,,, int24 bq, int24 bs, uint128 bw,,,,) = b.bm(cq);\n\n        uint256 a = l[cq];\n        uint256 d = cw.g(bq, bs, f);\n\n        uint256 bv =\n            FullMath.db(d - a, bw, FixedPoint128.Q128);\n        return bv;\n    }\n\n    function cn(uint256 cq) external ap ag {\n\n         (,,address da, address cs, int24 av, int24 bq, int24 bs, uint128 bw,,,,) =\n            b.bm(cq);\n\n        require(bw > 0, \"Gauge: zero liquidity\");\n\n        address am = aa(da, cs, av);\n\n        require(am == ay, \"Pool mismatch: Position not for this gauge pool\");\n\n        b.cf(INonfungiblePositionManager.CollectParams({\n                cq: cq,\n                bi: msg.sender,\n                bd: type(uint128).dl,\n                az: type(uint128).dl\n            }));\n\n        b.u(msg.sender, address(this), cq);\n\n        cw.dh(int128(bw), bq, bs, true);\n\n        uint256 an = cw.g(bq, bs, 0);\n        l[cq] = an;\n        ae[cq] = block.timestamp;\n\n        cl[msg.sender].dm(cq);\n\n        emit Deposit(msg.sender, cq);\n    }\n\n    function cb(uint256 cq, uint8 ba) external ap ag {\n           require(cl[msg.sender].bz(cq), \"NA\");\n\n\n        b.cf(\n            INonfungiblePositionManager.CollectParams({\n                cq: cq,\n                bi: msg.sender,\n                bd: type(uint128).dl,\n                az: type(uint128).dl\n            })\n        );\n\n        (,,,,, int24 bq, int24 bs, uint128 t,,,,) = b.bm(cq);\n        bf(bq, bs, cq, msg.sender, ba);\n\n\n        if (t != 0) {\n            cw.dh(-int128(t), bq, bs, true);\n        }\n\n        cl[msg.sender].ct(cq);\n        b.u(address(this), msg.sender, cq);\n\n        emit Withdraw(msg.sender, cq);\n    }\n\n    function bn(uint256 cq, address co,uint8 ba ) public ap s {\n\n        require(cl[co].bz(cq), \"NA\");\n\n        (,,,,, int24 bq, int24 bs,,,,,) = b.bm(cq);\n        bf(bq, bs, cq, co, ba);\n    }\n\n    function bf(int24 bq, int24 bs, uint256 cq,address co, uint8 ba) internal {\n        ad(cq, bq, bs);\n        uint256 ao = ck[cq];\n        if(ao > 0){\n            delete ck[cq];\n            ax.aw(df, ao);\n            IRHYBR(df).e(ao);\n            IRHYBR(df).bj(ao, ba, co);\n        }\n        emit Harvest(msg.sender, ao);\n    }\n\n    function k(address dd, uint256 ao) external ap\n        ag s returns (uint256 au) {\n        require(dd == address(ax), \"Invalid reward token\");\n\n\n        cw.c();\n\n\n        uint256 j = HybraTimeLibrary.bk(block.timestamp) - block.timestamp;\n        uint256 o = block.timestamp + j;\n\n\n        uint256 p = ao + cw.ca();\n\n\n        if (block.timestamp >= aj) {\n\n            bb = ao / j;\n            cw.be({\n                bb: bb,\n                al: p,\n                aq: o\n            });\n        } else {\n\n            uint256 af = j * bb;\n            bb = (ao + af) / j;\n            cw.be({\n                bb: bb,\n                al: p + af,\n                aq: o\n            });\n        }\n\n\n        q[HybraTimeLibrary.bh(block.timestamp)] = bb;\n\n\n        ax.u(DISTRIBUTION, address(this), ao);\n\n\n        uint256 w = ax.br(address(this));\n        require(bb <= w / j, \"Insufficient balance for reward rate\");\n\n\n        aj = o;\n        au = bb;\n\n        emit RewardAdded(ao);\n    }\n\n    function ah() external view returns (uint256 da, uint256 cs){\n\n        (da, cs) = cw.bo();\n\n    }\n\n    function bx() external ap returns (uint256 cc, uint256 ce) {\n        return bg();\n    }\n\n    function bg() internal returns (uint256 cc, uint256 ce) {\n        if (!bt) {\n            return (0, 0);\n        }\n\n        cw.as();\n\n        address ch = cw.da();\n        address cg = cw.cs();\n\n        cc = IERC20(ch).br(address(this));\n        ce = IERC20(cg).br(address(this));\n\n        if (cc > 0 || ce > 0) {\n\n            uint256 cz = cc;\n            uint256 cv = ce;\n\n            if (cz  > 0) {\n                IERC20(ch).aw(ab, 0);\n                IERC20(ch).aw(ab, cz);\n                IBribe(ab).k(ch, cz);\n            }\n            if (cv  > 0) {\n                IERC20(cg).aw(ab, 0);\n                IERC20(cg).aw(ab, cv);\n                IBribe(ab).k(cg, cv);\n            }\n            emit ClaimFees(msg.sender, cc, ce);\n        }\n    }\n\n\n    function n() external view returns (uint256) {\n        return bb * DURATION;\n    }\n\n\n    function r(address di) external bp {\n        require(di >= address(0), \"zero\");\n        ab = di;\n    }\n\n    function ai(address dd,address do,uint256 value) internal {\n        require(dd.code.length > 0);\n        (bool ci, bytes memory data) = dd.call(abi.i(IERC20.transfer.selector, do, value));\n        require(ci && (data.length == 0 || abi.cu(data, (bool))));\n    }\n\n\n    function v(\n        address cd,\n        address from,\n        uint256 cq,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.v.selector;\n    }\n\n}",
      "rename_map": {
        "rewardPerTokenInsideInitialX128": "a",
        "nonfungiblePositionManager": "b",
        "updateRewardsGrowthGlobal": "c",
        "rewardPerTokenInsideX128": "d",
        "depostionEmissionsToken": "e",
        "rewardGrowthGlobalX128": "f",
        "getRewardGrowthInside": "g",
        "activateEmergencyMode": "h",
        "encodeWithSelector": "i",
        "epochTimeRemaining": "j",
        "notifyRewardAmount": "k",
        "rewardGrowthInside": "l",
        "stopEmergencyMode": "m",
        "rewardForDuration": "n",
        "epochEndTimestamp": "o",
        "totalRewardAmount": "p",
        "rewardRateByEpoch": "q",
        "setInternalBribe": "r",
        "onlyDistribution": "s",
        "liquidityToStake": "t",
        "safeTransferFrom": "u",
        "onERC721Received": "v",
        "contractBalance": "w",
        "_internal_bribe": "x",
        "_external_bribe": "y",
        "stakedLiquidity": "z",
        "_getPoolAddress": "aa",
        "internal_bribe": "ab",
        "external_bribe": "ac",
        "_updateRewards": "ad",
        "lastUpdateTime": "ae",
        "pendingRewards": "af",
        "isNotEmergency": "ag",
        "gaugeBalances": "ah",
        "_safeTransfer": "ai",
        "_periodFinish": "aj",
        "_distribution": "ak",
        "rewardReserve": "al",
        "positionPool": "am",
        "rewardGrowth": "an",
        "rewardAmount": "ao",
        "nonReentrant": "ap",
        "periodFinish": "aq",
        "_rewardToken": "ar",
        "collectFees": "as",
        "lastUpdated": "at",
        "currentRate": "au",
        "tickSpacing": "av",
        "safeApprove": "aw",
        "rewardToken": "ax",
        "poolAddress": "ay",
        "amount1Max": "az",
        "redeemType": "ba",
        "rewardRate": "bb",
        "_isForPair": "bc",
        "amount0Max": "bd",
        "syncReward": "be",
        "_getReward": "bf",
        "_claimFees": "bg",
        "epochStart": "bh",
        "recipient": "bi",
        "redeemFor": "bj",
        "epochNext": "bk",
        "timeDelta": "bl",
        "positions": "bm",
        "getReward": "bn",
        "gaugeFees": "bo",
        "onlyOwner": "bp",
        "tickLower": "bq",
        "balanceOf": "br",
        "tickUpper": "bs",
        "isForPair": "bt",
        "emergency": "bu",
        "claimable": "bv",
        "liquidity": "bw",
        "claimFees": "bx",
        "_factory": "by",
        "contains": "bz",
        "rollover": "ca",
        "withdraw": "cb",
        "claimed0": "cc",
        "operator": "cd",
        "claimed1": "ce",
        "collect": "cf",
        "_token1": "cg",
        "_token0": "ch",
        "success": "ci",
        "factory": "cj",
        "rewards": "ck",
        "_stakes": "cl",
        "getPool": "cm",
        "deposit": "cn",
        "account": "co",
        "_earned": "cp",
        "tokenId": "cq",
        "_rHYBR": "cr",
        "token1": "cs",
        "remove": "ct",
        "decode": "cu",
        "_fees1": "cv",
        "clPool": "cw",
        "amount": "cx",
        "reward": "cy",
        "_fees0": "cz",
        "token0": "da",
        "mulDiv": "db",
        "earned": "dc",
        "token": "dd",
        "gauge": "de",
        "rHYBR": "df",
        "_pool": "dg",
        "stake": "dh",
        "_int": "di",
        "user": "dj",
        "nfpm": "dk",
        "max": "dl",
        "add": "dm",
        "_ve": "dn",
        "to": "do"
      },
      "changes": [
        "Renamed 119 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_008",
      "transformed_id": "ss_l2_short_nc_gs_008",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public k = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public d = 1200;\n    uint256 public c = 300;\n\n\n    uint256 public bg = 100;\n    uint256 public constant MIN_WITHDRAW_FEE = 10;\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant BASIS = 10000;\n    address public Team;\n    uint256 public dq;\n    uint256 public dg;\n    uint256 public bm;\n\n    struct UserLock {\n        uint256 dv;\n        uint256 cd;\n    }\n\n    mapping(address => UserLock[]) public cq;\n    mapping(address => uint256) public ak;\n\n\n    address public immutable HYBR;\n    address public immutable aw;\n    address public ed;\n    address public l;\n    address public au;\n    uint256 public cr;\n\n\n    address public db;\n    uint256 public an;\n\n\n    uint256 public ad;\n    uint256 public s;\n\n\n    ISwapper public de;\n\n\n    error NOT_AUTHORIZED();\n\n\n    event Deposit(address indexed em, uint256 cb, uint256 af);\n    event Withdraw(address indexed em, uint256 dt, uint256 cb, uint256 er);\n    event Compound(uint256 dj, uint256 ag);\n    event PenaltyRewardReceived(uint256 dv);\n    event TransferLockPeriodUpdated(uint256 ci, uint256 ct);\n    event SwapperUpdated(address indexed bv, address indexed bz);\n    event VoterSet(address ed);\n    event EmergencyUnlock(address indexed em);\n    event AutoVotingEnabled(bool do);\n    event OperatorUpdated(address indexed bs, address indexed br);\n    event DefaultVotingStrategyUpdated(address[] dy, uint256[] dl);\n    event AutoVoteExecuted(uint256 ei, address[] dy, uint256[] dl);\n\n    constructor(\n        address el,\n        address am\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(el != address(0), \"Invalid HYBR\");\n        require(am != address(0), \"Invalid VE\");\n\n        HYBR = el;\n        aw = am;\n        ad = block.timestamp;\n        s = block.timestamp;\n        db = msg.sender;\n    }\n\n    function e(address j) external cn {\n        require(j != address(0), \"Invalid rewards distributor\");\n        l = j;\n    }\n\n    function u(address ar) external cn {\n        require(ar != address(0), \"Invalid gauge manager\");\n        au = ar;\n    }\n\n\n    modifier at() {\n        if (msg.sender != db) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n\n    function dk(uint256 dv, address cj) external ay {\n        require(dv > 0, \"Zero amount\");\n        cj = cj == address(0) ? msg.sender : cj;\n\n\n        IERC20(HYBR).ba(msg.sender, address(this), dv);\n\n\n        if (cr == 0) {\n            n(dv);\n        } else {\n\n            IERC20(HYBR).df(aw, dv);\n            IVotingEscrow(aw).bf(cr, dv);\n\n\n            q();\n        }\n\n\n        uint256 dt = ab(dv);\n\n\n        ek(cj, dt);\n\n\n        p(cj, dt);\n\n        emit Deposit(msg.sender, dv, dt);\n    }\n\n\n    function cy(uint256 dt) external ay returns (uint256 bi) {\n        require(dt > 0, \"Zero shares\");\n        require(cp(msg.sender) >= dt, \"Insufficient balance\");\n        require(cr != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(aw).ef(cr) == false, \"Cannot withdraw yet\");\n\n        uint256 ce = HybraTimeLibrary.ce(block.timestamp);\n        uint256 cm = HybraTimeLibrary.cm(block.timestamp);\n\n        require(block.timestamp >= ce + d && block.timestamp < cm - c, \"Cannot withdraw yet\");\n\n\n        uint256 cb = y(dt);\n        require(cb > 0, \"No assets to withdraw\");\n\n\n        uint256 co = 0;\n        if (bg > 0) {\n            co = (cb * bg) / BASIS;\n        }\n\n\n        uint256 cg = cb - co;\n        require(cg > 0, \"Amount too small after fee\");\n\n\n        uint256 ch = bp();\n        require(cb <= ch, \"Insufficient veNFT balance\");\n\n        uint256 aa = ch - cg - co;\n        require(aa >= 0, \"Cannot withdraw entire veNFT\");\n\n\n        ej(msg.sender, dt);\n\n\n        uint256[] memory dh = new uint256[](3);\n        dh[0] = aa;\n        dh[1] = cg;\n        dh[2] = co;\n\n        uint256[] memory bj = IVotingEscrow(aw).bx(cr, dh);\n\n\n        cr = bj[0];\n        bi = bj[1];\n        uint256 cf = bj[2];\n\n        IVotingEscrow(aw).t(address(this), msg.sender, bi);\n        IVotingEscrow(aw).t(address(this), Team, cf);\n        emit Withdraw(msg.sender, dt, cg, co);\n    }\n\n\n    function n(uint256 aq) internal {\n\n        IERC20(HYBR).df(aw, type(uint256).eq);\n        uint256 da = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n\n        cr = IVotingEscrow(aw).v(aq, da, address(this));\n\n    }\n\n\n    function ab(uint256 dv) public view returns (uint256) {\n        uint256 ax = bo();\n        uint256 as = bp();\n        if (ax == 0 || as == 0) {\n            return dv;\n        }\n        return (dv * ax) / as;\n    }\n\n\n    function y(uint256 dt) public view returns (uint256) {\n        uint256 ax = bo();\n        if (ax == 0) {\n            return dt;\n        }\n        return (dt * bp()) / ax;\n    }\n\n\n    function bp() public view returns (uint256) {\n        if (cr == 0) {\n            return 0;\n        }\n\n        IVotingEscrow.LockedBalance memory du = IVotingEscrow(aw).du(cr);\n        return uint256(int256(du.dv));\n    }\n\n\n    function p(address em, uint256 dv) internal {\n        uint256 cd = block.timestamp + k;\n        cq[em].push(UserLock({\n            dv: dv,\n            cd: cd\n        }));\n        ak[em] += dv;\n    }\n\n\n    function r(address em) external view returns (uint256 ck) {\n        uint256 av = cp(em);\n        uint256 ao = 0;\n\n        UserLock[] storage es = cq[em];\n        for (uint256 i = 0; i < es.length; i++) {\n            if (es[i].cd > block.timestamp) {\n                ao += es[i].dv;\n            }\n        }\n\n        return av > ao ? av - ao : 0;\n    }\n\n    function ap(address em) internal returns (uint256 ec) {\n        UserLock[] storage es = cq[em];\n        uint256 ep = es.length;\n        if (ep == 0) return 0;\n\n        uint256 eb = 0;\n        unchecked {\n            for (uint256 i = 0; i < ep; i++) {\n                UserLock memory L = es[i];\n                if (L.cd <= block.timestamp) {\n                    ec += L.dv;\n                } else {\n                    if (eb != i) es[eb] = L;\n                    eb++;\n                }\n            }\n            if (ec > 0) {\n                ak[em] -= ec;\n            }\n            while (es.length > eb) {\n                es.pop();\n            }\n        }\n    }\n\n\n    function i(\n        address from,\n        address eu,\n        uint256 dv\n    ) internal override {\n        super.i(from, eu, dv);\n\n        if (from != address(0) && eu != address(0)) {\n            uint256 av = cp(from);\n\n\n            uint256 o = av > ak[from] ? av - ak[from] : 0;\n\n\n            if (o >= dv) {\n                return;\n            }\n\n\n            ap(from);\n            uint256 ac = av > ak[from] ? av - ak[from] : 0;\n\n\n            require(ac >= dv, \"Tokens locked\");\n        }\n    }\n\n\n    function bd() external at {\n        require(ed != address(0), \"Voter not set\");\n        require(l != address(0), \"Distributor not set\");\n\n\n        uint256  bc = IRewardsDistributor(l).ea(cr);\n        dq += bc;\n\n        address[] memory ca = IVoter(ed).cz(cr);\n\n        for (uint256 i = 0; i < ca.length; i++) {\n            if (ca[i] != address(0)) {\n                address ee = IGaugeManager(au).dp(ca[i]);\n\n                if (ee != address(0)) {\n\n                    address[] memory dr = new address[](1);\n                    address[][] memory ds = new address[][](1);\n\n\n                    address al = IGaugeManager(au).z(ee);\n                    if (al != address(0)) {\n                        uint256 bw = IBribe(al).m();\n                        if (bw > 0) {\n                            address[] memory bt = new address[](bw);\n                            for (uint256 j = 0; j < bw; j++) {\n                                bt[j] = IBribe(al).bt(j);\n                            }\n                            dr[0] = al;\n                            ds[0] = bt;\n\n                            IGaugeManager(au).bq(dr, ds, cr);\n                        }\n                    }\n\n\n                    address aj = IGaugeManager(au).w(ee);\n                    if (aj != address(0)) {\n                        uint256 bw = IBribe(aj).m();\n                        if (bw > 0) {\n                            address[] memory bt = new address[](bw);\n                            for (uint256 j = 0; j < bw; j++) {\n                                bt[j] = IBribe(aj).bt(j);\n                            }\n                            dr[0] = aj;\n                            ds[0] = bt;\n\n                            IGaugeManager(au).bq(dr, ds, cr);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    function bh(ISwapper.SwapParams calldata dn) external ay at {\n        require(address(de) != address(0), \"Swapper not set\");\n\n\n        uint256 bb = IERC20(dn.dm).cp(address(this));\n        require(bb >= dn.cw, \"Insufficient token balance\");\n\n\n        IERC20(dn.dm).bl(address(de), dn.cw);\n\n\n        uint256 be = de.by(dn);\n\n\n        IERC20(dn.dm).bl(address(de), 0);\n\n\n        bm += be;\n    }\n\n\n    function dc() external at {\n\n\n        uint256 bu = IERC20(HYBR).cp(address(this));\n\n        if (bu > 0) {\n\n            IERC20(HYBR).bl(aw, bu);\n            IVotingEscrow(aw).bf(cr, bu);\n\n\n            q();\n\n            s = block.timestamp;\n\n            emit Compound(bu, bp());\n        }\n    }\n\n\n    function en(address[] calldata cs, uint256[] calldata cu) external {\n        require(msg.sender == dx() || msg.sender == db, \"Not authorized\");\n        require(ed != address(0), \"Voter not set\");\n\n        IVoter(ed).en(cr, cs, cu);\n        an = HybraTimeLibrary.ce(block.timestamp);\n\n    }\n\n\n    function dz() external {\n        require(msg.sender == dx() || msg.sender == db, \"Not authorized\");\n        require(ed != address(0), \"Voter not set\");\n\n        IVoter(ed).dz(cr);\n    }\n\n\n    function g(uint256 dv) external {\n\n\n        if (dv > 0) {\n            IERC20(HYBR).df(aw, dv);\n\n            if(cr == 0){\n                n(dv);\n            } else{\n                IVotingEscrow(aw).bf(cr, dv);\n\n\n                q();\n            }\n        }\n        dg += dv;\n        emit PenaltyRewardReceived(dv);\n    }\n\n\n    function cv(address dw) external cn {\n        require(dw != address(0), \"Invalid voter\");\n        ed = dw;\n        emit VoterSet(dw);\n    }\n\n\n    function f(uint256 dd) external cn {\n        require(dd >= MIN_LOCK_PERIOD && dd <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 ci = k;\n        k = dd;\n        emit TransferLockPeriodUpdated(ci, dd);\n    }\n\n\n    function ae(uint256 eo) external cn {\n        require(eo >= MIN_WITHDRAW_FEE && eo <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        bg = eo;\n    }\n\n    function b(uint256 eh) external cn {\n        d = eh;\n    }\n\n    function a(uint256 eh) external cn {\n        c = eh;\n    }\n\n\n    function cc(address cx) external cn {\n        require(cx != address(0), \"Invalid swapper\");\n        address bv = address(de);\n        de = ISwapper(cx);\n        emit SwapperUpdated(bv, cx);\n    }\n\n\n    function di(address eg) external cn {\n        require(eg != address(0), \"Invalid team\");\n        Team = eg;\n    }\n\n\n    function x(address em) external at {\n        delete cq[em];\n        ak[em] = 0;\n        emit EmergencyUnlock(em);\n    }\n\n\n    function az(address em) external view returns (UserLock[] memory) {\n        return cq[em];\n    }\n\n\n    function bk(address cl) external cn {\n        require(cl != address(0), \"Invalid operator\");\n        address bs = db;\n        db = cl;\n        emit OperatorUpdated(bs, cl);\n    }\n\n\n    function ah() external view returns (uint256) {\n        if (cr == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory du = IVotingEscrow(aw).du(cr);\n        return uint256(du.et);\n    }\n\n\n    function q() internal {\n        if (cr == 0) return;\n\n        IVotingEscrow.LockedBalance memory du = IVotingEscrow(aw).du(cr);\n        if (du.bn || du.et <= block.timestamp) return;\n\n        uint256 ai = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n\n        if (ai > du.et + 2 hours) {\n            try IVotingEscrow(aw).h(cr, HybraTimeLibrary.MAX_LOCK_DURATION) {\n\n            } catch {\n\n\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setTailNotWithdrawTime": "a",
        "setHeadNotWithdrawTime": "b",
        "tail_not_withdraw_time": "c",
        "head_not_withdraw_time": "d",
        "setRewardsDistributor": "e",
        "setTransferLockPeriod": "f",
        "receivePenaltyReward": "g",
        "increase_unlock_time": "h",
        "_beforeTokenTransfer": "i",
        "_rewardsDistributor": "j",
        "transferLockPeriod": "k",
        "rewardsDistributor": "l",
        "rewardsListLength": "m",
        "_initializeVeNFT": "n",
        "currentAvailable": "o",
        "_addTransferLock": "p",
        "_extendLockToMax": "q",
        "previewAvailable": "r",
        "lastCompoundTime": "s",
        "safeTransferFrom": "t",
        "setGaugeManager": "u",
        "create_lock_for": "v",
        "external_bribes": "w",
        "emergencyUnlock": "x",
        "calculateAssets": "y",
        "internal_bribes": "z",
        "remainingAmount": "aa",
        "calculateShares": "ab",
        "finalAvailable": "ac",
        "lastRebaseTime": "ad",
        "setWithdrawFee": "ae",
        "sharesReceived": "af",
        "newTotalLocked": "ag",
        "getLockEndTime": "ah",
        "maxUnlockTime": "ai",
        "externalBribe": "aj",
        "lockedBalance": "ak",
        "internalBribe": "al",
        "_votingEscrow": "am",
        "lastVoteEpoch": "an",
        "currentLocked": "ao",
        "_cleanExpired": "ap",
        "initialAmount": "aq",
        "_gaugeManager": "ar",
        "_totalAssets": "as",
        "onlyOperator": "at",
        "gaugeManager": "au",
        "totalBalance": "av",
        "votingEscrow": "aw",
        "_totalSupply": "ax",
        "nonReentrant": "ay",
        "getUserLocks": "az",
        "transferFrom": "ba",
        "tokenBalance": "bb",
        "rebaseAmount": "bc",
        "claimRewards": "bd",
        "hybrReceived": "be",
        "deposit_for": "bf",
        "withdrawFee": "bg",
        "executeSwap": "bh",
        "userTokenId": "bi",
        "newTokenIds": "bj",
        "setOperator": "bk",
        "safeApprove": "bl",
        "votingYield": "bm",
        "isPermanent": "bn",
        "totalSupply": "bo",
        "totalAssets": "bp",
        "claimBribes": "bq",
        "newOperator": "br",
        "oldOperator": "bs",
        "bribeTokens": "bt",
        "hybrBalance": "bu",
        "oldSwapper": "bv",
        "tokenCount": "bw",
        "multiSplit": "bx",
        "swapToHYBR": "by",
        "newSwapper": "bz",
        "votedPools": "ca",
        "hybrAmount": "cb",
        "setSwapper": "cc",
        "unlockTime": "cd",
        "epochStart": "ce",
        "feeTokenId": "cf",
        "userAmount": "cg",
        "veBalance": "ch",
        "oldPeriod": "ci",
        "recipient": "cj",
        "available": "ck",
        "_operator": "cl",
        "epochNext": "cm",
        "onlyOwner": "cn",
        "feeAmount": "co",
        "balanceOf": "cp",
        "userLocks": "cq",
        "veTokenId": "cr",
        "_poolVote": "cs",
        "newPeriod": "ct",
        "_weights": "cu",
        "setVoter": "cv",
        "amountIn": "cw",
        "_swapper": "cx",
        "withdraw": "cy",
        "poolVote": "cz",
        "lockTime": "da",
        "operator": "db",
        "compound": "dc",
        "_period": "dd",
        "swapper": "de",
        "approve": "df",
        "penalty": "dg",
        "amounts": "dh",
        "setTeam": "di",
        "rewards": "dj",
        "deposit": "dk",
        "weights": "dl",
        "tokenIn": "dm",
        "_params": "dn",
        "enabled": "do",
        "gauges": "dp",
        "rebase": "dq",
        "bribes": "dr",
        "tokens": "ds",
        "shares": "dt",
        "locked": "du",
        "amount": "dv",
        "_voter": "dw",
        "owner": "dx",
        "pools": "dy",
        "reset": "dz",
        "claim": "ea",
        "write": "eb",
        "freed": "ec",
        "voter": "ed",
        "gauge": "ee",
        "voted": "ef",
        "_team": "eg",
        "_time": "eh",
        "epoch": "ei",
        "_burn": "ej",
        "_mint": "ek",
        "_HYBR": "el",
        "user": "em",
        "vote": "en",
        "_fee": "eo",
        "len": "ep",
        "max": "eq",
        "fee": "er",
        "arr": "es",
        "end": "et",
        "to": "eu"
      },
      "changes": [
        "Renamed 151 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_009",
      "transformed_id": "ss_l2_short_nc_gs_009",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport {IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IHybra.sol\";\nimport {IHybraVotes} from \"./interfaces/IHybraVotes.sol\";\nimport {IVeArtProxy} from \"./interfaces/IVeArtProxy.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport {VotingDelegationLib} from \"./libraries/VotingDelegationLib.sol\";\nimport {VotingBalanceLogic} from \"./libraries/VotingBalanceLogic.sol\";\n\n\ncontract VotingEscrow is IERC721, IERC721Metadata, IHybraVotes {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n\n    event Deposit(\n        address indexed eo,\n        uint fo,\n        uint value,\n        uint indexed fb,\n        DepositType br,\n        uint hs\n    );\n\n    event Merge(\n        address indexed fn,\n        uint256 indexed hc,\n        uint256 indexed hk,\n        uint256 cp,\n        uint256 ef,\n        uint256 cd,\n        uint256 du,\n        uint256 hq\n    );\n    event Split(\n        uint256 indexed hc,\n        uint256 indexed ea,\n        uint256 indexed ed,\n        address fn,\n        uint256 bm,\n        uint256 bf,\n        uint256 du,\n        uint256 hq\n    );\n\n    event MultiSplit(\n        uint256 indexed hc,\n        uint256[] bt,\n        address fn,\n        uint256[] ey,\n        uint256 du,\n        uint256 hq\n    );\n\n    event MetadataUpdate(uint256 fa);\n    event BatchMetadataUpdate(uint256 cc, uint256 cz);\n\n    event Withdraw(address indexed eo, uint fo, uint value, uint hs);\n    event LockPermanent(address indexed gd, uint256 indexed fa, uint256 gf, uint256 hq);\n    event UnlockPermanent(address indexed gd, uint256 indexed fa, uint256 gf, uint256 hq);\n    event Supply(uint dm, uint ga);\n\n\n    address public immutable gn;\n    address public gv;\n    address public hf;\n    address public eq;\n\n\n    uint public PRECISISON = 10000;\n\n\n    mapping(bytes4 => bool) internal l;\n    mapping(uint => bool) internal as;\n\n\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n\n    uint internal fo;\n\n    uint internal WEEK;\n\n    uint internal MAXTIME;\n    int128 internal ej;\n    IHybra public gy;\n\n\n    VotingDelegationLib.Data private gi;\n\n    VotingBalanceLogic.Data private d;\n\n\n    constructor(address dj, address eb) {\n        gn = dj;\n        gv = msg.sender;\n        hf = msg.sender;\n        eq = eb;\n        WEEK = HybraTimeLibrary.WEEK;\n        MAXTIME = HybraTimeLibrary.MAX_LOCK_DURATION;\n        ej = int128(int256(HybraTimeLibrary.MAX_LOCK_DURATION));\n\n        d.az[0].hn = block.number;\n        d.az[0].hs = block.timestamp;\n\n        l[ERC165_INTERFACE_ID] = true;\n        l[ERC721_INTERFACE_ID] = true;\n        l[ERC721_METADATA_INTERFACE_ID] = true;\n        gy = IHybra(gn);\n\n\n        emit Transfer(address(0), address(this), fo);\n\n        emit Transfer(address(this), address(0), fo);\n    }\n\n\n    uint8 internal constant bp = 1;\n    uint8 internal constant el = 2;\n    uint8 internal ar = 1;\n    modifier ca() {\n        require(ar == bp);\n        ar = el;\n        _;\n        ar = bp;\n    }\n\n    modifier bh(uint256 fa) {\n        require(!as[fa], \"PNFT\");\n        _;\n    }\n\n    modifier bx(uint hc) {\n        require(fd[msg.sender] || fd[address(0)], \"!SPLIT\");\n        require(cf[hc] == 0 && !gw[hc], \"ATT\");\n        require(r(msg.sender, hc), \"NAO\");\n        _;\n    }\n\n\n    string constant public he = \"veHYBR\";\n    string constant public fx = \"veHYBR\";\n    string constant public ff = \"1.0.0\";\n    uint8 constant public ex = 18;\n\n    function fj(address gx) external {\n        require(msg.sender == hf);\n        hf = gx;\n    }\n\n    function cg(address fy) external {\n        require(msg.sender == hf);\n        eq = fy;\n        emit BatchMetadataUpdate(0, type(uint256).hl);\n    }\n\n\n    function al(uint fa, bool dd) external {\n        require(msg.sender == hf, \"NA\");\n        require(dw[fa] != address(0), \"DNE\");\n        as[fa] = dd;\n    }\n\n\n    function et(uint fa) external view returns (string memory) {\n        require(dw[fa] != address(0), \"DNE\");\n        IVotingEscrow.LockedBalance memory fk = ge[fa];\n\n        return IVeArtProxy(eq).do(fa,VotingBalanceLogic.bu(fa, block.timestamp, d),fk.hp,uint(int256(fk.gf)));\n    }\n\n\n    mapping(uint => address) internal dw;\n\n\n    mapping(address => uint) internal k;\n\n\n    function fe(uint fa) public view returns (address) {\n        return dw[fa];\n    }\n\n    function e(address gm) public view returns (uint) {\n\n        return k[gm];\n    }\n\n\n    function ek(address gd) internal view returns (uint) {\n        return k[gd];\n    }\n\n\n    function ec(address gd) external view returns (uint) {\n        return ek(gd);\n    }\n\n\n    mapping(uint => address) internal bd;\n\n\n    mapping(address => mapping(address => bool)) internal ac;\n\n    mapping(uint => uint) public z;\n\n\n    function ch(uint fa) external view returns (address) {\n        return bd[fa];\n    }\n\n\n    function ad(address gd, address dq) external view returns (bool) {\n        return (ac[gd])[dq];\n    }\n\n\n    function fg(address ei, uint fa) public {\n        address gm = dw[fa];\n\n        require(gm != address(0), \"ZA\");\n\n        require(ei != gm, \"IA\");\n\n        bool bg = (dw[fa] == msg.sender);\n        bool c = (ac[gm])[msg.sender];\n        require(bg || c, \"NAO\");\n\n        bd[fa] = ei;\n        emit Approval(gm, ei, fa);\n    }\n\n\n    function x(address dq, bool ei) external {\n\n        assert(dq != msg.sender);\n        ac[msg.sender][dq] = ei;\n        emit ApprovalForAll(msg.sender, dq, ei);\n    }\n\n\n    function av(address gd, uint fa) internal {\n\n        assert(dw[fa] == gd);\n        if (bd[fa] != address(0)) {\n\n            bd[fa] = address(0);\n        }\n    }\n\n\n    function r(address ew, uint fa) internal view returns (bool) {\n        address gm = dw[fa];\n        bool ay = gm == ew;\n        bool w = ew == bd[fa];\n        bool b = (ac[gm])[ew];\n        return ay || w || b;\n    }\n\n    function v(address ew, uint fa) external view returns (bool) {\n        return r(ew, fa);\n    }\n\n\n    function bb(\n        address hc,\n        address hk,\n        uint fa,\n        address fn\n    ) internal bh(fa) {\n        require(cf[fa] == 0 && !gw[fa], \"ATT\");\n\n        require(r(fn, fa), \"NAO\");\n\n\n        av(hc, fa);\n\n        ab(hc, fa);\n\n        VotingDelegationLib.n(gi, dy(hc), dy(hk), fa, fe);\n\n        cw(hk, fa);\n\n        z[fa] = block.number;\n\n\n        emit Transfer(hc, hk, fa);\n    }\n\n\n    function by(\n        address hc,\n        address hk,\n        uint fa\n    ) external {\n        bb(hc, hk, fa, msg.sender);\n    }\n\n\n    function ae(\n        address hc,\n        address hk,\n        uint fa\n    ) external {\n        ae(hc, hk, fa, \"\");\n    }\n\n    function cv(address fm) internal view returns (bool) {\n\n\n        uint hj;\n        assembly {\n            hj := extcodesize(fm)\n        }\n        return hj > 0;\n    }\n\n\n    function ae(\n        address hc,\n        address hk,\n        uint fa,\n        bytes memory gt\n    ) public {\n        bb(hc, hk, fa, msg.sender);\n\n        if (cv(hk)) {\n\n            try IERC721Receiver(hk).af(msg.sender, hc, fa, gt) returns (bytes4 en) {\n                if (en != IERC721Receiver(hk).af.selector) {\n                    revert(\"E721_RJ\");\n                }\n            } catch (bytes memory fw) {\n                if (fw.length == 0) {\n                    revert('E721_NRCV');\n                } else {\n                    assembly {\n                        revert(add(32, fw), mload(fw))\n                    }\n                }\n            }\n        }\n    }\n\n\n    function u(bytes4 bq) external view returns (bool) {\n        return l[bq];\n    }\n\n\n    mapping(address => mapping(uint => uint)) internal h;\n\n\n    mapping(uint => uint) internal t;\n\n\n    function m(address gd, uint ce) public view returns (uint) {\n        return h[gd][ce];\n    }\n\n\n    function i(address hk, uint fa) internal {\n        uint be = ek(hk);\n\n        h[hk][be] = fa;\n        t[fa] = be;\n    }\n\n\n    function cw(address hk, uint fa) internal {\n\n        assert(dw[fa] == address(0));\n\n        dw[fa] = hk;\n\n        i(hk, fa);\n\n        k[hk] += 1;\n    }\n\n\n    function hb(address hk, uint fa) internal returns (bool) {\n\n        assert(hk != address(0));\n\n        VotingDelegationLib.n(gi, address(0), dy(hk), fa, fe);\n\n        cw(hk, fa);\n        emit Transfer(address(0), hk, fa);\n        return true;\n    }\n\n\n    function a(address hc, uint fa) internal {\n\n        uint be = ek(hc) - 1;\n        uint bn = t[fa];\n\n        if (be == bn) {\n\n            h[hc][be] = 0;\n\n            t[fa] = 0;\n        } else {\n            uint cx = h[hc][be];\n\n\n            h[hc][bn] = cx;\n\n            t[cx] = bn;\n\n\n            h[hc][be] = 0;\n\n            t[fa] = 0;\n        }\n    }\n\n\n    function ab(address hc, uint fa) internal {\n\n        assert(dw[fa] == hc);\n\n        dw[fa] = address(0);\n\n        a(hc, fa);\n\n        k[hc] -= 1;\n    }\n\n    function ha(uint fa) internal {\n        require(r(msg.sender, fa), \"NAO\");\n\n        address gm = fe(fa);\n\n\n        delete bd[fa];\n\n\n        ab(gm, fa);\n\n        VotingDelegationLib.n(gi, dy(gm), address(0), fa, fe);\n\n        emit Transfer(gm, address(0), fa);\n    }\n\n\n    mapping(uint => IVotingEscrow.LockedBalance) public ge;\n    uint public f;\n    uint public gz;\n    mapping(uint => int128) public ba;\n    uint public ga;\n    mapping(address => bool) public fd;\n\n    uint internal constant MULTIPLIER = 1 ether;\n\n\n    function j(uint fa) external view returns (int128) {\n        uint gb = d.aa[fa];\n        return d.q[fa][gb].gu;\n    }\n\n\n    function q(uint fa, uint hg) external view returns (IVotingEscrow.Point memory) {\n        return d.q[fa][hg];\n    }\n\n    function az(uint gz) external view returns (IVotingEscrow.Point memory) {\n        return d.az[gz];\n    }\n\n    function aa(uint fo) external view returns (uint) {\n        return d.aa[fo];\n    }\n\n\n    function ck(\n        uint fa,\n        IVotingEscrow.LockedBalance memory dc,\n        IVotingEscrow.LockedBalance memory db\n    ) internal {\n        IVotingEscrow.Point memory gp;\n        IVotingEscrow.Point memory hd;\n        int128 dn = 0;\n        int128 di = 0;\n        uint ft = gz;\n\n        if (fa != 0) {\n            hd.dz = 0;\n\n            if(db.cq){\n                hd.dz = uint(int256(db.gf));\n            }\n\n\n            if (dc.hp > block.timestamp && dc.gf > 0) {\n                gp.gu = dc.gf / ej;\n                gp.hh = gp.gu * int128(int256(dc.hp - block.timestamp));\n            }\n            if (db.hp > block.timestamp && db.gf > 0) {\n                hd.gu = db.gf / ej;\n                hd.hh = hd.gu * int128(int256(db.hp - block.timestamp));\n            }\n\n\n            dn = ba[dc.hp];\n            if (db.hp != 0) {\n                if (db.hp == dc.hp) {\n                    di = dn;\n                } else {\n                    di = ba[db.hp];\n                }\n            }\n        }\n\n        IVotingEscrow.Point memory da = IVotingEscrow.Point({hh: 0, gu: 0, hs: block.timestamp, hn: block.number, dz: 0});\n        if (ft > 0) {\n            da = d.az[ft];\n        }\n        uint aj = da.hs;\n\n\n        IVotingEscrow.Point memory p = da;\n        uint ct = 0;\n        if (block.timestamp > da.hs) {\n            ct = (MULTIPLIER * (block.number - da.hn)) / (block.timestamp - da.hs);\n        }\n\n\n        {\n            uint hm = (aj / WEEK) * WEEK;\n            for (uint i = 0; i < 255; ++i) {\n\n\n                hm += WEEK;\n                int128 fp = 0;\n                if (hm > block.timestamp) {\n                    hm = block.timestamp;\n                } else {\n                    fp = ba[hm];\n                }\n                da.hh -= da.gu * int128(int256(hm - aj));\n                da.gu += fp;\n                if (da.hh < 0) {\n\n                    da.hh = 0;\n                }\n                if (da.gu < 0) {\n\n                    da.gu = 0;\n                }\n                aj = hm;\n                da.hs = hm;\n                da.hn = p.hn + (ct * (hm - p.hs)) / MULTIPLIER;\n                ft += 1;\n                if (hm == block.timestamp) {\n                    da.hn = block.number;\n                    break;\n                } else {\n                    d.az[ft] = da;\n                }\n            }\n        }\n\n        gz = ft;\n\n\n        if (fa != 0) {\n\n\n            da.gu += (hd.gu - gp.gu);\n            da.hh += (hd.hh - gp.hh);\n            if (da.gu < 0) {\n                da.gu = 0;\n            }\n            if (da.hh < 0) {\n                da.hh = 0;\n            }\n            da.dz = f;\n        }\n\n\n        d.az[ft] = da;\n\n        if (fa != 0) {\n\n\n            if (dc.hp > block.timestamp) {\n\n                dn += gp.gu;\n                if (db.hp == dc.hp) {\n                    dn -= hd.gu;\n                }\n                ba[dc.hp] = dn;\n            }\n\n            if (db.hp > block.timestamp) {\n                if (db.hp > dc.hp) {\n                    di -= hd.gu;\n                    ba[db.hp] = di;\n                }\n\n            }\n\n            uint df = d.aa[fa] + 1;\n\n            d.aa[fa] = df;\n            hd.hs = block.timestamp;\n            hd.hn = block.number;\n            d.q[fa][df] = hd;\n        }\n    }\n\n\n    function bs(\n        uint fa,\n        uint gj,\n        uint cs,\n        IVotingEscrow.LockedBalance memory at,\n        DepositType br\n    ) internal {\n        IVotingEscrow.LockedBalance memory fk = at;\n        uint bi = ga;\n\n        ga = bi + gj;\n        IVotingEscrow.LockedBalance memory dc;\n        (dc.gf, dc.hp, dc.cq) = (fk.gf, fk.hp, fk.cq);\n\n        fk.gf += int128(int256(gj));\n\n        if (cs != 0) {\n            fk.hp = cs;\n        }\n        ge[fa] = fk;\n\n\n        ck(fa, dc, fk);\n\n        address from = msg.sender;\n        if (gj != 0) {\n            assert(IERC20(gn).by(from, address(this), gj));\n        }\n\n        emit Deposit(from, fa, gj, fk.hp, br, block.timestamp);\n        emit Supply(bi, bi + gj);\n    }\n\n\n    function de() external {\n        ck(0, IVotingEscrow.LockedBalance(0, 0, false), IVotingEscrow.LockedBalance(0, 0, false));\n    }\n\n\n    function ci(uint fa, uint gj) external ca {\n        IVotingEscrow.LockedBalance memory fk = ge[fa];\n\n        require(gj > 0, \"ZV\");\n        require(fk.gf > 0, 'ZL');\n        require(fk.hp > block.timestamp || fk.cq, 'EXP');\n\n        if (fk.cq) f += gj;\n\n        bs(fa, gj, 0, fk, DepositType.DEPOSIT_FOR_TYPE);\n\n        if(gw[fa]) {\n            IVoter(gv).hi(fa);\n        }\n    }\n\n\n    function bo(uint gj, uint ax, address hk) internal returns (uint) {\n        uint cs = (block.timestamp + ax) / WEEK * WEEK;\n\n        require(gj > 0, \"ZV\");\n        require(cs > block.timestamp && (cs <= block.timestamp + MAXTIME), 'IUT');\n\n        ++fo;\n        uint fa = fo;\n        hb(hk, fa);\n\n        IVotingEscrow.LockedBalance memory fk = ge[fa];\n\n        bs(fa, gj, cs, fk, DepositType.CREATE_LOCK_TYPE);\n        return fa;\n    }\n\n\n    function cm(uint gj, uint ax) external ca returns (uint) {\n        return bo(gj, ax, msg.sender);\n    }\n\n\n    function ak(uint gj, uint ax, address hk) external ca returns (uint) {\n        return bo(gj, ax, hk);\n    }\n\n\n    function am(uint fa, uint gj) external ca {\n        assert(r(msg.sender, fa));\n\n        IVotingEscrow.LockedBalance memory fk = ge[fa];\n\n        assert(gj > 0);\n        require(fk.gf > 0, 'ZL');\n        require(fk.hp > block.timestamp || fk.cq, 'EXP');\n\n        if (fk.cq) f += gj;\n        bs(fa, gj, 0, fk, DepositType.INCREASE_LOCK_AMOUNT);\n\n\n        if(gw[fa]) {\n            IVoter(gv).hi(fa);\n        }\n        emit MetadataUpdate(fa);\n    }\n\n\n    function g(uint fa, uint ax) external ca {\n        assert(r(msg.sender, fa));\n\n        IVotingEscrow.LockedBalance memory fk = ge[fa];\n        require(!fk.cq, \"!NORM\");\n        uint cs = (block.timestamp + ax) / WEEK * WEEK;\n\n        require(fk.hp > block.timestamp && fk.gf > 0, 'EXP||ZV');\n        require(cs > fk.hp && (cs <= block.timestamp + MAXTIME), 'IUT');\n\n        bs(fa, 0, cs, fk, DepositType.INCREASE_UNLOCK_TIME);\n\n\n        if(gw[fa]) {\n            IVoter(gv).hi(fa);\n        }\n        emit MetadataUpdate(fa);\n    }\n\n\n    function eu(uint fa) external ca {\n        assert(r(msg.sender, fa));\n        require(cf[fa] == 0 && !gw[fa], \"ATT\");\n\n        IVotingEscrow.LockedBalance memory fk = ge[fa];\n        require(!fk.cq, \"!NORM\");\n        require(block.timestamp >= fk.hp, \"!EXP\");\n        uint value = uint(int256(fk.gf));\n\n        ge[fa] = IVotingEscrow.LockedBalance(0, 0, false);\n        uint bi = ga;\n        ga = bi - value;\n\n\n        ck(fa, fk, IVotingEscrow.LockedBalance(0, 0, false));\n\n        assert(IERC20(gn).transfer(msg.sender, value));\n\n\n        ha(fa);\n\n        emit Withdraw(msg.sender, fa, value, block.timestamp);\n        emit Supply(bi, bi - value);\n    }\n\n    function bk(uint fa) external {\n        address sender = msg.sender;\n        require(r(sender, fa), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory dl = ge[fa];\n        require(!dl.cq, \"!NORM\");\n        require(dl.hp > block.timestamp, \"EXP\");\n        require(dl.gf > 0, \"ZV\");\n\n        uint fq = uint(int256(dl.gf));\n        f += fq;\n        dl.hp = 0;\n        dl.cq = true;\n        ck(fa, ge[fa], dl);\n        ge[fa] = dl;\n        if(gw[fa]) {\n            IVoter(gv).hi(fa);\n        }\n        emit LockPermanent(sender, fa, fq, block.timestamp);\n        emit MetadataUpdate(fa);\n    }\n\n    function ag(uint fa) external {\n        address sender = msg.sender;\n        require(r(msg.sender, fa), \"NAO\");\n\n        require(cf[fa] == 0 && !gw[fa], \"ATT\");\n        IVotingEscrow.LockedBalance memory dl = ge[fa];\n        require(dl.cq, \"!NORM\");\n        uint fq = uint(int256(dl.gf));\n        f -= fq;\n        dl.hp = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n        dl.cq = false;\n\n        ck(fa, ge[fa], dl);\n        ge[fa] = dl;\n\n        emit UnlockPermanent(sender, fa, fq, block.timestamp);\n        emit MetadataUpdate(fa);\n    }\n\n\n    function bu(uint fa) external view returns (uint) {\n        if (z[fa] == block.number) return 0;\n        return VotingBalanceLogic.bu(fa, block.timestamp, d);\n    }\n\n    function au(uint fa, uint hr) external view returns (uint) {\n        return VotingBalanceLogic.bu(fa, hr, d);\n    }\n\n    function aw(uint fa, uint fz) external view returns (uint) {\n        return VotingBalanceLogic.aw(fa, fz, d, gz);\n    }\n\n\n    function bc(uint fz) external view returns (uint) {\n        return VotingBalanceLogic.bc(fz, gz, d, ba);\n    }\n\n    function cr() external view returns (uint) {\n        return ao(block.timestamp);\n    }\n\n\n    function ao(uint t) public view returns (uint) {\n        return VotingBalanceLogic.ao(t, gz, ba,  d);\n    }\n\n\n    mapping(uint => uint) public cf;\n    mapping(uint => bool) public gw;\n\n    function ep(address gh) external {\n        require(msg.sender == hf);\n        gv = gh;\n    }\n\n    function fu(uint fa) external {\n        require(msg.sender == gv);\n        gw[fa] = true;\n    }\n\n    function fl(uint fa) external {\n        require(msg.sender == gv, \"NA\");\n        gw[fa] = false;\n    }\n\n    function fv(uint fa) external {\n        require(msg.sender == gv, \"NA\");\n        cf[fa] = cf[fa] + 1;\n    }\n\n    function fs(uint fa) external {\n        require(msg.sender == gv, \"NA\");\n        cf[fa] = cf[fa] - 1;\n    }\n\n    function go(uint hc, uint hk) external ca bh(hc) {\n        require(cf[hc] == 0 && !gw[hc], \"ATT\");\n        require(hc != hk, \"SAME\");\n        require(r(msg.sender, hc) &&\n        r(msg.sender, hk), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory er = ge[hc];\n        IVotingEscrow.LockedBalance memory em = ge[hk];\n        require(em.hp > block.timestamp ||  em.cq,\"EXP||PERM\");\n        require(er.cq ? em.cq : true, \"!MERGE\");\n\n        uint gg = uint(int256(er.gf));\n        uint hp = er.hp >= em.hp ? er.hp : em.hp;\n\n        ge[hc] = IVotingEscrow.LockedBalance(0, 0, false);\n        ck(hc, er, IVotingEscrow.LockedBalance(0, 0, false));\n        ha(hc);\n\n        IVotingEscrow.LockedBalance memory cl;\n        cl.cq = em.cq;\n\n        if (cl.cq){\n            cl.gf = em.gf + er.gf;\n            if (!er.cq) {\n                f += gg;\n            }\n        }else{\n            cl.gf = em.gf + er.gf;\n            cl.hp = hp;\n        }\n\n\n        ck(hk, em, cl);\n        ge[hk] = cl;\n\n        if(gw[hk]) {\n            IVoter(gv).hi(hk);\n        }\n        emit Merge(\n            msg.sender,\n            hc,\n            hk,\n            uint(int256(er.gf)),\n            uint(int256(em.gf)),\n            uint(int256(cl.gf)),\n            cl.hp,\n            block.timestamp\n        );\n        emit MetadataUpdate(hk);\n    }\n\n\n    function dh(\n        uint hc,\n        uint[] memory fi\n    ) external ca bx(hc) bh(hc) returns (uint256[] memory cn) {\n        require(fi.length >= 2 && fi.length <= 10, \"MIN2MAX10\");\n\n        address gm = dw[hc];\n\n        IVotingEscrow.LockedBalance memory ap = ge[hc];\n        require(ap.hp > block.timestamp || ap.cq, \"EXP\");\n        require(ap.gf > 0, \"ZV\");\n\n\n        uint co = 0;\n        for(uint i = 0; i < fi.length; i++) {\n            require(fi[i] > 0, \"ZW\");\n            co += fi[i];\n        }\n\n\n        ge[hc] = IVotingEscrow.LockedBalance(0, 0, false);\n        ck(hc, ap, IVotingEscrow.LockedBalance(0, 0, false));\n        ha(hc);\n\n\n        cn = new uint256[](fi.length);\n        uint[] memory bj = new uint[](fi.length);\n\n        for(uint i = 0; i < fi.length; i++) {\n            IVotingEscrow.LockedBalance memory ds = IVotingEscrow.LockedBalance({\n                gf: int128(int256(uint256(int256(ap.gf)) * fi[i] / co)),\n                hp: ap.hp,\n                cq: ap.cq\n            });\n\n            cn[i] = ai(gm, ds);\n            bj[i] = uint256(int256(ds.gf));\n        }\n\n        emit MultiSplit(\n            hc,\n            cn,\n            msg.sender,\n            bj,\n            ap.hp,\n            block.timestamp\n        );\n    }\n\n    function ai(address hk, IVotingEscrow.LockedBalance memory dl) private returns (uint256 fa) {\n        fa = ++fo;\n        ge[fa] = dl;\n        ck(fa, IVotingEscrow.LockedBalance(0, 0, false), dl);\n        hb(hk, fa);\n    }\n\n    function cu(address ev, bool gs) external {\n        require(msg.sender == hf);\n        fd[ev] = gs;\n    }\n\n\n    bytes32 public constant DOMAIN_TYPEHASH = dr(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\n    bytes32 public constant DELEGATION_TYPEHASH = dr(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n\n    mapping(address => address) private dk;\n\n\n    mapping(address => uint) public gk;\n\n\n    function dy(address dt) public view returns (address) {\n        address fh = dk[dt];\n        return fh == address(0) ? dt : fh;\n    }\n\n\n    function ez(address fm) external view returns (uint) {\n        uint32 bw = gi.aq[fm];\n        if (bw == 0) {\n            return 0;\n        }\n        uint[] storage ee = gi.cj[fm][bw - 1].fc;\n        uint gq = 0;\n        for (uint i = 0; i < ee.length; i++) {\n            uint ho = ee[i];\n            gq = gq + VotingBalanceLogic.bu(ho, block.timestamp, d);\n        }\n        return gq;\n    }\n\n    function bz(address fm, uint timestamp)\n        public\n        view\n        returns (uint)\n    {\n        uint32 cy = VotingDelegationLib.s(gi, fm, timestamp);\n\n        uint[] storage ee = gi.cj[fm][cy].fc;\n        uint gq = 0;\n        for (uint i = 0; i < ee.length; i++) {\n            uint ho = ee[i];\n\n            gq = gq + VotingBalanceLogic.bu(ho, timestamp,  d);\n        }\n\n        return gq;\n    }\n\n    function o(uint256 timestamp) external view returns (uint) {\n        return ao(timestamp);\n    }\n\n\n    function dp(address dt, address eh) internal {\n\n        address an = dy(dt);\n\n        dk[dt] = eh;\n\n        emit DelegateChanged(dt, an, eh);\n        VotingDelegationLib.TokenHelpers memory bv = VotingDelegationLib.TokenHelpers({\n            dv: fe,\n            e: e,\n            m:m\n        });\n        VotingDelegationLib.y(gi, dt, an, eh, bv);\n    }\n\n\n    function es(address eh) public {\n        if (eh == address(0)) eh = msg.sender;\n        return dp(msg.sender, eh);\n    }\n\n    function bl(\n        address eh,\n        uint gr,\n        uint gl,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(eh != msg.sender, \"NA\");\n        require(eh != address(0), \"ZA\");\n\n        bytes32 ah = dr(\n            abi.fr(\n                DOMAIN_TYPEHASH,\n                dr(bytes(he)),\n                dr(bytes(ff)),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 dg = dr(\n            abi.fr(DELEGATION_TYPEHASH, eh, gr, gl)\n        );\n        bytes32 gc = dr(\n            abi.cb(\"\\x19\\x01\", ah, dg)\n        );\n        address dx = eg(gc, v, r, s);\n        require(\n            dx != address(0),\n            \"ZA\"\n        );\n        require(\n            gr == gk[dx]++,\n            \"!NONCE\"\n        );\n        require(\n            block.timestamp <= gl,\n            \"EXP\"\n        );\n        return dp(dx, eh);\n    }\n\n}",
      "rename_map": {
        "_removeTokenFromOwnerList": "a",
        "spenderIsApprovedForAll": "b",
        "senderIsApprovedForAll": "c",
        "votingBalanceLogicData": "d",
        "ownerToNFTokenCountFn": "e",
        "permanentLockBalance": "f",
        "increase_unlock_time": "g",
        "ownerToNFTokenIdList": "h",
        "_addTokenToOwnerList": "i",
        "get_last_user_slope": "j",
        "ownerToNFTokenCount": "k",
        "supportedInterfaces": "l",
        "tokenOfOwnerByIndex": "m",
        "moveTokenDelegates": "n",
        "getPastTotalSupply": "o",
        "initial_last_point": "p",
        "user_point_history": "q",
        "_isApprovedOrOwner": "r",
        "getPastVotesIndex": "s",
        "tokenToOwnerIndex": "t",
        "supportsInterface": "u",
        "isApprovedOrOwner": "v",
        "spenderIsApproved": "w",
        "setApprovalForAll": "x",
        "_moveAllDelegates": "y",
        "ownership_change": "z",
        "user_point_epoch": "aa",
        "_removeTokenFrom": "ab",
        "ownerToOperators": "ac",
        "isApprovedForAll": "ad",
        "safeTransferFrom": "ae",
        "onERC721Received": "af",
        "unlockPermanent": "ag",
        "domainSeparator": "ah",
        "_createSplitNFT": "ai",
        "last_checkpoint": "aj",
        "create_lock_for": "ak",
        "setPartnerVeNFT": "al",
        "increase_amount": "am",
        "currentDelegate": "an",
        "totalSupplyAtT": "ao",
        "originalLocked": "ap",
        "numCheckpoints": "aq",
        "_entered_state": "ar",
        "isPartnerVeNFT": "as",
        "locked_balance": "at",
        "balanceOfNFTAt": "au",
        "_clearApproval": "av",
        "balanceOfAtNFT": "aw",
        "_lock_duration": "ax",
        "spenderIsOwner": "ay",
        "point_history": "az",
        "slope_changes": "ba",
        "_transferFrom": "bb",
        "totalSupplyAt": "bc",
        "idToApprovals": "bd",
        "current_count": "be",
        "_splitAmount2": "bf",
        "senderIsOwner": "bg",
        "notPartnerNFT": "bh",
        "supply_before": "bi",
        "actualAmounts": "bj",
        "lockPermanent": "bk",
        "delegateBySig": "bl",
        "_splitAmount1": "bm",
        "current_index": "bn",
        "_create_lock": "bo",
        "_not_entered": "bp",
        "_interfaceID": "bq",
        "deposit_type": "br",
        "_deposit_for": "bs",
        "_newTokenIds": "bt",
        "balanceOfNFT": "bu",
        "tokenHelpers": "bv",
        "nCheckpoints": "bw",
        "splitAllowed": "bx",
        "transferFrom": "by",
        "getPastVotes": "bz",
        "nonreentrant": "ca",
        "encodePacked": "cb",
        "_fromTokenId": "cc",
        "_amountFinal": "cd",
        "_tokenIndex": "ce",
        "attachments": "cf",
        "setArtProxy": "cg",
        "getApproved": "ch",
        "deposit_for": "ci",
        "checkpoints": "cj",
        "_checkpoint": "ck",
        "newLockedTo": "cl",
        "create_lock": "cm",
        "newTokenIds": "cn",
        "totalWeight": "co",
        "_amountFrom": "cp",
        "isPermanent": "cq",
        "totalSupply": "cr",
        "unlock_time": "cs",
        "block_slope": "ct",
        "toggleSplit": "cu",
        "_isContract": "cv",
        "_addTokenTo": "cw",
        "lastTokenId": "cx",
        "_checkIndex": "cy",
        "_toTokenId": "cz",
        "last_point": "da",
        "new_locked": "db",
        "old_locked": "dc",
        "_isPartner": "dd",
        "checkpoint": "de",
        "user_epoch": "df",
        "structHash": "dg",
        "multiSplit": "dh",
        "new_dslope": "di",
        "token_addr": "dj",
        "_delegates": "dk",
        "_newLocked": "dl",
        "prevSupply": "dm",
        "old_dslope": "dn",
        "_tokenURI": "do",
        "_delegate": "dp",
        "_operator": "dq",
        "keccak256": "dr",
        "newLocked": "ds",
        "delegator": "dt",
        "_locktime": "du",
        "ownerOfFn": "dv",
        "idToOwner": "dw",
        "signatory": "dx",
        "delegates": "dy",
        "permanent": "dz",
        "_tokenId1": "ea",
        "art_proxy": "eb",
        "balanceOf": "ec",
        "_tokenId2": "ed",
        "_tokenIds": "ee",
        "_amountTo": "ef",
        "ecrecover": "eg",
        "delegatee": "eh",
        "_approved": "ei",
        "iMAXTIME": "ej",
        "_balance": "ek",
        "_entered": "el",
        "_locked1": "em",
        "response": "en",
        "provider": "eo",
        "setVoter": "ep",
        "artProxy": "eq",
        "_locked0": "er",
        "delegate": "es",
        "tokenURI": "et",
        "withdraw": "eu",
        "_account": "ev",
        "_spender": "ew",
        "decimals": "ex",
        "_amounts": "ey",
        "getVotes": "ez",
        "_tokenId": "fa",
        "locktime": "fb",
        "tokenIds": "fc",
        "canSplit": "fd",
        "ownerOf": "fe",
        "version": "ff",
        "approve": "fg",
        "current": "fh",
        "amounts": "fi",
        "setTeam": "fj",
        "_locked": "fk",
        "abstain": "fl",
        "account": "fm",
        "_sender": "fn",
        "tokenId": "fo",
        "d_slope": "fp",
        "_amount": "fq",
        "encode": "fr",
        "detach": "fs",
        "_epoch": "ft",
        "voting": "fu",
        "attach": "fv",
        "reason": "fw",
        "symbol": "fx",
        "_proxy": "fy",
        "_block": "fz",
        "supply": "ga",
        "uepoch": "gb",
        "digest": "gc",
        "_owner": "gd",
        "locked": "ge",
        "amount": "gf",
        "value0": "gg",
        "_voter": "gh",
        "cpData": "gi",
        "_value": "gj",
        "nonces": "gk",
        "expiry": "gl",
        "owner": "gm",
        "token": "gn",
        "merge": "go",
        "u_old": "gp",
        "votes": "gq",
        "nonce": "gr",
        "_bool": "gs",
        "_data": "gt",
        "slope": "gu",
        "voter": "gv",
        "voted": "gw",
        "_team": "gx",
        "_hybr": "gy",
        "epoch": "gz",
        "_burn": "ha",
        "_mint": "hb",
        "_from": "hc",
        "u_new": "hd",
        "name": "he",
        "team": "hf",
        "_idx": "hg",
        "bias": "hh",
        "poke": "hi",
        "size": "hj",
        "_to": "hk",
        "max": "hl",
        "t_i": "hm",
        "blk": "hn",
        "tId": "ho",
        "end": "hp",
        "_ts": "hq",
        "_t": "hr",
        "ts": "hs"
      },
      "changes": [
        "Renamed 227 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_011",
      "transformed_id": "ss_l2_short_nc_gs_011",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n\ncontract MinVotingPowerCondition is PermissionCondition {\n\n    ILockToGovernBase public immutable k;\n\n\n    ILockManager public immutable f;\n\n\n    IERC20 public immutable l;\n\n\n    constructor(ILockToGovernBase i) {\n        k = i;\n        l = k.l();\n        f = k.f();\n    }\n\n\n    function h(address j, address n, bytes32 e, bytes calldata m)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (j, m, e);\n\n        uint256 d = l.g(n) + f.c(n);\n        uint256 a = k.b();\n\n        return d >= a;\n    }\n}",
      "rename_map": {
        "_minProposerVotingPower": "a",
        "minProposerVotingPower": "b",
        "getLockedBalance": "c",
        "_currentBalance": "d",
        "_permissionId": "e",
        "lockManager": "f",
        "balanceOf": "g",
        "isGranted": "h",
        "_plugin": "i",
        "_where": "j",
        "plugin": "k",
        "token": "l",
        "_data": "m",
        "_who": "n"
      },
      "changes": [
        "Renamed 14 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_012",
      "transformed_id": "ss_l2_short_nc_gs_012",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.d.selector ^ this.z.selector;\n\n\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = ax(\"CREATE_PROPOSAL_PERMISSION\");\n\n\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = ax(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 au, address bs);\n\n    error VoteRemovalForbidden(uint256 au, address bs);\n\n\n    function as(\n        IDAO bw,\n        ILockManager af,\n        VotingSettings calldata q,\n        IPlugin.TargetConfig calldata ab,\n        bytes calldata w\n    ) external a ac(1) {\n        __MajorityVotingBase_init(bw, q, ab, w);\n        __LockToGovernBase_init(af);\n\n        emit MembershipContractAnnounced({l: address(af.bo())});\n    }\n\n\n    function j(bytes4 ag)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return ag == LOCK_TO_VOTE_INTERFACE_ID || ag == type(ILockToVote).an\n            || super.j(ag);\n    }\n\n\n    function b() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n\n    function z(\n        bytes calldata az,\n        Action[] memory bg,\n        uint64 av,\n        uint64 bf,\n        bytes memory bq\n    ) external bt(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 au) {\n        uint256 m;\n\n        if (bq.length != 0) {\n            (m) = abi.bm(bq, (uint256));\n        }\n\n        if (i() == 0) {\n            revert NoVotingPower();\n        }\n\n\n        (av, bf) = e(av, bf);\n\n        au = k(ax(abi.bl(bg, az)));\n\n        if (v(au)) {\n            revert ProposalAlreadyExists(au);\n        }\n\n\n        Proposal storage ba = bb[au];\n\n        ba.at.ar = ar();\n        ba.at.f = f();\n        ba.at.aw = av;\n        ba.at.bh = bf;\n        ba.at.g = g();\n        ba.at.n = n();\n\n        ba.ae = r();\n\n\n        if (m != 0) {\n            ba.p = m;\n        }\n\n        for (uint256 i; i < bg.length;) {\n            ba.bj.push(bg[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(au, aq(), av, bf, az, bg, m);\n\n        al.x(au);\n    }\n\n\n    function bk(uint256 ak, address bn, VoteOption ah) public view returns (bool) {\n        if (!v(ak)) {\n            revert NonexistentProposal(ak);\n        }\n\n        Proposal storage ba = bb[ak];\n        return bd(ba, bn, ah, al.o(bn));\n    }\n\n\n    function bv(uint256 ak, address bn, VoteOption ah, uint256 s)\n        public\n        override\n        bt(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage ba = bb[ak];\n\n        if (!bd(ba, bn, ah, s)) {\n            revert VoteCastForbidden(ak, bn);\n        }\n\n\n        if (ah == ba.bp[bn].ap) {\n\n            if (s == ba.bp[bn].aj) return;\n\n\n            uint256 bu = s - ba.bp[bn].aj;\n            ba.bp[bn].aj = s;\n\n            if (ba.bp[bn].ap == VoteOption.Yes) {\n                ba.br.bx += bu;\n            } else if (ba.bp[bn].ap == VoteOption.No) {\n                ba.br.bz += bu;\n            } else {\n\n                ba.br.bi += bu;\n            }\n        } else {\n\n\n            if (ba.bp[bn].aj > 0) {\n\n                if (ba.bp[bn].ap == VoteOption.Yes) {\n                    ba.br.bx -= ba.bp[bn].aj;\n                } else if (ba.bp[bn].ap == VoteOption.No) {\n                    ba.br.bz -= ba.bp[bn].aj;\n                } else {\n\n                    ba.br.bi -= ba.bp[bn].aj;\n                }\n            }\n\n\n            if (ah == VoteOption.Yes) {\n                ba.br.bx += s;\n            } else if (ah == VoteOption.No) {\n                ba.br.bz += s;\n            } else {\n\n                ba.br.bi += s;\n            }\n            ba.bp[bn].ap = ah;\n            ba.bp[bn].aj = s;\n        }\n\n        emit VoteCast(ak, bn, ah, s);\n\n        if (ba.at.ar == VotingMode.EarlyExecution) {\n            c(ak, aq());\n        }\n    }\n\n\n    function ay(uint256 ak, address bn) external bt(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage ba = bb[ak];\n        if (!u(ba)) {\n            revert VoteRemovalForbidden(ak, bn);\n        } else if (ba.at.ar != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(ak, bn);\n        } else if (ba.bp[bn].aj == 0) {\n\n            return;\n        }\n\n\n        if (ba.bp[bn].ap == VoteOption.Yes) {\n            ba.br.bx -= ba.bp[bn].aj;\n        } else if (ba.bp[bn].ap == VoteOption.No) {\n            ba.br.bz -= ba.bp[bn].aj;\n        }\n\n        else if (ba.bp[bn].ap == VoteOption.Abstain) {\n            ba.br.bi -= ba.bp[bn].aj;\n        }\n        ba.bp[bn].aj = 0;\n\n        emit VoteCleared(ak, bn);\n    }\n\n\n    function y(uint256 ak) external view returns (bool) {\n        Proposal storage ba = bb[ak];\n        return u(ba);\n    }\n\n\n    function d() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.d();\n    }\n\n\n    function i() public view override returns (uint256) {\n        return IERC20(al.bo()).ao();\n    }\n\n\n    function t(uint256 ak, address bn) public view returns (uint256) {\n        return bb[ak].bp[bn].aj;\n    }\n\n\n    function bd(Proposal storage ba, address bn, VoteOption ah, uint256 s)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 h = ba.bp[bn].aj;\n\n\n        if (!u(ba)) {\n            return false;\n        } else if (ah == VoteOption.None) {\n            return false;\n        }\n\n        else if (ba.at.ar != VotingMode.VoteReplacement) {\n\n            if (s <= h) {\n                return false;\n            }\n\n            else if (\n                ba.bp[bn].ap != VoteOption.None\n                    && ah != ba.bp[bn].ap\n            ) {\n                return false;\n            }\n        }\n\n        else {\n\n            if (s == 0 || s < h) {\n                return false;\n            }\n\n            else if (s == h && ah == ba.bp[bn].ap) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function c(uint256 ak, address am) internal {\n        if (!ai(ak)) {\n            return;\n        } else if (!by().aa(address(this), am, EXECUTE_PROPOSAL_PERMISSION_ID, bc())) {\n            return;\n        }\n\n        be(ak);\n    }\n\n    function be(uint256 ak) internal override {\n        super.be(ak);\n\n\n        al.ad(ak);\n    }\n\n\n    uint256[50] private __gap;\n}",
      "rename_map": {
        "onlyCallAtInitialization": "a",
        "customProposalParamsABI": "b",
        "_attemptEarlyExecution": "c",
        "minProposerVotingPower": "d",
        "_validateProposalDates": "e",
        "supportThresholdRatio": "f",
        "minParticipationRatio": "g",
        "_currentVotingPower": "h",
        "currentTokenSupply": "i",
        "supportsInterface": "j",
        "_createProposalId": "k",
        "definingContract": "l",
        "_allowFailureMap": "m",
        "minApprovalRatio": "n",
        "getLockedBalance": "o",
        "allowFailureMap": "p",
        "_votingSettings": "q",
        "getTargetConfig": "r",
        "_newVotingPower": "s",
        "usedVotingPower": "t",
        "_isProposalOpen": "u",
        "_proposalExists": "v",
        "_pluginMetadata": "w",
        "proposalCreated": "x",
        "isProposalOpen": "y",
        "createProposal": "z",
        "hasPermission": "aa",
        "_targetConfig": "ab",
        "reinitializer": "ac",
        "proposalEnded": "ad",
        "targetConfig": "ae",
        "_lockManager": "af",
        "_interfaceId": "ag",
        "_voteOption": "ah",
        "_canExecute": "ai",
        "votingPower": "aj",
        "_proposalId": "ak",
        "lockManager": "al",
        "_voteCaller": "am",
        "interfaceId": "an",
        "totalSupply": "ao",
        "voteOption": "ap",
        "_msgSender": "aq",
        "votingMode": "ar",
        "initialize": "as",
        "parameters": "at",
        "proposalId": "au",
        "_startDate": "av",
        "startDate": "aw",
        "keccak256": "ax",
        "clearVote": "ay",
        "_metadata": "az",
        "proposal_": "ba",
        "proposals": "bb",
        "_msgData": "bc",
        "_canVote": "bd",
        "_execute": "be",
        "_endDate": "bf",
        "_actions": "bg",
        "endDate": "bh",
        "abstain": "bi",
        "actions": "bj",
        "canVote": "bk",
        "encode": "bl",
        "decode": "bm",
        "_voter": "bn",
        "token": "bo",
        "votes": "bp",
        "_data": "bq",
        "tally": "br",
        "voter": "bs",
        "auth": "bt",
        "diff": "bu",
        "vote": "bv",
        "_dao": "bw",
        "yes": "bx",
        "dao": "by",
        "no": "bz"
      },
      "changes": [
        "Renamed 78 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_013",
      "transformed_id": "ss_l2_short_nc_gs_013",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n\n    IERC20 private immutable e;\n\n\n    constructor(LockManagerSettings memory g, IERC20 j) LockManagerBase(g) {\n        e = j;\n    }\n\n\n    function k() public view virtual returns (address j) {\n        return address(e);\n    }\n\n\n    function a() internal view virtual override returns (uint256) {\n        return e.h(msg.sender, address(this));\n    }\n\n\n    function c(uint256 i) internal virtual override {\n        e.d(msg.sender, address(this), i);\n    }\n\n\n    function b(address f, uint256 i) internal virtual override {\n        e.transfer(f, i);\n    }\n}",
      "rename_map": {
        "_incomingTokenBalance": "a",
        "_doUnlockTransfer": "b",
        "_doLockTransfer": "c",
        "transferFrom": "d",
        "erc20Token": "e",
        "_recipient": "f",
        "_settings": "g",
        "allowance": "h",
        "_amount": "i",
        "_token": "j",
        "token": "k"
      },
      "changes": [
        "Renamed 11 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_014",
      "transformed_id": "ss_l2_short_nc_gs_014",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n\n    IERC20 private immutable e;\n\n\n    constructor(LockManagerSettings memory g, IERC20 j) LockManagerBase(g) {\n        e = j;\n    }\n\n\n    function k() public view virtual returns (address j) {\n        return address(e);\n    }\n\n\n    function a() internal view virtual override returns (uint256) {\n        return e.h(msg.sender, address(this));\n    }\n\n\n    function c(uint256 i) internal virtual override {\n        e.d(msg.sender, address(this), i);\n    }\n\n\n    function b(address f, uint256 i) internal virtual override {\n        e.transfer(f, i);\n    }\n}",
      "rename_map": {
        "_incomingTokenBalance": "a",
        "_doUnlockTransfer": "b",
        "_doLockTransfer": "c",
        "transferFrom": "d",
        "erc20Token": "e",
        "_recipient": "f",
        "_settings": "g",
        "allowance": "h",
        "_amount": "i",
        "_token": "j",
        "token": "k"
      },
      "changes": [
        "Renamed 11 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_015",
      "transformed_id": "ss_l2_short_nc_gs_015",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n\n    LockManagerSettings public ad;\n\n\n    ILockToGovernBase public aj;\n\n\n    mapping(address => uint256) private r;\n\n\n    EnumerableSet.UintSet internal l;\n\n\n    event BalanceLocked(address am, uint256 ah);\n\n\n    event BalanceUnlocked(address am, uint256 ah);\n\n\n    event ProposalEnded(uint256 x);\n\n\n    error InvalidPluginAddress();\n\n\n    error NoBalance();\n\n\n    error LocksStillActive();\n\n\n    error InvalidPlugin();\n\n\n    error InvalidPluginMode();\n\n\n    error SetPluginAddressForbidden();\n\n\n    constructor(LockManagerSettings memory aa) {\n        ad.z = aa.z;\n    }\n\n\n    function h(uint256 al) public view virtual returns (uint256) {\n        return l.at(al);\n    }\n\n\n    function b() public view virtual returns (uint256) {\n        return l.length();\n    }\n\n\n    function ap() public virtual {\n        ao(c());\n    }\n\n\n    function ap(uint256 ae) public virtual {\n        ao(ae);\n    }\n\n\n    function w(uint256 v, IMajorityVoting.VoteOption t) public virtual {\n        if (ad.z != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        ao(c());\n        an(v, t);\n    }\n\n\n    function w(uint256 v, IMajorityVoting.VoteOption t, uint256 ae) public virtual {\n        if (ad.z != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        ao(ae);\n        an(v, t);\n    }\n\n\n    function aq(uint256 v, IMajorityVoting.VoteOption t) public virtual {\n        if (ad.z != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        an(v, t);\n    }\n\n\n    function j(address ac) public view virtual returns (uint256) {\n        return r[ac];\n    }\n\n\n    function af(uint256 v, address ai, IMajorityVoting.VoteOption t)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(aj)).af(v, ai, t);\n    }\n\n\n    function ag() public virtual {\n        uint256 e = j(msg.sender);\n        if (e == 0) {\n            revert NoBalance();\n        }\n\n\n        a();\n\n\n        r[msg.sender] = 0;\n\n\n        f(msg.sender, e);\n        emit BalanceUnlocked(msg.sender, e);\n    }\n\n\n    function n(uint256 v) public virtual {\n        if (msg.sender != address(aj)) {\n            revert InvalidPluginAddress();\n        }\n\n\n        l.ar(v);\n    }\n\n\n    function s(uint256 v) public virtual {\n        if (msg.sender != address(aj)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(v);\n        l.ak(v);\n    }\n\n\n    function k(ILockToGovernBase i) public virtual {\n        if (address(aj) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(i)).g(type(ILockToGovernBase).u)) {\n            revert InvalidPlugin();\n        }\n\n        else if (\n            ad.z == PluginMode.Voting\n                && !IERC165(address(i)).g(type(ILockToVote).u)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        aj = i;\n    }\n\n\n    function c() internal view virtual returns (uint256);\n\n\n    function ao(uint256 ae) internal virtual {\n        if (ae == 0) {\n            revert NoBalance();\n        }\n\n\n        m(ae);\n\n        r[msg.sender] += ae;\n        emit BalanceLocked(msg.sender, ae);\n    }\n\n\n    function m(uint256 ae) internal virtual;\n\n\n    function f(address y, uint256 ae) internal virtual;\n\n    function an(uint256 v, IMajorityVoting.VoteOption t) internal virtual {\n        uint256 d = j(msg.sender);\n\n\n        ILockToVote(address(aj)).aq(v, msg.sender, t, d);\n    }\n\n    function a() internal virtual {\n        uint256 p = l.length();\n        for (uint256 as; as < p;) {\n            uint256 v = l.at(as);\n            if (!aj.q(v)) {\n                l.ak(v);\n                p = l.length();\n\n\n                if (as == p) {\n                    return;\n                }\n\n\n                continue;\n            }\n\n            if (aj.o(v, msg.sender) > 0) {\n                ILockToVote(address(aj)).ab(v, msg.sender);\n            }\n\n            unchecked {\n                as++;\n            }\n        }\n    }\n}",
      "rename_map": {
        "_withdrawActiveVotingPower": "a",
        "knownProposalIdsLength": "b",
        "_incomingTokenBalance": "c",
        "_currentVotingPower": "d",
        "_refundableBalance": "e",
        "_doUnlockTransfer": "f",
        "supportsInterface": "g",
        "knownProposalIdAt": "h",
        "_newPluginAddress": "i",
        "getLockedBalance": "j",
        "setPluginAddress": "k",
        "knownProposalIds": "l",
        "_doLockTransfer": "m",
        "proposalCreated": "n",
        "usedVotingPower": "o",
        "_proposalCount": "p",
        "isProposalOpen": "q",
        "lockedBalances": "r",
        "proposalEnded": "s",
        "_voteOption": "t",
        "interfaceId": "u",
        "_proposalId": "v",
        "lockAndVote": "w",
        "proposalId": "x",
        "_recipient": "y",
        "pluginMode": "z",
        "_settings": "aa",
        "clearVote": "ab",
        "_account": "ac",
        "settings": "ad",
        "_amount": "ae",
        "canVote": "af",
        "unlock": "ag",
        "amount": "ah",
        "_voter": "ai",
        "plugin": "aj",
        "remove": "ak",
        "_index": "al",
        "voter": "am",
        "_vote": "an",
        "_lock": "ao",
        "lock": "ap",
        "vote": "aq",
        "add": "ar",
        "_i": "as",
        "at": "at"
      },
      "changes": [
        "Renamed 46 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_016",
      "transformed_id": "ss_l2_short_nc_gs_016",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.d.selector ^ this.z.selector;\n\n\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = ax(\"CREATE_PROPOSAL_PERMISSION\");\n\n\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = ax(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 au, address bs);\n\n    error VoteRemovalForbidden(uint256 au, address bs);\n\n\n    function as(\n        IDAO bw,\n        ILockManager af,\n        VotingSettings calldata q,\n        IPlugin.TargetConfig calldata ab,\n        bytes calldata w\n    ) external a ac(1) {\n        __MajorityVotingBase_init(bw, q, ab, w);\n        __LockToGovernBase_init(af);\n\n        emit MembershipContractAnnounced({l: address(af.bo())});\n    }\n\n\n    function j(bytes4 ag)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return ag == LOCK_TO_VOTE_INTERFACE_ID || ag == type(ILockToVote).an\n            || super.j(ag);\n    }\n\n\n    function b() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n\n    function z(\n        bytes calldata az,\n        Action[] memory bg,\n        uint64 av,\n        uint64 bf,\n        bytes memory bq\n    ) external bt(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 au) {\n        uint256 m;\n\n        if (bq.length != 0) {\n            (m) = abi.bm(bq, (uint256));\n        }\n\n        if (i() == 0) {\n            revert NoVotingPower();\n        }\n\n\n        (av, bf) = e(av, bf);\n\n        au = k(ax(abi.bl(bg, az)));\n\n        if (v(au)) {\n            revert ProposalAlreadyExists(au);\n        }\n\n\n        Proposal storage ba = bb[au];\n\n        ba.at.ar = ar();\n        ba.at.f = f();\n        ba.at.aw = av;\n        ba.at.bh = bf;\n        ba.at.g = g();\n        ba.at.n = n();\n\n        ba.ae = r();\n\n\n        if (m != 0) {\n            ba.p = m;\n        }\n\n        for (uint256 i; i < bg.length;) {\n            ba.bj.push(bg[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(au, aq(), av, bf, az, bg, m);\n\n        al.x(au);\n    }\n\n\n    function bk(uint256 ak, address bn, VoteOption ah) public view returns (bool) {\n        if (!v(ak)) {\n            revert NonexistentProposal(ak);\n        }\n\n        Proposal storage ba = bb[ak];\n        return bd(ba, bn, ah, al.o(bn));\n    }\n\n\n    function bv(uint256 ak, address bn, VoteOption ah, uint256 s)\n        public\n        override\n        bt(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage ba = bb[ak];\n\n        if (!bd(ba, bn, ah, s)) {\n            revert VoteCastForbidden(ak, bn);\n        }\n\n\n        if (ah == ba.bp[bn].ap) {\n\n            if (s == ba.bp[bn].aj) return;\n\n\n            uint256 bu = s - ba.bp[bn].aj;\n            ba.bp[bn].aj = s;\n\n            if (ba.bp[bn].ap == VoteOption.Yes) {\n                ba.br.bx += bu;\n            } else if (ba.bp[bn].ap == VoteOption.No) {\n                ba.br.bz += bu;\n            } else {\n\n                ba.br.bi += bu;\n            }\n        } else {\n\n\n            if (ba.bp[bn].aj > 0) {\n\n                if (ba.bp[bn].ap == VoteOption.Yes) {\n                    ba.br.bx -= ba.bp[bn].aj;\n                } else if (ba.bp[bn].ap == VoteOption.No) {\n                    ba.br.bz -= ba.bp[bn].aj;\n                } else {\n\n                    ba.br.bi -= ba.bp[bn].aj;\n                }\n            }\n\n\n            if (ah == VoteOption.Yes) {\n                ba.br.bx += s;\n            } else if (ah == VoteOption.No) {\n                ba.br.bz += s;\n            } else {\n\n                ba.br.bi += s;\n            }\n            ba.bp[bn].ap = ah;\n            ba.bp[bn].aj = s;\n        }\n\n        emit VoteCast(ak, bn, ah, s);\n\n        if (ba.at.ar == VotingMode.EarlyExecution) {\n            c(ak, aq());\n        }\n    }\n\n\n    function ay(uint256 ak, address bn) external bt(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage ba = bb[ak];\n        if (!u(ba)) {\n            revert VoteRemovalForbidden(ak, bn);\n        } else if (ba.at.ar != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(ak, bn);\n        } else if (ba.bp[bn].aj == 0) {\n\n            return;\n        }\n\n\n        if (ba.bp[bn].ap == VoteOption.Yes) {\n            ba.br.bx -= ba.bp[bn].aj;\n        } else if (ba.bp[bn].ap == VoteOption.No) {\n            ba.br.bz -= ba.bp[bn].aj;\n        }\n\n        else if (ba.bp[bn].ap == VoteOption.Abstain) {\n            ba.br.bi -= ba.bp[bn].aj;\n        }\n        ba.bp[bn].aj = 0;\n\n        emit VoteCleared(ak, bn);\n    }\n\n\n    function y(uint256 ak) external view returns (bool) {\n        Proposal storage ba = bb[ak];\n        return u(ba);\n    }\n\n\n    function d() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.d();\n    }\n\n\n    function i() public view override returns (uint256) {\n        return IERC20(al.bo()).ao();\n    }\n\n\n    function t(uint256 ak, address bn) public view returns (uint256) {\n        return bb[ak].bp[bn].aj;\n    }\n\n\n    function bd(Proposal storage ba, address bn, VoteOption ah, uint256 s)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 h = ba.bp[bn].aj;\n\n\n        if (!u(ba)) {\n            return false;\n        } else if (ah == VoteOption.None) {\n            return false;\n        }\n\n        else if (ba.at.ar != VotingMode.VoteReplacement) {\n\n            if (s <= h) {\n                return false;\n            }\n\n            else if (\n                ba.bp[bn].ap != VoteOption.None\n                    && ah != ba.bp[bn].ap\n            ) {\n                return false;\n            }\n        }\n\n        else {\n\n            if (s == 0 || s < h) {\n                return false;\n            }\n\n            else if (s == h && ah == ba.bp[bn].ap) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function c(uint256 ak, address am) internal {\n        if (!ai(ak)) {\n            return;\n        } else if (!by().aa(address(this), am, EXECUTE_PROPOSAL_PERMISSION_ID, bc())) {\n            return;\n        }\n\n        be(ak);\n    }\n\n    function be(uint256 ak) internal override {\n        super.be(ak);\n\n\n        al.ad(ak);\n    }\n\n\n    uint256[50] private __gap;\n}",
      "rename_map": {
        "onlyCallAtInitialization": "a",
        "customProposalParamsABI": "b",
        "_attemptEarlyExecution": "c",
        "minProposerVotingPower": "d",
        "_validateProposalDates": "e",
        "supportThresholdRatio": "f",
        "minParticipationRatio": "g",
        "_currentVotingPower": "h",
        "currentTokenSupply": "i",
        "supportsInterface": "j",
        "_createProposalId": "k",
        "definingContract": "l",
        "_allowFailureMap": "m",
        "minApprovalRatio": "n",
        "getLockedBalance": "o",
        "allowFailureMap": "p",
        "_votingSettings": "q",
        "getTargetConfig": "r",
        "_newVotingPower": "s",
        "usedVotingPower": "t",
        "_isProposalOpen": "u",
        "_proposalExists": "v",
        "_pluginMetadata": "w",
        "proposalCreated": "x",
        "isProposalOpen": "y",
        "createProposal": "z",
        "hasPermission": "aa",
        "_targetConfig": "ab",
        "reinitializer": "ac",
        "proposalEnded": "ad",
        "targetConfig": "ae",
        "_lockManager": "af",
        "_interfaceId": "ag",
        "_voteOption": "ah",
        "_canExecute": "ai",
        "votingPower": "aj",
        "_proposalId": "ak",
        "lockManager": "al",
        "_voteCaller": "am",
        "interfaceId": "an",
        "totalSupply": "ao",
        "voteOption": "ap",
        "_msgSender": "aq",
        "votingMode": "ar",
        "initialize": "as",
        "parameters": "at",
        "proposalId": "au",
        "_startDate": "av",
        "startDate": "aw",
        "keccak256": "ax",
        "clearVote": "ay",
        "_metadata": "az",
        "proposal_": "ba",
        "proposals": "bb",
        "_msgData": "bc",
        "_canVote": "bd",
        "_execute": "be",
        "_endDate": "bf",
        "_actions": "bg",
        "endDate": "bh",
        "abstain": "bi",
        "actions": "bj",
        "canVote": "bk",
        "encode": "bl",
        "decode": "bm",
        "_voter": "bn",
        "token": "bo",
        "votes": "bp",
        "_data": "bq",
        "tally": "br",
        "voter": "bs",
        "auth": "bt",
        "diff": "bu",
        "vote": "bv",
        "_dao": "bw",
        "yes": "bx",
        "dao": "by",
        "no": "bz"
      },
      "changes": [
        "Renamed 78 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_017",
      "transformed_id": "ss_l2_short_nc_gs_017",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n\ncontract MinVotingPowerCondition is PermissionCondition {\n\n    ILockToGovernBase public immutable k;\n\n\n    ILockManager public immutable f;\n\n\n    IERC20 public immutable l;\n\n\n    constructor(ILockToGovernBase i) {\n        k = i;\n        l = k.l();\n        f = k.f();\n    }\n\n\n    function h(address j, address n, bytes32 e, bytes calldata m)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (j, m, e);\n\n        uint256 d = l.g(n) + f.c(n);\n        uint256 a = k.b();\n\n        return d >= a;\n    }\n}",
      "rename_map": {
        "_minProposerVotingPower": "a",
        "minProposerVotingPower": "b",
        "getLockedBalance": "c",
        "_currentBalance": "d",
        "_permissionId": "e",
        "lockManager": "f",
        "balanceOf": "g",
        "isGranted": "h",
        "_plugin": "i",
        "_where": "j",
        "plugin": "k",
        "token": "l",
        "_data": "m",
        "_who": "n"
      },
      "changes": [
        "Renamed 14 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_018",
      "transformed_id": "ss_l2_short_nc_gs_018",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.d.selector ^ this.z.selector;\n\n\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = ax(\"CREATE_PROPOSAL_PERMISSION\");\n\n\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = ax(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 au, address bs);\n\n    error VoteRemovalForbidden(uint256 au, address bs);\n\n\n    function as(\n        IDAO bw,\n        ILockManager af,\n        VotingSettings calldata q,\n        IPlugin.TargetConfig calldata ab,\n        bytes calldata w\n    ) external a ac(1) {\n        __MajorityVotingBase_init(bw, q, ab, w);\n        __LockToGovernBase_init(af);\n\n        emit MembershipContractAnnounced({l: address(af.bo())});\n    }\n\n\n    function j(bytes4 ag)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return ag == LOCK_TO_VOTE_INTERFACE_ID || ag == type(ILockToVote).an\n            || super.j(ag);\n    }\n\n\n    function b() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n\n    function z(\n        bytes calldata az,\n        Action[] memory bg,\n        uint64 av,\n        uint64 bf,\n        bytes memory bq\n    ) external bt(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 au) {\n        uint256 m;\n\n        if (bq.length != 0) {\n            (m) = abi.bm(bq, (uint256));\n        }\n\n        if (i() == 0) {\n            revert NoVotingPower();\n        }\n\n\n        (av, bf) = e(av, bf);\n\n        au = k(ax(abi.bl(bg, az)));\n\n        if (v(au)) {\n            revert ProposalAlreadyExists(au);\n        }\n\n\n        Proposal storage ba = bb[au];\n\n        ba.at.ar = ar();\n        ba.at.f = f();\n        ba.at.aw = av;\n        ba.at.bh = bf;\n        ba.at.g = g();\n        ba.at.n = n();\n\n        ba.ae = r();\n\n\n        if (m != 0) {\n            ba.p = m;\n        }\n\n        for (uint256 i; i < bg.length;) {\n            ba.bj.push(bg[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(au, aq(), av, bf, az, bg, m);\n\n        al.x(au);\n    }\n\n\n    function bk(uint256 ak, address bn, VoteOption ah) public view returns (bool) {\n        if (!v(ak)) {\n            revert NonexistentProposal(ak);\n        }\n\n        Proposal storage ba = bb[ak];\n        return bd(ba, bn, ah, al.o(bn));\n    }\n\n\n    function bv(uint256 ak, address bn, VoteOption ah, uint256 s)\n        public\n        override\n        bt(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage ba = bb[ak];\n\n        if (!bd(ba, bn, ah, s)) {\n            revert VoteCastForbidden(ak, bn);\n        }\n\n\n        if (ah == ba.bp[bn].ap) {\n\n            if (s == ba.bp[bn].aj) return;\n\n\n            uint256 bu = s - ba.bp[bn].aj;\n            ba.bp[bn].aj = s;\n\n            if (ba.bp[bn].ap == VoteOption.Yes) {\n                ba.br.bx += bu;\n            } else if (ba.bp[bn].ap == VoteOption.No) {\n                ba.br.bz += bu;\n            } else {\n\n                ba.br.bi += bu;\n            }\n        } else {\n\n\n            if (ba.bp[bn].aj > 0) {\n\n                if (ba.bp[bn].ap == VoteOption.Yes) {\n                    ba.br.bx -= ba.bp[bn].aj;\n                } else if (ba.bp[bn].ap == VoteOption.No) {\n                    ba.br.bz -= ba.bp[bn].aj;\n                } else {\n\n                    ba.br.bi -= ba.bp[bn].aj;\n                }\n            }\n\n\n            if (ah == VoteOption.Yes) {\n                ba.br.bx += s;\n            } else if (ah == VoteOption.No) {\n                ba.br.bz += s;\n            } else {\n\n                ba.br.bi += s;\n            }\n            ba.bp[bn].ap = ah;\n            ba.bp[bn].aj = s;\n        }\n\n        emit VoteCast(ak, bn, ah, s);\n\n        if (ba.at.ar == VotingMode.EarlyExecution) {\n            c(ak, aq());\n        }\n    }\n\n\n    function ay(uint256 ak, address bn) external bt(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage ba = bb[ak];\n        if (!u(ba)) {\n            revert VoteRemovalForbidden(ak, bn);\n        } else if (ba.at.ar != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(ak, bn);\n        } else if (ba.bp[bn].aj == 0) {\n\n            return;\n        }\n\n\n        if (ba.bp[bn].ap == VoteOption.Yes) {\n            ba.br.bx -= ba.bp[bn].aj;\n        } else if (ba.bp[bn].ap == VoteOption.No) {\n            ba.br.bz -= ba.bp[bn].aj;\n        }\n\n        else if (ba.bp[bn].ap == VoteOption.Abstain) {\n            ba.br.bi -= ba.bp[bn].aj;\n        }\n        ba.bp[bn].aj = 0;\n\n        emit VoteCleared(ak, bn);\n    }\n\n\n    function y(uint256 ak) external view returns (bool) {\n        Proposal storage ba = bb[ak];\n        return u(ba);\n    }\n\n\n    function d() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.d();\n    }\n\n\n    function i() public view override returns (uint256) {\n        return IERC20(al.bo()).ao();\n    }\n\n\n    function t(uint256 ak, address bn) public view returns (uint256) {\n        return bb[ak].bp[bn].aj;\n    }\n\n\n    function bd(Proposal storage ba, address bn, VoteOption ah, uint256 s)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 h = ba.bp[bn].aj;\n\n\n        if (!u(ba)) {\n            return false;\n        } else if (ah == VoteOption.None) {\n            return false;\n        }\n\n        else if (ba.at.ar != VotingMode.VoteReplacement) {\n\n            if (s <= h) {\n                return false;\n            }\n\n            else if (\n                ba.bp[bn].ap != VoteOption.None\n                    && ah != ba.bp[bn].ap\n            ) {\n                return false;\n            }\n        }\n\n        else {\n\n            if (s == 0 || s < h) {\n                return false;\n            }\n\n            else if (s == h && ah == ba.bp[bn].ap) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function c(uint256 ak, address am) internal {\n        if (!ai(ak)) {\n            return;\n        } else if (!by().aa(address(this), am, EXECUTE_PROPOSAL_PERMISSION_ID, bc())) {\n            return;\n        }\n\n        be(ak);\n    }\n\n    function be(uint256 ak) internal override {\n        super.be(ak);\n\n\n        al.ad(ak);\n    }\n\n\n    uint256[50] private __gap;\n}",
      "rename_map": {
        "onlyCallAtInitialization": "a",
        "customProposalParamsABI": "b",
        "_attemptEarlyExecution": "c",
        "minProposerVotingPower": "d",
        "_validateProposalDates": "e",
        "supportThresholdRatio": "f",
        "minParticipationRatio": "g",
        "_currentVotingPower": "h",
        "currentTokenSupply": "i",
        "supportsInterface": "j",
        "_createProposalId": "k",
        "definingContract": "l",
        "_allowFailureMap": "m",
        "minApprovalRatio": "n",
        "getLockedBalance": "o",
        "allowFailureMap": "p",
        "_votingSettings": "q",
        "getTargetConfig": "r",
        "_newVotingPower": "s",
        "usedVotingPower": "t",
        "_isProposalOpen": "u",
        "_proposalExists": "v",
        "_pluginMetadata": "w",
        "proposalCreated": "x",
        "isProposalOpen": "y",
        "createProposal": "z",
        "hasPermission": "aa",
        "_targetConfig": "ab",
        "reinitializer": "ac",
        "proposalEnded": "ad",
        "targetConfig": "ae",
        "_lockManager": "af",
        "_interfaceId": "ag",
        "_voteOption": "ah",
        "_canExecute": "ai",
        "votingPower": "aj",
        "_proposalId": "ak",
        "lockManager": "al",
        "_voteCaller": "am",
        "interfaceId": "an",
        "totalSupply": "ao",
        "voteOption": "ap",
        "_msgSender": "aq",
        "votingMode": "ar",
        "initialize": "as",
        "parameters": "at",
        "proposalId": "au",
        "_startDate": "av",
        "startDate": "aw",
        "keccak256": "ax",
        "clearVote": "ay",
        "_metadata": "az",
        "proposal_": "ba",
        "proposals": "bb",
        "_msgData": "bc",
        "_canVote": "bd",
        "_execute": "be",
        "_endDate": "bf",
        "_actions": "bg",
        "endDate": "bh",
        "abstain": "bi",
        "actions": "bj",
        "canVote": "bk",
        "encode": "bl",
        "decode": "bm",
        "_voter": "bn",
        "token": "bo",
        "votes": "bp",
        "_data": "bq",
        "tally": "br",
        "voter": "bs",
        "auth": "bt",
        "diff": "bu",
        "vote": "bv",
        "_dao": "bw",
        "yes": "bx",
        "dao": "by",
        "no": "bz"
      },
      "changes": [
        "Renamed 78 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_019",
      "transformed_id": "ss_l2_short_nc_gs_019",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.23;\n\nimport {ReentrancyGuardTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\n\ncontract MidasRedemptionVaultGateway is ReentrancyGuardTrait, IMidasRedemptionVaultGateway {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant override s = \"GATEWAY::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override ag = 3_10;\n\n    address public immutable d;\n    address public immutable ah;\n\n    mapping(address => PendingRedemption) public e;\n\n\n    constructor(address c) {\n        d = c;\n        ah = IMidasRedemptionVault(c).ah();\n    }\n\n\n    function n(address ae, uint256 l, uint256 h) external t {\n        IERC20(ah).f(msg.sender, address(this), l);\n\n        uint256 p = IERC20(ae).z(address(this));\n\n        IERC20(ah).u(d, l);\n        IMidasRedemptionVault(d).n(ae, l, h);\n\n        uint256 ai = IERC20(ae).z(address(this)) - p;\n\n        IERC20(ae).q(msg.sender, ai);\n    }\n\n\n    function o(address ae, uint256 l) external t {\n        if (e[msg.sender].ac) {\n            revert(\"MidasRedemptionVaultGateway: user has a pending redemption\");\n        }\n\n        uint256 x = IMidasRedemptionVault(d).g();\n\n        IERC20(ah).f(msg.sender, address(this), l);\n\n        IERC20(ah).u(d, l);\n        IMidasRedemptionVault(d).m(ae, l);\n\n        e[msg.sender] =\n            PendingRedemption({ac: true, x: x, timestamp: block.timestamp, y: 0});\n    }\n\n\n    function ab(uint256 ai) external t {\n        PendingRedemption memory af = e[msg.sender];\n\n        if (!af.ac) {\n            revert(\"MidasRedemptionVaultGateway: user does not have a pending redemption\");\n        }\n\n        (\n            address sender,\n            address ae,\n            uint8 aj,\n            uint256 l,\n            uint256 w,\n            uint256 r\n        ) = IMidasRedemptionVault(d).k(af.x);\n\n        if (sender != address(this)) {\n            revert(\"MidasRedemptionVaultGateway: invalid request\");\n        }\n\n        if (aj != 1) {\n            revert(\"MidasRedemptionVaultGateway: redemption not fulfilled\");\n        }\n\n        uint256 i;\n\n        if (af.y > 0) {\n            i = af.y;\n        } else {\n            i = a(l, w, r, ae);\n        }\n\n        if (ai > i) {\n            revert(\"MidasRedemptionVaultGateway: amount exceeds available\");\n        }\n\n        if (ai == i) {\n            delete e[msg.sender];\n        } else {\n            e[msg.sender].y = i - ai;\n        }\n\n        IERC20(ae).q(msg.sender, ai);\n    }\n\n\n    function b(address ak, address ae) external view returns (uint256) {\n        PendingRedemption memory af = e[ak];\n\n        if (!af.ac) {\n            return 0;\n        }\n\n        (address sender, address j,, uint256 l, uint256 w, uint256 r) =\n            IMidasRedemptionVault(d).k(af.x);\n\n        if (sender != address(this) || j != ae) {\n            return 0;\n        }\n\n        if (af.y > 0) {\n            return af.y;\n        } else {\n            return a(l, w, r, ae);\n        }\n    }\n\n\n    function a(\n        uint256 l,\n        uint256 w,\n        uint256 r,\n        address ae\n    ) internal view returns (uint256) {\n        uint256 v = (l * w) / r;\n\n        uint256 aa = 10 ** IERC20Metadata(ae).ad();\n\n        return v * aa / 1e18;\n    }\n}",
      "rename_map": {
        "_calculateTokenOutAmount": "a",
        "pendingTokenOutAmount": "b",
        "_midasRedemptionVault": "c",
        "midasRedemptionVault": "d",
        "pendingRedemptions": "e",
        "safeTransferFrom": "f",
        "currentRequestId": "g",
        "minReceiveAmount": "h",
        "availableAmount": "i",
        "requestTokenOut": "j",
        "redeemRequests": "k",
        "amountMTokenIn": "l",
        "redeemRequest": "m",
        "redeemInstant": "n",
        "requestRedeem": "o",
        "balanceBefore": "p",
        "safeTransfer": "q",
        "tokenOutRate": "r",
        "contractType": "s",
        "nonReentrant": "t",
        "forceApprove": "u",
        "amount1e18": "v",
        "mTokenRate": "w",
        "requestId": "x",
        "remainder": "y",
        "balanceOf": "z",
        "tokenUnit": "aa",
        "withdraw": "ab",
        "isActive": "ac",
        "decimals": "ad",
        "tokenOut": "ae",
        "pending": "af",
        "version": "ag",
        "mToken": "ah",
        "amount": "ai",
        "status": "aj",
        "user": "ak"
      },
      "changes": [
        "Renamed 37 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_020",
      "transformed_id": "ss_l2_short_nc_gs_020",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\nimport {NotImplementedException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultAdapter} from \"../../interfaces/midas/IMidasRedemptionVaultAdapter.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\nimport {WAD, RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\n\n\ncontract MidasRedemptionVaultAdapter is AbstractAdapter, IMidasRedemptionVaultAdapter {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 public constant override ac = \"ADAPTER::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override ap = 3_10;\n\n\n    address public immutable override au;\n\n\n    address public immutable override as;\n\n\n    mapping(address => address) public c;\n\n\n    mapping(address => address) public b;\n\n\n    EnumerableSet.AddressSet internal m;\n\n\n    constructor(address p, address al) AbstractAdapter(p, al) {\n        as = al;\n        au = IMidasRedemptionVaultGateway(al).au();\n\n        i(au);\n    }\n\n\n    function z(address am, uint256 t, uint256 j)\n        external\n        override\n        k\n        returns (bool)\n    {\n        if (!n(am)) revert TokenNotAllowedException();\n\n        o(am, t, j);\n\n        return false;\n    }\n\n\n    function g(address am, uint256 q, uint256 ae)\n        external\n        override\n        k\n        returns (bool)\n    {\n        if (!n(am)) revert TokenNotAllowedException();\n\n        address y = r();\n\n        uint256 balance = IERC20(au).ag(y);\n        if (balance > q) {\n            unchecked {\n                uint256 av = balance - q;\n                uint256 j = (av * ae) / RAY;\n                o(am, av, j);\n            }\n        }\n        return false;\n    }\n\n\n    function o(address am, uint256 t, uint256 j) internal {\n        d(\n            au,\n            abi.ad(\n                IMidasRedemptionVaultGateway.z,\n                (am, t, v(j, am))\n            )\n        );\n    }\n\n\n    function u(address am, uint256 t)\n        external\n        override\n        k\n        returns (bool)\n    {\n        if (!n(am) || b[am] == address(0)) {\n            revert TokenNotAllowedException();\n        }\n\n        d(\n            au, abi.ad(IMidasRedemptionVaultGateway.aa, (am, t))\n        );\n        return true;\n    }\n\n\n    function aj(uint256 av) external override k returns (bool) {\n        af(av);\n        return false;\n    }\n\n\n    function af(uint256 av) internal {\n        ao(abi.ad(IMidasRedemptionVaultGateway.aj, (av)));\n    }\n\n\n    function e(address az, uint256 av) external override k returns (bool) {\n        if (c[az] == address(0)) revert IncorrectStakedPhantomTokenException();\n        af(av);\n        return false;\n    }\n\n\n    function f(address, uint256) external pure override returns (bool) {\n        revert NotImplementedException();\n    }\n\n\n    function v(uint256 av, address az) internal view returns (uint256) {\n        uint256 ah = 10 ** IERC20Metadata(az).ak();\n        return av * WAD / ah;\n    }\n\n\n    function n(address az) public view override returns (bool) {\n        return m.an(az);\n    }\n\n\n    function w() public view override returns (address[] memory) {\n        return m.ay();\n    }\n\n\n    function a(MidasAllowedTokenStatus[] calldata aq)\n        external\n        override\n        h\n    {\n        uint256 ba = aq.length;\n\n        for (uint256 i; i < ba; ++i) {\n            MidasAllowedTokenStatus memory ax = aq[i];\n\n            if (ax.ar) {\n                i(ax.az);\n                m.bb(ax.az);\n\n                if (ax.ab != address(0)) {\n                    i(ax.ab);\n                    c[ax.ab] = ax.az;\n                    b[ax.az] = ax.ab;\n                }\n            } else {\n                m.aw(ax.az);\n\n                address ab = b[ax.az];\n\n                if (ab != address(0)) {\n                    delete b[ax.az];\n                    delete c[ab];\n                }\n            }\n\n            emit SetTokenAllowedStatus(ax.az, ax.ab, ax.ar);\n        }\n    }\n\n\n    function ai() external view returns (bytes memory l) {\n        l = abi.at(x, s, as, au, w());\n    }\n}",
      "rename_map": {
        "setTokenAllowedStatusBatch": "a",
        "outputTokenToPhantomToken": "b",
        "phantomTokenToOutputToken": "c",
        "_executeSwapSafeApprove": "d",
        "withdrawPhantomToken": "e",
        "depositPhantomToken": "f",
        "redeemInstantDiff": "g",
        "configuratorOnly": "h",
        "_getMaskOrRevert": "i",
        "minReceiveAmount": "j",
        "creditFacadeOnly": "k",
        "serializedData": "l",
        "_allowedTokens": "m",
        "isTokenAllowed": "n",
        "_redeemInstant": "o",
        "_creditManager": "p",
        "leftoverAmount": "q",
        "_creditAccount": "r",
        "targetContract": "s",
        "amountMTokenIn": "t",
        "redeemRequest": "u",
        "_convertToE18": "v",
        "allowedTokens": "w",
        "creditManager": "x",
        "creditAccount": "y",
        "redeemInstant": "z",
        "requestRedeem": "aa",
        "phantomToken": "ab",
        "contractType": "ac",
        "encodeCall": "ad",
        "rateMinRAY": "ae",
        "_withdraw": "af",
        "balanceOf": "ag",
        "tokenUnit": "ah",
        "serialize": "ai",
        "withdraw": "aj",
        "decimals": "ak",
        "_gateway": "al",
        "tokenOut": "am",
        "contains": "an",
        "_execute": "ao",
        "version": "ap",
        "configs": "aq",
        "allowed": "ar",
        "gateway": "as",
        "encode": "at",
        "mToken": "au",
        "amount": "av",
        "remove": "aw",
        "config": "ax",
        "values": "ay",
        "token": "az",
        "len": "ba",
        "add": "bb"
      },
      "changes": [
        "Renamed 54 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_021",
      "transformed_id": "ss_l2_short_nc_gs_021",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, x} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n\n  error NotPoolManager();\n\n\n  IPoolManager public immutable ah;\n\n  constructor(\n    IPoolManager ab,\n    address ad,\n    address[] memory c,\n    address n,\n    address k\n  ) BaseKEMHook(ad, c, n, k) {\n    ah = ab;\n    Hooks.d(IHooks(address(this)), j());\n  }\n\n\n  modifier t() {\n    if (msg.sender != address(ah)) revert NotPoolManager();\n    _;\n  }\n\n\n  function z(address[] calldata bf, uint256[] calldata ay) public {\n    require(an[msg.sender], NonClaimableAccount(msg.sender));\n    require(bf.length == ay.length, MismatchedArrayLengths());\n\n    ah.bc(abi.bb(bf, ay));\n  }\n\n  function y(bytes calldata data) public t returns (bytes memory) {\n    (address[] memory bf, uint256[] memory ay) = abi.bh(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < bf.length; i++) {\n      uint256 bq = uint256(uint160(bf[i]));\n      if (ay[i] == 0) {\n        ay[i] = ah.aq(address(this), bq);\n      }\n      if (ay[i] > 0) {\n        ah.bk(address(this), bq, ay[i]);\n        ah.bn(Currency.bl(bf[i]), ag, ay[i]);\n      }\n    }\n\n    emit ClaimEgTokens(ag, bf, ay);\n  }\n\n  function j() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      s: false,\n      u: false,\n      l: false,\n      r: false,\n      e: false,\n      h: false,\n      al: true,\n      ar: true,\n      aa: false,\n      ae: false,\n      f: false,\n      g: true,\n      b: false,\n      a: false\n    });\n  }\n\n  function al(\n    address sender,\n    PoolKey calldata bp,\n    IPoolManager.SwapParams calldata be,\n    bytes calldata aw\n  ) external t returns (bytes4, BeforeSwapDelta, uint24) {\n    require(be.v < 0, ExactOutputDisabled());\n\n    (\n      int256 aj,\n      int256 w,\n      int256 q,\n      uint256 bj,\n      uint256 ak,\n      bytes memory ap\n    ) = HookDataDecoder.p(aw);\n\n    require(block.timestamp <= ak, ExpiredSignature(ak, block.timestamp));\n    require(\n      -be.v <= aj,\n      ExceededMaxAmountIn(aj, -be.v)\n    );\n\n    m(bj);\n\n    bytes32 bd = as(\n      abi.bb(\n        sender,\n        bp,\n        be.am,\n        aj,\n        w,\n        q,\n        bj,\n        ak\n      )\n    );\n    require(\n      SignatureChecker.i(af, bd, ap), InvalidSignature()\n    );\n\n    return (this.al.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function ar(\n    address,\n    PoolKey calldata bp,\n    IPoolManager.SwapParams calldata be,\n    BalanceDelta bi,\n    bytes calldata aw\n  ) external t returns (bytes4, int128) {\n    (int256 w, int256 q) =\n      HookDataDecoder.o(aw);\n\n    int128 ax;\n    int128 ao;\n    Currency ai;\n    unchecked {\n      if (be.am) {\n        ax = -bi.ba();\n        ao = bi.az();\n        ai = bp.au;\n      } else {\n        ax = -bi.az();\n        ao = bi.ba();\n        ai = bp.at;\n      }\n    }\n\n    int256 ac = ax * w / q;\n\n    unchecked {\n      int256 av = ac < ao ? ao - ac : int256(0);\n      if (av > 0) {\n        ah.bo(\n          address(this), uint256(uint160(Currency.bg(ai))), uint256(av)\n        );\n\n        emit AbsorbEgToken(PoolId.bg(bp.bm()), Currency.bg(ai), av);\n      }\n\n      return (this.ar.selector, int128(av));\n    }\n  }\n}",
      "rename_map": {
        "afterRemoveLiquidityReturnDelta": "a",
        "afterAddLiquidityReturnDelta": "b",
        "initialClaimableAccounts": "c",
        "validateHookPermissions": "d",
        "beforeRemoveLiquidity": "e",
        "beforeSwapReturnDelta": "f",
        "afterSwapReturnDelta": "g",
        "afterRemoveLiquidity": "h",
        "isValidSignatureNow": "i",
        "getHookPermissions": "j",
        "initialEgRecipient": "k",
        "beforeAddLiquidity": "l",
        "_useUnorderedNonce": "m",
        "initialQuoteSigner": "n",
        "decodeExchangeRate": "o",
        "decodeAllHookData": "p",
        "exchangeRateDenom": "q",
        "afterAddLiquidity": "r",
        "beforeInitialize": "s",
        "onlyPoolManager": "t",
        "afterInitialize": "u",
        "amountSpecified": "v",
        "maxExchangeRate": "w",
        "toBalanceDelta": "x",
        "unlockCallback": "y",
        "claimEgTokens": "z",
        "beforeDonate": "aa",
        "_poolManager": "ab",
        "maxAmountOut": "ac",
        "initialOwner": "ad",
        "afterDonate": "ae",
        "quoteSigner": "af",
        "egRecipient": "ag",
        "poolManager": "ah",
        "currencyOut": "ai",
        "maxAmountIn": "aj",
        "expiryTime": "ak",
        "beforeSwap": "al",
        "zeroForOne": "am",
        "claimable": "an",
        "amountOut": "ao",
        "signature": "ap",
        "balanceOf": "aq",
        "afterSwap": "ar",
        "keccak256": "as",
        "currency0": "at",
        "currency1": "au",
        "egAmount": "av",
        "hookData": "aw",
        "amountIn": "ax",
        "amounts": "ay",
        "amount1": "az",
        "amount0": "ba",
        "encode": "bb",
        "unlock": "bc",
        "digest": "bd",
        "params": "be",
        "tokens": "bf",
        "unwrap": "bg",
        "decode": "bh",
        "delta": "bi",
        "nonce": "bj",
        "burn": "bk",
        "wrap": "bl",
        "toId": "bm",
        "take": "bn",
        "mint": "bo",
        "key": "bp",
        "id": "bq"
      },
      "changes": [
        "Renamed 69 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_022",
      "transformed_id": "ss_l2_short_nc_gs_022",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, x} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n\n  error NotPoolManager();\n\n\n  IPoolManager public immutable ah;\n\n  constructor(\n    IPoolManager ab,\n    address ad,\n    address[] memory c,\n    address n,\n    address k\n  ) BaseKEMHook(ad, c, n, k) {\n    ah = ab;\n    Hooks.d(IHooks(address(this)), j());\n  }\n\n\n  modifier t() {\n    if (msg.sender != address(ah)) revert NotPoolManager();\n    _;\n  }\n\n\n  function z(address[] calldata bf, uint256[] calldata ay) public {\n    require(an[msg.sender], NonClaimableAccount(msg.sender));\n    require(bf.length == ay.length, MismatchedArrayLengths());\n\n    ah.bc(abi.bb(bf, ay));\n  }\n\n  function y(bytes calldata data) public t returns (bytes memory) {\n    (address[] memory bf, uint256[] memory ay) = abi.bh(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < bf.length; i++) {\n      uint256 bq = uint256(uint160(bf[i]));\n      if (ay[i] == 0) {\n        ay[i] = ah.aq(address(this), bq);\n      }\n      if (ay[i] > 0) {\n        ah.bk(address(this), bq, ay[i]);\n        ah.bn(Currency.bl(bf[i]), ag, ay[i]);\n      }\n    }\n\n    emit ClaimEgTokens(ag, bf, ay);\n  }\n\n  function j() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      s: false,\n      u: false,\n      l: false,\n      r: false,\n      e: false,\n      h: false,\n      al: true,\n      ar: true,\n      aa: false,\n      ae: false,\n      f: false,\n      g: true,\n      b: false,\n      a: false\n    });\n  }\n\n  function al(\n    address sender,\n    PoolKey calldata bp,\n    IPoolManager.SwapParams calldata be,\n    bytes calldata aw\n  ) external t returns (bytes4, BeforeSwapDelta, uint24) {\n    require(be.v < 0, ExactOutputDisabled());\n\n    (\n      int256 aj,\n      int256 w,\n      int256 q,\n      uint256 bj,\n      uint256 ak,\n      bytes memory ap\n    ) = HookDataDecoder.p(aw);\n\n    require(block.timestamp <= ak, ExpiredSignature(ak, block.timestamp));\n    require(\n      -be.v <= aj,\n      ExceededMaxAmountIn(aj, -be.v)\n    );\n\n    m(bj);\n\n    bytes32 bd = as(\n      abi.bb(\n        sender,\n        bp,\n        be.am,\n        aj,\n        w,\n        q,\n        bj,\n        ak\n      )\n    );\n    require(\n      SignatureChecker.i(af, bd, ap), InvalidSignature()\n    );\n\n    return (this.al.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function ar(\n    address,\n    PoolKey calldata bp,\n    IPoolManager.SwapParams calldata be,\n    BalanceDelta bi,\n    bytes calldata aw\n  ) external t returns (bytes4, int128) {\n    (int256 w, int256 q) =\n      HookDataDecoder.o(aw);\n\n    int128 ax;\n    int128 ao;\n    Currency ai;\n    unchecked {\n      if (be.am) {\n        ax = -bi.ba();\n        ao = bi.az();\n        ai = bp.au;\n      } else {\n        ax = -bi.az();\n        ao = bi.ba();\n        ai = bp.at;\n      }\n    }\n\n    int256 ac = ax * w / q;\n\n    unchecked {\n      int256 av = ac < ao ? ao - ac : int256(0);\n      if (av > 0) {\n        ah.bo(\n          address(this), uint256(uint160(Currency.bg(ai))), uint256(av)\n        );\n\n        emit AbsorbEgToken(PoolId.bg(bp.bm()), Currency.bg(ai), av);\n      }\n\n      return (this.ar.selector, int128(av));\n    }\n  }\n}",
      "rename_map": {
        "afterRemoveLiquidityReturnDelta": "a",
        "afterAddLiquidityReturnDelta": "b",
        "initialClaimableAccounts": "c",
        "validateHookPermissions": "d",
        "beforeRemoveLiquidity": "e",
        "beforeSwapReturnDelta": "f",
        "afterSwapReturnDelta": "g",
        "afterRemoveLiquidity": "h",
        "isValidSignatureNow": "i",
        "getHookPermissions": "j",
        "initialEgRecipient": "k",
        "beforeAddLiquidity": "l",
        "_useUnorderedNonce": "m",
        "initialQuoteSigner": "n",
        "decodeExchangeRate": "o",
        "decodeAllHookData": "p",
        "exchangeRateDenom": "q",
        "afterAddLiquidity": "r",
        "beforeInitialize": "s",
        "onlyPoolManager": "t",
        "afterInitialize": "u",
        "amountSpecified": "v",
        "maxExchangeRate": "w",
        "toBalanceDelta": "x",
        "unlockCallback": "y",
        "claimEgTokens": "z",
        "beforeDonate": "aa",
        "_poolManager": "ab",
        "maxAmountOut": "ac",
        "initialOwner": "ad",
        "afterDonate": "ae",
        "quoteSigner": "af",
        "egRecipient": "ag",
        "poolManager": "ah",
        "currencyOut": "ai",
        "maxAmountIn": "aj",
        "expiryTime": "ak",
        "beforeSwap": "al",
        "zeroForOne": "am",
        "claimable": "an",
        "amountOut": "ao",
        "signature": "ap",
        "balanceOf": "aq",
        "afterSwap": "ar",
        "keccak256": "as",
        "currency0": "at",
        "currency1": "au",
        "egAmount": "av",
        "hookData": "aw",
        "amountIn": "ax",
        "amounts": "ay",
        "amount1": "az",
        "amount0": "ba",
        "encode": "bb",
        "unlock": "bc",
        "digest": "bd",
        "params": "be",
        "tokens": "bf",
        "unwrap": "bg",
        "decode": "bh",
        "delta": "bi",
        "nonce": "bj",
        "burn": "bk",
        "wrap": "bl",
        "toId": "bm",
        "take": "bn",
        "mint": "bo",
        "key": "bp",
        "id": "bq"
      },
      "changes": [
        "Renamed 69 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_023",
      "transformed_id": "ss_l2_short_nc_gs_023",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed ca, uint256 cm);\n    event ETHReturnedToStaking(uint256 cm);\n    event ETHAllocatedToManager(uint256 indexed ca, uint256 cm);\n    event ETHReceivedFromStaking(uint256 cm);\n    event FeesCollected(uint256 cm);\n    event InterestClaimed(\n        uint256 indexed ca,\n        uint256 bj\n    );\n    event InterestToppedUp(\n        uint256 cm\n    );\n}\n\n\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = cc(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = cc(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = cc(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = cc(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant h = 10_000;\n\n\n    IStakingReturnsWrite public bf;\n\n\n    IPauserRead public cl;\n\n\n    uint256 public ae;\n\n\n    mapping(uint256 => PositionManagerConfig) public r;\n\n\n    mapping(uint256 => PositionAccountant) public al;\n\n\n    uint256 public ao;\n\n\n    uint256 public aq;\n\n\n    uint256 public x;\n\n\n    uint256 public ac;\n\n\n    uint256 public t;\n\n\n    uint256 public l;\n\n\n    uint256 public ar;\n\n\n    uint256 public aw;\n\n\n    address payable public br;\n\n\n    uint16 public bd;\n\n    uint256 public am;\n\n\n    uint256 public bg;\n\n\n    uint256 public ay;\n\n\n    bool public m;\n\n    mapping(address => bool) public ah;\n\n    struct Init {\n        address cp;\n        address az;\n        address be;\n        address bp;\n        address bc;\n        address payable br;\n        IStakingReturnsWrite cj;\n        IPauserRead cl;\n    }\n\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n\n\n    constructor() {\n        ab();\n    }\n\n    function bx(Init memory cs) external bt {\n\n        __AccessControlEnumerable_init();\n\n        bw(DEFAULT_ADMIN_ROLE, cs.cp);\n        bw(LIQUIDITY_MANAGER_ROLE, cs.az);\n        bw(POSITION_MANAGER_ROLE, cs.be);\n        bw(INTEREST_TOPUP_ROLE, cs.bp);\n        bw(DRAWDOWN_MANAGER_ROLE, cs.bc);\n\n        bf = cs.cj;\n        cl = cs.cl;\n        br = cs.br;\n        m = true;\n\n        bw(LIQUIDITY_MANAGER_ROLE, address(bf));\n    }\n\n\n    function at(uint256 ca) public view returns (uint256) {\n        PositionManagerConfig memory co = r[ca];\n\n        IPositionManager ci = IPositionManager(co.bh);\n        uint256 bl = ci.y();\n\n\n        PositionAccountant memory by = al[ca];\n\n        if (bl > by.ax) {\n            return bl - by.ax;\n        }\n\n        return 0;\n    }\n\n    function ad() public view returns (uint256) {\n        return l - x;\n    }\n\n    function aj() public view returns (uint256) {\n        return ao - aq;\n    }\n\n    function z() public view returns (uint256) {\n        uint256 bs = address(this).balance;\n\n\n        for (uint256 i = 0; i < ae; i++) {\n            PositionManagerConfig storage co = r[i];\n            if (co.cf) {\n                IPositionManager ci = IPositionManager(co.bh);\n                uint256 bo = ci.y();\n                bs += bo;\n            }\n        }\n\n        return bs;\n    }\n\n\n    function an(\n        address bh,\n        uint256 bq\n    ) external cg(POSITION_MANAGER_ROLE) returns (uint256 ca) {\n        if (ah[bh]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        ca = ae;\n        ae++;\n\n        r[ca] = PositionManagerConfig({\n            bh: bh,\n            bq: bq,\n            cf: true\n        });\n        al[ca] = PositionAccountant({\n            ax: 0,\n            g: 0\n        });\n        ah[bh] = true;\n\n        l += bq;\n        emit ProtocolConfigChanged(\n            this.an.selector,\n            \"addPositionManager(address,uint256)\",\n            abi.ck(bh, bq)\n        );\n    }\n\n    function s(\n        uint256 ca,\n        uint256 ba,\n        bool cf\n    ) external cg(POSITION_MANAGER_ROLE) {\n        if (ca >= ae) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage co = r[ca];\n\n        if (ba < al[ca].ax) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n\n        l = l - co.bq + ba;\n\n        co.bq = ba;\n        co.cf = cf;\n\n        emit ProtocolConfigChanged(\n            this.s.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi.ck(ca, ba, cf)\n        );\n    }\n\n    function e(uint256 ca) external cg(POSITION_MANAGER_ROLE) {\n        if (ca >= ae) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage co = r[ca];\n        co.cf = !co.cf;\n\n        emit ProtocolConfigChanged(\n            this.e.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi.ck(ca)\n        );\n    }\n\n    function v(uint256 bk) external cg(DRAWDOWN_MANAGER_ROLE) {\n        ar = bk;\n\n        emit ProtocolConfigChanged(\n            this.v.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi.ck(bk)\n        );\n    }\n\n    function ag(uint256 ai) external cg(POSITION_MANAGER_ROLE) {\n        if (ai >= ae) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!r[ai].cf) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        aw = ai;\n\n        emit ProtocolConfigChanged(\n            this.ag.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi.ck(ai)\n        );\n    }\n\n\n    function as(uint16 bm) external cg(POSITION_MANAGER_ROLE) {\n        if (bm > h) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        bd = bm;\n        emit ProtocolConfigChanged(\n            this.as.selector, \"setFeeBasisPoints(uint16)\", abi.ck(bm)\n        );\n    }\n\n\n    function bb(address payable bu)\n        external\n        cg(POSITION_MANAGER_ROLE)\n        bi(bu)\n    {\n        br = bu;\n        emit ProtocolConfigChanged(this.bb.selector, \"setFeesReceiver(address)\", abi.ck(bu));\n    }\n\n\n    function f(bool au) external cg(POSITION_MANAGER_ROLE) {\n        m = au;\n        emit ProtocolConfigChanged(this.f.selector, \"setShouldExecuteAllocation(bool)\", abi.ck(au));\n    }\n\n\n    function bz() external payable cg(LIQUIDITY_MANAGER_ROLE) {\n        if (cl.n()) revert LiquidityBuffer__Paused();\n        p(msg.value);\n        if (m) {\n            w(aw, msg.value);\n        }\n    }\n\n    function av(uint256 ca, uint256 cm) external cg(LIQUIDITY_MANAGER_ROLE) {\n        k(ca, cm);\n        af(cm);\n    }\n\n    function aa(uint256 ca, uint256 cm) external cg(LIQUIDITY_MANAGER_ROLE) {\n        w(ca, cm);\n    }\n\n    function q(uint256 ca, uint256 cm) external cg(LIQUIDITY_MANAGER_ROLE) {\n        k(ca, cm);\n    }\n\n    function ap(uint256 cm) external cg(LIQUIDITY_MANAGER_ROLE) {\n        af(cm);\n    }\n\n    function c() external payable d {\n\n\n    }\n\n\n    function j(uint256 ca, uint256 cd) external cg(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 cm = i(ca);\n        if (cm < cd) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return cm;\n    }\n\n    function o(uint256 cm) external cg(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < cm) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        a(cm);\n        return cm;\n    }\n\n    function u(uint256 ca, uint256 cd) external cg(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 cm = i(ca);\n        if (cm < cd) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        a(cm);\n\n        return cm;\n    }\n\n\n    function a(uint256 cm) internal {\n        if (cl.n()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (cm > bg) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        bg -= cm;\n        uint256 cr = Math.cn(bd, cm, h);\n        uint256 bv = cm - cr;\n        bf.cq{value: bv}();\n        t += bv;\n        emit InterestToppedUp(bv);\n\n        if (cr > 0) {\n            Address.cb(br, cr);\n            am += cr;\n            emit FeesCollected(cr);\n        }\n    }\n\n    function i(uint256 ca) internal returns (uint256) {\n        if (cl.n()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        uint256 bj = at(ca);\n\n        if (bj > 0) {\n            PositionManagerConfig memory co = r[ca];\n\n\n            al[ca].g += bj;\n            ac += bj;\n            bg += bj;\n            emit InterestClaimed(ca, bj);\n\n\n            IPositionManager ci = IPositionManager(co.bh);\n            ci.ce(bj);\n        } else {\n            emit InterestClaimed(ca, bj);\n        }\n\n        return bj;\n    }\n\n    function k(uint256 ca, uint256 cm) internal {\n        if (cl.n()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (ca >= ae) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory co = r[ca];\n        if (!co.cf) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage by = al[ca];\n\n\n        if (cm > by.ax) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n\n        by.ax -= cm;\n        x -= cm;\n        ay += cm;\n        emit ETHWithdrawnFromManager(ca, cm);\n\n\n        IPositionManager ci = IPositionManager(co.bh);\n        ci.ce(cm);\n    }\n\n    function af(uint256 cm) internal {\n        if (cl.n()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n\n        if (address(bf) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (cm > ay) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n\n        aq += cm;\n        ay -= cm;\n        emit ETHReturnedToStaking(cm);\n\n\n        bf.b{value: cm}();\n    }\n\n    function w(uint256 ca, uint256 cm) internal {\n        if (cl.n()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (cm > ay) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (ca >= ae) revert LiquidityBuffer__ManagerNotFound();\n\n        if (address(this).balance < cm) revert LiquidityBuffer__InsufficientBalance();\n\n\n        PositionManagerConfig memory co = r[ca];\n        if (!co.cf) revert LiquidityBuffer__ManagerInactive();\n\n        PositionAccountant storage by = al[ca];\n        if (by.ax + cm > co.bq) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n\n        by.ax += cm;\n        x += cm;\n        ay -= cm;\n        emit ETHAllocatedToManager(ca, cm);\n\n\n        IPositionManager ci = IPositionManager(co.bh);\n        ci.ch{value: cm}(0);\n    }\n\n    function p(uint256 cm) internal {\n        ao += cm;\n        ay += cm;\n        emit ETHReceivedFromStaking(cm);\n    }\n\n\n    modifier bi(address ct) {\n        if (ct == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n\n    modifier ak() {\n        if (msg.sender != address(bf)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier d() {\n        bool bn = false;\n\n\n        for (uint256 i = 0; i < ae; i++) {\n            PositionManagerConfig memory co = r[i];\n\n            if (msg.sender == co.bh && co.cf) {\n                bn = true;\n                break;\n            }\n        }\n\n        if (!bn) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "_topUpInterestToStakingAndCollectFees": "a",
        "receiveReturnsFromLiquidityBuffer": "b",
        "receiveETHFromPositionManager": "c",
        "onlyPositionManagerContract": "d",
        "togglePositionManagerStatus": "e",
        "setShouldExecuteAllocation": "f",
        "interestClaimedFromManager": "g",
        "_BASIS_POINTS_DENOMINATOR": "h",
        "_claimInterestFromManager": "i",
        "claimInterestFromManager": "j",
        "_withdrawETHFromManager": "k",
        "totalAllocationCapacity": "l",
        "shouldExecuteAllocation": "m",
        "isLiquidityBufferPaused": "n",
        "topUpInterestToStaking": "o",
        "_receiveETHFromStaking": "p",
        "withdrawETHFromManager": "q",
        "positionManagerConfigs": "r",
        "updatePositionManager": "s",
        "totalInterestToppedUp": "t",
        "claimInterestAndTopUp": "u",
        "setCumulativeDrawdown": "v",
        "_allocateETHToManager": "w",
        "totalAllocatedBalance": "x",
        "getUnderlyingBalance": "y",
        "getControlledBalance": "z",
        "allocateETHToManager": "aa",
        "_disableInitializers": "ab",
        "totalInterestClaimed": "ac",
        "getAvailableCapacity": "ad",
        "positionManagerCount": "ae",
        "_returnETHToStaking": "af",
        "setDefaultManagerId": "ag",
        "isRegisteredManager": "ah",
        "newDefaultManagerId": "ai",
        "getAvailableBalance": "aj",
        "onlyStakingContract": "ak",
        "positionAccountants": "al",
        "totalFeesCollected": "am",
        "addPositionManager": "an",
        "totalFundsReceived": "ao",
        "returnETHToStaking": "ap",
        "totalFundsReturned": "aq",
        "cumulativeDrawdown": "ar",
        "setFeeBasisPoints": "as",
        "getInterestAmount": "at",
        "executeAllocation": "au",
        "withdrawAndReturn": "av",
        "defaultManagerId": "aw",
        "allocatedBalance": "ax",
        "pendingPrincipal": "ay",
        "liquidityManager": "az",
        "newAllocationCap": "ba",
        "setFeesReceiver": "bb",
        "drawdownManager": "bc",
        "feesBasisPoints": "bd",
        "positionManager": "be",
        "stakingContract": "bf",
        "pendingInterest": "bg",
        "managerAddress": "bh",
        "notZeroAddress": "bi",
        "interestAmount": "bj",
        "drawdownAmount": "bk",
        "currentBalance": "bl",
        "newBasisPoints": "bm",
        "isValidManager": "bn",
        "managerBalance": "bo",
        "interestTopUp": "bp",
        "allocationCap": "bq",
        "feesReceiver": "br",
        "totalBalance": "bs",
        "initializer": "bt",
        "newReceiver": "bu",
        "topUpAmount": "bv",
        "_grantRole": "bw",
        "initialize": "bx",
        "accounting": "by",
        "depositETH": "bz",
        "managerId": "ca",
        "sendValue": "cb",
        "keccak256": "cc",
        "minAmount": "cd",
        "withdraw": "ce",
        "isActive": "cf",
        "onlyRole": "cg",
        "deposit": "ch",
        "manager": "ci",
        "staking": "cj",
        "encode": "ck",
        "pauser": "cl",
        "amount": "cm",
        "mulDiv": "cn",
        "config": "co",
        "admin": "cp",
        "topUp": "cq",
        "fees": "cr",
        "init": "cs",
        "addr": "ct"
      },
      "changes": [
        "Renamed 98 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_024",
      "transformed_id": "ss_l2_short_nc_gs_024",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed ca, uint256 cm);\n    event ETHReturnedToStaking(uint256 cm);\n    event ETHAllocatedToManager(uint256 indexed ca, uint256 cm);\n    event ETHReceivedFromStaking(uint256 cm);\n    event FeesCollected(uint256 cm);\n    event InterestClaimed(\n        uint256 indexed ca,\n        uint256 bj\n    );\n    event InterestToppedUp(\n        uint256 cm\n    );\n}\n\n\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = cc(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = cc(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = cc(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = cc(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant h = 10_000;\n\n\n    IStakingReturnsWrite public bf;\n\n\n    IPauserRead public cl;\n\n\n    uint256 public ae;\n\n\n    mapping(uint256 => PositionManagerConfig) public r;\n\n\n    mapping(uint256 => PositionAccountant) public al;\n\n\n    uint256 public ao;\n\n\n    uint256 public aq;\n\n\n    uint256 public x;\n\n\n    uint256 public ac;\n\n\n    uint256 public t;\n\n\n    uint256 public l;\n\n\n    uint256 public ar;\n\n\n    uint256 public aw;\n\n\n    address payable public br;\n\n\n    uint16 public bd;\n\n    uint256 public am;\n\n\n    uint256 public bg;\n\n\n    uint256 public ay;\n\n\n    bool public m;\n\n    mapping(address => bool) public ah;\n\n    struct Init {\n        address cp;\n        address az;\n        address be;\n        address bp;\n        address bc;\n        address payable br;\n        IStakingReturnsWrite cj;\n        IPauserRead cl;\n    }\n\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n\n\n    constructor() {\n        ab();\n    }\n\n    function bx(Init memory cs) external bt {\n\n        __AccessControlEnumerable_init();\n\n        bw(DEFAULT_ADMIN_ROLE, cs.cp);\n        bw(LIQUIDITY_MANAGER_ROLE, cs.az);\n        bw(POSITION_MANAGER_ROLE, cs.be);\n        bw(INTEREST_TOPUP_ROLE, cs.bp);\n        bw(DRAWDOWN_MANAGER_ROLE, cs.bc);\n\n        bf = cs.cj;\n        cl = cs.cl;\n        br = cs.br;\n        m = true;\n\n        bw(LIQUIDITY_MANAGER_ROLE, address(bf));\n    }\n\n\n    function at(uint256 ca) public view returns (uint256) {\n        PositionManagerConfig memory co = r[ca];\n\n        IPositionManager ci = IPositionManager(co.bh);\n        uint256 bl = ci.y();\n\n\n        PositionAccountant memory by = al[ca];\n\n        if (bl > by.ax) {\n            return bl - by.ax;\n        }\n\n        return 0;\n    }\n\n    function ad() public view returns (uint256) {\n        return l - x;\n    }\n\n    function aj() public view returns (uint256) {\n        return ao - aq;\n    }\n\n    function z() public view returns (uint256) {\n        uint256 bs = address(this).balance;\n\n\n        for (uint256 i = 0; i < ae; i++) {\n            PositionManagerConfig storage co = r[i];\n            if (co.cf) {\n                IPositionManager ci = IPositionManager(co.bh);\n                uint256 bo = ci.y();\n                bs += bo;\n            }\n        }\n\n        return bs;\n    }\n\n\n    function an(\n        address bh,\n        uint256 bq\n    ) external cg(POSITION_MANAGER_ROLE) returns (uint256 ca) {\n        if (ah[bh]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        ca = ae;\n        ae++;\n\n        r[ca] = PositionManagerConfig({\n            bh: bh,\n            bq: bq,\n            cf: true\n        });\n        al[ca] = PositionAccountant({\n            ax: 0,\n            g: 0\n        });\n        ah[bh] = true;\n\n        l += bq;\n        emit ProtocolConfigChanged(\n            this.an.selector,\n            \"addPositionManager(address,uint256)\",\n            abi.ck(bh, bq)\n        );\n    }\n\n    function s(\n        uint256 ca,\n        uint256 ba,\n        bool cf\n    ) external cg(POSITION_MANAGER_ROLE) {\n        if (ca >= ae) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage co = r[ca];\n\n        if (ba < al[ca].ax) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n\n        l = l - co.bq + ba;\n\n        co.bq = ba;\n        co.cf = cf;\n\n        emit ProtocolConfigChanged(\n            this.s.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi.ck(ca, ba, cf)\n        );\n    }\n\n    function e(uint256 ca) external cg(POSITION_MANAGER_ROLE) {\n        if (ca >= ae) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage co = r[ca];\n        co.cf = !co.cf;\n\n        emit ProtocolConfigChanged(\n            this.e.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi.ck(ca)\n        );\n    }\n\n    function v(uint256 bk) external cg(DRAWDOWN_MANAGER_ROLE) {\n        ar = bk;\n\n        emit ProtocolConfigChanged(\n            this.v.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi.ck(bk)\n        );\n    }\n\n    function ag(uint256 ai) external cg(POSITION_MANAGER_ROLE) {\n        if (ai >= ae) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!r[ai].cf) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        aw = ai;\n\n        emit ProtocolConfigChanged(\n            this.ag.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi.ck(ai)\n        );\n    }\n\n\n    function as(uint16 bm) external cg(POSITION_MANAGER_ROLE) {\n        if (bm > h) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        bd = bm;\n        emit ProtocolConfigChanged(\n            this.as.selector, \"setFeeBasisPoints(uint16)\", abi.ck(bm)\n        );\n    }\n\n\n    function bb(address payable bu)\n        external\n        cg(POSITION_MANAGER_ROLE)\n        bi(bu)\n    {\n        br = bu;\n        emit ProtocolConfigChanged(this.bb.selector, \"setFeesReceiver(address)\", abi.ck(bu));\n    }\n\n\n    function f(bool au) external cg(POSITION_MANAGER_ROLE) {\n        m = au;\n        emit ProtocolConfigChanged(this.f.selector, \"setShouldExecuteAllocation(bool)\", abi.ck(au));\n    }\n\n\n    function bz() external payable cg(LIQUIDITY_MANAGER_ROLE) {\n        if (cl.n()) revert LiquidityBuffer__Paused();\n        p(msg.value);\n        if (m) {\n            w(aw, msg.value);\n        }\n    }\n\n    function av(uint256 ca, uint256 cm) external cg(LIQUIDITY_MANAGER_ROLE) {\n        k(ca, cm);\n        af(cm);\n    }\n\n    function aa(uint256 ca, uint256 cm) external cg(LIQUIDITY_MANAGER_ROLE) {\n        w(ca, cm);\n    }\n\n    function q(uint256 ca, uint256 cm) external cg(LIQUIDITY_MANAGER_ROLE) {\n        k(ca, cm);\n    }\n\n    function ap(uint256 cm) external cg(LIQUIDITY_MANAGER_ROLE) {\n        af(cm);\n    }\n\n    function c() external payable d {\n\n\n    }\n\n\n    function j(uint256 ca, uint256 cd) external cg(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 cm = i(ca);\n        if (cm < cd) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return cm;\n    }\n\n    function o(uint256 cm) external cg(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < cm) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        a(cm);\n        return cm;\n    }\n\n    function u(uint256 ca, uint256 cd) external cg(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 cm = i(ca);\n        if (cm < cd) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        a(cm);\n\n        return cm;\n    }\n\n\n    function a(uint256 cm) internal {\n        if (cl.n()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (cm > bg) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        bg -= cm;\n        uint256 cr = Math.cn(bd, cm, h);\n        uint256 bv = cm - cr;\n        bf.cq{value: bv}();\n        t += bv;\n        emit InterestToppedUp(bv);\n\n        if (cr > 0) {\n            Address.cb(br, cr);\n            am += cr;\n            emit FeesCollected(cr);\n        }\n    }\n\n    function i(uint256 ca) internal returns (uint256) {\n        if (cl.n()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        uint256 bj = at(ca);\n\n        if (bj > 0) {\n            PositionManagerConfig memory co = r[ca];\n\n\n            al[ca].g += bj;\n            ac += bj;\n            bg += bj;\n            emit InterestClaimed(ca, bj);\n\n\n            IPositionManager ci = IPositionManager(co.bh);\n            ci.ce(bj);\n        } else {\n            emit InterestClaimed(ca, bj);\n        }\n\n        return bj;\n    }\n\n    function k(uint256 ca, uint256 cm) internal {\n        if (cl.n()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (ca >= ae) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory co = r[ca];\n        if (!co.cf) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage by = al[ca];\n\n\n        if (cm > by.ax) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n\n        by.ax -= cm;\n        x -= cm;\n        ay += cm;\n        emit ETHWithdrawnFromManager(ca, cm);\n\n\n        IPositionManager ci = IPositionManager(co.bh);\n        ci.ce(cm);\n    }\n\n    function af(uint256 cm) internal {\n        if (cl.n()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n\n        if (address(bf) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (cm > ay) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n\n        aq += cm;\n        ay -= cm;\n        emit ETHReturnedToStaking(cm);\n\n\n        bf.b{value: cm}();\n    }\n\n    function w(uint256 ca, uint256 cm) internal {\n        if (cl.n()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (cm > ay) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (ca >= ae) revert LiquidityBuffer__ManagerNotFound();\n\n        if (address(this).balance < cm) revert LiquidityBuffer__InsufficientBalance();\n\n\n        PositionManagerConfig memory co = r[ca];\n        if (!co.cf) revert LiquidityBuffer__ManagerInactive();\n\n        PositionAccountant storage by = al[ca];\n        if (by.ax + cm > co.bq) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n\n        by.ax += cm;\n        x += cm;\n        ay -= cm;\n        emit ETHAllocatedToManager(ca, cm);\n\n\n        IPositionManager ci = IPositionManager(co.bh);\n        ci.ch{value: cm}(0);\n    }\n\n    function p(uint256 cm) internal {\n        ao += cm;\n        ay += cm;\n        emit ETHReceivedFromStaking(cm);\n    }\n\n\n    modifier bi(address ct) {\n        if (ct == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n\n    modifier ak() {\n        if (msg.sender != address(bf)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier d() {\n        bool bn = false;\n\n\n        for (uint256 i = 0; i < ae; i++) {\n            PositionManagerConfig memory co = r[i];\n\n            if (msg.sender == co.bh && co.cf) {\n                bn = true;\n                break;\n            }\n        }\n\n        if (!bn) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "_topUpInterestToStakingAndCollectFees": "a",
        "receiveReturnsFromLiquidityBuffer": "b",
        "receiveETHFromPositionManager": "c",
        "onlyPositionManagerContract": "d",
        "togglePositionManagerStatus": "e",
        "setShouldExecuteAllocation": "f",
        "interestClaimedFromManager": "g",
        "_BASIS_POINTS_DENOMINATOR": "h",
        "_claimInterestFromManager": "i",
        "claimInterestFromManager": "j",
        "_withdrawETHFromManager": "k",
        "totalAllocationCapacity": "l",
        "shouldExecuteAllocation": "m",
        "isLiquidityBufferPaused": "n",
        "topUpInterestToStaking": "o",
        "_receiveETHFromStaking": "p",
        "withdrawETHFromManager": "q",
        "positionManagerConfigs": "r",
        "updatePositionManager": "s",
        "totalInterestToppedUp": "t",
        "claimInterestAndTopUp": "u",
        "setCumulativeDrawdown": "v",
        "_allocateETHToManager": "w",
        "totalAllocatedBalance": "x",
        "getUnderlyingBalance": "y",
        "getControlledBalance": "z",
        "allocateETHToManager": "aa",
        "_disableInitializers": "ab",
        "totalInterestClaimed": "ac",
        "getAvailableCapacity": "ad",
        "positionManagerCount": "ae",
        "_returnETHToStaking": "af",
        "setDefaultManagerId": "ag",
        "isRegisteredManager": "ah",
        "newDefaultManagerId": "ai",
        "getAvailableBalance": "aj",
        "onlyStakingContract": "ak",
        "positionAccountants": "al",
        "totalFeesCollected": "am",
        "addPositionManager": "an",
        "totalFundsReceived": "ao",
        "returnETHToStaking": "ap",
        "totalFundsReturned": "aq",
        "cumulativeDrawdown": "ar",
        "setFeeBasisPoints": "as",
        "getInterestAmount": "at",
        "executeAllocation": "au",
        "withdrawAndReturn": "av",
        "defaultManagerId": "aw",
        "allocatedBalance": "ax",
        "pendingPrincipal": "ay",
        "liquidityManager": "az",
        "newAllocationCap": "ba",
        "setFeesReceiver": "bb",
        "drawdownManager": "bc",
        "feesBasisPoints": "bd",
        "positionManager": "be",
        "stakingContract": "bf",
        "pendingInterest": "bg",
        "managerAddress": "bh",
        "notZeroAddress": "bi",
        "interestAmount": "bj",
        "drawdownAmount": "bk",
        "currentBalance": "bl",
        "newBasisPoints": "bm",
        "isValidManager": "bn",
        "managerBalance": "bo",
        "interestTopUp": "bp",
        "allocationCap": "bq",
        "feesReceiver": "br",
        "totalBalance": "bs",
        "initializer": "bt",
        "newReceiver": "bu",
        "topUpAmount": "bv",
        "_grantRole": "bw",
        "initialize": "bx",
        "accounting": "by",
        "depositETH": "bz",
        "managerId": "ca",
        "sendValue": "cb",
        "keccak256": "cc",
        "minAmount": "cd",
        "withdraw": "ce",
        "isActive": "cf",
        "onlyRole": "cg",
        "deposit": "ch",
        "manager": "ci",
        "staking": "cj",
        "encode": "ck",
        "pauser": "cl",
        "amount": "cm",
        "mulDiv": "cn",
        "config": "co",
        "admin": "cp",
        "topUp": "cq",
        "fees": "cr",
        "init": "cs",
        "addr": "ct"
      },
      "changes": [
        "Renamed 98 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_025",
      "transformed_id": "ss_l2_short_nc_gs_025",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ninterface StakingEvents {\n\n    event Staked(address indexed bv, uint256 bs, uint256 bj);\n\n\n    event UnstakeRequested(uint256 indexed cl, address indexed bv, uint256 bs, uint256 bg);\n\n\n    event UnstakeRequestClaimed(uint256 indexed cl, address indexed bv);\n\n\n    event ValidatorInitiated(bytes32 indexed cl, uint256 indexed bf, bytes bw, uint256 ah);\n\n\n    event AllocatedETHToUnstakeRequestsManager(uint256 bz);\n\n\n    event AllocatedETHToDeposits(uint256 bz);\n\n\n    event ReturnsReceived(uint256 bz);\n\n\n    event ReturnsReceivedFromLiquidityBuffer(uint256 bz);\n\n\n    event AllocatedETHToLiquidityBuffer(uint256 bz);\n}\n\n\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 bk, uint256 ag);\n    error UnstakeBelowMinimumETHAmount(uint256 bs, uint256 ag);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = bn(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = bn(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = bn(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = bn(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = bn(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = bn(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 bf;\n        uint256 aw;\n        bytes bw;\n        bytes p;\n        bytes bp;\n        bytes32 ak;\n    }\n\n    mapping(bytes bw => bool cb) public at;\n    uint256 public f;\n    uint256 public o;\n    uint256 public ar;\n    uint256 public l;\n    uint256 public ab;\n    uint256 public w;\n    uint16 public n;\n    uint16 internal constant h = 10_000;\n    uint16 internal constant d = h / 10;\n    uint256 public s;\n    uint256 public t;\n    IDepositContract public al;\n    IMETH public cj;\n    IOracleReadRecord public by;\n    IPauserRead public bx;\n    IUnstakeRequestsManager public m;\n    address public ae;\n    address public aa;\n    bool public x;\n    uint256 public i;\n    uint256 public z;\n    ILiquidityBuffer public ai;\n\n    struct Init {\n        address cf;\n        address bu;\n        address ac;\n        address ad;\n        address aa;\n        address ae;\n        IMETH cj;\n        IDepositContract al;\n        IOracleReadRecord by;\n        IPauserRead bx;\n        IUnstakeRequestsManager m;\n    }\n\n    constructor() {\n        r();\n    }\n\n    function bi(Init memory ch) external bc {\n        __AccessControlEnumerable_init();\n\n        be(DEFAULT_ADMIN_ROLE, ch.cf);\n        be(STAKING_MANAGER_ROLE, ch.bu);\n        be(ALLOCATOR_SERVICE_ROLE, ch.ac);\n        be(INITIATOR_SERVICE_ROLE, ch.ad);\n\n        av(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        av(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        cj = ch.cj;\n        al = ch.al;\n        by = ch.by;\n        bx = ch.bx;\n        aa = ch.aa;\n        m = ch.m;\n        ae = ch.ae;\n\n        ab = 0.1 ether;\n        w = 0.01 ether;\n        s = 32 ether;\n        t = 32 ether;\n        x = true;\n        i = block.number;\n        z = 1024 ether;\n    }\n\n    function ay(ILiquidityBuffer cm) public ax(2) {\n        ai = cm;\n    }\n\n    function cg(uint256 au) external payable {\n        if (bx.an()) {\n            revert Paused();\n        }\n\n        if (x) {\n            bl(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < ab) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 ao = bm(msg.value);\n        if (ao + cj.bd() > z) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (ao < au) {\n            revert StakeBelowMinimumMETHAmount(ao, au);\n        }\n\n        ar += msg.value;\n\n        emit Staked(msg.sender, msg.value, ao);\n        cj.ci(msg.sender, ao);\n    }\n\n    function as(uint128 bk, uint128 ba) external returns (uint256) {\n        return am(bk, ba);\n    }\n\n    function j(\n        uint128 bk,\n        uint128 ba,\n        uint256 bt,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.bh(cj, msg.sender, address(this), bk, bt, v, r, s);\n        return am(bk, ba);\n    }\n\n    function am(uint128 bk, uint128 ba) internal returns (uint256) {\n        if (bx.b()) {\n            revert Paused();\n        }\n\n        if (bk < w) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 bs = uint128(bo(bk));\n        if (bs < ba) {\n            revert UnstakeBelowMinimumETHAmount(bs, ba);\n        }\n\n        uint256 br =\n            m.cc({bq: msg.sender, bg: bk, bb: bs});\n        emit UnstakeRequested({cl: br, bv: msg.sender, bs: bs, bg: bk});\n\n        SafeERC20Upgradeable.af(cj, msg.sender, address(m), bk);\n\n        return br;\n    }\n\n    function bm(uint256 bs) public view returns (uint256) {\n        if (cj.bd() == 0) {\n            return bs;\n        }\n        uint256 k = Math.cd(\n            aj(), h + n, h\n        );\n        return Math.cd(bs, cj.bd(), k);\n    }\n\n    function bo(uint256 bj) public view returns (uint256) {\n        if (cj.bd() == 0) {\n            return bj;\n        }\n        return Math.cd(bj, aj(), cj.bd());\n    }\n\n    function aj() public view returns (uint256) {\n        OracleRecord memory ca = by.az();\n        uint256 ce = 0;\n        ce += ar;\n        ce += l;\n        ce += f - ca.c;\n        ce += ca.e;\n        ce += ai.v();\n        ce -= ai.y();\n        ce += m.balance();\n        return ce;\n    }\n\n    function aq() external payable q {\n        emit ReturnsReceived(msg.value);\n        ar += msg.value;\n    }\n\n    function a() external payable u {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        ar += msg.value;\n    }\n\n    modifier q() {\n        if (msg.sender != aa) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier u() {\n        if (msg.sender != address(ai)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier g() {\n        if (msg.sender != address(m)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier ap(address ck) {\n        if (ck == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "a",
        "isUnstakeRequestsAndClaimsPaused": "b",
        "cumulativeProcessedDepositAmount": "c",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "d",
        "currentTotalValidatorBalance": "e",
        "totalDepositedInValidators": "f",
        "onlyUnstakeRequestsManager": "g",
        "_BASIS_POINTS_DENOMINATOR": "h",
        "initializationBlockNumber": "i",
        "unstakeRequestWithPermit": "j",
        "adjustedTotalControlled": "k",
        "allocatedETHForDeposits": "l",
        "unstakeRequestsManager": "m",
        "exchangeAdjustmentRate": "n",
        "numInitiatedValidators": "o",
        "withdrawalCredentials": "p",
        "onlyReturnsAggregator": "q",
        "_disableInitializers": "r",
        "minimumDepositAmount": "s",
        "maximumDepositAmount": "t",
        "onlyLiquidityBuffer": "u",
        "getAvailableBalance": "v",
        "minimumUnstakeBound": "w",
        "isStakingAllowlist": "x",
        "cumulativeDrawdown": "y",
        "maximumMETHSupply": "z",
        "returnsAggregator": "aa",
        "minimumStakeBound": "ab",
        "allocatorService": "ac",
        "initiatorService": "ad",
        "withdrawalWallet": "ae",
        "safeTransferFrom": "af",
        "expectedMinimum": "ag",
        "amountDeposited": "ah",
        "liquidityBuffer": "ai",
        "totalControlled": "aj",
        "depositDataRoot": "ak",
        "depositContract": "al",
        "_unstakeRequest": "am",
        "isStakingPaused": "an",
        "mETHMintAmount": "ao",
        "notZeroAddress": "ap",
        "receiveReturns": "aq",
        "unallocatedETH": "ar",
        "unstakeRequest": "as",
        "usedValidators": "at",
        "minMETHAmount": "au",
        "_setRoleAdmin": "av",
        "depositAmount": "aw",
        "reinitializer": "ax",
        "initializeV2": "ay",
        "latestRecord": "az",
        "minETHAmount": "ba",
        "ethRequested": "bb",
        "initializer": "bc",
        "totalSupply": "bd",
        "_grantRole": "be",
        "operatorID": "bf",
        "mETHLocked": "bg",
        "safePermit": "bh",
        "initialize": "bi",
        "mETHAmount": "bj",
        "methAmount": "bk",
        "_checkRole": "bl",
        "ethToMETH": "bm",
        "keccak256": "bn",
        "mETHToETH": "bo",
        "signature": "bp",
        "requester": "bq",
        "requestID": "br",
        "ethAmount": "bs",
        "deadline": "bt",
        "manager": "bu",
        "staker": "bv",
        "pubkey": "bw",
        "pauser": "bx",
        "oracle": "by",
        "amount": "bz",
        "record": "ca",
        "exists": "cb",
        "create": "cc",
        "mulDiv": "cd",
        "total": "ce",
        "admin": "cf",
        "stake": "cg",
        "init": "ch",
        "mint": "ci",
        "mETH": "cj",
        "addr": "ck",
        "id": "cl",
        "lb": "cm"
      },
      "changes": [
        "Renamed 91 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_026",
      "transformed_id": "ss_l2_short_nc_gs_026",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IPool} from \"aave-v3/interfaces/IPool.sol\";\nimport {DataTypes} from \"aave-v3/protocol/libraries/types/DataTypes.sol\";\nimport {IPositionManager} from './interfaces/IPositionManager.sol';\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {ILiquidityBuffer} from \"../liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ncontract PositionManager is Initializable, AccessControlEnumerableUpgradeable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n\n    bytes32 public constant EXECUTOR_ROLE = ag(\"EXECUTOR_ROLE\");\n    bytes32 public constant MANAGER_ROLE = ag(\"MANAGER_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = ag(\"EMERGENCY_ROLE\");\n\n\n    IPool public au;\n    IWETH public ax;\n    ILiquidityBuffer public o;\n\n\n    struct Init {\n        address aq;\n        address ak;\n        ILiquidityBuffer o;\n        IWETH ax;\n        IPool au;\n    }\n\n\n    event Deposit(address indexed ap, uint ao, uint t);\n    event Withdraw(address indexed ap, uint ao);\n    event Borrow(address indexed ap, uint ao, uint ai);\n    event Repay(address indexed ap, uint ao, uint ai);\n    event SetUserEMode(address indexed ap, uint8 ad);\n\n    constructor() {\n        f();\n    }\n\n    function ac(Init memory av) external x {\n        __AccessControlEnumerable_init();\n\n        ax = av.ax;\n        au = av.au;\n        o = av.o;\n\n\n        ab(DEFAULT_ADMIN_ROLE, av.aq);\n        ab(MANAGER_ROLE, av.ak);\n        ab(EXECUTOR_ROLE, address(av.o));\n\n\n        ax.am(address(au), type(uint256).az);\n    }\n\n\n    function an(uint16 q) external payable override aj(EXECUTOR_ROLE) {\n        if (msg.value > 0) {\n\n            ax.an{value: msg.value}();\n\n\n            au.an(address(ax), msg.value, address(this), q);\n\n            emit Deposit(msg.sender, msg.value, msg.value);\n        }\n    }\n\n    function ah(uint256 ao) external override aj(EXECUTOR_ROLE) {\n        require(ao > 0, 'Invalid ao');\n\n\n        IERC20 at = IERC20(au.n(address(ax)));\n        uint256 aa = at.ae(address(this));\n\n        uint256 k = ao;\n        if (ao == type(uint256).az) {\n            k = aa;\n        }\n\n        require(k <= aa, 'Insufficient balance');\n\n\n        au.ah(address(ax), k, address(this));\n\n\n        ax.ah(k);\n\n\n        o.b{value: k}();\n\n        emit Withdraw(msg.sender, k);\n    }\n\n    function h() external view returns (uint256) {\n        IERC20 at = IERC20(au.n(address(ax)));\n        return at.ae(address(this));\n    }\n\n    function u(uint8 ad) external override aj(MANAGER_ROLE) {\n\n        au.u(ad);\n\n        emit SetUserEMode(msg.sender, ad);\n    }\n    function v(address ar, address aw, uint256 ay) external override aj(MANAGER_ROLE) {\n        IERC20(ar).z(aw, ay);\n    }\n\n    function y(address ar, address aw) external override aj(MANAGER_ROLE) {\n        IERC20(ar).z(aw, 0);\n    }\n\n\n    function m() external view returns (uint256) {\n        address af = au.c(address(ax));\n        return IERC20(af).ae(address(this));\n    }\n\n    function g() external view returns (uint256) {\n        IERC20 at = IERC20(au.n(address(ax)));\n        return at.ae(address(this));\n    }\n\n    function s() external view returns (uint256) {\n        return au.s(address(this));\n    }\n\n    function a(address as, bool p) external aj(MANAGER_ROLE) {\n        au.a(as, p);\n    }\n\n    function i(address l) external aj(MANAGER_ROLE) {\n        w(EXECUTOR_ROLE, address(o));\n        ab(EXECUTOR_ROLE, l);\n        o = ILiquidityBuffer(l);\n    }\n\n\n    function d(address ar, address ba, uint256 ao) external aj(EMERGENCY_ROLE) {\n        IERC20(ar).r(ba, ao);\n    }\n\n\n    function e(address ba, uint256 ao) external aj(EMERGENCY_ROLE) {\n        j(ba, ao);\n    }\n\n\n    function j(address ba, uint256 value) internal {\n        (bool al, ) = ba.call{value: value}(new bytes(0));\n        require(al, 'ETH_TRANSFER_FAILED');\n    }\n\n\n    receive() external payable {\n        require(msg.sender == address(ax), 'Receive not allowed');\n    }\n\n\n    fallback() external payable {\n        revert('Fallback not allowed');\n    }\n}",
      "rename_map": {
        "setUserUseReserveAsCollateral": "a",
        "receiveETHFromPositionManager": "b",
        "getReserveVariableDebtToken": "c",
        "emergencyTokenTransfer": "d",
        "emergencyEtherTransfer": "e",
        "_disableInitializers": "f",
        "getCollateralBalance": "g",
        "getUnderlyingBalance": "h",
        "setLiquidityBuffer": "i",
        "_safeTransferETH": "j",
        "amountToWithdraw": "k",
        "_liquidityBuffer": "l",
        "getBorrowBalance": "m",
        "getReserveAToken": "n",
        "liquidityBuffer": "o",
        "useAsCollateral": "p",
        "referralCode": "q",
        "safeTransfer": "r",
        "getUserEMode": "s",
        "aTokenAmount": "t",
        "setUserEMode": "u",
        "approveToken": "v",
        "_revokeRole": "w",
        "initializer": "x",
        "revokeToken": "y",
        "safeApprove": "z",
        "userBalance": "aa",
        "_grantRole": "ab",
        "initialize": "ac",
        "categoryId": "ad",
        "balanceOf": "ae",
        "debtToken": "af",
        "keccak256": "ag",
        "withdraw": "ah",
        "rateMode": "ai",
        "onlyRole": "aj",
        "manager": "ak",
        "success": "al",
        "approve": "am",
        "deposit": "an",
        "amount": "ao",
        "caller": "ap",
        "admin": "aq",
        "token": "ar",
        "asset": "as",
        "aWETH": "at",
        "pool": "au",
        "init": "av",
        "addr": "aw",
        "weth": "ax",
        "wad": "ay",
        "max": "az",
        "to": "ba"
      },
      "changes": [
        "Renamed 53 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_027",
      "transformed_id": "ss_l2_short_nc_gs_027",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ninterface StakingEvents {\n\n    event Staked(address indexed bv, uint256 bs, uint256 bj);\n\n\n    event UnstakeRequested(uint256 indexed cl, address indexed bv, uint256 bs, uint256 bg);\n\n\n    event UnstakeRequestClaimed(uint256 indexed cl, address indexed bv);\n\n\n    event ValidatorInitiated(bytes32 indexed cl, uint256 indexed bf, bytes bw, uint256 ah);\n\n\n    event AllocatedETHToUnstakeRequestsManager(uint256 bz);\n\n\n    event AllocatedETHToDeposits(uint256 bz);\n\n\n    event ReturnsReceived(uint256 bz);\n\n\n    event ReturnsReceivedFromLiquidityBuffer(uint256 bz);\n\n\n    event AllocatedETHToLiquidityBuffer(uint256 bz);\n}\n\n\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 bk, uint256 ag);\n    error UnstakeBelowMinimumETHAmount(uint256 bs, uint256 ag);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = bn(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = bn(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = bn(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = bn(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = bn(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = bn(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 bf;\n        uint256 aw;\n        bytes bw;\n        bytes p;\n        bytes bp;\n        bytes32 ak;\n    }\n\n    mapping(bytes bw => bool cb) public at;\n    uint256 public f;\n    uint256 public o;\n    uint256 public ar;\n    uint256 public l;\n    uint256 public ab;\n    uint256 public w;\n    uint16 public n;\n    uint16 internal constant h = 10_000;\n    uint16 internal constant d = h / 10;\n    uint256 public s;\n    uint256 public t;\n    IDepositContract public al;\n    IMETH public cj;\n    IOracleReadRecord public by;\n    IPauserRead public bx;\n    IUnstakeRequestsManager public m;\n    address public ae;\n    address public aa;\n    bool public x;\n    uint256 public i;\n    uint256 public z;\n    ILiquidityBuffer public ai;\n\n    struct Init {\n        address cf;\n        address bu;\n        address ac;\n        address ad;\n        address aa;\n        address ae;\n        IMETH cj;\n        IDepositContract al;\n        IOracleReadRecord by;\n        IPauserRead bx;\n        IUnstakeRequestsManager m;\n    }\n\n    constructor() {\n        r();\n    }\n\n    function bi(Init memory ch) external bc {\n        __AccessControlEnumerable_init();\n\n        be(DEFAULT_ADMIN_ROLE, ch.cf);\n        be(STAKING_MANAGER_ROLE, ch.bu);\n        be(ALLOCATOR_SERVICE_ROLE, ch.ac);\n        be(INITIATOR_SERVICE_ROLE, ch.ad);\n\n        av(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        av(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        cj = ch.cj;\n        al = ch.al;\n        by = ch.by;\n        bx = ch.bx;\n        aa = ch.aa;\n        m = ch.m;\n        ae = ch.ae;\n\n        ab = 0.1 ether;\n        w = 0.01 ether;\n        s = 32 ether;\n        t = 32 ether;\n        x = true;\n        i = block.number;\n        z = 1024 ether;\n    }\n\n    function ay(ILiquidityBuffer cm) public ax(2) {\n        ai = cm;\n    }\n\n    function cg(uint256 au) external payable {\n        if (bx.an()) {\n            revert Paused();\n        }\n\n        if (x) {\n            bl(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < ab) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 ao = bm(msg.value);\n        if (ao + cj.bd() > z) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (ao < au) {\n            revert StakeBelowMinimumMETHAmount(ao, au);\n        }\n\n        ar += msg.value;\n\n        emit Staked(msg.sender, msg.value, ao);\n        cj.ci(msg.sender, ao);\n    }\n\n    function as(uint128 bk, uint128 ba) external returns (uint256) {\n        return am(bk, ba);\n    }\n\n    function j(\n        uint128 bk,\n        uint128 ba,\n        uint256 bt,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.bh(cj, msg.sender, address(this), bk, bt, v, r, s);\n        return am(bk, ba);\n    }\n\n    function am(uint128 bk, uint128 ba) internal returns (uint256) {\n        if (bx.b()) {\n            revert Paused();\n        }\n\n        if (bk < w) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 bs = uint128(bo(bk));\n        if (bs < ba) {\n            revert UnstakeBelowMinimumETHAmount(bs, ba);\n        }\n\n        uint256 br =\n            m.cc({bq: msg.sender, bg: bk, bb: bs});\n        emit UnstakeRequested({cl: br, bv: msg.sender, bs: bs, bg: bk});\n\n        SafeERC20Upgradeable.af(cj, msg.sender, address(m), bk);\n\n        return br;\n    }\n\n    function bm(uint256 bs) public view returns (uint256) {\n        if (cj.bd() == 0) {\n            return bs;\n        }\n        uint256 k = Math.cd(\n            aj(), h + n, h\n        );\n        return Math.cd(bs, cj.bd(), k);\n    }\n\n    function bo(uint256 bj) public view returns (uint256) {\n        if (cj.bd() == 0) {\n            return bj;\n        }\n        return Math.cd(bj, aj(), cj.bd());\n    }\n\n    function aj() public view returns (uint256) {\n        OracleRecord memory ca = by.az();\n        uint256 ce = 0;\n        ce += ar;\n        ce += l;\n        ce += f - ca.c;\n        ce += ca.e;\n        ce += ai.v();\n        ce -= ai.y();\n        ce += m.balance();\n        return ce;\n    }\n\n    function aq() external payable q {\n        emit ReturnsReceived(msg.value);\n        ar += msg.value;\n    }\n\n    function a() external payable u {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        ar += msg.value;\n    }\n\n    modifier q() {\n        if (msg.sender != aa) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier u() {\n        if (msg.sender != address(ai)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier g() {\n        if (msg.sender != address(m)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier ap(address ck) {\n        if (ck == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "a",
        "isUnstakeRequestsAndClaimsPaused": "b",
        "cumulativeProcessedDepositAmount": "c",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "d",
        "currentTotalValidatorBalance": "e",
        "totalDepositedInValidators": "f",
        "onlyUnstakeRequestsManager": "g",
        "_BASIS_POINTS_DENOMINATOR": "h",
        "initializationBlockNumber": "i",
        "unstakeRequestWithPermit": "j",
        "adjustedTotalControlled": "k",
        "allocatedETHForDeposits": "l",
        "unstakeRequestsManager": "m",
        "exchangeAdjustmentRate": "n",
        "numInitiatedValidators": "o",
        "withdrawalCredentials": "p",
        "onlyReturnsAggregator": "q",
        "_disableInitializers": "r",
        "minimumDepositAmount": "s",
        "maximumDepositAmount": "t",
        "onlyLiquidityBuffer": "u",
        "getAvailableBalance": "v",
        "minimumUnstakeBound": "w",
        "isStakingAllowlist": "x",
        "cumulativeDrawdown": "y",
        "maximumMETHSupply": "z",
        "returnsAggregator": "aa",
        "minimumStakeBound": "ab",
        "allocatorService": "ac",
        "initiatorService": "ad",
        "withdrawalWallet": "ae",
        "safeTransferFrom": "af",
        "expectedMinimum": "ag",
        "amountDeposited": "ah",
        "liquidityBuffer": "ai",
        "totalControlled": "aj",
        "depositDataRoot": "ak",
        "depositContract": "al",
        "_unstakeRequest": "am",
        "isStakingPaused": "an",
        "mETHMintAmount": "ao",
        "notZeroAddress": "ap",
        "receiveReturns": "aq",
        "unallocatedETH": "ar",
        "unstakeRequest": "as",
        "usedValidators": "at",
        "minMETHAmount": "au",
        "_setRoleAdmin": "av",
        "depositAmount": "aw",
        "reinitializer": "ax",
        "initializeV2": "ay",
        "latestRecord": "az",
        "minETHAmount": "ba",
        "ethRequested": "bb",
        "initializer": "bc",
        "totalSupply": "bd",
        "_grantRole": "be",
        "operatorID": "bf",
        "mETHLocked": "bg",
        "safePermit": "bh",
        "initialize": "bi",
        "mETHAmount": "bj",
        "methAmount": "bk",
        "_checkRole": "bl",
        "ethToMETH": "bm",
        "keccak256": "bn",
        "mETHToETH": "bo",
        "signature": "bp",
        "requester": "bq",
        "requestID": "br",
        "ethAmount": "bs",
        "deadline": "bt",
        "manager": "bu",
        "staker": "bv",
        "pubkey": "bw",
        "pauser": "bx",
        "oracle": "by",
        "amount": "bz",
        "record": "ca",
        "exists": "cb",
        "create": "cc",
        "mulDiv": "cd",
        "total": "ce",
        "admin": "cf",
        "stake": "cg",
        "init": "ch",
        "mint": "ci",
        "mETH": "cj",
        "addr": "ck",
        "id": "cl",
        "lb": "cm"
      },
      "changes": [
        "Renamed 91 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_028",
      "transformed_id": "ss_l2_short_nc_gs_028",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ninterface StakingEvents {\n\n    event Staked(address indexed bv, uint256 bs, uint256 bj);\n\n\n    event UnstakeRequested(uint256 indexed cl, address indexed bv, uint256 bs, uint256 bg);\n\n\n    event UnstakeRequestClaimed(uint256 indexed cl, address indexed bv);\n\n\n    event ValidatorInitiated(bytes32 indexed cl, uint256 indexed bf, bytes bw, uint256 ah);\n\n\n    event AllocatedETHToUnstakeRequestsManager(uint256 bz);\n\n\n    event AllocatedETHToDeposits(uint256 bz);\n\n\n    event ReturnsReceived(uint256 bz);\n\n\n    event ReturnsReceivedFromLiquidityBuffer(uint256 bz);\n\n\n    event AllocatedETHToLiquidityBuffer(uint256 bz);\n}\n\n\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 bk, uint256 ag);\n    error UnstakeBelowMinimumETHAmount(uint256 bs, uint256 ag);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = bn(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = bn(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = bn(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = bn(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = bn(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = bn(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 bf;\n        uint256 aw;\n        bytes bw;\n        bytes p;\n        bytes bp;\n        bytes32 ak;\n    }\n\n    mapping(bytes bw => bool cb) public at;\n    uint256 public f;\n    uint256 public o;\n    uint256 public ar;\n    uint256 public l;\n    uint256 public ab;\n    uint256 public w;\n    uint16 public n;\n    uint16 internal constant h = 10_000;\n    uint16 internal constant d = h / 10;\n    uint256 public s;\n    uint256 public t;\n    IDepositContract public al;\n    IMETH public cj;\n    IOracleReadRecord public by;\n    IPauserRead public bx;\n    IUnstakeRequestsManager public m;\n    address public ae;\n    address public aa;\n    bool public x;\n    uint256 public i;\n    uint256 public z;\n    ILiquidityBuffer public ai;\n\n    struct Init {\n        address cf;\n        address bu;\n        address ac;\n        address ad;\n        address aa;\n        address ae;\n        IMETH cj;\n        IDepositContract al;\n        IOracleReadRecord by;\n        IPauserRead bx;\n        IUnstakeRequestsManager m;\n    }\n\n    constructor() {\n        r();\n    }\n\n    function bi(Init memory ch) external bc {\n        __AccessControlEnumerable_init();\n\n        be(DEFAULT_ADMIN_ROLE, ch.cf);\n        be(STAKING_MANAGER_ROLE, ch.bu);\n        be(ALLOCATOR_SERVICE_ROLE, ch.ac);\n        be(INITIATOR_SERVICE_ROLE, ch.ad);\n\n        av(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        av(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        cj = ch.cj;\n        al = ch.al;\n        by = ch.by;\n        bx = ch.bx;\n        aa = ch.aa;\n        m = ch.m;\n        ae = ch.ae;\n\n        ab = 0.1 ether;\n        w = 0.01 ether;\n        s = 32 ether;\n        t = 32 ether;\n        x = true;\n        i = block.number;\n        z = 1024 ether;\n    }\n\n    function ay(ILiquidityBuffer cm) public ax(2) {\n        ai = cm;\n    }\n\n    function cg(uint256 au) external payable {\n        if (bx.an()) {\n            revert Paused();\n        }\n\n        if (x) {\n            bl(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < ab) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 ao = bm(msg.value);\n        if (ao + cj.bd() > z) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (ao < au) {\n            revert StakeBelowMinimumMETHAmount(ao, au);\n        }\n\n        ar += msg.value;\n\n        emit Staked(msg.sender, msg.value, ao);\n        cj.ci(msg.sender, ao);\n    }\n\n    function as(uint128 bk, uint128 ba) external returns (uint256) {\n        return am(bk, ba);\n    }\n\n    function j(\n        uint128 bk,\n        uint128 ba,\n        uint256 bt,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.bh(cj, msg.sender, address(this), bk, bt, v, r, s);\n        return am(bk, ba);\n    }\n\n    function am(uint128 bk, uint128 ba) internal returns (uint256) {\n        if (bx.b()) {\n            revert Paused();\n        }\n\n        if (bk < w) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 bs = uint128(bo(bk));\n        if (bs < ba) {\n            revert UnstakeBelowMinimumETHAmount(bs, ba);\n        }\n\n        uint256 br =\n            m.cc({bq: msg.sender, bg: bk, bb: bs});\n        emit UnstakeRequested({cl: br, bv: msg.sender, bs: bs, bg: bk});\n\n        SafeERC20Upgradeable.af(cj, msg.sender, address(m), bk);\n\n        return br;\n    }\n\n    function bm(uint256 bs) public view returns (uint256) {\n        if (cj.bd() == 0) {\n            return bs;\n        }\n        uint256 k = Math.cd(\n            aj(), h + n, h\n        );\n        return Math.cd(bs, cj.bd(), k);\n    }\n\n    function bo(uint256 bj) public view returns (uint256) {\n        if (cj.bd() == 0) {\n            return bj;\n        }\n        return Math.cd(bj, aj(), cj.bd());\n    }\n\n    function aj() public view returns (uint256) {\n        OracleRecord memory ca = by.az();\n        uint256 ce = 0;\n        ce += ar;\n        ce += l;\n        ce += f - ca.c;\n        ce += ca.e;\n        ce += ai.v();\n        ce -= ai.y();\n        ce += m.balance();\n        return ce;\n    }\n\n    function aq() external payable q {\n        emit ReturnsReceived(msg.value);\n        ar += msg.value;\n    }\n\n    function a() external payable u {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        ar += msg.value;\n    }\n\n    modifier q() {\n        if (msg.sender != aa) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier u() {\n        if (msg.sender != address(ai)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier g() {\n        if (msg.sender != address(m)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier ap(address ck) {\n        if (ck == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "a",
        "isUnstakeRequestsAndClaimsPaused": "b",
        "cumulativeProcessedDepositAmount": "c",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "d",
        "currentTotalValidatorBalance": "e",
        "totalDepositedInValidators": "f",
        "onlyUnstakeRequestsManager": "g",
        "_BASIS_POINTS_DENOMINATOR": "h",
        "initializationBlockNumber": "i",
        "unstakeRequestWithPermit": "j",
        "adjustedTotalControlled": "k",
        "allocatedETHForDeposits": "l",
        "unstakeRequestsManager": "m",
        "exchangeAdjustmentRate": "n",
        "numInitiatedValidators": "o",
        "withdrawalCredentials": "p",
        "onlyReturnsAggregator": "q",
        "_disableInitializers": "r",
        "minimumDepositAmount": "s",
        "maximumDepositAmount": "t",
        "onlyLiquidityBuffer": "u",
        "getAvailableBalance": "v",
        "minimumUnstakeBound": "w",
        "isStakingAllowlist": "x",
        "cumulativeDrawdown": "y",
        "maximumMETHSupply": "z",
        "returnsAggregator": "aa",
        "minimumStakeBound": "ab",
        "allocatorService": "ac",
        "initiatorService": "ad",
        "withdrawalWallet": "ae",
        "safeTransferFrom": "af",
        "expectedMinimum": "ag",
        "amountDeposited": "ah",
        "liquidityBuffer": "ai",
        "totalControlled": "aj",
        "depositDataRoot": "ak",
        "depositContract": "al",
        "_unstakeRequest": "am",
        "isStakingPaused": "an",
        "mETHMintAmount": "ao",
        "notZeroAddress": "ap",
        "receiveReturns": "aq",
        "unallocatedETH": "ar",
        "unstakeRequest": "as",
        "usedValidators": "at",
        "minMETHAmount": "au",
        "_setRoleAdmin": "av",
        "depositAmount": "aw",
        "reinitializer": "ax",
        "initializeV2": "ay",
        "latestRecord": "az",
        "minETHAmount": "ba",
        "ethRequested": "bb",
        "initializer": "bc",
        "totalSupply": "bd",
        "_grantRole": "be",
        "operatorID": "bf",
        "mETHLocked": "bg",
        "safePermit": "bh",
        "initialize": "bi",
        "mETHAmount": "bj",
        "methAmount": "bk",
        "_checkRole": "bl",
        "ethToMETH": "bm",
        "keccak256": "bn",
        "mETHToETH": "bo",
        "signature": "bp",
        "requester": "bq",
        "requestID": "br",
        "ethAmount": "bs",
        "deadline": "bt",
        "manager": "bu",
        "staker": "bv",
        "pubkey": "bw",
        "pauser": "bx",
        "oracle": "by",
        "amount": "bz",
        "record": "ca",
        "exists": "cb",
        "create": "cc",
        "mulDiv": "cd",
        "total": "ce",
        "admin": "cf",
        "stake": "cg",
        "init": "ch",
        "mint": "ci",
        "mETH": "cj",
        "addr": "ck",
        "id": "cl",
        "lb": "cm"
      },
      "changes": [
        "Renamed 91 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_029",
      "transformed_id": "ss_l2_short_nc_gs_029",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { Payload } from \"../Payload.sol\";\n\nimport { ICheckpointer, Snapshot } from \"../interfaces/ICheckpointer.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\nimport { ISapient, ISapientCompact } from \"../interfaces/ISapient.sol\";\n\nusing LibBytes for bytes;\nusing Payload for Payload.Decoded;\n\n\nlibrary BaseSig {\n\n  uint256 internal constant FLAG_SIGNATURE_HASH = 0;\n  uint256 internal constant FLAG_ADDRESS = 1;\n  uint256 internal constant FLAG_SIGNATURE_ERC1271 = 2;\n  uint256 internal constant FLAG_NODE = 3;\n  uint256 internal constant FLAG_BRANCH = 4;\n  uint256 internal constant FLAG_SUBDIGEST = 5;\n  uint256 internal constant FLAG_NESTED = 6;\n  uint256 internal constant FLAG_SIGNATURE_ETH_SIGN = 7;\n  uint256 internal constant FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST = 8;\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT = 9;\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT_COMPACT = 10;\n\n\n  error LowWeightChainedSignature(bytes ap, uint256 aj, uint256 bh);\n\n  error InvalidERC1271Signature(bytes32 bl, address bi, bytes ap);\n\n  error WrongChainedCheckpointOrder(uint256 o, uint256 af);\n\n  error UnusedSnapshot(Snapshot ay);\n\n  error InvalidSignatureFlag(uint256 bs);\n\n  function d(address bq, uint256 bh) internal pure returns (bytes32) {\n    return au(abi.ac(\"Sequence signer:\\n\", bq, bh));\n  }\n\n  function w(bytes32 br, uint256 aj, uint256 bh) internal pure returns (bytes32) {\n    return au(abi.ac(\"Sequence nested config:\\n\", br, aj, bh));\n  }\n\n  function n(address bq, uint256 bh, bytes32 ar) internal pure returns (bytes32) {\n    return au(abi.ac(\"Sequence sapient config:\\n\", bq, bh, ar));\n  }\n\n  function c(\n    bytes32 ao\n  ) internal pure returns (bytes32) {\n    return au(abi.ac(\"Sequence static digest:\\n\", ao));\n  }\n\n  function b(\n    bytes32 f\n  ) internal pure returns (bytes32) {\n    return au(abi.ac(\"Sequence any address subdigest:\\n\", f));\n  }\n\n  function bj(\n    Payload.Decoded memory be,\n    bytes calldata ap,\n    bool h,\n    address ab\n  ) internal view returns (uint256 av, uint256 bp, bytes32 bb, uint256 an, bytes32 bn) {\n\n    (uint256 y, uint256 bo) = ap.s();\n\n\n    Snapshot memory bc;\n\n\n    if (y & 0x40 == 0x40 && ab == address(0)) {\n\n\n      (ab, bo) = ap.ah(bo);\n\n      if (!h) {\n\n        uint256 g;\n        (g, bo) = ap.am(bo);\n\n\n        bytes memory l = ap[bo:bo + g];\n\n\n        bc = ICheckpointer(ab).ag(address(this), l);\n\n        bo += g;\n      }\n    }\n\n\n    if (y & 0x01 == 0x01) {\n      return t(be, ab, bc, ap[bo:]);\n    }\n\n\n    be.aw = y & 0x02 == 0x02;\n\n    {\n\n      uint256 r = (y & 0x1c) >> 2;\n      (an, bo) = ap.ba(bo, r);\n    }\n\n\n    {\n      uint256 z = ((y & 0x20) >> 5) + 1;\n      (av, bo) = ap.ba(bo, z);\n    }\n\n\n    bn = be.bw();\n    (bp, bb) = x(be, bn, ap[bo:]);\n\n    bb = LibOptim.al(bb, bytes32(av));\n    bb = LibOptim.al(bb, bytes32(an));\n    bb = LibOptim.al(bb, bytes32(uint256(uint160(ab))));\n\n\n    if (bc.bb != bytes32(0) && bc.bb != bb && an <= bc.an) {\n      revert UnusedSnapshot(bc);\n    }\n  }\n\n  function t(\n    Payload.Decoded memory be,\n    address ab,\n    Snapshot memory ay,\n    bytes calldata ap\n  ) internal view returns (uint256 av, uint256 bp, bytes32 bb, uint256 an, bytes32 bn) {\n    Payload.Decoded memory aa;\n    aa.bu = Payload.KIND_CONFIG_UPDATE;\n\n    uint256 bo;\n    uint256 q = type(uint256).ca;\n\n    while (bo < ap.length) {\n      uint256 bm;\n\n      {\n        uint256 bk;\n        (bk, bo) = ap.am(bo);\n        bm = bk + bo;\n      }\n\n      address ae = bm == ap.length ? ab : address(0);\n\n      if (q == type(uint256).ca) {\n        (av, bp, bb, an, bn) =\n          bj(be, ap[bo:bm], true, ae);\n      } else {\n        (av, bp, bb, an,) =\n          bj(aa, ap[bo:bm], true, ae);\n      }\n\n      if (bp < av) {\n        revert LowWeightChainedSignature(ap[bo:bm], av, bp);\n      }\n      bo = bm;\n\n      if (ay.bb == bb) {\n        ay.bb = bytes32(0);\n      }\n\n      if (an >= q) {\n        revert WrongChainedCheckpointOrder(an, q);\n      }\n\n      aa.bb = bb;\n      q = an;\n    }\n\n    if (ay.bb != bytes32(0) && an <= ay.an) {\n      revert UnusedSnapshot(ay);\n    }\n  }\n\n  function x(\n    Payload.Decoded memory be,\n    bytes32 bl,\n    bytes calldata ap\n  ) internal view returns (uint256 bp, bytes32 bv) {\n    unchecked {\n      uint256 bo;\n\n\n      while (bo < ap.length) {\n\n\n        uint256 at;\n        (at, bo) = ap.ax(bo);\n\n\n        uint256 bt = (at & 0xf0) >> 4;\n\n\n        if (bt == FLAG_SIGNATURE_HASH) {\n\n\n          uint8 aq = uint8(at & 0x0f);\n          if (aq == 0) {\n            (aq, bo) = ap.ax(bo);\n          }\n\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, bo) = ap.p(bo);\n\n          address by = az(bl, v, r, s);\n\n          bp += aq;\n          bytes32 bx = d(by, aq);\n          bv = bv != bytes32(0) ? LibOptim.al(bv, bx) : bx;\n          continue;\n        }\n\n\n        if (bt == FLAG_ADDRESS) {\n\n\n          uint8 aq = uint8(at & 0x0f);\n          if (aq == 0) {\n            (aq, bo) = ap.ax(bo);\n          }\n\n\n          address by;\n          (by, bo) = ap.ah(bo);\n\n\n          bytes32 bx = d(by, aq);\n          bv = bv != bytes32(0) ? LibOptim.al(bv, bx) : bx;\n          continue;\n        }\n\n\n        if (bt == FLAG_SIGNATURE_ERC1271) {\n\n\n          uint8 aq = uint8(at & 0x03);\n          if (aq == 0) {\n            (aq, bo) = ap.ax(bo);\n          }\n\n\n          address by;\n          (by, bo) = ap.ah(bo);\n\n\n          uint256 bd = uint8(at & 0x0c) >> 2;\n          uint256 bz;\n          (bz, bo) = ap.ba(bo, bd);\n\n\n          uint256 bm = bo + bz;\n\n\n          if (IERC1271(by).j(bl, ap[bo:bm]) != IERC1271_MAGIC_VALUE_HASH) {\n            revert InvalidERC1271Signature(bl, by, ap[bo:bm]);\n          }\n          bo = bm;\n\n          bp += aq;\n          bytes32 bx = d(by, aq);\n          bv = bv != bytes32(0) ? LibOptim.al(bv, bx) : bx;\n          continue;\n        }\n\n\n        if (bt == FLAG_NODE) {\n\n\n          bytes32 bx;\n          (bx, bo) = ap.ai(bo);\n          bv = bv != bytes32(0) ? LibOptim.al(bv, bx) : bx;\n          continue;\n        }\n\n\n        if (bt == FLAG_BRANCH) {\n\n\n          uint256 bd = uint8(at & 0x0f);\n          uint256 bz;\n          (bz, bo) = ap.ba(bo, bd);\n\n\n          uint256 bm = bo + bz;\n\n          (uint256 bf, bytes32 bx) = x(be, bl, ap[bo:bm]);\n          bo = bm;\n\n          bp += bf;\n          bv = LibOptim.al(bv, bx);\n          continue;\n        }\n\n\n        if (bt == FLAG_NESTED) {\n\n\n          uint256 u = uint8(at & 0x0c) >> 2;\n          if (u == 0) {\n            (u, bo) = ap.ax(bo);\n          }\n\n          uint256 i = uint8(at & 0x03);\n          if (i == 0) {\n            (i, bo) = ap.ak(bo);\n          }\n\n          uint256 bz;\n          (bz, bo) = ap.am(bo);\n          uint256 bm = bo + bz;\n\n          (uint256 v, bytes32 ad) = x(be, bl, ap[bo:bm]);\n          bo = bm;\n\n          if (v >= i) {\n            bp += u;\n          }\n\n          bytes32 bx = w(ad, i, u);\n          bv = bv != bytes32(0) ? LibOptim.al(bv, bx) : bx;\n          continue;\n        }\n\n\n        if (bt == FLAG_SUBDIGEST) {\n\n\n          bytes32 as;\n          (as, bo) = ap.ai(bo);\n          if (as == bl) {\n            bp = type(uint256).ca;\n          }\n\n          bytes32 bx = c(as);\n          bv = bv != bytes32(0) ? LibOptim.al(bv, bx) : bx;\n          continue;\n        }\n\n\n        if (bt == FLAG_SIGNATURE_ETH_SIGN) {\n\n\n          uint8 aq = uint8(at & 0x0f);\n          if (aq == 0) {\n            (aq, bo) = ap.ax(bo);\n          }\n\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, bo) = ap.p(bo);\n\n          address by = az(au(abi.ac(\"\\x19Ethereum Signed Message:\\n32\", bl)), v, r, s);\n\n          bp += aq;\n          bytes32 bx = d(by, aq);\n          bv = bv != bytes32(0) ? LibOptim.al(bv, bx) : bx;\n          continue;\n        }\n\n\n        if (bt == FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST) {\n\n\n          bytes32 as;\n          (as, bo) = ap.ai(bo);\n          bytes32 k = be.bg(address(0));\n          if (as == k) {\n            bp = type(uint256).ca;\n          }\n\n          bytes32 bx = b(as);\n          bv = bv != bytes32(0) ? LibOptim.al(bv, bx) : bx;\n          continue;\n        }\n\n\n        if (bt == FLAG_SIGNATURE_SAPIENT) {\n\n\n          uint8 aq = uint8(at & 0x03);\n          if (aq == 0) {\n            (aq, bo) = ap.ax(bo);\n          }\n\n          address by;\n          (by, bo) = ap.ah(bo);\n\n\n          uint256 bz;\n          {\n            uint256 bd = uint8(at & 0x0c) >> 2;\n            (bz, bo) = ap.ba(bo, bd);\n          }\n\n\n          uint256 bm = bo + bz;\n\n\n          bytes32 m = ISapient(by).e(be, ap[bo:bm]);\n          bo = bm;\n\n\n          bp += aq;\n          bytes32 bx = n(by, aq, m);\n          bv = bv != bytes32(0) ? LibOptim.al(bv, bx) : bx;\n          continue;\n        }\n\n\n        if (bt == FLAG_SIGNATURE_SAPIENT_COMPACT) {\n\n\n          uint8 aq = uint8(at & 0x03);\n          if (aq == 0) {\n            (aq, bo) = ap.ax(bo);\n          }\n\n          address by;\n          (by, bo) = ap.ah(bo);\n\n\n          uint256 bd = uint8(at & 0x0c) >> 2;\n          uint256 bz;\n          (bz, bo) = ap.ba(bo, bd);\n\n\n          uint256 bm = bo + bz;\n\n\n          bytes32 m =\n            ISapientCompact(by).a(bl, ap[bo:bm]);\n          bo = bm;\n\n          bp += aq;\n          bytes32 bx = n(by, aq, m);\n          bv = bv != bytes32(0) ? LibOptim.al(bv, bx) : bx;\n          continue;\n        }\n\n        revert InvalidSignatureFlag(bt);\n      }\n    }\n  }\n\n}",
      "rename_map": {
        "recoverSapientSignatureCompact": "a",
        "_leafForAnyAddressSubdigest": "b",
        "_leafForHardcodedSubdigest": "c",
        "_leafForAddressAndWeight": "d",
        "recoverSapientSignature": "e",
        "_anyAddressSubdigest": "f",
        "checkpointerDataSize": "g",
        "_ignoreCheckpointer": "h",
        "internalThreshold": "i",
        "isValidSignature": "j",
        "anyAddressOpHash": "k",
        "checkpointerData": "l",
        "sapientImageHash": "m",
        "_leafForSapient": "n",
        "_nextCheckpoint": "o",
        "readRSVCompact": "p",
        "prevCheckpoint": "q",
        "checkpointSize": "r",
        "readFirstUint8": "s",
        "recoverChained": "t",
        "externalWeight": "u",
        "internalWeight": "v",
        "_leafForNested": "w",
        "recoverBranch": "x",
        "signatureFlag": "y",
        "thresholdSize": "z",
        "linkedPayload": "aa",
        "_checkpointer": "ab",
        "encodePacked": "ac",
        "internalRoot": "ad",
        "checkpointer": "ae",
        "_checkpoint": "af",
        "snapshotFor": "ag",
        "readAddress": "ah",
        "readBytes32": "ai",
        "_threshold": "aj",
        "readUint16": "ak",
        "fkeccak256": "al",
        "readUint24": "am",
        "checkpoint": "an",
        "_subdigest": "ao",
        "_signature": "ap",
        "addrWeight": "aq",
        "_imageHash": "ar",
        "hardcoded": "as",
        "firstByte": "at",
        "keccak256": "au",
        "threshold": "av",
        "noChainId": "aw",
        "readUint8": "ax",
        "_snapshot": "ay",
        "ecrecover": "az",
        "readUintX": "ba",
        "imageHash": "bb",
        "snapshot": "bc",
        "sizeSize": "bd",
        "_payload": "be",
        "nweight": "bf",
        "hashFor": "bg",
        "_weight": "bh",
        "_signer": "bi",
        "recover": "bj",
        "sigSize": "bk",
        "_opHash": "bl",
        "nrindex": "bm",
        "opHash": "bn",
        "rindex": "bo",
        "weight": "bp",
        "_addr": "bq",
        "_node": "br",
        "_flag": "bs",
        "flag": "bt",
        "kind": "bu",
        "root": "bv",
        "hash": "bw",
        "node": "bx",
        "addr": "by",
        "size": "bz",
        "max": "ca"
      },
      "changes": [
        "Renamed 79 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_030",
      "transformed_id": "ss_l2_short_nc_gs_030",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport { LibOptim } from \"../utils/LibOptim.sol\";\nimport { Nonce } from \"./Nonce.sol\";\nimport { Payload } from \"./Payload.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { BaseAuth } from \"./auth/BaseAuth.sol\";\nimport { IDelegatedExtension } from \"./interfaces/IDelegatedExtension.sol\";\n\n\nabstract contract Calls is ReentrancyGuard, BaseAuth, Nonce {\n\n\n  event CallSucceeded(bytes32 v, uint256 ab);\n\n  event CallFailed(bytes32 v, uint256 ab, bytes j);\n\n  event CallAborted(bytes32 v, uint256 ab, bytes j);\n\n  event CallSkipped(bytes32 v, uint256 ab);\n\n\n  error Reverted(Payload.Decoded s, uint256 ab, bytes j);\n\n  error InvalidSignature(Payload.Decoded s, bytes l);\n\n  error NotEnoughGas(Payload.Decoded s, uint256 ab, uint256 r);\n\n\n  function u(bytes calldata s, bytes calldata l) external payable virtual h {\n    uint256 k = y();\n    Payload.Decoded memory x = Payload.d(s);\n\n    e(x.ac, x.ad);\n    (bool z, bytes32 aa) = b(x, l);\n\n    if (!z) {\n      revert InvalidSignature(x, l);\n    }\n\n    t(k, aa, x);\n  }\n\n\n  function i(\n    bytes calldata s\n  ) external payable virtual p {\n    uint256 k = y();\n    Payload.Decoded memory x = Payload.d(s);\n    bytes32 aa = Payload.af(x);\n    t(k, aa, x);\n  }\n\n  function t(uint256 g, bytes32 v, Payload.Decoded memory q) private {\n    bool n = false;\n\n    uint256 o = q.ae.length;\n    for (uint256 i = 0; i < o; i++) {\n      Payload.Call memory call = q.ae[i];\n\n\n      if (call.f && !n) {\n        emit CallSkipped(v, i);\n        continue;\n      }\n\n\n      n = false;\n\n      uint256 gasLimit = call.gasLimit;\n      if (gasLimit != 0 && y() < gasLimit) {\n        revert NotEnoughGas(q, i, y());\n      }\n\n      bool w;\n      if (call.delegateCall) {\n        (w) = LibOptim.delegatecall(\n          call.ag,\n          gasLimit == 0 ? y() : gasLimit,\n          abi.c(\n            IDelegatedExtension.a.selector,\n            v,\n            g,\n            i,\n            o,\n            q.ac,\n            call.data\n          )\n        );\n      } else {\n        (w) = LibOptim.call(call.ag, call.value, gasLimit == 0 ? y() : gasLimit, call.data);\n      }\n\n      if (!w) {\n        if (call.behaviorOnError == Payload.BEHAVIOR_IGNORE_ERROR) {\n          n = true;\n          emit CallFailed(v, i, LibOptim.m());\n          continue;\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_REVERT_ON_ERROR) {\n          revert Reverted(q, i, LibOptim.m());\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_ABORT_ON_ERROR) {\n          emit CallAborted(v, i, LibOptim.m());\n          break;\n        }\n      }\n\n      emit CallSucceeded(v, i);\n    }\n  }\n\n}",
      "rename_map": {
        "handleSequenceDelegateCall": "a",
        "signatureValidation": "b",
        "encodeWithSelector": "c",
        "fromPackedCalls": "d",
        "_consumeNonce": "e",
        "onlyFallback": "f",
        "_startingGas": "g",
        "nonReentrant": "h",
        "selfExecute": "i",
        "_returnData": "j",
        "startingGas": "k",
        "_signature": "l",
        "returnData": "m",
        "errorFlag": "n",
        "numCalls": "o",
        "onlySelf": "p",
        "_decoded": "q",
        "_gasLeft": "r",
        "_payload": "s",
        "_execute": "t",
        "execute": "u",
        "_opHash": "v",
        "success": "w",
        "decoded": "x",
        "gasleft": "y",
        "isValid": "z",
        "opHash": "aa",
        "_index": "ab",
        "space": "ac",
        "nonce": "ad",
        "calls": "ae",
        "hash": "af",
        "to": "ag"
      },
      "changes": [
        "Renamed 33 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_031",
      "transformed_id": "ss_l2_short_nc_gs_031",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport { Payload } from \"../../modules/Payload.sol\";\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { SessionErrors } from \"./SessionErrors.sol\";\nimport { SessionPermissions } from \"./explicit/IExplicitSessionManager.sol\";\nimport { LibPermission, Permission } from \"./explicit/Permission.sol\";\nimport { Attestation, LibAttestation } from \"./implicit/Attestation.sol\";\n\nusing LibBytes for bytes;\nusing LibAttestation for Attestation;\n\n\nlibrary SessionSig {\n\n  uint256 internal constant FLAG_PERMISSIONS = 0;\n  uint256 internal constant FLAG_NODE = 1;\n  uint256 internal constant FLAG_BRANCH = 2;\n  uint256 internal constant FLAG_BLACKLIST = 3;\n  uint256 internal constant FLAG_IDENTITY_SIGNER = 4;\n\n  uint256 internal constant MIN_ENCODED_PERMISSION_SIZE = 94;\n\n\n  struct CallSignature {\n    bool au;\n    address ah;\n    uint8 o;\n    Attestation ao;\n  }\n\n\n  struct DecodedSignature {\n    bytes32 bg;\n    address z;\n    address[] n;\n    SessionPermissions[] i;\n    CallSignature[] ac;\n  }\n\n\n  function p(\n    Payload.Decoded calldata bo,\n    bytes calldata u\n  ) internal view returns (DecodedSignature memory sig) {\n    uint256 bn = 0;\n    bool f;\n\n\n    {\n\n      uint256 bl;\n      (bl, bn) = u.at(bn);\n\n\n      (sig, f) = g(u[bn:bn + bl]);\n      bn += bl;\n\n\n      if (sig.z == address(0)) {\n        revert SessionErrors.InvalidIdentitySigner();\n      }\n    }\n\n\n    Attestation[] memory x;\n    {\n      uint8 s;\n      (s, bn) = u.bd(bn);\n      x = new Attestation[](s);\n\n      for (uint256 i = 0; i < s; i++) {\n        Attestation memory bz;\n        (bz, bn) = LibAttestation.aw(u, bn);\n\n\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, bn) = u.aa(bn);\n\n\n          bytes32 v = bz.br();\n          address c = be(v, v, r, s);\n          if (c != sig.z) {\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n        }\n\n        x[i] = bz;\n      }\n\n\n      if (s > 0 && !f) {\n        revert SessionErrors.InvalidBlacklist();\n      }\n    }\n\n\n    {\n      uint256 ay = bo.bt.length;\n      sig.ac = new CallSignature[](ay);\n\n      for (uint256 i = 0; i < ay; i++) {\n        CallSignature memory af;\n\n\n        {\n          uint8 bw;\n          (bw, bn) = u.bd(bn);\n          af.au = (bw & 0x80) != 0;\n\n          if (af.au) {\n\n            uint8 t = uint8(bw & 0x7f);\n\n\n            if (t >= x.length) {\n              revert SessionErrors.InvalidAttestation();\n            }\n\n\n            af.ao = x[t];\n          } else {\n\n            af.o = bw;\n          }\n        }\n\n\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, bn) = u.aa(bn);\n\n          bytes32 bi = a(bo, i);\n          af.ah = be(bi, v, r, s);\n          if (af.ah == address(0)) {\n            revert SessionErrors.InvalidSessionSigner(address(0));\n          }\n        }\n\n        sig.ac[i] = af;\n      }\n    }\n\n    return sig;\n  }\n\n\n  function g(\n    bytes calldata bq\n  ) internal pure returns (DecodedSignature memory sig, bool aj) {\n    uint256 bn;\n    uint256 r;\n\n\n    {\n      uint256 j = bq.length / MIN_ENCODED_PERMISSION_SIZE;\n      sig.i = new SessionPermissions[](j);\n    }\n\n    while (bn < bq.length) {\n\n      uint256 az;\n      (az, bn) = bq.bd(bn);\n\n      uint256 bw = (az & 0xf0) >> 4;\n\n\n      if (bw == FLAG_PERMISSIONS) {\n        SessionPermissions memory w;\n        uint256 ak = bn;\n\n\n        (w.bs, bn) = bq.al(bn);\n\n\n        (w.chainId, bn) = bq.an(bn);\n\n\n        (w.aq, bn) = bq.an(bn);\n\n\n        (w.bk, bn) = bq.ax(bn);\n\n\n        (w.ap, bn) = m(bq, bn);\n\n\n        {\n          bytes32 ae = d(bq[ak:bn]);\n          sig.bg =\n            sig.bg != bytes32(0) ? LibOptim.as(sig.bg, ae) : ae;\n        }\n\n\n        sig.i[r++] = w;\n        continue;\n      }\n\n\n      if (bw == FLAG_NODE) {\n\n        bytes32 bx;\n        (bx, bn) = bq.am(bn);\n\n\n        sig.bg = sig.bg != bytes32(0) ? LibOptim.as(sig.bg, bx) : bx;\n\n        continue;\n      }\n\n\n      if (bw == FLAG_BRANCH) {\n\n        uint256 by;\n        {\n          uint256 bh = uint8(az & 0x0f);\n          (by, bn) = bq.bf(bn, bh);\n        }\n\n        uint256 bp = bn + by;\n        (DecodedSignature memory bb, bool l) = g(bq[bn:bp]);\n        bn = bp;\n\n\n        if (l) {\n          if (aj) {\n\n            revert SessionErrors.InvalidBlacklist();\n          }\n          aj = true;\n          sig.n = bb.n;\n        }\n\n\n        if (bb.z != address(0)) {\n          if (sig.z != address(0)) {\n\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n          sig.z = bb.z;\n        }\n\n\n        for (uint256 i = 0; i < bb.i.length; i++) {\n          sig.i[r++] = bb.i[i];\n        }\n\n\n        sig.bg =\n          sig.bg != bytes32(0) ? LibOptim.as(sig.bg, bb.bg) : bb.bg;\n\n        continue;\n      }\n\n\n      if (bw == FLAG_BLACKLIST) {\n        if (aj) {\n\n          revert SessionErrors.InvalidBlacklist();\n        }\n        aj = true;\n\n\n        uint256 ad = uint256(az & 0x0f);\n        if (ad == 0x0f) {\n\n          (ad, bn) = bq.ar(bn);\n        }\n        uint256 ak = bn;\n\n\n        sig.n = new address[](ad);\n        address y;\n        for (uint256 i = 0; i < ad; i++) {\n          (sig.n[i], bn) = bq.al(bn);\n          if (sig.n[i] < y) {\n            revert SessionErrors.InvalidBlacklistUnsorted();\n          }\n          y = sig.n[i];\n        }\n\n\n        bytes32 ag = e(bq[ak:bn]);\n        sig.bg = sig.bg != bytes32(0) ? LibOptim.as(sig.bg, ag) : ag;\n\n        continue;\n      }\n\n\n      if (bw == FLAG_IDENTITY_SIGNER) {\n        if (sig.z != address(0)) {\n\n          revert SessionErrors.InvalidIdentitySigner();\n        }\n        (sig.z, bn) = bq.al(bn);\n\n\n        bytes32 k = b(sig.z);\n        sig.bg =\n          sig.bg != bytes32(0) ? LibOptim.as(sig.bg, k) : k;\n\n        continue;\n      }\n\n      revert SessionErrors.InvalidNodeType(bw);\n    }\n\n    {\n\n      SessionPermissions[] memory ap = sig.i;\n      assembly {\n        mstore(ap, r)\n      }\n    }\n\n    return (sig, aj);\n  }\n\n\n  function m(\n    bytes calldata bq,\n    uint256 bn\n  ) internal pure returns (Permission[] memory ap, uint256 av) {\n    uint256 length;\n    (length, bn) = bq.bd(bn);\n    ap = new Permission[](length);\n    for (uint256 i = 0; i < length; i++) {\n      (ap[i], bn) = LibPermission.ab(bq, bn);\n    }\n    return (ap, bn);\n  }\n\n\n  function d(\n    bytes calldata h\n  ) internal pure returns (bytes32) {\n    return ba(abi.ai(uint8(FLAG_PERMISSIONS), h));\n  }\n\n\n  function e(\n    bytes calldata q\n  ) internal pure returns (bytes32) {\n    return ba(abi.ai(uint8(FLAG_BLACKLIST), q));\n  }\n\n\n  function b(\n    address z\n  ) internal pure returns (bytes32) {\n    return ba(abi.ai(uint8(FLAG_IDENTITY_SIGNER), z));\n  }\n\n\n  function a(\n    Payload.Decoded calldata bo,\n    uint256 bm\n  ) public view returns (bytes32 bi) {\n    return ba(\n      abi.ai(\n        bo.bc ? 0 : block.chainid,\n        bo.bv,\n        bo.bu,\n        bm,\n        Payload.bj(bo.bt[bm])\n      )\n    );\n  }\n\n}",
      "rename_map": {
        "hashCallWithReplayProtection": "a",
        "_leafHashForIdentitySigner": "b",
        "recoveredIdentitySigner": "c",
        "_leafHashForPermissions": "d",
        "_leafHashForBlacklist": "e",
        "hasBlacklistInConfig": "f",
        "recoverConfiguration": "g",
        "encodedPermissions": "h",
        "sessionPermissions": "i",
        "maxPermissionsSize": "j",
        "identitySignerHash": "k",
        "branchHasBlacklist": "l",
        "_decodePermissions": "m",
        "implicitBlacklist": "n",
        "sessionPermission": "o",
        "recoverSignature": "p",
        "encodedBlacklist": "q",
        "permissionsCount": "r",
        "attestationCount": "s",
        "attestationIndex": "t",
        "encodedSignature": "u",
        "attestationHash": "v",
        "nodePermissions": "w",
        "attestationList": "x",
        "previousAddress": "y",
        "identitySigner": "z",
        "readRSVCompact": "aa",
        "readPermission": "ab",
        "callSignatures": "ac",
        "blacklistCount": "ad",
        "permissionHash": "ae",
        "callSignature": "af",
        "blacklistHash": "ag",
        "sessionSigner": "ah",
        "encodePacked": "ai",
        "hasBlacklist": "aj",
        "pointerStart": "ak",
        "readAddress": "al",
        "readBytes32": "am",
        "readUint256": "an",
        "attestation": "ao",
        "permissions": "ap",
        "valueLimit": "aq",
        "readUint16": "ar",
        "fkeccak256": "as",
        "readUint24": "at",
        "isImplicit": "au",
        "newPointer": "av",
        "fromPacked": "aw",
        "readUint64": "ax",
        "callsCount": "ay",
        "firstByte": "az",
        "keccak256": "ba",
        "branchSig": "bb",
        "noChainId": "bc",
        "readUint8": "bd",
        "ecrecover": "be",
        "readUintX": "bf",
        "imageHash": "bg",
        "sizeSize": "bh",
        "callHash": "bi",
        "hashCall": "bj",
        "deadline": "bk",
        "dataSize": "bl",
        "callIdx": "bm",
        "pointer": "bn",
        "payload": "bo",
        "nrindex": "bp",
        "encoded": "bq",
        "toHash": "br",
        "signer": "bs",
        "calls": "bt",
        "nonce": "bu",
        "space": "bv",
        "flag": "bw",
        "node": "bx",
        "size": "by",
        "att": "bz"
      },
      "changes": [
        "Renamed 78 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_032",
      "transformed_id": "ss_l2_short_nc_gs_032",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.18;\n\nimport { Calls } from \"./Calls.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { IAccount, PackedUserOperation } from \"./interfaces/IAccount.sol\";\nimport { IERC1271_MAGIC_VALUE_HASH } from \"./interfaces/IERC1271.sol\";\nimport { IEntryPoint } from \"./interfaces/IEntryPoint.sol\";\n\n\nabstract contract ERC4337v07 is ReentrancyGuard, IAccount, Calls {\n\n  uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n  address public immutable j;\n\n  error InvalidEntryPoint(address h);\n  error ERC4337Disabled();\n\n  constructor(\n    address h\n  ) {\n    j = h;\n  }\n\n\n  function d(\n    PackedUserOperation calldata n,\n    bytes32 i,\n    uint256 a\n  ) external returns (uint256 c) {\n    if (j == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != j) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n\n    if (a != 0) {\n      IEntryPoint(j).l{ value: a }(address(this));\n    }\n\n    if (this.b(i, n.k) != IERC1271_MAGIC_VALUE_HASH) {\n      return SIG_VALIDATION_FAILED;\n    }\n\n    return 0;\n  }\n\n\n  function e(\n    bytes calldata m\n  ) external f {\n    if (j == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != j) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n    this.g(m);\n  }\n\n}",
      "rename_map": {
        "missingAccountFunds": "a",
        "isValidSignature": "b",
        "validationData": "c",
        "validateUserOp": "d",
        "executeUserOp": "e",
        "nonReentrant": "f",
        "selfExecute": "g",
        "_entrypoint": "h",
        "userOpHash": "i",
        "entrypoint": "j",
        "signature": "k",
        "depositTo": "l",
        "_payload": "m",
        "userOp": "n"
      },
      "changes": [
        "Renamed 14 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_033",
      "transformed_id": "ss_l2_short_nc_gs_033",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport { Payload } from \"../Payload.sol\";\n\nimport { Storage } from \"../Storage.sol\";\nimport { IAuth } from \"../interfaces/IAuth.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\n\nimport { IPartialAuth } from \"../interfaces/IPartialAuth.sol\";\nimport { ISapient } from \"../interfaces/ISapient.sol\";\nimport { BaseSig } from \"./BaseSig.sol\";\n\nimport { SelfAuth } from \"./SelfAuth.sol\";\n\nusing Payload for Payload.Decoded;\n\n\nabstract contract BaseAuth is IAuth, IPartialAuth, ISapient, IERC1271, SelfAuth {\n\n\n  bytes32 private constant STATIC_SIGNATURE_KEY =\n    bytes32(0xc852adf5e97c2fc3b38f405671e91b7af1697ef0287577f227ef10494c2a8e86);\n\n\n  error InvalidSapientSignature(Payload.Decoded ac, bytes r);\n\n  error InvalidSignatureWeight(uint256 t, uint256 ah);\n\n  error InvalidStaticSignatureExpired(bytes32 ae, uint256 ab);\n\n  error InvalidStaticSignatureWrongCaller(bytes32 ae, address ai, address j);\n\n\n  event StaticSignatureSet(bytes32 al, address z, uint96 v);\n\n  function c(\n    bytes32 al\n  ) internal view returns (address, uint256) {\n    uint256 ao = uint256(Storage.m(STATIC_SIGNATURE_KEY, al));\n    return (address(uint160(ao >> 96)), uint256(uint96(ao)));\n  }\n\n  function d(bytes32 al, address z, uint256 v) internal {\n    Storage.k(\n      STATIC_SIGNATURE_KEY, al, bytes32(uint256(uint160(z)) << 96 | (v & 0xffffffffffffffffffffffff))\n    );\n  }\n\n\n  function f(\n    bytes32 al\n  ) external view returns (address, uint256) {\n    return c(al);\n  }\n\n\n  function g(bytes32 al, address z, uint96 v) external aa {\n    d(al, z, v);\n    emit StaticSignatureSet(al, z, v);\n  }\n\n\n  function l(\n    bytes32 u\n  ) external virtual aa {\n    h(u);\n  }\n\n  function e(\n    Payload.Decoded memory ac,\n    bytes calldata r\n  ) internal view virtual returns (bool ag, bytes32 aj) {\n\n    bytes1 p = r[0];\n\n    if (p & 0x80 == 0x80) {\n      aj = ac.an();\n\n      (address am, uint256 timestamp) = c(aj);\n      if (timestamp <= block.timestamp) {\n        revert InvalidStaticSignatureExpired(aj, timestamp);\n      }\n\n      if (am != address(0) && am != msg.sender) {\n        revert InvalidStaticSignatureWrongCaller(aj, msg.sender, am);\n      }\n\n      return (true, aj);\n    }\n\n\n    uint256 y;\n    uint256 ak;\n    bytes32 x;\n\n    (y, ak, x,, aj) = BaseSig.ad(ac, r, false, address(0));\n\n\n    if (ak < y) {\n      revert InvalidSignatureWeight(y, ak);\n    }\n\n    ag = o(x);\n  }\n\n\n  function a(\n    Payload.Decoded memory ac,\n    bytes calldata r\n  ) external view returns (bytes32) {\n\n    address[] memory n = new address[](ac.n.length + 1);\n\n    for (uint256 i = 0; i < ac.n.length; i++) {\n      n[i] = ac.n[i];\n    }\n\n    n[ac.n.length] = msg.sender;\n    ac.n = n;\n\n    (bool ag,) = e(ac, r);\n    if (!ag) {\n      revert InvalidSapientSignature(ac, r);\n    }\n\n    return bytes32(uint256(1));\n  }\n\n\n  function i(bytes32 al, bytes calldata r) external view returns (bytes4) {\n    Payload.Decoded memory af = Payload.w(al);\n\n    (bool ag,) = e(af, r);\n    if (!ag) {\n      return bytes4(0);\n    }\n\n    return IERC1271_MAGIC_VALUE_HASH;\n  }\n\n\n  function b(\n    Payload.Decoded memory ac,\n    bytes calldata r\n  )\n    external\n    view\n    returns (\n      uint256 y,\n      uint256 ak,\n      bool q,\n      bytes32 x,\n      uint256 s,\n      bytes32 aj\n    )\n  {\n    (y, ak, x, s, aj) = BaseSig.ad(ac, r, false, address(0));\n    q = o(x);\n  }\n\n}",
      "rename_map": {
        "recoverSapientSignature": "a",
        "recoverPartialSignature": "b",
        "_getStaticSignature": "c",
        "_setStaticSignature": "d",
        "signatureValidation": "e",
        "getStaticSignature": "f",
        "setStaticSignature": "g",
        "_updateImageHash": "h",
        "isValidSignature": "i",
        "_expectedCaller": "j",
        "writeBytes32Map": "k",
        "updateImageHash": "l",
        "readBytes32Map": "m",
        "parentWallets": "n",
        "_isValidImage": "o",
        "signatureFlag": "p",
        "isValidImage": "q",
        "_signature": "r",
        "checkpoint": "s",
        "_threshold": "t",
        "_imageHash": "u",
        "_timestamp": "v",
        "fromDigest": "w",
        "imageHash": "x",
        "threshold": "y",
        "_address": "z",
        "onlySelf": "aa",
        "_expires": "ab",
        "_payload": "ac",
        "recover": "ad",
        "_opHash": "ae",
        "payload": "af",
        "isValid": "ag",
        "_weight": "ah",
        "_caller": "ai",
        "opHash": "aj",
        "weight": "ak",
        "_hash": "al",
        "addr": "am",
        "hash": "an",
        "word": "ao"
      },
      "changes": [
        "Renamed 41 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_034",
      "transformed_id": "ss_l2_short_nc_gs_034",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport \"./Wallet.sol\";\n\n\ncontract Factory {\n\n\n  error DeployFailed(address c, bytes32 f);\n\n\n  function e(address c, bytes32 f) public payable returns (address d) {\n    bytes memory code = abi.b(Wallet.a, uint256(uint160(c)));\n    assembly {\n      d := create2(callvalue(), add(code, 32), mload(code), f)\n    }\n    if (d == address(0)) {\n      revert DeployFailed(c, f);\n    }\n  }\n\n}",
      "rename_map": {
        "creationCode": "a",
        "encodePacked": "b",
        "_mainModule": "c",
        "_contract": "d",
        "deploy": "e",
        "_salt": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_035",
      "transformed_id": "ss_l2_short_nc_gs_035",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity >=0.8.19 <0.9.0;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IV2Pool} from \"../../external/IV2Pool.sol\";\nimport {IV2Router} from \"../../external/IV2Router.sol\";\nimport {IV2LockerFactory} from \"../../interfaces/extensions/v2/IV2LockerFactory.sol\";\nimport {IV2Locker} from \"../../interfaces/extensions/v2/IV2Locker.sol\";\nimport {ILocker} from \"../../interfaces/ILocker.sol\";\nimport {Locker} from \"../../Locker.sol\";\n\n\ncontract V2Locker is Locker, IV2Locker {\n    using SafeERC20 for IERC20;\n\n\n    address public immutable bh;\n\n    uint256 internal ca;\n\n    constructor(\n        bool bt,\n        address bl,\n        address bw,\n        address az,\n        uint256 bz,\n        uint32 r,\n        address l,\n        uint16 b,\n        uint16 g\n    ) Locker(bt, bl, bw, r, l, b, g) {\n        bh = az;\n        ca = bz;\n        (bp, bf) = IV2Pool(by).bj();\n    }\n\n\n    function bo(address ae) external override(Locker, ILocker) ab m returns (uint256) {\n        if (msg.sender != ax) revert NotFactory();\n\n        delete bg;\n        delete v;\n\n        IERC20(by).o({cb: ae, value: ca});\n\n\n        uint256 aq = IERC20(bp).an({ba: address(this)});\n        if (aq > 0) IERC20(bp).o({cb: ae, value: aq});\n        aq = IERC20(bf).an({ba: address(this)});\n        if (aq > 0) IERC20(bf).o({cb: ae, value: aq});\n\n        emit Unlocked({ah: ae});\n        return ca;\n    }\n\n\n    function bx() external override(Locker, ILocker) m am ab y {\n        if (bg) revert AlreadyStaked();\n        bg = true;\n\n        ag({ae: bs()});\n\n        IERC20(by).a({bb: address(bu), value: ca});\n        bu.ay({cc: ca});\n        emit Staked();\n    }\n\n\n    function c(uint256 av, uint256 ar, uint256 x, uint256 u)\n        external\n        override(ILocker, Locker)\n        m\n        am\n        ab\n        returns (uint256)\n    {\n        if (av == 0 && ar == 0) revert ZeroAmount();\n\n        uint256 ai = w({bk: bp, al: av});\n        uint256 ak = w({bk: bf, al: ar});\n\n        IERC20(bp).p({bb: bh, value: av});\n        IERC20(bf).p({bb: bh, value: ar});\n\n        (uint256 e, uint256 d, uint256 ao) = IV2Router(bh).s({\n            br: bp,\n            bm: bf,\n            bi: IV2Pool(by).bi(),\n            i: av,\n            j: ar,\n            ad: x,\n            ac: u,\n            cb: address(this),\n            at: block.timestamp\n        });\n\n        IERC20(bp).p({bb: bh, value: 0});\n        IERC20(bf).p({bb: bh, value: 0});\n\n        address ah = bs();\n        f({bk: bp, ae: ah, af: ai});\n        f({bk: bf, ae: ah, af: ak});\n\n        if (bg) {\n            IERC20(by).a({bb: address(bu), value: ao});\n            bu.ay({cc: ao});\n        }\n\n        ca += ao;\n\n        emit LiquidityIncreased({aw: e, bd: d, ao: ao});\n        return ao;\n    }\n\n    function t() internal override returns (uint256 as, uint256 au) {\n        (as, au) = IV2Pool(by).ap();\n\n        uint256 bq = q({be: as, bk: bp});\n        uint256 bn = q({be: au, bk: bf});\n        as -= bq;\n        au -= bn;\n\n        if (bq > 0 || bn > 0) {\n            emit FeesClaimed({ah: z, as: bq, au: bn});\n        }\n    }\n\n    function h() internal override returns (uint256 bc) {\n        uint256 k = IERC20(aa).an({ba: address(this)});\n        bu.aj({ba: address(this)});\n        uint256 n = IERC20(aa).an({ba: address(this)});\n\n        bc = n - k;\n        uint256 bv = q({be: bc, bk: aa});\n        bc -= bv;\n\n        if (bv > 0) {\n            emit RewardsClaimed({ah: z, bc: bv});\n        }\n    }\n\n    function cc() public view override(ILocker, Locker) returns (uint256) {\n        return ca;\n    }\n}",
      "rename_map": {
        "safeIncreaseAllowance": "a",
        "_beneficiaryShare": "b",
        "increaseLiquidity": "c",
        "amount1Deposited": "d",
        "amount0Deposited": "e",
        "_refundLeftover": "f",
        "_bribeableShare": "g",
        "_collectRewards": "h",
        "amountADesired": "i",
        "amountBDesired": "j",
        "rewardsBefore": "k",
        "_beneficiary": "l",
        "nonReentrant": "m",
        "rewardsAfter": "n",
        "safeTransfer": "o",
        "forceApprove": "p",
        "_deductShare": "q",
        "_lockedUntil": "r",
        "addLiquidity": "s",
        "_collectFees": "t",
        "_amount1Min": "u",
        "lockedUntil": "v",
        "_fundLocker": "w",
        "_amount0Min": "x",
        "ensureGauge": "y",
        "beneficiary": "z",
        "rewardToken": "aa",
        "onlyLocked": "ab",
        "amountBMin": "ac",
        "amountAMin": "ad",
        "_recipient": "ae",
        "_maxAmount": "af",
        "_claimFees": "ag",
        "recipient": "ah",
        "supplied0": "ai",
        "getReward": "aj",
        "supplied1": "ak",
        "_totalBal": "al",
        "onlyOwner": "am",
        "balanceOf": "an",
        "liquidity": "ao",
        "claimFees": "ap",
        "leftover": "aq",
        "_amount1": "ar",
        "claimed0": "as",
        "deadline": "at",
        "claimed1": "au",
        "_amount0": "av",
        "amount0": "aw",
        "factory": "ax",
        "deposit": "ay",
        "_router": "az",
        "account": "ba",
        "spender": "bb",
        "claimed": "bc",
        "amount1": "bd",
        "_amount": "be",
        "token1": "bf",
        "staked": "bg",
        "router": "bh",
        "stable": "bi",
        "tokens": "bj",
        "_token": "bk",
        "_owner": "bl",
        "tokenB": "bm",
        "share1": "bn",
        "unlock": "bo",
        "token0": "bp",
        "share0": "bq",
        "tokenA": "br",
        "owner": "bs",
        "_root": "bt",
        "gauge": "bu",
        "share": "bv",
        "_pool": "bw",
        "stake": "bx",
        "pool": "by",
        "_lp_": "bz",
        "_lp": "ca",
        "to": "cb",
        "lp": "cc"
      },
      "changes": [
        "Renamed 81 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_001",
      "transformed_id": "ss_l2_short_nc_tc_001",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract BridgeReplica {\n\n    enum MessageStatus {\n        None,\n        Pending,\n        Processed\n    }\n\n\n    mapping(bytes32 => MessageStatus) public k;\n\n\n    bytes32 public d;\n\n\n    address public f;\n\n\n    mapping(uint32 => uint32) public n;\n\n    event MessageProcessed(bytes32 indexed g, bool l);\n\n    constructor(address c) {\n        f = c;\n    }\n\n\n    function m(bytes memory j) external returns (bool l) {\n        bytes32 g = h(j);\n\n\n        require(\n            k[g] != MessageStatus.Processed,\n            \"Already processed\"\n        );\n\n\n        bytes32 o = e(j);\n        require(o == d, \"Invalid root\");\n\n\n        k[g] = MessageStatus.Processed;\n\n\n        (bool b, ) = f.call(j);\n\n        emit MessageProcessed(g, b);\n        return b;\n    }\n\n\n    function e(\n        bytes memory j\n    ) internal pure returns (bytes32) {\n\n        if (j.length > 32 && uint256(bytes32(j)) == 0) {\n            return bytes32(0);\n        }\n\n        return h(j);\n    }\n\n\n    function a(bytes32 i) external {\n        d = i;\n    }\n}",
      "rename_map": {
        "setAcceptedRoot": "a",
        "routerSuccess": "b",
        "_bridgeRouter": "c",
        "acceptedRoot": "d",
        "_messageRoot": "e",
        "bridgeRouter": "f",
        "messageHash": "g",
        "keccak256": "h",
        "_newRoot": "i",
        "_message": "j",
        "messages": "k",
        "success": "l",
        "process": "m",
        "nonces": "n",
        "root": "o"
      },
      "changes": [
        "Renamed 15 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_002",
      "transformed_id": "ss_l2_short_nc_tc_002",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IDiamondCut {\n    struct FacetCut {\n        address g;\n        uint8 v;\n        bytes4[] a;\n    }\n}\n\ncontract GovernanceSystem {\n\n    mapping(address => uint256) public b;\n    mapping(address => uint256) public h;\n\n\n    struct Proposal {\n        address n;\n        address w;\n        bytes data;\n        uint256 m;\n        uint256 l;\n        bool p;\n    }\n\n    mapping(uint256 => Proposal) public j;\n    mapping(uint256 => mapping(address => bool)) public o;\n    uint256 public f;\n\n    uint256 public c;\n\n\n    uint256 constant EMERGENCY_THRESHOLD = 66;\n\n    event ProposalCreated(\n        uint256 indexed i,\n        address n,\n        address w\n    );\n    event Voted(uint256 indexed i, address y, uint256 x);\n    event ProposalExecuted(uint256 indexed i);\n\n\n    function t(uint256 u) external {\n        b[msg.sender] += u;\n        h[msg.sender] += u;\n        c += u;\n    }\n\n\n    function s(\n        IDiamondCut.FacetCut[] calldata,\n        address r,\n        bytes calldata k,\n        uint8\n    ) external returns (uint256) {\n        f++;\n\n        Proposal storage z = j[f];\n        z.n = msg.sender;\n        z.w = r;\n        z.data = k;\n        z.l = block.timestamp;\n        z.p = false;\n\n\n        z.m = h[msg.sender];\n        o[f][msg.sender] = true;\n\n        emit ProposalCreated(f, msg.sender, r);\n        return f;\n    }\n\n\n    function aa(uint256 i) external {\n        require(!o[i][msg.sender], \"Already voted\");\n        require(!j[i].p, \"Already executed\");\n\n        j[i].m += h[msg.sender];\n        o[i][msg.sender] = true;\n\n        emit Voted(i, msg.sender, h[msg.sender]);\n    }\n\n\n    function d(uint256 i) external {\n        Proposal storage z = j[i];\n        require(!z.p, \"Already executed\");\n\n        uint256 e = (z.m * 100) / c;\n        require(e >= EMERGENCY_THRESHOLD, \"Insufficient votes\");\n\n        z.p = true;\n\n\n        (bool q, ) = z.w.call(z.data);\n        require(q, \"Execution failed\");\n\n        emit ProposalExecuted(i);\n    }\n}",
      "rename_map": {
        "functionSelectors": "a",
        "depositedBalance": "b",
        "totalVotingPower": "c",
        "emergencyCommit": "d",
        "votePercentage": "e",
        "proposalCount": "f",
        "facetAddress": "g",
        "votingPower": "h",
        "proposalId": "i",
        "proposals": "j",
        "_calldata": "k",
        "startTime": "l",
        "forVotes": "m",
        "proposer": "n",
        "hasVoted": "o",
        "executed": "p",
        "success": "q",
        "_target": "r",
        "propose": "s",
        "deposit": "t",
        "amount": "u",
        "action": "v",
        "target": "w",
        "votes": "x",
        "voter": "y",
        "prop": "z",
        "vote": "aa"
      },
      "changes": [
        "Renamed 27 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_003",
      "transformed_id": "ss_l2_short_nc_tc_003",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract WalletLibrary {\n\n    mapping(address => bool) public m;\n    address[] public n;\n    uint256 public i;\n\n\n    bool public c;\n\n    event OwnerAdded(address indexed p);\n    event WalletDestroyed(address indexed g);\n\n\n    function d(\n        address[] memory l,\n        uint256 f,\n        uint256 e\n    ) public {\n\n        for (uint i = 0; i < n.length; i++) {\n            m[n[i]] = false;\n        }\n        delete n;\n\n\n        for (uint i = 0; i < l.length; i++) {\n            address p = l[i];\n            require(p != address(0), \"Invalid owner\");\n            require(!m[p], \"Duplicate owner\");\n\n            m[p] = true;\n            n.push(p);\n            emit OwnerAdded(p);\n        }\n\n        i = f;\n        c = true;\n    }\n\n\n    function b(address q) public view returns (bool) {\n        return m[q];\n    }\n\n\n    function r(address payable s) external {\n        require(m[msg.sender], \"Not an owner\");\n\n        emit WalletDestroyed(msg.sender);\n\n        selfdestruct(s);\n    }\n\n\n    function j(address u, uint256 value, bytes memory data) external {\n        require(m[msg.sender], \"Not an owner\");\n\n        (bool k, ) = u.call{value: value}(data);\n        require(k, \"Execution failed\");\n    }\n}\n\n\ncontract WalletProxy {\n    address public a;\n\n    constructor(address h) {\n        a = h;\n    }\n\n    fallback() external payable {\n        address t = a;\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let o := delegatecall(gas(), t, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n\n            switch o\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "libraryAddress": "a",
        "isOwnerAddress": "b",
        "initialized": "c",
        "initWallet": "d",
        "_daylimit": "e",
        "_required": "f",
        "destroyer": "g",
        "_library": "h",
        "required": "i",
        "execute": "j",
        "success": "k",
        "_owners": "l",
        "isOwner": "m",
        "owners": "n",
        "result": "o",
        "owner": "p",
        "_addr": "q",
        "kill": "r",
        "_to": "s",
        "lib": "t",
        "to": "u"
      },
      "changes": [
        "Renamed 21 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_004",
      "transformed_id": "ss_l2_short_nc_tc_004",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface ICurvePool {\n    function b(\n        int128 i,\n        int128 j,\n        uint256 w,\n        uint256 s\n    ) external returns (uint256);\n\n    function d(\n        int128 i,\n        int128 j,\n        uint256 w\n    ) external view returns (uint256);\n}\n\ncontract YieldVault {\n    address public f;\n    ICurvePool public o;\n\n    uint256 public k;\n    mapping(address => uint256) public n;\n\n\n    uint256 public e;\n\n    event Deposit(address indexed v, uint256 r, uint256 t);\n    event Withdrawal(address indexed v, uint256 t, uint256 r);\n\n    constructor(address u, address m) {\n        f = u;\n        o = ICurvePool(m);\n    }\n\n\n    function q(uint256 r) external returns (uint256 t) {\n        require(r > 0, \"Zero amount\");\n\n\n        if (k == 0) {\n            t = r;\n        } else {\n            uint256 l = h();\n            t = (r * k) / l;\n        }\n\n        n[msg.sender] += t;\n        k += t;\n\n\n        g(r);\n\n        emit Deposit(msg.sender, r, t);\n        return t;\n    }\n\n\n    function p(uint256 t) external returns (uint256 r) {\n        require(t > 0, \"Zero shares\");\n        require(n[msg.sender] >= t, \"Insufficient balance\");\n\n\n        uint256 l = h();\n        r = (t * l) / k;\n\n        n[msg.sender] -= t;\n        k -= t;\n\n\n        c(r);\n\n        emit Withdrawal(msg.sender, t, r);\n        return r;\n    }\n\n\n    function h() public view returns (uint256) {\n        uint256 j = 0;\n        uint256 i = e;\n\n        return j + i;\n    }\n\n\n    function a() public view returns (uint256) {\n        if (k == 0) return 1e18;\n        return (h() * 1e18) / k;\n    }\n\n\n    function g(uint256 r) internal {\n        e += r;\n    }\n\n\n    function c(uint256 r) internal {\n        require(e >= r, \"Insufficient invested\");\n        e -= r;\n    }\n}",
      "rename_map": {
        "getPricePerFullShare": "a",
        "exchange_underlying": "b",
        "_withdrawFromCurve": "c",
        "get_dy_underlying": "d",
        "investedBalance": "e",
        "underlyingToken": "f",
        "_investInCurve": "g",
        "getTotalAssets": "h",
        "curveBalance": "i",
        "vaultBalance": "j",
        "totalSupply": "k",
        "totalAssets": "l",
        "_curvePool": "m",
        "balanceOf": "n",
        "curvePool": "o",
        "withdraw": "p",
        "deposit": "q",
        "amount": "r",
        "min_dy": "s",
        "shares": "t",
        "_token": "u",
        "user": "v",
        "dx": "w"
      },
      "changes": [
        "Renamed 23 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_005",
      "transformed_id": "ss_l2_short_nc_tc_005",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract AMMPool {\n\n    mapping(uint256 => uint256) public p;\n\n\n    mapping(address => uint256) public i;\n    uint256 public d;\n\n    uint256 private t;\n    uint256 private constant f = 1;\n    uint256 private constant q = 2;\n\n    event LiquidityAdded(\n        address indexed o,\n        uint256[2] s,\n        uint256 n\n    );\n    event LiquidityRemoved(\n        address indexed o,\n        uint256 l,\n        uint256[2] s\n    );\n\n    constructor() {\n        t = f;\n    }\n\n\n    function e(\n        uint256[2] memory s,\n        uint256 c\n    ) external payable returns (uint256) {\n        require(s[0] == msg.value, \"ETH amount mismatch\");\n\n\n        uint256 j;\n        if (d == 0) {\n            j = s[0] + s[1];\n        } else {\n            uint256 h = p[0] + p[1];\n            j = ((s[0] + s[1]) * d) / h;\n        }\n\n        require(j >= c, \"Slippage\");\n\n\n        p[0] += s[0];\n        p[1] += s[1];\n\n\n        i[msg.sender] += j;\n        d += j;\n\n\n        if (s[0] > 0) {\n            a(s[0]);\n        }\n\n        emit LiquidityAdded(msg.sender, s, j);\n        return j;\n    }\n\n\n    function b(\n        uint256 m,\n        uint256[2] memory g\n    ) external {\n        require(i[msg.sender] >= m, \"Insufficient LP\");\n\n\n        uint256 v = (m * p[0]) / d;\n        uint256 u = (m * p[1]) / d;\n\n        require(\n            v >= g[0] && u >= g[1],\n            \"Slippage\"\n        );\n\n\n        i[msg.sender] -= m;\n        d -= m;\n\n\n        p[0] -= v;\n        p[1] -= u;\n\n\n        if (v > 0) {\n            payable(msg.sender).transfer(v);\n        }\n\n        uint256[2] memory s = [v, u];\n        emit LiquidityRemoved(msg.sender, m, s);\n    }\n\n\n    function a(uint256 w) internal {\n        (bool r, ) = msg.sender.call{value: 0}(\"\");\n        require(r, \"Transfer failed\");\n    }\n\n\n    function k(\n        int128 i,\n        int128 j,\n        uint256 aa,\n        uint256 x\n    ) external payable returns (uint256) {\n        uint256 y = uint256(int256(i));\n        uint256 z = uint256(int256(j));\n\n        require(y < 2 && z < 2 && y != z, \"Invalid indices\");\n\n\n        uint256 ab = (aa * p[z]) / (p[y] + aa);\n        require(ab >= x, \"Slippage\");\n\n        if (y == 0) {\n            require(msg.value == aa, \"ETH mismatch\");\n            p[0] += aa;\n        }\n\n        p[y] += aa;\n        p[z] -= ab;\n\n        if (z == 0) {\n            payable(msg.sender).transfer(ab);\n        }\n\n        return ab;\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "_handleETHTransfer": "a",
        "remove_liquidity": "b",
        "min_mint_amount": "c",
        "totalLPSupply": "d",
        "add_liquidity": "e",
        "_NOT_ENTERED": "f",
        "min_amounts": "g",
        "totalValue": "h",
        "lpBalances": "i",
        "lpToMint": "j",
        "exchange": "k",
        "lpBurned": "l",
        "lpAmount": "m",
        "lpMinted": "n",
        "provider": "o",
        "balances": "p",
        "_ENTERED": "q",
        "success": "r",
        "amounts": "s",
        "_status": "t",
        "amount1": "u",
        "amount0": "v",
        "amount": "w",
        "min_dy": "x",
        "ui": "y",
        "uj": "z",
        "dx": "aa",
        "dy": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_006",
      "transformed_id": "ss_l2_short_nc_tc_006",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract CrossChainBridge {\n\n    address[] public t;\n    mapping(address => bool) public o;\n\n    uint256 public c = 5;\n    uint256 public i;\n\n\n    mapping(uint256 => bool) public b;\n\n\n    mapping(address => bool) public h;\n\n    event WithdrawalProcessed(\n        uint256 indexed m,\n        address indexed ai,\n        address indexed ah,\n        uint256 ab\n    );\n\n    constructor(address[] memory r) {\n        require(\n            r.length >= c,\n            \"Not enough validators\"\n        );\n\n        for (uint256 i = 0; i < r.length; i++) {\n            address w = r[i];\n            require(w != address(0), \"Invalid validator\");\n            require(!o[w], \"Duplicate validator\");\n\n            t.push(w);\n            o[w] = true;\n        }\n\n        i = r.length;\n    }\n\n\n    function g(\n        uint256 l,\n        address ag,\n        address ae,\n        uint256 z,\n        bytes memory p\n    ) external {\n\n        require(!b[l], \"Already processed\");\n\n\n        require(h[ae], \"Token not supported\");\n\n\n        require(\n            f(\n                l,\n                ag,\n                ae,\n                z,\n                p\n            ),\n            \"Invalid signatures\"\n        );\n\n\n        b[l] = true;\n\n\n        emit WithdrawalProcessed(l, ag, ae, z);\n    }\n\n\n    function f(\n        uint256 l,\n        address ag,\n        address ae,\n        uint256 z,\n        bytes memory p\n    ) internal view returns (bool) {\n        require(p.length % 65 == 0, \"Invalid signature length\");\n\n        uint256 k = p.length / 65;\n        require(k >= c, \"Not enough signatures\");\n\n\n        bytes32 q = x(\n            abi.n(l, ag, ae, z)\n        );\n        bytes32 a = x(\n            abi.n(\"\\x19Ethereum Signed Message:\\n32\", q)\n        );\n\n        address[] memory y = new address[](k);\n\n\n        for (uint256 i = 0; i < k; i++) {\n            bytes memory v = e(p, i);\n            address aa = j(a, v);\n\n\n            require(o[aa], \"Invalid signer\");\n\n\n            for (uint256 j = 0; j < i; j++) {\n                require(y[j] != aa, \"Duplicate signer\");\n            }\n\n            y[i] = aa;\n        }\n\n\n        return true;\n    }\n\n\n    function e(\n        bytes memory p,\n        uint256 ad\n    ) internal pure returns (bytes memory) {\n        bytes memory v = new bytes(65);\n        uint256 ac = ad * 65;\n\n        for (uint256 i = 0; i < 65; i++) {\n            v[i] = p[ac + i];\n        }\n\n        return v;\n    }\n\n\n    function j(\n        bytes32 af,\n        bytes memory s\n    ) internal pure returns (address) {\n        require(s.length == 65, \"Invalid signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(s, 32))\n            s := mload(add(s, 64))\n            v := byte(0, mload(add(s, 96)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28, \"Invalid signature v value\");\n\n        return u(af, v, r, s);\n    }\n\n\n    function d(address ae) external {\n        h[ae] = true;\n    }\n}",
      "rename_map": {
        "ethSignedMessageHash": "a",
        "processedWithdrawals": "b",
        "requiredSignatures": "c",
        "addSupportedToken": "d",
        "_extractSignature": "e",
        "_verifySignatures": "f",
        "withdrawERC20For": "g",
        "supportedTokens": "h",
        "validatorCount": "i",
        "_recoverSigner": "j",
        "signatureCount": "k",
        "_withdrawalId": "l",
        "withdrawalId": "m",
        "encodePacked": "n",
        "isValidator": "o",
        "_signatures": "p",
        "messageHash": "q",
        "_validators": "r",
        "_signature": "s",
        "validators": "t",
        "ecrecover": "u",
        "signature": "v",
        "validator": "w",
        "keccak256": "x",
        "signers": "y",
        "_amount": "z",
        "signer": "aa",
        "amount": "ab",
        "offset": "ac",
        "_index": "ad",
        "_token": "ae",
        "_hash": "af",
        "_user": "ag",
        "token": "ah",
        "user": "ai"
      },
      "changes": [
        "Renamed 35 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_007",
      "transformed_id": "ss_l2_short_nc_tc_007",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface ICrossChainData {\n    function f(address v) external;\n\n    function b(\n        bytes calldata g\n    ) external returns (bool);\n\n    function a() external view returns (bytes memory);\n}\n\ncontract CrossChainData {\n    address public z;\n    bytes public d;\n\n    event OwnershipTransferred(\n        address indexed h,\n        address indexed v\n    );\n    event PublicKeysUpdated(bytes w);\n\n    constructor() {\n        z = msg.sender;\n    }\n\n    modifier r() {\n        require(msg.sender == z, \"Not owner\");\n        _;\n    }\n\n\n    function b(\n        bytes calldata g\n    ) external r returns (bool) {\n        d = g;\n        emit PublicKeysUpdated(g);\n        return true;\n    }\n\n\n    function f(address v) external r {\n        require(v != address(0), \"Invalid address\");\n        emit OwnershipTransferred(z, v);\n        z = v;\n    }\n\n    function a() external view returns (bytes memory) {\n        return d;\n    }\n}\n\ncontract CrossChainManager {\n    address public o;\n\n    event CrossChainEvent(\n        address indexed m,\n        bytes q,\n        bytes y\n    );\n\n    constructor(address i) {\n        o = i;\n    }\n\n\n    function c(\n        bytes memory aa,\n        bytes memory s,\n        bytes memory p,\n        bytes memory l,\n        bytes memory t\n    ) external returns (bool) {\n\n        require(j(s, t), \"Invalid header\");\n\n\n        require(k(aa, s), \"Invalid proof\");\n\n\n        (\n            address q,\n            bytes memory y,\n            bytes memory ab\n        ) = u(aa);\n\n\n        (bool x, ) = q.call(abi.n(y, ab));\n        require(x, \"Execution failed\");\n\n        return true;\n    }\n\n\n    function j(\n        bytes memory s,\n        bytes memory t\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n\n    function k(\n        bytes memory aa,\n        bytes memory s\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n\n    function u(\n        bytes memory aa\n    )\n        internal\n        view\n        returns (address q, bytes memory y, bytes memory ab)\n    {\n        q = o;\n        y = abi.e(\n            \"putCurEpochConPubKeyBytes(bytes)\",\n            \"\"\n        );\n        ab = \"\";\n    }\n}",
      "rename_map": {
        "getCurEpochConPubKeyBytes": "a",
        "putCurEpochConPubKeyBytes": "b",
        "verifyHeaderAndExecuteTx": "c",
        "currentEpochPublicKeys": "d",
        "encodeWithSignature": "e",
        "transferOwnership": "f",
        "curEpochPkBytes": "g",
        "previousOwner": "h",
        "_dataContract": "i",
        "_verifyHeader": "j",
        "_verifyProof": "k",
        "curRawHeader": "l",
        "fromContract": "m",
        "encodePacked": "n",
        "dataContract": "o",
        "headerProof": "p",
        "toContract": "q",
        "onlyOwner": "r",
        "rawHeader": "s",
        "headerSig": "t",
        "_decodeTx": "u",
        "newOwner": "v",
        "newKeys": "w",
        "success": "x",
        "method": "y",
        "owner": "z",
        "proof": "aa",
        "args": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_008",
      "transformed_id": "ss_l2_short_nc_tc_008",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IOracle {\n    function c(address z) external view returns (uint256);\n}\n\ninterface ICToken {\n    function ad(uint256 q) external;\n\n    function y(uint256 i) external;\n\n    function x(uint256 h) external;\n\n    function p() external view returns (address);\n}\n\ncontract LendingProtocol {\n\n    IOracle public v;\n\n\n    mapping(address => uint256) public d;\n\n\n    mapping(address => mapping(address => uint256)) public k;\n\n\n    mapping(address => mapping(address => uint256)) public l;\n\n\n    mapping(address => bool) public e;\n\n    event Deposit(address indexed ac, address indexed z, uint256 w);\n    event Borrow(address indexed ac, address indexed z, uint256 w);\n\n    constructor(address t) {\n        v = IOracle(t);\n    }\n\n\n    function ad(address z, uint256 w) external {\n        require(e[z], \"Market not supported\");\n\n\n        k[msg.sender][z] += w;\n\n        emit Deposit(msg.sender, z, w);\n    }\n\n\n    function y(address z, uint256 w) external {\n        require(e[z], \"Market not supported\");\n\n\n        uint256 m = b(msg.sender);\n\n\n        uint256 g = a(msg.sender);\n\n\n        uint256 n = (v.c(z) * w) /\n            1e18;\n\n\n        require(\n            g + n <= m,\n            \"Insufficient collateral\"\n        );\n\n\n        l[msg.sender][z] += w;\n\n        emit Borrow(msg.sender, z, w);\n    }\n\n\n    function b(address ac) public view returns (uint256) {\n        uint256 o = 0;\n\n        address[] memory u = new address[](2);\n\n        for (uint256 i = 0; i < u.length; i++) {\n            address z = u[i];\n            uint256 balance = k[ac][z];\n\n            if (balance > 0) {\n\n                uint256 aa = v.c(z);\n\n\n                uint256 value = (balance * aa) / 1e18;\n\n\n                uint256 ab = (value * d[z]) / 1e18;\n\n                o += ab;\n            }\n        }\n\n        return o;\n    }\n\n\n    function a(address ac) public view returns (uint256) {\n        uint256 j = 0;\n\n        address[] memory u = new address[](2);\n\n        for (uint256 i = 0; i < u.length; i++) {\n            address z = u[i];\n            uint256 s = l[ac][z];\n\n            if (s > 0) {\n                uint256 aa = v.c(z);\n                uint256 value = (s * aa) / 1e18;\n                j += value;\n            }\n        }\n\n        return j;\n    }\n\n\n    function r(address z, uint256 f) external {\n        e[z] = true;\n        d[z] = f;\n    }\n}",
      "rename_map": {
        "calculateTotalBorrows": "a",
        "calculateBorrowPower": "b",
        "getUnderlyingPrice": "c",
        "collateralFactors": "d",
        "supportedMarkets": "e",
        "collateralFactor": "f",
        "currentBorrows": "g",
        "redeemTokens": "h",
        "borrowAmount": "i",
        "totalBorrows": "j",
        "userDeposits": "k",
        "userBorrows": "l",
        "borrowPower": "m",
        "borrowValue": "n",
        "totalPower": "o",
        "underlying": "p",
        "mintAmount": "q",
        "addMarket": "r",
        "borrowed": "s",
        "_oracle": "t",
        "markets": "u",
        "oracle": "v",
        "amount": "w",
        "redeem": "x",
        "borrow": "y",
        "cToken": "z",
        "price": "aa",
        "power": "ab",
        "user": "ac",
        "mint": "ad"
      },
      "changes": [
        "Renamed 30 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_009",
      "transformed_id": "ss_l2_short_nc_tc_009",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract ConcentratedLiquidityPool {\n\n    address public aq;\n    address public ap;\n\n\n    uint160 public q;\n    int24 public v;\n    uint128 public af;\n\n\n    mapping(int24 => int128) public s;\n\n\n    struct Position {\n        uint128 af;\n        int24 ad;\n        int24 ag;\n    }\n\n    mapping(bytes32 => Position) public ac;\n\n    event Swap(\n        address indexed sender,\n        uint256 ab,\n        uint256 ai,\n        uint256 x,\n        uint256 z\n    );\n\n    event LiquidityAdded(\n        address indexed al,\n        int24 ad,\n        int24 ag,\n        uint128 af\n    );\n\n\n    function t(\n        int24 ad,\n        int24 ag,\n        uint128 n\n    ) external returns (uint256 ao, uint256 an) {\n        require(ad < ag, \"Invalid ticks\");\n        require(n > 0, \"Zero liquidity\");\n\n\n        bytes32 w = ah(\n            abi.r(msg.sender, ad, ag)\n        );\n\n\n        Position storage ak = ac[w];\n        ak.af += n;\n        ak.ad = ad;\n        ak.ag = ag;\n\n\n        s[ad] += int128(n);\n        s[ag] -= int128(n);\n\n\n        if (v >= ad && v < ag) {\n            af += n;\n        }\n\n\n        (ao, an) = f(\n            q,\n            ad,\n            ag,\n            int128(n)\n        );\n\n        emit LiquidityAdded(msg.sender, ad, ag, n);\n    }\n\n\n    function ar(\n        bool y,\n        int256 m,\n        uint160 g\n    ) external returns (int256 ao, int256 an) {\n        require(m != 0, \"Zero amount\");\n\n\n        uint160 i = q;\n        uint128 o = af;\n        int24 aj = v;\n\n\n        while (m != 0) {\n\n            (\n                uint256 am,\n                uint256 ae,\n                uint160 e\n            ) = k(\n                    i,\n                    g,\n                    o,\n                    m\n                );\n\n\n            i = e;\n\n\n            int24 u = a(i);\n            if (u != aj) {\n\n                int128 d = s[u];\n\n                if (y) {\n                    d = -d;\n                }\n\n                o = p(\n                    o,\n                    d\n                );\n\n                aj = u;\n            }\n\n\n            if (m > 0) {\n                m -= int256(am);\n            } else {\n                m += int256(ae);\n            }\n        }\n\n\n        q = i;\n        af = o;\n        v = aj;\n\n        return (ao, an);\n    }\n\n\n    function p(\n        uint128 x,\n        int128 y\n    ) internal pure returns (uint128 z) {\n        if (y < 0) {\n            z = x - uint128(-y);\n        } else {\n            z = x + uint128(y);\n        }\n    }\n\n\n    function f(\n        uint160 aa,\n        int24 ad,\n        int24 ag,\n        int128 n\n    ) internal pure returns (uint256 ao, uint256 an) {\n        ao = uint256(uint128(n)) / 2;\n        an = uint256(uint128(n)) / 2;\n    }\n\n\n    function k(\n        uint160 b,\n        uint160 c,\n        uint128 j,\n        int256 l\n    )\n        internal\n        pure\n        returns (uint256 am, uint256 ae, uint160 h)\n    {\n        am =\n            uint256(l > 0 ? l : -l) /\n            2;\n        ae = am;\n        h = b;\n    }\n\n\n    function a(\n        uint160 q\n    ) internal pure returns (int24 as) {\n        return int24(int256(uint256(q >> 96)));\n    }\n}",
      "rename_map": {
        "_getTickAtSqrtRatio": "a",
        "sqrtPriceCurrentX96": "b",
        "sqrtPriceTargetX96": "c",
        "liquidityNetAtTick": "d",
        "sqrtPriceX96Target": "e",
        "_calculateAmounts": "f",
        "sqrtPriceLimitX96": "g",
        "sqrtPriceNextX96": "h",
        "sqrtPriceX96Next": "i",
        "liquidityCurrent": "j",
        "_computeSwapStep": "k",
        "amountRemaining": "l",
        "amountSpecified": "m",
        "liquidityDelta": "n",
        "liquidityNext": "o",
        "_addLiquidity": "p",
        "sqrtPriceX96": "q",
        "encodePacked": "r",
        "liquidityNet": "s",
        "addLiquidity": "t",
        "tickCrossed": "u",
        "currentTick": "v",
        "positionKey": "w",
        "amount0Out": "x",
        "zeroForOne": "y",
        "amount1Out": "z",
        "sqrtPrice": "aa",
        "amount0In": "ab",
        "positions": "ac",
        "tickLower": "ad",
        "amountOut": "ae",
        "liquidity": "af",
        "tickUpper": "ag",
        "keccak256": "ah",
        "amount1In": "ai",
        "tickNext": "aj",
        "position": "ak",
        "provider": "al",
        "amountIn": "am",
        "amount1": "an",
        "amount0": "ao",
        "token1": "ap",
        "token0": "aq",
        "swap": "ar",
        "tick": "as"
      },
      "changes": [
        "Renamed 45 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_010",
      "transformed_id": "ss_l2_short_nc_tc_010",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\n\ncontract CreditSystem {\n    mapping(address => uint256) public f;\n    uint256 public balance;\n\n    function e() public payable {\n        f[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n\n    function a() public {\n        uint256 d = f[msg.sender];\n        if (d > 0) {\n            balance -= d;\n            bool b = msg.sender.call.value(d)();\n            require(b);\n            f[msg.sender] = 0;\n        }\n    }\n\n    function c(address g) public view returns (uint256) {\n        return f[g];\n    }\n}",
      "rename_map": {
        "withdrawAll": "a",
        "callResult": "b",
        "getCredit": "c",
        "oCredit": "d",
        "deposit": "e",
        "credit": "f",
        "user": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_011",
      "transformed_id": "ss_l2_short_nc_tc_011",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC777 {\n    function transfer(address s, uint256 n) external returns (bool);\n\n    function i(address l) external view returns (uint256);\n}\n\ninterface IERC1820Registry {\n    function a(\n        address l,\n        bytes32 d,\n        address f\n    ) external;\n}\n\ncontract LendingPool {\n    mapping(address => mapping(address => uint256)) public k;\n    mapping(address => uint256) public e;\n\n    function m(address p, uint256 n) external returns (uint256) {\n        IERC777 o = IERC777(p);\n\n        require(o.transfer(address(this), n), \"Transfer failed\");\n\n        k[msg.sender][p] += n;\n        e[p] += n;\n\n        return n;\n    }\n\n    function j(\n        address p,\n        uint256 b\n    ) external returns (uint256) {\n        uint256 g = k[msg.sender][p];\n        require(g > 0, \"No balance\");\n\n        uint256 c = b;\n        if (b == type(uint256).r) {\n            c = g;\n        }\n        require(c <= g, \"Insufficient balance\");\n\n        IERC777(p).transfer(msg.sender, c);\n\n        k[msg.sender][p] -= c;\n        e[p] -= c;\n\n        return c;\n    }\n\n    function h(\n        address q,\n        address p\n    ) external view returns (uint256) {\n        return k[q][p];\n    }\n}",
      "rename_map": {
        "setInterfaceImplementer": "a",
        "requestedAmount": "b",
        "withdrawAmount": "c",
        "interfaceHash": "d",
        "totalSupplied": "e",
        "implementer": "f",
        "userBalance": "g",
        "getSupplied": "h",
        "balanceOf": "i",
        "withdraw": "j",
        "supplied": "k",
        "account": "l",
        "supply": "m",
        "amount": "n",
        "token": "o",
        "asset": "p",
        "user": "q",
        "max": "r",
        "to": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_012",
      "transformed_id": "ss_l2_short_nc_tc_012",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IComptroller {\n    function h(\n        address[] memory s\n    ) external returns (uint256[] memory);\n\n    function j(address v) external returns (uint256);\n\n    function b(\n        address r\n    ) external view returns (uint256, uint256, uint256);\n}\n\ncontract LendingProtocol {\n    IComptroller public i;\n\n    mapping(address => uint256) public p;\n    mapping(address => uint256) public n;\n    mapping(address => bool) public m;\n\n    uint256 public f;\n    uint256 public e;\n    uint256 public constant COLLATERAL_FACTOR = 150;\n\n    constructor(address g) {\n        i = IComptroller(g);\n    }\n\n    function a() external payable {\n        p[msg.sender] += msg.value;\n        f += msg.value;\n        m[msg.sender] = true;\n    }\n\n    function l(\n        address r,\n        uint256 c\n    ) public view returns (bool) {\n        uint256 k = n[r] + c;\n        if (k == 0) return true;\n\n        if (!m[r]) return false;\n\n        uint256 d = p[r];\n        return d >= (k * COLLATERAL_FACTOR) / 100;\n    }\n\n    function u(uint256 t) external {\n        require(t > 0, \"Invalid amount\");\n        require(address(this).balance >= t, \"Insufficient funds\");\n\n        require(l(msg.sender, t), \"Insufficient collateral\");\n\n        n[msg.sender] += t;\n        e += t;\n\n        (bool q, ) = payable(msg.sender).call{value: t}(\"\");\n        require(q, \"Transfer failed\");\n\n        require(l(msg.sender, 0), \"Health check failed\");\n    }\n\n    function j() external {\n        require(n[msg.sender] == 0, \"Outstanding debt\");\n        m[msg.sender] = false;\n    }\n\n    function o(uint256 t) external {\n        require(p[msg.sender] >= t, \"Insufficient deposits\");\n        require(!m[msg.sender], \"Exit market first\");\n\n        p[msg.sender] -= t;\n        f -= t;\n\n        payable(msg.sender).transfer(t);\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "depositAndEnterMarket": "a",
        "getAccountLiquidity": "b",
        "additionalBorrow": "c",
        "collateralValue": "d",
        "totalBorrowed": "e",
        "totalDeposits": "f",
        "_comptroller": "g",
        "enterMarkets": "h",
        "comptroller": "i",
        "exitMarket": "j",
        "totalDebt": "k",
        "isHealthy": "l",
        "inMarket": "m",
        "borrowed": "n",
        "withdraw": "o",
        "deposits": "p",
        "success": "q",
        "account": "r",
        "cTokens": "s",
        "amount": "t",
        "borrow": "u",
        "cToken": "v"
      },
      "changes": [
        "Renamed 22 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_013",
      "transformed_id": "ss_l2_short_nc_tc_013",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address ac, uint256 y) external returns (bool);\n\n    function g(\n        address from,\n        address ac,\n        uint256 y\n    ) external returns (bool);\n\n    function m(address u) external view returns (uint256);\n}\n\ninterface IPancakeRouter {\n    function a(\n        uint r,\n        uint l,\n        address[] calldata ab,\n        address ac,\n        uint q\n    ) external returns (uint[] memory s);\n}\n\ncontract RewardMinter {\n    IERC20 public w;\n    IERC20 public i;\n\n    mapping(address => uint256) public j;\n    mapping(address => uint256) public e;\n\n    uint256 public constant REWARD_RATE = 100;\n\n    constructor(address p, address h) {\n        w = IERC20(p);\n        i = IERC20(h);\n    }\n\n    function v(uint256 y) external {\n        w.g(msg.sender, address(this), y);\n        j[msg.sender] += y;\n    }\n\n    function t(\n        address aa,\n        uint256 d,\n        uint256 c,\n        address ac,\n        uint256\n    ) external {\n        require(aa == address(w), \"Invalid token\");\n\n        uint256 x = c + d;\n        w.g(msg.sender, address(this), x);\n\n        uint256 b = f(\n            w.m(address(this))\n        );\n\n        e[ac] += b;\n    }\n\n    function f(uint256 o) internal pure returns (uint256) {\n        return o * REWARD_RATE;\n    }\n\n    function k() external {\n        uint256 z = e[msg.sender];\n        require(z > 0, \"No rewards\");\n\n        e[msg.sender] = 0;\n        i.transfer(msg.sender, z);\n    }\n\n    function n(uint256 y) external {\n        require(j[msg.sender] >= y, \"Insufficient balance\");\n        j[msg.sender] -= y;\n        w.transfer(msg.sender, y);\n    }\n}",
      "rename_map": {
        "swapExactTokensForTokens": "a",
        "hunnyRewardAmount": "b",
        "_performanceFee": "c",
        "_withdrawalFee": "d",
        "earnedRewards": "e",
        "tokenToReward": "f",
        "transferFrom": "g",
        "_rewardToken": "h",
        "rewardToken": "i",
        "depositedLP": "j",
        "getReward": "k",
        "amountOut": "l",
        "balanceOf": "m",
        "withdraw": "n",
        "lpAmount": "o",
        "_lpToken": "p",
        "deadline": "q",
        "amountIn": "r",
        "amounts": "s",
        "mintFor": "t",
        "account": "u",
        "deposit": "v",
        "lpToken": "w",
        "feeSum": "x",
        "amount": "y",
        "reward": "z",
        "flip": "aa",
        "path": "ab",
        "to": "ac"
      },
      "changes": [
        "Renamed 29 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_014",
      "transformed_id": "ss_l2_short_nc_tc_014",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface ICurve3Pool {\n    function g(\n        uint256[3] memory s,\n        uint256 d\n    ) external;\n\n    function a(\n        uint256[3] memory s,\n        uint256 c\n    ) external;\n\n    function b() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function transfer(address ad, uint256 w) external returns (bool);\n\n    function h(\n        address from,\n        address ad,\n        uint256 w\n    ) external returns (bool);\n\n    function q(address u) external view returns (uint256);\n\n    function t(address r, uint256 w) external returns (bool);\n}\n\ncontract YieldVault {\n    IERC20 public ac;\n    IERC20 public aa;\n    ICurve3Pool public p;\n\n    mapping(address => uint256) public x;\n    uint256 public k;\n    uint256 public f;\n\n    uint256 public constant MIN_EARN_THRESHOLD = 1000 ether;\n\n    constructor(address ab, address y, address l) {\n        ac = IERC20(ab);\n        aa = IERC20(y);\n        p = ICurve3Pool(l);\n    }\n\n    function v(uint256 w) external {\n        ac.h(msg.sender, address(this), w);\n\n        uint256 m;\n        if (k == 0) {\n            m = w;\n        } else {\n            m = (w * k) / f;\n        }\n\n        x[msg.sender] += m;\n        k += m;\n        f += w;\n    }\n\n    function z() external {\n        uint256 j = ac.q(address(this));\n        require(\n            j >= MIN_EARN_THRESHOLD,\n            \"Insufficient balance to earn\"\n        );\n\n        uint256 i = p.b();\n\n        ac.t(address(p), j);\n        uint256[3] memory s = [j, 0, 0];\n        p.g(s, 0);\n    }\n\n    function n() external {\n        uint256 o = x[msg.sender];\n        require(o > 0, \"No shares\");\n\n        uint256 e = (o * f) / k;\n\n        x[msg.sender] = 0;\n        k -= o;\n        f -= e;\n\n        ac.transfer(msg.sender, e);\n    }\n\n    function balance() public view returns (uint256) {\n        return\n            ac.q(address(this)) +\n            (aa.q(address(this)) * p.b()) /\n            1e18;\n    }\n}",
      "rename_map": {
        "remove_liquidity_imbalance": "a",
        "get_virtual_price": "b",
        "max_burn_amount": "c",
        "min_mint_amount": "d",
        "withdrawAmount": "e",
        "totalDeposits": "f",
        "add_liquidity": "g",
        "transferFrom": "h",
        "virtualPrice": "i",
        "vaultBalance": "j",
        "totalShares": "k",
        "_curve3Pool": "l",
        "shareAmount": "m",
        "withdrawAll": "n",
        "userShares": "o",
        "curve3Pool": "p",
        "balanceOf": "q",
        "spender": "r",
        "amounts": "s",
        "approve": "t",
        "account": "u",
        "deposit": "v",
        "amount": "w",
        "shares": "x",
        "_crv3": "y",
        "earn": "z",
        "crv3": "aa",
        "_dai": "ab",
        "dai": "ac",
        "to": "ad"
      },
      "changes": [
        "Renamed 30 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_015",
      "transformed_id": "ss_l2_short_nc_tc_015",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address l, uint256 g) external returns (bool);\n\n    function e(address f) external view returns (uint256);\n}\n\ncontract CompoundMarket {\n    address public d;\n    address public j;\n\n    mapping(address => uint256) public a;\n    uint256 public b;\n\n    address public constant OLD_TUSD =\n        0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;\n    address public constant NEW_TUSD =\n        0x0000000000085d4780B73119b644AE5ecd22b376;\n\n    constructor() {\n        j = msg.sender;\n        d = OLD_TUSD;\n    }\n\n    function k(uint256 g) external {\n        IERC20(NEW_TUSD).transfer(address(this), g);\n        a[msg.sender] += g;\n        b += g;\n    }\n\n    function c(address i) external {\n        require(i != d, \"Cannot sweep underlying token\");\n\n        uint256 balance = IERC20(i).e(address(this));\n        IERC20(i).transfer(msg.sender, balance);\n    }\n\n    function h(uint256 g) external {\n        require(a[msg.sender] >= g, \"Insufficient balance\");\n\n        a[msg.sender] -= g;\n        b -= g;\n\n        IERC20(NEW_TUSD).transfer(msg.sender, g);\n    }\n}",
      "rename_map": {
        "accountTokens": "a",
        "totalSupply": "b",
        "sweepToken": "c",
        "underlying": "d",
        "balanceOf": "e",
        "account": "f",
        "amount": "g",
        "redeem": "h",
        "token": "i",
        "admin": "j",
        "mint": "k",
        "to": "l"
      },
      "changes": [
        "Renamed 12 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_016",
      "transformed_id": "ss_l2_short_nc_tc_016",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address u, uint256 q) external returns (bool);\n\n    function l(address p) external view returns (uint256);\n}\n\ncontract LoanToken {\n    string public s = \"iETH\";\n    string public r = \"iETH\";\n\n    mapping(address => uint256) public m;\n    uint256 public h;\n    uint256 public a;\n    uint256 public b;\n\n    function d(\n        address n\n    ) external payable returns (uint256 j) {\n        uint256 e = f();\n        j = (msg.value * 1e18) / e;\n\n        m[n] += j;\n        h += j;\n        b += msg.value;\n\n        return j;\n    }\n\n    function transfer(address u, uint256 q) external returns (bool) {\n        require(m[msg.sender] >= q, \"Insufficient balance\");\n\n        m[msg.sender] -= q;\n        m[u] += q;\n\n        c(msg.sender, u, q);\n\n        return true;\n    }\n\n    function c(\n        address from,\n        address u,\n        uint256 q\n    ) internal {\n        if (i(u)) {\n            (bool o, ) = u.call(\"\");\n            o;\n        }\n    }\n\n    function g(\n        address n,\n        uint256 q\n    ) external returns (uint256 k) {\n        require(m[msg.sender] >= q, \"Insufficient balance\");\n\n        uint256 e = f();\n        k = (q * e) / 1e18;\n\n        m[msg.sender] -= q;\n        h -= q;\n        b -= k;\n\n        payable(n).transfer(k);\n\n        return k;\n    }\n\n    function f() internal view returns (uint256) {\n        if (h == 0) {\n            return 1e18;\n        }\n        return (b * 1e18) / h;\n    }\n\n    function i(address p) internal view returns (bool) {\n        uint256 t;\n        assembly {\n            t := extcodesize(p)\n        }\n        return t > 0;\n    }\n\n    function l(address p) external view returns (uint256) {\n        return m[p];\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "totalAssetBorrow": "a",
        "totalAssetSupply": "b",
        "_notifyTransfer": "c",
        "mintWithEther": "d",
        "currentPrice": "e",
        "_tokenPrice": "f",
        "burnToEther": "g",
        "totalSupply": "h",
        "_isContract": "i",
        "mintAmount": "j",
        "ethAmount": "k",
        "balanceOf": "l",
        "balances": "m",
        "receiver": "n",
        "success": "o",
        "account": "p",
        "amount": "q",
        "symbol": "r",
        "name": "s",
        "size": "t",
        "to": "u"
      },
      "changes": [
        "Renamed 21 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_017",
      "transformed_id": "ss_l2_short_nc_tc_017",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address x, uint256 r) external returns (bool);\n\n    function j(address p) external view returns (uint256);\n}\n\ninterface IJar {\n    function s() external view returns (address);\n\n    function k(uint256 r) external;\n}\n\ninterface IStrategy {\n    function d() external;\n\n    function k(address s) external;\n}\n\ncontract VaultController {\n    address public i;\n    mapping(address => address) public g;\n\n    constructor() {\n        i = msg.sender;\n    }\n\n    function a(\n        address l,\n        address q,\n        uint256 c,\n        uint256 b,\n        address[] calldata n,\n        bytes[] calldata t\n    ) external {\n        require(n.length == t.length, \"Length mismatch\");\n\n        for (uint256 i = 0; i < n.length; i++) {\n            (bool o, ) = n[i].call(t[i]);\n            require(o, \"Call failed\");\n        }\n    }\n\n    function e(address w, address m) external {\n        require(msg.sender == i, \"Not governance\");\n        g[w] = m;\n    }\n}\n\ncontract Strategy {\n    address public h;\n    address public v;\n\n    constructor(address f, address u) {\n        h = f;\n        v = u;\n    }\n\n    function d() external {\n        uint256 balance = IERC20(v).j(address(this));\n        IERC20(v).transfer(h, balance);\n    }\n\n    function k(address s) external {\n        uint256 balance = IERC20(s).j(address(this));\n        IERC20(s).transfer(h, balance);\n    }\n}",
      "rename_map": {
        "swapExactJarForJar": "a",
        "_toJarMinAmount": "b",
        "_fromJarAmount": "c",
        "withdrawAll": "d",
        "setStrategy": "e",
        "_controller": "f",
        "strategies": "g",
        "controller": "h",
        "governance": "i",
        "balanceOf": "j",
        "withdraw": "k",
        "_fromJar": "l",
        "strategy": "m",
        "_targets": "n",
        "success": "o",
        "account": "p",
        "_toJar": "q",
        "amount": "r",
        "token": "s",
        "_data": "t",
        "_want": "u",
        "want": "v",
        "jar": "w",
        "to": "x"
      },
      "changes": [
        "Renamed 24 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_018",
      "transformed_id": "ss_l2_short_nc_tc_018",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function n(address t) external view returns (uint256);\n\n    function transfer(address aa, uint256 v) external returns (bool);\n}\n\ncontract TokenPool {\n    struct Token {\n        address z;\n        uint256 balance;\n        uint256 u;\n    }\n\n    mapping(address => Token) public w;\n    address[] public m;\n    uint256 public f;\n\n    constructor() {\n        f = 100;\n    }\n\n    function p(address x, uint256 c) external {\n        w[x] = Token({z: x, balance: 0, u: c});\n        m.push(x);\n    }\n\n    function y(\n        address s,\n        address r,\n        uint256 q\n    ) external returns (uint256 k) {\n        require(w[s].z != address(0), \"Invalid token\");\n        require(w[r].z != address(0), \"Invalid token\");\n\n        IERC20(s).transfer(address(this), q);\n        w[s].balance += q;\n\n        k = a(s, r, q);\n\n        require(\n            w[r].balance >= k,\n            \"Insufficient liquidity\"\n        );\n        w[r].balance -= k;\n        IERC20(r).transfer(msg.sender, k);\n\n        b();\n\n        return k;\n    }\n\n    function a(\n        address s,\n        address r,\n        uint256 q\n    ) public view returns (uint256) {\n        uint256 o = w[s].u;\n        uint256 i = w[r].u;\n        uint256 g = w[r].balance;\n\n        uint256 l = g * q * i;\n        uint256 e = w[s].balance *\n            o +\n            q *\n            i;\n\n        return l / e;\n    }\n\n    function b() internal {\n        uint256 h = 0;\n\n        for (uint256 i = 0; i < m.length; i++) {\n            address x = m[i];\n            h += w[x].balance;\n        }\n\n        for (uint256 i = 0; i < m.length; i++) {\n            address x = m[i];\n            w[x].u = (w[x].balance * 100) / h;\n        }\n    }\n\n    function j(address x) external view returns (uint256) {\n        return w[x].u;\n    }\n\n    function d(address x, uint256 v) external {\n        require(w[x].z != address(0), \"Invalid token\");\n        IERC20(x).transfer(address(this), v);\n        w[x].balance += v;\n        b();\n    }\n}",
      "rename_map": {
        "calculateSwapAmount": "a",
        "_updateWeights": "b",
        "initialWeight": "c",
        "addLiquidity": "d",
        "denominator": "e",
        "totalWeight": "f",
        "balanceOut": "g",
        "totalValue": "h",
        "weightOut": "i",
        "getWeight": "j",
        "amountOut": "k",
        "numerator": "l",
        "tokenList": "m",
        "balanceOf": "n",
        "weightIn": "o",
        "addToken": "p",
        "amountIn": "q",
        "tokenOut": "r",
        "tokenIn": "s",
        "account": "t",
        "weight": "u",
        "amount": "v",
        "tokens": "w",
        "token": "x",
        "swap": "y",
        "addr": "z",
        "to": "aa"
      },
      "changes": [
        "Renamed 27 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_019",
      "transformed_id": "ss_l2_short_nc_tc_019",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function g(\n        address from,\n        address r,\n        uint256 p\n    ) external returns (bool);\n\n    function k(address m) external view returns (uint256);\n}\n\ncontract CrossChainBridge {\n    address public o;\n\n    event Deposit(\n        uint8 b,\n        bytes32 i,\n        uint64 e\n    );\n\n    uint64 public e;\n\n    constructor(address l) {\n        o = l;\n    }\n\n    function n(\n        uint8 b,\n        bytes32 i,\n        bytes calldata data\n    ) external payable {\n        e += 1;\n\n        BridgeHandler(o).n(i, msg.sender, data);\n\n        emit Deposit(b, i, e);\n    }\n}\n\ncontract BridgeHandler {\n    mapping(bytes32 => address) public a;\n    mapping(address => bool) public c;\n\n    function n(\n        bytes32 i,\n        address j,\n        bytes calldata data\n    ) external {\n        address d = a[i];\n\n        uint256 p;\n        (p) = abi.q(data, (uint256));\n\n        IERC20(d).g(j, address(this), p);\n    }\n\n    function h(bytes32 i, address f) external {\n        a[i] = f;\n    }\n}",
      "rename_map": {
        "resourceIDToTokenContractAddress": "a",
        "destinationDomainID": "b",
        "contractWhitelist": "c",
        "tokenContract": "d",
        "depositNonce": "e",
        "tokenAddress": "f",
        "transferFrom": "g",
        "setResource": "h",
        "resourceID": "i",
        "depositer": "j",
        "balanceOf": "k",
        "_handler": "l",
        "account": "m",
        "deposit": "n",
        "handler": "o",
        "amount": "p",
        "decode": "q",
        "to": "r"
      },
      "changes": [
        "Renamed 18 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_020",
      "transformed_id": "ss_l2_short_nc_tc_020",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function j()\n        external\n        view\n        returns (uint112 u, uint112 p, uint32 a);\n\n    function i() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function n(address w) external view returns (uint256);\n\n    function transfer(address af, uint256 aa) external returns (bool);\n\n    function f(\n        address from,\n        address af,\n        uint256 aa\n    ) external returns (bool);\n}\n\ncontract LendingVault {\n    struct Position {\n        uint256 e;\n        uint256 q;\n    }\n\n    mapping(address => Position) public m;\n\n    address public z;\n    address public k;\n    uint256 public constant COLLATERAL_RATIO = 150;\n\n    constructor(address t, address g) {\n        z = t;\n        k = g;\n    }\n\n    function y(uint256 aa) external {\n        IERC20(z).f(msg.sender, address(this), aa);\n        m[msg.sender].e += aa;\n    }\n\n    function ac(uint256 aa) external {\n        uint256 b = c(\n            m[msg.sender].e\n        );\n        uint256 o = (b * 100) / COLLATERAL_RATIO;\n\n        require(\n            m[msg.sender].q + aa <= o,\n            \"Insufficient collateral\"\n        );\n\n        m[msg.sender].q += aa;\n        IERC20(k).transfer(msg.sender, aa);\n    }\n\n    function c(uint256 s) public view returns (uint256) {\n        if (s == 0) return 0;\n\n        IUniswapV2Pair ae = IUniswapV2Pair(z);\n\n        (uint112 u, uint112 p, ) = ae.j();\n        uint256 i = ae.i();\n\n        uint256 x = (uint256(u) * s) / i;\n        uint256 v = (uint256(p) * s) / i;\n\n        uint256 ab = x;\n        uint256 l = x + v;\n\n        return l;\n    }\n\n    function ad(uint256 aa) external {\n        require(m[msg.sender].q >= aa, \"Repay exceeds debt\");\n\n        IERC20(k).f(msg.sender, address(this), aa);\n        m[msg.sender].q -= aa;\n    }\n\n    function r(uint256 aa) external {\n        require(\n            m[msg.sender].e >= aa,\n            \"Insufficient balance\"\n        );\n\n        uint256 h = m[msg.sender].e - aa;\n        uint256 d = c(h);\n        uint256 o = (d * 100) / COLLATERAL_RATIO;\n\n        require(\n            m[msg.sender].q <= o,\n            \"Withdrawal would liquidate position\"\n        );\n\n        m[msg.sender].e -= aa;\n        IERC20(z).transfer(msg.sender, aa);\n    }\n}",
      "rename_map": {
        "blockTimestampLast": "a",
        "collateralValue": "b",
        "getLPTokenValue": "c",
        "remainingValue": "d",
        "lpTokenAmount": "e",
        "transferFrom": "f",
        "_stablecoin": "g",
        "remainingLP": "h",
        "totalSupply": "i",
        "getReserves": "j",
        "stablecoin": "k",
        "totalValue": "l",
        "positions": "m",
        "balanceOf": "n",
        "maxBorrow": "o",
        "reserve1": "p",
        "borrowed": "q",
        "withdraw": "r",
        "lpAmount": "s",
        "_lpToken": "t",
        "reserve0": "u",
        "amount1": "v",
        "account": "w",
        "amount0": "x",
        "deposit": "y",
        "lpToken": "z",
        "amount": "aa",
        "value0": "ab",
        "borrow": "ac",
        "repay": "ad",
        "pair": "ae",
        "to": "af"
      },
      "changes": [
        "Renamed 32 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_021",
      "transformed_id": "ss_l2_short_nc_tc_021",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function s(address x) external view returns (uint256);\n\n    function transfer(address af, uint256 y) external returns (bool);\n\n    function d(\n        address from,\n        address af,\n        uint256 y\n    ) external returns (bool);\n}\n\ncontract LiquidityPool {\n    address public l;\n    address public t;\n    address public m;\n\n    uint256 public r;\n    uint256 public i;\n    uint256 public e;\n\n    bool public c;\n\n    event Initialized(address l, address ab, address aa);\n\n    function ad(\n        address g,\n        address o,\n        address h,\n        uint256 p\n    ) external {\n        l = g;\n        t = o;\n        m = h;\n        r = p;\n\n        c = true;\n\n        emit Initialized(g, o, h);\n    }\n\n    function f(uint256 n, uint256 j) external {\n        require(c, \"Not initialized\");\n\n        IERC20(t).d(msg.sender, address(this), n);\n        IERC20(m).d(msg.sender, address(this), j);\n\n        i += n;\n        e += j;\n    }\n\n    function ac(\n        address q,\n        address w,\n        uint256 k\n    ) external returns (uint256 v) {\n        require(c, \"Not initialized\");\n        require(\n            (q == t && w == m) ||\n                (q == m && w == t),\n            \"Invalid token pair\"\n        );\n\n        IERC20(q).d(msg.sender, address(this), k);\n\n        if (q == t) {\n            v = (e * k) / (i + k);\n            i += k;\n            e -= v;\n        } else {\n            v = (i * k) / (e + k);\n            e += k;\n            i -= v;\n        }\n\n        uint256 ae = (v * r) / 10000;\n        v -= ae;\n\n        IERC20(w).transfer(msg.sender, v);\n        IERC20(w).transfer(l, ae);\n\n        return v;\n    }\n\n    function u() external {\n        require(msg.sender == l, \"Only maintainer\");\n\n        uint256 b = IERC20(t).s(address(this));\n        uint256 a = IERC20(m).s(address(this));\n\n        if (b > i) {\n            uint256 z = b - i;\n            IERC20(t).transfer(l, z);\n        }\n\n        if (a > e) {\n            uint256 z = a - e;\n            IERC20(m).transfer(l, z);\n        }\n    }\n}",
      "rename_map": {
        "quoteTokenBalance": "a",
        "baseTokenBalance": "b",
        "isInitialized": "c",
        "transferFrom": "d",
        "quoteBalance": "e",
        "addLiquidity": "f",
        "_maintainer": "g",
        "_quoteToken": "h",
        "baseBalance": "i",
        "quoteAmount": "j",
        "fromAmount": "k",
        "maintainer": "l",
        "quoteToken": "m",
        "baseAmount": "n",
        "_baseToken": "o",
        "_lpFeeRate": "p",
        "fromToken": "q",
        "lpFeeRate": "r",
        "balanceOf": "s",
        "baseToken": "t",
        "claimFees": "u",
        "toAmount": "v",
        "toToken": "w",
        "account": "x",
        "amount": "y",
        "excess": "z",
        "quote": "aa",
        "base": "ab",
        "swap": "ac",
        "init": "ad",
        "fee": "ae",
        "to": "af"
      },
      "changes": [
        "Renamed 32 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_022",
      "transformed_id": "ss_l2_short_nc_tc_022",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function j(address r) external view returns (uint256);\n\n    function transfer(address ab, uint256 v) external returns (bool);\n\n    function c(\n        address from,\n        address ab,\n        uint256 v\n    ) external returns (bool);\n}\n\ncontract TokenPair {\n    address public x;\n    address public w;\n\n    uint112 private o;\n    uint112 private m;\n\n    uint256 public constant TOTAL_FEE = 16;\n\n    constructor(address u, address t) {\n        x = u;\n        w = t;\n    }\n\n    function aa(address ab) external returns (uint256 i) {\n        uint256 p = IERC20(x).j(address(this));\n        uint256 n = IERC20(w).j(address(this));\n\n        uint256 s = p - o;\n        uint256 q = n - m;\n\n        i = z(s * q);\n\n        o = uint112(p);\n        m = uint112(n);\n\n        return i;\n    }\n\n    function y(\n        uint256 e,\n        uint256 f,\n        address ab,\n        bytes calldata data\n    ) external {\n        require(e > 0 || f > 0, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        uint112 l = o;\n        uint112 h = m;\n\n        require(\n            e < l && f < h,\n            \"INSUFFICIENT_LIQUIDITY\"\n        );\n\n        if (e > 0) IERC20(x).transfer(ab, e);\n        if (f > 0) IERC20(w).transfer(ab, f);\n\n        uint256 p = IERC20(x).j(address(this));\n        uint256 n = IERC20(w).j(address(this));\n\n        uint256 g = p > l - e\n            ? p - (l - e)\n            : 0;\n        uint256 k = n > h - f\n            ? n - (h - f)\n            : 0;\n\n        require(g > 0 || k > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\n        uint256 b = p * 10000 - g * TOTAL_FEE;\n        uint256 a = n * 10000 - k * TOTAL_FEE;\n\n        require(\n            b * a >=\n                uint256(l) * h * (1000 ** 2),\n            \"K\"\n        );\n\n        o = uint112(p);\n        m = uint112(n);\n    }\n\n    function d() external view returns (uint112, uint112, uint32) {\n        return (o, m, 0);\n    }\n\n    function z(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}",
      "rename_map": {
        "balance1Adjusted": "a",
        "balance0Adjusted": "b",
        "transferFrom": "c",
        "getReserves": "d",
        "amount0Out": "e",
        "amount1Out": "f",
        "amount0In": "g",
        "_reserve1": "h",
        "liquidity": "i",
        "balanceOf": "j",
        "amount1In": "k",
        "_reserve0": "l",
        "reserve1": "m",
        "balance1": "n",
        "reserve0": "o",
        "balance0": "p",
        "amount1": "q",
        "account": "r",
        "amount0": "s",
        "_token1": "t",
        "_token0": "u",
        "amount": "v",
        "token1": "w",
        "token0": "x",
        "swap": "y",
        "sqrt": "z",
        "mint": "aa",
        "to": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_023",
      "transformed_id": "ss_l2_short_nc_tc_023",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function o(address r) external view returns (uint256);\n\n    function transfer(address ab, uint256 t) external returns (bool);\n\n    function h(\n        address from,\n        address ab,\n        uint256 t\n    ) external returns (bool);\n}\n\ninterface ICErc20 {\n    function u(uint256 t) external returns (uint256);\n\n    function a(address r) external returns (uint256);\n}\n\ncontract LeveragedVault {\n    struct Position {\n        address w;\n        uint256 j;\n        uint256 m;\n    }\n\n    mapping(uint256 => Position) public n;\n    uint256 public d;\n\n    address public v;\n    uint256 public l;\n    uint256 public e;\n\n    constructor(address s) {\n        v = s;\n        d = 1;\n    }\n\n    function g(\n        uint256 b,\n        uint256 i\n    ) external returns (uint256 k) {\n        k = d++;\n\n        n[k] = Position({\n            w: msg.sender,\n            j: b,\n            m: 0\n        });\n\n        q(k, i);\n\n        return k;\n    }\n\n    function q(uint256 k, uint256 t) internal {\n        Position storage aa = n[k];\n\n        uint256 y;\n\n        if (e == 0) {\n            y = t;\n        } else {\n            y = (t * e) / l;\n        }\n\n        aa.m += y;\n        e += y;\n        l += t;\n\n        ICErc20(v).u(t);\n    }\n\n    function x(uint256 k, uint256 t) external {\n        Position storage aa = n[k];\n        require(msg.sender == aa.w, \"Not position owner\");\n\n        uint256 f = (t * e) / l;\n\n        require(aa.m >= f, \"Excessive repayment\");\n\n        aa.m -= f;\n        e -= f;\n        l -= t;\n    }\n\n    function c(\n        uint256 k\n    ) external view returns (uint256) {\n        Position storage aa = n[k];\n\n        if (e == 0) return 0;\n\n        return (aa.m * l) / e;\n    }\n\n    function p(uint256 k) external {\n        Position storage aa = n[k];\n\n        uint256 z = (aa.m * l) / e;\n\n        require(aa.j * 100 < z * 150, \"Position is healthy\");\n\n        aa.j = 0;\n        aa.m = 0;\n    }\n}",
      "rename_map": {
        "borrowBalanceCurrent": "a",
        "collateralAmount": "b",
        "getPositionDebt": "c",
        "nextPositionId": "d",
        "totalDebtShare": "e",
        "shareToRemove": "f",
        "openPosition": "g",
        "transferFrom": "h",
        "borrowAmount": "i",
        "collateral": "j",
        "positionId": "k",
        "totalDebt": "l",
        "debtShare": "m",
        "positions": "n",
        "balanceOf": "o",
        "liquidate": "p",
        "_borrow": "q",
        "account": "r",
        "_cToken": "s",
        "amount": "t",
        "borrow": "u",
        "cToken": "v",
        "owner": "w",
        "repay": "x",
        "share": "y",
        "debt": "z",
        "pos": "aa",
        "to": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_024",
      "transformed_id": "ss_l2_short_nc_tc_024",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function o(address u) external view returns (uint256);\n\n    function transfer(address ac, uint256 y) external returns (bool);\n\n    function i(\n        address from,\n        address ac,\n        uint256 y\n    ) external returns (bool);\n}\n\ninterface ICurvePool {\n    function b() external view returns (uint256);\n\n    function g(\n        uint256[3] calldata t,\n        uint256 h\n    ) external;\n}\n\ncontract PriceOracle {\n    ICurvePool public p;\n\n    constructor(address l) {\n        p = ICurvePool(l);\n    }\n\n    function s() external view returns (uint256) {\n        return p.b();\n    }\n}\n\ncontract LendingProtocol {\n    struct Position {\n        uint256 m;\n        uint256 r;\n    }\n\n    mapping(address => Position) public n;\n\n    address public f;\n    address public k;\n    address public x;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(\n        address c,\n        address j,\n        address v\n    ) {\n        f = c;\n        k = j;\n        x = v;\n    }\n\n    function w(uint256 y) external {\n        IERC20(f).i(msg.sender, address(this), y);\n        n[msg.sender].m += y;\n    }\n\n    function z(uint256 y) external {\n        uint256 e = a(msg.sender);\n        uint256 q = (e * COLLATERAL_FACTOR) / 100;\n\n        require(\n            n[msg.sender].r + y <= q,\n            \"Insufficient collateral\"\n        );\n\n        n[msg.sender].r += y;\n        IERC20(k).transfer(msg.sender, y);\n    }\n\n    function a(address ab) public view returns (uint256) {\n        uint256 d = n[ab].m;\n        uint256 aa = PriceOracle(x).s();\n\n        return (d * aa) / 1e18;\n    }\n}",
      "rename_map": {
        "getCollateralValue": "a",
        "get_virtual_price": "b",
        "_collateralToken": "c",
        "collateralAmount": "d",
        "collateralValue": "e",
        "collateralToken": "f",
        "add_liquidity": "g",
        "minMintAmount": "h",
        "transferFrom": "i",
        "_borrowToken": "j",
        "borrowToken": "k",
        "_curvePool": "l",
        "collateral": "m",
        "positions": "n",
        "balanceOf": "o",
        "curvePool": "p",
        "maxBorrow": "q",
        "borrowed": "r",
        "getPrice": "s",
        "amounts": "t",
        "account": "u",
        "_oracle": "v",
        "deposit": "w",
        "oracle": "x",
        "amount": "y",
        "borrow": "z",
        "price": "aa",
        "user": "ab",
        "to": "ac"
      },
      "changes": [
        "Renamed 29 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_025",
      "transformed_id": "ss_l2_short_nc_tc_025",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address m, uint256 i) external returns (bool);\n    function d(address from, address m, uint256 i) external returns (bool);\n}\n\ninterface ICompoundToken {\n    function j(uint256 i) external;\n    function e(uint256 i) external;\n    function k(uint256 h) external;\n    function l(uint256 i) external;\n}\n\ncontract LendingMarket {\n    mapping(address => uint256) public a;\n    mapping(address => uint256) public b;\n\n    address public g;\n    uint256 public c;\n\n    constructor(address f) {\n        g = f;\n    }\n\n    function j(uint256 i) external {\n        a[msg.sender] += i;\n        c += i;\n\n        IERC20(g).transfer(msg.sender, i);\n    }\n\n    function e(uint256 i) external {\n        IERC20(g).d(msg.sender, address(this), i);\n\n        a[msg.sender] -= i;\n        c -= i;\n    }\n}",
      "rename_map": {
        "accountBorrows": "a",
        "accountTokens": "b",
        "totalBorrows": "c",
        "transferFrom": "d",
        "repayBorrow": "e",
        "_underlying": "f",
        "underlying": "g",
        "tokens": "h",
        "amount": "i",
        "borrow": "j",
        "redeem": "k",
        "mint": "l",
        "to": "m"
      },
      "changes": [
        "Renamed 13 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_026",
      "transformed_id": "ss_l2_short_nc_tc_026",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20Permit {\n    function g(address i, address e, uint256 value, uint256 d, uint8 v, bytes32 r, bytes32 s) external;\n}\n\ncontract BridgeRouter {\n\n    function a(\n        address from,\n        address h,\n        address j,\n        uint256 f,\n        uint256 d,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 c\n    ) external {\n\n        if (v != 0 || r != bytes32(0) || s != bytes32(0)) {\n            try IERC20Permit(h).g(from, address(this), f, d, v, r, s) {} catch {}\n        }\n\n        b(from, h, j, f, c);\n    }\n\n    function b(address from, address h, address j, uint256 f, uint256 c) internal {\n\n    }\n}",
      "rename_map": {
        "bridgeOutWithPermit": "a",
        "_bridgeOut": "b",
        "toChainID": "c",
        "deadline": "d",
        "spender": "e",
        "amount": "f",
        "permit": "g",
        "token": "h",
        "owner": "i",
        "to": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_027",
      "transformed_id": "ss_l2_short_nc_tc_027",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IPair {\n    function p() external view returns (address);\n    function o() external view returns (address);\n    function e() external view returns (uint112, uint112, uint32);\n}\n\ncontract SwapRouter {\n\n    function a(\n        uint256 l,\n        uint256 c,\n        address[] calldata t,\n        address u,\n        uint256 j\n    ) external returns (uint[] memory n) {\n\n        n = new uint[](t.length);\n        n[0] = l;\n\n        for (uint i = 0; i < t.length - 1; i++) {\n            address s = k(t[i], t[i+1]);\n\n            (uint112 m, uint112 i,) = IPair(s).e();\n\n            n[i+1] = b(n[i], m, i);\n        }\n\n        return n;\n    }\n\n    function k(address q, address r) internal pure returns (address) {\n        return address(uint160(uint256(h(abi.d(q, r)))));\n    }\n\n    function b(uint256 l, uint112 g, uint112 f) internal pure returns (uint256) {\n        return (l * uint256(f)) / uint256(g);\n    }\n}",
      "rename_map": {
        "swapExactTokensForTokens": "a",
        "_getAmountOut": "b",
        "amountOutMin": "c",
        "encodePacked": "d",
        "getReserves": "e",
        "reserveOut": "f",
        "reserveIn": "g",
        "keccak256": "h",
        "reserve1": "i",
        "deadline": "j",
        "_getPair": "k",
        "amountIn": "l",
        "reserve0": "m",
        "amounts": "n",
        "token1": "o",
        "token0": "p",
        "tokenA": "q",
        "tokenB": "r",
        "pair": "s",
        "path": "t",
        "to": "u"
      },
      "changes": [
        "Renamed 21 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_028",
      "transformed_id": "ss_l2_short_nc_tc_028",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function b(address e) external view returns (uint256);\n    function transfer(address j, uint256 g) external returns (bool);\n    function a(address from, address j, uint256 g) external returns (bool);\n}\n\ncontract TokenVault {\n    address public i;\n    mapping(address => uint256) public d;\n\n    constructor(address h) {\n        i = h;\n    }\n\n    function f(uint256 g) external {\n        IERC20(i).a(msg.sender, address(this), g);\n\n        d[msg.sender] += g;\n    }\n\n    function c(uint256 g) external {\n        require(d[msg.sender] >= g, \"Insufficient\");\n\n        d[msg.sender] -= g;\n\n        IERC20(i).transfer(msg.sender, g);\n    }\n}",
      "rename_map": {
        "transferFrom": "a",
        "balanceOf": "b",
        "withdraw": "c",
        "deposits": "d",
        "account": "e",
        "deposit": "f",
        "amount": "g",
        "_token": "h",
        "token": "i",
        "to": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_029",
      "transformed_id": "ss_l2_short_nc_tc_029",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function e(address i) external view returns (uint256);\n    function transfer(address s, uint256 m) external returns (bool);\n    function a(address from, address s, uint256 m) external returns (bool);\n}\n\ninterface IPriceOracle {\n    function h(address p) external view returns (uint256);\n}\n\ncontract VaultStrategy {\n    address public f;\n    address public l;\n    uint256 public c;\n\n    mapping(address => uint256) public n;\n\n    constructor(address q, address j) {\n        f = q;\n        l = j;\n    }\n\n    function k(uint256 m) external returns (uint256 d) {\n        uint256 r = IERC20(f).e(address(this));\n\n        if (c == 0) {\n            d = m;\n        } else {\n            uint256 o = IPriceOracle(l).h(f);\n            d = (m * c * 1e18) / (r * o);\n        }\n\n        n[msg.sender] += d;\n        c += d;\n\n        IERC20(f).a(msg.sender, address(this), m);\n        return d;\n    }\n\n    function g(uint256 b) external {\n        uint256 r = IERC20(f).e(address(this));\n\n        uint256 o = IPriceOracle(l).h(f);\n        uint256 m = (b * r * o) / (c * 1e18);\n\n        n[msg.sender] -= b;\n        c -= b;\n\n        IERC20(f).transfer(msg.sender, m);\n    }\n}",
      "rename_map": {
        "transferFrom": "a",
        "sharesAmount": "b",
        "totalShares": "c",
        "sharesAdded": "d",
        "balanceOf": "e",
        "wantToken": "f",
        "withdraw": "g",
        "getPrice": "h",
        "account": "i",
        "_oracle": "j",
        "deposit": "k",
        "oracle": "l",
        "amount": "m",
        "shares": "n",
        "price": "o",
        "token": "p",
        "_want": "q",
        "pool": "r",
        "to": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_030",
      "transformed_id": "ss_l2_short_nc_tc_030",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ncontract LiquidityPool {\n    uint256 public i;\n    uint256 public e;\n    uint256 public j;\n\n    mapping(address => uint256) public m;\n\n    function c(uint256 l, uint256 g) external returns (uint256 b) {\n\n        if (j == 0) {\n            b = l;\n        } else {\n            uint256 k = (l * j) / i;\n            uint256 f = (g * j) / e;\n\n            b = (k + f) / 2;\n        }\n\n        m[msg.sender] += b;\n        j += b;\n\n        i += l;\n        e += g;\n\n        return b;\n    }\n\n    function a(uint256 b) external returns (uint256, uint256) {\n        uint256 h = (b * i) / j;\n        uint256 d = (b * e) / j;\n\n        m[msg.sender] -= b;\n        j -= b;\n\n        i -= h;\n        e -= d;\n\n        return (h, d);\n    }\n}",
      "rename_map": {
        "removeLiquidity": "a",
        "liquidityUnits": "b",
        "addLiquidity": "c",
        "outputToken": "d",
        "tokenAmount": "e",
        "tokenRatio": "f",
        "inputToken": "g",
        "outputBase": "h",
        "baseAmount": "i",
        "totalUnits": "j",
        "baseRatio": "k",
        "inputBase": "l",
        "units": "m"
      },
      "changes": [
        "Renamed 13 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_031",
      "transformed_id": "ss_l2_short_nc_tc_031",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address s, uint256 o) external returns (bool);\n\n    function i(address m) external view returns (uint256);\n}\n\ncontract OrbitBridge {\n    mapping(bytes32 => bool) public a;\n    uint256 public constant REQUIRED_SIGNATURES = 5;\n    uint256 public constant TOTAL_VALIDATORS = 7;\n\n    mapping(address => bool) public e;\n    address[] public b;\n\n    event WithdrawalProcessed(\n        bytes32 n,\n        address r,\n        address f,\n        uint256 o\n    );\n\n    constructor() {\n        b = new address[](TOTAL_VALIDATORS);\n    }\n\n    function k(\n        address d,\n        string memory g,\n        bytes memory l,\n        address p,\n        address r,\n        bytes32[] memory j,\n        uint256[] memory q,\n        bytes memory data,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) external {\n        bytes32 n = j[1];\n\n        require(\n            !a[n],\n            \"Transaction already processed\"\n        );\n\n        require(v.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n        require(\n            v.length == r.length && r.length == s.length,\n            \"Signature length mismatch\"\n        );\n\n        uint256 o = q[0];\n\n        a[n] = true;\n\n        IERC20(r).transfer(p, o);\n\n        emit WithdrawalProcessed(n, r, p, o);\n    }\n\n    function c(address h) external {\n        e[h] = true;\n    }\n}",
      "rename_map": {
        "processedTransactions": "a",
        "validatorList": "b",
        "addValidator": "c",
        "hubContract": "d",
        "validators": "e",
        "recipient": "f",
        "fromChain": "g",
        "validator": "h",
        "balanceOf": "i",
        "bytes32s": "j",
        "withdraw": "k",
        "fromAddr": "l",
        "account": "m",
        "txHash": "n",
        "amount": "o",
        "toAddr": "p",
        "uints": "q",
        "token": "r",
        "to": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_032",
      "transformed_id": "ss_l2_short_nc_tc_032",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address aj, uint256 ac) external returns (bool);\n\n    function k(\n        address from,\n        address aj,\n        uint256 ac\n    ) external returns (bool);\n\n    function o(address y) external view returns (uint256);\n\n    function x(address u, uint256 ac) external returns (bool);\n}\n\ninterface IFlashLoanReceiver {\n    function b(\n        address[] calldata aa,\n        uint256[] calldata v,\n        uint256[] calldata s,\n        address q,\n        bytes calldata ae\n    ) external returns (bool);\n}\n\ncontract RadiantLendingPool {\n    uint256 public constant RAY = 1e27;\n\n    struct ReserveData {\n        uint256 e;\n        uint256 f;\n        address h;\n    }\n\n    mapping(address => ReserveData) public t;\n\n    function z(\n        address ag,\n        uint256 ac,\n        address n,\n        uint16 i\n    ) external {\n        IERC20(ag).k(msg.sender, address(this), ac);\n\n        ReserveData storage w = t[ag];\n\n        uint256 a = w.e;\n        if (a == 0) {\n            a = RAY;\n        }\n\n        w.e =\n            a +\n            (ac * RAY) /\n            (w.f + 1);\n        w.f += ac;\n\n        uint256 j = af(ac, w.e);\n        l(w.h, n, j);\n    }\n\n    function r(\n        address ag,\n        uint256 ac,\n        address aj\n    ) external returns (uint256) {\n        ReserveData storage w = t[ag];\n\n        uint256 g = af(ac, w.e);\n\n        m(w.h, msg.sender, g);\n\n        w.f -= ac;\n        IERC20(ag).transfer(aj, ac);\n\n        return ac;\n    }\n\n    function ad(\n        address ag,\n        uint256 ac,\n        uint256 c,\n        uint16 i,\n        address n\n    ) external {\n        IERC20(ag).transfer(n, ac);\n    }\n\n    function p(\n        address d,\n        address[] calldata aa,\n        uint256[] calldata v,\n        uint256[] calldata ah,\n        address n,\n        bytes calldata ae,\n        uint16 i\n    ) external {\n        for (uint256 i = 0; i < aa.length; i++) {\n            IERC20(aa[i]).transfer(d, v[i]);\n        }\n\n        require(\n            IFlashLoanReceiver(d).b(\n                aa,\n                v,\n                new uint256[](aa.length),\n                msg.sender,\n                ae\n            ),\n            \"Flashloan callback failed\"\n        );\n\n        for (uint256 i = 0; i < aa.length; i++) {\n            IERC20(aa[i]).k(\n                d,\n                address(this),\n                v[i]\n            );\n        }\n    }\n\n    function af(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 ai = b / 2;\n        require(b != 0, \"Division by zero\");\n        return (a * RAY + ai) / b;\n    }\n\n    function l(address ab, address aj, uint256 ac) internal {}\n\n    function m(\n        address ab,\n        address from,\n        uint256 ac\n    ) internal {}\n}",
      "rename_map": {
        "currentLiquidityIndex": "a",
        "executeOperation": "b",
        "interestRateMode": "c",
        "receiverAddress": "d",
        "liquidityIndex": "e",
        "totalLiquidity": "f",
        "rTokensToBurn": "g",
        "rTokenAddress": "h",
        "referralCode": "i",
        "rTokenAmount": "j",
        "transferFrom": "k",
        "_mintRToken": "l",
        "_burnRToken": "m",
        "onBehalfOf": "n",
        "balanceOf": "o",
        "flashLoan": "p",
        "initiator": "q",
        "withdraw": "r",
        "premiums": "s",
        "reserves": "t",
        "spender": "u",
        "amounts": "v",
        "reserve": "w",
        "approve": "x",
        "account": "y",
        "deposit": "z",
        "assets": "aa",
        "rToken": "ab",
        "amount": "ac",
        "borrow": "ad",
        "params": "ae",
        "rayDiv": "af",
        "asset": "ag",
        "modes": "ah",
        "halfB": "ai",
        "to": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_033",
      "transformed_id": "ss_l2_short_nc_tc_033",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address w, uint256 t) external returns (bool);\n\n    function e(\n        address from,\n        address w,\n        uint256 t\n    ) external returns (bool);\n\n    function j(address r) external view returns (uint256);\n\n    function q(address m, uint256 t) external returns (bool);\n}\n\ncontract SocketGateway {\n    mapping(uint32 => address) public s;\n    mapping(address => bool) public b;\n\n    event RouteExecuted(uint32 o, address v, bytes u);\n\n    function f(\n        uint32 o,\n        bytes calldata h\n    ) external payable returns (bytes memory) {\n        address g = s[o];\n        require(g != address(0), \"Invalid route\");\n        require(b[g], \"Route not approved\");\n\n        (bool n, bytes memory u) = g.call(h);\n        require(n, \"Route execution failed\");\n\n        emit RouteExecuted(o, msg.sender, u);\n        return u;\n    }\n\n    function l(uint32 o, address g) external {\n        s[o] = g;\n        b[g] = true;\n    }\n}\n\ncontract BasicRoute {\n    function c(\n        address i,\n        address p,\n        uint256 t,\n        address a,\n        bytes32 k,\n        bytes calldata d\n    ) external payable returns (uint256) {\n        if (d.length > 0) {\n            (bool n, ) = i.call(d);\n            require(n, \"Swap failed\");\n        }\n\n        return t;\n    }\n}",
      "rename_map": {
        "receiverAddress": "a",
        "approvedRoutes": "b",
        "performAction": "c",
        "swapExtraData": "d",
        "transferFrom": "e",
        "executeRoute": "f",
        "routeAddress": "g",
        "routeData": "h",
        "fromToken": "i",
        "balanceOf": "j",
        "metadata": "k",
        "addRoute": "l",
        "spender": "m",
        "success": "n",
        "routeId": "o",
        "toToken": "p",
        "approve": "q",
        "account": "r",
        "routes": "s",
        "amount": "t",
        "result": "u",
        "user": "v",
        "to": "w"
      },
      "changes": [
        "Renamed 23 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_034",
      "transformed_id": "ss_l2_short_nc_tc_034",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address aj, uint256 aa) external returns (bool);\n\n    function h(\n        address from,\n        address aj,\n        uint256 aa\n    ) external returns (bool);\n\n    function o(address x) external view returns (uint256);\n\n    function w(address u, uint256 aa) external returns (bool);\n}\n\ninterface IUniswapV3Pool {\n    function ai(\n        address m,\n        bool k,\n        int256 c,\n        uint160 a,\n        bytes calldata data\n    ) external returns (int256 y, int256 v);\n\n    function ag(\n        address m,\n        uint256 y,\n        uint256 v,\n        bytes calldata data\n    ) external;\n}\n\ncontract GammaHypervisor {\n    IERC20 public ac;\n    IERC20 public ab;\n    IUniswapV3Pool public ah;\n\n    uint256 public j;\n    mapping(address => uint256) public o;\n\n    struct Position {\n        uint128 n;\n        int24 l;\n        int24 p;\n    }\n\n    Position public i;\n    Position public f;\n\n    function z(\n        uint256 r,\n        uint256 s,\n        address aj\n    ) external returns (uint256 ad) {\n        uint256 ae = ac.o(address(this));\n        uint256 af = ab.o(address(this));\n\n        ac.h(msg.sender, address(this), r);\n        ab.h(msg.sender, address(this), s);\n\n        if (j == 0) {\n            ad = r + s;\n        } else {\n            uint256 d = ae + r;\n            uint256 e = af + s;\n\n            ad = (j * (r + s)) / (ae + af);\n        }\n\n        o[aj] += ad;\n        j += ad;\n\n        g(r, s);\n    }\n\n    function t(\n        uint256 ad,\n        address aj\n    ) external returns (uint256 y, uint256 v) {\n        require(o[msg.sender] >= ad, \"Insufficient balance\");\n\n        uint256 ae = ac.o(address(this));\n        uint256 af = ab.o(address(this));\n\n        y = (ad * ae) / j;\n        v = (ad * af) / j;\n\n        o[msg.sender] -= ad;\n        j -= ad;\n\n        ac.transfer(aj, y);\n        ab.transfer(aj, v);\n    }\n\n    function q() external {\n        b(i.n);\n\n        g(\n            ac.o(address(this)),\n            ab.o(address(this))\n        );\n    }\n\n    function g(uint256 y, uint256 v) internal {}\n\n    function b(uint128 n) internal {}\n}",
      "rename_map": {
        "sqrtPriceLimitX96": "a",
        "_removeLiquidity": "b",
        "amountSpecified": "c",
        "amount0Current": "d",
        "amount1Current": "e",
        "limitPosition": "f",
        "_addLiquidity": "g",
        "transferFrom": "h",
        "basePosition": "i",
        "totalSupply": "j",
        "zeroForOne": "k",
        "tickLower": "l",
        "recipient": "m",
        "liquidity": "n",
        "balanceOf": "o",
        "tickUpper": "p",
        "rebalance": "q",
        "deposit0": "r",
        "deposit1": "s",
        "withdraw": "t",
        "spender": "u",
        "amount1": "v",
        "approve": "w",
        "account": "x",
        "amount0": "y",
        "deposit": "z",
        "amount": "aa",
        "token1": "ab",
        "token0": "ac",
        "shares": "ad",
        "total0": "ae",
        "total1": "af",
        "flash": "ag",
        "pool": "ah",
        "swap": "ai",
        "to": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_035",
      "transformed_id": "ss_l2_short_nc_tc_035",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ah, uint256 ad) external returns (bool);\n\n    function o(\n        address from,\n        address ah,\n        uint256 ad\n    ) external returns (bool);\n\n    function v(address aa) external view returns (uint256);\n\n    function z(address w, uint256 ad) external returns (bool);\n}\n\ninterface IERC721 {\n    function o(address from, address ah, uint256 y) external;\n\n    function x(uint256 y) external view returns (address);\n}\n\ncontract WiseLending {\n    struct PoolData {\n        uint256 l;\n        uint256 e;\n        uint256 g;\n        uint256 i;\n    }\n\n    mapping(address => PoolData) public k;\n    mapping(uint256 => mapping(address => uint256)) public f;\n    mapping(uint256 => mapping(address => uint256)) public h;\n\n    IERC721 public q;\n    uint256 public r;\n\n    function n() external returns (uint256) {\n        uint256 af = ++r;\n        return af;\n    }\n\n    function d(\n        uint256 ae,\n        address u,\n        uint256 ac\n    ) external returns (uint256 s) {\n        IERC20(u).o(msg.sender, address(this), ac);\n\n        PoolData storage ag = k[u];\n\n        if (ag.e == 0) {\n            s = ac;\n            ag.e = ac;\n        } else {\n            s =\n                (ac * ag.e) /\n                ag.l;\n            ag.e += s;\n        }\n\n        ag.l += ac;\n        f[ae][u] += s;\n\n        return s;\n    }\n\n    function c(\n        uint256 ae,\n        address u,\n        uint256 ab\n    ) external returns (uint256 m) {\n        require(\n            f[ae][u] >= ab,\n            \"Insufficient shares\"\n        );\n\n        PoolData storage ag = k[u];\n\n        m =\n            (ab * ag.l) /\n            ag.e;\n\n        f[ae][u] -= ab;\n        ag.e -= ab;\n        ag.l -= m;\n\n        IERC20(u).transfer(msg.sender, m);\n\n        return m;\n    }\n\n    function b(\n        uint256 ae,\n        address u,\n        uint256 j\n    ) external returns (uint256 t) {\n        PoolData storage ag = k[u];\n\n        t =\n            (j * ag.e) /\n            ag.l;\n\n        require(\n            f[ae][u] >= t,\n            \"Insufficient shares\"\n        );\n\n        f[ae][u] -= t;\n        ag.e -= t;\n        ag.l -= j;\n\n        IERC20(u).transfer(msg.sender, j);\n\n        return t;\n    }\n\n    function a(\n        uint256 ae,\n        address u\n    ) external view returns (uint256) {\n        return f[ae][u];\n    }\n\n    function p(address u) external view returns (uint256) {\n        return k[u].l;\n    }\n}",
      "rename_map": {
        "getPositionLendingShares": "a",
        "withdrawExactAmount": "b",
        "withdrawExactShares": "c",
        "depositExactAmount": "d",
        "totalDepositShares": "e",
        "userLendingShares": "f",
        "totalBorrowShares": "g",
        "userBorrowShares": "h",
        "collateralFactor": "i",
        "_withdrawAmount": "j",
        "lendingPoolData": "k",
        "pseudoTotalPool": "l",
        "withdrawAmount": "m",
        "mintPosition": "n",
        "transferFrom": "o",
        "getTotalPool": "p",
        "positionNFTs": "q",
        "nftIdCounter": "r",
        "shareAmount": "s",
        "shareBurned": "t",
        "_poolToken": "u",
        "balanceOf": "v",
        "spender": "w",
        "ownerOf": "x",
        "tokenId": "y",
        "approve": "z",
        "account": "aa",
        "_shares": "ab",
        "_amount": "ac",
        "amount": "ad",
        "_nftId": "ae",
        "nftId": "af",
        "pool": "ag",
        "to": "ah"
      },
      "changes": [
        "Renamed 34 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_036",
      "transformed_id": "ss_l2_short_nc_tc_036",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address al, uint256 ag) external returns (bool);\n\n    function l(\n        address from,\n        address al,\n        uint256 ag\n    ) external returns (bool);\n\n    function x(address ae) external view returns (uint256);\n\n    function ad(address ab, uint256 ag) external returns (bool);\n}\n\ninterface IBorrowerOperations {\n    function a(address v, bool o) external;\n\n    function t(\n        address m,\n        address ae,\n        uint256 f,\n        uint256 g,\n        uint256 n,\n        address q,\n        address s\n    ) external;\n\n    function r(address m, address ae) external;\n}\n\ninterface ITroveManager {\n    function d(\n        address aa\n    ) external view returns (uint256 ak, uint256 aj);\n\n    function y(address aa) external;\n}\n\ncontract MigrateTroveZap {\n    IBorrowerOperations public e;\n    address public af;\n    address public ai;\n\n    constructor(address c, address ac, address ah) {\n        e = c;\n        af = ac;\n        ai = ah;\n    }\n\n    function b(\n        address m,\n        address ae,\n        uint256 i,\n        uint256 h,\n        uint256 p,\n        address u,\n        address z\n    ) external {\n        IERC20(af).l(\n            msg.sender,\n            address(this),\n            h\n        );\n\n        IERC20(af).ad(address(e), h);\n\n        e.t(\n            m,\n            ae,\n            i,\n            h,\n            p,\n            u,\n            z\n        );\n\n        IERC20(ai).transfer(msg.sender, p);\n    }\n\n    function k(address m, address ae) external {\n        e.r(m, ae);\n    }\n}\n\ncontract BorrowerOperations {\n    mapping(address => mapping(address => bool)) public w;\n    ITroveManager public m;\n\n    function a(address v, bool o) external {\n        w[msg.sender][v] = o;\n    }\n\n    function t(\n        address j,\n        address ae,\n        uint256 f,\n        uint256 g,\n        uint256 n,\n        address q,\n        address s\n    ) external {\n        require(\n            msg.sender == ae || w[ae][msg.sender],\n            \"Not authorized\"\n        );\n    }\n\n    function r(address j, address ae) external {\n        require(\n            msg.sender == ae || w[ae][msg.sender],\n            \"Not authorized\"\n        );\n    }\n}",
      "rename_map": {
        "setDelegateApproval": "a",
        "openTroveAndMigrate": "b",
        "_borrowerOperations": "c",
        "getTroveCollAndDebt": "d",
        "borrowerOperations": "e",
        "_maxFeePercentage": "f",
        "_collateralAmount": "g",
        "collateralAmount": "h",
        "maxFeePercentage": "i",
        "_troveManager": "j",
        "closeTroveFor": "k",
        "transferFrom": "l",
        "troveManager": "m",
        "_debtAmount": "n",
        "_isApproved": "o",
        "debtAmount": "p",
        "_upperHint": "q",
        "closeTrove": "r",
        "_lowerHint": "s",
        "openTrove": "t",
        "upperHint": "u",
        "_delegate": "v",
        "delegates": "w",
        "balanceOf": "x",
        "liquidate": "y",
        "lowerHint": "z",
        "_borrower": "aa",
        "spender": "ab",
        "_wstETH": "ac",
        "approve": "ad",
        "account": "ae",
        "wstETH": "af",
        "amount": "ag",
        "_mkUSD": "ah",
        "mkUSD": "ai",
        "debt": "aj",
        "coll": "ak",
        "to": "al"
      },
      "changes": [
        "Renamed 38 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_037",
      "transformed_id": "ss_l2_short_nc_tc_037",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address aj, uint256 ab) external returns (bool);\n\n    function g(\n        address from,\n        address aj,\n        uint256 ab\n    ) external returns (bool);\n\n    function k(address w) external view returns (uint256);\n\n    function v(address t, uint256 ab) external returns (bool);\n}\n\ninterface IAaveOracle {\n    function e(address ah) external view returns (uint256);\n\n    function c(\n        address[] calldata z,\n        address[] calldata x\n    ) external;\n}\n\ninterface ICurvePool {\n    function n(\n        int128 i,\n        int128 j,\n        uint256 ai,\n        uint256 ac\n    ) external returns (uint256);\n\n    function ae(\n        int128 i,\n        int128 j,\n        uint256 ai\n    ) external view returns (uint256);\n\n    function q(uint256 i) external view returns (uint256);\n}\n\ninterface ILendingPool {\n    function y(\n        address ah,\n        uint256 ab,\n        address j,\n        uint16 f\n    ) external;\n\n    function ad(\n        address ah,\n        uint256 ab,\n        uint256 a,\n        uint16 f,\n        address j\n    ) external;\n\n    function o(\n        address ah,\n        uint256 ab,\n        address aj\n    ) external returns (uint256);\n}\n\ncontract UwuLendingPool is ILendingPool {\n    IAaveOracle public aa;\n    mapping(address => uint256) public r;\n    mapping(address => uint256) public u;\n    uint256 public constant LTV = 8500;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    function y(\n        address ah,\n        uint256 ab,\n        address j,\n        uint16 f\n    ) external override {\n        IERC20(ah).g(msg.sender, address(this), ab);\n        r[j] += ab;\n    }\n\n    function ad(\n        address ah,\n        uint256 ab,\n        uint256 a,\n        uint16 f,\n        address j\n    ) external override {\n        uint256 d = aa.e(msg.sender);\n        uint256 h = aa.e(ah);\n\n        uint256 b = (r[msg.sender] * d) /\n            1e18;\n        uint256 m = (b * LTV) / BASIS_POINTS;\n\n        uint256 i = (ab * h) / 1e18;\n\n        require(i <= m, \"Insufficient collateral\");\n\n        u[msg.sender] += ab;\n        IERC20(ah).transfer(j, ab);\n    }\n\n    function o(\n        address ah,\n        uint256 ab,\n        address aj\n    ) external override returns (uint256) {\n        require(r[msg.sender] >= ab, \"Insufficient balance\");\n        r[msg.sender] -= ab;\n        IERC20(ah).transfer(aj, ab);\n        return ab;\n    }\n}\n\ncontract CurveOracle {\n    ICurvePool public l;\n\n    constructor(address ag) {\n        l = ag;\n    }\n\n    function e(address ah) external view returns (uint256) {\n        uint256 s = l.q(0);\n        uint256 p = l.q(1);\n\n        uint256 af = (p * 1e18) / s;\n\n        return af;\n    }\n}",
      "rename_map": {
        "interestRateMode": "a",
        "collateralValue": "b",
        "setAssetSources": "c",
        "collateralPrice": "d",
        "getAssetPrice": "e",
        "referralCode": "f",
        "transferFrom": "g",
        "borrowPrice": "h",
        "borrowValue": "i",
        "onBehalfOf": "j",
        "balanceOf": "k",
        "curvePool": "l",
        "maxBorrow": "m",
        "exchange": "n",
        "withdraw": "o",
        "balance1": "p",
        "balances": "q",
        "deposits": "r",
        "balance0": "s",
        "spender": "t",
        "borrows": "u",
        "approve": "v",
        "account": "w",
        "sources": "x",
        "deposit": "y",
        "assets": "z",
        "oracle": "aa",
        "amount": "ab",
        "min_dy": "ac",
        "borrow": "ad",
        "get_dy": "ae",
        "price": "af",
        "_pool": "ag",
        "asset": "ah",
        "dx": "ai",
        "to": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_038",
      "transformed_id": "ss_l2_short_nc_tc_038",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ah, uint256 ab) external returns (bool);\n\n    function g(\n        address from,\n        address ah,\n        uint256 ab\n    ) external returns (bool);\n\n    function o(address x) external view returns (uint256);\n\n    function v(address u, uint256 ab) external returns (bool);\n}\n\ninterface IPriceOracle {\n    function r(address af) external view returns (uint256);\n}\n\ncontract BlueberryLending {\n    struct Market {\n        bool t;\n        uint256 c;\n        mapping(address => uint256) b;\n        mapping(address => uint256) f;\n    }\n\n    mapping(address => Market) public y;\n    IPriceOracle public aa;\n\n    uint256 public constant COLLATERAL_FACTOR = 75;\n    uint256 public constant BASIS_POINTS = 100;\n\n    function i(\n        address[] calldata w\n    ) external returns (uint256[] memory) {\n        uint256[] memory z = new uint256[](w.length);\n        for (uint256 i = 0; i < w.length; i++) {\n            y[w[i]].t = true;\n            z[i] = 0;\n        }\n        return z;\n    }\n\n    function ag(address af, uint256 ab) external returns (uint256) {\n        IERC20(af).g(msg.sender, address(this), ab);\n\n        uint256 ae = aa.r(af);\n\n        y[af].b[msg.sender] += ab;\n        return 0;\n    }\n\n    function ac(\n        address j,\n        uint256 h\n    ) external returns (uint256) {\n        uint256 a = 0;\n\n        uint256 l = aa.r(j);\n        uint256 m = (h * l) / 1e18;\n\n        uint256 e = (a * COLLATERAL_FACTOR) /\n            BASIS_POINTS;\n\n        require(m <= e, \"Insufficient collateral\");\n\n        y[j].f[msg.sender] += h;\n        IERC20(j).transfer(msg.sender, h);\n\n        return 0;\n    }\n\n    function p(\n        address s,\n        address n,\n        uint256 k,\n        address d\n    ) external {}\n}\n\ncontract ManipulableOracle is IPriceOracle {\n    mapping(address => uint256) public ad;\n\n    function r(address af) external view override returns (uint256) {\n        return ad[af];\n    }\n\n    function q(address af, uint256 ae) external {\n        ad[af] = ae;\n    }\n}",
      "rename_map": {
        "totalCollateralValue": "a",
        "accountCollateral": "b",
        "collateralFactor": "c",
        "collateralToken": "d",
        "maxBorrowValue": "e",
        "accountBorrows": "f",
        "transferFrom": "g",
        "borrowAmount": "h",
        "enterMarkets": "i",
        "borrowToken": "j",
        "repayAmount": "k",
        "borrowPrice": "l",
        "borrowValue": "m",
        "repayToken": "n",
        "balanceOf": "o",
        "liquidate": "p",
        "setPrice": "q",
        "getPrice": "r",
        "borrower": "s",
        "isListed": "t",
        "spender": "u",
        "approve": "v",
        "vTokens": "w",
        "account": "x",
        "markets": "y",
        "results": "z",
        "oracle": "aa",
        "amount": "ab",
        "borrow": "ac",
        "prices": "ad",
        "price": "ae",
        "token": "af",
        "mint": "ag",
        "to": "ah"
      },
      "changes": [
        "Renamed 34 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_039",
      "transformed_id": "ss_l2_short_nc_tc_039",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address w, uint256 r) external returns (bool);\n\n    function d(\n        address from,\n        address w,\n        uint256 r\n    ) external returns (bool);\n\n    function k(address p) external view returns (uint256);\n\n    function o(address m, uint256 r) external returns (bool);\n}\n\ninterface IWETH {\n    function q() external payable;\n\n    function l(uint256 r) external;\n\n    function k(address p) external view returns (uint256);\n}\n\ncontract CowSolver {\n    IWETH public immutable WETH;\n    address public immutable i;\n\n    constructor(address v, address h) {\n        WETH = IWETH(v);\n        i = h;\n    }\n\n    function a(\n        int256 e,\n        int256 f,\n        bytes calldata data\n    ) external payable {\n        (\n            uint256 u,\n            address s,\n            address n,\n            address j\n        ) = abi.t(data, (uint256, address, address, address));\n\n        uint256 g;\n        if (e > 0) {\n            g = uint256(e);\n        } else {\n            g = uint256(f);\n        }\n\n        if (n == address(WETH)) {\n            WETH.l(g);\n            payable(j).transfer(g);\n        } else {\n            IERC20(n).transfer(j, g);\n        }\n    }\n\n    function b(bytes calldata c) external {\n        require(msg.sender == i, \"Only settlement\");\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "uniswapV3SwapCallback": "a",
        "executeSettlement": "b",
        "settlementData": "c",
        "transferFrom": "d",
        "amount0Delta": "e",
        "amount1Delta": "f",
        "amountToPay": "g",
        "_settlement": "h",
        "settlement": "i",
        "recipient": "j",
        "balanceOf": "k",
        "withdraw": "l",
        "spender": "m",
        "tokenIn": "n",
        "approve": "o",
        "account": "p",
        "deposit": "q",
        "amount": "r",
        "solver": "s",
        "decode": "t",
        "price": "u",
        "_weth": "v",
        "to": "w"
      },
      "changes": [
        "Renamed 23 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_040",
      "transformed_id": "ss_l2_short_nc_tc_040",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ad, uint256 v) external returns (bool);\n\n    function g(\n        address from,\n        address ad,\n        uint256 v\n    ) external returns (bool);\n\n    function l(address t) external view returns (uint256);\n\n    function s(address q, uint256 v) external returns (bool);\n}\n\ninterface IUniswapV3Router {\n    struct ExactInputSingleParams {\n        address r;\n        address o;\n        uint24 ac;\n        address i;\n        uint256 m;\n        uint256 n;\n        uint256 d;\n        uint160 b;\n    }\n\n    function e(\n        ExactInputSingleParams calldata y\n    ) external payable returns (uint256 j);\n}\n\ncontract BedrockVault {\n    IERC20 public immutable z;\n    IERC20 public immutable WBTC;\n    IUniswapV3Router public immutable x;\n\n    uint256 public c;\n    uint256 public a;\n\n    constructor(address u, address aa, address p) {\n        z = IERC20(u);\n        WBTC = IERC20(aa);\n        x = IUniswapV3Router(p);\n    }\n\n    function ab() external payable {\n        require(msg.value > 0, \"No ETH sent\");\n\n        uint256 h = msg.value;\n\n        c += msg.value;\n        a += h;\n\n        z.transfer(msg.sender, h);\n    }\n\n    function w(uint256 v) external {\n        require(v > 0, \"No amount specified\");\n        require(z.l(msg.sender) >= v, \"Insufficient balance\");\n\n        z.g(msg.sender, address(this), v);\n\n        uint256 k = v;\n        require(address(this).balance >= k, \"Insufficient ETH\");\n\n        payable(msg.sender).transfer(k);\n    }\n\n    function f() external pure returns (uint256) {\n        return 1e18;\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "totalUniBTCMinted": "a",
        "sqrtPriceLimitX96": "b",
        "totalETHDeposited": "c",
        "amountOutMinimum": "d",
        "exactInputSingle": "e",
        "getExchangeRate": "f",
        "transferFrom": "g",
        "uniBTCAmount": "h",
        "recipient": "i",
        "amountOut": "j",
        "ethAmount": "k",
        "balanceOf": "l",
        "deadline": "m",
        "amountIn": "n",
        "tokenOut": "o",
        "_router": "p",
        "spender": "q",
        "tokenIn": "r",
        "approve": "s",
        "account": "t",
        "_uniBTC": "u",
        "amount": "v",
        "redeem": "w",
        "router": "x",
        "params": "y",
        "uniBTC": "z",
        "_wbtc": "aa",
        "mint": "ab",
        "fee": "ac",
        "to": "ad"
      },
      "changes": [
        "Renamed 30 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_041",
      "transformed_id": "ss_l2_short_nc_tc_041",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address z, uint256 t) external returns (bool);\n\n    function g(\n        address from,\n        address z,\n        uint256 t\n    ) external returns (bool);\n\n    function k(address r) external view returns (uint256);\n\n    function q(address o, uint256 t) external returns (bool);\n}\n\ncontract ShezmuCollateralToken is IERC20 {\n    string public x = \"Shezmu Collateral Token\";\n    string public v = \"SCT\";\n    uint8 public n = 18;\n\n    mapping(address => uint256) public k;\n    mapping(address => mapping(address => uint256)) public j;\n    uint256 public h;\n\n    function y(address z, uint256 t) external {\n        k[z] += t;\n        h += t;\n    }\n\n    function transfer(\n        address z,\n        uint256 t\n    ) external override returns (bool) {\n        require(k[msg.sender] >= t, \"Insufficient balance\");\n        k[msg.sender] -= t;\n        k[z] += t;\n        return true;\n    }\n\n    function g(\n        address from,\n        address z,\n        uint256 t\n    ) external override returns (bool) {\n        require(k[from] >= t, \"Insufficient balance\");\n        require(\n            j[from][msg.sender] >= t,\n            \"Insufficient allowance\"\n        );\n        k[from] -= t;\n        k[z] += t;\n        j[from][msg.sender] -= t;\n        return true;\n    }\n\n    function q(\n        address o,\n        uint256 t\n    ) external override returns (bool) {\n        j[msg.sender][o] = t;\n        return true;\n    }\n}\n\ncontract ShezmuVault {\n    IERC20 public e;\n    IERC20 public p;\n\n    mapping(address => uint256) public c;\n    mapping(address => uint256) public i;\n\n    uint256 public constant COLLATERAL_RATIO = 150;\n    uint256 public constant BASIS_POINTS = 100;\n\n    constructor(address d, address m) {\n        e = IERC20(d);\n        p = IERC20(m);\n    }\n\n    function f(uint256 t) external {\n        e.g(msg.sender, address(this), t);\n        c[msg.sender] += t;\n    }\n\n    function u(uint256 t) external {\n        uint256 l = (c[msg.sender] * BASIS_POINTS) /\n            COLLATERAL_RATIO;\n\n        require(\n            i[msg.sender] + t <= l,\n            \"Insufficient collateral\"\n        );\n\n        i[msg.sender] += t;\n\n        p.transfer(msg.sender, t);\n    }\n\n    function w(uint256 t) external {\n        require(i[msg.sender] >= t, \"Excessive repayment\");\n        p.g(msg.sender, address(this), t);\n        i[msg.sender] -= t;\n    }\n\n    function b(uint256 t) external {\n        require(\n            c[msg.sender] >= t,\n            \"Insufficient collateral\"\n        );\n        uint256 a = c[msg.sender] - t;\n        uint256 s = (a * BASIS_POINTS) /\n            COLLATERAL_RATIO;\n        require(\n            i[msg.sender] <= s,\n            \"Would be undercollateralized\"\n        );\n\n        c[msg.sender] -= t;\n        e.transfer(msg.sender, t);\n    }\n}",
      "rename_map": {
        "remainingCollateral": "a",
        "withdrawCollateral": "b",
        "collateralBalance": "c",
        "_collateralToken": "d",
        "collateralToken": "e",
        "addCollateral": "f",
        "transferFrom": "g",
        "totalSupply": "h",
        "debtBalance": "i",
        "allowance": "j",
        "balanceOf": "k",
        "maxBorrow": "l",
        "_shezUSD": "m",
        "decimals": "n",
        "spender": "o",
        "shezUSD": "p",
        "approve": "q",
        "account": "r",
        "maxDebt": "s",
        "amount": "t",
        "borrow": "u",
        "symbol": "v",
        "repay": "w",
        "name": "x",
        "mint": "y",
        "to": "z"
      },
      "changes": [
        "Renamed 26 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_042",
      "transformed_id": "ss_l2_short_nc_tc_042",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ab, uint256 s) external returns (bool);\n\n    function d(\n        address from,\n        address ab,\n        uint256 s\n    ) external returns (bool);\n\n    function j(address r) external view returns (uint256);\n\n    function q(address n, uint256 s) external returns (bool);\n}\n\nenum TokenLockup {\n    Unlocked,\n    Locked,\n    Vesting\n}\n\nstruct Campaign {\n    address m;\n    address u;\n    uint256 s;\n    uint256 z;\n    TokenLockup f;\n    bytes32 x;\n}\n\nstruct ClaimLockup {\n    address g;\n    uint256 w;\n    uint256 v;\n    uint256 t;\n    uint256 p;\n}\n\nstruct Donation {\n    address g;\n    uint256 s;\n    uint256 y;\n    uint256 w;\n    uint256 v;\n    uint256 t;\n}\n\ncontract HedgeyClaimCampaigns {\n    mapping(bytes16 => Campaign) public i;\n\n    function a(\n        bytes16 aa,\n        Campaign memory k,\n        ClaimLockup memory e,\n        Donation memory l\n    ) external {\n        require(i[aa].m == address(0), \"Campaign exists\");\n\n        i[aa] = k;\n\n        if (l.s > 0 && l.g != address(0)) {\n            (bool o, ) = l.g.call(\n                abi.b(\n                    \"createTokenLock(address,uint256,uint256,uint256,uint256,uint256)\",\n                    k.u,\n                    l.s,\n                    l.w,\n                    l.v,\n                    l.y,\n                    l.t\n                )\n            );\n\n            require(o, \"Token lock failed\");\n        }\n    }\n\n    function c(bytes16 h) external {\n        require(i[h].m == msg.sender, \"Not manager\");\n        delete i[h];\n    }\n}",
      "rename_map": {
        "createLockedCampaign": "a",
        "encodeWithSignature": "b",
        "cancelCampaign": "c",
        "transferFrom": "d",
        "claimLockup": "e",
        "tokenLockup": "f",
        "tokenLocker": "g",
        "campaignId": "h",
        "campaigns": "i",
        "balanceOf": "j",
        "campaign": "k",
        "donation": "l",
        "manager": "m",
        "spender": "n",
        "success": "o",
        "periods": "p",
        "approve": "q",
        "account": "r",
        "amount": "s",
        "period": "t",
        "token": "u",
        "cliff": "v",
        "start": "w",
        "root": "x",
        "rate": "y",
        "end": "z",
        "id": "aa",
        "to": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_043",
      "transformed_id": "ss_l2_short_nc_tc_043",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address q, uint256 j) external returns (bool);\n\n    function b(\n        address from,\n        address q,\n        uint256 j\n    ) external returns (bool);\n\n    function d(address h) external view returns (uint256);\n\n    function e(address f, uint256 j) external returns (bool);\n}\n\ncontract SenecaChamber {\n    uint8 public constant OPERATION_CALL = 30;\n    uint8 public constant OPERATION_DELEGATECALL = 31;\n\n    mapping(address => bool) public c;\n\n    function a(\n        uint8[] memory i,\n        uint256[] memory k,\n        bytes[] memory p\n    ) external payable returns (uint256 o, uint256 n) {\n        require(\n            i.length == k.length && k.length == p.length,\n            \"Length mismatch\"\n        );\n\n        for (uint256 i = 0; i < i.length; i++) {\n            if (i[i] == OPERATION_CALL) {\n                (address l, bytes memory callData, , , ) = abi.m(\n                    p[i],\n                    (address, bytes, uint256, uint256, uint256)\n                );\n\n                (bool g, ) = l.call{value: k[i]}(callData);\n                require(g, \"Call failed\");\n            }\n        }\n\n        return (0, 0);\n    }\n}",
      "rename_map": {
        "performOperations": "a",
        "transferFrom": "b",
        "vaultOwners": "c",
        "balanceOf": "d",
        "approve": "e",
        "spender": "f",
        "success": "g",
        "account": "h",
        "actions": "i",
        "amount": "j",
        "values": "k",
        "target": "l",
        "decode": "m",
        "value2": "n",
        "value1": "o",
        "datas": "p",
        "to": "q"
      },
      "changes": [
        "Renamed 17 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_044",
      "transformed_id": "ss_l2_short_nc_tc_044",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address y, uint256 s) external returns (bool);\n\n    function e(\n        address from,\n        address y,\n        uint256 s\n    ) external returns (bool);\n\n    function k(address r) external view returns (uint256);\n\n    function q(address o, uint256 s) external returns (bool);\n}\n\ninterface ISmartLoan {\n    function c(\n        bytes32 j,\n        bytes32 m,\n        uint256 f,\n        uint256 d,\n        bytes4 selector,\n        bytes memory data\n    ) external;\n\n    function h(address v, uint256[] calldata x) external;\n}\n\ncontract SmartLoansFactory {\n    address public t;\n\n    constructor() {\n        t = msg.sender;\n    }\n\n    function i() external returns (address) {\n        SmartLoan w = new SmartLoan();\n        return address(w);\n    }\n\n    function g(\n        address l,\n        address b\n    ) external {\n        require(msg.sender == t, \"Not admin\");\n    }\n}\n\ncontract SmartLoan is ISmartLoan {\n    mapping(bytes32 => uint256) public n;\n    mapping(bytes32 => uint256) public u;\n\n    function c(\n        bytes32 j,\n        bytes32 m,\n        uint256 f,\n        uint256 d,\n        bytes4 selector,\n        bytes memory data\n    ) external override {}\n\n    function h(\n        address v,\n        uint256[] calldata x\n    ) external override {\n        (bool p, ) = v.call(\n            abi.a(\"claimRewards(address)\", msg.sender)\n        );\n    }\n}",
      "rename_map": {
        "encodeWithSignature": "a",
        "newImplementation": "b",
        "swapDebtParaSwap": "c",
        "_borrowAmount": "d",
        "transferFrom": "e",
        "_repayAmount": "f",
        "upgradePool": "g",
        "claimReward": "h",
        "createLoan": "i",
        "_fromAsset": "j",
        "balanceOf": "k",
        "poolProxy": "l",
        "_toAsset": "m",
        "deposits": "n",
        "spender": "o",
        "success": "p",
        "approve": "q",
        "account": "r",
        "amount": "s",
        "admin": "t",
        "debts": "u",
        "pair": "v",
        "loan": "w",
        "ids": "x",
        "to": "y"
      },
      "changes": [
        "Renamed 25 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_045",
      "transformed_id": "ss_l2_short_nc_tc_045",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address s, uint256 p) external returns (bool);\n\n    function e(\n        address from,\n        address s,\n        uint256 p\n    ) external returns (bool);\n\n    function i(address m) external view returns (uint256);\n\n    function l(address k, uint256 p) external returns (bool);\n}\n\ninterface IPendleMarket {\n    function c() external view returns (address[] memory);\n\n    function a() external returns (uint256[] memory);\n\n    function g(address r) external returns (uint256[] memory);\n}\n\ncontract PenpieStaking {\n    mapping(address => mapping(address => uint256)) public f;\n    mapping(address => uint256) public h;\n\n    function o(address q, uint256 p) external {\n        IERC20(q).e(msg.sender, address(this), p);\n        f[q][msg.sender] += p;\n        h[q] += p;\n    }\n\n    function g(address q, address r) external {\n        uint256[] memory n = IPendleMarket(q).g(r);\n\n        for (uint256 i = 0; i < n.length; i++) {}\n    }\n\n    function j(address q, uint256 p) external {\n        require(\n            f[q][msg.sender] >= p,\n            \"Insufficient balance\"\n        );\n\n        f[q][msg.sender] -= p;\n        h[q] -= p;\n\n        IERC20(q).transfer(msg.sender, p);\n    }\n}\n\ncontract PendleMarketRegister {\n    mapping(address => bool) public b;\n\n    function d(address q) external {\n        b[q] = true;\n    }\n}",
      "rename_map": {
        "rewardIndexesCurrent": "a",
        "registeredMarkets": "b",
        "getRewardTokens": "c",
        "registerMarket": "d",
        "transferFrom": "e",
        "userBalances": "f",
        "claimRewards": "g",
        "totalStaked": "h",
        "balanceOf": "i",
        "withdraw": "j",
        "spender": "k",
        "approve": "l",
        "account": "m",
        "rewards": "n",
        "deposit": "o",
        "amount": "p",
        "market": "q",
        "user": "r",
        "to": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_046",
      "transformed_id": "ss_l2_short_nc_tc_046",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address l, uint256 i) external returns (bool);\n\n    function e(address h) external view returns (uint256);\n}\n\ncontract FloatHotWalletV2 {\n    address public j;\n\n    mapping(address => bool) public a;\n\n    event Withdrawal(address k, address l, uint256 i);\n\n    constructor() {\n        j = msg.sender;\n    }\n\n    modifier d() {\n        require(msg.sender == j, \"Not owner\");\n        _;\n    }\n\n    function f(\n        address k,\n        address l,\n        uint256 i\n    ) external d {\n        if (k == address(0)) {\n            payable(l).transfer(i);\n        } else {\n            IERC20(k).transfer(l, i);\n        }\n\n        emit Withdrawal(k, l, i);\n    }\n\n    function b(address k) external d {\n        uint256 balance;\n        if (k == address(0)) {\n            balance = address(this).balance;\n            payable(j).transfer(balance);\n        } else {\n            balance = IERC20(k).e(address(this));\n            IERC20(k).transfer(j, balance);\n        }\n\n        emit Withdrawal(k, j, balance);\n    }\n\n    function c(address g) external d {\n        j = g;\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "authorizedOperators": "a",
        "emergencyWithdraw": "b",
        "transferOwnership": "c",
        "onlyOwner": "d",
        "balanceOf": "e",
        "withdraw": "f",
        "newOwner": "g",
        "account": "h",
        "amount": "i",
        "owner": "j",
        "token": "k",
        "to": "l"
      },
      "changes": [
        "Renamed 12 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_047",
      "transformed_id": "ss_l2_short_nc_tc_047",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address s, uint256 l) external returns (bool);\n\n    function g(address k) external view returns (uint256);\n}\n\ncontract PlayDappToken {\n    string public q = \"PlayDapp Token\";\n    string public m = \"PLA\";\n    uint8 public h = 18;\n\n    uint256 public b;\n\n    address public n;\n\n    mapping(address => uint256) public g;\n    mapping(address => mapping(address => uint256)) public e;\n\n    event Transfer(address indexed from, address indexed s, uint256 value);\n    event Approval(\n        address indexed o,\n        address indexed i,\n        uint256 value\n    );\n    event Minted(address indexed s, uint256 l);\n\n    constructor() {\n        n = msg.sender;\n        p(msg.sender, 700_000_000 * 10 ** 18);\n    }\n\n    modifier c() {\n        require(msg.sender == n, \"Not minter\");\n        _;\n    }\n\n    function r(address s, uint256 l) external c {\n        p(s, l);\n        emit Minted(s, l);\n    }\n\n    function p(address s, uint256 l) internal {\n        require(s != address(0), \"Mint to zero address\");\n\n        b += l;\n        g[s] += l;\n\n        emit Transfer(address(0), s, l);\n    }\n\n    function f(address d) external c {\n        n = d;\n    }\n\n    function transfer(address s, uint256 l) external returns (bool) {\n        require(g[msg.sender] >= l, \"Insufficient balance\");\n        g[msg.sender] -= l;\n        g[s] += l;\n        emit Transfer(msg.sender, s, l);\n        return true;\n    }\n\n    function j(address i, uint256 l) external returns (bool) {\n        e[msg.sender][i] = l;\n        emit Approval(msg.sender, i, l);\n        return true;\n    }\n\n    function a(\n        address from,\n        address s,\n        uint256 l\n    ) external returns (bool) {\n        require(g[from] >= l, \"Insufficient balance\");\n        require(\n            e[from][msg.sender] >= l,\n            \"Insufficient allowance\"\n        );\n\n        g[from] -= l;\n        g[s] += l;\n        e[from][msg.sender] -= l;\n\n        emit Transfer(from, s, l);\n        return true;\n    }\n}",
      "rename_map": {
        "transferFrom": "a",
        "totalSupply": "b",
        "onlyMinter": "c",
        "newMinter": "d",
        "allowance": "e",
        "setMinter": "f",
        "balanceOf": "g",
        "decimals": "h",
        "spender": "i",
        "approve": "j",
        "account": "k",
        "amount": "l",
        "symbol": "m",
        "minter": "n",
        "owner": "o",
        "_mint": "p",
        "name": "q",
        "mint": "r",
        "to": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_048",
      "transformed_id": "ss_l2_short_nc_tc_048",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address z, uint256 s) external returns (bool);\n\n    function g(\n        address from,\n        address z,\n        uint256 s\n    ) external returns (bool);\n\n    function o(address r) external view returns (uint256);\n}\n\ncontract SonneMarket {\n    IERC20 public m;\n\n    string public w = \"Sonne WETH\";\n    string public u = \"soWETH\";\n    uint8 public q = 8;\n\n    uint256 public j;\n    mapping(address => uint256) public o;\n\n    uint256 public h;\n    uint256 public d;\n\n    event Mint(address v, uint256 n, uint256 l);\n    event Redeem(address p, uint256 i, uint256 f);\n\n    constructor(address k) {\n        m = IERC20(k);\n    }\n\n    function e() public view returns (uint256) {\n        if (j == 0) {\n            return 1e18;\n        }\n\n        uint256 x = m.o(address(this));\n\n        uint256 c = x + h - d;\n\n        return (c * 1e18) / j;\n    }\n\n    function y(uint256 n) external returns (uint256) {\n        require(n > 0, \"Zero mint\");\n\n        uint256 a = e();\n\n        uint256 l = (n * 1e18) / a;\n\n        j += l;\n        o[msg.sender] += l;\n\n        m.g(msg.sender, address(this), n);\n\n        emit Mint(msg.sender, n, l);\n        return l;\n    }\n\n    function t(uint256 f) external returns (uint256) {\n        require(o[msg.sender] >= f, \"Insufficient balance\");\n\n        uint256 a = e();\n\n        uint256 i = (f * a) / 1e18;\n\n        o[msg.sender] -= f;\n        j -= f;\n\n        m.transfer(msg.sender, i);\n\n        emit Redeem(msg.sender, i, f);\n        return i;\n    }\n\n    function b(\n        address r\n    ) external view returns (uint256) {\n        uint256 a = e();\n\n        return (o[r] * a) / 1e18;\n    }\n}",
      "rename_map": {
        "exchangeRateMantissa": "a",
        "balanceOfUnderlying": "b",
        "totalUnderlying": "c",
        "totalReserves": "d",
        "exchangeRate": "e",
        "redeemTokens": "f",
        "transferFrom": "g",
        "totalBorrows": "h",
        "redeemAmount": "i",
        "totalSupply": "j",
        "_underlying": "k",
        "mintTokens": "l",
        "underlying": "m",
        "mintAmount": "n",
        "balanceOf": "o",
        "redeemer": "p",
        "decimals": "q",
        "account": "r",
        "amount": "s",
        "redeem": "t",
        "symbol": "u",
        "minter": "v",
        "name": "w",
        "cash": "x",
        "mint": "y",
        "to": "z"
      },
      "changes": [
        "Renamed 26 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_049",
      "transformed_id": "ss_l2_short_nc_tc_049",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ae, uint256 y) external returns (bool);\n\n    function g(\n        address from,\n        address ae,\n        uint256 y\n    ) external returns (bool);\n\n    function n(address u) external view returns (uint256);\n}\n\ninterface IMarket {\n    function b(\n        address u\n    )\n        external\n        view\n        returns (uint256 j, uint256 s, uint256 f);\n}\n\ncontract DebtPreviewer {\n    function i(\n        address aa,\n        address u\n    )\n        external\n        view\n        returns (\n            uint256 c,\n            uint256 m,\n            uint256 h\n        )\n    {\n        (uint256 j, uint256 s, uint256 f) = IMarket(\n            aa\n        ).b(u);\n\n        c = (j * f) / 1e18;\n        m = s;\n\n        if (m == 0) {\n            h = type(uint256).ad;\n        } else {\n            h = (c * 1e18) / m;\n        }\n\n        return (c, m, h);\n    }\n\n    function a(\n        address[] calldata v,\n        address u\n    )\n        external\n        view\n        returns (\n            uint256 d,\n            uint256 l,\n            uint256 e\n        )\n    {\n        for (uint256 i = 0; i < v.length; i++) {\n            (uint256 j, uint256 ac, ) = this.i(\n                v[i],\n                u\n            );\n\n            d += j;\n            l += ac;\n        }\n\n        if (l == 0) {\n            e = type(uint256).ad;\n        } else {\n            e = (d * 1e18) / l;\n        }\n\n        return (d, l, e);\n    }\n}\n\ncontract ExactlyMarket {\n    IERC20 public ab;\n    DebtPreviewer public p;\n\n    mapping(address => uint256) public r;\n    mapping(address => uint256) public s;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(address x, address k) {\n        ab = IERC20(x);\n        p = DebtPreviewer(k);\n    }\n\n    function w(uint256 y) external {\n        ab.g(msg.sender, address(this), y);\n        r[msg.sender] += y;\n    }\n\n    function z(uint256 y, address[] calldata v) external {\n        (uint256 d, uint256 l, ) = p\n            .a(v, msg.sender);\n\n        uint256 t = l + y;\n\n        uint256 o = (d * COLLATERAL_FACTOR) / 100;\n        require(t <= o, \"Insufficient collateral\");\n\n        s[msg.sender] += y;\n        ab.transfer(msg.sender, y);\n    }\n\n    function b(\n        address u\n    )\n        external\n        view\n        returns (uint256 j, uint256 q, uint256 f)\n    {\n        return (r[u], s[u], 1e18);\n    }\n}",
      "rename_map": {
        "previewMultipleMarkets": "a",
        "getAccountSnapshot": "b",
        "collateralValue": "c",
        "totalCollateral": "d",
        "overallHealth": "e",
        "exchangeRate": "f",
        "transferFrom": "g",
        "healthFactor": "h",
        "previewDebt": "i",
        "collateral": "j",
        "_previewer": "k",
        "totalDebt": "l",
        "debtValue": "m",
        "balanceOf": "n",
        "maxBorrow": "o",
        "previewer": "p",
        "borrowed": "q",
        "deposits": "r",
        "borrows": "s",
        "newDebt": "t",
        "account": "u",
        "markets": "v",
        "deposit": "w",
        "_asset": "x",
        "amount": "y",
        "borrow": "z",
        "market": "aa",
        "asset": "ab",
        "debt": "ac",
        "max": "ad",
        "to": "ae"
      },
      "changes": [
        "Renamed 31 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_050",
      "transformed_id": "ss_l2_short_nc_tc_050",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ae, uint256 y) external returns (bool);\n\n    function k(\n        address from,\n        address ae,\n        uint256 y\n    ) external returns (bool);\n\n    function r(address w) external view returns (uint256);\n}\n\ncontract MunchablesLockManager {\n    address public aa;\n    address public i;\n\n    struct PlayerSettings {\n        uint256 n;\n        address h;\n        uint256 m;\n        uint256 j;\n    }\n\n    mapping(address => PlayerSettings) public e;\n    mapping(address => uint256) public d;\n\n    IERC20 public immutable ad;\n\n    event Locked(address z, uint256 y, address p);\n    event ConfigUpdated(address s, address o);\n\n    constructor(address ab) {\n        aa = msg.sender;\n        ad = IERC20(ab);\n    }\n\n    modifier q() {\n        require(msg.sender == aa, \"Not admin\");\n        _;\n    }\n\n    function ac(uint256 y, uint256 v) external {\n        require(y > 0, \"Zero amount\");\n\n        ad.k(msg.sender, address(this), y);\n\n        d[msg.sender] += y;\n        e[msg.sender] = PlayerSettings({\n            n: y,\n            h: msg.sender,\n            m: v,\n            j: block.timestamp\n        });\n\n        emit Locked(msg.sender, y, msg.sender);\n    }\n\n    function b(address f) external q {\n        address s = i;\n        i = f;\n\n        emit ConfigUpdated(s, f);\n    }\n\n    function a(\n        address z,\n        address l\n    ) external q {\n        e[z].h = l;\n    }\n\n    function x() external {\n        PlayerSettings memory u = e[msg.sender];\n\n        require(u.n > 0, \"No locked tokens\");\n        require(\n            block.timestamp >= u.j + u.m,\n            \"Still locked\"\n        );\n\n        uint256 y = u.n;\n\n        address p = u.h;\n\n        delete e[msg.sender];\n        d[msg.sender] = 0;\n\n        ad.transfer(p, y);\n    }\n\n    function c(address z) external q {\n        PlayerSettings memory u = e[z];\n        uint256 y = u.n;\n        address p = u.h;\n\n        delete e[z];\n        d[z] = 0;\n\n        ad.transfer(p, y);\n    }\n\n    function g(address t) external q {\n        aa = t;\n    }\n}",
      "rename_map": {
        "setLockRecipient": "a",
        "setConfigStorage": "b",
        "emergencyUnlock": "c",
        "playerBalances": "d",
        "playerSettings": "e",
        "_configStorage": "f",
        "transferAdmin": "g",
        "lockRecipient": "h",
        "configStorage": "i",
        "lockStartTime": "j",
        "transferFrom": "k",
        "newRecipient": "l",
        "lockDuration": "m",
        "lockedAmount": "n",
        "newConfig": "o",
        "recipient": "p",
        "onlyAdmin": "q",
        "balanceOf": "r",
        "oldConfig": "s",
        "newAdmin": "t",
        "settings": "u",
        "duration": "v",
        "account": "w",
        "unlock": "x",
        "amount": "y",
        "player": "z",
        "admin": "aa",
        "_weth": "ab",
        "lock": "ac",
        "weth": "ad",
        "to": "ae"
      },
      "changes": [
        "Renamed 31 identifiers using short style"
      ],
      "stats": {},
      "error": null
    }
  ]
}