{
  "timestamp": "2025-12-18T12:55:38.414357",
  "level": "l2",
  "variant": "short",
  "source": "nocomments",
  "total_files": 252,
  "successful": 248,
  "failed": 4,
  "results": [
    {
      "original_id": "nc_ds_001",
      "transformed_id": "ss_l2_short_nc_ds_001",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "contract h {\n        uint private Balance = 0;\n        uint private Payout_id = 0;\n        uint private Last_Payout = 0;\n        uint private WinningPot = 0;\n        uint private Min_multiplier = 1100;\n\n\n        uint private q = 0;\n        uint private e = 20;\n\n        uint private PotFrac = 30;\n\n        address private k;\n\n        function h() {\n            k = msg.sender;\n        }\n\n        modifier b {if (msg.sender == k) _;  }\n\n        struct Player {\n            address o;\n            uint g;\n            bool p;\n        }\n\n        Player[] private c;\n\n\n        function() {\n            m();\n        }\n\n\n        function m() private {\n            uint d=msg.value;\n            if (msg.value < 500 finney) {\n                    msg.sender.send(msg.value);\n                    return;\n            }\n            if (msg.value > 20 ether) {\n                    msg.sender.send(msg.value- (20 ether));\n                    d=20 ether;\n            }\n            Participate(d);\n        }\n\n\n        function Participate(uint d) private {\n\n\n                uint a=Min_multiplier;\n                if(Balance < 1 ether && c.length>1){\n                    a+=100;\n                }\n                if( (c.length % 10)==0 && c.length>1 ){\n                    a+=100;\n                }\n\n\n                c.push(Player(msg.sender, (d * a) / 1000, false));\n\n\n                WinningPot += (d * PotFrac) / 1000;\n                q += (d * e) / 1000;\n                Balance += (d * (1000 - ( e + PotFrac ))) / 1000;\n\n\n                if(  ( d > 1 ether ) && (d > c[Payout_id].g) ){\n                    uint r = f(100);\n                    if( r % 10 == 0 ){\n                        msg.sender.send(WinningPot);\n                        WinningPot=0;\n                    }\n\n                }\n\n\n                while ( Balance > c[Payout_id].g ) {\n                    Last_Payout = c[Payout_id].g;\n                    c[Payout_id].o.send(Last_Payout);\n                    Balance -= c[Payout_id].g;\n                    c[Payout_id].p=true;\n\n                    Payout_id += 1;\n                }\n        }\n\n    uint256 constant private l =  block.timestamp;\n\n    function f(uint Max) constant private returns (uint256 j){\n\n        uint256 x = l * 100 / Max;\n        uint256 y = l * block.number / (l % 5) ;\n        uint256 n = block.number/3 + (l % 300) + Last_Payout +y;\n        uint256 h = uint256(block.blockhash(n));\n\n        return uint256((h / x)) % Max + 1;\n    }\n\n\n    function ChangeOwnership(address i) b {\n        k = i;\n    }\n    function WatchBalance() constant returns(uint TotalBalance) {\n        TotalBalance = Balance /  1 wei;\n    }\n\n    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\n        TotalBalanceInEther = Balance /  1 ether;\n    }\n\n\n    function CollectAllFees() b {\n        if (q == 0) throw;\n        k.send(q);\n        e-=1;\n        q = 0;\n    }\n\n    function GetAndReduceFeesByFraction(uint p) b {\n        if (q == 0) e-=1;\n        k.send(q / 1000 * p);\n        q -= q / 1000 * p;\n    }\n\n\nfunction NextPayout() constant returns(uint NextPayout) {\n    NextPayout = c[Payout_id].g /  1 wei;\n}\n\nfunction WatchFees() constant returns(uint CollectedFees) {\n    CollectedFees = q / 1 wei;\n}\n\nfunction WatchWinningPot() constant returns(uint WinningPot) {\n    WinningPot = WinningPot / 1 wei;\n}\n\nfunction WatchLastPayout() constant returns(uint g) {\n    g = Last_Payout;\n}\n\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\n    NumberOfPlayers = c.length;\n}\n\nfunction PlayerInfo(uint s) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (s <= c.length) {\n        Address = c[s].o;\n        Payout = c[s].g / 1 wei;\n        UserPaid=c[s].p;\n    }\n}\n\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\n    QueueSize = c.length - Payout_id;\n}\n\n}",
      "rename_map": {
        "total_multiplier": "a",
        "onlyowner": "b",
        "players": "c",
        "deposit": "d",
        "feeFrac": "e",
        "random": "f",
        "payout": "g",
        "theRun": "h",
        "_owner": "i",
        "result": "j",
        "admin": "k",
        "salt": "l",
        "init": "m",
        "seed": "n",
        "addr": "o",
        "paid": "p",
        "fees": "q",
        "roll": "r",
        "id": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_002",
      "transformed_id": "ss_l2_short_nc_ds_002",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract TokenVault {\n    mapping (address => uint) e;\n\n    function f(address u) constant returns(uint){\n        return e[u];\n    }\n\n    function d() payable{\n        e[msg.sender] += msg.value;\n    }\n\n    function c(){\n\n\n        if( ! (msg.sender.call.value(e[msg.sender])() ) ){\n            throw;\n        }\n        e[msg.sender] = 0;\n    }\n\n    function b(){\n\n\n        uint g = e[msg.sender];\n        e[msg.sender] = 0;\n        if( ! (msg.sender.call.value(g)() ) ){\n            throw;\n        }\n    }\n\n    function a(){\n\n\n        msg.sender.transfer(e[msg.sender]);\n        e[msg.sender] = 0;\n    }\n\n}",
      "rename_map": {
        "withdrawBalanceV3": "a",
        "withdrawBalanceV2": "b",
        "withdrawBalance": "c",
        "addToBalance": "d",
        "userBalance": "e",
        "getBalance": "f",
        "amount": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_003",
      "transformed_id": "ss_l2_short_nc_ds_003",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract VaultOperator {\n    bool public c=false;\n    address public b;\n    address public g;\n\n    function VaultOperator() public{\n        g = msg.sender;\n    }\n\n    function f(address a) public payable{\n        b = a ;\n\n        require(b.call.value(msg.value)(bytes4(h(\"addToBalance()\"))));\n    }\n\n    function d() public{\n        c = true;\n\n\n        require(b.call(bytes4(h(\"withdrawBalance()\"))));\n    }\n\n    function () public payable{\n\n        if (c){\n            c = false;\n                require(b.call(bytes4(h(\"withdrawBalance()\"))));\n        }\n    }\n\n    function e(){\n        suicide(g);\n    }\n\n}",
      "rename_map": {
        "_target_contract": "a",
        "target_contract": "b",
        "operationActive": "c",
        "launch_handler": "d",
        "get_money": "e",
        "deposit": "f",
        "owner": "g",
        "sha3": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_004",
      "transformed_id": "ss_l2_short_nc_ds_004",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Ledger {\n    uint private a=0;\n\n    function c(uint value) returns (bool){\n        a += value;\n\n\n    }\n\n    function b(uint value) returns (bool){\n        require(value + a >= a);\n        a += value;\n    }\n}",
      "rename_map": {
        "sellerBalance": "a",
        "safe_add": "b",
        "add": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_005",
      "transformed_id": "ss_l2_short_nc_ds_005",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract OpenAccess{\n    address private e;\n\n    modifier d {\n        require(msg.sender==e);\n        _;\n    }\n\n    function OpenAccess()\n        public\n    {\n        e = msg.sender;\n    }\n\n\n    function b(address c)\n        public\n    {\n       e = c;\n    }\n\n    function a(address c)\n        public\n        d\n    {\n       e = c;\n    }\n}",
      "rename_map": {
        "changeOwnerV2": "a",
        "changeOwner": "b",
        "_newOwner": "c",
        "onlyowner": "d",
        "owner": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_006",
      "transformed_id": "ss_l2_short_nc_ds_006",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Alice {\n    int public d;\n\n    function c(int a){\n        d = a;\n    }\n\n    function b(int a){\n        d = a;\n    }\n\n    function(){\n        d = 1;\n    }\n}",
      "rename_map": {
        "new_val": "a",
        "setV2": "b",
        "set": "c",
        "val": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_007",
      "transformed_id": "ss_l2_short_nc_ds_007",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.22;\n\ncontract FibonacciBalance {\n\n    address public fibonacciLibrary;\n\n    uint public a;\n\n    uint public i = 3;\n    uint public b;\n\n    bytes4 constant g = bytes4(j(\"setFibonacci(uint256)\"));\n\n\n    constructor(address _fibonacciLibrary) public payable {\n        fibonacciLibrary = _fibonacciLibrary;\n    }\n\n    function f() {\n        b += 1;\n\n\n        require(fibonacciLibrary.delegatecall(g, b));\n        msg.sender.transfer(a * 1 ether);\n    }\n\n\n    function() public {\n        require(fibonacciLibrary.delegatecall(msg.data));\n    }\n}\n\n\ncontract FibonacciLib {\n\n    uint public i;\n    uint public a;\n\n\n    function e(uint h) public {\n        i = h;\n    }\n\n    function c(uint n) public {\n        a = d(n);\n    }\n\n    function d(uint n) internal returns (uint) {\n        if (n == 0) return i;\n        else if (n == 1) return i + 1;\n        else return d(n - 1) + d(n - 2);\n    }\n}",
      "rename_map": {
        "calculatedFibNumber": "a",
        "withdrawalCounter": "b",
        "setFibonacci": "c",
        "fibonacci": "d",
        "setStart": "e",
        "withdraw": "f",
        "fibSig": "g",
        "_start": "h",
        "start": "i",
        "sha3": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_008",
      "transformed_id": "ss_l2_short_nc_ds_008",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\n contract Wallet {\n     uint[] private a;\n     address private b;\n\n     constructor() public {\n         a = new uint[](0);\n         b = msg.sender;\n     }\n\n     function () public payable {\n     }\n\n     function PushBonusCode(uint c) public {\n         a.push(c);\n     }\n\n     function PopBonusCode() public {\n         require(0 <= a.length);\n         a.length--;\n     }\n\n     function UpdateBonusCodeAt(uint c, uint c) public {\n         require(c < a.length);\n         a[c] = c;\n     }\n\n     function Destroy() public {\n         require(msg.sender == b);\n         selfdestruct(msg.sender);\n     }\n }",
      "rename_map": {
        "bonusCodes": "a",
        "owner": "b",
        "idx": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_009",
      "transformed_id": "ss_l2_short_nc_ds_009",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Map {\n     address public b;\n     uint256[] c;\n\n     function e(uint256 f, uint256 value) public {\n         if (c.length <= f) {\n             c.length = f + 1;\n         }\n         c[f] = value;\n     }\n\n     function d(uint256 f) public view returns (uint256) {\n         return c[f];\n     }\n     function a() public{\n       require(msg.sender == b);\n       msg.sender.transfer(address(this).balance);\n     }\n }",
      "rename_map": {
        "withdraw": "a",
        "owner": "b",
        "map": "c",
        "get": "d",
        "set": "e",
        "key": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_010",
      "transformed_id": "ss_l2_short_nc_ds_010",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract MyContract {\n\n    address d;\n\n    function MyContract() public {\n        d = msg.sender;\n    }\n\n    function c(address a, uint b) public {\n        require(tx.origin == d);\n        a.transfer(b);\n    }\n\n}",
      "rename_map": {
        "receiver": "a",
        "amount": "b",
        "sendTo": "c",
        "owner": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_011",
      "transformed_id": "ss_l2_short_nc_ds_011",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.22;\n\n contract Phishable {\n    address public d;\n\n    constructor (address c) {\n        d = c;\n    }\n\n    function () public payable {}\n\n    function a(address b) public {\n        require(tx.origin == d);\n        b.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "withdrawAll": "a",
        "_recipient": "b",
        "_owner": "c",
        "owner": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_012",
      "transformed_id": "ss_l2_short_nc_ds_012",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Proxy {\n\n  address c;\n\n  constructor() public {\n    c = msg.sender;\n  }\n\n  function a(address b, bytes d) public {\n    require(b.delegatecall(d));\n  }\n\n}",
      "rename_map": {
        "forward": "a",
        "callee": "b",
        "owner": "c",
        "_data": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_013",
      "transformed_id": "ss_l2_short_nc_ds_013",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract SimpleDestruct {\n  function a() {\n    selfdestruct(msg.sender);\n  }\n\n}",
      "rename_map": {
        "sudicideAnyone": "a"
      },
      "changes": [
        "Renamed 1 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_014",
      "transformed_id": "ss_l2_short_nc_ds_014",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Wallet {\n     address e;\n\n     mapping(address => uint256) b;\n\n     constructor() public {\n         e = msg.sender;\n     }\n\n     function d() public payable {\n         assert(b[msg.sender] + msg.value > b[msg.sender]);\n         b[msg.sender] += msg.value;\n     }\n\n     function c(uint256 f) public {\n         require(f <= b[msg.sender]);\n         msg.sender.transfer(f);\n         b[msg.sender] -= f;\n     }\n\n     function g() public {\n         msg.sender.transfer(b[msg.sender]);\n     }\n\n\n     function a(address h) public {\n         require(e == msg.sender);\n         h.transfer(this.balance);\n     }\n\n }",
      "rename_map": {
        "migrateTo": "a",
        "balances": "b",
        "withdraw": "c",
        "deposit": "d",
        "creator": "e",
        "amount": "f",
        "refund": "g",
        "to": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_015",
      "transformed_id": "ss_l2_short_nc_ds_015",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Wallet {\n     address f;\n\n     mapping(address => uint256) c;\n\n     function a() public {\n         f = msg.sender;\n     }\n\n     function e() public payable {\n         assert(c[msg.sender] + msg.value > c[msg.sender]);\n         c[msg.sender] += msg.value;\n     }\n\n     function d(uint256 g) public {\n         require(g <= c[msg.sender]);\n         msg.sender.transfer(g);\n         c[msg.sender] -= g;\n     }\n\n\n     function b(address h) public {\n         require(f == msg.sender);\n         h.transfer(this.balance);\n     }\n\n }",
      "rename_map": {
        "initWallet": "a",
        "migrateTo": "b",
        "balances": "c",
        "withdraw": "d",
        "deposit": "e",
        "creator": "f",
        "amount": "g",
        "to": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_016",
      "transformed_id": "ss_l2_short_nc_ds_016",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n contract Wallet {\n     address e;\n\n     mapping(address => uint256) b;\n\n     constructor() public {\n         e = msg.sender;\n     }\n\n     function d() public payable {\n         assert(b[msg.sender] + msg.value > b[msg.sender]);\n         b[msg.sender] += msg.value;\n     }\n\n     function c(uint256 f) public {\n         require(f >= b[msg.sender]);\n         msg.sender.transfer(f);\n         b[msg.sender] -= f;\n     }\n\n\n     function a(address g) public {\n         require(e == msg.sender);\n         g.transfer(this.balance);\n     }\n\n }",
      "rename_map": {
        "migrateTo": "a",
        "balances": "b",
        "withdraw": "c",
        "deposit": "d",
        "creator": "e",
        "amount": "f",
        "to": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_017",
      "transformed_id": "ss_l2_short_nc_ds_017",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PERSONAL_BANK\n{\n    mapping (address=>uint256) public b;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool a;\n\n    function SetMinSum(uint f)\n    public\n    {\n        if(a)revert();\n        MinSum = f;\n    }\n\n    function SetLogFile(address d)\n    public\n    {\n        if(a)revert();\n        Log = LogFile(d);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint g)\n    public\n    payable\n    {\n        if(b[msg.sender]>=MinSum && b[msg.sender]>=g)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                Log.AddMessage(msg.sender,g,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address e,uint f,string c)\n    public\n    {\n        LastMsg.Sender = e;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "balances": "b",
        "_data": "c",
        "_log": "d",
        "_adr": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_018",
      "transformed_id": "ss_l2_short_nc_ds_018",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address c)\n    {\n        TransferLog = Log(c);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    {\n        if(f<=a[msg.sender])\n        {\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string b)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_log": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_019",
      "transformed_id": "ss_l2_short_nc_ds_019",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ACCURAL_DEPOSIT\n{\n    mapping (address=>uint256) public b;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool a;\n\n    function SetMinSum(uint f)\n    public\n    {\n        if(a)revert();\n        MinSum = f;\n    }\n\n    function SetLogFile(address d)\n    public\n    {\n        if(a)revert();\n        Log = LogFile(d);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint g)\n    public\n    payable\n    {\n        if(b[msg.sender]>=MinSum && b[msg.sender]>=g)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                Log.AddMessage(msg.sender,g,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address e,uint f,string c)\n    public\n    {\n        LastMsg.Sender = e;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "balances": "b",
        "_data": "c",
        "_log": "d",
        "_adr": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_020",
      "transformed_id": "ss_l2_short_nc_ds_020",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PRIVATE_ETH_CELL\n{\n    mapping (address=>uint256) public b;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool a;\n\n    function SetMinSum(uint f)\n    public\n    {\n        require(!a);\n        MinSum = f;\n    }\n\n    function SetLogFile(address d)\n    public\n    {\n        require(!a);\n        Log = LogFile(d);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint g)\n    public\n    payable\n    {\n        if(b[msg.sender]>=MinSum && b[msg.sender]>=g)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                Log.AddMessage(msg.sender,g,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address e,uint f,string c)\n    public\n    {\n        LastMsg.Sender = e;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "balances": "b",
        "_data": "c",
        "_log": "d",
        "_adr": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_021",
      "transformed_id": "ss_l2_short_nc_ds_021",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract BANK_SAFE\n{\n    mapping (address=>uint256) public b;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool a;\n\n    function SetMinSum(uint f)\n    public\n    {\n        if(a)throw;\n        MinSum = f;\n    }\n\n    function SetLogFile(address d)\n    public\n    {\n        if(a)throw;\n        Log = LogFile(d);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint g)\n    public\n    payable\n    {\n        if(b[msg.sender]>=MinSum && b[msg.sender]>=g)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                Log.AddMessage(msg.sender,g,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address e,uint f,string c)\n    public\n    {\n        LastMsg.Sender = e;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "balances": "b",
        "_data": "c",
        "_log": "d",
        "_adr": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_022",
      "transformed_id": "ss_l2_short_nc_ds_022",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address e;\n    address k = msg.sender;\n\n    function c(address m)\n    public\n    d\n    {\n        e = m;\n    }\n\n    function b()\n    public\n    {\n        if(msg.sender==e)\n        {\n            k=e;\n        }\n    }\n\n    modifier d\n    {\n        if(k == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address k = msg.sender;\n    function WithdrawToken(address j, uint256 g,address p)\n    public\n    d\n    {\n        j.call(bytes4(n(\"transfer(address,uint256)\")),p,g);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function a()\n    public\n    {\n        k = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address o,address h,uint f)\n    public\n    d\n    {\n        if(Holders[o]>0)\n        {\n            Holders[o]=0;\n            WithdrawToken(h,f,o);\n        }\n    }\n\n    function WithdrawToHolder(address i, uint l)\n    public\n    d\n    payable\n    {\n        if(Holders[i]>0)\n        {\n            if(i.call.value(l)())\n            {\n                Holders[i]-=l;\n            }\n        }\n    }\n}",
      "rename_map": {
        "initTokenBank": "a",
        "confirmOwner": "b",
        "changeOwner": "c",
        "onlyOwner": "d",
        "newOwner": "e",
        "_amount": "f",
        "amount": "g",
        "_token": "h",
        "_addr": "i",
        "token": "j",
        "owner": "k",
        "_wei": "l",
        "addr": "m",
        "sha3": "n",
        "_to": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_023",
      "transformed_id": "ss_l2_short_nc_ds_023",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract U_BANK\n{\n    function Put(uint a)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        h.balance += msg.value;\n        h.b = a>i?a:i;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint f)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        if( h.balance>=MinSum && h.balance>=f && i>h.b)\n        {\n            if(msg.sender.call.value(f)())\n            {\n                h.balance-=f;\n                LogFile.AddMessage(msg.sender,f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 2 ether;\n\n    function U_BANK(address g) public{\n        LogFile = Log(g);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = i;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "a",
        "unlockTime": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "log": "g",
        "acc": "h",
        "now": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_024",
      "transformed_id": "ss_l2_short_nc_ds_024",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PrivateDeposit\n{\n    mapping (address => uint) public b;\n\n    uint public MinDeposit = 1 ether;\n    address public e;\n\n    Log TransferLog;\n\n    modifier a() {\n        require(tx.origin == e);\n        _;\n    }\n\n    function PrivateDeposit()\n    {\n        e = msg.sender;\n        TransferLog = new Log();\n    }\n\n    function c(address f) a\n    {\n        TransferLog = Log(f);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            b[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint i)\n    {\n        if(i<=b[msg.sender])\n        {\n            if(msg.sender.call.value(i)())\n            {\n                b[msg.sender]-=i;\n                TransferLog.AddMessage(msg.sender,i,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address g,uint h,string d)\n    public\n    {\n        LastMsg.Sender = g;\n        LastMsg.Time = j;\n        LastMsg.Val = h;\n        LastMsg.Data = d;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "onlyOwner": "a",
        "balances": "b",
        "setLog": "c",
        "_data": "d",
        "owner": "e",
        "_lib": "f",
        "_adr": "g",
        "_val": "h",
        "_am": "i",
        "now": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_025",
      "transformed_id": "ss_l2_short_nc_ds_025",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract W_WALLET\n{\n    function Put(uint a)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        h.balance += msg.value;\n        h.b = a>i?a:i;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint f)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        if( h.balance>=MinSum && h.balance>=f && i>h.b)\n        {\n            if(msg.sender.call.value(f)())\n            {\n                h.balance-=f;\n                LogFile.AddMessage(msg.sender,f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function W_WALLET(address g) public{\n        LogFile = Log(g);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = i;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "a",
        "unlockTime": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "log": "g",
        "acc": "h",
        "now": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_026",
      "transformed_id": "ss_l2_short_nc_ds_026",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public a;\n\n    Log TransferLog;\n\n    uint public MinDeposit = 1 ether;\n\n    function ETH_VAULT(address c)\n    public\n    {\n        TransferLog = Log(c);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    public\n    payable\n    {\n        if(f<=a[msg.sender])\n        {\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string b)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_log": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_027",
      "transformed_id": "ss_l2_short_nc_ds_027",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract X_WALLET\n{\n    function Put(uint a)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        h.balance += msg.value;\n        h.b = a>i?a:i;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint f)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        if( h.balance>=MinSum && h.balance>=f && i>h.b)\n        {\n            if(msg.sender.call.value(f)())\n            {\n                h.balance-=f;\n                LogFile.AddMessage(msg.sender,f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function X_WALLET(address g) public{\n        LogFile = Log(g);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = i;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "a",
        "unlockTime": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "log": "g",
        "acc": "h",
        "now": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_028",
      "transformed_id": "ss_l2_short_nc_ds_028",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ETH_FUND\n{\n    mapping (address => uint) public b;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    uint a;\n\n    function ETH_FUND(address f)\n    public\n    {\n        TransferLog = Log(f);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            b[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            a = block.number;\n        }\n    }\n\n    function CashOut(uint g)\n    public\n    payable\n    {\n        if(g<=b[msg.sender]&&block.number>a)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                TransferLog.AddMessage(msg.sender,g,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = h;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "lastBlock": "a",
        "balances": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_log": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_029",
      "transformed_id": "ss_l2_short_nc_ds_029",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PENNY_BY_PENNY\n{\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool a;\n\n    function SetMinSum(uint g)\n    public\n    {\n        if(a)throw;\n        MinSum = g;\n    }\n\n    function SetLogFile(address e)\n    public\n    {\n        if(a)throw;\n        Log = LogFile(e);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Put(uint c)\n    public\n    payable\n    {\n        var i = Acc[msg.sender];\n        i.balance += msg.value;\n        if(j+c>i.b)i.b=j+c;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint h)\n    public\n    payable\n    {\n        var i = Acc[msg.sender];\n        if( i.balance>=MinSum && i.balance>=h && j>i.b)\n        {\n            if(msg.sender.call.value(h)())\n            {\n                i.balance-=h;\n                Log.AddMessage(msg.sender,h,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address f,uint g,string d)\n    public\n    {\n        LastMsg.Sender = f;\n        LastMsg.Time = j;\n        LastMsg.Val = g;\n        LastMsg.Data = d;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "unlockTime": "b",
        "_lockTime": "c",
        "_data": "d",
        "_log": "e",
        "_adr": "f",
        "_val": "g",
        "_am": "h",
        "acc": "i",
        "now": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_030",
      "transformed_id": "ss_l2_short_nc_ds_030",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract DEP_BANK\n{\n    mapping (address=>uint256) public b;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool a;\n\n    function SetMinSum(uint f)\n    public\n    {\n        if(a)throw;\n        MinSum = f;\n    }\n\n    function SetLogFile(address d)\n    public\n    {\n        if(a)throw;\n        Log = LogFile(d);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint g)\n    public\n    payable\n    {\n        if(b[msg.sender]>=MinSum && b[msg.sender]>=g)\n        {\n            if(msg.sender.call.value(g)())\n            {\n                b[msg.sender]-=g;\n                Log.AddMessage(msg.sender,g,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address e,uint f,string c)\n    public\n    {\n        LastMsg.Sender = e;\n        LastMsg.Time = h;\n        LastMsg.Val = f;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "balances": "b",
        "_data": "c",
        "_log": "d",
        "_adr": "e",
        "_val": "f",
        "_am": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_031",
      "transformed_id": "ss_l2_short_nc_ds_031",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address c)\n    {\n        TransferLog = Log(c);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    public\n    payable\n    {\n        if(f<=a[msg.sender])\n        {\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string b)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_log": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_032",
      "transformed_id": "ss_l2_short_nc_ds_032",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address c)\n    {\n        TransferLog = Log(c);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    {\n        if(f<=a[msg.sender])\n        {\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string b)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_lib": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_033",
      "transformed_id": "ss_l2_short_nc_ds_033",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function ETH_VAULT(address c)\n    public\n    {\n        TransferLog = Log(c);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    public\n    payable\n    {\n        if(f<=a[msg.sender])\n        {\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string b)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_log": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_034",
      "transformed_id": "ss_l2_short_nc_ds_034",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract MONEY_BOX\n{\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    Log LogFile;\n\n    bool a;\n\n    function SetMinSum(uint g)\n    public\n    {\n        if(a)throw;\n        MinSum = g;\n    }\n\n    function SetLogFile(address e)\n    public\n    {\n        if(a)throw;\n        LogFile = Log(e);\n    }\n\n    function Initialized()\n    public\n    {\n        a = true;\n    }\n\n    function Put(uint c)\n    public\n    payable\n    {\n        var i = Acc[msg.sender];\n        i.balance += msg.value;\n        if(j+c>i.b)i.b=j+c;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint h)\n    public\n    payable\n    {\n        var i = Acc[msg.sender];\n        if( i.balance>=MinSum && i.balance>=h && j>i.b)\n        {\n            if(msg.sender.call.value(h)())\n            {\n                i.balance-=h;\n                LogFile.AddMessage(msg.sender,h,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address f,uint g,string d)\n    public\n    {\n        LastMsg.Sender = f;\n        LastMsg.Time = j;\n        LastMsg.Val = g;\n        LastMsg.Data = d;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "a",
        "unlockTime": "b",
        "_lockTime": "c",
        "_data": "d",
        "_log": "e",
        "_adr": "f",
        "_val": "g",
        "_am": "h",
        "acc": "i",
        "now": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_035",
      "transformed_id": "ss_l2_short_nc_ds_035",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract WALLET\n{\n    function Put(uint a)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        h.balance += msg.value;\n        h.b = a>i?a:i;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint f)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        if( h.balance>=MinSum && h.balance>=f && i>h.b)\n        {\n            if(msg.sender.call.value(f)())\n            {\n                h.balance-=f;\n                LogFile.AddMessage(msg.sender,f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function WALLET(address g) public{\n        LogFile = Log(g);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = i;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "a",
        "unlockTime": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "log": "g",
        "acc": "h",
        "now": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_036",
      "transformed_id": "ss_l2_short_nc_ds_036",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract MY_BANK\n{\n    function Put(uint a)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        h.balance += msg.value;\n        h.b = a>i?a:i;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint f)\n    public\n    payable\n    {\n        var h = Acc[msg.sender];\n        if( h.balance>=MinSum && h.balance>=f && i>h.b)\n        {\n            if(msg.sender.call.value(f)())\n            {\n                h.balance-=f;\n                LogFile.AddMessage(msg.sender,f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint b;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function MY_BANK(address g) public{\n        LogFile = Log(g);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string c)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = i;\n        LastMsg.Val = e;\n        LastMsg.Data = c;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "a",
        "unlockTime": "b",
        "_data": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "log": "g",
        "acc": "h",
        "now": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_037",
      "transformed_id": "ss_l2_short_nc_ds_037",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract EtherBank{\n    mapping (address => uint) d;\n    function e(address f) constant returns(uint) {\n\t\treturn d[f];\n\t}\n\n\tfunction c() {\n\t\td[msg.sender] += msg.value;\n\t}\n\n\tfunction b() {\n\t\tuint a = d[msg.sender];\n\t\tif (!(msg.sender.call.value(a)())) { throw; }\n\t\td[msg.sender] = 0;\n\t}\n}",
      "rename_map": {
        "amountToWithdraw": "a",
        "withdrawBalance": "b",
        "addToBalance": "c",
        "userBalances": "d",
        "getBalance": "e",
        "user": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_038",
      "transformed_id": "ss_l2_short_nc_ds_038",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\ncontract EtherStore {\n\n    uint256 public b = 1 ether;\n    mapping(address => uint256) public a;\n    mapping(address => uint256) public f;\n\n    function e() public payable {\n        f[msg.sender] += msg.value;\n    }\n\n    function d (uint256 c) public {\n        require(f[msg.sender] >= c);\n\n        require(c <= b);\n\n        require(g >= a[msg.sender] + 1 weeks);\n        require(msg.sender.call.value(c)());\n        f[msg.sender] -= c;\n        a[msg.sender] = g;\n    }\n }",
      "rename_map": {
        "lastWithdrawTime": "a",
        "withdrawalLimit": "b",
        "_weiToWithdraw": "c",
        "withdrawFunds": "d",
        "depositFunds": "e",
        "balances": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_039",
      "transformed_id": "ss_l2_short_nc_ds_039",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract ModifierBank {\n  mapping (address => uint) public e;\n  string constant j = \"Nu Token\";\n\n\n  function h() d b  public{\n    e[msg.sender] += 20;\n  }\n\n\n  modifier b() {\n    require(f(abi.c(\"Nu Token\")) == Bank(msg.sender).b());\n    _;\n  }\n\n  modifier d {\n      require(e[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n    function b() external pure returns(bytes32){\n        return(f(abi.c(\"Nu Token\")));\n    }\n}\n\ncontract g {\n    bool a;\n    function b() external returns(bytes32){\n        if(!a){\n            a = true;\n            ModifierBank(msg.sender).h();\n        }\n        return(f(abi.c(\"Nu Token\")));\n    }\n    function call(address i) public{\n        ModifierBank(i).h();\n    }\n}",
      "rename_map": {
        "hasBeenCalled": "a",
        "supportsToken": "b",
        "encodePacked": "c",
        "hasNoBalance": "d",
        "tokenBalance": "e",
        "keccak256": "f",
        "executor": "g",
        "airDrop": "h",
        "token": "i",
        "name": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_040",
      "transformed_id": "ss_l2_short_nc_ds_040",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract TokenVault {\n\n  mapping(address => uint) public b;\n\n  function e(address g) public payable {\n    b[g] += msg.value;\n  }\n\n  function a(address f) public view returns (uint balance) {\n    return b[f];\n  }\n\n  function c(uint d) public {\n    if(b[msg.sender] >= d) {\n      if(msg.sender.call.value(d)()) {\n        d;\n      }\n      b[msg.sender] -= d;\n    }\n  }\n\n  function() public payable {}\n}",
      "rename_map": {
        "balanceOf": "a",
        "balances": "b",
        "withdraw": "c",
        "_amount": "d",
        "donate": "e",
        "_who": "f",
        "_to": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_041",
      "transformed_id": "ss_l2_short_nc_ds_041",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract BonusVault{\n\n    mapping (address => uint) private e;\n    mapping (address => bool) private d;\n    mapping (address => uint) private f;\n\n    function c(address g) public {\n        uint b = f[g];\n        f[g] = 0;\n        (bool h, ) = g.call.value(b)(\"\");\n        require(h);\n    }\n\n    function a(address g) public {\n        require(!d[g]);\n\n        f[g] += 100;\n        c(g);\n        d[g] = true;\n    }\n}",
      "rename_map": {
        "getFirstWithdrawalBonus": "a",
        "amountToWithdraw": "b",
        "withdrawReward": "c",
        "claimedBonus": "d",
        "userBalances": "e",
        "rewardsForA": "f",
        "recipient": "g",
        "success": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_042",
      "transformed_id": "ss_l2_short_nc_ds_042",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract CrossFunctionVault {\n\n    mapping (address => uint) private c;\n\n    function transfer(address f, uint e) {\n        if (c[msg.sender] >= e) {\n            c[f] += e;\n            c[msg.sender] -= e;\n        }\n    }\n\n    function b() public {\n        uint a = c[msg.sender];\n        (bool d, ) = msg.sender.call.value(a)(\"\");\n        require(d);\n        c[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "amountToWithdraw": "a",
        "withdrawBalance": "b",
        "userBalances": "c",
        "success": "d",
        "amount": "e",
        "to": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_043",
      "transformed_id": "ss_l2_short_nc_ds_043",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract CommunityVault {\n    mapping (address => uint) e;\n    uint balance;\n\n    function a() public {\n        uint c = e[msg.sender];\n        if (c > 0) {\n            balance -= c;\n            bool b = msg.sender.call.value(c)();\n            require (b);\n            e[msg.sender] = 0;\n        }\n    }\n\n    function d() public payable {\n        e[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n}",
      "rename_map": {
        "withdrawAll": "a",
        "callResult": "b",
        "oCredit": "c",
        "deposit": "d",
        "credit": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_044",
      "transformed_id": "ss_l2_short_nc_ds_044",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.5.0;\n\ncontract SimpleVault {\n\n    mapping (address => uint) private c;\n\n    function b() public {\n        uint a = c[msg.sender];\n        (bool d, ) = msg.sender.call.value(a)(\"\");\n        require(d);\n        c[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "amountToWithdraw": "a",
        "withdrawBalance": "b",
        "userBalances": "c",
        "success": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_045",
      "transformed_id": "ss_l2_short_nc_ds_045",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n contract TokenVault {\n     mapping (address => uint) c;\n\n     function d(address u) constant returns(uint){\n         return c[u];\n     }\n\n     function b() payable{\n         c[msg.sender] += msg.value;\n     }\n\n     function a(){\n\n\n         if( ! (msg.sender.call.value(c[msg.sender])() ) ){\n             throw;\n         }\n         c[msg.sender] = 0;\n     }\n }",
      "rename_map": {
        "withdrawBalance": "a",
        "addToBalance": "b",
        "userBalance": "c",
        "getBalance": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_046",
      "transformed_id": "ss_l2_short_nc_ds_046",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.2;\n\ncontract SimpleDAO {\n  mapping (address => uint) public e;\n\n  function d(address g) payable {\n    e[g] += msg.value;\n  }\n\n  function b(uint c) {\n    if (e[msg.sender]>= c) {\n      bool f = msg.sender.call.value(c)();\n      e[msg.sender]-=c;\n    }\n  }\n\n  function a(address g) returns (uint){\n    return e[g];\n  }\n}",
      "rename_map": {
        "queryCredit": "a",
        "withdraw": "b",
        "amount": "c",
        "donate": "d",
        "credit": "e",
        "res": "f",
        "to": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_047",
      "transformed_id": "ss_l2_short_nc_ds_047",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\ncontract Caller {\n    function a(address a) {\n        a.call();\n    }\n}",
      "rename_map": {
        "callAddress": "a"
      },
      "changes": [
        "Renamed 1 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_048",
      "transformed_id": "ss_l2_short_nc_ds_048",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\ncontract d{\n    function transfer(address from,address b,address[] c,uint[] v)public returns (bool){\n        require(c.length > 0);\n        bytes4 e=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<c.length;i++){\n            b.call(e,from,c[i],v[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "_tos": "c",
        "demo": "d",
        "id": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_049",
      "transformed_id": "ss_l2_short_nc_ds_049",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address e;\n    address k = msg.sender;\n\n    function c(address m)\n    public\n    d\n    {\n        e = m;\n    }\n\n    function b()\n    public\n    {\n        if(msg.sender==e)\n        {\n            k=e;\n        }\n    }\n\n    modifier d\n    {\n        if(k == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address k = msg.sender;\n    function WithdrawToken(address j, uint256 g,address p)\n    public\n    d\n    {\n        j.call(bytes4(n(\"transfer(address,uint256)\")),p,g);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function a()\n    public\n    {\n        k = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address o,address h,uint f)\n    public\n    d\n    {\n        if(Holders[o]>0)\n        {\n            Holders[o]=0;\n            WithdrawToken(h,f,o);\n        }\n    }\n\n    function WithdrawToHolder(address i, uint l)\n    public\n    d\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[i]>=l)\n            {\n                i.call.value(l);\n                Holders[i]-=l;\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "initTokenBank": "a",
        "confirmOwner": "b",
        "changeOwner": "c",
        "onlyOwner": "d",
        "newOwner": "e",
        "_amount": "f",
        "amount": "g",
        "_token": "h",
        "_addr": "i",
        "token": "j",
        "owner": "k",
        "_wei": "l",
        "addr": "m",
        "sha3": "n",
        "_to": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_050",
      "transformed_id": "ss_l2_short_nc_ds_050",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address e;\n    address k = msg.sender;\n\n    function c(address m)\n    public\n    d\n    {\n        e = m;\n    }\n\n    function b()\n    public\n    {\n        if(msg.sender==e)\n        {\n            k=e;\n        }\n    }\n\n    modifier d\n    {\n        if(k == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address k = msg.sender;\n    function WithdrawToken(address j, uint256 g,address p)\n    public\n    d\n    {\n        j.call(bytes4(n(\"transfer(address,uint256)\")),p,g);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function a()\n    public\n    {\n        k = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address o,address h,uint f)\n    public\n    d\n    {\n        if(Holders[o]>0)\n        {\n            Holders[o]=0;\n            WithdrawToken(h,f,o);\n        }\n    }\n\n    function WithdrawToHolder(address i, uint l)\n    public\n    d\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[i]>=l)\n            {\n                i.call.value(l);\n                Holders[i]-=l;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {
        "initTokenBank": "a",
        "confirmOwner": "b",
        "changeOwner": "c",
        "onlyOwner": "d",
        "newOwner": "e",
        "_amount": "f",
        "amount": "g",
        "_token": "h",
        "_addr": "i",
        "token": "j",
        "owner": "k",
        "_wei": "l",
        "addr": "m",
        "sha3": "n",
        "_to": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_051",
      "transformed_id": "ss_l2_short_nc_ds_051",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract MultiplicatorX4\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function b()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address c,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        c.call.value(msg.value)(data);\n    }\n\n    function a(address c)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            c.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "a",
        "withdraw": "b",
        "adr": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_052",
      "transformed_id": "ss_l2_short_nc_ds_052",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n    uint constant public a = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function c()\n    public\n    payable\n    {\n        if(msg.value>=a)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function b()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address d,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        d.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "minEligibility": "a",
        "withdraw": "b",
        "redeem": "c",
        "adr": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_053",
      "transformed_id": "ss_l2_short_nc_ds_053",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract c{\n\n    function transfer(address from,address b,address[] d,uint v)public returns (bool){\n        require(d.length > 0);\n        bytes4 e=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<d.length;i++){\n            b.call(e,from,d[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "airdrop": "c",
        "_tos": "d",
        "id": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_054",
      "transformed_id": "ss_l2_short_nc_ds_054",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract EBU{\n    address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;\n    address public b = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;\n\n    function transfer(address[] c,uint[] v)public returns (bool){\n        require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\n        require(c.length > 0);\n        bytes4 d=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<c.length;i++){\n            b.call(d,from,c[i],v[i]*1000000000000000000);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "_tos": "c",
        "id": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_055",
      "transformed_id": "ss_l2_short_nc_ds_055",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract c{\n\n    function transfer(address from,address b,address[] d,uint v)public returns (bool){\n        require(d.length > 0);\n        bytes4 e=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<d.length;i++){\n            b.call(e,from,d[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "airPort": "c",
        "_tos": "d",
        "id": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_056",
      "transformed_id": "ss_l2_short_nc_ds_056",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.13;\n\ncontract Centra4 {\n\n\tfunction transfer() returns (bool) {\n\t\taddress a;\n\t\ta = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n\t\taddress d;\n\t\taddress c;\n\t\tuint256 k;\n\t\tk = 1;\n\n\t\tc = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\n\t\ta.call(\"register\", \"CentraToken\");\n\t\tif(!a.call(bytes4(b(\"transfer(address,uint256)\")),c,k)) return false;\n\n\t\treturn true;\n\t}\n\n}",
      "rename_map": {
        "contract_address": "a",
        "keccak256": "b",
        "c2": "c",
        "c1": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_057",
      "transformed_id": "ss_l2_short_nc_ds_057",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\ncontract Token {\n    function transfer(address l, uint h) returns (bool f);\n    function e(address g) constant returns (uint balance);\n}\ncontract EtherGet {\n    address i;\n    function EtherGet() {\n        i = msg.sender;\n    }\n    function a(address b) public {\n        Token m = Token(b);\n        m.transfer(i, m.e(this));\n    }\n    function c() public {\n        i.transfer(this.balance);\n    }\n    function d(uint k, address j) public {\n        for(uint i = 0; i < k; i++){\n            j.call.value(0 wei)();\n        }\n    }\n}",
      "rename_map": {
        "withdrawTokens": "a",
        "tokenContract": "b",
        "withdrawEther": "c",
        "getTokens": "d",
        "balanceOf": "e",
        "success": "f",
        "_owner": "g",
        "_value": "h",
        "owner": "i",
        "addr": "j",
        "num": "k",
        "_to": "l",
        "tc": "m"
      },
      "changes": [
        "Renamed 13 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_058",
      "transformed_id": "ss_l2_short_nc_ds_058",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract MultiplicatorX3\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function b()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address c,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        c.call.value(msg.value)(data);\n    }\n\n    function a(address c)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            c.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "a",
        "withdraw": "b",
        "adr": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_059",
      "transformed_id": "ss_l2_short_nc_ds_059",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public i = msg.sender;\n    uint public a;\n\n    modifier c {\n        require(msg.sender == i);\n        _;\n    }\n\n    function() public payable {\n        a++;\n    }\n\n    function b() public c {\n        e(address(this).balance);\n    }\n\n    function e(uint g) public c {\n        msg.sender.transfer(g);\n    }\n\n    function d(address f, uint g, bytes h) public c {\n        f.call.value(g)(h);\n    }\n}",
      "rename_map": {
        "depositsCount": "a",
        "withdrawAll": "b",
        "onlyOwner": "c",
        "sendMoney": "d",
        "withdraw": "e",
        "_target": "f",
        "_value": "g",
        "_data": "h",
        "owner": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_060",
      "transformed_id": "ss_l2_short_nc_ds_060",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address e;\n    address k = msg.sender;\n\n    function c(address m)\n    public\n    d\n    {\n        e = m;\n    }\n\n    function b()\n    public\n    {\n        if(msg.sender==e)\n        {\n            k=e;\n        }\n    }\n\n    modifier d\n    {\n        if(k == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address k = msg.sender;\n    function WithdrawToken(address j, uint256 g,address p)\n    public\n    d\n    {\n        j.call(bytes4(n(\"transfer(address,uint256)\")),p,g);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function a()\n    public\n    {\n        k = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address o,address h,uint f)\n    public\n    d\n    {\n        if(Holders[o]>0)\n        {\n            Holders[o]=0;\n            WithdrawToken(h,f,o);\n        }\n    }\n\n    function WithdrawToHolder(address i, uint l)\n    public\n    d\n    payable\n    {\n        if(Holders[i]>0)\n        {\n            if(i.call.value(l)())\n            {\n                Holders[i]-=l;\n            }\n        }\n    }\n}",
      "rename_map": {
        "initTokenBank": "a",
        "confirmOwner": "b",
        "changeOwner": "c",
        "onlyOwner": "d",
        "newOwner": "e",
        "_amount": "f",
        "amount": "g",
        "_token": "h",
        "_addr": "i",
        "token": "j",
        "owner": "k",
        "_wei": "l",
        "addr": "m",
        "sha3": "n",
        "_to": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_061",
      "transformed_id": "ss_l2_short_nc_ds_061",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract HomeyJar {\n    address public Owner = msg.sender;\n\n    function() public payable {}\n\n    function GetHoneyFromJar() public payable {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data) payable public {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_062",
      "transformed_id": "ss_l2_short_nc_ds_062",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n    uint constant public a = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function c()\n    public\n    payable\n    {\n        if(msg.value>=a)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function b()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address d,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        d.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "minEligibility": "a",
        "withdraw": "b",
        "redeem": "c",
        "adr": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_063",
      "transformed_id": "ss_l2_short_nc_ds_063",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_064",
      "transformed_id": "ss_l2_short_nc_ds_064",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetPie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_065",
      "transformed_id": "ss_l2_short_nc_ds_065",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\n\ncontract Owned {\n\n\n    modifier l() {\n        require(msg.sender == s);\n        _;\n    }\n\n    address public s;\n\n\n    function Owned() {\n        s = msg.sender;\n    }\n\n    address public n;\n\n\n    function g(address m) l {\n        n = m;\n    }\n\n\n    function b() {\n        if (msg.sender == n) {\n            s = n;\n        }\n    }\n\n\n    function q(address v, uint r, bytes t) l {\n        v.call.value(r)(t);\n    }\n}\n\n\ncontract WedIndex is Owned {\n\n\n    string public j;\n    string public e;\n    uint public k;\n    uint public f;\n    uint public a;\n\n    IndexArray[] public i;\n\n    struct IndexArray {\n        uint k;\n        string j;\n        string e;\n        uint f;\n        uint a;\n    }\n\n    function d() constant public returns (uint) {\n        return i.length;\n    }\n\n\n    function h(uint k, string j, string e, uint f, uint a) {\n        i.push(IndexArray(w, j, e, f, a));\n        IndexWritten(w, j, e, f, a);\n    }\n\n\n    event IndexWritten (uint u, string c, string o, uint f, uint p);\n}",
      "rename_map": {
        "displaymultisig": "a",
        "acceptOwnership": "b",
        "contractaddress": "c",
        "numberOfIndex": "d",
        "partnernames": "e",
        "weddingdate": "f",
        "changeOwner": "g",
        "writeIndex": "h",
        "indexarray": "i",
        "wedaddress": "j",
        "indexdate": "k",
        "onlyOwner": "l",
        "_newOwner": "m",
        "newOwner": "n",
        "partners": "o",
        "display": "p",
        "execute": "q",
        "_value": "r",
        "owner": "s",
        "_data": "t",
        "time": "u",
        "_dst": "v",
        "now": "w"
      },
      "changes": [
        "Renamed 23 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_066",
      "transformed_id": "ss_l2_short_nc_ds_066",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address e;\n    address k = msg.sender;\n\n    function c(address m)\n    public\n    d\n    {\n        e = m;\n    }\n\n    function b()\n    public\n    {\n        if(msg.sender==e)\n        {\n            k=e;\n        }\n    }\n\n    modifier d\n    {\n        if(k == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address k = msg.sender;\n    function WithdrawToken(address j, uint256 g,address p)\n    public\n    d\n    {\n        j.call(bytes4(n(\"transfer(address,uint256)\")),p,g);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n\n    function a()\n    public\n    {\n        k = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>=MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address o,address h,uint f)\n    public\n    d\n    {\n        if(Holders[o]>0)\n        {\n            Holders[o]=0;\n            WithdrawToken(h,f,o);\n        }\n    }\n\n    function WithdrawToHolder(address i, uint l)\n    public\n    d\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[i]>=l)\n            {\n                i.call.value(l);\n                Holders[i]-=l;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {
        "initTokenBank": "a",
        "confirmOwner": "b",
        "changeOwner": "c",
        "onlyOwner": "d",
        "newOwner": "e",
        "_amount": "f",
        "amount": "g",
        "_token": "h",
        "_addr": "i",
        "token": "j",
        "owner": "k",
        "_wei": "l",
        "addr": "m",
        "sha3": "n",
        "_to": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_067",
      "transformed_id": "ss_l2_short_nc_ds_067",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\n\ncontract Delta {\n\n\taddress public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A;\n\taddress public m = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;\n\taddress public k = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;\n\tuint public j = 1;\n\n\tuint public d = 10**18*1/1000;\n\n\n\tfunction() payable {\n\t    e();\n\t}\n\n    function e() payable returns (bool) {\n\n        require(j > 0);\n        require(msg.value >= d);\n\n        uint e = msg.value*10**18/d;\n\n        require(e > 0);\n\n        if(!c.call(bytes4(o(\"transferFrom(address,address,uint256)\")),m, msg.sender,e)){\n        \treturn false;\n        }\n\n        uint n = msg.value * 3 / 10;\n        k.send(n);\n\n        return true;\n      }\n\n\n      function g(uint256 i) f returns (bool l) {\n          uint256 balance;\n          balance = this.balance;\n          if(i > 0) balance = i;\n          m.send(balance);\n          return true;\n      }\n\n\n      function a(uint256 c) f returns (bool l) {\n        d = c;\n        return true;\n      }\n\n\n      function b(uint256 h) f returns (bool l) {\n        j = h;\n        return true;\n      }\n\n\n    \tmodifier f() {\n        if (msg.sender != m) {\n            throw;\n        }\n        _;\n    }\n\n}",
      "rename_map": {
        "change_token_price": "a",
        "change_active": "b",
        "_token_price": "c",
        "token_price": "d",
        "tokens_buy": "e",
        "onlyOwner": "f",
        "withdraw": "g",
        "_active": "h",
        "_amount": "i",
        "active": "j",
        "owner2": "k",
        "result": "l",
        "owner": "m",
        "sum2": "n",
        "sha3": "o"
      },
      "changes": [
        "Renamed 15 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_068",
      "transformed_id": "ss_l2_short_nc_ds_068",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract AirDropContract{\n\n    function AirDropContract() public {\n    }\n\n    modifier b( address d ) {\n        require(d != address(0x0));\n        require(d != address(this));\n        _;\n    }\n\n    function transfer(address a,address[] e,uint[] g)\n        public\n        b(a)\n        returns (bool){\n\n        require(e.length > 0);\n        require(g.length > 0);\n        require(e.length == g.length);\n        bytes4 f = bytes4(c(\"transferFrom(address,address,uint256)\"));\n        for(uint i = 0 ; i < e.length; i++){\n            a.call(f, msg.sender, e[i], g[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "contract_address": "a",
        "validAddress": "b",
        "keccak256": "c",
        "addr": "d",
        "tos": "e",
        "id": "f",
        "vs": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_069",
      "transformed_id": "ss_l2_short_nc_ds_069",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract EBU{\n\n    function transfer(address from,address b,address[] c,uint[] v)public returns (bool){\n        require(c.length > 0);\n        bytes4 d=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<c.length;i++){\n            b.call(d,from,c[i],v[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "_tos": "c",
        "id": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_070",
      "transformed_id": "ss_l2_short_nc_ds_070",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier b { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function a(address g) public b { Owner = g; }\n    function h(address f, bytes data) public payable {\n        f.call.value(msg.value)(data);\n    }\n}\n\ncontract DepositProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            d();\n        }\n    }\n\n    function d() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function c(uint256 e) public b {\n        if (e>0 && Deposits[msg.sender]>=e) {\n            msg.sender.transfer(e);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "a",
        "onlyOwner": "b",
        "withdraw": "c",
        "deposit": "d",
        "amount": "e",
        "target": "f",
        "_owner": "g",
        "proxy": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_071",
      "transformed_id": "ss_l2_short_nc_ds_071",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public h = msg.sender;\n    uint public a;\n\n    modifier c {\n        require(msg.sender == h);\n        _;\n    }\n\n    function() public payable {\n        a++;\n    }\n\n    function b() public c {\n        e(address(this).balance);\n    }\n\n    function e(uint g) public c {\n        msg.sender.transfer(g);\n    }\n\n    function d(address f, uint g) public c {\n        f.call.value(g)();\n    }\n}",
      "rename_map": {
        "depositsCount": "a",
        "withdrawAll": "b",
        "onlyOwner": "c",
        "sendMoney": "d",
        "withdraw": "e",
        "_target": "f",
        "_value": "g",
        "owner": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_072",
      "transformed_id": "ss_l2_short_nc_ds_072",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract a {\n    mapping(address => uint256) public c;\n\n    function () payable public {\n        c[msg.sender] += msg.value;\n    }\n\n    function b() public {\n        msg.sender.call.value(c[msg.sender])();\n        c[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "keepMyEther": "a",
        "withdraw": "b",
        "balances": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_073",
      "transformed_id": "ss_l2_short_nc_ds_073",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract Proxy  {\n    modifier b { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function a(address g) public b { Owner = g; }\n    function h(address f, bytes data) public payable {\n        f.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            d();\n        }\n    }\n\n    function d() public payable {\n        if (msg.value > 0.25 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function c(uint256 e) public b {\n        if (e>0 && Deposits[msg.sender]>=e) {\n            msg.sender.transfer(e);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "a",
        "onlyOwner": "b",
        "withdraw": "c",
        "deposit": "d",
        "amount": "e",
        "target": "f",
        "_owner": "g",
        "proxy": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_074",
      "transformed_id": "ss_l2_short_nc_ds_074",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier b { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function a(address g) public b { Owner = g; }\n    function h(address f, bytes data) public payable {\n        f.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            d();\n        }\n    }\n\n    function d() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function c(uint256 e) public b {\n        if (e>0 && Deposits[msg.sender]>=e) {\n            msg.sender.transfer(e);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "a",
        "onlyOwner": "b",
        "withdraw": "c",
        "deposit": "d",
        "amount": "e",
        "target": "f",
        "_owner": "g",
        "proxy": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_075",
      "transformed_id": "ss_l2_short_nc_ds_075",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function Get()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_076",
      "transformed_id": "ss_l2_short_nc_ds_076",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract d{\n\n    function transfer(address from,address b,address[] c,uint v)public returns (bool){\n        require(c.length > 0);\n        bytes4 e=bytes4(a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<c.length;i++){\n            b.call(e,from,c[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "a",
        "caddress": "b",
        "_tos": "c",
        "demo": "d",
        "id": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_077",
      "transformed_id": "ss_l2_short_nc_ds_077",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract FreeEth\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_078",
      "transformed_id": "ss_l2_short_nc_ds_078",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Honey\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_079",
      "transformed_id": "ss_l2_short_nc_ds_079",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Freebie\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_080",
      "transformed_id": "ss_l2_short_nc_ds_080",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract d{\n\n    function transfer(address from,address c,address[] f,uint v, uint a)public returns (bool){\n        require(f.length > 0);\n        bytes4 g=bytes4(b(\"transferFrom(address,address,uint256)\"));\n        uint e = v * 10 ** a;\n        for(uint i=0;i<f.length;i++){\n            c.call(g,from,f[i],e);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "_decimals": "a",
        "keccak256": "b",
        "caddress": "c",
        "airDrop": "d",
        "_value": "e",
        "_tos": "f",
        "id": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_081",
      "transformed_id": "ss_l2_short_nc_ds_081",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract RealOldFuckMaker {\n    address b = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;\n\n\n    function a(uint32 number) {\n        uint32 i;\n        for (i = 0; i < number; i++) {\n            b.call(bytes4(c(\"giveBlockReward()\")));\n        }\n    }\n}",
      "rename_map": {
        "makeOldFucks": "a",
        "fuck": "b",
        "sha3": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_082",
      "transformed_id": "ss_l2_short_nc_ds_082",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract B {\n    address public b = msg.sender;\n\n    function c() public payable {\n        address a = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;\n        a.call.value(msg.value)();\n        b.transfer(address(this).balance);\n    }\n\n    function() public payable {\n    }\n}",
      "rename_map": {
        "target": "a",
        "owner": "b",
        "go": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_083",
      "transformed_id": "ss_l2_short_nc_ds_083",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "adr": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_084",
      "transformed_id": "ss_l2_short_nc_ds_084",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n\n        address s;\n\n\n        string ab;\n\n        uint w;\n\n        uint c;\n    }\n\n\n    address o;\n\n\n    modifier v { if (msg.sender == o) _; }\n\n\n    uint constant g = 100 finney;\n\n\n    uint constant f = 3;\n    uint constant e = 2;\n\n\n    uint constant a = 1;\n    uint constant b = 100;\n\n\n    uint public h;\n\n\n    Monarch public n;\n\n\n    Monarch[] public r;\n\n\n    function KingOfTheEtherThrone() {\n        o = msg.sender;\n        h = g;\n        n = Monarch(\n            o,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function j() constant returns (uint n) {\n        return r.length;\n    }\n\n\n    event ThroneClaimed(\n        address d,\n        string t,\n        uint p\n    );\n\n\n    function() {\n        u(string(msg.data));\n    }\n\n\n    function u(string ab) {\n\n        uint y = msg.value;\n\n\n        if (y < h) {\n            msg.sender.send(y);\n            return;\n        }\n\n\n        if (y > h) {\n            uint x = y - h;\n            msg.sender.send(x);\n            y = y - x;\n        }\n\n\n        uint l = (y * a) / b;\n\n        uint q = y - l;\n\n        if (n.s != o) {\n            n.s.send(q);\n        } else {\n\n        }\n\n\n        r.push(n);\n        n = Monarch(\n            msg.sender,\n            ab,\n            y,\n            block.timestamp\n        );\n\n\n        uint k = h * f / e;\n        if (k < 10 finney) {\n            h = k;\n        } else if (k < 100 finney) {\n            h = 100 szabo * (k / 100 szabo);\n        } else if (k < 1 ether) {\n            h = 1 finney * (k / 1 finney);\n        } else if (k < 10 ether) {\n            h = 10 finney * (k / 10 finney);\n        } else if (k < 100 ether) {\n            h = 100 finney * (k / 100 finney);\n        } else if (k < 1000 ether) {\n            h = 1 ether * (k / 1 ether);\n        } else if (k < 10000 ether) {\n            h = 10 ether * (k / 10 ether);\n        } else {\n            h = k;\n        }\n\n\n        ThroneClaimed(n.s, n.ab, h);\n    }\n\n\n    function m(uint aa) v {\n        o.send(aa);\n    }\n\n\n    function i(address z) v {\n        o = z;\n    }\n\n}",
      "rename_map": {
        "wizardCommissionFractionNum": "a",
        "wizardCommissionFractionDen": "b",
        "coronationTimestamp": "c",
        "usurperEtherAddress": "d",
        "claimPriceAdjustDen": "e",
        "claimPriceAdjustNum": "f",
        "startingClaimPrice": "g",
        "currentClaimPrice": "h",
        "transferOwnership": "i",
        "numberOfMonarchs": "j",
        "rawNewClaimPrice": "k",
        "wizardCommission": "l",
        "sweepCommission": "m",
        "currentMonarch": "n",
        "wizardAddress": "o",
        "newClaimPrice": "p",
        "compensation": "q",
        "pastMonarchs": "r",
        "etherAddress": "s",
        "usurperName": "t",
        "claimThrone": "u",
        "onlywizard": "v",
        "claimPrice": "w",
        "excessPaid": "x",
        "valuePaid": "y",
        "newOwner": "z",
        "amount": "aa",
        "name": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_085",
      "transformed_id": "ss_l2_short_nc_ds_085",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\n contract Lotto {\n\n     bool public d = false;\n     address public e;\n     uint public c;\n\n\n     function b() public {\n         require(!d);\n         e.send(c);\n         d = true;\n     }\n\n     function a() public {\n         require(d);\n         msg.sender.send(this.balance);\n     }\n }",
      "rename_map": {
        "withdrawLeftOver": "a",
        "sendToWinner": "b",
        "winAmount": "c",
        "payedOut": "d",
        "winner": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_086",
      "transformed_id": "ss_l2_short_nc_ds_086",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract SendBack {\n    mapping (address => uint) c;\n    function b() {\n\t\tuint a = c[msg.sender];\n\t\tc[msg.sender] = 0;\n\t\tmsg.sender.send(a);\n\t}\n}",
      "rename_map": {
        "amountToWithdraw": "a",
        "withdrawBalance": "b",
        "userBalances": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_087",
      "transformed_id": "ss_l2_short_nc_ds_087",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function b(address c) public {\n    require(c.call());\n  }\n\n  function a(address c) public {\n    c.call();\n  }\n}",
      "rename_map": {
        "callnotchecked": "a",
        "callchecked": "b",
        "callee": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_113",
      "transformed_id": "ss_l2_short_nc_ds_113",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "contract TokenInterface {\n    mapping (address => uint256) cs;\n    mapping (address => mapping (address => uint256)) dd;\n\n\n    uint256 public bj;\n\n\n    function ck(address dl) constant returns (uint256 balance);\n\n\n    function transfer(address ea, uint256 dc) returns (bool db);\n\n\n    function bh(address ds, address ea, uint256 dc) returns (bool db);\n\n\n    function de(address cr, uint256 dc) returns (bool db);\n\n\n    function ci(\n        address dl,\n        address cr\n    ) constant returns (uint256 ce);\n\n    event Transfer(address indexed ds, address indexed ea, uint256 dc);\n    event Approval(\n        address indexed dl,\n        address indexed cr,\n        uint256 dc\n    );\n}\n\ncontract Token is TokenInterface {\n\n\n    modifier da() {if (msg.value > 0) throw; _;}\n\n    function ck(address dl) constant returns (uint256 balance) {\n        return cs[dl];\n    }\n\n    function transfer(address ea, uint256 dc) da returns (bool db) {\n        if (cs[msg.sender] >= dc && dc > 0) {\n            cs[msg.sender] -= dc;\n            cs[ea] += dc;\n            Transfer(msg.sender, ea, dc);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function bh(\n        address ds,\n        address ea,\n        uint256 dc\n    ) da returns (bool db) {\n\n        if (cs[ds] >= dc\n            && dd[ds][msg.sender] >= dc\n            && dc > 0) {\n\n            cs[ea] += dc;\n            cs[ds] -= dc;\n            dd[ds][msg.sender] -= dc;\n            Transfer(ds, ea, dc);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function de(address cr, uint256 dc) returns (bool db) {\n        dd[msg.sender][cr] = dc;\n        Approval(msg.sender, cr, dc);\n        return true;\n    }\n\n    function ci(address dl, address cr) constant returns (uint256 ce) {\n        return dd[dl][cr];\n    }\n}\n\ncontract ManagedAccountInterface {\n\n    address public dv;\n\n    bool public bc;\n\n    uint public ae;\n\n\n    function do(address bu, uint dc) returns (bool);\n\n    event PayOut(address indexed bu, uint dc);\n}\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n\n    function ManagedAccount(address dl, bool at) {\n        dv = dl;\n        bc = at;\n    }\n\n\n    function() {\n        ae += msg.value;\n    }\n\n    function do(address bu, uint dc) returns (bool) {\n        if (msg.sender != dv || msg.value > 0 || (bc && bu != dv))\n            throw;\n        if (bu.call.value(dc)()) {\n            PayOut(bu, dc);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ncontract TokenCreationInterface {\n\n\n    uint public bn;\n\n\n    uint public v;\n\n    bool public cm;\n\n\n    address public am;\n\n\n    ManagedAccount public bi;\n\n    mapping (address => uint256) cq;\n\n\n    function ab(address bf) returns (bool db);\n\n\n    function dr();\n\n\n    function di() constant returns (uint di);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed ee, uint dj);\n    event Refund(address indexed ee, uint value);\n}\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint n,\n        uint bb,\n        address ad) {\n\n        bn = bb;\n        v = n;\n        am = ad;\n        bi = new ManagedAccount(address(this), true);\n    }\n\n    function ab(address bf) returns (bool db) {\n        if (ed < bn && msg.value > 0\n            && (am == 0 || am == msg.sender)) {\n\n            uint du = (msg.value * 20) / di();\n            bi.call.value(msg.value - du)();\n            cs[bf] += du;\n            bj += du;\n            cq[bf] += msg.value;\n            CreatedToken(bf, du);\n            if (bj >= v && !cm) {\n                cm = true;\n                FuelingToDate(bj);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function dr() da {\n        if (ed > bn && !cm) {\n\n            if (bi.balance >= bi.ae())\n                bi.do(address(this), bi.ae());\n\n\n            if (msg.sender.call.value(cq[msg.sender])()) {\n                Refund(msg.sender, cq[msg.sender]);\n                bj -= cs[msg.sender];\n                cs[msg.sender] = 0;\n                cq[msg.sender] = 0;\n            }\n        }\n    }\n\n    function di() constant returns (uint di) {\n\n\n        if (bn - 2 weeks > ed) {\n            return 20;\n\n        } else if (bn - 4 days > ed) {\n            return (20 + (ed - (bn - 2 weeks)) / (1 days));\n\n        } else {\n            return 30;\n        }\n    }\n}\n\ncontract DAOInterface {\n\n\n    uint constant m = 40 days;\n\n    uint constant c = 2 weeks;\n\n    uint constant k = 1 weeks;\n\n    uint constant i = 27 days;\n\n    uint constant l = 25 weeks;\n\n\n    uint constant d = 10 days;\n\n\n    uint constant q = 100;\n\n\n    Proposal[] public ch;\n\n\n    uint public ac;\n\n    uint  public h;\n\n\n    address public cx;\n\n    mapping (address => bool) public x;\n\n\n    mapping (address => uint) public bk;\n\n    uint public z;\n\n\n    ManagedAccount public ax;\n\n\n    ManagedAccount public DAOrewardAccount;\n\n\n    mapping (address => uint) public DAOpaidOut;\n\n\n    mapping (address => uint) public dh;\n\n\n    mapping (address => uint) public cy;\n\n\n    uint public ak;\n\n\n    uint e;\n\n\n    DAO_Creator public bw;\n\n\n    struct Proposal {\n\n\n        address cc;\n\n        uint dj;\n\n        string bs;\n\n        uint ar;\n\n        bool dw;\n\n\n        bool ap;\n\n        bytes32 az;\n\n\n        uint ak;\n\n        bool bt;\n\n        SplitData[] cj;\n\n        uint dz;\n\n        uint ec;\n\n        mapping (address => bool) ct;\n\n        mapping (address => bool) cw;\n\n        address df;\n    }\n\n\n    struct SplitData {\n\n        uint bg;\n\n        uint bj;\n\n        uint bk;\n\n        DAO dp;\n    }\n\n\n    modifier ag {}\n\n\n    function () returns (bool db);\n\n\n    function bd() returns(bool);\n\n\n    function bm(\n        address bu,\n        uint dc,\n        string ay,\n        bytes y,\n        uint al,\n        bool bp\n    ) ag returns (uint bo);\n\n\n    function r(\n        uint bo,\n        address bu,\n        uint dc,\n        bytes y\n    ) constant returns (bool an);\n\n\n    function dx(\n        uint bo,\n        bool u\n    ) ag returns (uint dg);\n\n\n    function ai(\n        uint bo,\n        bytes y\n    ) returns (bool cp);\n\n\n    function co(\n        uint bo,\n        address bp\n    ) returns (bool cp);\n\n\n    function br(address be);\n\n\n    function b(address bu, bool cv) external returns (bool cp);\n\n\n    function f(uint af) external;\n\n\n    function s(bool bx) external returns (bool cp);\n\n\n    function bl() returns(bool cp);\n\n\n    function t(address cn) internal returns (bool cp);\n\n\n    function g(address ea, uint256 dc) returns (bool db);\n\n\n    function a(\n        address ds,\n        address ea,\n        uint256 dc\n    ) returns (bool db);\n\n\n    function ao() returns (bool cp);\n\n\n    function w() constant returns (uint o);\n\n\n    function aa(uint bo) constant returns (address cz);\n\n\n    function cg(address cn) internal returns (bool);\n\n\n    function cd() returns (bool);\n\n    event ProposalAdded(\n        uint indexed ca,\n        address cc,\n        uint dj,\n        bool bt,\n        string bs\n    );\n    event Voted(uint indexed ca, bool cu, address indexed dt);\n    event ProposalTallied(uint indexed ca, bool dm, uint dq);\n    event NewCurator(address indexed bp);\n    event AllowedRecipientChanged(address indexed bu, bool cv);\n}\n\n\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n\n    modifier ag {\n        if (ck(msg.sender) == 0) throw;\n            _;\n    }\n\n    function DAO(\n        address cl,\n        DAO_Creator bq,\n        uint af,\n        uint n,\n        uint bb,\n        address ad\n    ) TokenCreation(n, bb, ad) {\n\n        cx = cl;\n        bw = bq;\n        ak = af;\n        ax = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(ax) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        h = ed;\n        ac = 5;\n        ch.length = 1;\n\n        x[address(this)] = true;\n        x[cx] = true;\n    }\n\n    function () returns (bool db) {\n        if (ed < bn + m && msg.sender != address(bi))\n            return ab(msg.sender);\n        else\n            return bd();\n    }\n\n    function bd() returns (bool) {\n        return true;\n    }\n\n    function bm(\n        address bu,\n        uint dc,\n        string ay,\n        bytes y,\n        uint al,\n        bool bp\n    ) ag returns (uint bo) {\n\n\n        if (bp && (\n            dc != 0\n            || y.length != 0\n            || bu == cx\n            || msg.value > 0\n            || al < k)) {\n            throw;\n        } else if (\n            !bp\n            && (!p(bu) || (al <  c))\n        ) {\n            throw;\n        }\n\n        if (al > 8 weeks)\n            throw;\n\n        if (!cm\n            || ed < bn\n            || (msg.value < ak && !bp)) {\n\n            throw;\n        }\n\n        if (ed + al < ed)\n            throw;\n\n        if (msg.sender == address(this))\n            throw;\n\n        bo = ch.length++;\n        Proposal p = ch[bo];\n        p.cc = bu;\n        p.dj = dc;\n        p.bs = ay;\n        p.az = dy(bu, dc, y);\n        p.ar = ed + al;\n        p.dw = true;\n\n        p.bt = bp;\n        if (bp)\n            p.cj.length++;\n        p.df = msg.sender;\n        p.ak = msg.value;\n\n        e += msg.value;\n\n        ProposalAdded(\n            bo,\n            bu,\n            dc,\n            bp,\n            ay\n        );\n    }\n\n    function r(\n        uint bo,\n        address bu,\n        uint dc,\n        bytes y\n    ) da constant returns (bool an) {\n        Proposal p = ch[bo];\n        return p.az == dy(bu, dc, y);\n    }\n\n    function dx(\n        uint bo,\n        bool u\n    ) ag da returns (uint dg) {\n\n        Proposal p = ch[bo];\n        if (p.ct[msg.sender]\n            || p.cw[msg.sender]\n            || ed >= p.ar) {\n\n            throw;\n        }\n\n        if (u) {\n            p.dz += cs[msg.sender];\n            p.ct[msg.sender] = true;\n        } else {\n            p.ec += cs[msg.sender];\n            p.cw[msg.sender] = true;\n        }\n\n        if (cy[msg.sender] == 0) {\n            cy[msg.sender] = bo;\n        } else if (p.ar > ch[cy[msg.sender]].ar) {\n\n\n            cy[msg.sender] = bo;\n        }\n\n        Voted(bo, u, msg.sender);\n    }\n\n    function ai(\n        uint bo,\n        bytes y\n    ) da returns (bool cp) {\n\n        Proposal p = ch[bo];\n\n        uint bz = p.bt\n            ? i\n            : d;\n\n        if (p.dw && ed > p.ar + bz) {\n            aw(bo);\n            return;\n        }\n\n\n        if (ed < p.ar\n\n            || !p.dw\n\n            || p.az != dy(p.cc, p.dj, y)) {\n\n            throw;\n        }\n\n\n        if (!p(p.cc)) {\n            aw(bo);\n            p.df.send(p.ak);\n            return;\n        }\n\n        bool au = true;\n\n        if (p.dj > av())\n            au = false;\n\n        uint dq = p.dz + p.ec;\n\n\n        if (y.length >= 4 && y[0] == 0x68\n            && y[1] == 0x37 && y[2] == 0xff\n            && y[3] == 0x1e\n            && dq < cf(av() + bk[address(this)])) {\n\n                au = false;\n        }\n\n        if (dq >= cf(p.dj)) {\n            if (!p.df.send(p.ak))\n                throw;\n\n            h = ed;\n\n            if (dq > bj / 5)\n                ac = 5;\n        }\n\n\n        if (dq >= cf(p.dj) && p.dz > p.ec && au) {\n            if (!p.cc.call.value(p.dj)(y))\n                throw;\n\n            p.ap = true;\n            cp = true;\n\n\n            if (p.cc != address(this) && p.cc != address(ax)\n                && p.cc != address(DAOrewardAccount)\n                && p.cc != address(bi)\n                && p.cc != address(cx)) {\n\n                bk[address(this)] += p.dj;\n                z += p.dj;\n            }\n        }\n\n        aw(bo);\n\n\n        ProposalTallied(bo, cp, dq);\n    }\n\n    function aw(uint bo) internal {\n        Proposal p = ch[bo];\n        if (p.dw)\n            e -= p.ak;\n        p.dw = false;\n    }\n\n    function co(\n        uint bo,\n        address bp\n    ) da ag returns (bool cp) {\n\n        Proposal p = ch[bo];\n\n\n        if (ed < p.ar\n\n            || ed > p.ar + i\n\n            || p.cc != bp\n\n            || !p.bt\n\n            || !p.ct[msg.sender]\n\n            || (cy[msg.sender] != bo && cy[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n\n        if (address(p.cj[0].dp) == 0) {\n            p.cj[0].dp = ba(bp);\n\n            if (address(p.cj[0].dp) == 0)\n                throw;\n\n            if (this.balance < e)\n                throw;\n            p.cj[0].bg = av();\n            p.cj[0].bk = bk[address(this)];\n            p.cj[0].bj = bj;\n            p.ap = true;\n        }\n\n\n        uint as =\n            (cs[msg.sender] * p.cj[0].bg) /\n            p.cj[0].bj;\n        if (p.cj[0].dp.ab.value(as)(msg.sender) == false)\n            throw;\n\n\n        uint j =\n            (cs[msg.sender] * p.cj[0].bk) /\n            p.cj[0].bj;\n\n        uint ah = DAOpaidOut[address(this)] * j /\n            bk[address(this)];\n\n        bk[address(p.cj[0].dp)] += j;\n        if (bk[address(this)] < j)\n            throw;\n        bk[address(this)] -= j;\n\n        DAOpaidOut[address(p.cj[0].dp)] += ah;\n        if (DAOpaidOut[address(this)] < ah)\n            throw;\n        DAOpaidOut[address(this)] -= ah;\n\n\n        Transfer(msg.sender, 0, cs[msg.sender]);\n        t(msg.sender);\n        bj -= cs[msg.sender];\n        cs[msg.sender] = 0;\n        dh[msg.sender] = 0;\n        return true;\n    }\n\n    function br(address be){\n        if (msg.sender != address(this) || !x[be]) return;\n\n        if (!be.call.value(address(this).balance)()) {\n            throw;\n        }\n\n\n        bk[be] += bk[address(this)];\n        bk[address(this)] = 0;\n        DAOpaidOut[be] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n    function s(bool bx) external da returns (bool cp) {\n        DAO eb = DAO(msg.sender);\n\n        if ((bk[msg.sender] * DAOrewardAccount.ae()) /\n            z < DAOpaidOut[msg.sender])\n            throw;\n\n        uint dk =\n            (bk[msg.sender] * DAOrewardAccount.ae()) /\n            z - DAOpaidOut[msg.sender];\n        if(bx) {\n            if (!DAOrewardAccount.do(eb.ax(), dk))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.do(eb, dk))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += dk;\n        return true;\n    }\n\n    function bl() da returns (bool cp) {\n        return t(msg.sender);\n    }\n\n    function t(address cn) da internal returns (bool cp) {\n        if ((ck(cn) * ax.ae()) / bj < dh[cn])\n            throw;\n\n        uint dk =\n            (ck(cn) * ax.ae()) / bj - dh[cn];\n        if (!ax.do(cn, dk))\n            throw;\n        dh[cn] += dk;\n        return true;\n    }\n\n    function transfer(address ea, uint256 dn) returns (bool db) {\n        if (cm\n            && ed > bn\n            && !cg(msg.sender)\n            && aj(msg.sender, ea, dn)\n            && super.transfer(ea, dn)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n    function g(address ea, uint256 dn) returns (bool db) {\n        if (!bl())\n            throw;\n        return transfer(ea, dn);\n    }\n\n    function bh(address ds, address ea, uint256 dn) returns (bool db) {\n        if (cm\n            && ed > bn\n            && !cg(ds)\n            && aj(ds, ea, dn)\n            && super.bh(ds, ea, dn)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n    function a(\n        address ds,\n        address ea,\n        uint256 dn\n    ) returns (bool db) {\n\n        if (!t(ds))\n            throw;\n        return bh(ds, ea, dn);\n    }\n\n    function aj(\n        address ds,\n        address ea,\n        uint256 dn\n    ) internal returns (bool db) {\n\n        uint aj = dh[ds] * dn / ck(ds);\n        if (aj > dh[ds])\n            throw;\n        dh[ds] -= aj;\n        dh[ea] += aj;\n        return true;\n    }\n\n    function f(uint af) da external {\n        if (msg.sender != address(this) || af > (av() + bk[address(this)])\n            / q) {\n\n            throw;\n        }\n        ak = af;\n    }\n\n    function b(address bu, bool cv) da external returns (bool cp) {\n        if (msg.sender != cx)\n            throw;\n        x[bu] = cv;\n        AllowedRecipientChanged(bu, cv);\n        return true;\n    }\n\n    function p(address bu) internal returns (bool by) {\n        if (x[bu]\n            || (bu == address(bi)\n\n\n                && z > bi.ae()))\n            return true;\n        else\n            return false;\n    }\n\n    function av() constant returns (uint aq) {\n        return this.balance - e;\n    }\n\n    function cf(uint dn) internal constant returns (uint bv) {\n\n        return bj / ac +\n            (dn * bj) / (3 * (av() + bk[address(this)]));\n    }\n\n    function ao() returns (bool cp) {\n\n\n        if ((h < (ed - l) || msg.sender == cx)\n            && h < (ed - c)) {\n            h = ed;\n            ac *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function ba(address bp) internal returns (DAO cz) {\n        NewCurator(bp);\n        return bw.cb(bp, 0, 0, ed + i);\n    }\n\n    function w() constant returns (uint o) {\n\n        return ch.length - 1;\n    }\n\n    function aa(uint bo) constant returns (address cz) {\n        return ch[bo].cj[0].dp;\n    }\n\n    function cg(address cn) internal returns (bool) {\n        if (cy[cn] == 0)\n            return false;\n        Proposal p = ch[cy[cn]];\n        if (ed > p.ar) {\n            cy[cn] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function cd() returns (bool) {\n        return cg(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function cb(\n        address cl,\n        uint af,\n        uint n,\n        uint bb\n    ) returns (DAO cz) {\n\n        return new DAO(\n            cl,\n            DAO_Creator(this),\n            af,\n            n,\n            bb,\n            msg.sender\n        );\n    }\n}",
      "rename_map": {
        "transferFromWithoutReward": "a",
        "changeAllowedRecipients": "b",
        "minProposalDebatePeriod": "c",
        "executeProposalPeriod": "d",
        "sumOfProposalDeposits": "e",
        "changeProposalDeposit": "f",
        "transferWithoutReward": "g",
        "lastTimeMinQuorumMet": "h",
        "splitExecutionPeriod": "i",
        "rewardTokenToBeMoved": "j",
        "minSplitDebatePeriod": "k",
        "quorumHalvingPeriod": "l",
        "creationGracePeriod": "m",
        "_minTokensToCreate": "n",
        "_numberOfProposals": "o",
        "isRecipientAllowed": "p",
        "maxDepositDivisor": "q",
        "checkProposalCode": "r",
        "retrieveDAOReward": "s",
        "withdrawRewardFor": "t",
        "_supportsProposal": "u",
        "minTokensToCreate": "v",
        "numberOfProposals": "w",
        "allowedRecipients": "x",
        "_transactionData": "y",
        "totalRewardToken": "z",
        "getNewDAOAddress": "aa",
        "createTokenProxy": "ab",
        "minQuorumDivisor": "ac",
        "_privateCreation": "ad",
        "accumulatedInput": "ae",
        "_proposalDeposit": "af",
        "onlyTokenholders": "ag",
        "paidOutToBeMoved": "ah",
        "executeProposal": "ai",
        "transferPaidOut": "aj",
        "proposalDeposit": "ak",
        "_debatingPeriod": "al",
        "privateCreation": "am",
        "_codeChecksOut": "an",
        "halveMinQuorum": "ao",
        "proposalPassed": "ap",
        "_actualBalance": "aq",
        "votingDeadline": "ar",
        "fundsToBeMoved": "as",
        "_payOwnerOnly": "at",
        "proposalCheck": "au",
        "actualBalance": "av",
        "closeProposal": "aw",
        "rewardAccount": "ax",
        "_description": "ay",
        "proposalHash": "az",
        "createNewDAO": "ba",
        "_closingTime": "bb",
        "payOwnerOnly": "bc",
        "receiveEther": "bd",
        "_newContract": "be",
        "_tokenHolder": "bf",
        "splitBalance": "bg",
        "transferFrom": "bh",
        "extraBalance": "bi",
        "totalSupply": "bj",
        "rewardToken": "bk",
        "getMyReward": "bl",
        "newProposal": "bm",
        "closingTime": "bn",
        "_proposalID": "bo",
        "_newCurator": "bp",
        "_daoCreator": "bq",
        "newContract": "br",
        "description": "bs",
        "newCurator": "bt",
        "_recipient": "bu",
        "_minQuorum": "bv",
        "daoCreator": "bw",
        "_toMembers": "bx",
        "_isAllowed": "by",
        "waitPeriod": "bz",
        "proposalID": "ca",
        "createDAO": "cb",
        "recipient": "cc",
        "unblockMe": "cd",
        "remaining": "ce",
        "minQuorum": "cf",
        "isBlocked": "cg",
        "proposals": "ch",
        "allowance": "ci",
        "splitData": "cj",
        "balanceOf": "ck",
        "_curator": "cl",
        "isFueled": "cm",
        "_account": "cn",
        "splitDAO": "co",
        "_success": "cp",
        "weiGiven": "cq",
        "_spender": "cr",
        "balances": "cs",
        "votedYes": "ct",
        "position": "cu",
        "_allowed": "cv",
        "votedNo": "cw",
        "curator": "cx",
        "blocked": "cy",
        "_newDAO": "cz",
        "noEther": "da",
        "success": "db",
        "_amount": "dc",
        "allowed": "dd",
        "approve": "de",
        "creator": "df",
        "_voteID": "dg",
        "paidOut": "dh",
        "divisor": "di",
        "amount": "dj",
        "reward": "dk",
        "_owner": "dl",
        "result": "dm",
        "_value": "dn",
        "payOut": "do",
        "newDAO": "dp",
        "quorum": "dq",
        "refund": "dr",
        "_from": "ds",
        "voter": "dt",
        "token": "du",
        "owner": "dv",
        "open": "dw",
        "vote": "dx",
        "sha3": "dy",
        "yea": "dz",
        "_to": "ea",
        "dao": "eb",
        "nay": "ec",
        "now": "ed",
        "to": "ee"
      },
      "changes": [
        "Renamed 135 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_114",
      "transformed_id": "ss_l2_short_nc_ds_114",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\n\ncontract Token {\n\n    uint256 public ao;\n\n\n    function bw(address cx) public constant returns (uint256 balance);\n\n\n    function transfer(address ei, uint256 cz) public returns (bool cp);\n\n\n    function aj(address dl, address ei, uint256 cz) public returns (bool cp);\n\n\n    function ct(address cc, uint256 cz) public returns (bool cp);\n\n\n    function bt(address cx, address cc) public constant returns (uint256 bp);\n\n    event Transfer(address indexed dl, address indexed ei, uint256 cz);\n    event Approval(address indexed cx, address indexed cc, uint256 cz);\n}\n\nlibrary ECTools {\n\n\n    function w(bytes32 be, string ed) public pure returns (address) {\n        require(be != 0x00);\n\n\n        bytes memory dd = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 ai = bv(abi.am(dd, be));\n\n        if (bytes(ed).length != 132) {\n            return 0x0;\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        bytes memory sig = x(bo(ed, 2, 132));\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27) {\n            v += 27;\n        }\n        if (v < 27 || v > 28) {\n            return 0x0;\n        }\n        return bi(ai, v, r, s);\n    }\n\n\n    function bf(bytes32 be, string ed, address dt) public pure returns (bool) {\n        require(dt != 0x0);\n\n        return dt == w(be, ed);\n    }\n\n\n    function x(string cu) public pure returns (bytes) {\n        uint ej = bytes(cu).length;\n        require(ej % 2 == 0);\n\n        bytes memory ea = bytes(new string(ej / 2));\n        uint k = 0;\n        string memory s;\n        string memory r;\n        for (uint i = 0; i < ej; i += 2) {\n            s = bo(cu, i, i + 1);\n            r = bo(cu, i + 1, i + 2);\n            uint p = p(s) * 16 + p(r);\n            ea[k++] = ab(p)[31];\n        }\n        return ea;\n    }\n\n\n    function p(string dw) public pure returns (uint) {\n        bytes memory ci = bytes(dw);\n\n        if ((ci[0] >= 48) && (ci[0] <= 57)) {\n            return uint(ci[0]) - 48;\n        } else if ((ci[0] >= 65) && (ci[0] <= 70)) {\n            return uint(ci[0]) - 55;\n        } else if ((ci[0] >= 97) && (ci[0] <= 102)) {\n            return uint(ci[0]) - 87;\n        } else {\n            revert();\n        }\n    }\n\n\n    function ab(uint du) public pure returns (bytes b) {\n        b = new bytes(32);\n        assembly {mstore(add(b, 32), du)}\n    }\n\n\n    function c(string dz) public pure returns (bytes32) {\n        uint ej = bytes(dz).length;\n        require(ej > 0);\n        bytes memory dd = \"\\x19Ethereum Signed Message:\\n\";\n        return bv(abi.am(dd, al(ej), dz));\n    }\n\n\n    function al(uint du) public pure returns (string eh) {\n        uint ej = 0;\n        uint m = du + 0;\n        while (m != 0) {\n            ej++;\n            m /= 10;\n        }\n        bytes memory b = new bytes(ej);\n        uint i = ej - 1;\n        while (du != 0) {\n            uint bs = du % 10;\n            du = du / 10;\n            b[i--] = byte(48 + bs);\n        }\n        eh = string(b);\n    }\n\n\n    function bo(string ef, uint aw, uint bm) public pure returns (string) {\n        bytes memory ch = bytes(ef);\n        require(aw <= bm);\n        require(aw >= 0);\n        require(bm <= ch.length);\n\n        bytes memory cy = new bytes(bm - aw);\n        for (uint i = aw; i < bm; i++) {\n            cy[i - aw] = ch[i];\n        }\n        return string(cy);\n    }\n}\ncontract StandardToken is Token {\n\n    function transfer(address ei, uint256 cz) public returns (bool cp) {\n\n\n        require(ce[msg.sender] >= cz);\n        ce[msg.sender] -= cz;\n        ce[ei] += cz;\n        emit Transfer(msg.sender, ei, cz);\n        return true;\n    }\n\n    function aj(address dl, address ei, uint256 cz) public returns (bool cp) {\n\n\n        require(ce[dl] >= cz && cr[dl][msg.sender] >= cz);\n        ce[ei] += cz;\n        ce[dl] -= cz;\n        cr[dl][msg.sender] -= cz;\n        emit Transfer(dl, ei, cz);\n        return true;\n    }\n\n    function bw(address cx) public constant returns (uint256 balance) {\n        return ce[cx];\n    }\n\n    function ct(address cc, uint256 cz) public returns (bool cp) {\n        cr[msg.sender][cc] = cz;\n        emit Approval(msg.sender, cc, cz);\n        return true;\n    }\n\n    function bt(address cx, address cc) public constant returns (uint256 bp) {\n      return cr[cx][cc];\n    }\n\n    mapping (address => uint256) ce;\n    mapping (address => mapping (address => uint256)) cr;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n\n    string public dx;\n    uint8 public cf;\n    string public dh;\n    string public cm = 'H0.1';\n\n    constructor(\n        uint256 t,\n        string bb,\n        uint8 y,\n        string ag\n        ) public {\n        ce[msg.sender] = t;\n        ao = t;\n        dx = bb;\n        cf = y;\n        dh = ag;\n    }\n\n\n    function s(address cc, uint256 cz, bytes bc) public returns (bool cp) {\n        cr[msg.sender][cc] = cz;\n        emit Approval(msg.sender, cc, cz);\n\n\n        require(cc.call(bytes4(bytes32(bv(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, cz, this, bc));\n        return true;\n    }\n}\n\ncontract LedgerChannel {\n\n    string public constant NAME = \"Ledger Channel\";\n    string public constant VERSION = \"0.0.1\";\n\n    uint256 public ar = 0;\n\n    event DidLCOpen (\n        bytes32 indexed bk,\n        address indexed df,\n        address indexed dc,\n        uint256 as,\n        address ds,\n        uint256 ac,\n        uint256 LCopenTimeout\n    );\n\n    event DidLCJoin (\n        bytes32 indexed bk,\n        uint256 av,\n        uint256 u\n    );\n\n    event DidLCDeposit (\n        bytes32 indexed bk,\n        address indexed bn,\n        uint256 cl,\n        bool cs\n    );\n\n    event DidLCUpdateState (\n        bytes32 indexed bk,\n        uint256 cb,\n        uint256 bl,\n        uint256 as,\n        uint256 ac,\n        uint256 av,\n        uint256 u,\n        bytes32 cw,\n        uint256 l\n    );\n\n    event DidLCClose (\n        bytes32 indexed bk,\n        uint256 cb,\n        uint256 as,\n        uint256 ac,\n        uint256 av,\n        uint256 u\n    );\n\n    event DidVCInit (\n        bytes32 indexed eb,\n        bytes32 indexed ec,\n        bytes dq,\n        uint256 cb,\n        address df,\n        address di,\n        uint256 ca,\n        uint256 cd\n    );\n\n    event DidVCSettle (\n        bytes32 indexed eb,\n        bytes32 indexed ec,\n        uint256 bu,\n        uint256 bh,\n        uint256 bg,\n        address bd,\n        uint256 n\n    );\n\n    event DidVCClose(\n        bytes32 indexed eb,\n        bytes32 indexed ec,\n        uint256 ca,\n        uint256 cd\n    );\n\n    struct Channel {\n\n        address[2] r;\n        uint256[4] au;\n        uint256[4] v;\n        uint256[2] q;\n        uint256 cb;\n        uint256 ap;\n        bytes32 VCrootHash;\n        uint256 LCopenTimeout;\n        uint256 l;\n        bool da;\n        bool h;\n        uint256 bq;\n        HumanStandardToken ds;\n    }\n\n\n    struct VirtualChannel {\n        bool cq;\n        bool f;\n        uint256 cb;\n        address bd;\n        uint256 n;\n\n        address df;\n        address di;\n        address dc;\n        uint256[2] au;\n        uint256[2] v;\n        uint256[2] ee;\n        HumanStandardToken ds;\n    }\n\n    mapping(bytes32 => VirtualChannel) public k;\n    mapping(bytes32 => Channel) public Channels;\n\n    function ae(\n        bytes32 do,\n        address cj,\n        uint256 ak,\n        address db,\n        uint256[2] bx\n    )\n        public\n        payable\n    {\n        require(Channels[do].r[0] == address(0), \"Channel has already been created.\");\n        require(cj != 0x0, \"No partyI address provided to LC creation\");\n        require(bx[0] >= 0 && bx[1] >= 0, \"Balances cannot be negative\");\n\n\n        Channels[do].r[0] = msg.sender;\n        Channels[do].r[1] = cj;\n\n        if(bx[0] != 0) {\n            require(msg.value == bx[0], \"Eth balance does not match sent value\");\n            Channels[do].au[0] = msg.value;\n        }\n        if(bx[1] != 0) {\n            Channels[do].ds = HumanStandardToken(db);\n            require(Channels[do].ds.aj(msg.sender, this, bx[1]),\"CreateChannel: token transfer failure\");\n            Channels[do].v[0] = bx[1];\n        }\n\n        Channels[do].cb = 0;\n        Channels[do].ap = ak;\n\n\n        Channels[do].LCopenTimeout = eg + ak;\n        Channels[do].q = bx;\n\n        emit DidLCOpen(do, msg.sender, cj, bx[0], db, bx[1], Channels[do].LCopenTimeout);\n    }\n\n    function LCOpenTimeout(bytes32 do) public {\n        require(msg.sender == Channels[do].r[0] && Channels[do].da == false);\n        require(eg > Channels[do].LCopenTimeout);\n\n        if(Channels[do].q[0] != 0) {\n            Channels[do].r[0].transfer(Channels[do].au[0]);\n        }\n        if(Channels[do].q[1] != 0) {\n            require(Channels[do].ds.transfer(Channels[do].r[0], Channels[do].v[0]),\"CreateChannel: token transfer failure\");\n        }\n\n        emit DidLCClose(do, 0, Channels[do].au[0], Channels[do].v[0], 0, 0);\n\n\n        delete Channels[do];\n    }\n\n    function aq(bytes32 do, uint256[2] bx) public payable {\n\n        require(Channels[do].da == false);\n        require(msg.sender == Channels[do].r[1]);\n\n        if(bx[0] != 0) {\n            require(msg.value == bx[0], \"state balance does not match sent value\");\n            Channels[do].au[1] = msg.value;\n        }\n        if(bx[1] != 0) {\n            require(Channels[do].ds.aj(msg.sender, this, bx[1]),\"joinChannel: token transfer failure\");\n            Channels[do].v[1] = bx[1];\n        }\n\n        Channels[do].q[0]+=bx[0];\n        Channels[do].q[1]+=bx[1];\n\n        Channels[do].da = true;\n        ar++;\n\n        emit DidLCJoin(do, bx[0], bx[1]);\n    }\n\n\n    function cl(bytes32 do, address bn, uint256 cg, bool cs) public payable {\n        require(Channels[do].da == true, \"Tried adding funds to a closed channel\");\n        require(bn == Channels[do].r[0] || bn == Channels[do].r[1]);\n\n\n        if (Channels[do].r[0] == bn) {\n            if(cs) {\n                require(Channels[do].ds.aj(msg.sender, this, cg),\"deposit: token transfer failure\");\n                Channels[do].v[2] += cg;\n            } else {\n                require(msg.value == cg, \"state balance does not match sent value\");\n                Channels[do].au[2] += msg.value;\n            }\n        }\n\n        if (Channels[do].r[1] == bn) {\n            if(cs) {\n                require(Channels[do].ds.aj(msg.sender, this, cg),\"deposit: token transfer failure\");\n                Channels[do].v[3] += cg;\n            } else {\n                require(msg.value == cg, \"state balance does not match sent value\");\n                Channels[do].au[3] += msg.value;\n            }\n        }\n\n        emit DidLCDeposit(do, bn, cg, cs);\n    }\n\n\n    function d(\n        bytes32 do,\n        uint256 by,\n        uint256[4] bx,\n        string dk,\n        string dv\n    )\n        public\n    {\n\n\n        require(Channels[do].da == true);\n        uint256 m = Channels[do].q[0] + Channels[do].au[2] + Channels[do].au[3];\n        uint256 j = Channels[do].q[1] + Channels[do].v[2] + Channels[do].v[3];\n        require(m == bx[0] + bx[1]);\n        require(j == bx[2] + bx[3]);\n\n        bytes32 dg = bv(\n            abi.am(\n                do,\n                true,\n                by,\n                uint256(0),\n                bytes32(0x0),\n                Channels[do].r[0],\n                Channels[do].r[1],\n                bx[0],\n                bx[1],\n                bx[2],\n                bx[3]\n            )\n        );\n\n        require(Channels[do].r[0] == ECTools.w(dg, dk));\n        require(Channels[do].r[1] == ECTools.w(dg, dv));\n\n        Channels[do].da = false;\n\n        if(bx[0] != 0 || bx[1] != 0) {\n            Channels[do].r[0].transfer(bx[0]);\n            Channels[do].r[1].transfer(bx[1]);\n        }\n\n        if(bx[2] != 0 || bx[3] != 0) {\n            require(Channels[do].ds.transfer(Channels[do].r[0], bx[2]),\"happyCloseChannel: token transfer failure\");\n            require(Channels[do].ds.transfer(Channels[do].r[1], bx[3]),\"happyCloseChannel: token transfer failure\");\n        }\n\n        ar--;\n\n        emit DidLCClose(do, by, bx[0], bx[1], bx[2], bx[3]);\n    }\n\n\n    function ad(\n        bytes32 do,\n        uint256[6] af,\n        bytes32 ck,\n        string dk,\n        string dv\n    )\n        public\n    {\n        Channel storage co = Channels[do];\n        require(co.da);\n        require(co.cb < af[0]);\n        require(co.au[0] + co.au[1] >= af[2] + af[3]);\n        require(co.v[0] + co.v[1] >= af[4] + af[5]);\n\n        if(co.h == true) {\n            require(co.l > eg);\n        }\n\n        bytes32 dg = bv(\n            abi.am(\n                do,\n                false,\n                af[0],\n                af[1],\n                ck,\n                co.r[0],\n                co.r[1],\n                af[2],\n                af[3],\n                af[4],\n                af[5]\n            )\n        );\n\n        require(co.r[0] == ECTools.w(dg, dk));\n        require(co.r[1] == ECTools.w(dg, dv));\n\n\n        co.cb = af[0];\n        co.bq = af[1];\n        co.au[0] = af[2];\n        co.au[1] = af[3];\n        co.v[0] = af[4];\n        co.v[1] = af[5];\n        co.VCrootHash = ck;\n        co.h = true;\n        co.l = eg + co.ap;\n\n\n        emit DidLCUpdateState (\n            do,\n            af[0],\n            af[1],\n            af[2],\n            af[3],\n            af[4],\n            af[5],\n            ck,\n            co.l\n        );\n    }\n\n\n    function ax(\n        bytes32 do,\n        bytes32 dn,\n        bytes dj,\n        address cn,\n        address cv,\n        uint256[2] dp,\n        uint256[4] bx,\n        string dy\n    )\n        public\n    {\n        require(Channels[do].da, \"LC is closed.\");\n\n        require(!k[dn].cq, \"VC is closed.\");\n\n        require(Channels[do].l < eg, \"LC timeout not over.\");\n\n        require(k[dn].n == 0);\n\n        bytes32 ba = bv(\n            abi.am(dn, uint256(0), cn, cv, dp[0], dp[1], bx[0], bx[1], bx[2], bx[3])\n        );\n\n\n        require(cn == ECTools.w(ba, dy));\n\n\n        require(ah(ba, dj, Channels[do].VCrootHash) == true);\n\n        k[dn].df = cn;\n        k[dn].di = cv;\n        k[dn].cb = uint256(0);\n        k[dn].au[0] = bx[0];\n        k[dn].au[1] = bx[1];\n        k[dn].v[0] = bx[2];\n        k[dn].v[1] = bx[3];\n        k[dn].ee = dp;\n        k[dn].n = eg + Channels[do].ap;\n        k[dn].f = true;\n\n        emit DidVCInit(do, dn, dj, uint256(0), cn, cv, bx[0], bx[1]);\n    }\n\n\n    function bz(\n        bytes32 do,\n        bytes32 dn,\n        uint256 bu,\n        address cn,\n        address cv,\n        uint256[4] bj,\n        string dy\n    )\n        public\n    {\n        require(Channels[do].da, \"LC is closed.\");\n\n        require(!k[dn].cq, \"VC is closed.\");\n        require(k[dn].cb < bu, \"VC sequence is higher than update sequence.\");\n        require(\n            k[dn].au[1] < bj[1] && k[dn].v[1] < bj[3],\n            \"State updates may only increase recipient balance.\"\n        );\n        require(\n            k[dn].ee[0] == bj[0] + bj[1] &&\n            k[dn].ee[1] == bj[2] + bj[3],\n            \"Incorrect balances for bonded amount\");\n\n\n        require(Channels[do].l < eg);\n\n        bytes32 an = bv(\n            abi.am(\n                dn,\n                bu,\n                cn,\n                cv,\n                k[dn].ee[0],\n                k[dn].ee[1],\n                bj[0],\n                bj[1],\n                bj[2],\n                bj[3]\n            )\n        );\n\n\n        require(k[dn].df == ECTools.w(an, dy));\n\n\n        k[dn].bd = msg.sender;\n        k[dn].cb = bu;\n\n\n        k[dn].au[0] = bj[0];\n        k[dn].au[1] = bj[1];\n        k[dn].v[0] = bj[2];\n        k[dn].v[1] = bj[3];\n\n        k[dn].n = eg + Channels[do].ap;\n\n        emit DidVCSettle(do, dn, bu, bj[0], bj[1], msg.sender, k[dn].n);\n    }\n\n    function g(bytes32 do, bytes32 dn) public {\n\n        require(Channels[do].da, \"LC is closed.\");\n        require(k[dn].f, \"VC is not in settlement state.\");\n        require(k[dn].n < eg, \"Update vc timeout has not elapsed.\");\n        require(!k[dn].cq, \"VC is already closed\");\n\n        Channels[do].bq--;\n\n        k[dn].cq = true;\n\n\n        if(k[dn].df == Channels[do].r[0]) {\n            Channels[do].au[0] += k[dn].au[0];\n            Channels[do].au[1] += k[dn].au[1];\n\n            Channels[do].v[0] += k[dn].v[0];\n            Channels[do].v[1] += k[dn].v[1];\n        } else if (k[dn].di == Channels[do].r[0]) {\n            Channels[do].au[0] += k[dn].au[1];\n            Channels[do].au[1] += k[dn].au[0];\n\n            Channels[do].v[0] += k[dn].v[1];\n            Channels[do].v[1] += k[dn].v[0];\n        }\n\n        emit DidVCClose(do, dn, k[dn].v[0], k[dn].v[1]);\n    }\n\n\n    function e(bytes32 do) public {\n        Channel storage co = Channels[do];\n\n\n        require(co.da, \"Channel is not open\");\n        require(co.h == true);\n        require(co.bq == 0);\n        require(co.l < eg, \"LC timeout over.\");\n\n\n        uint256 m = co.q[0] + co.au[2] + co.au[3];\n        uint256 j = co.q[1] + co.v[2] + co.v[3];\n\n        uint256 b = co.au[0] + co.au[1];\n        uint256 a = co.v[0] + co.v[1];\n\n        if(b < m) {\n            co.au[0]+=co.au[2];\n            co.au[1]+=co.au[3];\n        } else {\n            require(b == m);\n        }\n\n        if(a < j) {\n            co.v[0]+=co.v[2];\n            co.v[1]+=co.v[3];\n        } else {\n            require(a == j);\n        }\n\n        uint256 at = co.au[0];\n        uint256 ay = co.au[1];\n        uint256 aa = co.v[0];\n        uint256 z = co.v[1];\n\n        co.au[0] = 0;\n        co.au[1] = 0;\n        co.v[0] = 0;\n        co.v[1] = 0;\n\n        if(at != 0 || ay != 0) {\n            co.r[0].transfer(at);\n            co.r[1].transfer(ay);\n        }\n\n        if(aa != 0 || z != 0) {\n            require(\n                co.ds.transfer(co.r[0], aa),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n            require(\n                co.ds.transfer(co.r[1], z),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n        }\n\n        co.da = false;\n        ar--;\n\n        emit DidLCClose(do, co.cb, at, ay, aa, z);\n    }\n\n    function ah(bytes32 dm, bytes dj, bytes32 dr) internal pure returns (bool) {\n        bytes32 de = dm;\n        bytes32 br;\n\n        for (uint256 i = 64; i <= dj.length; i += 32) {\n            assembly { br := mload(add(dj, i)) }\n\n            if (de < br) {\n                de = bv(abi.am(de, br));\n            } else {\n                de = bv(abi.am(br, de));\n            }\n        }\n\n        return de == dr;\n    }\n\n\n    function az(bytes32 ek) public view returns (\n        address[2],\n        uint256[4],\n        uint256[4],\n        uint256[2],\n        uint256,\n        uint256,\n        bytes32,\n        uint256,\n        uint256,\n        bool,\n        bool,\n        uint256\n    ) {\n        Channel memory co = Channels[ek];\n        return (\n            co.r,\n            co.au,\n            co.v,\n            co.q,\n            co.cb,\n            co.ap,\n            co.VCrootHash,\n            co.LCopenTimeout,\n            co.l,\n            co.da,\n            co.h,\n            co.bq\n        );\n    }\n\n    function i(bytes32 ek) public view returns(\n        bool,\n        bool,\n        uint256,\n        address,\n        uint256,\n        address,\n        address,\n        address,\n        uint256[2],\n        uint256[2],\n        uint256[2]\n    ) {\n        VirtualChannel memory o = k[ek];\n        return(\n            o.cq,\n            o.f,\n            o.cb,\n            o.bd,\n            o.n,\n            o.df,\n            o.di,\n            o.dc,\n            o.au,\n            o.v,\n            o.ee\n        );\n    }\n}",
      "rename_map": {
        "possibleTotalTokenBeforeDeposit": "a",
        "possibleTotalEthBeforeDeposit": "b",
        "toEthereumSignedMessage": "c",
        "consensusCloseChannel": "d",
        "byzantineCloseChannel": "e",
        "isInSettlementState": "f",
        "closeVirtualChannel": "g",
        "isUpdateLCSettling": "h",
        "getVirtualChannel": "i",
        "totalTokenDeposit": "j",
        "virtualChannels": "k",
        "updateLCtimeout": "l",
        "totalEthDeposit": "m",
        "updateVCtimeout": "n",
        "virtualChannel": "o",
        "parseInt16Char": "p",
        "initialDeposit": "q",
        "partyAddresses": "r",
        "approveAndCall": "s",
        "_initialAmount": "t",
        "tokenBalanceI": "u",
        "erc20Balances": "v",
        "recoverSigner": "w",
        "hexstrToBytes": "x",
        "_decimalUnits": "y",
        "tokenbalanceI": "z",
        "tokenbalanceA": "aa",
        "uintToBytes32": "ab",
        "tokenBalanceA": "ac",
        "updateLCstate": "ad",
        "createChannel": "ae",
        "updateParams": "af",
        "_tokenSymbol": "ag",
        "_isContained": "ah",
        "prefixedHash": "ai",
        "transferFrom": "aj",
        "_confirmTime": "ak",
        "uintToString": "al",
        "encodePacked": "am",
        "_updateState": "an",
        "totalSupply": "ao",
        "confirmTime": "ap",
        "joinChannel": "aq",
        "numChannels": "ar",
        "ethBalanceA": "as",
        "ethbalanceA": "at",
        "ethBalances": "au",
        "ethBalanceI": "av",
        "_startIndex": "aw",
        "initVCstate": "ax",
        "ethbalanceI": "ay",
        "getChannel": "az",
        "_initState": "ba",
        "_tokenName": "bb",
        "_extraData": "bc",
        "challenger": "bd",
        "_hashedMsg": "be",
        "isSignedBy": "bf",
        "updateBalB": "bg",
        "updateBalA": "bh",
        "ecrecover": "bi",
        "updateBal": "bj",
        "channelId": "bk",
        "numOpenVc": "bl",
        "_endIndex": "bm",
        "recipient": "bn",
        "substring": "bo",
        "remaining": "bp",
        "numOpenVC": "bq",
        "proofElem": "br",
        "remainder": "bs",
        "allowance": "bt",
        "updateSeq": "bu",
        "keccak256": "bv",
        "balanceOf": "bw",
        "_balances": "bx",
        "_sequence": "by",
        "settleVC": "bz",
        "balanceA": "ca",
        "sequence": "cb",
        "_spender": "cc",
        "balanceB": "cd",
        "balances": "ce",
        "decimals": "cf",
        "_balance": "cg",
        "strBytes": "ch",
        "bresult": "ci",
        "_partyI": "cj",
        "_VCroot": "ck",
        "deposit": "cl",
        "version": "cm",
        "_partyA": "cn",
        "channel": "co",
        "success": "cp",
        "isClose": "cq",
        "allowed": "cr",
        "isToken": "cs",
        "approve": "ct",
        "_hexstr": "cu",
        "_partyB": "cv",
        "vcRoot": "cw",
        "_owner": "cx",
        "result": "cy",
        "_value": "cz",
        "isOpen": "da",
        "_token": "db",
        "partyI": "dc",
        "prefix": "dd",
        "cursor": "de",
        "partyA": "df",
        "_state": "dg",
        "symbol": "dh",
        "partyB": "di",
        "_proof": "dj",
        "_sigA": "dk",
        "_from": "dl",
        "_hash": "dm",
        "_vcID": "dn",
        "_lcID": "do",
        "_bond": "dp",
        "proof": "dq",
        "_root": "dr",
        "token": "ds",
        "_addr": "dt",
        "_uint": "du",
        "_sigI": "dv",
        "_char": "dw",
        "name": "dx",
        "sigA": "dy",
        "_msg": "dz",
        "bstr": "ea",
        "lcId": "eb",
        "vcId": "ec",
        "_sig": "ed",
        "bond": "ee",
        "_str": "ef",
        "now": "eg",
        "str": "eh",
        "_to": "ei",
        "len": "ej",
        "id": "ek"
      },
      "changes": [
        "Renamed 141 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_115",
      "transformed_id": "ss_l2_short_nc_ds_115",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.4.15;\n\ncontract Token {\n\n    uint256 public f;\n\n\n    function i(address u) constant returns (uint256 balance);\n\n\n    function transfer(address y, uint256 t) returns (bool o);\n\n\n    function e(address v, address y, uint256 t) returns (bool o);\n\n\n    function r(address l, uint256 t) returns (bool o);\n\n\n    function k(address u, address l) constant returns (uint256 j);\n\n    event Transfer(address indexed v, address indexed y, uint256 t);\n    event Approval(address indexed u, address indexed l, uint256 t);\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address y, uint256 t) returns (bool o) {\n\n\n        require(m[msg.sender] >= t);\n        m[msg.sender] -= t;\n        m[y] += t;\n        Transfer(msg.sender, y, t);\n        return true;\n    }\n\n    function e(address v, address y, uint256 t) returns (bool o) {\n\n\n        require(m[v] >= t && q[v][msg.sender] >= t);\n        m[y] += t;\n        m[v] -= t;\n        q[v][msg.sender] -= t;\n        Transfer(v, y, t);\n        return true;\n    }\n\n    function i(address u) constant returns (uint256 balance) {\n        return m[u];\n    }\n\n    function r(address l, uint256 t) returns (bool o) {\n        q[msg.sender][l] = t;\n        Approval(msg.sender, l, t);\n        return true;\n    }\n\n    function k(address u, address l) constant returns (uint256 j) {\n      return q[u][l];\n    }\n\n    mapping (address => uint256) m;\n    mapping (address => mapping (address => uint256)) q;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n\n    string public w;\n    uint8 public n;\n    string public s;\n    string public p = 'H0.1';\n\n    function HumanStandardToken(\n        uint256 b,\n        string g,\n        uint8 c,\n        string d\n        ) {\n        m[msg.sender] = b;\n        f = b;\n        w = g;\n        n = c;\n        s = d;\n    }\n\n\n    function a(address l, uint256 t, bytes h) returns (bool o) {\n        q[msg.sender][l] = t;\n        Approval(msg.sender, l, t);\n\n\n        require(l.call(bytes4(bytes32(x(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, t, this, h));\n        return true;\n    }\n}",
      "rename_map": {
        "approveAndCall": "a",
        "_initialAmount": "b",
        "_decimalUnits": "c",
        "_tokenSymbol": "d",
        "transferFrom": "e",
        "totalSupply": "f",
        "_tokenName": "g",
        "_extraData": "h",
        "balanceOf": "i",
        "remaining": "j",
        "allowance": "k",
        "_spender": "l",
        "balances": "m",
        "decimals": "n",
        "success": "o",
        "version": "p",
        "allowed": "q",
        "approve": "r",
        "symbol": "s",
        "_value": "t",
        "_owner": "u",
        "_from": "v",
        "name": "w",
        "sha3": "x",
        "_to": "y"
      },
      "changes": [
        "Renamed 25 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_116",
      "transformed_id": "ss_l2_short_nc_ds_116",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Missing{\n    address private c;\n\n    modifier a {\n        require(msg.sender==c);\n        _;\n    }\n\n\n    function IamMissing()\n        public\n    {\n        c = msg.sender;\n    }\n\n    function b()\n        public\n        a\n    {\n       c.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "a",
        "withdraw": "b",
        "owner": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_117",
      "transformed_id": "ss_l2_short_nc_ds_117",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Rubixi {\n\n\n        uint private balance = 0;\n        uint private q = 0;\n        uint private z = 10;\n        uint private j = 300;\n        uint private x = 0;\n\n        address private ac;\n\n\n        function DynamicPyramid() {\n                ac = msg.sender;\n        }\n\n        modifier aa {\n                if (msg.sender == ac) _;\n        }\n\n        struct Participant {\n                address v;\n                uint ae;\n        }\n\n        Participant[] private u;\n\n\n        function() {\n                aj();\n        }\n\n\n        function aj() private {\n\n                if (msg.value < 1 ether) {\n                        q += msg.value;\n                        return;\n                }\n\n                uint am = z;\n\n                if (msg.value >= 50 ether) am /= 2;\n\n                ab(am);\n        }\n\n\n        function ab(uint am) private {\n\n                u.push(Participant(msg.sender, (msg.value * j) / 100));\n\n\n                if (u.length == 10) j = 200;\n                else if (u.length == 25) j = 150;\n\n\n                balance += (msg.value * (100 - am)) / 100;\n                q += (msg.value * am) / 100;\n\n\n                while (balance > u[x].ae) {\n                        uint t = u[x].ae;\n                        u[x].v.send(t);\n\n                        balance -= u[x].ae;\n                        x += 1;\n                }\n        }\n\n\n        function n() aa {\n                if (q == 0) throw;\n\n                ac.send(q);\n                q = 0;\n        }\n\n        function i(uint al) aa {\n                al *= 1 ether;\n                if (al > q) n();\n\n                if (q == 0) throw;\n\n                ac.send(al);\n                q -= al;\n        }\n\n        function f(uint ad) aa {\n                if (q == 0 || ad > 100) throw;\n\n                uint s = q / 100 * ad;\n                ac.send(s);\n                q -= s;\n        }\n\n\n        function w(address af) aa {\n                ac = af;\n        }\n\n        function m(uint ag) aa {\n                if (ag > 300 || ag < 120) throw;\n\n                j = ag;\n        }\n\n        function g(uint am) aa {\n                if (am > 10) throw;\n\n                z = am;\n        }\n\n\n        function k() constant returns(uint y, string ai) {\n                y = j;\n                ai = 'This y applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, y is x100 for a fractional y e.g. 250 is actually a 2.5x y. Capped at 3x max and 1.2x min.';\n        }\n\n        function e() constant returns(uint an, string ai) {\n                an = z;\n                ai = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n        }\n\n        function d() constant returns(uint p, string ai) {\n                p = balance / 1 ether;\n                ai = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n        }\n\n        function a() constant returns(uint r) {\n                r = u[x].ae / 1 ether;\n        }\n\n        function b() constant returns(uint ak) {\n                ak = q / 1 ether;\n        }\n\n        function l() constant returns(uint ah) {\n                ah = u.length;\n        }\n\n        function c() constant returns(uint ah) {\n                ah = u.length - x;\n        }\n\n        function h(uint o) constant returns(address Address, uint Payout) {\n                if (o <= u.length) {\n                        Address = u[o].v;\n                        Payout = u[o].ae / 1 ether;\n                }\n        }\n}",
      "rename_map": {
        "nextPayoutWhenPyramidBalanceTotalsApproximately": "a",
        "feesSeperateFromBalanceApproximately": "b",
        "numberOfParticipantsWaitingForPayout": "c",
        "currentPyramidBalanceApproximately": "d",
        "currentFeePercentage": "e",
        "collectPercentOfFees": "f",
        "changeFeePercentage": "g",
        "participantDetails": "h",
        "collectFeesInEther": "i",
        "pyramidMultiplier": "j",
        "currentMultiplier": "k",
        "totalParticipants": "l",
        "changeMultiplier": "m",
        "collectAllFees": "n",
        "orderInPyramid": "o",
        "pyramidBalance": "p",
        "collectedFees": "q",
        "balancePayout": "r",
        "feesToCollect": "s",
        "payoutToSend": "t",
        "participants": "u",
        "etherAddress": "v",
        "changeOwner": "w",
        "payoutOrder": "x",
        "multiplier": "y",
        "feePercent": "z",
        "onlyowner": "aa",
        "addPayout": "ab",
        "creator": "ac",
        "_pcent": "ad",
        "payout": "ae",
        "_owner": "af",
        "_mult": "ag",
        "count": "ah",
        "info": "ai",
        "init": "aj",
        "fees": "ak",
        "_amt": "al",
        "_fee": "am",
        "fee": "an"
      },
      "changes": [
        "Renamed 40 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_118",
      "transformed_id": "ss_l2_short_nc_ds_118",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "contract Destructible {\n  address a;\n  function suicide() public returns (address) {\n    require(a == msg.sender);\n    selfdestruct(a);\n  }\n}\ncontract C is Destructible {\n  address a;\n  function C() {\n    a = msg.sender;\n  }\n}",
      "rename_map": {
        "owner": "a"
      },
      "changes": [
        "Renamed 1 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_119",
      "transformed_id": "ss_l2_short_nc_ds_119",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n\n        address s;\n\n\n        string ab;\n\n        uint w;\n\n        uint c;\n    }\n\n\n    address o;\n\n\n    modifier v { if (msg.sender == o) _; }\n\n\n    uint constant g = 100 finney;\n\n\n    uint constant f = 3;\n    uint constant e = 2;\n\n\n    uint constant a = 1;\n    uint constant b = 100;\n\n\n    uint public h;\n\n\n    Monarch public n;\n\n\n    Monarch[] public r;\n\n\n    function KingOfTheEtherThrone() {\n        o = msg.sender;\n        h = g;\n        n = Monarch(\n            o,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function j() constant returns (uint n) {\n        return r.length;\n    }\n\n\n    event ThroneClaimed(\n        address d,\n        string t,\n        uint p\n    );\n\n\n    function() {\n        u(string(msg.data));\n    }\n\n\n    function u(string ab) {\n\n        uint y = msg.value;\n\n\n        if (y < h) {\n            msg.sender.send(y);\n            return;\n        }\n\n\n        if (y > h) {\n            uint x = y - h;\n            msg.sender.send(x);\n            y = y - x;\n        }\n\n\n        uint l = (y * a) / b;\n\n        uint q = y - l;\n\n        if (n.s != o) {\n            n.s.send(q);\n        } else {\n\n        }\n\n\n        r.push(n);\n        n = Monarch(\n            msg.sender,\n            ab,\n            y,\n            block.timestamp\n        );\n\n\n        uint k = h * f / e;\n        if (k < 10 finney) {\n            h = k;\n        } else if (k < 100 finney) {\n            h = 100 szabo * (k / 100 szabo);\n        } else if (k < 1 ether) {\n            h = 1 finney * (k / 1 finney);\n        } else if (k < 10 ether) {\n            h = 10 finney * (k / 10 finney);\n        } else if (k < 100 ether) {\n            h = 100 finney * (k / 100 finney);\n        } else if (k < 1000 ether) {\n            h = 1 ether * (k / 1 ether);\n        } else if (k < 10000 ether) {\n            h = 10 ether * (k / 10 ether);\n        } else {\n            h = k;\n        }\n\n\n        ThroneClaimed(n.s, n.ab, h);\n    }\n\n\n    function m(uint aa) v {\n        o.send(aa);\n    }\n\n\n    function i(address z) v {\n        o = z;\n    }\n\n}",
      "rename_map": {
        "wizardCommissionFractionNum": "a",
        "wizardCommissionFractionDen": "b",
        "coronationTimestamp": "c",
        "usurperEtherAddress": "d",
        "claimPriceAdjustDen": "e",
        "claimPriceAdjustNum": "f",
        "startingClaimPrice": "g",
        "currentClaimPrice": "h",
        "transferOwnership": "i",
        "numberOfMonarchs": "j",
        "rawNewClaimPrice": "k",
        "wizardCommission": "l",
        "sweepCommission": "m",
        "currentMonarch": "n",
        "wizardAddress": "o",
        "newClaimPrice": "p",
        "compensation": "q",
        "pastMonarchs": "r",
        "etherAddress": "s",
        "usurperName": "t",
        "claimThrone": "u",
        "onlywizard": "v",
        "claimPrice": "w",
        "excessPaid": "x",
        "valuePaid": "y",
        "newOwner": "z",
        "amount": "aa",
        "name": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_120",
      "transformed_id": "ss_l2_short_nc_ds_120",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract CrowdFundBasic {\n  address[] private a;\n  mapping(address => uint) public c;\n\n  function d() public {\n    for(uint i; i < a.length; i++) {\n      require(a[i].transfer(c[a[i]]));\n    }\n  }\n}\n\ncontract CrowdFundPull {\n  address[] private a;\n  mapping(address => uint) public c;\n\n  function e() external {\n    uint g = c[msg.sender];\n    c[msg.sender] = 0;\n    msg.sender.transfer(g);\n  }\n}\n\ncontract CrowdFundBatched {\n  address[] private a;\n  mapping(address => uint) public c;\n  uint256 f;\n\n  function b() public {\n    uint256 i = f;\n    while(i < a.length && msg.gas > 200000) {\n      a[i].transfer(c[i]);\n      i++;\n    }\n    f = i;\n  }\n}",
      "rename_map": {
        "refundAddresses": "a",
        "refundBatched": "b",
        "refundAmount": "c",
        "refundAll": "d",
        "withdraw": "e",
        "nextIdx": "f",
        "refund": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_121",
      "transformed_id": "ss_l2_short_nc_ds_121",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address a;\n  uint b;\n\n  function f() payable {\n    require(msg.value > b);\n\n\n    if (a != 0) {\n\n      require(a.send(b));\n    }\n\n    a = msg.sender;\n    b         = msg.value;\n  }\n}\n\ncontract AuctionV2 {\n  address a;\n  uint    b;\n\n  mapping(address => uint) d;\n\n\n  function f() payable external {\n    require(msg.value > b);\n\n    if (a != 0) {\n      d[a] += b;\n    }\n\n    a = msg.sender;\n    b         = msg.value;\n  }\n\n\n  function c() external {\n\n    uint e = d[msg.sender];\n    d[msg.sender] = 0;\n\n    msg.sender.send(e);\n  }\n}",
      "rename_map": {
        "currentFrontrunner": "a",
        "currentBid": "b",
        "withdraw": "c",
        "refunds": "d",
        "refund": "e",
        "bid": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_122",
      "transformed_id": "ss_l2_short_nc_ds_122",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\ncontract WalletEvents {\n\n\n  event Confirmation(address bp, bytes32 ag);\n  event Revoke(address bp, bytes32 ag);\n\n\n  event OwnerChanged(address at, address an);\n  event OwnerAdded(address an);\n  event OwnerRemoved(address at);\n\n\n  event RequirementChanged(uint i);\n\n\n  event Deposit(address bk, uint value);\n\n  event SingleTransact(address bp, uint value, address bx, bytes data, address aw);\n\n  event MultiTransact(address bp, bytes32 ag, uint value, address bx, bytes data, address aw);\n\n  event ConfirmationNeeded(bytes32 ag, address ai, uint value, address bx, bytes data);\n}\n\ncontract WalletAbi {\n\n  function bg(bytes32 ab) external;\n\n\n  function u(address bk, address bv) external;\n\n  function as(address bd) external;\n\n  function w(address bd) external;\n\n  function a(uint p) external;\n\n  function az(address bm) constant returns (bool);\n\n  function n(bytes32 ab, address bd) external constant returns (bool);\n\n\n  function k(uint ah) external;\n\n  function au(address bv, uint be, bytes bq) external returns (bytes32 bf);\n  function ba(bytes32 by) returns (bool am);\n}\n\ncontract WalletLibrary is WalletEvents {\n\n\n  struct PendingState {\n    uint aj;\n    uint aa;\n    uint bn;\n  }\n\n\n  struct Transaction {\n    address bx;\n    uint value;\n    bytes data;\n  }\n\n\n  modifier af {\n    if (az(msg.sender))\n      _;\n  }\n\n\n  modifier g(bytes32 ab) {\n    if (e(ab))\n      _;\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n\n  function f(address[] ay, uint ak) {\n    t = ay.length + 1;\n    aq[1] = uint(msg.sender);\n    s[uint(msg.sender)] = 1;\n    for (uint i = 0; i < ay.length; ++i)\n    {\n      aq[2 + i] = uint(ay[i]);\n      s[uint(ay[i])] = 2 + i;\n    }\n    z = ak;\n  }\n\n\n  function bg(bytes32 ab) external {\n    uint x = s[uint(msg.sender)];\n\n    if (x == 0) return;\n    uint j = 2**x;\n    var ax = ad[ab];\n    if (ax.aa & j > 0) {\n      ax.aj++;\n      ax.aa -= j;\n      Revoke(msg.sender, ab);\n    }\n  }\n\n\n  function u(address bk, address bv) g(bt(msg.data)) external {\n    if (az(bv)) return;\n    uint x = s[uint(bk)];\n    if (x == 0) return;\n\n    o();\n    aq[x] = uint(bv);\n    s[uint(bk)] = 0;\n    s[uint(bv)] = x;\n    OwnerChanged(bk, bv);\n  }\n\n  function as(address bd) g(bt(msg.data)) external {\n    if (az(bd)) return;\n\n    o();\n    if (t >= v)\n      b();\n    if (t >= v)\n      return;\n    t++;\n    aq[t] = uint(bd);\n    s[uint(bd)] = t;\n    OwnerAdded(bd);\n  }\n\n  function w(address bd) g(bt(msg.data)) external {\n    uint x = s[uint(bd)];\n    if (x == 0) return;\n    if (z > t - 1) return;\n\n    aq[x] = 0;\n    s[uint(bd)] = 0;\n    o();\n    b();\n    OwnerRemoved(bd);\n  }\n\n  function a(uint p) g(bt(msg.data)) external {\n    if (p > t) return;\n    z = p;\n    o();\n    RequirementChanged(p);\n  }\n\n\n  function ap(uint x) external constant returns (address) {\n    return address(aq[x + 1]);\n  }\n\n  function az(address bm) constant returns (bool) {\n    return s[uint(bm)] > 0;\n  }\n\n  function n(bytes32 ab, address bd) external constant returns (bool) {\n    var ax = ad[ab];\n    uint x = s[uint(bd)];\n\n\n    if (x == 0) return false;\n\n\n    uint j = 2**x;\n    return !(ax.aa & j == 0);\n  }\n\n\n  function l(uint bh) {\n    m = bh;\n    ae = br();\n  }\n\n  function k(uint ah) g(bt(msg.data)) external {\n    m = ah;\n  }\n\n  function d() g(bt(msg.data)) external {\n    q = 0;\n  }\n\n\n  function ac(address[] ay, uint ak, uint al) {\n    l(al);\n    f(ay, ak);\n  }\n\n\n  function bu(address bv) g(bt(msg.data)) external {\n    suicide(bv);\n  }\n\n\n  function au(address bv, uint be, bytes bq) external af returns (bytes32 bf) {\n\n    if ((bq.length == 0 && y(be)) || z == 1) {\n\n      address aw;\n      if (bv == 0) {\n        aw = bc(be, bq);\n      } else {\n        if (!bv.call.value(be)(bq))\n          throw;\n      }\n      SingleTransact(msg.sender, be, bv, bq, aw);\n    } else {\n\n      bf = bt(msg.data, block.number);\n\n      if (bl[bf].bx == 0 && bl[bf].value == 0 && bl[bf].data.length == 0) {\n        bl[bf].bx = bv;\n        bl[bf].value = be;\n        bl[bf].data = bq;\n      }\n      if (!ba(bf)) {\n        ConfirmationNeeded(bf, msg.sender, be, bv, bq);\n      }\n    }\n  }\n\n  function bc(uint be, bytes bo) internal returns (address bb) {\n    assembly {\n      bb := bc(be, add(bo, 0x20), mload(bo))\n      bj(c, iszero(extcodesize(bb)))\n    }\n  }\n\n\n  function ba(bytes32 by) g(by) returns (bool am) {\n    if (bl[by].bx != 0 || bl[by].value != 0 || bl[by].data.length != 0) {\n      address aw;\n      if (bl[by].bx == 0) {\n        aw = bc(bl[by].value, bl[by].data);\n      } else {\n        if (!bl[by].bx.call.value(bl[by].value)(bl[by].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, by, bl[by].value, bl[by].bx, bl[by].data, aw);\n      delete bl[by];\n      return true;\n    }\n  }\n\n\n  function e(bytes32 ab) internal returns (bool) {\n\n    uint x = s[uint(msg.sender)];\n\n    if (x == 0) return;\n\n    var ax = ad[ab];\n\n    if (ax.aj == 0) {\n\n      ax.aj = z;\n\n      ax.aa = 0;\n      ax.bn = h.length++;\n      h[ax.bn] = ab;\n    }\n\n    uint j = 2**x;\n\n    if (ax.aa & j == 0) {\n      Confirmation(msg.sender, ab);\n\n      if (ax.aj <= 1) {\n\n        delete h[ad[ab].bn];\n        delete ad[ab];\n        return true;\n      }\n      else\n      {\n\n        ax.aj--;\n        ax.aa |= j;\n      }\n    }\n  }\n\n  function b() private {\n    uint bs = 1;\n    while (bs < t)\n    {\n      while (bs < t && aq[bs] != 0) bs++;\n      while (t > 1 && aq[t] == 0) t--;\n      if (bs < t && aq[t] != 0 && aq[bs] == 0)\n      {\n        aq[bs] = aq[t];\n        s[aq[bs]] = bs;\n        aq[t] = 0;\n      }\n    }\n  }\n\n\n  function y(uint be) internal af returns (bool) {\n\n    if (br() > ae) {\n      q = 0;\n      ae = br();\n    }\n\n\n    if (q + be >= q && q + be <= m) {\n      q += be;\n      return true;\n    }\n    return false;\n  }\n\n\n  function br() private constant returns (uint) { return bw / 1 days; }\n\n  function o() internal {\n    uint length = h.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete bl[h[i]];\n\n      if (h[i] != 0)\n        delete ad[h[i]];\n    }\n\n    delete h;\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public z;\n\n  uint public t;\n\n  uint public m;\n  uint public q;\n  uint public ae;\n\n\n  uint[256] aq;\n\n  uint constant v = 250;\n\n  mapping(uint => uint) s;\n\n  mapping(bytes32 => PendingState) ad;\n  bytes32[] h;\n\n\n  mapping (bytes32 => Transaction) bl;\n}\n\ncontract Wallet is WalletEvents {\n\n\n  function Wallet(address[] ay, uint ak, uint al) {\n\n    bytes4 sig = bytes4(bt(\"initWallet(address[],uint256,uint256)\"));\n    address bi = _walletLibrary;\n\n\n    uint r = (2 + ay.length);\n    uint av = (2 + r) * 32;\n\n    assembly {\n\n      mstore(0x0, sig)\n\n\n      ar(0x4,  sub(ao, av), av)\n\n      delegatecall(sub(gas, 10000), bi, 0x0, add(av, 0x4), 0x0, 0x0)\n    }\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n\n  function ap(uint x) constant returns (address) {\n    return address(aq[x + 1]);\n  }\n\n\n  function n(bytes32 ab, address bd) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function az(address bm) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public z;\n\n  uint public t;\n\n  uint public m;\n  uint public q;\n  uint public ae;\n\n\n  uint[256] aq;\n}",
      "rename_map": {
        "changeRequirement": "a",
        "reorganizeOwners": "b",
        "invalidJumpLabel": "c",
        "resetSpentToday": "d",
        "confirmAndCheck": "e",
        "initMultiowned": "f",
        "onlymanyowners": "g",
        "m_pendingIndex": "h",
        "newRequirement": "i",
        "ownerIndexBit": "j",
        "setDailyLimit": "k",
        "initDaylimit": "l",
        "m_dailyLimit": "m",
        "hasConfirmed": "n",
        "clearPending": "o",
        "_newRequired": "p",
        "m_spentToday": "q",
        "argarraysize": "r",
        "m_ownerIndex": "s",
        "m_numOwners": "t",
        "changeOwner": "u",
        "c_maxOwners": "v",
        "removeOwner": "w",
        "ownerIndex": "x",
        "underLimit": "y",
        "m_required": "z",
        "ownersDone": "aa",
        "_operation": "ab",
        "initWallet": "ac",
        "m_pending": "ad",
        "m_lastDay": "ae",
        "onlyowner": "af",
        "operation": "ag",
        "_newLimit": "ah",
        "initiator": "ai",
        "yetNeeded": "aj",
        "_required": "ak",
        "_daylimit": "al",
        "o_success": "am",
        "newOwner": "an",
        "codesize": "ao",
        "getOwner": "ap",
        "m_owners": "aq",
        "codecopy": "ar",
        "addOwner": "as",
        "oldOwner": "at",
        "execute": "au",
        "argsize": "av",
        "created": "aw",
        "pending": "ax",
        "_owners": "ay",
        "isOwner": "az",
        "confirm": "ba",
        "o_addr": "bb",
        "create": "bc",
        "_owner": "bd",
        "_value": "be",
        "o_hash": "bf",
        "revoke": "bg",
        "_limit": "bh",
        "target": "bi",
        "jumpi": "bj",
        "_from": "bk",
        "m_txs": "bl",
        "_addr": "bm",
        "index": "bn",
        "_code": "bo",
        "owner": "bp",
        "_data": "bq",
        "today": "br",
        "free": "bs",
        "sha3": "bt",
        "kill": "bu",
        "_to": "bv",
        "now": "bw",
        "to": "bx",
        "_h": "by"
      },
      "changes": [
        "Renamed 77 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_123",
      "transformed_id": "ss_l2_short_nc_ds_123",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract ae {\n    address public ad;\n\n    function ae() public {\n        ad = msg.sender;\n    }\n\n    modifier m {\n        require(msg.sender == ad);\n        _;\n    }\n\n    function b(address q) m public {\n        ad = q;\n    }\n}\n\ninterface f { function d(address af, uint256 y, address aa, bytes k) external; }\n\ncontract TokenERC20 {\n\n    string public ag;\n    string public w;\n    uint8 public s = 18;\n\n    uint256 public i;\n\n\n    mapping (address => uint256) public n;\n    mapping (address => mapping (address => uint256)) public p;\n\n\n    event Transfer(address indexed from, address indexed aj, uint256 value);\n\n\n    event Approval(address indexed ac, address indexed r, uint256 y);\n\n    function TokenERC20(\n        string o,\n        string j\n    ) public {\n        ag = o;\n        w = j;\n    }\n\n    function l(address af, address ah, uint y) internal {\n\n        require(ah != 0x0);\n\n        require(n[af] >= y);\n\n        require(n[ah] + y > n[ah]);\n\n        uint c = n[af] + n[ah];\n\n        n[af] -= y;\n\n        n[ah] += y;\n        emit Transfer(af, ah, y);\n\n        assert(n[af] + n[ah] == c);\n    }\n\n    function transfer(address ah, uint256 y) public returns (bool t) {\n        l(msg.sender, ah, y);\n        return true;\n    }\n\n    function h(address af, address ah, uint256 y) public returns (bool t) {\n        require(y <= p[af][msg.sender]);\n        p[af][msg.sender] -= y;\n        l(af, ah, y);\n        return true;\n    }\n\n    function v(address r, uint256 y) public\n        returns (bool t) {\n        p[msg.sender][r] = y;\n        emit Approval(msg.sender, r, y);\n        return true;\n    }\n\n    function e(address r, uint256 y, bytes k)\n        public\n        returns (bool t) {\n        f u = f(r);\n        if (v(r, y)) {\n            u.d(msg.sender, y, this, k);\n            return true;\n        }\n    }\n\n}\n\n\ncontract MyAdvancedToken is ae, TokenERC20 {\n\n    mapping (address => bool) public g;\n\n\n    event FrozenFunds(address ab, bool x);\n\n\n    function MyAdvancedToken(\n        string o,\n        string j\n    ) TokenERC20(o, j) public {}\n\n\n    function l(address af, address ah, uint y) internal {\n        require (ah != 0x0);\n        require (n[af] >= y);\n        require (n[ah] + y >= n[ah]);\n        require(!g[af]);\n        require(!g[ah]);\n        n[af] -= y;\n        n[ah] += y;\n        emit Transfer(af, ah, y);\n    }\n\n\n    function ai() payable public {\n        uint z = msg.value;\n\tn[msg.sender] += z;\n        i += z;\n        l(address(0x0), msg.sender, z);\n    }\n\n\n    function a() m {\n\tassert(this.balance == i);\n\tsuicide(ad);\n    }\n}",
      "rename_map": {
        "migrate_and_destroy": "a",
        "transferOwnership": "b",
        "previousBalances": "c",
        "receiveApproval": "d",
        "approveAndCall": "e",
        "tokenRecipient": "f",
        "frozenAccount": "g",
        "transferFrom": "h",
        "totalSupply": "i",
        "tokenSymbol": "j",
        "_extraData": "k",
        "_transfer": "l",
        "onlyOwner": "m",
        "balanceOf": "n",
        "tokenName": "o",
        "allowance": "p",
        "newOwner": "q",
        "_spender": "r",
        "decimals": "s",
        "success": "t",
        "spender": "u",
        "approve": "v",
        "symbol": "w",
        "frozen": "x",
        "_value": "y",
        "amount": "z",
        "_token": "aa",
        "target": "ab",
        "_owner": "ac",
        "owner": "ad",
        "owned": "ae",
        "_from": "af",
        "name": "ag",
        "_to": "ah",
        "buy": "ai",
        "to": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_124",
      "transformed_id": "ss_l2_short_nc_ds_124",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract Alice {\n    function b(uint);\n    function a(int);\n}\n\ncontract Bob {\n    function b(Alice c){\n        c.b(42);\n    }\n\n    function a(Alice c){\n        c.a(42);\n    }\n}",
      "rename_map": {
        "setV2": "a",
        "set": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_125",
      "transformed_id": "ss_l2_short_nc_ds_125",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Missing{\n    address private c;\n\n    modifier a {\n        require(msg.sender==c);\n        _;\n    }\n\n\n    function IamMissing()\n        public\n    {\n        c = msg.sender;\n    }\n\n    function () payable {}\n\n    function b()\n        public\n        a\n    {\n       c.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "a",
        "withdraw": "b",
        "owner": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_126",
      "transformed_id": "ss_l2_short_nc_ds_126",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Missing{\n    address private d;\n\n    modifier a {\n        require(msg.sender==d);\n        _;\n    }\n    function c()\n        public\n    {\n        d = msg.sender;\n    }\n\n    function () payable {}\n\n    function b()\n        public\n        a\n    {\n       d.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "a",
        "withdraw": "b",
        "missing": "c",
        "owner": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_127",
      "transformed_id": "ss_l2_short_nc_ds_127",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract Missing{\n    address private c;\n\n    modifier a {\n        require(msg.sender==c);\n        _;\n    }\n    function Constructor()\n        public\n    {\n        c = msg.sender;\n    }\n\n    function () payable {}\n\n    function b()\n        public\n        a\n    {\n       c.transfer(this.balance);\n    }\n\n}",
      "rename_map": {
        "onlyowner": "a",
        "withdraw": "b",
        "owner": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_128",
      "transformed_id": "ss_l2_short_nc_ds_128",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract MultiOwnable {\n  address public g;\n  mapping (address => address) public f;\n\n  constructor() public {\n    g = msg.sender;\n    f[g] = g;\n  }\n\n  modifier c() {\n    require(f[msg.sender] != 0);\n    _;\n  }\n\n  function d(address e) external returns (bool) {\n    require(e != 0);\n    f[e] = msg.sender;\n    return true;\n  }\n\n  function b(address e) c external returns (bool) {\n    require(f[e] == msg.sender || (f[e] != 0 && msg.sender == g));\n    f[e] = 0;\n    return true;\n  }\n}\n\ncontract TestContract is MultiOwnable {\n\n  function a() c {\n    msg.sender.transfer(this.balance);\n  }\n\n  function() payable {\n  }\n\n}",
      "rename_map": {
        "withdrawAll": "a",
        "deleteOwner": "b",
        "onlyOwner": "c",
        "newOwner": "d",
        "_owner": "e",
        "owners": "f",
        "root": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_129",
      "transformed_id": "ss_l2_short_nc_ds_129",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n contract Rubixi {\n\n\n         uint private balance = 0;\n         uint private q = 0;\n         uint private z = 10;\n         uint private j = 300;\n         uint private x = 0;\n\n         address private ac;\n\n\n         function DynamicPyramid() {\n                 ac = msg.sender;\n         }\n\n         modifier aa {\n                 if (msg.sender == ac) _;\n         }\n\n         struct Participant {\n                 address v;\n                 uint ae;\n         }\n\n         Participant[] private u;\n\n\n         function() {\n                 aj();\n         }\n\n\n         function aj() private {\n\n                 if (msg.value < 1 ether) {\n                         q += msg.value;\n                         return;\n                 }\n\n                 uint am = z;\n\n                 if (msg.value >= 50 ether) am /= 2;\n\n                 ab(am);\n         }\n\n\n         function ab(uint am) private {\n\n                 u.push(Participant(msg.sender, (msg.value * j) / 100));\n\n\n                 if (u.length == 10) j = 200;\n                 else if (u.length == 25) j = 150;\n\n\n                 balance += (msg.value * (100 - am)) / 100;\n                 q += (msg.value * am) / 100;\n\n\n                 while (balance > u[x].ae) {\n                         uint t = u[x].ae;\n                         u[x].v.send(t);\n\n                         balance -= u[x].ae;\n                         x += 1;\n                 }\n         }\n\n\n         function n() aa {\n                 if (q == 0) throw;\n\n                 ac.send(q);\n                 q = 0;\n         }\n\n         function i(uint al) aa {\n                 al *= 1 ether;\n                 if (al > q) n();\n\n                 if (q == 0) throw;\n\n                 ac.send(al);\n                 q -= al;\n         }\n\n         function f(uint ad) aa {\n                 if (q == 0 || ad > 100) throw;\n\n                 uint s = q / 100 * ad;\n                 ac.send(s);\n                 q -= s;\n         }\n\n\n         function w(address af) aa {\n                 ac = af;\n         }\n\n         function m(uint ag) aa {\n                 if (ag > 300 || ag < 120) throw;\n\n                 j = ag;\n         }\n\n         function g(uint am) aa {\n                 if (am > 10) throw;\n\n                 z = am;\n         }\n\n\n         function k() constant returns(uint y, string ai) {\n                 y = j;\n                 ai = 'This y applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, y is x100 for a fractional y e.g. 250 is actually a 2.5x y. Capped at 3x max and 1.2x min.';\n         }\n\n         function e() constant returns(uint an, string ai) {\n                 an = z;\n                 ai = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function d() constant returns(uint p, string ai) {\n                 p = balance / 1 ether;\n                 ai = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function a() constant returns(uint r) {\n                 r = u[x].ae / 1 ether;\n         }\n\n         function b() constant returns(uint ak) {\n                 ak = q / 1 ether;\n         }\n\n         function l() constant returns(uint ah) {\n                 ah = u.length;\n         }\n\n         function c() constant returns(uint ah) {\n                 ah = u.length - x;\n         }\n\n         function h(uint o) constant returns(address Address, uint Payout) {\n                 if (o <= u.length) {\n                         Address = u[o].v;\n                         Payout = u[o].ae / 1 ether;\n                 }\n         }\n }",
      "rename_map": {
        "nextPayoutWhenPyramidBalanceTotalsApproximately": "a",
        "feesSeperateFromBalanceApproximately": "b",
        "numberOfParticipantsWaitingForPayout": "c",
        "currentPyramidBalanceApproximately": "d",
        "currentFeePercentage": "e",
        "collectPercentOfFees": "f",
        "changeFeePercentage": "g",
        "participantDetails": "h",
        "collectFeesInEther": "i",
        "pyramidMultiplier": "j",
        "currentMultiplier": "k",
        "totalParticipants": "l",
        "changeMultiplier": "m",
        "collectAllFees": "n",
        "orderInPyramid": "o",
        "pyramidBalance": "p",
        "collectedFees": "q",
        "balancePayout": "r",
        "feesToCollect": "s",
        "payoutToSend": "t",
        "participants": "u",
        "etherAddress": "v",
        "changeOwner": "w",
        "payoutOrder": "x",
        "multiplier": "y",
        "feePercent": "z",
        "onlyowner": "aa",
        "addPayout": "ab",
        "creator": "ac",
        "_pcent": "ad",
        "payout": "ae",
        "_owner": "af",
        "_mult": "ag",
        "count": "ah",
        "info": "ai",
        "init": "aj",
        "fees": "ak",
        "_amt": "al",
        "_fee": "am",
        "fee": "an"
      },
      "changes": [
        "Renamed 40 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_130",
      "transformed_id": "ss_l2_short_nc_ds_130",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n contract OpenAccess{\n     address private d;\n\n     modifier b {\n         require(msg.sender==d);\n         _;\n     }\n\n     function OpenAccess()\n         public\n     {\n         d = msg.sender;\n     }\n\n\n     function a(address c)\n         public\n     {\n        d = c;\n     }\n\n }",
      "rename_map": {
        "changeOwner": "a",
        "onlyowner": "b",
        "_newOwner": "c",
        "owner": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_131",
      "transformed_id": "ss_l2_short_nc_ds_131",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\ncontract AdditionCounter {\n    mapping (address => uint256) public a;\n\n    function transfer(address c, uint256 b) public{\n\n        require(a[msg.sender] >= b);\n        a[msg.sender] -= b;\n        a[c] += b;\n}\n\n}",
      "rename_map": {
        "balanceOf": "a",
        "_value": "b",
        "_to": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_132",
      "transformed_id": "ss_l2_short_nc_ds_132",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n contract Ledger {\n     uint private a=0;\n\n     function b(uint value) returns (bool){\n         a += value;\n\n\n     }\n\n\n }",
      "rename_map": {
        "sellerBalance": "a",
        "add": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_133",
      "transformed_id": "ss_l2_short_nc_ds_133",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract AdditionCounter {\n    uint public b = 1;\n\n    function c(uint256 a) public {\n        b += a;\n    }\n}",
      "rename_map": {
        "input": "a",
        "count": "b",
        "run": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_134",
      "transformed_id": "ss_l2_short_nc_ds_134",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract BenignCounter {\n    uint public b = 1;\n\n    function c(uint256 a) public {\n        uint d = b - a;\n    }\n}",
      "rename_map": {
        "input": "a",
        "count": "b",
        "run": "c",
        "res": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_135",
      "transformed_id": "ss_l2_short_nc_ds_135",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.11;\n\ncontract MappingCounter {\n    mapping(uint256 => uint256) b;\n\n    function a(uint256 k, uint256 v) public {\n        b[k] -= v;\n    }\n}",
      "rename_map": {
        "init": "a",
        "map": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_136",
      "transformed_id": "ss_l2_short_nc_ds_136",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract MinimalCounter {\n    uint public b = 1;\n\n    function c(uint256 a) public {\n        b -= a;\n    }\n}",
      "rename_map": {
        "input": "a",
        "count": "b",
        "run": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_137",
      "transformed_id": "ss_l2_short_nc_ds_137",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract MultiplyCounter {\n    uint public b = 2;\n\n    function c(uint256 a) public {\n        b *= a;\n    }\n}",
      "rename_map": {
        "input": "a",
        "count": "b",
        "run": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_138",
      "transformed_id": "ss_l2_short_nc_ds_138",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract MultiTxCalculator {\n    uint256 private a = 0;\n    uint256 public c = 1;\n\n    function d() public {\n        a = 1;\n    }\n\n    function e(uint256 b) {\n        if (a == 0) {\n            return;\n        }\n        c -= b;\n    }\n}",
      "rename_map": {
        "initialized": "a",
        "input": "b",
        "count": "c",
        "init": "d",
        "run": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_139",
      "transformed_id": "ss_l2_short_nc_ds_139",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract SingleFuncCalculator {\n    uint256 private a = 0;\n    uint256 public c = 1;\n\n    function d(uint256 b) public {\n        if (a == 0) {\n            a = 1;\n            return;\n        }\n        c -= b;\n    }\n}",
      "rename_map": {
        "initialized": "a",
        "input": "b",
        "count": "c",
        "run": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_140",
      "transformed_id": "ss_l2_short_nc_ds_140",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.4.25;\n\ncontract AdditionLedger {\n    uint public balance = 1;\n\n    function b(uint256 a) public {\n        balance += a;\n    }\n}",
      "rename_map": {
        "deposit": "a",
        "add": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_141",
      "transformed_id": "ss_l2_short_nc_ds_141",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract SingleTxCounter {\n    uint public h = 1;\n\n    function d(uint256 g) public {\n        h += g;\n    }\n\n    function e(uint256 g) public {\n        h *= g;\n    }\n\n    function b(uint256 g) public {\n        h -= g;\n    }\n\n    function f(uint256 g) public {\n        uint i = h + g;\n    }\n\n    function c(uint256 g) public {\n        uint i = h * g;\n    }\n\n    function a(uint256 g) public {\n       \tuint i = h - g;\n    }\n\n}",
      "rename_map": {
        "underflowlocalonly": "a",
        "underflowtostate": "b",
        "mullocalonly": "c",
        "addtostate": "d",
        "multostate": "e",
        "localcalc": "f",
        "input": "g",
        "count": "h",
        "res": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_142",
      "transformed_id": "ss_l2_short_nc_ds_142",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\n contract TimeLock {\n\n     mapping(address => uint) public d;\n     mapping(address => uint) public f;\n\n     function g() public payable {\n         d[msg.sender] += msg.value;\n         f[msg.sender] = h + 1 weeks;\n     }\n\n     function b(uint a) public {\n         f[msg.sender] += a;\n     }\n\n     function e() public {\n         require(d[msg.sender] > 0);\n         require(h > f[msg.sender]);\n         uint c = d[msg.sender];\n         d[msg.sender] = 0;\n         msg.sender.transfer(c);\n     }\n }",
      "rename_map": {
        "_secondsToIncrease": "a",
        "increaseLockTime": "b",
        "transferValue": "c",
        "balances": "d",
        "withdraw": "e",
        "lockTime": "f",
        "deposit": "g",
        "now": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_143",
      "transformed_id": "ss_l2_short_nc_ds_143",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) d;\n   uint public b;\n\n   function Token(uint a) {\n     d[msg.sender] = b = a;\n   }\n\n   function transfer(address g, uint f) public returns (bool) {\n     require(d[msg.sender] - f >= 0);\n     d[msg.sender] -= f;\n     d[g] += f;\n     return true;\n   }\n\n   function c(address e) public constant returns (uint balance) {\n     return d[e];\n   }\n }",
      "rename_map": {
        "_initialSupply": "a",
        "totalSupply": "b",
        "balanceOf": "c",
        "balances": "d",
        "_owner": "e",
        "_value": "f",
        "_to": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_144",
      "transformed_id": "ss_l2_short_nc_ds_144",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public c;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address d) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function a() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function f(uint256 b) public payable {\n        require(msg.value == b * PRICE_PER_TOKEN);\n        c[msg.sender] += b;\n    }\n\n    function e(uint256 b) public {\n        require(c[msg.sender] >= b);\n\n        c[msg.sender] -= b;\n        msg.sender.transfer(b * PRICE_PER_TOKEN);\n    }\n}",
      "rename_map": {
        "isComplete": "a",
        "numTokens": "b",
        "balanceOf": "c",
        "_player": "d",
        "sell": "e",
        "buy": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_145",
      "transformed_id": "ss_l2_short_nc_ds_145",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address aa;\n        uint s;\n    }\n\n    event RaffleResult(\n        uint s,\n        uint c,\n        address b,\n        address y,\n        address w,\n        uint v,\n        bytes32 r\n    );\n\n    event TicketPurchase(\n        uint s,\n        address j,\n        uint number\n    );\n\n    event TicketRefund(\n        uint s,\n        address j,\n        uint number\n    );\n\n\n    uint public constant x = 2.5 ether;\n    uint public constant ac = 0.03 ether;\n    uint public constant e = 50;\n    uint public constant a = (x + ac) / e;\n    address m;\n\n\n    bool public t = false;\n    uint public s = 1;\n    uint public h = block.number;\n    uint l = 0;\n    mapping (uint => Contestant) g;\n    uint[] z;\n\n\n    function Ethraffle_v4b() public {\n        m = msg.sender;\n    }\n\n\n    function () payable public {\n        i();\n    }\n\n    function i() payable public {\n        if (t) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint o = msg.value;\n\n        while (o >= a && l < e) {\n            uint k = 0;\n            if (z.length > 0) {\n                k = z[z.length-1];\n                z.length--;\n            } else {\n                k = l++;\n            }\n\n            g[k] = Contestant(msg.sender, s);\n            TicketPurchase(s, msg.sender, k);\n            o -= a;\n        }\n\n\n        if (l == e) {\n            d();\n        }\n\n\n        if (o > 0) {\n            msg.sender.transfer(o);\n        }\n    }\n\n    function d() private {\n        address y = g[uint(block.coinbase) % e].aa;\n        address w = g[uint(msg.sender) % e].aa;\n        uint v = block.difficulty;\n        bytes32 r = p(y, w, v);\n\n        uint c = uint(r) % e;\n        address b = g[c].aa;\n        RaffleResult(s, c, b, y, w, v, r);\n\n\n        s++;\n        l = 0;\n        h = block.number;\n\n\n        b.transfer(x);\n        m.transfer(ac);\n    }\n\n\n    function n() public {\n        uint u = 0;\n        for (uint i = 0; i < e; i++) {\n            if (msg.sender == g[i].aa && s == g[i].s) {\n                u += a;\n                g[i] = Contestant(address(0), 0);\n                z.push(i);\n                TicketRefund(s, msg.sender, i);\n            }\n        }\n\n        if (u > 0) {\n            msg.sender.transfer(u);\n        }\n    }\n\n\n    function q() public {\n        if (msg.sender == m) {\n            t = true;\n\n            for (uint i = 0; i < e; i++) {\n                if (s == g[i].s) {\n                    TicketRefund(s, g[i].aa, i);\n                    g[i].aa.transfer(a);\n                }\n            }\n\n            RaffleResult(s, e, address(0), address(0), address(0), 0, 0);\n            s++;\n            l = 0;\n            h = block.number;\n            z.length = 0;\n        }\n    }\n\n    function f() public {\n        if (msg.sender == m) {\n            t = !t;\n        }\n    }\n\n    function ab() public {\n        if (msg.sender == m) {\n            selfdestruct(m);\n        }\n    }\n}",
      "rename_map": {
        "pricePerTicket": "a",
        "winningAddress": "b",
        "winningNumber": "c",
        "chooseWinner": "d",
        "totalTickets": "e",
        "togglePause": "f",
        "contestants": "g",
        "blockNumber": "h",
        "buyTickets": "i",
        "contestant": "j",
        "currTicket": "k",
        "nextTicket": "l",
        "feeAddress": "m",
        "getRefund": "n",
        "moneySent": "o",
        "keccak256": "p",
        "endRaffle": "q",
        "randHash": "r",
        "raffleId": "s",
        "paused": "t",
        "refund": "u",
        "seed3": "v",
        "seed2": "w",
        "prize": "x",
        "seed1": "y",
        "gaps": "z",
        "addr": "aa",
        "kill": "ab",
        "fee": "ac"
      },
      "changes": [
        "Renamed 29 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_146",
      "transformed_id": "ss_l2_short_nc_ds_146",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 c;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n        c = uint8(b(block.blockhash(block.number - 1), e));\n    }\n\n    function a() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function d(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == c) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
      "rename_map": {
        "isComplete": "a",
        "keccak256": "b",
        "answer": "c",
        "guess": "d",
        "now": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_147",
      "transformed_id": "ss_l2_short_nc_ds_147",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract Lottery {\n     event GetBet(uint c, uint a, bool h);\n\n     struct Bet {\n         uint c;\n         uint a;\n         bool h;\n     }\n\n     address private b;\n     Bet[] private g;\n\n\n     function Lottery() {\n         b = msg.sender;\n     }\n\n\n     function() {\n         throw;\n     }\n\n\n     function f() {\n\n\n         bool h = (block.number % 2) == 0;\n\n\n         g.push(Bet(msg.value, block.number, h));\n\n\n         if(h) {\n             if(!msg.sender.send(msg.value)) {\n\n                 throw;\n             }\n         }\n     }\n\n\n     function d() {\n         if(msg.sender != b) { throw; }\n\n         for (uint i = 0; i < g.length; i++) {\n             GetBet(g[i].c, g[i].a, g[i].h);\n         }\n     }\n\n     function e() {\n         if(msg.sender != b) { throw; }\n\n         suicide(b);\n     }\n }",
      "rename_map": {
        "blockNumber": "a",
        "organizer": "b",
        "betAmount": "c",
        "getBets": "d",
        "destroy": "e",
        "makeBet": "f",
        "bets": "g",
        "won": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_148",
      "transformed_id": "ss_l2_short_nc_ds_148",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\n\ncontract PredictTheBlockHashChallenge {\n\n    struct e{\n      uint block;\n      bytes32 e;\n    }\n\n    mapping(address => e) b;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function a(bytes32 f) public payable {\n        require(b[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        b[msg.sender].e = f;\n        b[msg.sender].block  = block.number + 1;\n    }\n\n    function c() public {\n        require(block.number > b[msg.sender].block);\n        bytes32 d = blockhash(b[msg.sender].block);\n\n        b[msg.sender].block = 0;\n        if (b[msg.sender].e == d) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
      "rename_map": {
        "lockInGuess": "a",
        "guesses": "b",
        "settle": "c",
        "answer": "d",
        "guess": "e",
        "hash": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_149",
      "transformed_id": "ss_l2_short_nc_ds_149",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\n\ncontract RandomNumberGenerator {\n  uint256 private c =  block.timestamp;\n\n  function a(uint e) view private returns (uint256 b) {\n\n    uint256 x = c * 100 / e;\n    uint256 y = c * block.number / (c % 5);\n    uint256 d = block.number / 3 + (c % 300) + y;\n    uint256 h = uint256(blockhash(d));\n\n    return uint256((h / x)) % e + 1;\n  }\n}",
      "rename_map": {
        "random": "a",
        "result": "b",
        "salt": "c",
        "seed": "d",
        "max": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_150",
      "transformed_id": "ss_l2_short_nc_ds_150",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address a;\n  uint b;\n\n  function c() payable {\n    require(msg.value > b);\n\n\n    if (a != 0) {\n\n      require(a.send(b));\n    }\n\n    a = msg.sender;\n    b         = msg.value;\n  }\n}",
      "rename_map": {
        "currentFrontrunner": "a",
        "currentBid": "b",
        "bid": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_151",
      "transformed_id": "ss_l2_short_nc_ds_151",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract GasAuction {\n\n    address[] a;\n    bool f = false;\n\n    function c() public {\n        if(a.length>1500) {\n            a = new address[](0);\n            f = true;\n        }\n    }\n\n    function d() public returns (bool) {\n        for(uint i=0;i<350;i++) {\n          a.push(msg.sender);\n        }\n        return true;\n    }\n\n    function e() public view returns (bool) {\n        return f;\n    }\n\n    function b() public view returns (uint) {\n        return a.length;\n    }\n}",
      "rename_map": {
        "creditorAddresses": "a",
        "numberCreditors": "b",
        "emptyCreditors": "c",
        "addCreditors": "d",
        "iWin": "e",
        "win": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_152",
      "transformed_id": "ss_l2_short_nc_ds_152",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract NumberRegistry {\n\n    uint d = 0;\n    uint[] array;\n\n    function c(uint value,uint f) public {\n\n        for(uint i=0;i<f;i++) {\n            if(d == array.length) {\n                array.length += 1;\n            }\n            array[d++] = value;\n        }\n    }\n\n    function g() public {\n        require(d>1500);\n        d = 0;\n    }\n\n    function e() public {\n\n\n        require(d>1500);\n        array = new uint[](0);\n        d = 0;\n    }\n\n    function b() public view returns(uint) {\n        return d;\n    }\n\n    function a() public view returns(uint) {\n        return array.length;\n    }\n}",
      "rename_map": {
        "getRealLengthArray": "a",
        "getLengthArray": "b",
        "insertNnumbers": "c",
        "numElements": "d",
        "clearDOS": "e",
        "numbers": "f",
        "clear": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_153",
      "transformed_id": "ss_l2_short_nc_ds_153",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract SingleFuncRegistry {\n\n    address[] a;\n\n    function b() public returns (bool){\n        if(a.length<1500) {\n            for(uint i=0;i<350;i++) {\n                a.push(msg.sender);\n            }\n            return true;\n\n        } else {\n            a = new address[](0);\n            return false;\n        }\n    }\n}",
      "rename_map": {
        "listAddresses": "a",
        "ifillArray": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_154",
      "transformed_id": "ss_l2_short_nc_ds_154",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract Government {\n\n\n     uint32 public b;\n     uint public d;\n     uint public j;\n     address[] public h;\n     uint[] public i;\n     address public m;\n     mapping (address => uint) o;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public r;\n\n     function Government() {\n\n\n         j = msg.value;\n         m = msg.sender;\n         d = block.timestamp;\n     }\n\n     function e(address s) returns (bool) {\n         uint p = msg.value;\n\n\n         if (d + TWELVE_HOURS < block.timestamp) {\n\n             msg.sender.send(p);\n\n             h[h.length - 1].send(j);\n             m.send(this.balance);\n\n             b = 0;\n             d = block.timestamp;\n             j = 0;\n             h = new address[](0);\n             i = new uint[](0);\n             r += 1;\n             return false;\n         }\n         else {\n\n             if (p >= 10 ** 18) {\n\n                 d = block.timestamp;\n\n                 h.push(msg.sender);\n                 i.push(p * 110 / 100);\n\n\n                 m.send(p * 5/100);\n\n                 if (j < 10000 * 10**18) {\n                     j += p * 5/100;\n                 }\n\n\n                 if(o[s] >= p) {\n                     s.send(p * 5/100);\n                 }\n                 o[msg.sender] += p * 110 / 100;\n\n                 if (i[b] <= address(this).balance - j) {\n                     h[b].send(i[b]);\n                     o[h[b]] -= i[b];\n                     b += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(p);\n                 return false;\n             }\n         }\n     }\n\n\n     function() {\n         e(0);\n     }\n\n     function n() returns (uint t) {\n         for(uint i=b; i<i.length; i++){\n             t += i[i];\n         }\n     }\n\n     function l() returns (uint q) {\n         for(uint i=0; i<b; i++){\n             q += i[i];\n         }\n     }\n\n\n     function g() {\n         j += msg.value;\n     }\n\n\n     function a(address k) {\n         if (msg.sender == m) {\n             m = k;\n         }\n     }\n\n     function c() returns (address[]) {\n         return h;\n     }\n\n     function f() returns (uint[]) {\n         return i;\n     }\n }",
      "rename_map": {
        "inheritToNextGeneration": "a",
        "lastCreditorPayedOut": "b",
        "getCreditorAddresses": "c",
        "lastTimeOfNewCredit": "d",
        "lendGovernmentMoney": "e",
        "getCreditorAmounts": "f",
        "investInTheSystem": "g",
        "creditorAddresses": "h",
        "creditorAmounts": "i",
        "profitFromCrash": "j",
        "nextGeneration": "k",
        "totalPayedOut": "l",
        "corruptElite": "m",
        "totalDebt": "n",
        "buddies": "o",
        "amount": "p",
        "payout": "q",
        "round": "r",
        "buddy": "s",
        "debt": "t"
      },
      "changes": [
        "Renamed 20 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_155",
      "transformed_id": "ss_l2_short_nc_ds_155",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.4.24;\n\ncontract Refunder {\n\naddress[] private a;\nmapping (address => uint) public c;\n\n    constructor() {\n        a.push(0x79B483371E87d664cd39491b5F06250165e4b184);\n        a.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n    }\n\n\n    function b() public {\n        for(uint x; x < a.length; x++) {\n            require(a[x].send(c[a[x]]));\n        }\n    }\n\n}",
      "rename_map": {
        "refundAddresses": "a",
        "refundAll": "b",
        "refunds": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_156",
      "transformed_id": "ss_l2_short_nc_ds_156",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n  function l(uint256 a, uint256 b) internal pure returns (uint256) {\n\n\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  function o(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0);\n    uint256 c = a / b;\n\n\n    return c;\n  }\n\n  function m(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function n(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  function k(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\ncontract ERC20 {\n\n  event Transfer( address indexed from, address indexed p, uint256 value );\n  event Approval( address indexed j, address indexed h, uint256 value);\n  using SafeMath for *;\n\n  mapping (address => uint256) private f;\n\n  mapping (address => mapping (address => uint256)) private g;\n\n  uint256 private a;\n\n  constructor(uint c){\n    f[msg.sender] = c;\n  }\n\n  function d(address j) public view returns (uint256) {\n    return f[j];\n  }\n\n  function e(address j, address h) public view returns (uint256)\n  {\n    return g[j][h];\n  }\n\n  function transfer(address p, uint256 value) public returns (bool) {\n    require(value <= f[msg.sender]);\n    require(p != address(0));\n\n    f[msg.sender] = f[msg.sender].m(value);\n    f[p] = f[p].n(value);\n    emit Transfer(msg.sender, p, value);\n    return true;\n  }\n  function i(address h, uint256 value) public returns (bool) {\n    require(h != address(0));\n    g[msg.sender][h] = value;\n    emit Approval(msg.sender, h, value);\n    return true;\n  }\n\n  function b(address from, address p, uint256 value) public returns (bool) {\n    require(value <= f[from]);\n    require(value <= g[from][msg.sender]);\n    require(p != address(0));\n\n    f[from] = f[from].m(value);\n    f[p] = f[p].n(value);\n    g[from][msg.sender] = g[from][msg.sender].m(value);\n    emit Transfer(from, p, value);\n    return true;\n  }\n}",
      "rename_map": {
        "_totalSupply": "a",
        "transferFrom": "b",
        "totalSupply": "c",
        "balanceOf": "d",
        "allowance": "e",
        "_balances": "f",
        "_allowed": "g",
        "spender": "h",
        "approve": "i",
        "owner": "j",
        "mod": "k",
        "mul": "l",
        "sub": "m",
        "add": "n",
        "div": "o",
        "to": "p"
      },
      "changes": [
        "Renamed 16 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_157",
      "transformed_id": "ss_l2_short_nc_ds_157",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.22;\n\ncontract FindThisHash {\n    bytes32 constant public c = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;\n\n    constructor() public payable {}\n\n    function b(string a) public {\n\n        require(c == d(a));\n        msg.sender.transfer(1000 ether);\n    }\n}",
      "rename_map": {
        "solution": "a",
        "solve": "b",
        "hash": "c",
        "sha3": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_158",
      "transformed_id": "ss_l2_short_nc_ds_158",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n    address public f;\n    bool public d;\n    uint public e;\n\n    function EthTxOrderDependenceMinimal() public {\n        f = msg.sender;\n    }\n\n    function c() public payable {\n        require (!d);\n\n        require(msg.sender == f);\n        f.transfer(e);\n        e = msg.value;\n    }\n\n    function a(uint256 b) {\n        require (!d);\n        require(b < 10);\n        msg.sender.transfer(e);\n        d = true;\n    }\n}",
      "rename_map": {
        "claimReward": "a",
        "submission": "b",
        "setReward": "c",
        "claimed": "d",
        "reward": "e",
        "owner": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_159",
      "transformed_id": "ss_l2_short_nc_ds_159",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.2;\n\ncontract OddsAndEvens{\n\n  struct Player {\n    address f;\n    uint number;\n  }\n\n  Player[2] public c;\n\n  uint8 h;\n  address d;\n\n  function OddsAndEvens() {\n    d = msg.sender;\n  }\n  function e(uint number) payable{\n    if (msg.value != 1 ether) throw;\n    c[h] = Player(msg.sender, number);\n    h++;\n\n    if (h==2) a();\n  }\n\n  function a() private {\n    bool g ;\n    uint n = c[0].number+c[1].number;\n    if (n%2==0) {\n      g = c[0].f.send(1800 finney);\n    }\n    else {\n      g = c[1].f.send(1800 finney);\n    }\n\n    delete c;\n    h=0;\n  }\n\n  function b() {\n    if(msg.sender!=d) throw;\n    bool g = msg.sender.send(this.balance);\n  }\n\n}",
      "rename_map": {
        "andTheWinnerIs": "a",
        "getProfit": "b",
        "players": "c",
        "owner": "d",
        "play": "e",
        "addr": "f",
        "res": "g",
        "tot": "h"
      },
      "changes": [
        "Renamed 8 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_160",
      "transformed_id": "ss_l2_short_nc_ds_160",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\n\ncontract CryptoRoulette {\n\n    uint256 private a;\n    uint256 public c;\n    uint256 public e = 0.1 ether;\n    address public d;\n\n    struct Game {\n        address g;\n        uint256 number;\n    }\n    Game[] public b;\n\n    function CryptoRoulette() public {\n        d = msg.sender;\n        f();\n    }\n\n    function f() internal {\n\n        a = uint8(k(l, block.blockhash(block.number-1))) % 20 + 1;\n    }\n\n    function j(uint256 number) payable public {\n        require(msg.value >= e && number <= 10);\n        Game h;\n        h.g = msg.sender;\n        h.number = number;\n        b.push(h);\n\n        if (number == a) {\n\n            msg.sender.transfer(this.balance);\n        }\n\n        f();\n        c = l;\n    }\n\n    function i() public {\n        if (msg.sender == d && l > c + 1 days) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n}",
      "rename_map": {
        "secretNumber": "a",
        "gamesPlayed": "b",
        "lastPlayed": "c",
        "ownerAddr": "d",
        "betPrice": "e",
        "shuffle": "f",
        "player": "g",
        "game": "h",
        "kill": "i",
        "play": "j",
        "sha3": "k",
        "now": "l"
      },
      "changes": [
        "Renamed 12 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_161",
      "transformed_id": "ss_l2_short_nc_ds_161",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract NameRegistrar {\n\n    bool public e = false;\n\n    struct NameRecord {\n        bytes32 i;\n        address c;\n    }\n\n    mapping(address => NameRecord) public a;\n    mapping(bytes32 => address) public g;\n\n    function f(bytes32 h, address b) public {\n\n        NameRecord d;\n        d.i = h;\n        d.c = b;\n\n        g[h] = b;\n        a[msg.sender] = d;\n\n        require(e);\n    }\n}",
      "rename_map": {
        "registeredNameRecord": "a",
        "_mappedAddress": "b",
        "mappedAddress": "c",
        "newRecord": "d",
        "unlocked": "e",
        "register": "f",
        "resolve": "g",
        "_name": "h",
        "name": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_162",
      "transformed_id": "ss_l2_short_nc_ds_162",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint g;\n        uint e;\n        uint j;\n        uint i;\n    }\n\n    address n;\n    uint private h;\n    uint private d;\n    uint LuckyNumber = 7;\n\n    mapping (address => bool) m;\n\n    function OpenAddressLottery() {\n        n = msg.sender;\n        l(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n    }\n\n    function b() payable {\n        if(msg.value<0.1 ether)\n            return;\n\n\n        require(m[msg.sender] == false);\n\n        if(a(msg.sender) == LuckyNumber){\n            m[msg.sender] = true;\n\n            uint q=msg.value*7;\n\n            if(q>this.balance)\n                q=this.balance;\n            msg.sender.transfer(q);\n        }\n\n        if(block.number-d>1000)\n            l(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n    }\n\n    function a(address p) constant returns(uint n){\n\n        n = uint(k(uint(p), h)[0]) % 8;\n    }\n\n    function l(SeedComponents f) internal {\n        h = uint256(k(\n            f.g,\n            f.e,\n            f.j,\n            f.i\n        ));\n        d = block.number;\n    }\n\n    function o() {\n        require(msg.sender==n);\n\n        selfdestruct(msg.sender);\n    }\n\n    function c() {\n        require(msg.sender==n);\n        SeedComponents s;\n        s.g = uint(msg.sender);\n        s.e = uint256(block.blockhash(block.number - 1));\n        s.j = block.difficulty*(uint)(block.coinbase);\n        s.i = tx.gasprice * 7;\n\n        l(s);\n    }\n\n    function () payable {\n        if(msg.value>=0.1 ether && msg.sender!=n)\n            b();\n    }\n\n}",
      "rename_map": {
        "luckyNumberOfAddress": "a",
        "participate": "b",
        "forceReseed": "c",
        "lastReseed": "d",
        "component2": "e",
        "components": "f",
        "component1": "g",
        "secretSeed": "h",
        "component4": "i",
        "component3": "j",
        "keccak256": "k",
        "reseed": "l",
        "winner": "m",
        "owner": "n",
        "kill": "o",
        "addr": "p",
        "win": "q"
      },
      "changes": [
        "Renamed 17 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_163",
      "transformed_id": "ss_l2_short_nc_ds_163",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.11;\n\n contract MyToken {\n     mapping (address => uint) c;\n\n     event Transfer(address indexed g, address indexed i, uint256 f);\n\n     function MyToken() {\n         c[tx.origin] = 10000;\n     }\n     function d(address j, uint e) returns(bool b) {\n         if (c[msg.sender] < e) return false;\n         c[msg.sender] -= e;\n         c[j] += e;\n         Transfer(msg.sender, j, e);\n         return true;\n     }\n\n     function a(address h) constant returns(uint) {\n         return c[h];\n     }\n }",
      "rename_map": {
        "getBalance": "a",
        "sufficient": "b",
        "balances": "c",
        "sendCoin": "d",
        "amount": "e",
        "_value": "f",
        "_from": "g",
        "addr": "h",
        "_to": "i",
        "to": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_164",
      "transformed_id": "ss_l2_short_nc_ds_164",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.15;\n\n\ncontract EtherLotto {\n\n\n    uint constant TICKET_AMOUNT = 10;\n\n\n    uint constant FEE_AMOUNT = 1;\n\n\n    address public c;\n\n\n    uint public e;\n\n\n    function EtherLotto() {\n        c = msg.sender;\n    }\n\n\n    function b() payable {\n\n\n        assert(msg.value == TICKET_AMOUNT);\n\n\n        e += msg.value;\n\n\n        var a = uint(d(block.timestamp)) % 2;\n\n\n        if (a == 0) {\n\n\n            c.transfer(FEE_AMOUNT);\n\n\n            msg.sender.transfer(e - FEE_AMOUNT);\n\n\n            e = 0;\n        }\n    }\n\n}",
      "rename_map": {
        "random": "a",
        "play": "b",
        "bank": "c",
        "sha3": "d",
        "pot": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_165",
      "transformed_id": "ss_l2_short_nc_ds_165",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract Governmental {\n  address public h;\n  address public c;\n  uint public e = 1 ether;\n  uint public a;\n  uint public ONE_MINUTE = 1 minutes;\n\n  function Governmental() {\n    h = msg.sender;\n    if (msg.value<1 ether) throw;\n  }\n\n  function g() {\n    if (msg.value<e/2) throw;\n    c = msg.sender;\n    e += msg.value/2;\n    a = block.timestamp;\n  }\n\n  function b() {\n    if (block.timestamp < a+ONE_MINUTE)\n      throw;\n\n    c.send(e);\n    h.send(this.balance-1 ether);\n\n    c = 0;\n    e = 1 ether;\n    a = 0;\n  }\n}\n\ncontract Operator {\n\n  function d(address f, uint i) {\n    if (0<=i && i<1023) {\n      this.d.gas(msg.gas-2000)(f, i+1);\n    }\n    else {\n      Governmental(f).b();\n    }\n  }\n}",
      "rename_map": {
        "lastInvestmentTimestamp": "a",
        "resetInvestment": "b",
        "lastInvestor": "c",
        "operate": "d",
        "jackpot": "e",
        "target": "f",
        "invest": "g",
        "owner": "h",
        "count": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_166",
      "transformed_id": "ss_l2_short_nc_ds_166",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\ncontract b {\n  address d;\n  uint    timestamp;\n  function e(uint g) internal {\n    if ( g> 0 && i - g > 24 hours ) {\n      msg.sender.send( msg.value );\n\n      if ( this.balance > 0 ) {\n        d.send( this.balance );\n      }\n    }\n    else if ( msg.value >= 1 ether ) {\n      d = msg.sender;\n      timestamp = g;\n    }\n  }\n  function c() constant returns (uint a) {\n      return block.timestamp;\n    }\n  function f(uint h){\n    uint a=c();\n    e(a);\n  }\n}",
      "rename_map": {
        "randomNumber": "a",
        "lottopollo": "b",
        "randomGen": "c",
        "leader": "d",
        "payOut": "e",
        "draw": "f",
        "rand": "g",
        "seed": "h",
        "now": "i"
      },
      "changes": [
        "Renamed 9 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_167",
      "transformed_id": "ss_l2_short_nc_ds_167",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract Roulette {\n    uint public a;\n\n    constructor() public payable {}\n\n\n    function () public payable {\n        require(msg.value == 10 ether);\n        require(b != a);\n        a = b;\n        if(b % 15 == 0) {\n            msg.sender.transfer(this.balance);\n        }\n    }\n}",
      "rename_map": {
        "pastBlockTime": "a",
        "now": "b"
      },
      "changes": [
        "Renamed 2 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_168",
      "transformed_id": "ss_l2_short_nc_ds_168",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.25;\n\ncontract TimedCrowdsale {\n\n  function a() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n}",
      "rename_map": {
        "isSaleFinished": "a"
      },
      "changes": [
        "Renamed 1 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_169",
      "transformed_id": "ss_l2_short_nc_ds_169",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\ncontract TownCrier {\n    struct Request {\n        address p;\n        uint ai;\n        address e;\n        bytes4 g;\n        bytes32 k;\n    }\n\n    event Upgrade(address ab);\n    event Reset(uint q, uint u, uint a);\n    event RequestInfo(uint64 aj, uint8 i, address p, uint ai, address e, bytes32 k, uint timestamp, bytes32[] f);\n    event DeliverInfo(uint64 n, uint ai, uint gasPrice, uint y, uint h, bytes32 k, uint64 error, bytes32 r);\n    event Cancel(uint64 n, address o, address p, uint ai, int ah);\n\n    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;\n\n    uint public GAS_PRICE = 5 * 10**10;\n    uint public MIN_FEE = 30000 * GAS_PRICE;\n    uint public CANCELLATION_FEE = 25000 * GAS_PRICE;\n\n    uint public constant CANCELLED_FEE_FLAG = 1;\n    uint public constant DELIVERED_FEE_FLAG = 0;\n    int public constant FAIL_FLAG = -2 ** 250;\n    int public constant SUCCESS_FLAG = 1;\n\n    bool public m;\n\n    bool public b;\n\n    uint64 public j;\n    uint64 public d;\n    Request[2**64] public t;\n\n    int public l = 0;\n\n\n    function () {}\n\n    function TownCrier() public {\n\n\n        j = 1;\n        t[0].p = msg.sender;\n        m = false;\n        d = 0;\n        b = false;\n    }\n\n    function z(address ab) {\n        if (msg.sender == t[0].p && d == 0) {\n            l = -int(ab);\n            m = true;\n            Upgrade(ab);\n        }\n    }\n\n    function af(uint ae, uint ac, uint c) public {\n        if (msg.sender == t[0].p && d == 0) {\n            GAS_PRICE = ae;\n            MIN_FEE = ae * ac;\n            CANCELLATION_FEE = ae * c;\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n        }\n    }\n\n    function w() public {\n        if (msg.sender == t[0].p) {\n            m = true;\n        }\n    }\n\n    function aa() public {\n        if (msg.sender == t[0].p && l == 0) {\n            m = false;\n        }\n    }\n\n    function s() public {\n        if (msg.sender == t[0].p && d == 0) {\n            if (!t[0].p.call.value(this.balance)()) {\n                throw;\n            }\n        }\n    }\n\n    function x(uint8 i, address e, bytes4 g, uint timestamp, bytes32[] f) public payable returns (int) {\n        if (b) {\n            throw;\n        }\n\n        if (m) {\n            b = true;\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            b = false;\n            return l;\n        }\n\n        if (msg.value < MIN_FEE) {\n            b = true;\n\n\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            b = false;\n            return FAIL_FLAG;\n        } else {\n\n            uint64 n = j;\n            j++;\n            d++;\n\n            bytes32 k = ag(i, f);\n            t[n].p = msg.sender;\n            t[n].ai = msg.value;\n            t[n].e = e;\n            t[n].g = g;\n            t[n].k = k;\n\n\n            RequestInfo(n, i, msg.sender, msg.value, e, k, timestamp, f);\n            return n;\n        }\n    }\n\n    function v(uint64 n, bytes32 k, uint64 error, bytes32 r) public {\n        if (msg.sender != SGX_ADDRESS ||\n                n <= 0 ||\n                t[n].p == 0 ||\n                t[n].ai == DELIVERED_FEE_FLAG) {\n\n\n            return;\n        }\n\n        uint ai = t[n].ai;\n        if (t[n].k != k) {\n\n\n            return;\n        } else if (ai == CANCELLED_FEE_FLAG) {\n\n\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            t[n].ai = DELIVERED_FEE_FLAG;\n            d--;\n            return;\n        }\n\n        t[n].ai = DELIVERED_FEE_FLAG;\n        d--;\n\n        if (error < 2) {\n\n\n            SGX_ADDRESS.send(ai);\n        } else {\n\n            b = true;\n            t[n].p.call.gas(2300).value(ai)();\n            b = false;\n        }\n\n        uint h = (ai - MIN_FEE) / tx.gasprice;\n        DeliverInfo(n, ai, tx.gasprice, msg.gas, h, k, error, r);\n        if (h > msg.gas - 5000) {\n            h = msg.gas - 5000;\n        }\n\n        b = true;\n        t[n].e.call.gas(h)(t[n].g, n, error, r);\n        b = false;\n    }\n\n    function ad(uint64 n) public returns (int) {\n        if (b) {\n            throw;\n        }\n\n        if (m) {\n            return 0;\n        }\n\n        uint ai = t[n].ai;\n        if (t[n].p == msg.sender && ai >= CANCELLATION_FEE) {\n\n\n            t[n].ai = CANCELLED_FEE_FLAG;\n            b = true;\n            if (!msg.sender.call.value(ai - CANCELLATION_FEE)()) {\n                throw;\n            }\n            b = false;\n            Cancel(n, msg.sender, t[n].p, t[n].ai, 1);\n            return SUCCESS_FLAG;\n        } else {\n            Cancel(n, msg.sender, t[n].p, ai, -1);\n            return FAIL_FLAG;\n        }\n    }\n}",
      "rename_map": {
        "cancellation_fee": "a",
        "externalCallFlag": "b",
        "cancellationGas": "c",
        "unrespondedCnt": "d",
        "callbackAddr": "e",
        "requestData": "f",
        "callbackFID": "g",
        "callbackGas": "h",
        "requestType": "i",
        "requestCnt": "j",
        "paramsHash": "k",
        "newVersion": "l",
        "killswitch": "m",
        "requestId": "n",
        "canceller": "o",
        "requester": "p",
        "gas_price": "q",
        "respData": "r",
        "withdraw": "s",
        "requests": "t",
        "min_fee": "u",
        "deliver": "v",
        "suspend": "w",
        "request": "x",
        "gasLeft": "y",
        "upgrade": "z",
        "restart": "aa",
        "newAddr": "ab",
        "minGas": "ac",
        "cancel": "ad",
        "price": "ae",
        "reset": "af",
        "sha3": "ag",
        "flag": "ah",
        "fee": "ai",
        "id": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_170",
      "transformed_id": "ss_l2_short_nc_ds_170",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\n\ncontract Owned {\n\n\n    modifier l() {\n        require(msg.sender == aa);\n        _;\n    }\n\n    address public aa;\n\n\n    function Owned() {\n        aa = msg.sender;\n    }\n\n    address public r;\n\n\n    function g(address o) l {\n        r = o;\n    }\n\n\n    function c() {\n        if (msg.sender == r) {\n            aa = r;\n        }\n    }\n\n\n    function v(address ag, uint w, bytes ab) l {\n        ag.call.value(w)(ab);\n    }\n}\n\ncontract Marriage is Owned\n{\n\n    string public s;\n    string public u;\n    uint public f;\n    string public d;\n    string public ad;\n\n    Event[] public h;\n    Message[] public t;\n\n    struct Event {\n        uint ae;\n        string ac;\n        string i;\n        string ai;\n    }\n\n    struct Message {\n        uint ae;\n        string q;\n        string af;\n        string ai;\n        uint value;\n    }\n\n    modifier k {\n        require(ah(d) == ah(\"Married\"));\n        _;\n    }\n\n\n    function Marriage(address x) {\n        aa = x;\n    }\n\n    function a() constant public returns (uint) {\n        return h.length;\n    }\n\n    function b() constant public returns (uint) {\n        return t.length;\n    }\n\n\n    function e(\n        string p,\n        string n,\n        string z,\n        string ai) l\n    {\n        require(h.length == 0);\n        s = p;\n        u = n;\n        f = aj;\n        ad = z;\n        d = \"Married\";\n        h.push(Event(aj, \"Marriage\", ad, ai));\n        MajorEvent(\"Marrigage\", ad, ai);\n    }\n\n\n    function m(string y, string ai) l\n    {\n        d = y;\n        setMajorEvent(\"Changed Status\", y, ai);\n    }\n\n\n    function setMajorEvent(string ac, string i, string ai) l k\n    {\n        h.push(Event(aj, ac, i, ai));\n        MajorEvent(ac, i, ai);\n    }\n\n    function j(string q, string af, string ai) payable k {\n        if (msg.value > 0) {\n            aa.transfer(this.balance);\n        }\n        t.push(Message(aj, q, af, ai, msg.value));\n        MessageSent(q, af, ai, msg.value);\n    }\n\n\n    event MajorEvent(string ac, string i, string ai);\n    event MessageSent(string ac, string i, string ai, uint value);\n}",
      "rename_map": {
        "numberOfMajorEvents": "a",
        "numberOfMessages": "b",
        "acceptOwnership": "c",
        "marriageStatus": "d",
        "createMarriage": "e",
        "marriageDate": "f",
        "changeOwner": "g",
        "majorEvents": "h",
        "description": "i",
        "sendMessage": "j",
        "areMarried": "k",
        "onlyOwner": "l",
        "setStatus": "m",
        "_partner2": "n",
        "_newOwner": "o",
        "_partner1": "p",
        "nameFrom": "q",
        "newOwner": "r",
        "partner1": "s",
        "messages": "t",
        "partner2": "u",
        "execute": "v",
        "_value": "w",
        "_owner": "x",
        "status": "y",
        "_vows": "z",
        "owner": "aa",
        "_data": "ab",
        "name": "ac",
        "vows": "ad",
        "date": "ae",
        "text": "af",
        "_dst": "ag",
        "sha3": "ah",
        "url": "ai",
        "now": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_171",
      "transformed_id": "ss_l2_short_nc_ds_171",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract Splitter{\n\n\taddress public m;\n\taddress[] public h;\n\tmapping (uint256 => address) public o;\n\taddress private n;\n\tuint256 private k;\n\tuint256 private l;\n\n\n\tconstructor() payable public{\n\t\tm = msg.sender;\n\t\td();\n\t\td();\n\t\td();\n\t\td();\n\t\to[0] = h[0];\n        o[1] = h[1];\n        o[2] = h[2];\n        o[3] = h[3];\n\t}\n\n\n\tfunction g() public{\n\t\trequire(msg.sender == m);\n\t\tm.transfer(address(this).balance);\n\t}\n\n\n\tfunction a() public constant returns(uint256 c){\n    \treturn h.length;\n  \t}\n\n\n\tfunction d() public returns(address d){\n\t    require(msg.sender == m);\n    \tPuppet p = new Puppet();\n    \th.push(p);\n    \treturn p;\n  \t\t}\n\n\n    function f(uint256 r, address e) public {\n        require(e != address(0));\n        o[r] = e;\n    }\n\n\n    function b() public payable {\n        require(msg.sender == m);\n    \tk = SafeMath.t(msg.value, 4);\n        o[0].call.value(k).gas(800000)();\n        o[1].call.value(k).gas(800000)();\n        o[2].call.value(k).gas(800000)();\n        o[3].call.value(k).gas(800000)();\n        }\n\n\nfunction() payable public{\n\t}\n}\n\ncontract Puppet {\n\n    mapping (uint256 => address) public j;\n    mapping (uint256 => address) public i;\n\n\tconstructor() payable public{\n\n\t\tj[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        i[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\n\n\tfunction() public payable{\n\t    if(msg.sender != j[0]){\n\t\t\tj[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\n\n\tfunction g() public{\n\t\trequire(msg.sender == i[0]);\n\t\ti[0].transfer(address(this).balance);\n\t}\n}\n\n\nlibrary SafeMath {\n\n  function p(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function t(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function s(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function q(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
      "rename_map": {
        "getPuppetCount": "a",
        "fundPuppets": "b",
        "puppetCount": "c",
        "newPuppet": "d",
        "_newExtra": "e",
        "setExtra": "f",
        "withdraw": "g",
        "puppets": "h",
        "master": "i",
        "target": "j",
        "_share": "k",
        "_count": "l",
        "owner": "m",
        "_addy": "n",
        "extra": "o",
        "mul": "p",
        "add": "q",
        "_id": "r",
        "sub": "s",
        "div": "t"
      },
      "changes": [
        "Renamed 20 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_172",
      "transformed_id": "ss_l2_short_nc_ds_172",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\ncontract FundManager {\n\n\naddress public aa = 0x0;\naddress public ad;\naddress public j = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public f = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public u;\n\nmapping(address=>bool) d;\n\nuint256 public y;\nuint256[] public af = [951828771,158769871220];\nuint256[] public balance;\n\n\nfunction DranMe() public payable{\n\tad = msg.sender;\n}\n\n\nmodifier q() {\n    require(msg.sender == ad);\n    _;\n}\n\nmodifier m() {\n    require(msg.sender == aa);\n    _;\n}\n\nmodifier k() {\n    require(d[msg.sender]);\n    _;\n}\n\n\nfunction n() public constant returns(uint256) {\n\treturn af.length;\n}\n\nfunction r(uint256 v) public payable q{\n\ty = v;\n}\n\nfunction e() public constant returns(uint256) {\n\treturn u.length;\n}\n\nfunction t() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction g() public payable{\n\trequire(msg.value >= 0.02 ether);\n\tu.push(msg.sender);\n\td[msg.sender]=true;\n}\n\nfunction b() public payable k{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=ad || h()){\n\t    uint256 ab = 0;\n        msg.sender.transfer(ab);\n\t}\n}\n\nfunction h() private returns(bool){\n    bytes32 ag = o(blockhash(block.number-1));\n    uint256 y = uint256(ag);\n        if(y%5==0){\n            aa = msg.sender;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction c () public payable k {\n\trequire (msg.value >= 0.005 ether);\n\tj.call.value(msg.value)();\n}\n\nfunction a () public payable k {\n\trequire (msg.value >= 0.005 ether);\n\tf.call.value(msg.value)();\n}\n\nfunction x (uint256 ac, uint256 z) public payable k {\n\taf[ac] = z;\n}\n\nfunction w (uint256 ah) public payable k {\n\taf.length = ah;\n}\n\nfunction p (uint256 ae) public payable k returns(uint256) {\n\treturn (ae / (af[0]*af[1]));\n\tif((ae / (af[0]*af[1])) == y) {\n\t\tad = aa;\n\t}\n}\n\nfunction i () public payable k returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == y){\n        return true;\n    }\n}\n\nfunction s() public payable q {\n\tad.call.value(1 wei)();\n}\n\nfunction l() public payable m {\n\taa.transfer(address(this).balance);\n}\n\n\nfunction() public payable{\n\t}\n}",
      "rename_map": {
        "callSecondTarget": "a",
        "manipulateSecret": "b",
        "callFirstTarget": "c",
        "approvedPlayers": "d",
        "getPlayerCount": "e",
        "secondTarget": "f",
        "becomePlayer": "g",
        "unlockSecret": "h",
        "checkSecret": "i",
        "firstTarget": "j",
        "onlyPlayers": "k",
        "claimPrize": "l",
        "onlyWinner": "m",
        "getLength": "n",
        "keccak256": "o",
        "guessSeed": "p",
        "onlyOwner": "q",
        "setSecret": "r",
        "winPrize": "s",
        "getPrize": "t",
        "players": "u",
        "_secret": "v",
        "addSeed": "w",
        "setSeed": "x",
        "secret": "y",
        "_value": "z",
        "winner": "aa",
        "amount": "ab",
        "_index": "ac",
        "owner": "ad",
        "_seed": "ae",
        "seed": "af",
        "hash": "ag",
        "_add": "ah"
      },
      "changes": [
        "Renamed 34 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_173",
      "transformed_id": "ss_l2_short_nc_ds_173",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.11;\n\ncontract Owned {\n    function Owned() {\n        o = msg.sender;\n    }\n\n    address public o;\n\n\n    modifier e { if (msg.sender == o) _; }\n\n    function c(address h) e {\n        o = h;\n    }\n\n\n    function i(address v, uint j, bytes p) e {\n        v.call.value(j)(p);\n    }\n}\n\ncontract Token {\n    function transfer(address, uint) returns(bool);\n    function f(address) constant returns (uint);\n}\n\ncontract TokenSender is Owned {\n    Token public n;\n    uint public a;\n\n    uint public u;\n\n    struct Transfer {\n        address r;\n        uint k;\n    }\n\n    Transfer[] public g;\n\n    function TokenSender(address l) {\n        n = Token(l);\n    }\n\n\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n\n\n    function s(uint[] data) e {\n\n\n        if (u>0) throw;\n\n        uint w;\n        uint m = g.length;\n        g.length = g.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address r = address( data[i] & (D160-1) );\n            uint k = data[i] / D160;\n\n            g[m + i].r = r;\n            g[m + i].k = k;\n            w += k;\n        }\n        a += w;\n    }\n\n\n    function x() e {\n        if (g.length == 0) return;\n\n\n        uint q = u;\n\n        u = g.length;\n\n        if ((q == 0 ) && ( n.f(this) != a)) throw;\n\n        while ((q<g.length) && ( gas() > 150000 )) {\n            uint k = g[q].k;\n            address r = g[q].r;\n            if (k > 0) {\n                if (!n.transfer(r, g[q].k)) throw;\n            }\n            q ++;\n        }\n\n\n        u = q;\n    }\n\n\n    function b() constant returns (bool) {\n        if (g.length == 0) return false;\n        if (u < g.length) return false;\n        return true;\n    }\n\n    function d() constant returns (uint) {\n        return g.length;\n    }\n\n    function gas() internal constant returns (uint t) {\n        assembly {\n            t:= gas\n        }\n    }\n\n}",
      "rename_map": {
        "totalToDistribute": "a",
        "hasTerminated": "b",
        "changeOwner": "c",
        "nTransfers": "d",
        "onlyOwner": "e",
        "balanceOf": "f",
        "transfers": "g",
        "_newOwner": "h",
        "execute": "i",
        "_value": "j",
        "amount": "k",
        "_token": "l",
        "offset": "m",
        "token": "n",
        "owner": "o",
        "_data": "p",
        "mNext": "q",
        "addr": "r",
        "fill": "s",
        "_gas": "t",
        "next": "u",
        "_dst": "v",
        "acc": "w",
        "run": "x"
      },
      "changes": [
        "Renamed 24 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_174",
      "transformed_id": "ss_l2_short_nc_ds_174",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract Lotto {\n\n     uint constant public j = 6800;\n\n\n     uint constant public r = 100000000000000000;\n\n\n     uint constant public s = 5000000000000000000;\n\n     function g() constant returns(uint){ return j; }\n     function k() constant returns(uint){ return r; }\n\n\n     struct Round {\n         address[] ab;\n         uint ai;\n         uint n;\n         mapping(uint=>bool) aa;\n         mapping(address=>uint) c;\n     }\n     mapping(uint => Round) ae;\n\n\n     function m() constant returns (uint){\n\n\n         return block.number/j;\n     }\n\n     function u(uint w,uint t) constant returns (bool){\n\n\n         return ae[w].aa[t];\n     }\n\n     function i(uint w, uint t) constant returns(address){\n\n\n         var d = b(w,t);\n\n         if(d>block.number)\n             return;\n\n\n         var f = l(d);\n         var e = f%ae[w].n;\n\n\n         var q = uint256(0);\n\n         for(var x = 0; x<ae[w].ab.length; x++){\n             var ag = ae[w].ab[x];\n             q+=ae[w].c[ag];\n\n             if(q>e){\n                 return ag;\n             }\n         }\n     }\n\n     function b(uint w,uint t) constant returns (uint){\n         return ((w+1)*j)+t;\n     }\n\n     function h(uint w) constant returns(uint){\n         var o = ae[w].ai/s;\n\n         if(ae[w].ai%s>0)\n             o++;\n\n         return o;\n     }\n\n     function y(uint w) constant returns(uint){\n         return ae[w].ai/h(w);\n     }\n\n     function ah(uint w, uint t){\n\n         var o = h(w);\n\n         if(t>=o)\n             return;\n\n         var d = b(w,t);\n\n         if(d>block.number)\n             return;\n\n         if(ae[w].aa[t])\n             return;\n\n\n         var ad = i(w,t);\n         var ac = y(w);\n\n         ad.send(ac);\n\n         ae[w].aa[t] = true;\n\n     }\n\n     function l(uint v) constant returns(uint){\n         return uint(block.blockhash(v));\n     }\n\n     function z(uint w,address ag) constant returns (address[]){\n         return ae[w].ab;\n     }\n\n     function a(uint w,address ag) constant returns (uint){\n         return ae[w].c[ag];\n     }\n\n     function af(uint w) constant returns(uint){\n         return ae[w].ai;\n     }\n\n     function() {\n\n\n         var w = m();\n         var value = msg.value-(msg.value%r);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n             msg.sender.send(msg.value-value);\n         }\n\n\n         var n = value/r;\n         ae[w].n+=n;\n\n         if(ae[w].c[msg.sender]==0){\n             var p = ae[w].ab.length++;\n             ae[w].ab[p] = msg.sender;\n         }\n\n         ae[w].c[msg.sender]+=n;\n         ae[w].n+=n;\n\n\n         ae[w].ai+=value;\n\n\n     }\n\n }",
      "rename_map": {
        "getTicketsCountByBuyer": "a",
        "getDecisionBlockNumber": "b",
        "ticketsCountByBuyer": "c",
        "decisionBlockNumber": "d",
        "winningTicketIndex": "e",
        "decisionBlockHash": "f",
        "getBlocksPerRound": "g",
        "getSubpotsCount": "h",
        "calculateWinner": "i",
        "blocksPerRound": "j",
        "getTicketPrice": "k",
        "getHashOfBlock": "l",
        "getRoundIndex": "m",
        "ticketsCount": "n",
        "subpotsCount": "o",
        "buyersLength": "p",
        "ticketIndex": "q",
        "ticketPrice": "r",
        "blockReward": "s",
        "subpotIndex": "t",
        "getIsCashed": "u",
        "blockIndex": "v",
        "roundIndex": "w",
        "buyerIndex": "x",
        "getSubpot": "y",
        "getBuyers": "z",
        "isCashed": "aa",
        "buyers": "ab",
        "subpot": "ac",
        "winner": "ad",
        "rounds": "ae",
        "getPot": "af",
        "buyer": "ag",
        "cash": "ah",
        "pot": "ai"
      },
      "changes": [
        "Renamed 35 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_201",
      "transformed_id": "ss_l2_short_nc_ds_201",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address c)\n    {\n        TransferLog = Log(c);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint f)\n    {\n        if(f<=a[msg.sender])\n        {\n\n            if(msg.sender.call.value(f)())\n            {\n                a[msg.sender]-=f;\n                TransferLog.AddMessage(msg.sender,f,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address d,uint e,string b)\n    public\n    {\n        LastMsg.Sender = d;\n        LastMsg.Time = g;\n        LastMsg.Val = e;\n        LastMsg.Data = b;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "a",
        "_data": "b",
        "_log": "c",
        "_adr": "d",
        "_val": "e",
        "_am": "f",
        "now": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_202",
      "transformed_id": "ss_l2_short_nc_ds_202",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Multiplicator\n{\n    address public Owner = msg.sender;\n\n    function()payable{}\n\n    function b()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function a(address c)\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            c.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "a",
        "withdraw": "b",
        "adr": "c"
      },
      "changes": [
        "Renamed 3 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_203",
      "transformed_id": "ss_l2_short_nc_ds_203",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\n\ncontract Ownable {\n    address public d;\n    function Ownable() public {d = msg.sender;}\n    modifier b() {require(msg.sender == d); _;\n    }\n}\n\n\ncontract CEOThrone is Ownable {\n    address public d;\n    uint public a;\n\n\n    function Stake() public payable {\n\n        if (msg.value > a) {\n            d = msg.sender;\n            a = msg.value;\n        }\n    }\n\n    function c() public b {\n\n        msg.sender.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "largestStake": "a",
        "onlyOwner": "b",
        "withdraw": "c",
        "owner": "d"
      },
      "changes": [
        "Renamed 4 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_204",
      "transformed_id": "ss_l2_short_nc_ds_204",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "contract OpenAddressLottery{\n    struct SeedComponents{\n        uint g;\n        uint e;\n        uint j;\n        uint i;\n    }\n\n    address n;\n    uint private h;\n    uint private d;\n    uint LuckyNumber = 7;\n\n    mapping (address => bool) m;\n\n    function OpenAddressLottery() {\n        n = msg.sender;\n        l(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n    }\n\n    function b() payable {\n        if(msg.value<0.1 ether)\n            return;\n\n\n        require(m[msg.sender] == false);\n\n        if(a(msg.sender) == LuckyNumber){\n            m[msg.sender] = true;\n\n            uint q=msg.value*7;\n\n            if(q>this.balance)\n                q=this.balance;\n            msg.sender.transfer(q);\n        }\n\n        if(block.number-d>1000)\n            l(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp));\n    }\n\n    function a(address p) constant returns(uint n){\n\n        n = uint(k(uint(p), h)[0]) % 8;\n    }\n\n    function l(SeedComponents f) internal {\n        h = uint256(k(\n            f.g,\n            f.e,\n            f.j,\n            f.i\n        ));\n        d = block.number;\n    }\n\n    function o() {\n        require(msg.sender==n);\n\n        selfdestruct(msg.sender);\n    }\n\n    function c() {\n        require(msg.sender==n);\n\n        SeedComponents s;\n        s.g = uint(msg.sender);\n        s.e = uint256(block.blockhash(block.number - 1));\n        s.j = block.difficulty*(uint)(block.coinbase);\n        s.i = tx.gasprice * 7;\n\n        l(s);\n    }\n\n    function () payable {\n        if(msg.value>=0.1 ether && msg.sender!=n)\n            b();\n    }\n\n}",
      "rename_map": {
        "luckyNumberOfAddress": "a",
        "participate": "b",
        "forceReseed": "c",
        "lastReseed": "d",
        "component2": "e",
        "components": "f",
        "component1": "g",
        "secretSeed": "h",
        "component4": "i",
        "component3": "j",
        "keccak256": "k",
        "reseed": "l",
        "winner": "m",
        "owner": "n",
        "kill": "o",
        "addr": "p",
        "win": "q"
      },
      "changes": [
        "Renamed 17 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_205",
      "transformed_id": "ss_l2_short_nc_ds_205",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract NEW_YEARS_GIFT\n{\n    string d;\n\n    bool a = false;\n\n    address sender;\n\n    bytes32 public c;\n\n    function() public payable{}\n\n    function GetHash(bytes e) public constant returns (bytes32) {return g(e);}\n\n    function SetPass(bytes32 f)\n    public\n    payable\n    {\n        if( (!a&&(msg.value > 1 ether)) || c==0x0 )\n        {\n            c = f;\n            sender = msg.sender;\n        }\n    }\n\n    function SetMessage(string b)\n    public\n    {\n        if(msg.sender==sender)\n        {\n            d =b;\n        }\n    }\n\n    function GetGift(bytes e)\n    external\n    payable\n    returns (string)\n    {\n        if(c == g(e))\n        {\n            msg.sender.transfer(this.balance);\n            return d;\n        }\n    }\n\n    function Revoce()\n    public\n    payable\n    {\n        if(msg.sender==sender)\n        {\n            sender.transfer(this.balance);\n            d=\"\";\n        }\n    }\n\n    function PassHasBeenSet(bytes32 f)\n    public\n    {\n        if(msg.sender==sender&&f==c)\n        {\n           a=true;\n        }\n    }\n}",
      "rename_map": {
        "passHasBeenSet": "a",
        "_message": "b",
        "hashPass": "c",
        "message": "d",
        "pass": "e",
        "hash": "f",
        "sha3": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_206",
      "transformed_id": "ss_l2_short_nc_ds_206",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.18;\n\ncontract Test1\n{\n    address b = msg.sender;\n\n    function a()\n    payable\n    public\n    {\n        require(msg.sender==b);\n        b.transfer(this.balance);\n    }\n\n    function() payable {}\n\n    function Test()\n    payable\n    public\n    {\n        if(msg.value>=1 ether)\n        {\n\n            var d = 1;\n            var e = 0;\n            var c = msg.value*2;\n\n            while(true)\n            {\n                if(d<e)break;\n                if(d>c)break;\n\n                e=d;\n                d++;\n            }\n            msg.sender.transfer(e);\n        }\n    }\n}",
      "rename_map": {
        "withdraw": "a",
        "owner": "b",
        "amX2": "c",
        "i1": "d",
        "i2": "e"
      },
      "changes": [
        "Renamed 5 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_207",
      "transformed_id": "ss_l2_short_nc_ds_207",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\n\ncontract ERC20 {\n    function b() constant returns (uint b);\n    function d(address n) constant returns (uint balance);\n    function transfer(address s, uint k) returns (bool i);\n    function a(address r, address s, uint k) returns (bool i);\n    function j(address h, uint k) returns (bool i);\n    function f(address n, address h) constant returns (uint e);\n    event Transfer(address indexed r, address indexed s, uint k);\n    event Approval(address indexed n, address indexed h, uint k);\n}\n\ncontract TokenExchange{\n    address private p;\n    uint public q;\n    ERC20 o;\n\n    function TokenExchange(uint l, ERC20 m)\n        public\n    {\n        p = msg.sender;\n        q = l;\n        o = m;\n    }\n\n\n    function t(uint g) payable\n        public\n    {\n        require(msg.value >= q);\n\n\n        o.a(msg.sender, p, q);\n\n        q = g;\n        p = msg.sender;\n    }\n\n    function c(uint g){\n        require(msg.sender == p);\n        q = g;\n    }\n\n}",
      "rename_map": {
        "transferFrom": "a",
        "totalSupply": "b",
        "changePrice": "c",
        "balanceOf": "d",
        "remaining": "e",
        "allowance": "f",
        "new_price": "g",
        "_spender": "h",
        "success": "i",
        "approve": "j",
        "_value": "k",
        "_price": "l",
        "_token": "m",
        "_owner": "n",
        "token": "o",
        "owner": "p",
        "price": "q",
        "_from": "r",
        "_to": "s",
        "buy": "t"
      },
      "changes": [
        "Renamed 20 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_208",
      "transformed_id": "ss_l2_short_nc_ds_208",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.4.9;\n\ncontract WalletEvents {\n\n\n  event Confirmation(address bp, bytes32 ag);\n  event Revoke(address bp, bytes32 ag);\n\n\n  event OwnerChanged(address at, address an);\n  event OwnerAdded(address an);\n  event OwnerRemoved(address at);\n\n\n  event RequirementChanged(uint i);\n\n\n  event Deposit(address bk, uint value);\n\n  event SingleTransact(address bp, uint value, address bx, bytes data, address aw);\n\n  event MultiTransact(address bp, bytes32 ag, uint value, address bx, bytes data, address aw);\n\n  event ConfirmationNeeded(bytes32 ag, address ai, uint value, address bx, bytes data);\n}\n\ncontract WalletAbi {\n\n  function bg(bytes32 ab) external;\n\n\n  function u(address bk, address bv) external;\n\n  function as(address bd) external;\n\n  function w(address bd) external;\n\n  function a(uint p) external;\n\n  function az(address bm) constant returns (bool);\n\n  function n(bytes32 ab, address bd) external constant returns (bool);\n\n\n  function k(uint ah) external;\n\n  function au(address bv, uint be, bytes bq) external returns (bytes32 bf);\n  function ba(bytes32 by) returns (bool am);\n}\n\ncontract WalletLibrary is WalletEvents {\n\n\n  struct PendingState {\n    uint aj;\n    uint aa;\n    uint bn;\n  }\n\n\n  struct Transaction {\n    address bx;\n    uint value;\n    bytes data;\n  }\n\n\n  modifier af {\n    if (az(msg.sender))\n      _;\n  }\n\n\n  modifier g(bytes32 ab) {\n    if (e(ab))\n      _;\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n\n  function f(address[] ay, uint ak) {\n    t = ay.length + 1;\n    aq[1] = uint(msg.sender);\n    s[uint(msg.sender)] = 1;\n    for (uint i = 0; i < ay.length; ++i)\n    {\n      aq[2 + i] = uint(ay[i]);\n      s[uint(ay[i])] = 2 + i;\n    }\n    z = ak;\n  }\n\n\n  function bg(bytes32 ab) external {\n    uint x = s[uint(msg.sender)];\n\n    if (x == 0) return;\n    uint j = 2**x;\n    var ax = ad[ab];\n    if (ax.aa & j > 0) {\n      ax.aj++;\n      ax.aa -= j;\n      Revoke(msg.sender, ab);\n    }\n  }\n\n\n  function u(address bk, address bv) g(bt(msg.data)) external {\n    if (az(bv)) return;\n    uint x = s[uint(bk)];\n    if (x == 0) return;\n\n    o();\n    aq[x] = uint(bv);\n    s[uint(bk)] = 0;\n    s[uint(bv)] = x;\n    OwnerChanged(bk, bv);\n  }\n\n  function as(address bd) g(bt(msg.data)) external {\n    if (az(bd)) return;\n\n    o();\n    if (t >= v)\n      b();\n    if (t >= v)\n      return;\n    t++;\n    aq[t] = uint(bd);\n    s[uint(bd)] = t;\n    OwnerAdded(bd);\n  }\n\n  function w(address bd) g(bt(msg.data)) external {\n    uint x = s[uint(bd)];\n    if (x == 0) return;\n    if (z > t - 1) return;\n\n    aq[x] = 0;\n    s[uint(bd)] = 0;\n    o();\n    b();\n    OwnerRemoved(bd);\n  }\n\n  function a(uint p) g(bt(msg.data)) external {\n    if (p > t) return;\n    z = p;\n    o();\n    RequirementChanged(p);\n  }\n\n\n  function ap(uint x) external constant returns (address) {\n    return address(aq[x + 1]);\n  }\n\n  function az(address bm) constant returns (bool) {\n    return s[uint(bm)] > 0;\n  }\n\n  function n(bytes32 ab, address bd) external constant returns (bool) {\n    var ax = ad[ab];\n    uint x = s[uint(bd)];\n\n\n    if (x == 0) return false;\n\n\n    uint j = 2**x;\n    return !(ax.aa & j == 0);\n  }\n\n\n  function l(uint bh) {\n    m = bh;\n    ae = br();\n  }\n\n  function k(uint ah) g(bt(msg.data)) external {\n    m = ah;\n  }\n\n  function d() g(bt(msg.data)) external {\n    q = 0;\n  }\n\n\n  function ac(address[] ay, uint ak, uint al) {\n    l(al);\n    f(ay, ak);\n  }\n\n\n  function bu(address bv) g(bt(msg.data)) external {\n    suicide(bv);\n  }\n\n\n  function au(address bv, uint be, bytes bq) external af returns (bytes32 bf) {\n\n    if ((bq.length == 0 && y(be)) || z == 1) {\n\n      address aw;\n      if (bv == 0) {\n        aw = bc(be, bq);\n      } else {\n        if (!bv.call.value(be)(bq))\n          throw;\n      }\n      SingleTransact(msg.sender, be, bv, bq, aw);\n    } else {\n\n      bf = bt(msg.data, block.number);\n\n      if (bl[bf].bx == 0 && bl[bf].value == 0 && bl[bf].data.length == 0) {\n        bl[bf].bx = bv;\n        bl[bf].value = be;\n        bl[bf].data = bq;\n      }\n      if (!ba(bf)) {\n        ConfirmationNeeded(bf, msg.sender, be, bv, bq);\n      }\n    }\n  }\n\n  function bc(uint be, bytes bo) internal returns (address bb) {\n    assembly {\n      bb := bc(be, add(bo, 0x20), mload(bo))\n      bj(c, iszero(extcodesize(bb)))\n    }\n  }\n\n\n  function ba(bytes32 by) g(by) returns (bool am) {\n    if (bl[by].bx != 0 || bl[by].value != 0 || bl[by].data.length != 0) {\n      address aw;\n      if (bl[by].bx == 0) {\n        aw = bc(bl[by].value, bl[by].data);\n      } else {\n        if (!bl[by].bx.call.value(bl[by].value)(bl[by].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, by, bl[by].value, bl[by].bx, bl[by].data, aw);\n      delete bl[by];\n      return true;\n    }\n  }\n\n\n  function e(bytes32 ab) internal returns (bool) {\n\n    uint x = s[uint(msg.sender)];\n\n    if (x == 0) return;\n\n    var ax = ad[ab];\n\n    if (ax.aj == 0) {\n\n      ax.aj = z;\n\n      ax.aa = 0;\n      ax.bn = h.length++;\n      h[ax.bn] = ab;\n    }\n\n    uint j = 2**x;\n\n    if (ax.aa & j == 0) {\n      Confirmation(msg.sender, ab);\n\n      if (ax.aj <= 1) {\n\n        delete h[ad[ab].bn];\n        delete ad[ab];\n        return true;\n      }\n      else\n      {\n\n        ax.aj--;\n        ax.aa |= j;\n      }\n    }\n  }\n\n  function b() private {\n    uint bs = 1;\n    while (bs < t)\n    {\n      while (bs < t && aq[bs] != 0) bs++;\n      while (t > 1 && aq[t] == 0) t--;\n      if (bs < t && aq[t] != 0 && aq[bs] == 0)\n      {\n        aq[bs] = aq[t];\n        s[aq[bs]] = bs;\n        aq[t] = 0;\n      }\n    }\n  }\n\n\n  function y(uint be) internal af returns (bool) {\n\n    if (br() > ae) {\n      q = 0;\n      ae = br();\n    }\n\n\n    if (q + be >= q && q + be <= m) {\n      q += be;\n      return true;\n    }\n    return false;\n  }\n\n\n  function br() private constant returns (uint) { return bw / 1 days; }\n\n  function o() internal {\n    uint length = h.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete bl[h[i]];\n\n      if (h[i] != 0)\n        delete ad[h[i]];\n    }\n\n    delete h;\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public z;\n\n  uint public t;\n\n  uint public m;\n  uint public q;\n  uint public ae;\n\n\n  uint[256] aq;\n\n  uint constant v = 250;\n\n  mapping(uint => uint) s;\n\n  mapping(bytes32 => PendingState) ad;\n  bytes32[] h;\n\n\n  mapping (bytes32 => Transaction) bl;\n}\n\ncontract Wallet is WalletEvents {\n\n\n  function Wallet(address[] ay, uint ak, uint al) {\n\n    bytes4 sig = bytes4(bt(\"initWallet(address[],uint256,uint256)\"));\n    address bi = _walletLibrary;\n\n\n    uint r = (2 + ay.length);\n    uint av = (2 + r) * 32;\n\n    assembly {\n\n      mstore(0x0, sig)\n\n\n      ar(0x4,  sub(ao, av), av)\n\n      delegatecall(sub(gas, 10000), bi, 0x0, add(av, 0x4), 0x0, 0x0)\n    }\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n\n  function ap(uint x) constant returns (address) {\n    return address(aq[x + 1]);\n  }\n\n\n  function n(bytes32 ab, address bd) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function az(address bm) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public z;\n\n  uint public t;\n\n  uint public m;\n  uint public q;\n  uint public ae;\n\n\n  uint[256] aq;\n}",
      "rename_map": {
        "changeRequirement": "a",
        "reorganizeOwners": "b",
        "invalidJumpLabel": "c",
        "resetSpentToday": "d",
        "confirmAndCheck": "e",
        "initMultiowned": "f",
        "onlymanyowners": "g",
        "m_pendingIndex": "h",
        "newRequirement": "i",
        "ownerIndexBit": "j",
        "setDailyLimit": "k",
        "initDaylimit": "l",
        "m_dailyLimit": "m",
        "hasConfirmed": "n",
        "clearPending": "o",
        "_newRequired": "p",
        "m_spentToday": "q",
        "argarraysize": "r",
        "m_ownerIndex": "s",
        "m_numOwners": "t",
        "changeOwner": "u",
        "c_maxOwners": "v",
        "removeOwner": "w",
        "ownerIndex": "x",
        "underLimit": "y",
        "m_required": "z",
        "ownersDone": "aa",
        "_operation": "ab",
        "initWallet": "ac",
        "m_pending": "ad",
        "m_lastDay": "ae",
        "onlyowner": "af",
        "operation": "ag",
        "_newLimit": "ah",
        "initiator": "ai",
        "yetNeeded": "aj",
        "_required": "ak",
        "_daylimit": "al",
        "o_success": "am",
        "newOwner": "an",
        "codesize": "ao",
        "getOwner": "ap",
        "m_owners": "aq",
        "codecopy": "ar",
        "addOwner": "as",
        "oldOwner": "at",
        "execute": "au",
        "argsize": "av",
        "created": "aw",
        "pending": "ax",
        "_owners": "ay",
        "isOwner": "az",
        "confirm": "ba",
        "o_addr": "bb",
        "create": "bc",
        "_owner": "bd",
        "_value": "be",
        "o_hash": "bf",
        "revoke": "bg",
        "_limit": "bh",
        "target": "bi",
        "jumpi": "bj",
        "_from": "bk",
        "m_txs": "bl",
        "_addr": "bm",
        "index": "bn",
        "_code": "bo",
        "owner": "bp",
        "_data": "bq",
        "today": "br",
        "free": "bs",
        "sha3": "bt",
        "kill": "bu",
        "_to": "bv",
        "now": "bw",
        "to": "bx",
        "_h": "by"
      },
      "changes": [
        "Renamed 77 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_209",
      "transformed_id": "ss_l2_short_nc_ds_209",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\ncontract WalletEvents {\n\n\n  event Confirmation(address bf, bytes32 ai);\n  event Revoke(address bf, bytes32 ai);\n\n\n  event OwnerChanged(address an, address ao);\n  event OwnerAdded(address ao);\n  event OwnerRemoved(address an);\n\n\n  event RequirementChanged(uint g);\n\n\n  event Deposit(address bj, uint value);\n\n  event SingleTransact(address bf, uint value, address bs, bytes data, address aw);\n\n  event MultiTransact(address bf, bytes32 ai, uint value, address bs, bytes data, address aw);\n\n  event ConfirmationNeeded(bytes32 ai, address ac, uint value, address bs, bytes data);\n}\n\ncontract WalletAbi {\n\n  function ay(bytes32 w) external;\n\n\n  function u(address bj, address bp) external;\n\n  function aq(address bc) external;\n\n  function s(address bc) external;\n\n  function b(uint m) external;\n\n  function at(address bg) constant returns (bool);\n\n  function q(bytes32 w, address bc) external constant returns (bool);\n\n\n  function j(uint al) external;\n\n  function av(address bp, uint ax, bytes bh) external returns (bytes32 ba);\n  function au(bytes32 br) returns (bool aj);\n}\n\ncontract WalletLibrary is WalletEvents {\n\n\n  struct PendingState {\n    uint ae;\n    uint x;\n    uint bi;\n  }\n\n\n  struct Transaction {\n    address bs;\n    uint value;\n    bytes data;\n  }\n\n\n  modifier ad {\n    if (at(msg.sender))\n      _;\n  }\n\n\n  modifier i(bytes32 w) {\n    if (d(w))\n      _;\n  }\n\n\n  function() payable {\n\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n\n  function f(address[] as, uint af) a {\n    t = as.length + 1;\n    ap[1] = uint(msg.sender);\n    n[uint(msg.sender)] = 1;\n    for (uint i = 0; i < as.length; ++i)\n    {\n      ap[2 + i] = uint(as[i]);\n      n[uint(as[i])] = 2 + i;\n    }\n    aa = af;\n  }\n\n\n  function ay(bytes32 w) external {\n    uint y = n[uint(msg.sender)];\n\n    if (y == 0) return;\n    uint k = 2**y;\n    var ar = ag[w];\n    if (ar.x & k > 0) {\n      ar.ae++;\n      ar.x -= k;\n      Revoke(msg.sender, w);\n    }\n  }\n\n\n  function u(address bj, address bp) i(bo(msg.data)) external {\n    if (at(bp)) return;\n    uint y = n[uint(bj)];\n    if (y == 0) return;\n\n    r();\n    ap[y] = uint(bp);\n    n[uint(bj)] = 0;\n    n[uint(bp)] = y;\n    OwnerChanged(bj, bp);\n  }\n\n  function aq(address bc) i(bo(msg.data)) external {\n    if (at(bc)) return;\n\n    r();\n    if (t >= v)\n      c();\n    if (t >= v)\n      return;\n    t++;\n    ap[t] = uint(bc);\n    n[uint(bc)] = t;\n    OwnerAdded(bc);\n  }\n\n  function s(address bc) i(bo(msg.data)) external {\n    uint y = n[uint(bc)];\n    if (y == 0) return;\n    if (aa > t - 1) return;\n\n    ap[y] = 0;\n    n[uint(bc)] = 0;\n    r();\n    c();\n    OwnerRemoved(bc);\n  }\n\n  function b(uint m) i(bo(msg.data)) external {\n    if (m > t) return;\n    aa = m;\n    r();\n    RequirementChanged(m);\n  }\n\n\n  function am(uint y) external constant returns (address) {\n    return address(ap[y + 1]);\n  }\n\n  function at(address bg) constant returns (bool) {\n    return n[uint(bg)] > 0;\n  }\n\n  function q(bytes32 w, address bc) external constant returns (bool) {\n    var ar = ag[w];\n    uint y = n[uint(bc)];\n\n\n    if (y == 0) return false;\n\n\n    uint k = 2**y;\n    return !(ar.x & k == 0);\n  }\n\n\n  function l(uint bd) a {\n    p = bd;\n    ak = bk();\n  }\n\n  function j(uint al) i(bo(msg.data)) external {\n    p = al;\n  }\n\n  function e() i(bo(msg.data)) external {\n    o = 0;\n  }\n\n\n  modifier a { if (t > 0) throw; _; }\n\n\n  function ab(address[] as, uint af, uint ah) a {\n    l(ah);\n    f(as, af);\n  }\n\n\n  function bm(address bp) i(bo(msg.data)) external {\n    suicide(bp);\n  }\n\n\n  function av(address bp, uint ax, bytes bh) external ad returns (bytes32 ba) {\n\n    if ((bh.length == 0 && z(ax)) || aa == 1) {\n\n      address aw;\n      if (bp == 0) {\n        aw = bb(ax, bh);\n      } else {\n        if (!bp.call.value(ax)(bh))\n          throw;\n      }\n      SingleTransact(msg.sender, ax, bp, bh, aw);\n    } else {\n\n      ba = bo(msg.data, block.number);\n\n      if (be[ba].bs == 0 && be[ba].value == 0 && be[ba].data.length == 0) {\n        be[ba].bs = bp;\n        be[ba].value = ax;\n        be[ba].data = bh;\n      }\n      if (!au(ba)) {\n        ConfirmationNeeded(ba, msg.sender, ax, bp, bh);\n      }\n    }\n  }\n\n  function bb(uint ax, bytes bl) internal returns (address az) {\n  }\n\n\n  function au(bytes32 br) i(br) returns (bool aj) {\n    if (be[br].bs != 0 || be[br].value != 0 || be[br].data.length != 0) {\n      address aw;\n      if (be[br].bs == 0) {\n        aw = bb(be[br].value, be[br].data);\n      } else {\n        if (!be[br].bs.call.value(be[br].value)(be[br].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, br, be[br].value, be[br].bs, be[br].data, aw);\n      delete be[br];\n      return true;\n    }\n  }\n\n\n  function d(bytes32 w) internal returns (bool) {\n\n    uint y = n[uint(msg.sender)];\n\n    if (y == 0) return;\n\n    var ar = ag[w];\n\n    if (ar.ae == 0) {\n\n      ar.ae = aa;\n\n      ar.x = 0;\n      ar.bi = h.length++;\n      h[ar.bi] = w;\n    }\n\n    uint k = 2**y;\n\n    if (ar.x & k == 0) {\n      Confirmation(msg.sender, w);\n\n      if (ar.ae <= 1) {\n\n        delete h[ag[w].bi];\n        delete ag[w];\n        return true;\n      }\n      else\n      {\n\n        ar.ae--;\n        ar.x |= k;\n      }\n    }\n  }\n\n  function c() private {\n    uint bn = 1;\n    while (bn < t)\n    {\n      while (bn < t && ap[bn] != 0) bn++;\n      while (t > 1 && ap[t] == 0) t--;\n      if (bn < t && ap[t] != 0 && ap[bn] == 0)\n      {\n        ap[bn] = ap[t];\n        n[ap[bn]] = bn;\n        ap[t] = 0;\n      }\n    }\n  }\n\n\n  function z(uint ax) internal ad returns (bool) {\n\n    if (bk() > ak) {\n      o = 0;\n      ak = bk();\n    }\n\n\n    if (o + ax >= o && o + ax <= p) {\n      o += ax;\n      return true;\n    }\n    return false;\n  }\n\n\n  function bk() private constant returns (uint) { return bq / 1 days; }\n\n  function r() internal {\n    uint length = h.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete be[h[i]];\n\n      if (h[i] != 0)\n        delete ag[h[i]];\n    }\n\n    delete h;\n  }\n\n\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n\n  uint public aa;\n\n  uint public t;\n\n  uint public p;\n  uint public o;\n  uint public ak;\n\n\n  uint[256] ap;\n\n  uint constant v = 250;\n\n  mapping(uint => uint) n;\n\n  mapping(bytes32 => PendingState) ag;\n  bytes32[] h;\n\n\n  mapping (bytes32 => Transaction) be;\n}",
      "rename_map": {
        "only_uninitialized": "a",
        "changeRequirement": "b",
        "reorganizeOwners": "c",
        "confirmAndCheck": "d",
        "resetSpentToday": "e",
        "initMultiowned": "f",
        "newRequirement": "g",
        "m_pendingIndex": "h",
        "onlymanyowners": "i",
        "setDailyLimit": "j",
        "ownerIndexBit": "k",
        "initDaylimit": "l",
        "_newRequired": "m",
        "m_ownerIndex": "n",
        "m_spentToday": "o",
        "m_dailyLimit": "p",
        "hasConfirmed": "q",
        "clearPending": "r",
        "removeOwner": "s",
        "m_numOwners": "t",
        "changeOwner": "u",
        "c_maxOwners": "v",
        "_operation": "w",
        "ownersDone": "x",
        "ownerIndex": "y",
        "underLimit": "z",
        "m_required": "aa",
        "initWallet": "ab",
        "initiator": "ac",
        "onlyowner": "ad",
        "yetNeeded": "ae",
        "_required": "af",
        "m_pending": "ag",
        "_daylimit": "ah",
        "operation": "ai",
        "o_success": "aj",
        "m_lastDay": "ak",
        "_newLimit": "al",
        "getOwner": "am",
        "oldOwner": "an",
        "newOwner": "ao",
        "m_owners": "ap",
        "addOwner": "aq",
        "pending": "ar",
        "_owners": "as",
        "isOwner": "at",
        "confirm": "au",
        "execute": "av",
        "created": "aw",
        "_value": "ax",
        "revoke": "ay",
        "o_addr": "az",
        "o_hash": "ba",
        "create": "bb",
        "_owner": "bc",
        "_limit": "bd",
        "m_txs": "be",
        "owner": "bf",
        "_addr": "bg",
        "_data": "bh",
        "index": "bi",
        "_from": "bj",
        "today": "bk",
        "_code": "bl",
        "kill": "bm",
        "free": "bn",
        "sha3": "bo",
        "_to": "bp",
        "now": "bq",
        "_h": "br",
        "to": "bs"
      },
      "changes": [
        "Renamed 71 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_210",
      "transformed_id": "ss_l2_short_nc_ds_210",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract LuckyDoubler {\n\n\n    address private ab;\n\n\n    uint private balance = 0;\n    uint private an = 5;\n    uint private k = 125;\n\n    mapping (address => User) private ac;\n    Entry[] private t;\n    uint[] private f;\n\n\n    function LuckyDoubler() {\n        ab = msg.sender;\n    }\n\n    modifier n { if (msg.sender == ab) _; }\n\n    struct User {\n        address ap;\n        uint q;\n        uint d;\n    }\n\n    struct Entry {\n        address h;\n        uint s;\n        uint x;\n        bool aj;\n    }\n\n\n    function() {\n        ah();\n    }\n\n    function ah() private{\n\n        if (msg.value < 1 ether) {\n             msg.sender.send(msg.value);\n            return;\n        }\n\n        ai();\n    }\n\n    function ai() private {\n\n\n        uint w = 1 ether;\n\n        if (msg.value > 1 ether) {\n\n        \tmsg.sender.send(msg.value - 1 ether);\n        \tw = 1 ether;\n        }\n\n\n        if (ac[msg.sender].ap == address(0))\n        {\n            ac[msg.sender].ap = msg.sender;\n            ac[msg.sender].q = 0;\n            ac[msg.sender].d = 0;\n        }\n\n\n        t.push(Entry(msg.sender, w, (w * (k) / 100), false));\n        ac[msg.sender].q++;\n        f.push(t.length -1);\n\n\n        balance += (w * (100 - an)) / 100;\n\n        uint ad = f.length > 1 ? am(f.length) : 0;\n        Entry r = t[f[ad]];\n\n\n        if (balance > r.x) {\n\n            uint x = r.x;\n\n            r.h.send(x);\n            r.aj = true;\n            ac[r.h].d++;\n\n            balance -= x;\n\n            if (ad < f.length - 1)\n                f[ad] = f[f.length - 1];\n\n            f.length--;\n\n        }\n\n\n        uint ak = this.balance - balance;\n        if (ak > 0)\n        {\n                ab.send(ak);\n        }\n\n    }\n\n\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function am(uint ao) constant private returns (uint256 z){\n        uint256 aa = FACTOR * 100 / ao;\n        uint256 c = block.number - 1;\n        uint256 v = uint256(block.blockhash(c));\n\n        return uint256((uint256(v) / aa)) % ao;\n    }\n\n\n    function j(address p) n {\n        ab = p;\n    }\n\n    function a(uint ae) n {\n        if (ae < 110 || ae > 150) throw;\n\n        k = ae;\n    }\n\n    function o(uint y) n {\n        if (an > 5)\n            throw;\n        an = y;\n    }\n\n\n    function b() constant returns (uint aa, string ag) {\n        aa = k;\n        ag = 'The current k applied to all q. Min 110%, ao 150%.';\n    }\n\n    function l() constant returns (uint e, string ag) {\n        e = an;\n        ag = 'The an percentage applied to all q. It can change to speed u (ao 5%).';\n    }\n\n    function g() constant returns (uint af, string ag) {\n        af = t.length;\n        ag = 'The number of q.';\n    }\n\n    function m(address al) constant returns (uint q, uint u, string ag)\n    {\n        if (ac[al].ap != address(0x0))\n        {\n            q = ac[al].q;\n            u = ac[al].d;\n            ag = 'Users stats: total q, u received.';\n        }\n    }\n\n    function i(uint ad) constant returns (address al, uint x, bool aj, string ag)\n    {\n        if (ad < t.length) {\n            al = t[ad].h;\n            x = t[ad].x / 1 finney;\n            aj = t[ad].aj;\n            ag = 'Entry ag: al address, expected x in Finneys, x status.';\n        }\n    }\n\n}",
      "rename_map": {
        "changeMultiplier": "a",
        "multiplierFactor": "b",
        "lastBlockNumber": "c",
        "payoutsReceived": "d",
        "feePercentage": "e",
        "unpaidEntries": "f",
        "totalEntries": "g",
        "entryAddress": "h",
        "entryDetails": "i",
        "changeOwner": "j",
        "multiplier": "k",
        "currentFee": "l",
        "userStats": "m",
        "onlyowner": "n",
        "changeFee": "o",
        "newOwner": "p",
        "deposits": "q",
        "theEntry": "r",
        "deposit": "s",
        "entries": "t",
        "payouts": "u",
        "hashVal": "v",
        "dValue": "w",
        "payout": "x",
        "newFee": "y",
        "result": "z",
        "factor": "aa",
        "owner": "ab",
        "users": "ac",
        "index": "ad",
        "multi": "ae",
        "count": "af",
        "info": "ag",
        "init": "ah",
        "join": "ai",
        "paid": "aj",
        "fees": "ak",
        "user": "al",
        "rand": "am",
        "fee": "an",
        "max": "ao",
        "id": "ap"
      },
      "changes": [
        "Renamed 42 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_211",
      "transformed_id": "ss_l2_short_nc_ds_211",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.23;\n\n\n contract Token {\n\n     uint256 public ao;\n\n\n     function bw(address cx) public constant returns (uint256 balance);\n\n\n     function transfer(address ei, uint256 cz) public returns (bool cp);\n\n\n     function aj(address dl, address ei, uint256 cz) public returns (bool cp);\n\n\n     function ct(address cc, uint256 cz) public returns (bool cp);\n\n\n     function bt(address cx, address cc) public constant returns (uint256 bp);\n\n     event Transfer(address indexed dl, address indexed ei, uint256 cz);\n     event Approval(address indexed cx, address indexed cc, uint256 cz);\n }\n\n library ECTools {\n\n\n     function w(bytes32 be, string ed) public pure returns (address) {\n         require(be != 0x00);\n\n\n         bytes memory dd = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 ai = bv(abi.am(dd, be));\n\n         if (bytes(ed).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = x(bo(ed, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return bi(ai, v, r, s);\n     }\n\n\n     function bf(bytes32 be, string ed, address dt) public pure returns (bool) {\n         require(dt != 0x0);\n\n         return dt == w(be, ed);\n     }\n\n\n     function x(string cu) public pure returns (bytes) {\n         uint ej = bytes(cu).length;\n         require(ej % 2 == 0);\n\n         bytes memory ea = bytes(new string(ej / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < ej; i += 2) {\n             s = bo(cu, i, i + 1);\n             r = bo(cu, i + 1, i + 2);\n             uint p = p(s) * 16 + p(r);\n             ea[k++] = ab(p)[31];\n         }\n         return ea;\n     }\n\n\n     function p(string dw) public pure returns (uint) {\n         bytes memory ci = bytes(dw);\n\n         if ((ci[0] >= 48) && (ci[0] <= 57)) {\n             return uint(ci[0]) - 48;\n         } else if ((ci[0] >= 65) && (ci[0] <= 70)) {\n             return uint(ci[0]) - 55;\n         } else if ((ci[0] >= 97) && (ci[0] <= 102)) {\n             return uint(ci[0]) - 87;\n         } else {\n             revert();\n         }\n     }\n\n\n     function ab(uint du) public pure returns (bytes b) {\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), du)}\n     }\n\n\n     function c(string dz) public pure returns (bytes32) {\n         uint ej = bytes(dz).length;\n         require(ej > 0);\n         bytes memory dd = \"\\x19Ethereum Signed Message:\\n\";\n         return bv(abi.am(dd, al(ej), dz));\n     }\n\n\n     function al(uint du) public pure returns (string eh) {\n         uint ej = 0;\n         uint m = du + 0;\n         while (m != 0) {\n             ej++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(ej);\n         uint i = ej - 1;\n         while (du != 0) {\n             uint bs = du % 10;\n             du = du / 10;\n             b[i--] = byte(48 + bs);\n         }\n         eh = string(b);\n     }\n\n\n     function bo(string ef, uint aw, uint bm) public pure returns (string) {\n         bytes memory ch = bytes(ef);\n         require(aw <= bm);\n         require(aw >= 0);\n         require(bm <= ch.length);\n\n         bytes memory cy = new bytes(bm - aw);\n         for (uint i = aw; i < bm; i++) {\n             cy[i - aw] = ch[i];\n         }\n         return string(cy);\n     }\n }\n contract StandardToken is Token {\n\n     function transfer(address ei, uint256 cz) public returns (bool cp) {\n\n\n         require(ce[msg.sender] >= cz);\n         ce[msg.sender] -= cz;\n         ce[ei] += cz;\n         emit Transfer(msg.sender, ei, cz);\n         return true;\n     }\n\n     function aj(address dl, address ei, uint256 cz) public returns (bool cp) {\n\n\n         require(ce[dl] >= cz && cr[dl][msg.sender] >= cz);\n         ce[ei] += cz;\n         ce[dl] -= cz;\n         cr[dl][msg.sender] -= cz;\n         emit Transfer(dl, ei, cz);\n         return true;\n     }\n\n     function bw(address cx) public constant returns (uint256 balance) {\n         return ce[cx];\n     }\n\n     function ct(address cc, uint256 cz) public returns (bool cp) {\n         cr[msg.sender][cc] = cz;\n         emit Approval(msg.sender, cc, cz);\n         return true;\n     }\n\n     function bt(address cx, address cc) public constant returns (uint256 bp) {\n       return cr[cx][cc];\n     }\n\n     mapping (address => uint256) ce;\n     mapping (address => mapping (address => uint256)) cr;\n }\n\n contract HumanStandardToken is StandardToken {\n\n\n     string public dx;\n     uint8 public cf;\n     string public dh;\n     string public cm = 'H0.1';\n\n     constructor(\n         uint256 t,\n         string bb,\n         uint8 y,\n         string ag\n         ) public {\n         ce[msg.sender] = t;\n         ao = t;\n         dx = bb;\n         cf = y;\n         dh = ag;\n     }\n\n\n     function s(address cc, uint256 cz, bytes bc) public returns (bool cp) {\n         cr[msg.sender][cc] = cz;\n         emit Approval(msg.sender, cc, cz);\n\n\n         require(cc.call(bytes4(bytes32(bv(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, cz, this, bc));\n         return true;\n     }\n }\n\n contract LedgerChannel {\n\n     string public constant NAME = \"Ledger Channel\";\n     string public constant VERSION = \"0.0.1\";\n\n     uint256 public ar = 0;\n\n     event DidLCOpen (\n         bytes32 indexed bk,\n         address indexed df,\n         address indexed dc,\n         uint256 as,\n         address ds,\n         uint256 ac,\n         uint256 LCopenTimeout\n     );\n\n     event DidLCJoin (\n         bytes32 indexed bk,\n         uint256 av,\n         uint256 u\n     );\n\n     event DidLCDeposit (\n         bytes32 indexed bk,\n         address indexed bn,\n         uint256 cl,\n         bool cs\n     );\n\n     event DidLCUpdateState (\n         bytes32 indexed bk,\n         uint256 cb,\n         uint256 bl,\n         uint256 as,\n         uint256 ac,\n         uint256 av,\n         uint256 u,\n         bytes32 cw,\n         uint256 l\n     );\n\n     event DidLCClose (\n         bytes32 indexed bk,\n         uint256 cb,\n         uint256 as,\n         uint256 ac,\n         uint256 av,\n         uint256 u\n     );\n\n     event DidVCInit (\n         bytes32 indexed eb,\n         bytes32 indexed ec,\n         bytes dq,\n         uint256 cb,\n         address df,\n         address di,\n         uint256 ca,\n         uint256 cd\n     );\n\n     event DidVCSettle (\n         bytes32 indexed eb,\n         bytes32 indexed ec,\n         uint256 bu,\n         uint256 bh,\n         uint256 bg,\n         address bd,\n         uint256 n\n     );\n\n     event DidVCClose(\n         bytes32 indexed eb,\n         bytes32 indexed ec,\n         uint256 ca,\n         uint256 cd\n     );\n\n     struct Channel {\n\n         address[2] r;\n         uint256[4] au;\n         uint256[4] v;\n         uint256[2] q;\n         uint256 cb;\n         uint256 ap;\n         bytes32 VCrootHash;\n         uint256 LCopenTimeout;\n         uint256 l;\n         bool da;\n         bool h;\n         uint256 bq;\n         HumanStandardToken ds;\n     }\n\n\n     struct VirtualChannel {\n         bool cq;\n         bool f;\n         uint256 cb;\n         address bd;\n         uint256 n;\n\n         address df;\n         address di;\n         address dc;\n         uint256[2] au;\n         uint256[2] v;\n         uint256[2] ee;\n         HumanStandardToken ds;\n     }\n\n     mapping(bytes32 => VirtualChannel) public k;\n     mapping(bytes32 => Channel) public Channels;\n\n     function ae(\n         bytes32 do,\n         address cj,\n         uint256 ak,\n         address db,\n         uint256[2] bx\n     )\n         public\n         payable\n     {\n         require(Channels[do].r[0] == address(0), \"Channel has already been created.\");\n         require(cj != 0x0, \"No partyI address provided to LC creation\");\n         require(bx[0] >= 0 && bx[1] >= 0, \"Balances cannot be negative\");\n\n\n         Channels[do].r[0] = msg.sender;\n         Channels[do].r[1] = cj;\n\n         if(bx[0] != 0) {\n             require(msg.value == bx[0], \"Eth balance does not match sent value\");\n             Channels[do].au[0] = msg.value;\n         }\n         if(bx[1] != 0) {\n             Channels[do].ds = HumanStandardToken(db);\n             require(Channels[do].ds.aj(msg.sender, this, bx[1]),\"CreateChannel: token transfer failure\");\n             Channels[do].v[0] = bx[1];\n         }\n\n         Channels[do].cb = 0;\n         Channels[do].ap = ak;\n\n\n         Channels[do].LCopenTimeout = eg + ak;\n         Channels[do].q = bx;\n\n         emit DidLCOpen(do, msg.sender, cj, bx[0], db, bx[1], Channels[do].LCopenTimeout);\n     }\n\n     function LCOpenTimeout(bytes32 do) public {\n         require(msg.sender == Channels[do].r[0] && Channels[do].da == false);\n         require(eg > Channels[do].LCopenTimeout);\n\n         if(Channels[do].q[0] != 0) {\n             Channels[do].r[0].transfer(Channels[do].au[0]);\n         }\n         if(Channels[do].q[1] != 0) {\n             require(Channels[do].ds.transfer(Channels[do].r[0], Channels[do].v[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(do, 0, Channels[do].au[0], Channels[do].v[0], 0, 0);\n\n\n         delete Channels[do];\n     }\n\n     function aq(bytes32 do, uint256[2] bx) public payable {\n\n         require(Channels[do].da == false);\n         require(msg.sender == Channels[do].r[1]);\n\n         if(bx[0] != 0) {\n             require(msg.value == bx[0], \"state balance does not match sent value\");\n             Channels[do].au[1] = msg.value;\n         }\n         if(bx[1] != 0) {\n             require(Channels[do].ds.aj(msg.sender, this, bx[1]),\"joinChannel: token transfer failure\");\n             Channels[do].v[1] = bx[1];\n         }\n\n         Channels[do].q[0]+=bx[0];\n         Channels[do].q[1]+=bx[1];\n\n         Channels[do].da = true;\n         ar++;\n\n         emit DidLCJoin(do, bx[0], bx[1]);\n     }\n\n\n     function cl(bytes32 do, address bn, uint256 cg, bool cs) public payable {\n         require(Channels[do].da == true, \"Tried adding funds to a closed channel\");\n         require(bn == Channels[do].r[0] || bn == Channels[do].r[1]);\n\n\n         if (Channels[do].r[0] == bn) {\n             if(cs) {\n                 require(Channels[do].ds.aj(msg.sender, this, cg),\"deposit: token transfer failure\");\n                 Channels[do].v[2] += cg;\n             } else {\n                 require(msg.value == cg, \"state balance does not match sent value\");\n                 Channels[do].au[2] += msg.value;\n             }\n         }\n\n         if (Channels[do].r[1] == bn) {\n             if(cs) {\n                 require(Channels[do].ds.aj(msg.sender, this, cg),\"deposit: token transfer failure\");\n                 Channels[do].v[3] += cg;\n             } else {\n                 require(msg.value == cg, \"state balance does not match sent value\");\n                 Channels[do].au[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(do, bn, cg, cs);\n     }\n\n\n     function d(\n         bytes32 do,\n         uint256 by,\n         uint256[4] bx,\n         string dk,\n         string dv\n     )\n         public\n     {\n\n\n         require(Channels[do].da == true);\n         uint256 m = Channels[do].q[0] + Channels[do].au[2] + Channels[do].au[3];\n         uint256 j = Channels[do].q[1] + Channels[do].v[2] + Channels[do].v[3];\n         require(m == bx[0] + bx[1]);\n         require(j == bx[2] + bx[3]);\n\n         bytes32 dg = bv(\n             abi.am(\n                 do,\n                 true,\n                 by,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[do].r[0],\n                 Channels[do].r[1],\n                 bx[0],\n                 bx[1],\n                 bx[2],\n                 bx[3]\n             )\n         );\n\n         require(Channels[do].r[0] == ECTools.w(dg, dk));\n         require(Channels[do].r[1] == ECTools.w(dg, dv));\n\n         Channels[do].da = false;\n\n         if(bx[0] != 0 || bx[1] != 0) {\n             Channels[do].r[0].transfer(bx[0]);\n             Channels[do].r[1].transfer(bx[1]);\n         }\n\n         if(bx[2] != 0 || bx[3] != 0) {\n             require(Channels[do].ds.transfer(Channels[do].r[0], bx[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[do].ds.transfer(Channels[do].r[1], bx[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         ar--;\n\n         emit DidLCClose(do, by, bx[0], bx[1], bx[2], bx[3]);\n     }\n\n\n     function ad(\n         bytes32 do,\n         uint256[6] af,\n         bytes32 ck,\n         string dk,\n         string dv\n     )\n         public\n     {\n         Channel storage co = Channels[do];\n         require(co.da);\n         require(co.cb < af[0]);\n         require(co.au[0] + co.au[1] >= af[2] + af[3]);\n         require(co.v[0] + co.v[1] >= af[4] + af[5]);\n\n         if(co.h == true) {\n             require(co.l > eg);\n         }\n\n         bytes32 dg = bv(\n             abi.am(\n                 do,\n                 false,\n                 af[0],\n                 af[1],\n                 ck,\n                 co.r[0],\n                 co.r[1],\n                 af[2],\n                 af[3],\n                 af[4],\n                 af[5]\n             )\n         );\n\n         require(co.r[0] == ECTools.w(dg, dk));\n         require(co.r[1] == ECTools.w(dg, dv));\n\n\n         co.cb = af[0];\n         co.bq = af[1];\n         co.au[0] = af[2];\n         co.au[1] = af[3];\n         co.v[0] = af[4];\n         co.v[1] = af[5];\n         co.VCrootHash = ck;\n         co.h = true;\n         co.l = eg + co.ap;\n\n\n         emit DidLCUpdateState (\n             do,\n             af[0],\n             af[1],\n             af[2],\n             af[3],\n             af[4],\n             af[5],\n             ck,\n             co.l\n         );\n     }\n\n\n     function ax(\n         bytes32 do,\n         bytes32 dn,\n         bytes dj,\n         address cn,\n         address cv,\n         uint256[2] dp,\n         uint256[4] bx,\n         string dy\n     )\n         public\n     {\n         require(Channels[do].da, \"LC is closed.\");\n\n         require(!k[dn].cq, \"VC is closed.\");\n\n         require(Channels[do].l < eg, \"LC timeout not over.\");\n\n         require(k[dn].n == 0);\n\n         bytes32 ba = bv(\n             abi.am(dn, uint256(0), cn, cv, dp[0], dp[1], bx[0], bx[1], bx[2], bx[3])\n         );\n\n\n         require(cn == ECTools.w(ba, dy));\n\n\n         require(ah(ba, dj, Channels[do].VCrootHash) == true);\n\n         k[dn].df = cn;\n         k[dn].di = cv;\n         k[dn].cb = uint256(0);\n         k[dn].au[0] = bx[0];\n         k[dn].au[1] = bx[1];\n         k[dn].v[0] = bx[2];\n         k[dn].v[1] = bx[3];\n         k[dn].ee = dp;\n         k[dn].n = eg + Channels[do].ap;\n         k[dn].f = true;\n\n         emit DidVCInit(do, dn, dj, uint256(0), cn, cv, bx[0], bx[1]);\n     }\n\n\n     function bz(\n         bytes32 do,\n         bytes32 dn,\n         uint256 bu,\n         address cn,\n         address cv,\n         uint256[4] bj,\n         string dy\n     )\n         public\n     {\n         require(Channels[do].da, \"LC is closed.\");\n\n         require(!k[dn].cq, \"VC is closed.\");\n         require(k[dn].cb < bu, \"VC sequence is higher than update sequence.\");\n         require(\n             k[dn].au[1] < bj[1] && k[dn].v[1] < bj[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             k[dn].ee[0] == bj[0] + bj[1] &&\n             k[dn].ee[1] == bj[2] + bj[3],\n             \"Incorrect balances for bonded amount\");\n\n\n         require(Channels[do].l < eg);\n\n         bytes32 an = bv(\n             abi.am(\n                 dn,\n                 bu,\n                 cn,\n                 cv,\n                 k[dn].ee[0],\n                 k[dn].ee[1],\n                 bj[0],\n                 bj[1],\n                 bj[2],\n                 bj[3]\n             )\n         );\n\n\n         require(k[dn].df == ECTools.w(an, dy));\n\n\n         k[dn].bd = msg.sender;\n         k[dn].cb = bu;\n\n\n         k[dn].au[0] = bj[0];\n         k[dn].au[1] = bj[1];\n         k[dn].v[0] = bj[2];\n         k[dn].v[1] = bj[3];\n\n         k[dn].n = eg + Channels[do].ap;\n\n         emit DidVCSettle(do, dn, bu, bj[0], bj[1], msg.sender, k[dn].n);\n     }\n\n     function g(bytes32 do, bytes32 dn) public {\n\n         require(Channels[do].da, \"LC is closed.\");\n         require(k[dn].f, \"VC is not in settlement state.\");\n         require(k[dn].n < eg, \"Update vc timeout has not elapsed.\");\n         require(!k[dn].cq, \"VC is already closed\");\n\n         Channels[do].bq--;\n\n         k[dn].cq = true;\n\n\n         if(k[dn].df == Channels[do].r[0]) {\n             Channels[do].au[0] += k[dn].au[0];\n             Channels[do].au[1] += k[dn].au[1];\n\n             Channels[do].v[0] += k[dn].v[0];\n             Channels[do].v[1] += k[dn].v[1];\n         } else if (k[dn].di == Channels[do].r[0]) {\n             Channels[do].au[0] += k[dn].au[1];\n             Channels[do].au[1] += k[dn].au[0];\n\n             Channels[do].v[0] += k[dn].v[1];\n             Channels[do].v[1] += k[dn].v[0];\n         }\n\n         emit DidVCClose(do, dn, k[dn].v[0], k[dn].v[1]);\n     }\n\n\n     function e(bytes32 do) public {\n         Channel storage co = Channels[do];\n\n\n         require(co.da, \"Channel is not open\");\n         require(co.h == true);\n         require(co.bq == 0);\n         require(co.l < eg, \"LC timeout over.\");\n\n\n         uint256 m = co.q[0] + co.au[2] + co.au[3];\n         uint256 j = co.q[1] + co.v[2] + co.v[3];\n\n         uint256 b = co.au[0] + co.au[1];\n         uint256 a = co.v[0] + co.v[1];\n\n         if(b < m) {\n             co.au[0]+=co.au[2];\n             co.au[1]+=co.au[3];\n         } else {\n             require(b == m);\n         }\n\n         if(a < j) {\n             co.v[0]+=co.v[2];\n             co.v[1]+=co.v[3];\n         } else {\n             require(a == j);\n         }\n\n         uint256 at = co.au[0];\n         uint256 ay = co.au[1];\n         uint256 aa = co.v[0];\n         uint256 z = co.v[1];\n\n         co.au[0] = 0;\n         co.au[1] = 0;\n         co.v[0] = 0;\n         co.v[1] = 0;\n\n         if(at != 0 || ay != 0) {\n             co.r[0].transfer(at);\n             co.r[1].transfer(ay);\n         }\n\n         if(aa != 0 || z != 0) {\n             require(\n                 co.ds.transfer(co.r[0], aa),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 co.ds.transfer(co.r[1], z),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         co.da = false;\n         ar--;\n\n         emit DidLCClose(do, co.cb, at, ay, aa, z);\n     }\n\n     function ah(bytes32 dm, bytes dj, bytes32 dr) internal pure returns (bool) {\n         bytes32 de = dm;\n         bytes32 br;\n\n         for (uint256 i = 64; i <= dj.length; i += 32) {\n             assembly { br := mload(add(dj, i)) }\n\n             if (de < br) {\n                 de = bv(abi.am(de, br));\n             } else {\n                 de = bv(abi.am(br, de));\n             }\n         }\n\n         return de == dr;\n     }\n\n\n     function az(bytes32 ek) public view returns (\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     ) {\n         Channel memory co = Channels[ek];\n         return (\n             co.r,\n             co.au,\n             co.v,\n             co.q,\n             co.cb,\n             co.ap,\n             co.VCrootHash,\n             co.LCopenTimeout,\n             co.l,\n             co.da,\n             co.h,\n             co.bq\n         );\n     }\n\n     function i(bytes32 ek) public view returns(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     ) {\n         VirtualChannel memory o = k[ek];\n         return(\n             o.cq,\n             o.f,\n             o.cb,\n             o.bd,\n             o.n,\n             o.df,\n             o.di,\n             o.dc,\n             o.au,\n             o.v,\n             o.ee\n         );\n     }\n }",
      "rename_map": {
        "possibleTotalTokenBeforeDeposit": "a",
        "possibleTotalEthBeforeDeposit": "b",
        "toEthereumSignedMessage": "c",
        "consensusCloseChannel": "d",
        "byzantineCloseChannel": "e",
        "isInSettlementState": "f",
        "closeVirtualChannel": "g",
        "isUpdateLCSettling": "h",
        "getVirtualChannel": "i",
        "totalTokenDeposit": "j",
        "virtualChannels": "k",
        "updateLCtimeout": "l",
        "totalEthDeposit": "m",
        "updateVCtimeout": "n",
        "virtualChannel": "o",
        "parseInt16Char": "p",
        "initialDeposit": "q",
        "partyAddresses": "r",
        "approveAndCall": "s",
        "_initialAmount": "t",
        "tokenBalanceI": "u",
        "erc20Balances": "v",
        "recoverSigner": "w",
        "hexstrToBytes": "x",
        "_decimalUnits": "y",
        "tokenbalanceI": "z",
        "tokenbalanceA": "aa",
        "uintToBytes32": "ab",
        "tokenBalanceA": "ac",
        "updateLCstate": "ad",
        "createChannel": "ae",
        "updateParams": "af",
        "_tokenSymbol": "ag",
        "_isContained": "ah",
        "prefixedHash": "ai",
        "transferFrom": "aj",
        "_confirmTime": "ak",
        "uintToString": "al",
        "encodePacked": "am",
        "_updateState": "an",
        "totalSupply": "ao",
        "confirmTime": "ap",
        "joinChannel": "aq",
        "numChannels": "ar",
        "ethBalanceA": "as",
        "ethbalanceA": "at",
        "ethBalances": "au",
        "ethBalanceI": "av",
        "_startIndex": "aw",
        "initVCstate": "ax",
        "ethbalanceI": "ay",
        "getChannel": "az",
        "_initState": "ba",
        "_tokenName": "bb",
        "_extraData": "bc",
        "challenger": "bd",
        "_hashedMsg": "be",
        "isSignedBy": "bf",
        "updateBalB": "bg",
        "updateBalA": "bh",
        "ecrecover": "bi",
        "updateBal": "bj",
        "channelId": "bk",
        "numOpenVc": "bl",
        "_endIndex": "bm",
        "recipient": "bn",
        "substring": "bo",
        "remaining": "bp",
        "numOpenVC": "bq",
        "proofElem": "br",
        "remainder": "bs",
        "allowance": "bt",
        "updateSeq": "bu",
        "keccak256": "bv",
        "balanceOf": "bw",
        "_balances": "bx",
        "_sequence": "by",
        "settleVC": "bz",
        "balanceA": "ca",
        "sequence": "cb",
        "_spender": "cc",
        "balanceB": "cd",
        "balances": "ce",
        "decimals": "cf",
        "_balance": "cg",
        "strBytes": "ch",
        "bresult": "ci",
        "_partyI": "cj",
        "_VCroot": "ck",
        "deposit": "cl",
        "version": "cm",
        "_partyA": "cn",
        "channel": "co",
        "success": "cp",
        "isClose": "cq",
        "allowed": "cr",
        "isToken": "cs",
        "approve": "ct",
        "_hexstr": "cu",
        "_partyB": "cv",
        "vcRoot": "cw",
        "_owner": "cx",
        "result": "cy",
        "_value": "cz",
        "isOpen": "da",
        "_token": "db",
        "partyI": "dc",
        "prefix": "dd",
        "cursor": "de",
        "partyA": "df",
        "_state": "dg",
        "symbol": "dh",
        "partyB": "di",
        "_proof": "dj",
        "_sigA": "dk",
        "_from": "dl",
        "_hash": "dm",
        "_vcID": "dn",
        "_lcID": "do",
        "_bond": "dp",
        "proof": "dq",
        "_root": "dr",
        "token": "ds",
        "_addr": "dt",
        "_uint": "du",
        "_sigI": "dv",
        "_char": "dw",
        "name": "dx",
        "sigA": "dy",
        "_msg": "dz",
        "bstr": "ea",
        "lcId": "eb",
        "vcId": "ec",
        "_sig": "ed",
        "bond": "ee",
        "_str": "ef",
        "now": "eg",
        "str": "eh",
        "_to": "ei",
        "len": "ej",
        "id": "ek"
      },
      "changes": [
        "Renamed 141 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_212",
      "transformed_id": "ss_l2_short_nc_ds_212",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier y()\n    {\n        require(msg.sender == al);\n        _;\n    }\n\n   modifier f()\n    {\n        require(m);\n        _;\n    }\n\n    modifier e()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  p()\n    {\n        require (ag[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 ae, address w);\n    event Win(uint256 ae, address aj);\n    event Lose(uint256 ae, address an);\n    event Donate(uint256 ae, address aj, address ac);\n    event DifficultyChanged(uint256 b);\n    event BetLimitChanged(uint256 d);\n\n    address private ao;\n    uint256 aa;\n    uint difficulty;\n    uint private u;\n    address al;\n    mapping(address => uint256) r;\n    mapping(address => uint256) ag;\n    bool m;\n    uint256 j;\n\n    constructor(address n, uint256 s)\n    e()\n    public\n    {\n        m = false;\n        al = msg.sender;\n        ao = n;\n        j = 0;\n        aa = s;\n\n    }\n\n    function OpenToThePublic()\n    y()\n    public\n    {\n        m = true;\n    }\n\n    function AdjustBetAmounts(uint256 ae)\n    y()\n    public\n    {\n        aa = ae;\n\n        emit BetLimitChanged(aa);\n    }\n\n    function AdjustDifficulty(uint256 ae)\n    y()\n    public\n    {\n        difficulty = ae;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function am()\n    f()\n    e()\n    payable\n    public\n    {\n\n        require(msg.value == aa);\n\n\n        require(ag[msg.sender] == 0);\n\n\n        r[msg.sender] = block.number;\n        ag[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function ap()\n    f()\n    e()\n    p()\n    public\n    {\n        uint256 o = r[msg.sender];\n        if(o < block.number)\n        {\n            r[msg.sender] = 0;\n            ag[msg.sender] = 0;\n\n            uint256 g = uint256(x(abi.k(blockhash(o),  msg.sender)))%difficulty +1;\n\n            if(g == difficulty / 2)\n            {\n                af(msg.sender);\n            }\n            else\n            {\n\n                z(aa / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function ak()\n    f()\n    public\n    payable\n    {\n        h(msg.value);\n    }\n\n    function af(address ad)\n    internal\n    {\n        uint256 i = address(this).balance / 2;\n\n        ad.transfer(i);\n        emit Win(i, ad);\n    }\n\n    function h(uint256 ae)\n    internal\n    {\n        ao.call.value(ae)(bytes4(x(\"donate()\")));\n        j += ae;\n        emit Donate(ae, ao, msg.sender);\n    }\n\n    function z(uint256 ae)\n    internal\n    {\n        ao.call.value(ae)(bytes4(x(\"donate()\")));\n        j += ae;\n        emit Lose(ae, msg.sender);\n    }\n\n    function q()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function b()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function d()\n    public\n    view\n    returns (uint256)\n    {\n        return aa;\n    }\n\n    function c(address ah)\n    public\n    view\n    returns (bool)\n    {\n        if(ag[ah] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function t()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function a(address l, address v, uint ai)\n    public\n    y()\n    returns (bool ab)\n    {\n        return ERC20Interface(l).transfer(v, ai);\n    }\n}\n\n\ncontract ERC20Interface\n{\n    function transfer(address aq, uint256 ai) public returns (bool ab);\n}",
      "rename_map": {
        "transferAnyERC20Token": "a",
        "currentDifficulty": "b",
        "hasPlayerWagered": "c",
        "currentBetLimit": "d",
        "onlyRealPeople": "e",
        "isOpenToPublic": "f",
        "winningNumber": "g",
        "donateToWhale": "h",
        "ethToTransfer": "i",
        "totalDonated": "j",
        "encodePacked": "k",
        "tokenAddress": "l",
        "openToPublic": "m",
        "whaleAddress": "n",
        "blockNumber": "o",
        "onlyPlayers": "p",
        "ethBalance": "q",
        "timestamps": "r",
        "wagerLimit": "s",
        "winnersPot": "t",
        "randomSeed": "u",
        "tokenOwner": "v",
        "depositer": "w",
        "keccak256": "x",
        "onlyOwner": "y",
        "loseWager": "z",
        "betLimit": "aa",
        "success": "ab",
        "donator": "ac",
        "winner": "ad",
        "amount": "ae",
        "payout": "af",
        "wagers": "ag",
        "player": "ah",
        "tokens": "ai",
        "paidTo": "aj",
        "donate": "ak",
        "owner": "al",
        "wager": "am",
        "loser": "an",
        "whale": "ao",
        "play": "ap",
        "to": "aq"
      },
      "changes": [
        "Renamed 43 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_213",
      "transformed_id": "ss_l2_short_nc_ds_213",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.11;\ninterface q { function o(address ce, uint256 by, address bz, bytes ao) public; }\n\n\ncontract MigrationAgent {\n    function ak(address ce, uint256 by);\n}\n\ncontract ERC20 {\n  uint public ae;\n  function ay(address cm) constant returns (uint);\n  function av(address ci, address bl) constant returns (uint);\n\n  function transfer(address co, uint value) returns (bool cp);\n  function ac(address from, address co, uint value) returns (bool cp);\n  function bq(address bl, uint value) returns (bool cp);\n  event Transfer(address indexed from, address indexed co, uint value);\n  event Approval(address indexed ci, address indexed bl, uint value);\n}\n\ncontract SafeMath {\n  function bi(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function bs(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function bu(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function bh(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function cg(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function ch(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function ca(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function cb(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function assert(bool ax) internal {\n    if (!ax) {\n      throw;\n    }\n  }\n}\n\ncontract StandardToken is ERC20, SafeMath {\n\n\n  event Minted(address az, uint bv);\n\n\n  mapping(address => uint) bc;\n\n  mapping(address => uint) ai;\n\n  mapping (address => mapping (address => uint)) bm;\n\n\n  function bo() public constant returns (bool cd) {\n    return true;\n  }\n\n  function transfer(address cn, uint by) returns (bool bk) {\n    bc[msg.sender] = bu(bc[msg.sender], by);\n    bc[cn] = bh(bc[cn], by);\n    Transfer(msg.sender, cn, by);\n    return true;\n  }\n\n  function ac(address ce, address cn, uint by) returns (bool bk) {\n    uint an = bm[ce][msg.sender];\n\n    bc[cn] = bh(bc[cn], by);\n    bc[ce] = bu(bc[ce], by);\n    bm[ce][msg.sender] = bu(an, by);\n    Transfer(ce, cn, by);\n    return true;\n  }\n\n  function ay(address bx) constant returns (uint balance) {\n    return bc[bx];\n  }\n\n  function bq(address bb, uint by) returns (bool bk) {\n\n\n    if ((by != 0) && (bm[msg.sender][bb] != 0)) throw;\n\n    bm[msg.sender][bb] = by;\n    Approval(msg.sender, bb, by);\n    return true;\n  }\n\n  function av(address bx, address bb) constant returns (uint aq) {\n    return bm[bx][bb];\n  }\n\n}\n\n\ncontract m{\n\n    string public cj = \"DAO POLSKA TOKEN version 1\";\n    string public cc = \"DPL\";\n    uint8 public constant be = 18;\n\n\n    address public ci;\n    address public n;\n\n\n    uint256 public b =1.0 ether;\n    uint256 public aj      = 10000.0 ether;\n\n   uint256 public  ae      = 0.0 ether;\n\n\taddress public Chain1 = 0x0;\n\taddress public Chain2 = 0x0;\n\taddress public Chain3 = 0x0;\n\taddress public Chain4 = 0x0;\n\n\taddress public p=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\n    uint256 public v;\n\n    event Migrate(address indexed ce, address indexed cn, uint256 by);\n    event Refund(address indexed ce, uint256 by);\n\n\tstruct u{\n\t\tStandardToken ad;\n\t\tuint bv;\n\t\taddress ap;\n\t}\n\tmapping(uint => u) ar;\n\tuint y=0;\n\n  mapping (address => uint256) bc;\nmapping (address => uint256) ai;\n  mapping (address => mapping (address => uint256)) bm;\n\n\tevent UpdatedTokenInformation(string bp, string au);\n\n    event Transfer(address indexed ce, address indexed cn, uint256 by);\n\tevent w(address indexed ce,uint256 by);\n  event Approval(address indexed bx, address indexed bb, uint256 by);\n\n\n    event Burn(address indexed from, uint256 value);\n\n  bool public t = false;\n  bool public f = false;\n\n  function m() {\nci=msg.sender;\nn=msg.sender;\n}\n\nfunction  as(uint256 ab) public {\n    \t   if (msg.sender != ci) {\n      throw;\n    }\n\t\t    \t   if (t != false) {\n      throw;\n    }\n\tt = true;\n\n\taj = ab ** uint256(be);\n\n  }\nfunction a(uint256 ab) public {\n    \t   if (msg.sender != ci) {\n      throw;\n    }\n\t    \t   if (t != false) {\n      throw;\n    }\n\n\tf = true;\n\tb = ab ** uint256(be);\n\n  }\n    function s(address bb, uint256 by, bytes ao)\n        public\n        returns (bool bk) {\n        q bl = q(bb);\n        if (bq(bb, by)) {\n            bl.o(msg.sender, by, this, ao);\n            return true;\n        }\n    }\n\n    function ck(uint256 by) public returns (bool bk) {\n        require(bc[msg.sender] >= by);\n        bc[msg.sender] -= by;\n        ae -= by;\n        Burn(msg.sender, by);\n        return true;\n    }\n\n    function bd(address ce, uint256 by) public returns (bool bk) {\n        require(bc[ce] >= by);\n        require(by <= bm[ce][msg.sender]);\n        bc[ce] -= by;\n        bm[ce][msg.sender] -= by;\n        ae -= by;\n        Burn(ce, by);\n        return true;\n    }\n\n  function transfer(address cn, uint256 by) returns (bool bk) {\n\n\n    if (bc[msg.sender] >= by && bc[cn] + by > bc[cn]) {\n\n      bc[msg.sender] -= by;\n      bc[cn] += by;\n      Transfer(msg.sender, cn, by);\n      return true;\n    } else { return false; }\n  }\n\n  function ac(address ce, address cn, uint256 by) returns (bool bk) {\n\n    if (bc[ce] >= by && bm[ce][msg.sender] >= by && bc[cn] + by > bc[cn]) {\n\n      bc[cn] += by;\n      bc[ce] -= by;\n      bm[ce][msg.sender] -= by;\n      Transfer(ce, cn, by);\n      return true;\n    } else { return false; }\n  }\n\n  function ay(address bx) constant returns (uint256 balance) {\n    return bc[bx];\n  }\n\n  function bq(address bb, uint256 by) returns (bool bk) {\n    bm[msg.sender][bb] = by;\n    Approval(msg.sender, bb, by);\n    return true;\n  }\n\n  function av(address bx, address bb) constant returns (uint256 aq) {\n    return bm[bx][bb];\n  }\n\n\t    function () payable  public {\n\t\t if(bt){\n        w(msg.sender, msg.value);\n\t\tbc[msg.sender]=bc[msg.sender]+msg.value;\n\t\t} else throw;\n\n    }\n\n  function e(string cf, string bg) {\n\n\t   if (msg.sender != ci) {\n      throw;\n    }\n\tcj = cf;\n    cc = bg;\n\n    UpdatedTokenInformation(cj, cc);\n  }\n\nfunction g(address bj, int af) {\n\n\t   if (msg.sender != ci) {\n      throw;\n    }\n\tif(af==1){Chain1=bj;}\n\tif(af==2){Chain2=bj;}\n\tif(af==3){Chain3=bj;}\n\tif(af==4){Chain4=bj;}\n  }\n\n  function DAOPolskaTokenICOregulations() external returns(string cl) {\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\n}\n\n\n\tfunction al(address StandardTokenAddress, address az, uint bv){\n\t\tif (msg.sender != ci) {\n\t\tthrow;\n\t\t}\n\t\tu t = ar[y];\n\t\tt.ad = StandardToken(StandardTokenAddress);\n\t\tt.bv = bv;\n\t\tt.ap = az;\n\t\tt.ad.transfer(az, bv);\n\t\ty++;\n\t}\n\n\nuint public h=1000;\nuint public j=1000;\nuint public CreationRate=1761;\n   uint256 public constant bn = 36000;\nuint256 public l = 5433616;\nbool public bt = true;\nbool public ag = false;\nbool public x= false;\n        function c(address bw) payable {\n\n        if (!bt) throw;\n\n\n        if (msg.value == 0) throw;\n\n        if (msg.value > (aj - ae) / CreationRate)\n          throw;\n\n\n\t var z = msg.value;\n\n        var aw = msg.value * CreationRate;\n        ae += aw;\n\n\n        bc[bw] += aw;\n        ai[bw] += z;\n\n        Transfer(0, bw, aw);\n\n\n        uint256 r = 12;\n        uint256 k = \taw * r / (100);\n\n        ae += k;\n\n        bc[n] += k;\n        Transfer(0, n, k);\n\n\t}\n\tfunction d(uint bf){\n\tif(msg.sender == ci) {\n\tj=bf;\n\tCreationRate=h+j;\n\t}\n\t}\n\n    function FundsTransfer() external {\n\tif(bt==true) throw;\n\t\t \tif (!ci.send(this.balance)) throw;\n    }\n\n    function PartialFundsTransfer(uint SubX) external {\n\t      if (msg.sender != ci) throw;\n        ci.send(this.balance - SubX);\n\t}\n\tfunction am() external {\n\t      if (msg.sender != ci) throw;\n\tag=!ag;\n        }\n\n\t\t\tfunction aa() external {\n\t      if (msg.sender != ci) throw;\n\tbt=!bt;\n        }\n    function ah() external {\n\t      if (msg.sender != n) throw;\n\tx=!x;\n}\n\n\nfunction ba() external {\n        if (block.number <= l+8*bn) throw;\n\n        bt = false;\n\t\tag=!ag;\n\n        if (msg.sender==ci)\n\t\tci.send(this.balance);\n    }\n    function br(uint256 by) external {\n\n        if (x) throw;\n\n\n        if (by == 0) throw;\n        if (by > bc[msg.sender]) throw;\n\n        bc[msg.sender] -= by;\n        ae -= by;\n        v += by;\n        MigrationAgent(p).ak(msg.sender, by);\n        Migrate(msg.sender, p, by);\n    }\n\nfunction at() external {\n\n        if (bt) throw;\n        if (!ag) throw;\n\n        var DAOPLTokenValue = bc[msg.sender];\n        var ETHValue = ai[msg.sender];\n        if (ETHValue == 0) throw;\n        ai[msg.sender] = 0;\n        ae -= DAOPLTokenValue;\n\n        Refund(msg.sender, ETHValue);\n        msg.sender.transfer(ETHValue);\n}\n\nfunction i() external returns(string cl) {\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\n}\n\n}",
      "rename_map": {
        "setotherchainstotalsupply": "a",
        "otherchainstotalsupply": "b",
        "createDaoPOLSKAtokens": "c",
        "setBonusCreationRate": "d",
        "setTokenInformation": "e",
        "otherchainstotalset": "f",
        "setChainsAddresses": "g",
        "tokenCreationRate": "h",
        "preICOregulations": "i",
        "bonusCreationRate": "j",
        "additionalTokens": "k",
        "fundingEndBlock": "l",
        "daoPOLSKAtokens": "m",
        "migrationMaster": "n",
        "receiveApproval": "o",
        "migrationAgent": "p",
        "tokenRecipient": "q",
        "percentOfTotal": "r",
        "approveAndCall": "s",
        "supplylimitset": "t",
        "sendTokenAway": "u",
        "totalMigrated": "v",
        "receivedEther": "w",
        "migratestate": "x",
        "numTransfers": "y",
        "numTokensRAW": "z",
        "fundingState": "aa",
        "supplyLOCKER": "ab",
        "transferFrom": "ac",
        "coinContract": "ad",
        "totalSupply": "ae",
        "chainnumber": "af",
        "refundstate": "ag",
        "turnmigrate": "ah",
        "balancesRAW": "ai",
        "supplylimit": "aj",
        "migrateFrom": "ak",
        "sendTokenAw": "al",
        "turnrefund": "am",
        "_allowance": "an",
        "_extraData": "ao",
        "recipient": "ap",
        "remaining": "aq",
        "transfers": "ar",
        "setSupply": "as",
        "refundTRA": "at",
        "newSymbol": "au",
        "allowance": "av",
        "numTokens": "aw",
        "assertion": "ax",
        "balanceOf": "ay",
        "receiver": "az",
        "finalize": "ba",
        "_spender": "bb",
        "balances": "bc",
        "burnFrom": "bd",
        "decimals": "be",
        "newRate": "bf",
        "_symbol": "bg",
        "safeAdd": "bh",
        "safeMul": "bi",
        "chainAd": "bj",
        "success": "bk",
        "spender": "bl",
        "allowed": "bm",
        "oneweek": "bn",
        "isToken": "bo",
        "newName": "bp",
        "approve": "bq",
        "migrate": "br",
        "safeDiv": "bs",
        "funding": "bt",
        "safeSub": "bu",
        "amount": "bv",
        "holder": "bw",
        "_owner": "bx",
        "_value": "by",
        "_token": "bz",
        "max256": "ca",
        "min256": "cb",
        "symbol": "cc",
        "weAre": "cd",
        "_from": "ce",
        "_name": "cf",
        "max64": "cg",
        "min64": "ch",
        "owner": "ci",
        "name": "cj",
        "burn": "ck",
        "wow": "cl",
        "who": "cm",
        "_to": "cn",
        "to": "co",
        "ok": "cp"
      },
      "changes": [
        "Renamed 94 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_214",
      "transformed_id": "ss_l2_short_nc_ds_214",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract ERC20 {\n    function cy() constant returns (uint hu);\n    function fg( address jd ) constant returns (uint value);\n    function fd( address ij, address gq ) constant returns (uint du);\n\n    function transfer( address ji, uint value) returns (bool jl);\n    function cu( address from, address ji, uint value) returns (bool jl);\n    function gv( address gq, uint value ) returns (bool jl);\n\n    event Transfer( address indexed from, address indexed ji, uint value);\n    event Approval( address indexed ij, address indexed gq, uint value);\n}\ncontract Ownable {\n  address public ij;\n\n  function Ownable() {\n    ij = msg.sender;\n  }\n\n  modifier eu() {\n    require(msg.sender == ij);\n    _;\n  }\n\n  function ap(address fm) eu {\n    if (fm != address(0)) {\n      ij = fm;\n    }\n  }\n\n}\n\n\ncontract ERC721 {\n\n    function cy() public view returns (uint256 ie);\n    function fg(address he) public view returns (uint256 balance);\n    function gg(uint256 fk) external view returns (address ij);\n    function gv(address jf, uint256 fk) external;\n    function transfer(address jf, uint256 fk) external;\n    function cu(address hy, address jf, uint256 fk) external;\n\n\n    event Transfer(address from, address ji, uint256 gw);\n    event Approval(address ij, address fn, uint256 gw);\n\n\n    function ak(bytes4 cw) external view returns (bool);\n}\n\ncontract GeneScienceInterface {\n\n    function bs() public pure returns (bool);\n\n\n    function fy(uint256[2] ho, uint256[2] hg,uint256 jh,uint256 jj, uint256 dl) public returns (uint256[2]);\n\n    function ax(uint256[2] ir) public view returns(uint256);\n\n\n    function hb(uint256[2] ir) public view returns(uint256);\n\n\n    function do(uint256[2] ir) public view returns(uint256);\n\n    function bw(uint256[2] ih) public returns(uint256[2]);\n}\n\n\ncontract PandaAccessControl {\n\n\n    event ContractUpgrade(address dr);\n\n\n    address public ds;\n    address public ed;\n    address public ea;\n\n\n    bool public hp = false;\n\n\n    modifier gj() {\n        require(msg.sender == ds);\n        _;\n    }\n\n\n    modifier gd() {\n        require(msg.sender == ed);\n        _;\n    }\n\n\n    modifier ge() {\n        require(msg.sender == ea);\n        _;\n    }\n\n    modifier dt() {\n        require(\n            msg.sender == ea ||\n            msg.sender == ds ||\n            msg.sender == ed\n        );\n        _;\n    }\n\n\n    function hi(address gf) external gj {\n        require(gf != address(0));\n\n        ds = gf;\n    }\n\n\n    function hv(address gm) external gj {\n        require(gm != address(0));\n\n        ed = gm;\n    }\n\n\n    function gz(address gk) external gj {\n        require(gk != address(0));\n\n        ea = gk;\n    }\n\n\n    modifier ce() {\n        require(!hp);\n        _;\n    }\n\n\n    modifier ej {\n        require(hp);\n        _;\n    }\n\n\n    function ii() external dt ce {\n        hp = true;\n    }\n\n\n    function gp() public gj ej {\n\n        hp = false;\n    }\n}\n\n\ncontract PandaBase is PandaAccessControl {\n\n\n    uint256 public constant GEN0_TOTAL_COUNT = 16200;\n    uint256 public as;\n\n\n    event Birth(address ij, uint256 gu, uint256 ft, uint256 hh, uint256[2] ig);\n\n\n    event Transfer(address from, address ji, uint256 gw);\n\n\n    struct Panda {\n\n\n        uint256[2] ig;\n\n\n        uint64 em;\n\n\n        uint64 av;\n\n\n        uint32 ft;\n        uint32 hh;\n\n\n        uint32 ck;\n\n\n        uint16 bq;\n\n\n        uint16 dx;\n    }\n\n\n    uint32[9] public el = [\n        uint32(5 minutes),\n        uint32(30 minutes),\n        uint32(2 hours),\n        uint32(4 hours),\n        uint32(8 hours),\n        uint32(24 hours),\n        uint32(48 hours),\n        uint32(72 hours),\n        uint32(7 days)\n    ];\n\n\n    uint256 public ay = 15;\n\n\n    Panda[] hd;\n\n\n    mapping (uint256 => address) public am;\n\n\n    mapping (address => uint256) y;\n\n\n    mapping (uint256 => address) public o;\n\n\n    mapping (uint256 => address) public s;\n\n\n    SaleClockAuction public df;\n\n\n    SiringClockAuction public ca;\n\n\n    GeneScienceInterface public dj;\n\n    SaleClockAuctionERC20 public ar;\n\n\n    mapping (uint256 => uint256) public bl;\n    mapping (uint256 => uint256) public bj;\n\n\n    function aa(uint256 iz) view external returns(uint256) {\n        return bl[iz];\n    }\n\n    function u(uint256 iz) view external returns(uint256) {\n        return bj[iz];\n    }\n\n    function w(uint256 iz,uint256 hn) external dt {\n        require (bl[iz]==0);\n        require (hn==uint256(uint32(hn)));\n        bl[iz] = hn;\n    }\n\n    function cf(uint256 iy) view external returns(uint256) {\n        Panda memory jk = hd[iy];\n        return dj.do(jk.ig);\n    }\n\n\n    function ey(address hy, address jf, uint256 fk) internal {\n\n        y[jf]++;\n\n        am[fk] = jf;\n\n        if (hy != address(0)) {\n            y[hy]--;\n\n            delete s[fk];\n\n            delete o[fk];\n        }\n\n        Transfer(hy, jf, fk);\n    }\n\n\n    function cq(\n        uint256 ex,\n        uint256 gx,\n        uint256 dc,\n        uint256[2] hs,\n        address he\n    )\n        internal\n        returns (uint)\n    {\n\n\n        require(ex == uint256(uint32(ex)));\n        require(gx == uint256(uint32(gx)));\n        require(dc == uint256(uint16(dc)));\n\n\n        uint16 bq = 0;\n\n        if (hd.length>0){\n            uint16 ee = uint16(dj.ax(hs));\n            if (ee==0) {\n                ee = 1;\n            }\n            bq = 1000/ee;\n            if (bq%10 < 5){\n                bq = bq/10;\n            }else{\n                bq = bq/10 + 1;\n            }\n            bq = bq - 1;\n            if (bq > 8) {\n                bq = 8;\n            }\n            uint256 iz = dj.do(hs);\n            if (iz>0 && bl[iz]<=bj[iz]) {\n                hs = dj.bw(hs);\n                iz = 0;\n            }\n\n            if (iz == 1){\n                bq = 5;\n            }\n\n\n            if (iz>0){\n                bj[iz] = bj[iz] + 1;\n            }\n\n            if (dc <= 1 && iz != 1){\n                require(as<GEN0_TOTAL_COUNT);\n                as++;\n            }\n        }\n\n        Panda memory hl = Panda({\n            ig: hs,\n            em: uint64(jg),\n            av: 0,\n            ft: uint32(ex),\n            hh: uint32(gx),\n            ck: 0,\n            bq: bq,\n            dx: uint16(dc)\n        });\n        uint256 da = hd.push(hl) - 1;\n\n\n        require(da == uint256(uint32(da)));\n\n\n        Birth(\n            he,\n            da,\n            uint256(hl.ft),\n            uint256(hl.hh),\n            hl.ig\n        );\n\n\n        ey(0, he, da);\n\n        return da;\n    }\n\n\n    function ae(uint256 it) external dt {\n        require(it < el[0]);\n        ay = it;\n    }\n}\n\n\ncontract ERC721Metadata {\n\n    function db(uint256 fk, string) public view returns (bytes32[4] hw, uint256 il) {\n        if (fk == 1) {\n            hw[0] = \"Hello World! :D\";\n            il = 15;\n        } else if (fk == 2) {\n            hw[0] = \"I would definitely choose a medi\";\n            hw[1] = \"um length string.\";\n            il = 49;\n        } else if (fk == 3) {\n            hw[0] = \"Lorem ipsum dolor sit amet, mi e\";\n            hw[1] = \"st accumsan dapibus augue lorem,\";\n            hw[2] = \" tristique vestibulum id, libero\";\n            hw[3] = \" suscipit varius sapien aliquam.\";\n            il = 128;\n        }\n    }\n}\n\n\ncontract PandaOwnership is PandaBase, ERC721 {\n\n\n    string public constant im = \"PandaEarth\";\n    string public constant hr = \"PE\";\n\n    bytes4 constant InterfaceSignature_ERC165 =\n        bytes4(ff('ak(bytes4)'));\n\n    bytes4 constant InterfaceSignature_ERC721 =\n        bytes4(ff('im()')) ^\n        bytes4(ff('hr()')) ^\n        bytes4(ff('cy()')) ^\n        bytes4(ff('fg(address)')) ^\n        bytes4(ff('gg(uint256)')) ^\n        bytes4(ff('gv(address,uint256)')) ^\n        bytes4(ff('transfer(address,uint256)')) ^\n        bytes4(ff('cu(address,address,uint256)')) ^\n        bytes4(ff('cb(address)')) ^\n        bytes4(ff('tokenMetadata(uint256,string)'));\n\n\n    function ak(bytes4 cw) external view returns (bool)\n    {\n\n\n        return ((cw == InterfaceSignature_ERC165) || (cw == InterfaceSignature_ERC721));\n    }\n\n\n    function hz(address ew, uint256 fk) internal view returns (bool) {\n        return am[fk] == ew;\n    }\n\n\n    function cn(address ew, uint256 fk) internal view returns (bool) {\n        return o[fk] == ew;\n    }\n\n\n    function fl(uint256 fk, address ep) internal {\n        o[fk] = ep;\n    }\n\n\n    function fg(address he) public view returns (uint256 il) {\n        return y[he];\n    }\n\n\n    function transfer(\n        address jf,\n        uint256 fk\n    )\n        external\n        ce\n    {\n\n        require(jf != address(0));\n\n\n        require(jf != address(this));\n\n\n        require(jf != address(df));\n        require(jf != address(ca));\n\n\n        require(hz(msg.sender, fk));\n\n\n        ey(msg.sender, jf, fk);\n    }\n\n\n    function gv(\n        address jf,\n        uint256 fk\n    )\n        external\n        ce\n    {\n\n        require(hz(msg.sender, fk));\n\n\n        fl(fk, jf);\n\n\n        Approval(msg.sender, jf, fk);\n    }\n\n\n    function cu(\n        address hy,\n        address jf,\n        uint256 fk\n    )\n        external\n        ce\n    {\n\n        require(jf != address(0));\n\n\n        require(jf != address(this));\n\n        require(cn(msg.sender, fk));\n        require(hz(hy, fk));\n\n\n        ey(hy, jf, fk);\n    }\n\n\n    function cy() public view returns (uint) {\n        return hd.length - 1;\n    }\n\n\n    function gg(uint256 fk)\n        external\n        view\n        returns (address ij)\n    {\n        ij = am[fk];\n\n        require(ij != address(0));\n    }\n\n\n    function cb(address he) external view returns(uint256[] dd) {\n        uint256 eb = fg(he);\n\n        if (eb == 0) {\n\n            return new uint256[](0);\n        } else {\n            uint256[] memory hf = new uint256[](eb);\n            uint256 er = cy();\n            uint256 dn = 0;\n\n\n            uint256 hx;\n\n            for (hx = 1; hx <= er; hx++) {\n                if (am[hx] == he) {\n                    hf[dn] = hx;\n                    dn++;\n                }\n            }\n\n            return hf;\n        }\n    }\n\n\n    function gl(uint ib, uint is, uint ip) private view {\n\n        for(; ip >= 32; ip -= 32) {\n            assembly {\n                mstore(ib, mload(is))\n            }\n            ib += 32;\n            is += 32;\n        }\n\n\n        uint256 iq = 256 ** (32 - ip) - 1;\n        assembly {\n            let gt := and(mload(is), not(iq))\n            let fs := and(mload(ib), iq)\n            mstore(ib, or(fs, gt))\n        }\n    }\n\n\n    function eo(bytes32[4] fa, uint256 bt) private view returns (string) {\n        var cx = new string(bt);\n        uint256 fh;\n        uint256 fr;\n\n        assembly {\n            fh := add(cx, 32)\n            fr := fa\n        }\n\n        gl(fh, fr, bt);\n\n        return cx;\n    }\n\n}\n\n\ncontract PandaBreeding is PandaOwnership {\n\n    uint256 public constant GENSIS_TOTAL_COUNT = 100;\n\n\n    event Pregnant(address ij, uint256 ft, uint256 hh, uint256 av);\n\n    event Abortion(address ij, uint256 ft, uint256 hh);\n\n\n    uint256 public co = 2 finney;\n\n\n    uint256 public bm;\n\n    mapping(uint256 => address) ei;\n\n\n    function k(address fj) external gj {\n        GeneScienceInterface al = GeneScienceInterface(fj);\n\n\n        require(al.bs());\n\n\n        dj = al;\n    }\n\n\n    function bc(Panda iw) internal view returns(bool) {\n\n\n        return (iw.ck == 0) && (iw.av <= uint64(block.number));\n    }\n\n\n    function ah(uint256 gx, uint256 ex) internal view returns(bool) {\n        address dh = am[ex];\n        address eq = am[gx];\n\n\n        return (dh == eq || s[gx] == dh);\n    }\n\n\n    function at(Panda storage go) internal {\n\n        go.av = uint64((el[go.bq] / ay) + block.number);\n\n\n        if (go.bq < 8 && dj.do(go.ig) != 1) {\n            go.bq += 1;\n        }\n    }\n\n\n    function cd(address if, uint256 gx)\n    external\n    ce {\n        require(hz(msg.sender, gx));\n        s[gx] = if;\n    }\n\n\n    function az(uint256 jb) external ge {\n        co = jb;\n    }\n\n\n    function x(Panda gn) private view returns(bool) {\n        return (gn.ck != 0) && (gn.av <= uint64(block.number));\n    }\n\n\n    function bh(uint256 fo)\n    public\n    view\n    returns(bool) {\n        require(fo > 0);\n        Panda storage ja = hd[fo];\n        return bc(ja);\n    }\n\n\n    function ef(uint256 fo)\n    public\n    view\n    returns(bool) {\n        require(fo > 0);\n\n        return hd[fo].ck != 0;\n    }\n\n\n    function ag(\n        Panda storage gn,\n        uint256 ex,\n        Panda storage id,\n        uint256 gx\n    )\n    private\n    view\n    returns(bool) {\n\n        if (ex == gx) {\n            return false;\n        }\n\n\n        if (gn.ft == gx || gn.hh == gx) {\n            return false;\n        }\n        if (id.ft == ex || id.hh == ex) {\n            return false;\n        }\n\n\n        if (id.ft == 0 || gn.ft == 0) {\n            return true;\n        }\n\n\n        if (id.ft == gn.ft || id.ft == gn.hh) {\n            return false;\n        }\n        if (id.hh == gn.ft || id.hh == gn.hh) {\n            return false;\n        }\n\n\n        if (dj.hb(gn.ig) + dj.hb(id.ig) != 1) {\n            return false;\n        }\n\n\n        return true;\n    }\n\n\n    function g(uint256 ex, uint256 gx)\n    internal\n    view\n    returns(bool) {\n        Panda storage ha = hd[ex];\n        Panda storage io = hd[gx];\n        return ag(ha, ex, io, gx);\n    }\n\n\n    function cm(uint256 ex, uint256 gx)\n    external\n    view\n    returns(bool) {\n        require(ex > 0);\n        require(gx > 0);\n        Panda storage ha = hd[ex];\n        Panda storage io = hd[gx];\n        return ag(ha, ex, io, gx) &&\n            ah(gx, ex);\n    }\n\n    function l(uint256 ex, uint256 gx) internal returns(uint256, uint256) {\n        if (dj.hb(hd[ex].ig) == 1) {\n            return (gx, ex);\n        } else {\n            return (ex, gx);\n        }\n    }\n\n\n    function eh(uint256 ex, uint256 gx, address he) internal {\n\n        (ex, gx) = l(ex, gx);\n\n        Panda storage io = hd[gx];\n        Panda storage ha = hd[ex];\n\n\n        ha.ck = uint32(gx);\n\n\n        at(io);\n        at(ha);\n\n\n        delete s[ex];\n        delete s[gx];\n\n\n        bm++;\n\n        ei[ex] = he;\n\n\n        Pregnant(am[ex], ex, gx, ha.av);\n    }\n\n\n    function cc(uint256 ex, uint256 gx)\n    external\n    payable\n    ce {\n\n        require(msg.value >= co);\n\n\n        require(hz(msg.sender, ex));\n\n\n        require(ah(gx, ex));\n\n\n        Panda storage ha = hd[ex];\n\n\n        require(bc(ha));\n\n\n        Panda storage io = hd[gx];\n\n\n        require(bc(io));\n\n\n        require(ag(\n            ha,\n            ex,\n            io,\n            gx\n        ));\n\n\n        eh(ex, gx, msg.sender);\n    }\n\n\n    function fc(uint256 ex, uint256[2] dk, uint256[2] ga)\n    external\n    ce\n    dt\n    returns(uint256) {\n\n        Panda storage ha = hd[ex];\n\n\n        require(ha.em != 0);\n\n\n        require(x(ha));\n\n\n        uint256 hh = ha.ck;\n        Panda storage io = hd[hh];\n\n\n        uint16 en = ha.dx;\n        if (io.dx > ha.dx) {\n            en = io.dx;\n        }\n\n\n        uint256[2] memory dz = dk;\n\n        uint256 fi = 0;\n\n\n        uint256 dg = (dj.ax(ha.ig) + dj.ax(io.ig)) / 2 + ga[0];\n        if (dg >= (en + 1) * ga[1]) {\n            dg = dg - (en + 1) * ga[1];\n        } else {\n            dg = 0;\n        }\n        if (en == 0 && as == GEN0_TOTAL_COUNT) {\n            dg = 0;\n        }\n        if (uint256(ff(block.blockhash(block.number - 2), jg)) % 100 < dg) {\n\n            address ij = ei[ex];\n            fi = cq(ex, ha.ck, en + 1, dz, ij);\n        } else {\n            Abortion(am[ex], ex, hh);\n        }\n\n\n        delete ha.ck;\n\n\n        bm--;\n\n\n        msg.sender.send(co);\n\n        delete ei[ex];\n\n\n        return fi;\n    }\n}\n\n\ncontract ClockAuctionBase {\n\n\n    struct Auction {\n\n        address hk;\n\n        uint128 br;\n\n        uint128 di;\n\n        uint64 fq;\n\n\n        uint64 ez;\n\n        uint64 hj;\n    }\n\n\n    ERC721 public ab;\n\n\n    uint256 public gc;\n\n\n    mapping (uint256 => Auction) aw;\n\n    event AuctionCreated(uint256 gw, uint256 br, uint256 di, uint256 fq);\n    event AuctionSuccessful(uint256 gw, uint256 dv, address ht);\n    event AuctionCancelled(uint256 gw);\n\n\n    function hz(address ew, uint256 fk) internal view returns (bool) {\n        return (ab.gg(fk) == ew);\n    }\n\n\n    function gh(address he, uint256 fk) internal {\n\n        ab.cu(he, this, fk);\n    }\n\n\n    function ey(address fe, uint256 fk) internal {\n\n        ab.transfer(fe, fk);\n    }\n\n\n    function de(uint256 fk, Auction fw) internal {\n\n\n        require(fw.fq >= 1 minutes);\n\n        aw[fk] = fw;\n\n        AuctionCreated(\n            uint256(fk),\n            uint256(fw.br),\n            uint256(fw.di),\n            uint256(fw.fq)\n        );\n    }\n\n\n    function bf(uint256 fk, address gs) internal {\n        bk(fk);\n        ey(gs, fk);\n        AuctionCancelled(fk);\n    }\n\n\n    function iv(uint256 fk, uint256 dy)\n        internal\n        returns (uint256)\n    {\n\n        Auction storage gy = aw[fk];\n\n\n        require(cp(gy));\n\n\n        uint256 ia = bn(gy);\n        require(dy >= ia);\n\n\n        address hk = gy.hk;\n\n\n        bk(fk);\n\n\n        if (ia > 0) {\n\n\n            uint256 bu = cz(ia);\n            uint256 bg = ia - bu;\n\n\n            hk.transfer(bg);\n        }\n\n\n        uint256 et = dy - ia;\n\n\n        msg.sender.transfer(et);\n\n\n        AuctionSuccessful(fk, ia, msg.sender);\n\n        return ia;\n    }\n\n\n    function bk(uint256 fk) internal {\n        delete aw[fk];\n    }\n\n\n    function cp(Auction storage fw) internal view returns (bool) {\n        return (fw.ez > 0);\n    }\n\n\n    function bn(Auction storage fw)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 ci = 0;\n\n\n        if (jg > fw.ez) {\n            ci = jg - fw.ez;\n        }\n\n        return p(\n            fw.br,\n            fw.di,\n            fw.fq,\n            ci\n        );\n    }\n\n\n    function p(\n        uint256 be,\n        uint256 cr,\n        uint256 es,\n        uint256 bi\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n\n\n        if (bi >= es) {\n\n\n            return cr;\n        } else {\n\n\n            int256 au = int256(cr) - int256(be);\n\n\n            int256 af = au * int256(bi) / int256(es);\n\n\n            int256 ct = int256(be) + af;\n\n            return uint256(ct);\n        }\n    }\n\n\n    function cz(uint256 hm) internal view returns (uint256) {\n\n\n        return hm * gc / 10000;\n    }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public hp = false;\n\n  modifier ce() {\n    require(!hp);\n    _;\n  }\n\n  modifier ej {\n    require(hp);\n    _;\n  }\n\n  function ii() eu ce returns (bool) {\n    hp = true;\n    Pause();\n    return true;\n  }\n\n  function gp() eu ej returns (bool) {\n    hp = false;\n    Unpause();\n    return true;\n  }\n}\n\n\ncontract ClockAuction is Pausable, ClockAuctionBase {\n\n\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n\n\n    function ClockAuction(address dm, uint256 iu) public {\n        require(iu <= 10000);\n        gc = iu;\n\n        ERC721 al = ERC721(dm);\n        require(al.ak(InterfaceSignature_ERC721));\n        ab = al;\n    }\n\n\n    function bd() external {\n        address eg = address(ab);\n\n        require(\n            msg.sender == ij ||\n            msg.sender == eg\n        );\n\n        bool je = eg.send(this.balance);\n    }\n\n\n    function bz(\n        uint256 fk,\n        uint256 be,\n        uint256 cr,\n        uint256 es,\n        address gs\n    )\n        external\n        ce\n    {\n\n\n        require(be == uint256(uint128(be)));\n        require(cr == uint256(uint128(cr)));\n        require(es == uint256(uint64(es)));\n\n        require(hz(msg.sender, fk));\n        gh(msg.sender, fk);\n        Auction memory gy = Auction(\n            gs,\n            uint128(be),\n            uint128(cr),\n            uint64(es),\n            uint64(jg),\n            0\n        );\n        de(fk, gy);\n    }\n\n\n    function ix(uint256 fk)\n        external\n        payable\n        ce\n    {\n\n        iv(fk, msg.value);\n        ey(msg.sender, fk);\n    }\n\n\n    function cg(uint256 fk)\n        external\n    {\n        Auction storage gy = aw[fk];\n        require(cp(gy));\n        address hk = gy.hk;\n        require(msg.sender == hk);\n        bf(fk, hk);\n    }\n\n\n    function e(uint256 fk)\n        ej\n        eu\n        external\n    {\n        Auction storage gy = aw[fk];\n        require(cp(gy));\n        bf(fk, gy.hk);\n    }\n\n\n    function dw(uint256 fk)\n        external\n        view\n        returns\n    (\n        address hk,\n        uint256 br,\n        uint256 di,\n        uint256 fq,\n        uint256 ez\n    ) {\n        Auction storage gy = aw[fk];\n        require(cp(gy));\n        return (\n            gy.hk,\n            gy.br,\n            gy.di,\n            gy.fq,\n            gy.ez\n        );\n    }\n\n\n    function ba(uint256 fk)\n        external\n        view\n        returns (uint256)\n    {\n        Auction storage gy = aw[fk];\n        require(cp(gy));\n        return bn(gy);\n    }\n\n}\n\n\ncontract SiringClockAuction is ClockAuction {\n\n\n    bool public t = true;\n\n\n    function SiringClockAuction(address fx, uint256 iu) public\n        ClockAuction(fx, iu) {}\n\n\n    function bz(\n        uint256 fk,\n        uint256 be,\n        uint256 cr,\n        uint256 es,\n        address gs\n    )\n        external\n    {\n\n\n        require(be == uint256(uint128(be)));\n        require(cr == uint256(uint128(cr)));\n        require(es == uint256(uint64(es)));\n\n        require(msg.sender == address(ab));\n        gh(gs, fk);\n        Auction memory gy = Auction(\n            gs,\n            uint128(be),\n            uint128(cr),\n            uint64(es),\n            uint64(jg),\n            0\n        );\n        de(fk, gy);\n    }\n\n\n    function ix(uint256 fk)\n        external\n        payable\n    {\n        require(msg.sender == address(ab));\n        address hk = aw[fk].hk;\n\n        iv(fk, msg.value);\n\n\n        ey(hk, fk);\n    }\n\n}\n\n\ncontract SaleClockAuction is ClockAuction {\n\n\n    bool public ac = true;\n\n\n    uint256 public cj;\n    uint256[5] public ad;\n    uint256 public constant SurpriseValue = 10 finney;\n\n    uint256[] CommonPanda;\n    uint256[] RarePanda;\n    uint256   CommonPandaIndex;\n    uint256   RarePandaIndex;\n\n\n    function SaleClockAuction(address fx, uint256 iu) public\n        ClockAuction(fx, iu) {\n            CommonPandaIndex = 1;\n            RarePandaIndex   = 1;\n    }\n\n\n    function bz(\n        uint256 fk,\n        uint256 be,\n        uint256 cr,\n        uint256 es,\n        address gs\n    )\n        external\n    {\n\n\n        require(be == uint256(uint128(be)));\n        require(cr == uint256(uint128(cr)));\n        require(es == uint256(uint64(es)));\n\n        require(msg.sender == address(ab));\n        gh(gs, fk);\n        Auction memory gy = Auction(\n            gs,\n            uint128(be),\n            uint128(cr),\n            uint64(es),\n            uint64(jg),\n            0\n        );\n        de(fk, gy);\n    }\n\n    function ao(\n        uint256 fk,\n        uint256 be,\n        uint256 cr,\n        uint256 es,\n        address gs\n    )\n        external\n    {\n\n\n        require(be == uint256(uint128(be)));\n        require(cr == uint256(uint128(cr)));\n        require(es == uint256(uint64(es)));\n\n        require(msg.sender == address(ab));\n        gh(gs, fk);\n        Auction memory gy = Auction(\n            gs,\n            uint128(be),\n            uint128(cr),\n            uint64(es),\n            uint64(jg),\n            1\n        );\n        de(fk, gy);\n    }\n\n\n    function ix(uint256 fk)\n        external\n        payable\n    {\n\n        uint64 hj = aw[fk].hj;\n        uint256 ia = iv(fk, msg.value);\n        ey(msg.sender, fk);\n\n\n        if (hj == 1) {\n\n            ad[cj % 5] = ia;\n            cj++;\n        }\n    }\n\n    function dq(uint256 fk,uint256 ik)\n        external\n    {\n        require(msg.sender == address(ab));\n        if (ik == 0) {\n            CommonPanda.push(fk);\n        }else {\n            RarePanda.push(fk);\n        }\n    }\n\n    function bo()\n        external\n        payable\n    {\n        bytes32 ic = ff(block.blockhash(block.number),block.blockhash(block.number-1));\n        uint256 PandaIndex;\n        if (ic[25] > 0xC8) {\n            require(uint256(RarePanda.length) >= RarePandaIndex);\n            PandaIndex = RarePandaIndex;\n            RarePandaIndex ++;\n\n        } else{\n            require(uint256(CommonPanda.length) >= CommonPandaIndex);\n            PandaIndex = CommonPandaIndex;\n            CommonPandaIndex ++;\n        }\n        ey(msg.sender,PandaIndex);\n    }\n\n    function cs() external view returns(uint256 hq,uint256 fz) {\n        hq   = CommonPanda.length + 1 - CommonPandaIndex;\n        fz = RarePanda.length + 1 - RarePandaIndex;\n    }\n\n    function r() external view returns (uint256) {\n        uint256 jc = 0;\n        for (uint256 i = 0; i < 5; i++) {\n            jc += ad[i];\n        }\n        return jc / 5;\n    }\n\n}\n\n\ncontract SaleClockAuctionERC20 is ClockAuction {\n\n    event AuctionERC20Created(uint256 gw, uint256 br, uint256 di, uint256 fq, address bv);\n\n\n    bool public d = true;\n\n    mapping (uint256 => address) public j;\n\n    mapping (address => uint256) public h;\n\n    mapping (address => uint256) public fv;\n\n\n    function SaleClockAuctionERC20(address fx, uint256 iu) public\n        ClockAuction(fx, iu) {}\n\n    function v(address bx, uint256 hc) external{\n        require (msg.sender == address(ab));\n\n        require (bx != address(0));\n\n        h[bx] = hc;\n    }\n\n\n    function bz(\n        uint256 fk,\n        address ch,\n        uint256 be,\n        uint256 cr,\n        uint256 es,\n        address gs\n    )\n        external\n    {\n\n\n        require(be == uint256(uint128(be)));\n        require(cr == uint256(uint128(cr)));\n        require(es == uint256(uint64(es)));\n\n        require(msg.sender == address(ab));\n\n        require (h[ch] > 0);\n\n        gh(gs, fk);\n        Auction memory gy = Auction(\n            gs,\n            uint128(be),\n            uint128(cr),\n            uint64(es),\n            uint64(jg),\n            0\n        );\n        aq(fk, gy, ch);\n        j[fk] = ch;\n    }\n\n\n    function aq(uint256 fk, Auction fw, address bx) internal {\n\n\n        require(fw.fq >= 1 minutes);\n\n        aw[fk] = fw;\n\n        AuctionERC20Created(\n            uint256(fk),\n            uint256(fw.br),\n            uint256(fw.di),\n            uint256(fw.fq),\n            bx\n        );\n    }\n\n    function ix(uint256 fk)\n        external\n        payable{\n\n    }\n\n\n    function fp(uint256 fk,uint256 gr)\n        external\n    {\n\n        address hk = aw[fk].hk;\n        address bx = j[fk];\n        require (bx != address(0));\n        uint256 ia = ev(bx,msg.sender,fk, gr);\n        ey(msg.sender, fk);\n        delete j[fk];\n    }\n\n    function cg(uint256 fk)\n        external\n    {\n        Auction storage gy = aw[fk];\n        require(cp(gy));\n        address hk = gy.hk;\n        require(msg.sender == hk);\n        bf(fk, hk);\n        delete j[fk];\n    }\n\n    function q(address ch, address jf) external returns(bool je)  {\n        require (fv[ch] > 0);\n        require(msg.sender == address(ab));\n        ERC20(ch).transfer(jf, fv[ch]);\n    }\n\n\n    function ev(address ch,address by, uint256 fk, uint256 dy)\n        internal\n        returns (uint256)\n    {\n\n        Auction storage gy = aw[fk];\n\n\n        require(cp(gy));\n\n        require (ch != address(0) && ch == j[fk]);\n\n\n        uint256 ia = bn(gy);\n        require(dy >= ia);\n\n\n        address hk = gy.hk;\n\n\n        bk(fk);\n\n\n        if (ia > 0) {\n\n\n            uint256 bu = cz(ia);\n            uint256 bg = ia - bu;\n\n\n            require(ERC20(ch).cu(by,hk,bg));\n            if (bu > 0){\n                require(ERC20(ch).cu(by,address(this),bu));\n                fv[ch] += bu;\n            }\n        }\n\n\n        AuctionSuccessful(fk, ia, msg.sender);\n\n        return ia;\n    }\n}\n\n\ncontract PandaAuction is PandaBreeding {\n\n\n    function m(address fj) external gj {\n        SaleClockAuction al = SaleClockAuction(fj);\n\n\n        require(al.ac());\n\n\n        df = al;\n    }\n\n    function a(address fj) external gj {\n        SaleClockAuctionERC20 al = SaleClockAuctionERC20(fj);\n\n\n        require(al.d());\n\n\n        ar = al;\n    }\n\n\n    function f(address fj) external gj {\n        SiringClockAuction al = SiringClockAuction(fj);\n\n\n        require(al.t());\n\n\n        ca = al;\n    }\n\n\n    function an(\n        uint256 fo,\n        uint256 be,\n        uint256 cr,\n        uint256 es\n    )\n        external\n        ce\n    {\n\n\n        require(hz(msg.sender, fo));\n\n\n        require(!ef(fo));\n        fl(fo, df);\n\n\n        df.bz(\n            fo,\n            be,\n            cr,\n            es,\n            msg.sender\n        );\n    }\n\n\n    function i(\n        uint256 fo,\n        address bx,\n        uint256 be,\n        uint256 cr,\n        uint256 es\n    )\n        external\n        ce\n    {\n\n\n        require(hz(msg.sender, fo));\n\n\n        require(!ef(fo));\n        fl(fo, ar);\n\n\n        ar.bz(\n            fo,\n            bx,\n            be,\n            cr,\n            es,\n            msg.sender\n        );\n    }\n\n    function b(address bx, uint256 hc) external ge{\n        ar.v(bx,hc);\n    }\n\n\n    function z(\n        uint256 fo,\n        uint256 be,\n        uint256 cr,\n        uint256 es\n    )\n        external\n        ce\n    {\n\n\n        require(hz(msg.sender, fo));\n        require(bh(fo));\n        fl(fo, ca);\n\n\n        ca.bz(\n            fo,\n            be,\n            cr,\n            es,\n            msg.sender\n        );\n    }\n\n\n    function aj(\n        uint256 gx,\n        uint256 ex\n    )\n        external\n        payable\n        ce\n    {\n\n        require(hz(msg.sender, ex));\n        require(bh(ex));\n        require(g(ex, gx));\n\n\n        uint256 ct = ca.ba(gx);\n        require(msg.value >= ct + co);\n\n\n        ca.ix.value(msg.value - co)(gx);\n        eh(uint32(ex), uint32(gx), msg.sender);\n    }\n\n\n    function c() external dt {\n        df.bd();\n        ca.bd();\n    }\n\n    function q(address ch, address jf) external dt {\n        require(ar != address(0));\n        ar.q(ch,jf);\n    }\n}\n\n\ncontract PandaMinting is PandaAuction {\n\n\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\n\n\n    uint256 public constant GEN0_STARTING_PRICE = 100 finney;\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\n    uint256 public constant OPEN_PACKAGE_PRICE = 10 finney;\n\n\n    function bb(uint256[2] hs, uint256 dc, address he) external ge {\n        address ek = he;\n        if (ek == address(0)) {\n            ek = ea;\n        }\n\n        cq(0, 0, dc, hs, ek);\n    }\n\n\n    function dq(uint256[2] hs,uint256 dc,uint256 ik)\n        external\n        payable\n        ge\n        ce\n    {\n        require(msg.value >= OPEN_PACKAGE_PRICE);\n        uint256 fi = cq(0, 0, dc, hs, df);\n        df.dq(fi,ik);\n    }\n\n\n    function ao(uint256 fo) external ge {\n        require(hz(msg.sender, fo));\n\n\n        fl(fo, df);\n\n        df.ao(\n            fo,\n            n(),\n            0,\n            GEN0_AUCTION_DURATION,\n            msg.sender\n        );\n    }\n\n\n    function n() internal view returns(uint256) {\n        uint256 gb = df.r();\n\n        require(gb == uint256(uint128(gb)));\n\n        uint256 fb = gb + (gb / 2);\n\n\n        if (fb < GEN0_STARTING_PRICE) {\n            fb = GEN0_STARTING_PRICE;\n        }\n\n        return fb;\n    }\n}\n\n\ncontract PandaCore is PandaMinting {\n\n\n    address public ai;\n\n\n    function PandaCore() public {\n\n        hp = true;\n\n\n        ds = msg.sender;\n\n\n        ea = msg.sender;\n\n\n    }\n\n\n    function in() external gj ej {\n\n        require(hd.length == 0);\n\n        uint256[2] memory hs = [uint256(-1),uint256(-1)];\n\n        bl[1] = 100;\n       cq(0, 0, 0, hs, address(0));\n    }\n\n\n    function bp(address ec) external gj ej {\n\n        ai = ec;\n        ContractUpgrade(ec);\n    }\n\n\n    function() external payable {\n        require(\n            msg.sender == address(df) ||\n            msg.sender == address(ca)\n        );\n    }\n\n\n    function fu(uint256 iy)\n        external\n        view\n        returns (\n        bool dp,\n        bool gi,\n        uint256 bq,\n        uint256 cv,\n        uint256 ck,\n        uint256 em,\n        uint256 ft,\n        uint256 hh,\n        uint256 dx,\n        uint256[2] ig\n    ) {\n        Panda storage ja = hd[iy];\n\n\n        dp = (ja.ck != 0);\n        gi = (ja.av <= block.number);\n        bq = uint256(ja.bq);\n        cv = uint256(ja.av);\n        ck = uint256(ja.ck);\n        em = uint256(ja.em);\n        ft = uint256(ja.ft);\n        hh = uint256(ja.hh);\n        dx = uint256(ja.dx);\n        ig = ja.ig;\n    }\n\n\n    function gp() public gj ej {\n        require(df != address(0));\n        require(ca != address(0));\n        require(dj != address(0));\n        require(ai == address(0));\n\n\n        super.gp();\n    }\n\n\n    function bd() external gd {\n        uint256 balance = this.balance;\n\n        uint256 cl = (bm + 1) * co;\n\n        if (balance > cl) {\n            ed.send(balance - cl);\n        }\n    }\n}",
      "rename_map": {
        "setSaleAuctionERC20Address": "a",
        "switchSaleAuctionERC20For": "b",
        "withdrawAuctionBalances": "c",
        "isSaleClockAuctionERC20": "d",
        "cancelAuctionWhenPaused": "e",
        "setSiringAuctionAddress": "f",
        "_canBreedWithViaAuction": "g",
        "erc20ContractsSwitcher": "h",
        "createSaleAuctionERC20": "i",
        "tokenIdToErc20Address": "j",
        "setGeneScienceAddress": "k",
        "_exchangeMatronSireId": "l",
        "setSaleAuctionAddress": "m",
        "_computeNextGen0Price": "n",
        "pandaIndexToApproved": "o",
        "_computeCurrentPrice": "p",
        "withdrawERC20Balance": "q",
        "averageGen0SalePrice": "r",
        "sireAllowedToAddress": "s",
        "isSiringClockAuction": "t",
        "getWizzPandaCountOf": "u",
        "erc20ContractSwitch": "v",
        "setTotalWizzPandaOf": "w",
        "_isReadyToGiveBirth": "x",
        "ownershipTokenCount": "y",
        "createSiringAuction": "z",
        "getWizzPandaQuotaOf": "aa",
        "nonFungibleContract": "ab",
        "isSaleClockAuction": "ac",
        "lastGen0SalePrices": "ad",
        "setSecondsPerBlock": "ae",
        "currentPriceChange": "af",
        "_isValidMatingPair": "ag",
        "_isSiringPermitted": "ah",
        "newContractAddress": "ai",
        "bidOnSiringAuction": "aj",
        "supportsInterface": "ak",
        "candidateContract": "al",
        "pandaIndexToOwner": "am",
        "createSaleAuction": "an",
        "createGen0Auction": "ao",
        "transferOwnership": "ap",
        "_addAuctionERC20": "aq",
        "saleAuctionERC20": "ar",
        "gen0CreatedCount": "as",
        "_triggerCooldown": "at",
        "totalPriceChange": "au",
        "cooldownEndBlock": "av",
        "tokenIdToAuction": "aw",
        "getPureFromGene": "ax",
        "secondsPerBlock": "ay",
        "setAutoBirthFee": "az",
        "getCurrentPrice": "ba",
        "createWizzPanda": "bb",
        "_isReadyToBreed": "bc",
        "withdrawBalance": "bd",
        "_startingPrice": "be",
        "_cancelAuction": "bf",
        "sellerProceeds": "bg",
        "isReadyToBreed": "bh",
        "_secondsPassed": "bi",
        "wizzPandaCount": "bj",
        "_removeAuction": "bk",
        "wizzPandaQuota": "bl",
        "pregnantPandas": "bm",
        "_currentPrice": "bn",
        "surprisePanda": "bo",
        "setNewAddress": "bp",
        "cooldownIndex": "bq",
        "startingPrice": "br",
        "isGeneScience": "bs",
        "_stringLength": "bt",
        "auctioneerCut": "bu",
        "erc20Contract": "bv",
        "clearWizzType": "bw",
        "_erc20address": "bx",
        "_buyerAddress": "by",
        "createAuction": "bz",
        "siringAuction": "ca",
        "tokensOfOwner": "cb",
        "breedWithAuto": "cc",
        "approveSiring": "cd",
        "whenNotPaused": "ce",
        "getWizzTypeOf": "cf",
        "cancelAuction": "cg",
        "_erc20Address": "ch",
        "secondsPassed": "ci",
        "gen0SaleCount": "cj",
        "siringWithId": "ck",
        "subtractFees": "cl",
        "canBreedWith": "cm",
        "_approvedFor": "cn",
        "autoBirthFee": "co",
        "_isOnAuction": "cp",
        "_createPanda": "cq",
        "_endingPrice": "cr",
        "packageCount": "cs",
        "currentPrice": "ct",
        "transferFrom": "cu",
        "nextActionAt": "cv",
        "_interfaceID": "cw",
        "outputString": "cx",
        "totalSupply": "cy",
        "_computeCut": "cz",
        "newKittenId": "da",
        "getMetadata": "db",
        "_generation": "dc",
        "ownerTokens": "dd",
        "_addAuction": "de",
        "saleAuction": "df",
        "probability": "dg",
        "matronOwner": "dh",
        "endingPrice": "di",
        "geneScience": "dj",
        "_childGenes": "dk",
        "targetBlock": "dl",
        "_nftAddress": "dm",
        "resultIndex": "dn",
        "getWizzType": "do",
        "isGestating": "dp",
        "createPanda": "dq",
        "newContract": "dr",
        "ceoAddress": "ds",
        "onlyCLevel": "dt",
        "_allowance": "du",
        "totalPrice": "dv",
        "getAuction": "dw",
        "generation": "dx",
        "_bidAmount": "dy",
        "childGenes": "dz",
        "cooAddress": "ea",
        "tokenCount": "eb",
        "_v2Address": "ec",
        "cfoAddress": "ed",
        "pureDegree": "ee",
        "isPregnant": "ef",
        "nftAddress": "eg",
        "_breedWith": "eh",
        "childOwner": "ei",
        "whenPaused": "ej",
        "pandaOwner": "ek",
        "cooldowns": "el",
        "birthTime": "em",
        "parentGen": "en",
        "_toString": "eo",
        "_approved": "ep",
        "sireOwner": "eq",
        "totalCats": "er",
        "_duration": "es",
        "bidExcess": "et",
        "onlyOwner": "eu",
        "_bidERC20": "ev",
        "_claimant": "ew",
        "_matronId": "ex",
        "_transfer": "ey",
        "startedAt": "ez",
        "_rawBytes": "fa",
        "nextPrice": "fb",
        "giveBirth": "fc",
        "allowance": "fd",
        "_receiver": "fe",
        "keccak256": "ff",
        "balanceOf": "fg",
        "outputPtr": "fh",
        "kittenId": "fi",
        "_address": "fj",
        "_tokenId": "fk",
        "_approve": "fl",
        "newOwner": "fm",
        "approved": "fn",
        "_pandaId": "fo",
        "bidERC20": "fp",
        "duration": "fq",
        "bytesPtr": "fr",
        "destpart": "fs",
        "matronId": "ft",
        "getPanda": "fu",
        "balances": "fv",
        "_auction": "fw",
        "_nftAddr": "fx",
        "mixGenes": "fy",
        "surprise": "fz",
        "_factors": "ga",
        "avePrice": "gb",
        "ownerCut": "gc",
        "onlyCFO": "gd",
        "onlyCOO": "ge",
        "_newCEO": "gf",
        "ownerOf": "gg",
        "_escrow": "gh",
        "isReady": "gi",
        "onlyCEO": "gj",
        "_newCOO": "gk",
        "_memcpy": "gl",
        "_newCFO": "gm",
        "_matron": "gn",
        "_kitten": "go",
        "unpause": "gp",
        "spender": "gq",
        "_amount": "gr",
        "_seller": "gs",
        "srcpart": "gt",
        "pandaId": "gu",
        "approve": "gv",
        "tokenId": "gw",
        "_sireId": "gx",
        "auction": "gy",
        "setCOO": "gz",
        "matron": "ha",
        "getSex": "hb",
        "_onoff": "hc",
        "pandas": "hd",
        "_owner": "he",
        "result": "hf",
        "genes2": "hg",
        "sireId": "hh",
        "setCEO": "hi",
        "isGen0": "hj",
        "seller": "hk",
        "_panda": "hl",
        "_price": "hm",
        "_total": "hn",
        "genes1": "ho",
        "paused": "hp",
        "common": "hq",
        "symbol": "hr",
        "_genes": "hs",
        "winner": "ht",
        "supply": "hu",
        "setCFO": "hv",
        "buffer": "hw",
        "catId": "hx",
        "_from": "hy",
        "_owns": "hz",
        "price": "ia",
        "_dest": "ib",
        "bHash": "ic",
        "_sire": "id",
        "total": "ie",
        "_addr": "if",
        "genes": "ig",
        "_gene": "ih",
        "pause": "ii",
        "owner": "ij",
        "_type": "ik",
        "count": "il",
        "name": "im",
        "init": "in",
        "sire": "io",
        "_len": "ip",
        "mask": "iq",
        "gene": "ir",
        "_src": "is",
        "secs": "it",
        "_cut": "iu",
        "_bid": "iv",
        "_kit": "iw",
        "bid": "ix",
        "_id": "iy",
        "_tp": "iz",
        "kit": "ja",
        "val": "jb",
        "sum": "jc",
        "who": "jd",
        "res": "je",
        "_to": "jf",
        "now": "jg",
        "g1": "jh",
        "to": "ji",
        "g2": "jj",
        "_p": "jk",
        "ok": "jl"
      },
      "changes": [
        "Renamed 272 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_215",
      "transformed_id": "ss_l2_short_nc_ds_215",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier y()\n    {\n        require(msg.sender == al);\n        _;\n    }\n\n   modifier f()\n    {\n        require(m);\n        _;\n    }\n\n    modifier e()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  p()\n    {\n        require (ag[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 ae, address w);\n    event Win(uint256 ae, address aj);\n    event Lose(uint256 ae, address an);\n    event Donate(uint256 ae, address aj, address ac);\n    event DifficultyChanged(uint256 b);\n    event BetLimitChanged(uint256 d);\n\n    address private ao;\n    uint256 aa;\n    uint difficulty;\n    uint private u;\n    address al;\n    mapping(address => uint256) r;\n    mapping(address => uint256) ag;\n    bool m;\n    uint256 j;\n\n    constructor(address n, uint256 s)\n    e()\n    public\n    {\n        m = false;\n        al = msg.sender;\n        ao = n;\n        j = 0;\n        aa = s;\n\n    }\n\n    function OpenToThePublic()\n    y()\n    public\n    {\n        m = true;\n    }\n\n    function AdjustBetAmounts(uint256 ae)\n    y()\n    public\n    {\n        aa = ae;\n\n        emit BetLimitChanged(aa);\n    }\n\n    function AdjustDifficulty(uint256 ae)\n    y()\n    public\n    {\n        difficulty = ae;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function am()\n    f()\n    e()\n    payable\n    public\n    {\n\n        require(msg.value == aa);\n\n\n        r[msg.sender] = block.number;\n        ag[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function ap()\n    f()\n    e()\n    p()\n    public\n    {\n        uint256 o = r[msg.sender];\n        if(o < block.number)\n        {\n            r[msg.sender] = 0;\n            ag[msg.sender] = 0;\n\n            uint256 g = uint256(x(abi.k(blockhash(o),  msg.sender)))%difficulty +1;\n\n            if(g == difficulty / 2)\n            {\n                af(msg.sender);\n            }\n            else\n            {\n\n                z(aa / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function ak()\n    f()\n    public\n    payable\n    {\n        h(msg.value);\n    }\n\n    function af(address ad)\n    internal\n    {\n        uint256 i = address(this).balance / 2;\n\n        ad.transfer(i);\n        emit Win(i, ad);\n    }\n\n    function h(uint256 ae)\n    internal\n    {\n        ao.call.value(ae)(bytes4(x(\"donate()\")));\n        j += ae;\n        emit Donate(ae, ao, msg.sender);\n    }\n\n    function z(uint256 ae)\n    internal\n    {\n        ao.call.value(ae)(bytes4(x(\"donate()\")));\n        j += ae;\n        emit Lose(ae, msg.sender);\n    }\n\n    function q()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function b()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function d()\n    public\n    view\n    returns (uint256)\n    {\n        return aa;\n    }\n\n    function c(address ah)\n    public\n    view\n    returns (bool)\n    {\n        if(ag[ah] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function t()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function a(address l, address v, uint ai)\n    public\n    y()\n    returns (bool ab)\n    {\n        return ERC20Interface(l).transfer(v, ai);\n    }\n}\n\n\ncontract ERC20Interface\n{\n    function transfer(address aq, uint256 ai) public returns (bool ab);\n}",
      "rename_map": {
        "transferAnyERC20Token": "a",
        "currentDifficulty": "b",
        "hasPlayerWagered": "c",
        "currentBetLimit": "d",
        "onlyRealPeople": "e",
        "isOpenToPublic": "f",
        "winningNumber": "g",
        "donateToWhale": "h",
        "ethToTransfer": "i",
        "totalDonated": "j",
        "encodePacked": "k",
        "tokenAddress": "l",
        "openToPublic": "m",
        "whaleAddress": "n",
        "blockNumber": "o",
        "onlyPlayers": "p",
        "ethBalance": "q",
        "timestamps": "r",
        "wagerLimit": "s",
        "winnersPot": "t",
        "randomSeed": "u",
        "tokenOwner": "v",
        "depositer": "w",
        "keccak256": "x",
        "onlyOwner": "y",
        "loseWager": "z",
        "betLimit": "aa",
        "success": "ab",
        "donator": "ac",
        "winner": "ad",
        "amount": "ae",
        "payout": "af",
        "wagers": "ag",
        "player": "ah",
        "tokens": "ai",
        "paidTo": "aj",
        "donate": "ak",
        "owner": "al",
        "wager": "am",
        "loser": "an",
        "whale": "ao",
        "play": "ap",
        "to": "aq"
      },
      "changes": [
        "Renamed 43 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_216",
      "transformed_id": "ss_l2_short_nc_ds_216",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.24;\n\ncontract FiftyFlip {\n    uint constant DONATING_X = 20;\n\n\n    uint constant JACKPOT_FEE = 10;\n    uint constant JACKPOT_MODULO = 1000;\n    uint constant DEV_FEE = 20;\n    uint constant WIN_X = 1900;\n\n\n    uint constant MIN_BET = 0.01 ether;\n    uint constant MAX_BET = 1 ether;\n\n    uint constant BET_EXPIRATION_BLOCKS = 250;\n\n\n    address public bn;\n    address public ah;\n    address public y;\n    address private br;\n\n\n    uint256 public ai;\n    uint256 public ak;\n\n\n    uint256 public ac;\n    uint256 public h;\n\n    struct Bet {\n\n        uint bi;\n\n        uint256 ag;\n\n        bool bf;\n\n        address bk;\n    }\n\n    mapping (uint => Bet) bs;\n    mapping (address => uint) ae;\n\n\n    event Wager(uint az, uint ax, uint256 o, bool bf, address aq);\n    event Win(address bh, uint bi, uint az, bool bd, uint an);\n    event Lose(address bq, uint bi, uint az, bool bd, uint an);\n    event Refund(uint az, uint256 bi, address au);\n    event Donate(uint256 bi, address be);\n    event FailedPayment(address ay, uint bi);\n    event Payment(address aj, uint bi);\n    event JackpotPayment(address bk, uint az, uint ao);\n\n\n    constructor (address af, address g, address e) public {\n        bn = msg.sender;\n        ah = g;\n        br = af;\n        y = e;\n        ai = 0;\n        ak = 0;\n        ac = 0;\n        h = 0;\n    }\n\n\n    modifier av() {\n        require (msg.sender == bn, \"You are not the owner of this contract!\");\n        _;\n    }\n\n    modifier bc() {\n        require (msg.sender == ah, \"You are not the bot of this contract!\");\n        _;\n    }\n\n    modifier d() {\n        require (address(this).balance >= ac + ai + ak, \"This contract doesn't have enough balance, it is stopped till someone donate to this game!\");\n        _;\n    }\n\n\n    function() public payable { }\n\n    function t(address g)\n    av()\n    external\n    {\n        ah = g;\n    }\n\n    function l(address u)\n    av()\n    external\n    {\n        y = u;\n    }\n\n\n    function bp(bool bo, uint az, uint n, uint8 v, bytes32 r, bytes32 s)\n    d()\n    external\n    payable {\n        Bet storage bv = bs[az];\n        uint bi = msg.value;\n        address bk = msg.sender;\n        require (bv.bk == address(0), \"Ticket is not new one!\");\n        require (bi >= MIN_BET, \"Your bet is lower than minimum bet amount\");\n        require (bi <= MAX_BET, \"Your bet is higher than maximum bet amount\");\n        require (c() >= 2 * bi, \"If we accept this, this contract will be in danger!\");\n\n        require (block.number <= n, \"Ticket has expired.\");\n        bytes32 s = as(abi.ab('\\x19Ethereum Signed Message:\\n37', uint40(n), az));\n        require (y == ar(s, v, r, s), \"web3 vrs signature is not valid.\");\n\n        ai += bi * JACKPOT_FEE / 1000;\n        ak += bi * DEV_FEE / 1000;\n        ac += bi * WIN_X / 1000;\n\n        uint w = bi * DONATING_X / 1000;\n        br.call.value(w)(bytes4(as(\"donate()\")));\n        h += w;\n\n        bv.bi = bi;\n        bv.ag = block.number;\n        bv.bf = bo;\n        bv.bk = bk;\n\n        emit Wager(az, bv.bi, bv.ag, bv.bf, bv.bk);\n    }\n\n\n    function bu(uint z)\n    d()\n    external\n    {\n        uint az = uint(as(abi.ab(z)));\n        Bet storage bv = bs[az];\n        require (bv.bk != address(0), \"TicketID is not correct!\");\n        require (bv.bi != 0, \"Ticket is already used one!\");\n        uint256 ag = bv.ag;\n        if(ag < block.number && ag >= block.number - BET_EXPIRATION_BLOCKS)\n        {\n            uint256 bg = uint256(as(abi.ab(blockhash(ag),  z)));\n            bool bd = (bg % 2) !=0;\n            uint an = bg % JACKPOT_MODULO;\n\n            uint v = bv.bi * WIN_X / 1000;\n\n            uint ba = 0;\n            uint ao = 0;\n\n            if(bv.bf == bd) {\n                ba = v;\n            }\n            if(an == 0) {\n                ao = ai;\n                ai = 0;\n            }\n            if (ao > 0) {\n                emit JackpotPayment(bv.bk, az, ao);\n            }\n            if(ba + ao > 0)\n            {\n                bj(bv.bk, ba + ao, az, bd, an);\n            }\n            else\n            {\n                aw(bv.bk, bv.bi, az, bd, an);\n            }\n            ac -= v;\n            bv.bi = 0;\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function a()\n    external\n    payable\n    {\n        ae[msg.sender] += msg.value;\n        emit Donate(msg.value, msg.sender);\n    }\n\n    function k(uint bi)\n    external\n    {\n        require(ae[msg.sender] >= bi, \"You are going to withdraw more than you donated!\");\n\n        if (at(msg.sender, bi)){\n            ae[msg.sender] -= bi;\n        }\n    }\n\n\n    function bm(uint az)\n    d()\n    external {\n        Bet storage bv = bs[az];\n\n        require (bv.bi != 0, \"this ticket has no balance\");\n        require (block.number > bv.ag + BET_EXPIRATION_BLOCKS, \"this ticket is expired.\");\n        am(az);\n    }\n\n\n    function p(address m, uint r)\n    av()\n    d()\n    external {\n        require (ak >= r, \"You are trying to withdraw more amount than developer fee.\");\n        require (r <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (ak <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (at(m, r)){\n            ak -= r;\n        }\n    }\n\n\n    function q(uint r)\n    bc()\n    d()\n    external {\n        require (ak >= r, \"You are trying to withdraw more amount than developer fee.\");\n        require (r <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (ak <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (at(ah, r)){\n            ak -= r;\n        }\n    }\n\n\n    function al(uint az)\n    constant\n    external\n    returns (uint, uint256, bool, address){\n        Bet storage bv = bs[az];\n        return (bv.bi, bv.ag, bv.bf, bv.bk);\n    }\n\n\n    function f()\n    constant\n    external\n    returns (uint){\n        return address(this).balance;\n    }\n\n\n    function c()\n    constant\n    public\n    returns (uint){\n        if (address(this).balance > ac + ai + ak)\n            return address(this).balance - ac - ai - ak;\n        return 0;\n    }\n\n\n    function bt() external av() {\n        require (ac == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n        selfdestruct(bn);\n    }\n\n\n    function bj(address bh, uint x, uint az, bool bd, uint an)\n    internal\n    {\n        bh.transfer(x);\n        emit Win(bh, x, az, bd, an);\n    }\n\n\n    function am(uint az)\n    internal\n    {\n        Bet storage bv = bs[az];\n        address au = bv.bk;\n        uint256 x = bv.bi;\n        au.transfer(x);\n\n        uint v = bv.bi * WIN_X / 1000;\n        ac -= v;\n\n        bv.bi = 0;\n        emit Refund(az, x, au);\n    }\n\n\n    function at(address ay, uint bi) private returns (bool){\n        bool bb = ay.send(bi);\n        if (bb) {\n            emit Payment(ay, bi);\n        } else {\n            emit FailedPayment(ay, bi);\n        }\n        return bb;\n    }\n\n    function aw(address bk, uint bi, uint az, bool bd, uint an)\n    internal\n    {\n        emit Lose(bk, bi, az, bd, an);\n    }\n\n\n    function aa(uint[] j) external {\n        uint length = j.length;\n\n        for (uint i = 0; i < length; i++) {\n            i(j[i]);\n        }\n    }\n\n\n    function i(uint az) private {\n        Bet storage bv = bs[az];\n\n\n        if (bv.bi != 0 || block.number <= bv.ag + BET_EXPIRATION_BLOCKS) {\n            return;\n        }\n\n        bv.ag = 0;\n        bv.bf = false;\n        bv.bk = address(0);\n    }\n\n\n    function b(address ad, address ap, uint bl)\n    public\n    av()\n    returns (bool bb)\n    {\n        return ERC20Interface(ad).transfer(ap, bl);\n    }\n}\n\n\ncontract ERC20Interface\n{\n    function transfer(address bw, uint256 bl) public returns (bool bb);\n}",
      "rename_map": {
        "donateForContractHealth": "a",
        "transferAnyERC20Token": "b",
        "getCollateralBalance": "c",
        "checkContractHealth": "d",
        "secretSignerAddress": "e",
        "getContractBalance": "f",
        "autoPlayBotAddress": "g",
        "totalAmountToWhale": "h",
        "clearProcessedBet": "i",
        "toCleanTicketIDs": "j",
        "withdrawDonation": "k",
        "setSecretSigner": "l",
        "withdrawAddress": "m",
        "ticketLastBlock": "n",
        "betBlockNumber": "o",
        "withdrawDevFee": "p",
        "withdrawBotFee": "q",
        "withdrawAmount": "r",
        "signatureHash": "s",
        "setBotAddress": "t",
        "_secretSigner": "u",
        "tossWinAmount": "v",
        "donate_amount": "w",
        "ethToTransfer": "x",
        "secretSigner": "y",
        "ticketReveal": "z",
        "clearStorage": "aa",
        "encodePacked": "ab",
        "lockedInBets": "ac",
        "tokenAddress": "ad",
        "donateAmount": "ae",
        "whaleAddress": "af",
        "blockNumber": "ag",
        "autoPlayBot": "ah",
        "jackpotSize": "ai",
        "noPaidUser": "aj",
        "devFeeSize": "ak",
        "getBetInfo": "al",
        "sendRefund": "am",
        "jackpotRes": "an",
        "jackpotWin": "ao",
        "tokenOwner": "ap",
        "betPlayer": "aq",
        "ecrecover": "ar",
        "keccak256": "as",
        "sendFunds": "at",
        "requester": "au",
        "onlyOwner": "av",
        "loseWager": "aw",
        "betAmount": "ax",
        "paidUser": "ay",
        "ticketID": "az",
        "tossWin": "ba",
        "success": "bb",
        "onlyBot": "bc",
        "maskRes": "bd",
        "donator": "be",
        "betMask": "bf",
        "random": "bg",
        "winner": "bh",
        "amount": "bi",
        "payout": "bj",
        "player": "bk",
        "tokens": "bl",
        "refund": "bm",
        "owner": "bn",
        "bMask": "bo",
        "wager": "bp",
        "loser": "bq",
        "whale": "br",
        "bets": "bs",
        "kill": "bt",
        "play": "bu",
        "bet": "bv",
        "to": "bw"
      },
      "changes": [
        "Renamed 75 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_232",
      "transformed_id": "ss_l2_short_nc_ds_232",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.16;\n\nlibrary SafeMath {\n  function ae(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n\n  function ak(uint256 a, uint256 b) internal constant returns (uint256) {\n\n    uint256 c = a / b;\n\n    return c;\n  }\n\n  function aj(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function ah(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint256 public f;\n  function j(address ai) public constant returns (uint256);\n  function transfer(address al, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed al, uint256 value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) o;\n\n  function transfer(address af, uint256 w) public returns (bool) {\n    require(af != address(0));\n    require(w > 0 && w <= o[msg.sender]);\n\n\n    o[msg.sender] = o[msg.sender].aj(w);\n    o[af] = o[af].ah(w);\n    Transfer(msg.sender, af, w);\n    return true;\n  }\n\n  function j(address z) public constant returns (uint256 balance) {\n    return o[z];\n  }\n}\n\ncontract ERC20 is ERC20Basic {\n  function l(address aa, address s) public constant returns (uint256);\n  function e(address from, address al, uint256 value) public returns (bool);\n  function u(address s, uint256 value) public returns (bool);\n  event Approval(address indexed aa, address indexed s, uint256 value);\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal t;\n\n  function e(address ab, address af, uint256 w) public returns (bool) {\n    require(af != address(0));\n    require(w > 0 && w <= o[ab]);\n    require(w <= t[ab][msg.sender]);\n\n    o[ab] = o[ab].aj(w);\n    o[af] = o[af].ah(w);\n    t[ab][msg.sender] = t[ab][msg.sender].aj(w);\n    Transfer(ab, af, w);\n    return true;\n  }\n\n  function u(address n, uint256 w) public returns (bool) {\n    t[msg.sender][n] = w;\n    Approval(msg.sender, n, w);\n    return true;\n  }\n\n  function l(address z, address n) public constant returns (uint256 k) {\n    return t[z][n];\n  }\n}\n\ncontract Ownable {\n  address public aa;\n\n  event OwnershipTransferred(address indexed c, address indexed m);\n\n  function Ownable() {\n    aa = msg.sender;\n  }\n\n  modifier i() {\n    require(msg.sender == aa);\n    _;\n  }\n\n  function a(address m) i public {\n    require(m != address(0));\n    OwnershipTransferred(aa, m);\n    aa = m;\n  }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public y = false;\n\n  modifier d() {\n    require(!y);\n    _;\n  }\n\n  modifier g() {\n    require(y);\n    _;\n  }\n\n  function ac() i d public {\n    y = true;\n    Pause();\n  }\n\n  function r() i g public {\n    y = false;\n    Unpause();\n  }\n}\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address af, uint256 w) public d returns (bool) {\n    return super.transfer(af, w);\n  }\n\n  function e(address ab, address af, uint256 w) public d returns (bool) {\n    return super.e(ab, af, w);\n  }\n\n  function u(address n, uint256 w) public d returns (bool) {\n    return super.u(n, w);\n  }\n\n  function b(address[] h, uint256 w) public d returns (bool) {\n    uint ag = h.length;\n    uint256 x = uint256(ag) * w;\n    require(ag > 0 && ag <= 20);\n    require(w > 0 && o[msg.sender] >= x);\n\n    o[msg.sender] = o[msg.sender].aj(x);\n    for (uint i = 0; i < ag; i++) {\n        o[h[i]] = o[h[i]].ah(w);\n        Transfer(msg.sender, h[i], w);\n    }\n    return true;\n  }\n}\n\ncontract BecToken is PausableToken {\n    string public ad = \"BeautyChain\";\n    string public v = \"BEC\";\n    string public q = '1.0.0';\n    uint8 public p = 18;\n\n    function BecToken() {\n      f = 7000000000 * (10**(uint256(p)));\n      o[msg.sender] = f;\n    }\n\n    function () {\n\n        revert();\n    }\n}",
      "rename_map": {
        "transferOwnership": "a",
        "batchTransfer": "b",
        "previousOwner": "c",
        "whenNotPaused": "d",
        "transferFrom": "e",
        "totalSupply": "f",
        "whenPaused": "g",
        "_receivers": "h",
        "onlyOwner": "i",
        "balanceOf": "j",
        "remaining": "k",
        "allowance": "l",
        "newOwner": "m",
        "_spender": "n",
        "balances": "o",
        "decimals": "p",
        "version": "q",
        "unpause": "r",
        "spender": "s",
        "allowed": "t",
        "approve": "u",
        "symbol": "v",
        "_value": "w",
        "amount": "x",
        "paused": "y",
        "_owner": "z",
        "owner": "aa",
        "_from": "ab",
        "pause": "ac",
        "name": "ad",
        "mul": "ae",
        "_to": "af",
        "cnt": "ag",
        "add": "ah",
        "who": "ai",
        "sub": "aj",
        "div": "ak",
        "to": "al"
      },
      "changes": [
        "Renamed 38 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_233",
      "transformed_id": "ss_l2_short_nc_ds_233",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.9;\n\nlibrary Deck {\n\n\n\tfunction am(address aa, uint8 q) internal returns (uint8) {\n\t\tuint b = block.number;\n\t\tuint timestamp = block.timestamp;\n\t\treturn uint8(uint256(u(block.blockhash(b), aa, q, timestamp)) % 52);\n\t}\n\n\tfunction z(uint8 an, bool x) internal constant returns (uint8) {\n\t\tuint8 value = an / 4;\n\t\tif (value == 0 || value == 11 || value == 12) {\n\t\t\treturn 10;\n\t\t}\n\t\tif (value == 1 && x) {\n\t\t\treturn 11;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction ai(uint8 an) internal constant returns (bool) {\n\t\treturn an / 4 == 1;\n\t}\n\n\tfunction al(uint8 an) internal constant returns (bool) {\n\t\treturn an / 4 == 10;\n\t}\n}\n\ncontract BlackJack {\n\tusing Deck for *;\n\n\tuint public ab = 50 finney;\n\tuint public ac = 5 ether;\n\n\tuint8 BLACKJACK = 21;\n\n  enum GameState { Ongoing, Player, Tie, House }\n\n\tstruct Game {\n\t\taddress aa;\n\t\tuint ap;\n\n\t\tuint8[] s;\n\t\tuint8[] n;\n\n\t\tGameState ah;\n\t\tuint8 o;\n\t}\n\n\tmapping (address => Game) public af;\n\n\tmodifier h() {\n\t\tif (af[msg.sender].aa == 0 || af[msg.sender].ah != GameState.Ongoing) {\n\t\t\tthrow;\n\t\t}\n\t\t_;\n\t}\n\n\tevent Deal(\n        bool ad,\n        uint8 ag\n    );\n\n    event GameStatus(\n    \tuint8 t,\n    \tuint8 i,\n    \tuint8 m,\n    \tuint8 e\n    );\n\n    event Log(\n    \tuint8 value\n    );\n\n\tfunction BlackJack() {\n\n\t}\n\n\tfunction () payable {\n\n\t}\n\n\n\tfunction am() public payable {\n\t\tif (af[msg.sender].aa != 0 && af[msg.sender].ah == GameState.Ongoing) {\n\t\t\tthrow;\n\t\t}\n\n\t\tif (msg.value < ab || msg.value > ac) {\n\t\t\tthrow;\n\t\t}\n\n\t\tuint8[] memory s = new uint8[](1);\n\t\tuint8[] memory n = new uint8[](2);\n\n\n\t\tn[0] = Deck.am(msg.sender, 0);\n\t\tDeal(true, n[0]);\n\t\ts[0] = Deck.am(msg.sender, 1);\n\t\tDeal(false, s[0]);\n\t\tn[1] = Deck.am(msg.sender, 2);\n\t\tDeal(true, n[1]);\n\n\t\taf[msg.sender] = Game({\n\t\t\taa: msg.sender,\n\t\t\tap: msg.value,\n\t\t\ts: s,\n\t\t\tn: n,\n\t\t\tah: GameState.Ongoing,\n\t\t\to: 3\n\t\t});\n\n\t\tc(af[msg.sender], false);\n\t}\n\n\n\tfunction aq() public h {\n\t\tuint8 w = af[msg.sender].o;\n\t\taf[msg.sender].n.push(Deck.am(msg.sender, w));\n\t\taf[msg.sender].o = w + 1;\n\t\tDeal(true, af[msg.sender].n[af[msg.sender].n.length - 1]);\n\t\tc(af[msg.sender], false);\n\t}\n\n\n\tfunction ae() public h {\n\n\t\tvar (t, i) = d(af[msg.sender].s);\n\n\t\twhile (i < 17) {\n\t\t\tuint8 w = af[msg.sender].o;\n\t\t\tuint8 y = Deck.am(msg.sender, w);\n\t\t\taf[msg.sender].s.push(y);\n\t\t\taf[msg.sender].o = w + 1;\n\t\t\ti += Deck.z(y, true);\n\t\t\tDeal(false, y);\n\t\t}\n\n\t\tc(af[msg.sender], true);\n\t}\n\n\n\tfunction c(Game ao, bool r) private {\n\n\t\tvar (t, i) = d(ao.s);\n\n\t\tvar (m, e) = d(ao.n);\n\n\t\tGameStatus(t, i, m, e);\n\n\t\tif (i == BLACKJACK || t == BLACKJACK) {\n\t\t\tif (m == BLACKJACK || e == BLACKJACK) {\n\n\t\t\t\tif (!msg.sender.send(ao.ap)) throw;\n\t\t\t\taf[msg.sender].ah = GameState.Tie;\n\t\t\t\treturn;\n\t\t\t} else {\n\n\t\t\t\taf[msg.sender].ah = GameState.House;\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (m == BLACKJACK || e == BLACKJACK) {\n\n\t\t\t\tif (ao.n.length == 2 && (Deck.al(ao.n[0]) || Deck.al(ao.n[1]))) {\n\n\t\t\t\t\tif (!msg.sender.send((ao.ap * 5) / 2)) throw;\n\t\t\t\t} else {\n\n\t\t\t\t\tif (!msg.sender.send(ao.ap * 2)) throw;\n\t\t\t\t}\n\t\t\t\taf[msg.sender].ah = GameState.Player;\n\t\t\t\treturn;\n\t\t\t} else {\n\n\t\t\t\tif (m > BLACKJACK) {\n\n\t\t\t\t\tLog(1);\n\t\t\t\t\taf[msg.sender].ah = GameState.House;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!r) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\t\t\t\tuint8 f = 0;\n\t\t\t\tuint8 j = 0;\n\n\n\t\t\t\tif (e > BLACKJACK) {\n\t\t\t\t\tif (m > BLACKJACK) {\n\n\t\t\t\t\t\taf[msg.sender].ah = GameState.House;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tf = BLACKJACK - m;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tf = BLACKJACK - e;\n\t\t\t\t}\n\n\t\t\t\tif (i > BLACKJACK) {\n\t\t\t\t\tif (t > BLACKJACK) {\n\n\t\t\t\t\t\tif (!msg.sender.send(ao.ap * 2)) throw;\n\t\t\t\t\t\taf[msg.sender].ah = GameState.Player;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tj = BLACKJACK - t;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tj = BLACKJACK - i;\n\t\t\t\t}\n\n\n\t\t\t\tif (j == f) {\n\n\t\t\t\t\tif (!msg.sender.send(ao.ap)) throw;\n\t\t\t\t\taf[msg.sender].ah = GameState.Tie;\n\t\t\t\t} else if (j > f) {\n\n\t\t\t\t\tif (!msg.sender.send(ao.ap * 2)) throw;\n\t\t\t\t\taf[msg.sender].ah = GameState.Player;\n\t\t\t\t} else {\n\t\t\t\t\taf[msg.sender].ah = GameState.House;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction d(uint8[] aj) private constant returns (uint8, uint8) {\n\t\tuint8 ak = 0;\n\t\tuint8 v = 0;\n\t\tbool p = false;\n\t\tfor (uint i = 0; i < aj.length; ++i) {\n\t\t\tuint8 an = aj[i];\n\t\t\tif (Deck.ai(an) && !p) {\n\t\t\t\tv += Deck.z(an, true);\n\t\t\t\tp = true;\n\t\t\t} else {\n\t\t\t\tv += Deck.z(an, false);\n\t\t\t}\n\t\t\tak += Deck.z(an, false);\n\t\t}\n\t\treturn (ak, v);\n\t}\n\n\tfunction g(uint8 ar) public h constant returns(uint8) {\n\t\tif (ar < 0 || ar > af[msg.sender].n.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn af[msg.sender].n[ar];\n\t}\n\n\tfunction k(uint8 ar) public h constant returns(uint8) {\n\t\tif (ar < 0 || ar > af[msg.sender].s.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn af[msg.sender].s[ar];\n\t}\n\n\tfunction a() public h constant returns(uint) {\n\t\treturn af[msg.sender].n.length;\n\t}\n\n\tfunction b() public h constant returns(uint) {\n\t\treturn af[msg.sender].s.length;\n\t}\n\n\tfunction l() public constant returns (uint8) {\n\t\tif (af[msg.sender].aa == 0) {\n\t\t\tthrow;\n\t\t}\n\n\t\tGame ao = af[msg.sender];\n\n\t\tif (ao.ah == GameState.Player) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (ao.ah == GameState.House) {\n\t\t\treturn 2;\n\t\t}\n\t\tif (ao.ah == GameState.Tie) {\n\t\t\treturn 3;\n\t\t}\n\n\t\treturn 0;\n\t}\n\n}",
      "rename_map": {
        "getPlayerCardsNumber": "a",
        "getHouseCardsNumber": "b",
        "checkGameResult": "c",
        "calculateScore": "d",
        "playerScoreBig": "e",
        "playerShortage": "f",
        "getPlayerCard": "g",
        "gameIsGoingOn": "h",
        "houseScoreBig": "i",
        "houseShortage": "j",
        "getHouseCard": "k",
        "getGameState": "l",
        "playerScore": "m",
        "playerCards": "n",
        "cardsDealt": "o",
        "bigAceUsed": "p",
        "cardNumber": "q",
        "finishGame": "r",
        "houseCards": "s",
        "houseScore": "t",
        "keccak256": "u",
        "scoreBig": "v",
        "nextCard": "w",
        "isBigAce": "x",
        "newCard": "y",
        "valueOf": "z",
        "player": "aa",
        "minBet": "ab",
        "maxBet": "ac",
        "isUser": "ad",
        "stand": "ae",
        "games": "af",
        "_card": "ag",
        "state": "ah",
        "isAce": "ai",
        "cards": "aj",
        "score": "ak",
        "isTen": "al",
        "deal": "am",
        "card": "an",
        "game": "ao",
        "bet": "ap",
        "hit": "aq",
        "id": "ar"
      },
      "changes": [
        "Renamed 44 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_ds_234",
      "transformed_id": "ss_l2_short_nc_ds_234",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.13;\n\nlibrary SafeMath {\n  function dq(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n  function dn(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint public ad;\n  address public db;\n  address public bf;\n  function be(address dp) constant returns (uint);\n  function transfer(address dv, uint value);\n  event Transfer(address indexed from, address indexed dv, uint value);\n  function n(address dp) internal;\n}\n\ncontract ERC20 is ERC20Basic {\n  function bb(address db, address by) constant returns (uint);\n  function aa(address from, address dv, uint value);\n  function cc(address by, uint value);\n  event Approval(address indexed db, address indexed by, uint value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n  mapping(address => uint) bm;\n\n  modifier h(uint df) {\n     assert(msg.data.length >= df + 4);\n     _;\n  }\n\n  function transfer(address ds, uint ci) h(2 * 32) {\n    n(msg.sender);\n    bm[msg.sender] = bm[msg.sender].dq(ci);\n    if(ds == address(this)) {\n        n(db);\n        bm[db] = bm[db].dn(ci);\n        Transfer(msg.sender, db, ci);\n    }\n    else {\n        n(ds);\n        bm[ds] = bm[ds].dn(ci);\n        Transfer(msg.sender, ds, ci);\n    }\n  }\n\n  function be(address cg) constant returns (uint balance) {\n    return bm[cg];\n  }\n}\n\ncontract StandardToken is BasicToken, ERC20 {\n  mapping (address => mapping (address => uint)) cb;\n\n  function aa(address ct, address ds, uint ci) h(3 * 32) {\n    var ai = cb[ct][msg.sender];\n    n(ct);\n    n(ds);\n    bm[ds] = bm[ds].dn(ci);\n    bm[ct] = bm[ct].dq(ci);\n    cb[ct][msg.sender] = ai.dq(ci);\n    Transfer(ct, ds, ci);\n  }\n\n  function cc(address bl, uint ci) {\n\n    assert(!((ci != 0) && (cb[msg.sender][bl] != 0)));\n    cb[msg.sender][bl] = ci;\n    Approval(msg.sender, bl, ci);\n  }\n\n  function bb(address cg, address bl) constant returns (uint av) {\n    return cb[cg][bl];\n  }\n}\n\ncontract SmartBillions is StandardToken {\n\n\n    string public constant dd = \"SmartBillions Token\";\n    string public constant cq = \"PLAY\";\n    uint public constant bn = 0;\n\n\n    struct Wallet {\n        uint208 balance;\n    \tuint16 a;\n    \tuint32 d;\n    }\n    mapping (address => Wallet) br;\n    struct Bet {\n        uint192 value;\n        uint32 ce;\n        uint32 bo;\n    }\n    mapping (address => Bet) de;\n\n    uint public r = 0;\n\n\n    uint public ag = 1;\n    uint public s = 0;\n    uint public f = 200000 ether;\n    uint public m = 1;\n    uint[] public ar;\n\n\n    uint public co = 0;\n    uint public bc = 0;\n    uint public bh = 0;\n    uint public bj = 0;\n    uint public al = 0;\n    uint public aj = 5 ether;\n    uint[] public cp;\n\n\n    uint public constant an = 16384 ;\n    uint public q = 0 ;\n\n\n    event LogBet(address indexed cr, uint bx, uint ah, uint bs);\n    event LogLoss(address indexed cr, uint bx, uint dg);\n    event LogWin(address indexed cr, uint bx, uint dg, uint cx);\n    event LogInvestment(address indexed bq, address indexed cd, uint cf);\n    event LogRecordWin(address indexed cr, uint cf);\n    event LogLate(address indexed cr,uint e,uint b);\n    event LogDividend(address indexed bq, uint cf, uint cm);\n\n    modifier at() {\n        assert(msg.sender == db);\n        _;\n    }\n\n    modifier ab() {\n        assert(msg.sender == bf);\n        _;\n    }\n\n\n    function SmartBillions() {\n        db = msg.sender;\n        bf = msg.sender;\n        br[db].a = uint16(m);\n        ar.push(0);\n        ar.push(0);\n    }\n\n\n    function v() constant external returns (uint) {\n        return uint(cp.length);\n    }\n\n    function k(address cg) constant external returns (uint) {\n        return uint(br[cg].balance);\n    }\n\n    function l(address cg) constant external returns (uint) {\n        return uint(br[cg].a);\n    }\n\n    function t(address cg) constant external returns (uint) {\n        return uint(br[cg].d);\n    }\n\n    function ao(address cg) constant external returns (uint) {\n        return uint(de[cg].value);\n    }\n\n    function az(address cg) constant external returns (uint) {\n        return uint(de[cg].ce);\n    }\n\n    function g(address cg) constant external returns (uint) {\n        return uint(de[cg].bo);\n    }\n\n    function i() constant external returns (uint) {\n        if(ag > 0) {\n            return(0);\n        }\n        uint cm = (block.number - bc) / (10 * an);\n        if(cm > m) {\n            return(0);\n        }\n        return((10 * an) - ((block.number - bc) % (10 * an)));\n    }\n\n\n    function ae(address di) external at {\n        assert(di != address(0));\n        n(msg.sender);\n        n(di);\n        db = di;\n    }\n\n    function o(address di) external ab {\n        assert(di != address(0));\n        n(msg.sender);\n        n(di);\n        bf = di;\n    }\n\n    function p(uint cu) external at {\n        require(ag == 1 && bc > 0 && block.number < cu);\n        ag = cu;\n    }\n\n    function bd(uint ca) external at {\n        aj = ca;\n    }\n\n    function bk() external at {\n        bj = block.number + 3;\n        al = 0;\n    }\n\n    function ax(uint bz) external at {\n        w();\n        require(bz > 0 && this.balance >= (s * 9 / 10) + r + bz);\n        if(s >= f / 2){\n            require((bz <= this.balance / 400) && q + 4 * 60 * 24 * 7 <= block.number);\n        }\n        msg.sender.transfer(bz);\n        q = block.number;\n    }\n\n    function bg() payable external {\n        w();\n    }\n\n\n    function w() public {\n        if(ag > 1 && block.number >= ag + (an * 5)){\n            ag = 0;\n        }\n        else {\n            if(bc > 0){\n\t\t        uint cm = (block.number - bc) / (10 * an );\n                if(cm > ar.length - 2) {\n                    ar.push(0);\n                }\n                if(cm > m && ag == 0 && m < ar.length - 1) {\n                    m++;\n                }\n            }\n        }\n    }\n\n\n    function ay() public {\n        if(br[msg.sender].balance > 0 && br[msg.sender].d <= block.number){\n            uint balance = br[msg.sender].balance;\n            br[msg.sender].balance = 0;\n            r -= balance;\n            dm(balance);\n        }\n    }\n\n    function dm(uint bz) private {\n        uint ck = this.balance / 2;\n        if(ck >= bz) {\n            msg.sender.transfer(bz);\n            if(bz > 1 finney) {\n                w();\n            }\n        }\n        else {\n            uint af = bz - ck;\n            r += af;\n            br[msg.sender].balance += uint208(af);\n            br[msg.sender].d = uint32(block.number + 4 * 60 * 24 * 30);\n            msg.sender.transfer(ck);\n        }\n    }\n\n\n    function z() payable external {\n        cn(db);\n    }\n\n    function cn(address bi) payable public {\n\n        require(ag > 1 && block.number < ag + (an * 5) && s < f);\n        uint au = msg.value;\n        if(au > f - s) {\n            au = f - s;\n            s = f;\n            ag = 0;\n            msg.sender.transfer(msg.value.dq(au));\n        }\n        else{\n            s += au;\n        }\n        if(bi == address(0) || bi == db){\n            r += au / 10;\n            br[db].balance += uint208(au / 10);}\n        else{\n            r += (au * 5 / 100) * 2;\n            br[db].balance += uint208(au * 5 / 100);\n            br[bi].balance += uint208(au * 5 / 100);}\n        br[msg.sender].a = uint16(m);\n        uint u = au / 10**15;\n        uint ac = au * 16 / 10**17  ;\n        uint j = au * 10 / 10**17  ;\n        bm[msg.sender] += u;\n        bm[db] += ac ;\n        bm[bf] += j ;\n        ad += u + ac + j;\n        Transfer(address(0),msg.sender,u);\n        Transfer(address(0),db,ac);\n        Transfer(address(0),bf,j);\n        LogInvestment(msg.sender,bi,au);\n    }\n\n    function ba() external {\n        require(ag == 0);\n        n(msg.sender);\n        uint c = bm[msg.sender] * 10**15;\n        Transfer(msg.sender,address(0),bm[msg.sender]);\n        delete bm[msg.sender];\n        s -= c;\n        br[msg.sender].balance += uint208(c * 9 / 10);\n        ay();\n    }\n\n    function x() external {\n        require(ag == 0);\n        n(msg.sender);\n        ay();\n    }\n\n    function n(address di) internal {\n        uint dj = br[di].a;\n        if((bm[di]==0) || (dj==0)){\n            br[di].a=uint16(m);\n            return;\n        }\n        if(dj==m) {\n            return;\n        }\n        uint cs = bm[di] * 0xffffffff / ad;\n        uint balance = 0;\n        for(;dj<m;dj++) {\n            balance += cs * ar[dj];\n        }\n        balance = (balance / 0xffffffff);\n        r += balance;\n        br[di].balance += uint208(balance);\n        br[di].a = uint16(dj);\n        LogDividend(di,balance,dj);\n    }\n\n\n    function bp(Bet bt, uint24 cv) constant private returns (uint) {\n        uint24 bx = uint24(bt.ce);\n        uint24 do = bx ^ cv;\n        uint24 bv =\n            ((do & 0xF) == 0 ? 1 : 0 ) +\n            ((do & 0xF0) == 0 ? 1 : 0 ) +\n            ((do & 0xF00) == 0 ? 1 : 0 ) +\n            ((do & 0xF000) == 0 ? 1 : 0 ) +\n            ((do & 0xF0000) == 0 ? 1 : 0 ) +\n            ((do & 0xF00000) == 0 ? 1 : 0 );\n        if(bv == 6){\n            return(uint(bt.value) * 7000000);\n        }\n        if(bv == 5){\n            return(uint(bt.value) * 20000);\n        }\n        if(bv == 4){\n            return(uint(bt.value) * 500);\n        }\n        if(bv == 3){\n            return(uint(bt.value) * 25);\n        }\n        if(bv == 2){\n            return(uint(bt.value) * 3);\n        }\n        return(0);\n    }\n\n    function cz(address di) constant external returns (uint)  {\n        Bet memory cr = de[di];\n        if( (cr.value==0) ||\n            (cr.bo<=1) ||\n            (block.number<cr.bo) ||\n            (block.number>=cr.bo + (10 * an))){\n            return(0);\n        }\n        if(block.number<cr.bo+256){\n            return(bp(cr,uint24(block.blockhash(cr.bo))));\n        }\n        if(bc>0){\n            uint32 dg = bu(cr.bo);\n            if(dg == 0x1000000) {\n                return(uint(cr.value));\n            }\n            else{\n                return(bp(cr,uint24(dg)));\n            }\n\t}\n        return(0);\n    }\n\n    function dt() public {\n        Bet memory cr = de[msg.sender];\n        if(cr.bo==0){\n            de[msg.sender] = Bet({value: 0, ce: 0, bo: 1});\n            return;\n        }\n        if((cr.value==0) || (cr.bo==1)){\n            ay();\n            return;\n        }\n        require(block.number>cr.bo);\n        if(cr.bo + (10 * an) <= block.number){\n            LogLate(msg.sender,cr.bo,block.number);\n            de[msg.sender] = Bet({value: 0, ce: 0, bo: 1});\n            return;\n        }\n        uint cx = 0;\n        uint32 dg = 0;\n        if(block.number<cr.bo+256){\n            dg = uint24(block.blockhash(cr.bo));\n            cx = bp(cr,uint24(dg));\n        }\n        else {\n            if(bc>0){\n                dg = bu(cr.bo);\n                if(dg == 0x1000000) {\n                    cx = uint(cr.value);\n                }\n                else{\n                    cx = bp(cr,uint24(dg));\n                }\n\t    }\n            else{\n                LogLate(msg.sender,cr.bo,block.number);\n                de[msg.sender] = Bet({value: 0, ce: 0, bo: 1});\n                return();\n            }\n        }\n        de[msg.sender] = Bet({value: 0, ce: 0, bo: 1});\n        if(cx>0) {\n            LogWin(msg.sender,uint(cr.ce),uint(dg),cx);\n            if(cx > co){\n                co = cx;\n                LogRecordWin(msg.sender,cx);\n            }\n            dm(cx);\n        }\n        else{\n            LogLoss(msg.sender,uint(cr.ce),uint(dg));\n        }\n    }\n\n    function () payable external {\n        if(msg.value > 0){\n            if(ag>1){\n                cn(db);\n            }\n            else{\n                dh();\n            }\n            return;\n        }\n\n        if(ag == 0 && bm[msg.sender]>0){\n            n(msg.sender);}\n        dt();\n    }\n\n    function dh() payable public returns (uint) {\n        return ap(uint(dk(msg.sender,block.number)), address(0));\n    }\n\n    function ak(address bi) payable public returns (uint) {\n        return ap(uint(dk(msg.sender,block.number)), bi);\n    }\n\n    function ap(uint cv, address bi) payable public returns (uint) {\n        dt();\n        uint24 bx = uint24(cv);\n        require(msg.value <= 1 ether && msg.value < aj);\n        if(msg.value > 0){\n            if(ag==0) {\n                ar[m] += msg.value / 20;\n            }\n            if(bi != address(0)) {\n                uint dr = msg.value / 100;\n                r += dr;\n                br[bi].balance += uint208(dr);\n            }\n            if(bj < block.number + 3) {\n                bj = block.number + 3;\n                al = msg.value;\n            }\n            else{\n                if(al > aj) {\n                    bj++;\n                    al = msg.value;\n                }\n                else{\n                    al += msg.value;\n                }\n            }\n            de[msg.sender] = Bet({value: uint192(msg.value), ce: uint32(bx), bo: uint32(bj)});\n            LogBet(msg.sender,uint(bx),bj,msg.value);\n        }\n        bw();\n        return(bj);\n    }\n\n\n    function aq(uint cy) public returns (uint) {\n        require(bc == 0 && cy > 0 && cy <= an);\n        uint n = cp.length;\n        if(n + cy > an){\n            cp.length = an;\n        }\n        else{\n            cp.length += cy;\n        }\n        for(;n<cp.length;n++){\n            cp[n] = 1;\n        }\n        if(cp.length>=an) {\n            bc = block.number - ( block.number % 10);\n            bh = bc;\n        }\n        return(cp.length);\n    }\n\n    function y() external returns (uint) {\n        return(aq(128));\n    }\n\n    function am(uint32 ch, uint32 cl) constant private returns (uint) {\n        return( ( uint(block.blockhash(ch  )) & 0xFFFFFF )\n            | ( ( uint(block.blockhash(ch+1)) & 0xFFFFFF ) << 24 )\n            | ( ( uint(block.blockhash(ch+2)) & 0xFFFFFF ) << 48 )\n            | ( ( uint(block.blockhash(ch+3)) & 0xFFFFFF ) << 72 )\n            | ( ( uint(block.blockhash(ch+4)) & 0xFFFFFF ) << 96 )\n            | ( ( uint(block.blockhash(ch+5)) & 0xFFFFFF ) << 120 )\n            | ( ( uint(block.blockhash(ch+6)) & 0xFFFFFF ) << 144 )\n            | ( ( uint(block.blockhash(ch+7)) & 0xFFFFFF ) << 168 )\n            | ( ( uint(block.blockhash(ch+8)) & 0xFFFFFF ) << 192 )\n            | ( ( uint(block.blockhash(ch+9)) & 0xFFFFFF ) << 216 )\n            | ( ( uint(cl) / an) << 240));\n    }\n\n    function bu(uint cj) constant private returns (uint32) {\n        uint dc = (cj - bc) / 10;\n        uint dg = cp[dc % an];\n        if(dc / an != dg >> 240) {\n            return(0x1000000);\n        }\n        uint da = (cj - bc) % 10;\n        return(uint32((dg >> (24 * da)) & 0xFFFFFF));\n    }\n\n    function bw() public returns (bool) {\n        uint cw = bh;\n        if(cw == 0 || block.number <= cw + 10) {\n            return(false);\n        }\n        uint as;\n        if(block.number<256) {\n            as = 0;\n        }\n        else{\n            as = block.number - 256;\n        }\n        if(cw < as) {\n            uint du = as;\n            du += du % 10;\n            cw = du;\n        }\n        uint dc = (cw - bc) / 10;\n        cp[dc % an] = am(uint32(cw),uint32(dc));\n        bh = cw + 10;\n        return(true);\n    }\n\n    function aw(uint dl) external {\n        uint n=0;\n        for(;n<dl;n++){\n            if(!bw()){\n                return;\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "lastDividendPeriod": "a",
        "currentBlockNumber": "b",
        "initialInvestment": "c",
        "nextWithdrawBlock": "d",
        "playerBlockNumber": "e",
        "investBalanceMax": "f",
        "betBlockNumberOf": "g",
        "onlyPayloadSize": "h",
        "dividendsBlocks": "i",
        "animatorBalance": "j",
        "walletBalanceOf": "k",
        "walletPeriodOf": "l",
        "dividendPeriod": "m",
        "commitDividend": "n",
        "changeAnimator": "o",
        "setInvestStart": "p",
        "coldStoreLast": "q",
        "walletBalance": "r",
        "investBalance": "s",
        "walletBlockOf": "t",
        "senderBalance": "u",
        "hashesLength": "v",
        "houseKeeping": "w",
        "payDividends": "x",
        "addHashes128": "y",
        "investDirect": "z",
        "transferFrom": "aa",
        "onlyAnimator": "ab",
        "ownerBalance": "ac",
        "totalSupply": "ad",
        "changeOwner": "ae",
        "keepbalance": "af",
        "investStart": "ag",
        "blocknumber": "ah",
        "_allowance": "ai",
        "hashBetMax": "aj",
        "playRandom": "ak",
        "hashBetSum": "al",
        "calcHashes": "am",
        "hashesSize": "an",
        "betValueOf": "ao",
        "playSystem": "ap",
        "addHashes": "aq",
        "dividends": "ar",
        "blockn256": "as",
        "onlyOwner": "at",
        "investing": "au",
        "remaining": "av",
        "putHashes": "aw",
        "coldStore": "ax",
        "payWallet": "ay",
        "betHashOf": "az",
        "disinvest": "ba",
        "allowance": "bb",
        "hashFirst": "bc",
        "setBetMax": "bd",
        "balanceOf": "be",
        "animator": "bf",
        "hotStore": "bg",
        "hashLast": "bh",
        "_partner": "bi",
        "hashNext": "bj",
        "resetBet": "bk",
        "_spender": "bl",
        "balances": "bm",
        "decimals": "bn",
        "blockNum": "bo",
        "betPrize": "bp",
        "investor": "bq",
        "wallets": "br",
        "betsize": "bs",
        "_player": "bt",
        "getHash": "bu",
        "matches": "bv",
        "putHash": "bw",
        "bethash": "bx",
        "spender": "by",
        "_amount": "bz",
        "_maxsum": "ca",
        "allowed": "cb",
        "approve": "cc",
        "partner": "cd",
        "betHash": "ce",
        "amount": "cf",
        "_owner": "cg",
        "_lastb": "ch",
        "_value": "ci",
        "_block": "cj",
        "maxpay": "ck",
        "_delta": "cl",
        "period": "cm",
        "invest": "cn",
        "maxWin": "co",
        "hashes": "cp",
        "symbol": "cq",
        "player": "cr",
        "share": "cs",
        "_from": "ct",
        "_when": "cu",
        "_hash": "cv",
        "lastb": "cw",
        "prize": "cx",
        "_sadd": "cy",
        "betOf": "cz",
        "slotp": "da",
        "owner": "db",
        "delta": "dc",
        "name": "dd",
        "bets": "de",
        "size": "df",
        "hash": "dg",
        "play": "dh",
        "_who": "di",
        "last": "dj",
        "sha3": "dk",
        "_num": "dl",
        "pay": "dm",
        "add": "dn",
        "hit": "do",
        "who": "dp",
        "sub": "dq",
        "fee": "dr",
        "_to": "ds",
        "won": "dt",
        "num": "du",
        "to": "dv"
      },
      "changes": [
        "Renamed 126 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_001",
      "transformed_id": "ss_l2_short_nc_gs_001",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": false,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public l = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public d = 1200;\n    uint256 public a = 300;\n\n\n    uint256 public bk = 100;\n    uint256 public constant MIN_WITHDRAW_FEE = 10;\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant BASIS = 10000;\n    address public Team;\n    uint256 public dp;\n    uint256 public dg;\n    uint256 public bl;\n\n    struct UserLock {\n        uint256 dq;\n        uint256 by;\n    }\n\n    mapping(address => UserLock[]) public cr;\n    mapping(address => uint256) public ai;\n\n\n    address public immutable HYBR;\n    address public immutable at;\n    address public eb;\n    address public k;\n    address public bb;\n    uint256 public co;\n\n\n    address public cx;\n    uint256 public aq;\n\n\n    uint256 public ad;\n    uint256 public p;\n\n\n    ISwapper public do;\n\n\n    error NOT_AUTHORIZED();\n\n\n    event Deposit(address indexed em, uint256 ce, uint256 ag);\n    event Withdraw(address indexed em, uint256 dt, uint256 ce, uint256 eq);\n    event Compound(uint256 dm, uint256 af);\n    event PenaltyRewardReceived(uint256 dq);\n    event TransferLockPeriodUpdated(uint256 cj, uint256 cq);\n    event SwapperUpdated(address indexed bx, address indexed bw);\n    event VoterSet(address eb);\n    event EmergencyUnlock(address indexed em);\n    event AutoVotingEnabled(bool di);\n    event OperatorUpdated(address indexed bt, address indexed bq);\n    event DefaultVotingStrategyUpdated(address[] ec, uint256[] dd);\n    event AutoVoteExecuted(uint256 ei, address[] ec, uint256[] dd);\n\n    constructor(\n        address ee,\n        address ak\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(ee != address(0), \"Invalid HYBR\");\n        require(ak != address(0), \"Invalid VE\");\n\n        HYBR = ee;\n        at = ak;\n        ad = block.timestamp;\n        p = block.timestamp;\n        cx = msg.sender;\n    }\n\n    function f(address j) external cn {\n        require(j != address(0), \"Invalid rewards distributor\");\n        k = j;\n    }\n\n    function x(address ar) external cn {\n        require(ar != address(0), \"Invalid gauge manager\");\n        bb = ar;\n    }\n\n\n    modifier av() {\n        if (msg.sender != cx) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n\n    function df(uint256 dq, address cl) external ax {\n        require(dq > 0, \"Zero amount\");\n        cl = cl == address(0) ? msg.sender : cl;\n\n\n        IERC20(HYBR).bc(msg.sender, address(this), dq);\n\n\n        if (co == 0) {\n            q(dq);\n        } else {\n\n            IERC20(HYBR).dl(at, dq);\n            IVotingEscrow(at).bh(co, dq);\n\n\n            o();\n        }\n\n\n        uint256 dt = aa(dq);\n\n\n        ek(cl, dt);\n\n\n        t(cl, dt);\n\n        emit Deposit(msg.sender, dq, dt);\n    }\n\n\n    function cz(uint256 dt) external ax returns (uint256 br) {\n        require(dt > 0, \"Zero shares\");\n        require(ct(msg.sender) >= dt, \"Insufficient balance\");\n        require(co != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(at).ea(co) == false, \"Cannot withdraw yet\");\n\n        uint256 cb = HybraTimeLibrary.cb(block.timestamp);\n        uint256 ch = HybraTimeLibrary.ch(block.timestamp);\n\n        require(block.timestamp >= cb + d && block.timestamp < ch - a, \"Cannot withdraw yet\");\n\n\n        uint256 ce = z(dt);\n        require(ce > 0, \"No assets to withdraw\");\n\n\n        uint256 cp = 0;\n        if (bk > 0) {\n            cp = (ce * bk) / BASIS;\n        }\n\n\n        uint256 bz = ce - cp;\n        require(bz > 0, \"Amount too small after fee\");\n\n\n        uint256 ck = bg();\n        require(ce <= ck, \"Insufficient veNFT balance\");\n\n        uint256 w = ck - bz - cp;\n        require(w >= 0, \"Cannot withdraw entire veNFT\");\n\n\n        el(msg.sender, dt);\n\n\n        uint256[] memory dn = new uint256[](3);\n        dn[0] = w;\n        dn[1] = bz;\n        dn[2] = cp;\n\n        uint256[] memory bm = IVotingEscrow(at).cf(co, dn);\n\n\n        co = bm[0];\n        br = bm[1];\n        uint256 bv = bm[2];\n\n        IVotingEscrow(at).r(address(this), msg.sender, br);\n        IVotingEscrow(at).r(address(this), Team, bv);\n        emit Withdraw(msg.sender, dt, bz, cp);\n    }\n\n\n    function q(uint256 ap) internal {\n\n        IERC20(HYBR).dl(at, type(uint256).ep);\n        uint256 cw = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n\n        co = IVotingEscrow(at).y(ap, cw, address(this));\n\n    }\n\n\n    function aa(uint256 dq) public view returns (uint256) {\n        uint256 aw = bf();\n        uint256 au = bg();\n        if (aw == 0 || au == 0) {\n            return dq;\n        }\n        return (dq * aw) / au;\n    }\n\n\n    function z(uint256 dt) public view returns (uint256) {\n        uint256 aw = bf();\n        if (aw == 0) {\n            return dt;\n        }\n        return (dt * bg()) / aw;\n    }\n\n\n    function bg() public view returns (uint256) {\n        if (co == 0) {\n            return 0;\n        }\n\n        IVotingEscrow.LockedBalance memory dw = IVotingEscrow(at).dw(co);\n        return uint256(int256(dw.dq));\n    }\n\n\n    function t(address em, uint256 dq) internal {\n        uint256 by = block.timestamp + l;\n        cr[em].push(UserLock({\n            dq: dq,\n            by: by\n        }));\n        ai[em] += dq;\n    }\n\n\n    function s(address em) external view returns (uint256 cs) {\n        uint256 bd = ct(em);\n        uint256 an = 0;\n\n        UserLock[] storage er = cr[em];\n        for (uint256 i = 0; i < er.length; i++) {\n            if (er[i].by > block.timestamp) {\n                an += er[i].dq;\n            }\n        }\n\n        return bd > an ? bd - an : 0;\n    }\n\n    function al(address em) internal returns (uint256 dy) {\n        UserLock[] storage er = cr[em];\n        uint256 et = er.length;\n        if (et == 0) return 0;\n\n        uint256 ed = 0;\n        unchecked {\n            for (uint256 i = 0; i < et; i++) {\n                UserLock memory L = er[i];\n                if (L.by <= block.timestamp) {\n                    dy += L.dq;\n                } else {\n                    if (ed != i) er[ed] = L;\n                    ed++;\n                }\n            }\n            if (dy > 0) {\n                ai[em] -= dy;\n            }\n            while (er.length > ed) {\n                er.pop();\n            }\n        }\n    }\n\n\n    function h(\n        address from,\n        address eu,\n        uint256 dq\n    ) internal override {\n        super.h(from, eu, dq);\n\n        if (from != address(0) && eu != address(0)) {\n            uint256 bd = ct(from);\n\n\n            uint256 n = bd > ai[from] ? bd - ai[from] : 0;\n\n\n            if (n >= dq) {\n                return;\n            }\n\n\n            al(from);\n            uint256 ae = bd > ai[from] ? bd - ai[from] : 0;\n\n\n            require(ae >= dq, \"Tokens locked\");\n        }\n    }\n\n\n    function ay() external av {\n        require(eb != address(0), \"Voter not set\");\n        require(k != address(0), \"Distributor not set\");\n\n\n        uint256  as = IRewardsDistributor(k).ef(co);\n        dp += as;\n\n        address[] memory cc = IVoter(eb).db(co);\n\n        for (uint256 i = 0; i < cc.length; i++) {\n            if (cc[i] != address(0)) {\n                address eg = IGaugeManager(bb).dv(cc[i]);\n\n                if (eg != address(0)) {\n\n                    address[] memory dr = new address[](1);\n                    address[][] memory du = new address[][](1);\n\n\n                    address aj = IGaugeManager(bb).u(eg);\n                    if (aj != address(0)) {\n                        uint256 ca = IBribe(aj).m();\n                        if (ca > 0) {\n                            address[] memory bn = new address[](ca);\n                            for (uint256 j = 0; j < ca; j++) {\n                                bn[j] = IBribe(aj).bn(j);\n                            }\n                            dr[0] = aj;\n                            du[0] = bn;\n\n                            IGaugeManager(bb).bo(dr, du, co);\n                        }\n                    }\n\n\n                    address ao = IGaugeManager(bb).ab(eg);\n                    if (ao != address(0)) {\n                        uint256 ca = IBribe(ao).m();\n                        if (ca > 0) {\n                            address[] memory bn = new address[](ca);\n                            for (uint256 j = 0; j < ca; j++) {\n                                bn[j] = IBribe(ao).bn(j);\n                            }\n                            dr[0] = ao;\n                            du[0] = bn;\n\n                            IGaugeManager(bb).bo(dr, du, co);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    function bp(ISwapper.SwapParams calldata dk) external ax av {\n        require(address(do) != address(0), \"Swapper not set\");\n\n\n        uint256 az = IERC20(dk.dh).ct(address(this));\n        require(az >= dk.da, \"Insufficient token balance\");\n\n\n        IERC20(dk.dh).bs(address(do), dk.da);\n\n\n        uint256 ba = do.cd(dk);\n\n\n        IERC20(dk.dh).bs(address(do), 0);\n\n\n        bl += ba;\n    }\n\n\n    function dc() external av {\n\n\n        uint256 bu = IERC20(HYBR).ct(address(this));\n\n        if (bu > 0) {\n\n            IERC20(HYBR).bs(at, bu);\n            IVotingEscrow(at).bh(co, bu);\n\n\n            o();\n\n            p = block.timestamp;\n\n            emit Compound(bu, bg());\n        }\n    }\n\n\n    function eo(address[] calldata ci, uint256[] calldata cy) external {\n        require(msg.sender == ej() || msg.sender == cx, \"Not authorized\");\n        require(eb != address(0), \"Voter not set\");\n\n        IVoter(eb).eo(co, ci, cy);\n        aq = HybraTimeLibrary.cb(block.timestamp);\n\n    }\n\n\n    function eh() external {\n        require(msg.sender == ej() || msg.sender == cx, \"Not authorized\");\n        require(eb != address(0), \"Voter not set\");\n\n        IVoter(eb).eh(co);\n    }\n\n\n    function i(uint256 dq) external {\n\n\n        if (dq > 0) {\n            IERC20(HYBR).dl(at, dq);\n\n            if(co == 0){\n                q(dq);\n            } else{\n                IVotingEscrow(at).bh(co, dq);\n\n\n                o();\n            }\n        }\n        dg += dq;\n        emit PenaltyRewardReceived(dq);\n    }\n\n\n    function cu(address ds) external cn {\n        require(ds != address(0), \"Invalid voter\");\n        eb = ds;\n        emit VoterSet(ds);\n    }\n\n\n    function e(uint256 dj) external cn {\n        require(dj >= MIN_LOCK_PERIOD && dj <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 cj = l;\n        l = dj;\n        emit TransferLockPeriodUpdated(cj, dj);\n    }\n\n\n    function ac(uint256 en) external cn {\n        require(en >= MIN_WITHDRAW_FEE && en <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        bk = en;\n    }\n\n    function b(uint256 dz) external cn {\n        d = dz;\n    }\n\n    function c(uint256 dz) external cn {\n        a = dz;\n    }\n\n\n    function cg(address cv) external cn {\n        require(cv != address(0), \"Invalid swapper\");\n        address bx = address(do);\n        do = ISwapper(cv);\n        emit SwapperUpdated(bx, cv);\n    }\n\n\n    function de(address dx) external cn {\n        require(dx != address(0), \"Invalid team\");\n        Team = dx;\n    }\n\n\n    function v(address em) external av {\n        delete cr[em];\n        ai[em] = 0;\n        emit EmergencyUnlock(em);\n    }\n\n\n    function be(address em) external view returns (UserLock[] memory) {\n        return cr[em];\n    }\n\n\n    function bj(address cm) external cn {\n        require(cm != address(0), \"Invalid operator\");\n        address bt = cx;\n        cx = cm;\n        emit OperatorUpdated(bt, cm);\n    }\n\n\n    function ah() external view returns (uint256) {\n        if (co == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory dw = IVotingEscrow(at).dw(co);\n        return uint256(dw.es);\n    }\n\n\n    function o() internal {\n        if (co == 0) return;\n\n        IVotingEscrow.LockedBalance memory dw = IVotingEscrow(at).dw(co);\n        if (dw.bi || dw.es <= block.timestamp) return;\n\n        uint256 am = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n\n        if (am > dw.es + 2 hours) {\n            try IVotingEscrow(at).g(co, HybraTimeLibrary.MAX_LOCK_DURATION) {\n\n            } catch {\n\n\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "tail_not_withdraw_time": "a",
        "setHeadNotWithdrawTime": "b",
        "setTailNotWithdrawTime": "c",
        "head_not_withdraw_time": "d",
        "setTransferLockPeriod": "e",
        "setRewardsDistributor": "f",
        "increase_unlock_time": "g",
        "_beforeTokenTransfer": "h",
        "receivePenaltyReward": "i",
        "_rewardsDistributor": "j",
        "rewardsDistributor": "k",
        "transferLockPeriod": "l",
        "rewardsListLength": "m",
        "currentAvailable": "n",
        "_extendLockToMax": "o",
        "lastCompoundTime": "p",
        "_initializeVeNFT": "q",
        "safeTransferFrom": "r",
        "previewAvailable": "s",
        "_addTransferLock": "t",
        "internal_bribes": "u",
        "emergencyUnlock": "v",
        "remainingAmount": "w",
        "setGaugeManager": "x",
        "create_lock_for": "y",
        "calculateAssets": "z",
        "calculateShares": "aa",
        "external_bribes": "ab",
        "setWithdrawFee": "ac",
        "lastRebaseTime": "ad",
        "finalAvailable": "ae",
        "newTotalLocked": "af",
        "sharesReceived": "ag",
        "getLockEndTime": "ah",
        "lockedBalance": "ai",
        "internalBribe": "aj",
        "_votingEscrow": "ak",
        "_cleanExpired": "al",
        "maxUnlockTime": "am",
        "currentLocked": "an",
        "externalBribe": "ao",
        "initialAmount": "ap",
        "lastVoteEpoch": "aq",
        "_gaugeManager": "ar",
        "rebaseAmount": "as",
        "votingEscrow": "at",
        "_totalAssets": "au",
        "onlyOperator": "av",
        "_totalSupply": "aw",
        "nonReentrant": "ax",
        "claimRewards": "ay",
        "tokenBalance": "az",
        "hybrReceived": "ba",
        "gaugeManager": "bb",
        "transferFrom": "bc",
        "totalBalance": "bd",
        "getUserLocks": "be",
        "totalSupply": "bf",
        "totalAssets": "bg",
        "deposit_for": "bh",
        "isPermanent": "bi",
        "setOperator": "bj",
        "withdrawFee": "bk",
        "votingYield": "bl",
        "newTokenIds": "bm",
        "bribeTokens": "bn",
        "claimBribes": "bo",
        "executeSwap": "bp",
        "newOperator": "bq",
        "userTokenId": "br",
        "safeApprove": "bs",
        "oldOperator": "bt",
        "hybrBalance": "bu",
        "feeTokenId": "bv",
        "newSwapper": "bw",
        "oldSwapper": "bx",
        "unlockTime": "by",
        "userAmount": "bz",
        "tokenCount": "ca",
        "epochStart": "cb",
        "votedPools": "cc",
        "swapToHYBR": "cd",
        "hybrAmount": "ce",
        "multiSplit": "cf",
        "setSwapper": "cg",
        "epochNext": "ch",
        "_poolVote": "ci",
        "oldPeriod": "cj",
        "veBalance": "ck",
        "recipient": "cl",
        "_operator": "cm",
        "onlyOwner": "cn",
        "veTokenId": "co",
        "feeAmount": "cp",
        "newPeriod": "cq",
        "userLocks": "cr",
        "available": "cs",
        "balanceOf": "ct",
        "setVoter": "cu",
        "_swapper": "cv",
        "lockTime": "cw",
        "operator": "cx",
        "_weights": "cy",
        "withdraw": "cz",
        "amountIn": "da",
        "poolVote": "db",
        "compound": "dc",
        "weights": "dd",
        "setTeam": "de",
        "deposit": "df",
        "penalty": "dg",
        "tokenIn": "dh",
        "enabled": "di",
        "_period": "dj",
        "_params": "dk",
        "approve": "dl",
        "rewards": "dm",
        "amounts": "dn",
        "swapper": "do",
        "rebase": "dp",
        "amount": "dq",
        "bribes": "dr",
        "_voter": "ds",
        "shares": "dt",
        "tokens": "du",
        "gauges": "dv",
        "locked": "dw",
        "_team": "dx",
        "freed": "dy",
        "_time": "dz",
        "voted": "ea",
        "voter": "eb",
        "pools": "ec",
        "write": "ed",
        "_HYBR": "ee",
        "claim": "ef",
        "gauge": "eg",
        "reset": "eh",
        "epoch": "ei",
        "owner": "ej",
        "_mint": "ek",
        "_burn": "el",
        "user": "em",
        "_fee": "en",
        "vote": "eo",
        "max": "ep",
        "fee": "eq",
        "arr": "er",
        "end": "es",
        "len": "et",
        "to": "eu"
      },
      "changes": [
        "Renamed 151 identifiers using short style"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 482, column 9', 'Syntax error at line 482, column 12']"
    },
    {
      "original_id": "nc_gs_002",
      "transformed_id": "ss_l2_short_nc_gs_002",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity =0.7.6;\n\nimport \"./interfaces/ICLFactory.sol\";\nimport \"./interfaces/fees/IFeeModule.sol\";\n\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/IFactoryRegistry.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@nomad-xyz/src/ExcessivelySafeCall.sol\";\nimport \"./CLPool.sol\";\n\n\ncontract CLFactory is ICLFactory {\n    using ExcessivelySafeCall for address;\n\n\n    IGaugeManager public override au;\n\n    address public immutable override v;\n\n    address public override bv;\n\n    address public override ak;\n\n    address public override an;\n\n    address public override t;\n\n    address public override ab;\n\n    uint24 public override w;\n\n\n    address public override s;\n\n    address public override aa;\n\n    uint24 public override u;\n\n    mapping(int24 => uint24) public override ac;\n\n    mapping(address => mapping(address => mapping(int24 => address))) public override bi;\n\n    mapping(address => bool) private bg;\n\n    address[] public override bc;\n\n    int24[] private ao;\n\n    constructor(address k) {\n        bv = msg.sender;\n        ak = msg.sender;\n        t = msg.sender;\n        s = msg.sender;\n        v = k;\n        w = 100_000;\n        u = 250_000;\n        emit OwnerChanged(address(0), msg.sender);\n        emit SwapFeeManagerChanged(address(0), msg.sender);\n        emit UnstakedFeeManagerChanged(address(0), msg.sender);\n        emit DefaultUnstakedFeeChanged(0, 100_000);\n\n        y(1, 100);\n        y(50, 500);\n        y(100, 500);\n        y(200, 3_000);\n        y(2_000, 10_000);\n    }\n\n    function af(address ap) external {\n        require(msg.sender == bv);\n        au = IGaugeManager(ap);\n    }\n\n\n    function ax(address br, address bm, int24 aw, uint160 at)\n        external\n        override\n        returns (address bw)\n    {\n        require(br != bm);\n        (address bo, address bu) = br < bm ? (br, bm) : (bm, br);\n        require(bo != address(0));\n        require(ac[aw] != 0);\n        require(bi[bo][bu][aw] == address(0));\n        bw = Clones.x({\n            bs: v,\n            bx: ba(abi.bp(bo, bu, aw))\n        });\n        CLPool(bw).az({\n            bd: address(this),\n            bh: bo,\n            be: bu,\n            ar: aw,\n            ap: address(au),\n            am: at\n        });\n        bc.push(bw);\n        bg[bw] = true;\n        bi[bo][bu][aw] = bw;\n\n        bi[bu][bo][aw] = bw;\n        emit PoolCreated(bo, bu, aw, bw);\n    }\n\n\n    function bb(address bl) external override {\n        address av = bv;\n        require(msg.sender == av);\n        require(bl != address(0));\n        emit OwnerChanged(av, bl);\n        bv = bl;\n    }\n\n\n    function z(address ae) external override {\n        address i = ak;\n        require(msg.sender == i);\n        require(ae != address(0));\n        ak = ae;\n        emit SwapFeeManagerChanged(i, ae);\n    }\n\n\n    function d(address o) external override {\n        address b = t;\n        require(msg.sender == b);\n        require(o != address(0));\n        t = o;\n        emit UnstakedFeeManagerChanged(b, o);\n    }\n\n\n    function ad(address ag) external override {\n        require(msg.sender == ak);\n        require(ag != address(0));\n        address aq = an;\n        an = ag;\n        emit SwapFeeModuleChanged(aq, ag);\n    }\n\n\n    function h(address p) external override {\n        require(msg.sender == t);\n        require(p != address(0));\n        address aq = ab;\n        ab = p;\n        emit UnstakedFeeModuleChanged(aq, p);\n    }\n\n\n    function e(uint24 m) external override {\n        require(msg.sender == t);\n        require(m <= 500_000);\n        uint24 aj = w;\n        w = m;\n        emit DefaultUnstakedFeeChanged(aj, m);\n    }\n\n    function g(address r) external override {\n        require(msg.sender == s);\n        require(r != address(0));\n        aa = r;\n    }\n\n    function f(address j) external override {\n        require(msg.sender == s);\n        require(j != address(0));\n        s = j;\n    }\n\n\n    function ay(address bw) external view override returns (uint24) {\n        if (an != address(0)) {\n            (bool bk, bytes memory data) = an.a(\n                200_000, 32, abi.q(IFeeModule.bt.selector, bw)\n            );\n            if (bk) {\n                uint24 by = abi.bn(data, (uint24));\n                if (by <= 100_000) {\n                    return by;\n                }\n            }\n        }\n        return ac[CLPool(bw).aw()];\n    }\n\n\n    function ah(address bw) external view override returns (uint24) {\n\n        if (!au.l(bw)) {\n            return 0;\n        }\n        if (ab != address(0)) {\n            (bool bk, bytes memory data) = ab.a(\n                200_000, 32, abi.q(IFeeModule.bt.selector, bw)\n            );\n            if (bk) {\n                uint24 by = abi.bn(data, (uint24));\n                if (by <= 1_000_000) {\n                    return by;\n                }\n            }\n        }\n        return w;\n    }\n\n    function ai(address bw) external view override returns (uint24) {\n\n        if (au.l(bw)) {\n            return 0;\n        }\n\n        if (aa != address(0)) {\n            (bool bk, bytes memory data) = aa.a(\n                200_000, 32, abi.q(IFeeModule.bt.selector, bw)\n            );\n            if (bk) {\n                uint24 by = abi.bn(data, (uint24));\n                if (by <= 500_000) {\n                    return by;\n                }\n            }\n        }\n        return u;\n    }\n\n\n    function y(int24 aw, uint24 by) public override {\n        require(msg.sender == bv);\n        require(by > 0 && by <= 100_000);\n\n\n        require(aw > 0 && aw < 16384);\n        require(ac[aw] == 0);\n\n        ac[aw] = by;\n        ao.push(aw);\n        emit TickSpacingEnabled(aw, by);\n    }\n\n    function c() external  {\n        require(msg.sender == bv);\n\n        for (uint256 i = 0; i < bc.length; i++) {\n            CLPool(bc[i]).n(msg.sender);\n        }\n    }\n\n    function n(address bw) external returns (uint128 bj, uint128 bf) {\n        require(msg.sender == bv);\n        (bj, bf) = CLPool(bw).n(msg.sender);\n    }\n\n\n    function as() external view override returns (int24[] memory) {\n        return ao;\n    }\n\n\n    function al() external view override returns (uint256) {\n        return bc.length;\n    }\n\n\n    function bq(address bw) external view override returns (bool) {\n        return bg[bw];\n    }\n}",
      "rename_map": {
        "excessivelySafeStaticCall": "a",
        "cachedUnstakedFeeManager": "b",
        "collectAllProtocolFees": "c",
        "setUnstakedFeeManager": "d",
        "setDefaultUnstakedFee": "e",
        "setProtocolFeeManager": "f",
        "setProtocolFeeModule": "g",
        "setUnstakedFeeModule": "h",
        "cachedSwapFeeManager": "i",
        "_protocolFeeManager": "j",
        "_poolImplementation": "k",
        "isGaugeAliveForPool": "l",
        "_defaultUnstakedFee": "m",
        "collectProtocolFees": "n",
        "_unstakedFeeManager": "o",
        "_unstakedFeeModule": "p",
        "encodeWithSelector": "q",
        "_protocolFeeModule": "r",
        "protocolFeeManager": "s",
        "unstakedFeeManager": "t",
        "defaultProtocolFee": "u",
        "poolImplementation": "v",
        "defaultUnstakedFee": "w",
        "cloneDeterministic": "x",
        "enableTickSpacing": "y",
        "setSwapFeeManager": "z",
        "protocolFeeModule": "aa",
        "unstakedFeeModule": "ab",
        "tickSpacingToFee": "ac",
        "setSwapFeeModule": "ad",
        "_swapFeeManager": "ae",
        "setGaugeManager": "af",
        "_swapFeeModule": "ag",
        "getUnstakedFee": "ah",
        "getProtocolFee": "ai",
        "oldUnstakedFee": "aj",
        "swapFeeManager": "ak",
        "allPoolsLength": "al",
        "_sqrtPriceX96": "am",
        "swapFeeModule": "an",
        "_tickSpacings": "ao",
        "_gaugeManager": "ap",
        "oldFeeModule": "aq",
        "_tickSpacing": "ar",
        "tickSpacings": "as",
        "sqrtPriceX96": "at",
        "gaugeManager": "au",
        "cachedOwner": "av",
        "tickSpacing": "aw",
        "createPool": "ax",
        "getSwapFee": "ay",
        "initialize": "az",
        "keccak256": "ba",
        "setOwner": "bb",
        "allPools": "bc",
        "_factory": "bd",
        "_token1": "be",
        "amount1": "bf",
        "_isPool": "bg",
        "_token0": "bh",
        "getPool": "bi",
        "amount0": "bj",
        "success": "bk",
        "_owner": "bl",
        "tokenB": "bm",
        "decode": "bn",
        "token0": "bo",
        "encode": "bp",
        "isPool": "bq",
        "tokenA": "br",
        "master": "bs",
        "getFee": "bt",
        "token1": "bu",
        "owner": "bv",
        "pool": "bw",
        "salt": "bx",
        "fee": "by"
      },
      "changes": [
        "Renamed 77 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_003",
      "transformed_id": "ss_l2_short_nc_gs_003",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport './interfaces/IPair.sol';\nimport './interfaces/IBribe.sol';\nimport \"./libraries/Math.sol\";\n\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport './interfaces/IRHYBR.sol';\ninterface IRewarder {\n    function be(\n        address cd,\n        address aw,\n        uint256 ak\n    ) external;\n}\n\ncontract GaugeV2 is ReentrancyGuard, Ownable {\n\n    using SafeERC20 for IERC20;\n\n    bool public immutable ba;\n    bool public ax;\n\n    IERC20 public immutable aj;\n    IERC20 public immutable TOKEN;\n    address public immutable ca;\n    address public VE;\n    address public DISTRIBUTION;\n    address public z;\n    address public x;\n    address public u;\n\n    uint256 public DURATION;\n    uint256 internal y;\n    uint256 public as;\n    uint256 public t;\n    uint256 public g;\n\n    mapping(address => uint256) public d;\n    mapping(address => uint256) public bo;\n\n    uint256 internal ac;\n    mapping(address => uint256) internal bc;\n    mapping(address => uint256) public af;\n\n    event RewardAdded(uint256 br);\n    event Deposit(address indexed cd, uint256 bq);\n    event Withdraw(address indexed cd, uint256 bq);\n    event Harvest(address indexed cd, uint256 br);\n\n    event ClaimFees(address indexed from, uint256 bi, uint256 bj);\n    event EmergencyActivated(address indexed cb, uint256 timestamp);\n    event EmergencyDeactivated(address indexed cb, uint256 timestamp);\n\n    modifier ag(address bp) {\n        g = s();\n        t = a();\n        if (bp != address(0)) {\n            bo[bp] = bv(bp);\n            d[bp] = g;\n        }\n        _;\n    }\n\n    modifier l() {\n        require(msg.sender == DISTRIBUTION, \"NA\");\n        _;\n    }\n\n    modifier v() {\n        require(ax == false, \"EMER\");\n        _;\n    }\n\n    constructor(address ab,address bs,address ce,address bt,address aa, address q, address p, bool ao) {\n        aj = IERC20(ab);\n        ca = bs;\n        VE = ce;\n        TOKEN = IERC20(bt);\n        DISTRIBUTION = aa;\n        DURATION = HybraTimeLibrary.WEEK;\n\n        x = q;\n        u = p;\n\n        ba = ao;\n\n        ax = false;\n\n    }\n\n\n    function r(address aa) external ay {\n        require(aa != address(0), \"ZA\");\n        require(aa != DISTRIBUTION, \"SAME_ADDR\");\n        DISTRIBUTION = aa;\n    }\n\n\n    function n(address w) external ay {\n        require(w != z, \"SAME_ADDR\");\n        z = w;\n    }\n\n\n    function m(address cc) external ay {\n        require(cc >= address(0), \"ZA\");\n        x = cc;\n    }\n\n    function e() external ay {\n        require(ax == false, \"EMER\");\n        ax = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function i() external ay {\n\n        require(ax == true,\"EMER\");\n\n        ax = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n\n    function ai() public view returns (uint256) {\n        return ac;\n    }\n\n\n    function bd(address bp) external view returns (uint256) {\n        return ap(bp);\n    }\n\n    function ap(address bp) internal view returns (uint256) {\n\n        return bc[bp];\n    }\n\n\n    function a() public view returns (uint256) {\n        return Math.cf(block.timestamp, y);\n    }\n\n\n    function s() public view returns (uint256) {\n        if (ac == 0) {\n            return g;\n        } else {\n            return g + (a() - t) * as * 1e18 / ac;\n        }\n    }\n\n\n    function bv(address bp) public view returns (uint256) {\n        return bo[bp] + ap(bp) * (s() - d[bp]) / 1e18;\n    }\n\n\n    function k() external view returns (uint256) {\n        return as * DURATION;\n    }\n\n    function ah() external view returns (uint256) {\n        return y;\n    }\n\n\n    function ar() external {\n        bf(TOKEN.bd(msg.sender), msg.sender);\n    }\n\n\n    function bl(uint256 bq) external {\n        bf(bq, msg.sender);\n    }\n\n\n    function bf(uint256 bq, address bp) internal ad v ag(bp) {\n        require(bq > 0, \"ZV\");\n\n        bc[bp] = bc[bp] + bq;\n        ac = ac + bq;\n        if (address(z) != address(0)) {\n            IRewarder(z).be(bp, bp, ap(bp));\n        }\n\n        TOKEN.o(bp, address(this), bq);\n\n        emit Deposit(bp, bq);\n    }\n\n\n    function am() external {\n        bb(ap(msg.sender));\n    }\n\n\n    function bg(uint256 bq) external {\n        bb(bq);\n    }\n\n\n    function bb(uint256 bq) internal ad v ag(msg.sender) {\n        require(bq > 0, \"ZV\");\n        require(ap(msg.sender) > 0, \"ZV\");\n        require(block.timestamp >= af[msg.sender], \"!MATURE\");\n\n        ac = ac - bq;\n        bc[msg.sender] = bc[msg.sender] - bq;\n\n        if (address(z) != address(0)) {\n            IRewarder(z).be(msg.sender, msg.sender,ap(msg.sender));\n        }\n\n        TOKEN.ae(msg.sender, bq);\n\n        emit Withdraw(msg.sender, bq);\n    }\n\n    function j() external ad {\n        require(ax, \"EMER\");\n        uint256 bn = ap(msg.sender);\n        require(bn > 0, \"ZV\");\n        ac = ac - bn;\n\n        bc[msg.sender] = 0;\n\n        TOKEN.ae(msg.sender, bn);\n        emit Withdraw(msg.sender, bn);\n    }\n\n    function b(uint256 bn) external ad {\n\n        require(ax, \"EMER\");\n        ac = ac - bn;\n\n        bc[msg.sender] = bc[msg.sender] - bn;\n\n        TOKEN.ae(msg.sender, bn);\n        emit Withdraw(msg.sender, bn);\n    }\n\n\n    function f(uint8 al) external {\n        bb(ap(msg.sender));\n        at(al);\n    }\n\n\n    function at(address by, uint8 al) public ad l ag(by) {\n        uint256 br = bo[by];\n        if (br > 0) {\n            bo[by] = 0;\n            IERC20(aj).an(ca, br);\n            IRHYBR(ca).c(br);\n            IRHYBR(ca).au(br, al, by);\n            emit Harvest(by, br);\n        }\n\n        if (z != address(0)) {\n            IRewarder(z).be(by, by, ap(by));\n        }\n    }\n\n\n    function at(uint8 al) public ad ag(msg.sender) {\n        uint256 br = bo[msg.sender];\n        if (br > 0) {\n            bo[msg.sender] = 0;\n            IERC20(aj).an(ca, br);\n            IRHYBR(ca).c(br);\n            IRHYBR(ca).au(br, al, msg.sender);\n            emit Harvest(msg.sender, br);\n        }\n\n        if (z != address(0)) {\n            IRewarder(z).be(msg.sender, msg.sender, ap(msg.sender));\n        }\n    }\n\n\n    function h(address bz, uint256 br) external ad v l ag(address(0)) {\n        require(bz == address(aj), \"IA\");\n        aj.o(DISTRIBUTION, address(this), br);\n\n        if (block.timestamp >= y) {\n            as = br / DURATION;\n        } else {\n            uint256 az = y - block.timestamp;\n            uint256 bh = az * as;\n            as = (br + bh) / DURATION;\n        }\n\n\n        uint256 balance = aj.bd(address(this));\n        require(as <= balance / DURATION, \"REWARD_HIGH\");\n\n        t = block.timestamp;\n        y = block.timestamp + DURATION;\n        emit RewardAdded(br);\n    }\n\n    function av() external ad returns (uint256 bi, uint256 bj) {\n        return aq();\n    }\n\n     function aq() internal returns (uint256 bi, uint256 bj) {\n        if (!ba) {\n            return (0, 0);\n        }\n        address bt = address(TOKEN);\n        (bi, bj) = IPair(bt).av();\n        if (bi > 0 || bj > 0) {\n\n            uint256 bu = bi;\n            uint256 bx = bj;\n\n            (address bm, address bk) = IPair(bt).bw();\n\n            if (bu  > 0) {\n                IERC20(bm).an(x, 0);\n                IERC20(bm).an(x, bu);\n                IBribe(x).h(bm, bu);\n            }\n            if (bx  > 0) {\n                IERC20(bk).an(x, 0);\n                IERC20(bk).an(x, bx);\n                IBribe(x).h(bk, bx);\n            }\n            emit ClaimFees(msg.sender, bi, bj);\n        }\n    }\n\n}",
      "rename_map": {
        "lastTimeRewardApplicable": "a",
        "emergencyWithdrawAmount": "b",
        "depostionEmissionsToken": "c",
        "userRewardPerTokenPaid": "d",
        "activateEmergencyMode": "e",
        "withdrawAllAndHarvest": "f",
        "rewardPerTokenStored": "g",
        "notifyRewardAmount": "h",
        "stopEmergencyMode": "i",
        "emergencyWithdraw": "j",
        "rewardForDuration": "k",
        "onlyDistribution": "l",
        "setInternalBribe": "m",
        "setGaugeRewarder": "n",
        "safeTransferFrom": "o",
        "_external_bribe": "p",
        "_internal_bribe": "q",
        "setDistribution": "r",
        "rewardPerToken": "s",
        "lastUpdateTime": "t",
        "external_bribe": "u",
        "isNotEmergency": "v",
        "_gaugeRewarder": "w",
        "internal_bribe": "x",
        "_periodFinish": "y",
        "gaugeRewarder": "z",
        "_distribution": "aa",
        "_rewardToken": "ab",
        "_totalSupply": "ac",
        "nonReentrant": "ad",
        "safeTransfer": "ae",
        "maturityTime": "af",
        "updateReward": "ag",
        "periodFinish": "ah",
        "totalSupply": "ai",
        "rewardToken": "aj",
        "userBalance": "ak",
        "_redeemType": "al",
        "withdrawAll": "am",
        "safeApprove": "an",
        "_isForPair": "ao",
        "_balanceOf": "ap",
        "_claimFees": "aq",
        "depositAll": "ar",
        "rewardRate": "as",
        "getReward": "at",
        "redeemFor": "au",
        "claimFees": "av",
        "recipient": "aw",
        "emergency": "ax",
        "onlyOwner": "ay",
        "remaining": "az",
        "isForPair": "ba",
        "_withdraw": "bb",
        "_balances": "bc",
        "balanceOf": "bd",
        "onReward": "be",
        "_deposit": "bf",
        "withdraw": "bg",
        "leftover": "bh",
        "claimed0": "bi",
        "claimed1": "bj",
        "_token1": "bk",
        "deposit": "bl",
        "_token0": "bm",
        "_amount": "bn",
        "rewards": "bo",
        "account": "bp",
        "amount": "bq",
        "reward": "br",
        "_rHYBR": "bs",
        "_token": "bt",
        "_fees0": "bu",
        "earned": "bv",
        "tokens": "bw",
        "_fees1": "bx",
        "_user": "by",
        "token": "bz",
        "rHYBR": "ca",
        "gauge": "cb",
        "_int": "cc",
        "user": "cd",
        "_ve": "ce",
        "min": "cf"
      },
      "changes": [
        "Renamed 84 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_004",
      "transformed_id": "ss_l2_short_nc_gs_004",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": false,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public l = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public d = 1200;\n    uint256 public a = 300;\n\n\n    uint256 public bk = 100;\n    uint256 public constant MIN_WITHDRAW_FEE = 10;\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant BASIS = 10000;\n    address public Team;\n    uint256 public dp;\n    uint256 public dg;\n    uint256 public bl;\n\n    struct UserLock {\n        uint256 dq;\n        uint256 by;\n    }\n\n    mapping(address => UserLock[]) public cr;\n    mapping(address => uint256) public ai;\n\n\n    address public immutable HYBR;\n    address public immutable at;\n    address public eb;\n    address public k;\n    address public bb;\n    uint256 public co;\n\n\n    address public cx;\n    uint256 public aq;\n\n\n    uint256 public ad;\n    uint256 public p;\n\n\n    ISwapper public do;\n\n\n    error NOT_AUTHORIZED();\n\n\n    event Deposit(address indexed em, uint256 ce, uint256 ag);\n    event Withdraw(address indexed em, uint256 dt, uint256 ce, uint256 eq);\n    event Compound(uint256 dm, uint256 af);\n    event PenaltyRewardReceived(uint256 dq);\n    event TransferLockPeriodUpdated(uint256 cj, uint256 cq);\n    event SwapperUpdated(address indexed bx, address indexed bw);\n    event VoterSet(address eb);\n    event EmergencyUnlock(address indexed em);\n    event AutoVotingEnabled(bool di);\n    event OperatorUpdated(address indexed bt, address indexed bq);\n    event DefaultVotingStrategyUpdated(address[] ec, uint256[] dd);\n    event AutoVoteExecuted(uint256 ei, address[] ec, uint256[] dd);\n\n    constructor(\n        address ee,\n        address ak\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(ee != address(0), \"Invalid HYBR\");\n        require(ak != address(0), \"Invalid VE\");\n\n        HYBR = ee;\n        at = ak;\n        ad = block.timestamp;\n        p = block.timestamp;\n        cx = msg.sender;\n    }\n\n    function f(address j) external cn {\n        require(j != address(0), \"Invalid rewards distributor\");\n        k = j;\n    }\n\n    function x(address ar) external cn {\n        require(ar != address(0), \"Invalid gauge manager\");\n        bb = ar;\n    }\n\n\n    modifier av() {\n        if (msg.sender != cx) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n\n    function df(uint256 dq, address cl) external ax {\n        require(dq > 0, \"Zero amount\");\n        cl = cl == address(0) ? msg.sender : cl;\n\n\n        IERC20(HYBR).bc(msg.sender, address(this), dq);\n\n\n        if (co == 0) {\n            q(dq);\n        } else {\n\n            IERC20(HYBR).dl(at, dq);\n            IVotingEscrow(at).bh(co, dq);\n\n\n            o();\n        }\n\n\n        uint256 dt = aa(dq);\n\n\n        ek(cl, dt);\n\n\n        t(cl, dt);\n\n        emit Deposit(msg.sender, dq, dt);\n    }\n\n\n    function cz(uint256 dt) external ax returns (uint256 br) {\n        require(dt > 0, \"Zero shares\");\n        require(ct(msg.sender) >= dt, \"Insufficient balance\");\n        require(co != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(at).ea(co) == false, \"Cannot withdraw yet\");\n\n        uint256 cb = HybraTimeLibrary.cb(block.timestamp);\n        uint256 ch = HybraTimeLibrary.ch(block.timestamp);\n\n        require(block.timestamp >= cb + d && block.timestamp < ch - a, \"Cannot withdraw yet\");\n\n\n        uint256 ce = z(dt);\n        require(ce > 0, \"No assets to withdraw\");\n\n\n        uint256 cp = 0;\n        if (bk > 0) {\n            cp = (ce * bk) / BASIS;\n        }\n\n\n        uint256 bz = ce - cp;\n        require(bz > 0, \"Amount too small after fee\");\n\n\n        uint256 ck = bg();\n        require(ce <= ck, \"Insufficient veNFT balance\");\n\n        uint256 w = ck - bz - cp;\n        require(w >= 0, \"Cannot withdraw entire veNFT\");\n\n\n        el(msg.sender, dt);\n\n\n        uint256[] memory dn = new uint256[](3);\n        dn[0] = w;\n        dn[1] = bz;\n        dn[2] = cp;\n\n        uint256[] memory bm = IVotingEscrow(at).cf(co, dn);\n\n\n        co = bm[0];\n        br = bm[1];\n        uint256 bv = bm[2];\n\n        IVotingEscrow(at).r(address(this), msg.sender, br);\n        IVotingEscrow(at).r(address(this), Team, bv);\n        emit Withdraw(msg.sender, dt, bz, cp);\n    }\n\n\n    function q(uint256 ap) internal {\n\n        IERC20(HYBR).dl(at, type(uint256).ep);\n        uint256 cw = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n\n        co = IVotingEscrow(at).y(ap, cw, address(this));\n\n    }\n\n\n    function aa(uint256 dq) public view returns (uint256) {\n        uint256 aw = bf();\n        uint256 au = bg();\n        if (aw == 0 || au == 0) {\n            return dq;\n        }\n        return (dq * aw) / au;\n    }\n\n\n    function z(uint256 dt) public view returns (uint256) {\n        uint256 aw = bf();\n        if (aw == 0) {\n            return dt;\n        }\n        return (dt * bg()) / aw;\n    }\n\n\n    function bg() public view returns (uint256) {\n        if (co == 0) {\n            return 0;\n        }\n\n        IVotingEscrow.LockedBalance memory dw = IVotingEscrow(at).dw(co);\n        return uint256(int256(dw.dq));\n    }\n\n\n    function t(address em, uint256 dq) internal {\n        uint256 by = block.timestamp + l;\n        cr[em].push(UserLock({\n            dq: dq,\n            by: by\n        }));\n        ai[em] += dq;\n    }\n\n\n    function s(address em) external view returns (uint256 cs) {\n        uint256 bd = ct(em);\n        uint256 an = 0;\n\n        UserLock[] storage er = cr[em];\n        for (uint256 i = 0; i < er.length; i++) {\n            if (er[i].by > block.timestamp) {\n                an += er[i].dq;\n            }\n        }\n\n        return bd > an ? bd - an : 0;\n    }\n\n    function al(address em) internal returns (uint256 dy) {\n        UserLock[] storage er = cr[em];\n        uint256 et = er.length;\n        if (et == 0) return 0;\n\n        uint256 ed = 0;\n        unchecked {\n            for (uint256 i = 0; i < et; i++) {\n                UserLock memory L = er[i];\n                if (L.by <= block.timestamp) {\n                    dy += L.dq;\n                } else {\n                    if (ed != i) er[ed] = L;\n                    ed++;\n                }\n            }\n            if (dy > 0) {\n                ai[em] -= dy;\n            }\n            while (er.length > ed) {\n                er.pop();\n            }\n        }\n    }\n\n\n    function h(\n        address from,\n        address eu,\n        uint256 dq\n    ) internal override {\n        super.h(from, eu, dq);\n\n        if (from != address(0) && eu != address(0)) {\n            uint256 bd = ct(from);\n\n\n            uint256 n = bd > ai[from] ? bd - ai[from] : 0;\n\n\n            if (n >= dq) {\n                return;\n            }\n\n\n            al(from);\n            uint256 ae = bd > ai[from] ? bd - ai[from] : 0;\n\n\n            require(ae >= dq, \"Tokens locked\");\n        }\n    }\n\n\n    function ay() external av {\n        require(eb != address(0), \"Voter not set\");\n        require(k != address(0), \"Distributor not set\");\n\n\n        uint256  as = IRewardsDistributor(k).ef(co);\n        dp += as;\n\n        address[] memory cc = IVoter(eb).db(co);\n\n        for (uint256 i = 0; i < cc.length; i++) {\n            if (cc[i] != address(0)) {\n                address eg = IGaugeManager(bb).dv(cc[i]);\n\n                if (eg != address(0)) {\n\n                    address[] memory dr = new address[](1);\n                    address[][] memory du = new address[][](1);\n\n\n                    address aj = IGaugeManager(bb).u(eg);\n                    if (aj != address(0)) {\n                        uint256 ca = IBribe(aj).m();\n                        if (ca > 0) {\n                            address[] memory bn = new address[](ca);\n                            for (uint256 j = 0; j < ca; j++) {\n                                bn[j] = IBribe(aj).bn(j);\n                            }\n                            dr[0] = aj;\n                            du[0] = bn;\n\n                            IGaugeManager(bb).bo(dr, du, co);\n                        }\n                    }\n\n\n                    address ao = IGaugeManager(bb).ab(eg);\n                    if (ao != address(0)) {\n                        uint256 ca = IBribe(ao).m();\n                        if (ca > 0) {\n                            address[] memory bn = new address[](ca);\n                            for (uint256 j = 0; j < ca; j++) {\n                                bn[j] = IBribe(ao).bn(j);\n                            }\n                            dr[0] = ao;\n                            du[0] = bn;\n\n                            IGaugeManager(bb).bo(dr, du, co);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    function bp(ISwapper.SwapParams calldata dk) external ax av {\n        require(address(do) != address(0), \"Swapper not set\");\n\n\n        uint256 az = IERC20(dk.dh).ct(address(this));\n        require(az >= dk.da, \"Insufficient token balance\");\n\n\n        IERC20(dk.dh).bs(address(do), dk.da);\n\n\n        uint256 ba = do.cd(dk);\n\n\n        IERC20(dk.dh).bs(address(do), 0);\n\n\n        bl += ba;\n    }\n\n\n    function dc() external av {\n\n\n        uint256 bu = IERC20(HYBR).ct(address(this));\n\n        if (bu > 0) {\n\n            IERC20(HYBR).bs(at, bu);\n            IVotingEscrow(at).bh(co, bu);\n\n\n            o();\n\n            p = block.timestamp;\n\n            emit Compound(bu, bg());\n        }\n    }\n\n\n    function eo(address[] calldata ci, uint256[] calldata cy) external {\n        require(msg.sender == ej() || msg.sender == cx, \"Not authorized\");\n        require(eb != address(0), \"Voter not set\");\n\n        IVoter(eb).eo(co, ci, cy);\n        aq = HybraTimeLibrary.cb(block.timestamp);\n\n    }\n\n\n    function eh() external {\n        require(msg.sender == ej() || msg.sender == cx, \"Not authorized\");\n        require(eb != address(0), \"Voter not set\");\n\n        IVoter(eb).eh(co);\n    }\n\n\n    function i(uint256 dq) external {\n\n\n        if (dq > 0) {\n            IERC20(HYBR).dl(at, dq);\n\n            if(co == 0){\n                q(dq);\n            } else{\n                IVotingEscrow(at).bh(co, dq);\n\n\n                o();\n            }\n        }\n        dg += dq;\n        emit PenaltyRewardReceived(dq);\n    }\n\n\n    function cu(address ds) external cn {\n        require(ds != address(0), \"Invalid voter\");\n        eb = ds;\n        emit VoterSet(ds);\n    }\n\n\n    function e(uint256 dj) external cn {\n        require(dj >= MIN_LOCK_PERIOD && dj <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 cj = l;\n        l = dj;\n        emit TransferLockPeriodUpdated(cj, dj);\n    }\n\n\n    function ac(uint256 en) external cn {\n        require(en >= MIN_WITHDRAW_FEE && en <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        bk = en;\n    }\n\n    function b(uint256 dz) external cn {\n        d = dz;\n    }\n\n    function c(uint256 dz) external cn {\n        a = dz;\n    }\n\n\n    function cg(address cv) external cn {\n        require(cv != address(0), \"Invalid swapper\");\n        address bx = address(do);\n        do = ISwapper(cv);\n        emit SwapperUpdated(bx, cv);\n    }\n\n\n    function de(address dx) external cn {\n        require(dx != address(0), \"Invalid team\");\n        Team = dx;\n    }\n\n\n    function v(address em) external av {\n        delete cr[em];\n        ai[em] = 0;\n        emit EmergencyUnlock(em);\n    }\n\n\n    function be(address em) external view returns (UserLock[] memory) {\n        return cr[em];\n    }\n\n\n    function bj(address cm) external cn {\n        require(cm != address(0), \"Invalid operator\");\n        address bt = cx;\n        cx = cm;\n        emit OperatorUpdated(bt, cm);\n    }\n\n\n    function ah() external view returns (uint256) {\n        if (co == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory dw = IVotingEscrow(at).dw(co);\n        return uint256(dw.es);\n    }\n\n\n    function o() internal {\n        if (co == 0) return;\n\n        IVotingEscrow.LockedBalance memory dw = IVotingEscrow(at).dw(co);\n        if (dw.bi || dw.es <= block.timestamp) return;\n\n        uint256 am = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n\n        if (am > dw.es + 2 hours) {\n            try IVotingEscrow(at).g(co, HybraTimeLibrary.MAX_LOCK_DURATION) {\n\n            } catch {\n\n\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "tail_not_withdraw_time": "a",
        "setHeadNotWithdrawTime": "b",
        "setTailNotWithdrawTime": "c",
        "head_not_withdraw_time": "d",
        "setTransferLockPeriod": "e",
        "setRewardsDistributor": "f",
        "increase_unlock_time": "g",
        "_beforeTokenTransfer": "h",
        "receivePenaltyReward": "i",
        "_rewardsDistributor": "j",
        "rewardsDistributor": "k",
        "transferLockPeriod": "l",
        "rewardsListLength": "m",
        "currentAvailable": "n",
        "_extendLockToMax": "o",
        "lastCompoundTime": "p",
        "_initializeVeNFT": "q",
        "safeTransferFrom": "r",
        "previewAvailable": "s",
        "_addTransferLock": "t",
        "internal_bribes": "u",
        "emergencyUnlock": "v",
        "remainingAmount": "w",
        "setGaugeManager": "x",
        "create_lock_for": "y",
        "calculateAssets": "z",
        "calculateShares": "aa",
        "external_bribes": "ab",
        "setWithdrawFee": "ac",
        "lastRebaseTime": "ad",
        "finalAvailable": "ae",
        "newTotalLocked": "af",
        "sharesReceived": "ag",
        "getLockEndTime": "ah",
        "lockedBalance": "ai",
        "internalBribe": "aj",
        "_votingEscrow": "ak",
        "_cleanExpired": "al",
        "maxUnlockTime": "am",
        "currentLocked": "an",
        "externalBribe": "ao",
        "initialAmount": "ap",
        "lastVoteEpoch": "aq",
        "_gaugeManager": "ar",
        "rebaseAmount": "as",
        "votingEscrow": "at",
        "_totalAssets": "au",
        "onlyOperator": "av",
        "_totalSupply": "aw",
        "nonReentrant": "ax",
        "claimRewards": "ay",
        "tokenBalance": "az",
        "hybrReceived": "ba",
        "gaugeManager": "bb",
        "transferFrom": "bc",
        "totalBalance": "bd",
        "getUserLocks": "be",
        "totalSupply": "bf",
        "totalAssets": "bg",
        "deposit_for": "bh",
        "isPermanent": "bi",
        "setOperator": "bj",
        "withdrawFee": "bk",
        "votingYield": "bl",
        "newTokenIds": "bm",
        "bribeTokens": "bn",
        "claimBribes": "bo",
        "executeSwap": "bp",
        "newOperator": "bq",
        "userTokenId": "br",
        "safeApprove": "bs",
        "oldOperator": "bt",
        "hybrBalance": "bu",
        "feeTokenId": "bv",
        "newSwapper": "bw",
        "oldSwapper": "bx",
        "unlockTime": "by",
        "userAmount": "bz",
        "tokenCount": "ca",
        "epochStart": "cb",
        "votedPools": "cc",
        "swapToHYBR": "cd",
        "hybrAmount": "ce",
        "multiSplit": "cf",
        "setSwapper": "cg",
        "epochNext": "ch",
        "_poolVote": "ci",
        "oldPeriod": "cj",
        "veBalance": "ck",
        "recipient": "cl",
        "_operator": "cm",
        "onlyOwner": "cn",
        "veTokenId": "co",
        "feeAmount": "cp",
        "newPeriod": "cq",
        "userLocks": "cr",
        "available": "cs",
        "balanceOf": "ct",
        "setVoter": "cu",
        "_swapper": "cv",
        "lockTime": "cw",
        "operator": "cx",
        "_weights": "cy",
        "withdraw": "cz",
        "amountIn": "da",
        "poolVote": "db",
        "compound": "dc",
        "weights": "dd",
        "setTeam": "de",
        "deposit": "df",
        "penalty": "dg",
        "tokenIn": "dh",
        "enabled": "di",
        "_period": "dj",
        "_params": "dk",
        "approve": "dl",
        "rewards": "dm",
        "amounts": "dn",
        "swapper": "do",
        "rebase": "dp",
        "amount": "dq",
        "bribes": "dr",
        "_voter": "ds",
        "shares": "dt",
        "tokens": "du",
        "gauges": "dv",
        "locked": "dw",
        "_team": "dx",
        "freed": "dy",
        "_time": "dz",
        "voted": "ea",
        "voter": "eb",
        "pools": "ec",
        "write": "ed",
        "_HYBR": "ee",
        "claim": "ef",
        "gauge": "eg",
        "reset": "eh",
        "epoch": "ei",
        "owner": "ej",
        "_mint": "ek",
        "_burn": "el",
        "user": "em",
        "_fee": "en",
        "vote": "eo",
        "max": "ep",
        "fee": "eq",
        "arr": "er",
        "end": "es",
        "len": "et",
        "to": "eu"
      },
      "changes": [
        "Renamed 151 identifiers using short style"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 482, column 9', 'Syntax error at line 482, column 12']"
    },
    {
      "original_id": "nc_gs_005",
      "transformed_id": "ss_l2_short_nc_gs_005",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPairInfo.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVotingEscrow.sol';\nimport './interfaces/IGaugeManager.sol';\nimport './interfaces/IPermissionsRegistry.sol';\nimport './interfaces/ITokenHandler.sol';\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract VoterV3 is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public bk;\n    address internal bh;\n    address public f;\n    address public u;\n    uint256 public w;\n    uint public EPOCH_DURATION;\n    uint256 internal constant MIN_VOTING_NUM = 10;\n    IGaugeManager public t;\n\n    mapping(uint256 => mapping(address => uint256)) public be;\n    mapping(uint256 => address[]) public an;\n\n    mapping(address => uint256) public aq;\n    uint256 public ae;\n    mapping(uint256 => uint256) public ab;\n\n    mapping(uint256 => uint256) public aj;\n    mapping(uint256 => uint256) public g;\n\n    event Voted(address indexed bb, uint256 as, uint256 aw);\n    event Abstained(uint256 as, uint256 aw);\n    event SetPermissionRegistry(address indexed bl, address indexed az);\n\n    constructor() {}\n\n\n    function ah(\n        address __ve,\n        address p,\n        address r,\n        address d\n    ) public ac {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        bk = __ve;\n        bh = IVotingEscrow(__ve).ba();\n        t = IGaugeManager(r);\n        f = d;\n        u = p;\n        w = 30;\n        EPOCH_DURATION = HybraTimeLibrary.WEEK;\n    }\n\n\n    modifier VoterAdmin() {\n        require(IPermissionsRegistry(f).au(\"VOTER_ADMIN\",msg.sender), 'VOTER_ADMIN');\n        _;\n    }\n\n    modifier Governance() {\n        require(IPermissionsRegistry(f).au(\"GOVERNANCE\",msg.sender), 'GOVERNANCE');\n        _;\n    }\n\n    modifier GenesisManager() {\n        require(IPermissionsRegistry(f).au(\"GENESIS_MANAGER\", msg.sender), 'GENESIS_MANAGER');\n        _;\n    }\n\n\n    function c(address d) external VoterAdmin {\n        require(d.code.length > 0, \"CODELEN\");\n        require(d != address(0), \"ZA\");\n        emit SetPermissionRegistry(f, d);\n        f = d;\n    }\n\n    function j(uint256 q) external VoterAdmin {\n        require (q >= MIN_VOTING_NUM, \"LOW_VOTE\");\n        w = q;\n    }\n\n\n    function bg(uint256 ak) external z(ak) y {\n        require(IVotingEscrow(bk).h(msg.sender, ak), \"NAO\");\n        ax(ak);\n        IVotingEscrow(bk).ar(ak);\n    }\n\n    function ax(uint256 ak) internal {\n        address[] storage ai = an[ak];\n        uint256 s = ai.length;\n        uint256 v = 0;\n\n        for (uint256 i = 0; i < s; i ++) {\n            address bf = ai[i];\n            uint256 av = be[ak][bf];\n\n            if (av != 0) {\n                aq[bf] -= av;\n\n                be[ak][bf] -= av;\n                address n = t.a(bf);\n                address o = t.b(bf);\n                IBribe(n).ao(uint256(av), ak);\n                IBribe(o).ao(uint256(av), ak);\n\n\n                v += av;\n\n                emit Abstained(ak, av);\n            }\n        }\n        ae -= v;\n        ab[ak] = 0;\n        delete an[ak];\n    }\n\n\n    function bi(uint256 ak) external y {\n        uint256 af = block.timestamp;\n        if (af <= HybraTimeLibrary.l(af)){\n            revert(\"DW\");\n        }\n        require(IVotingEscrow(bk).h(msg.sender, ak) || msg.sender == bk, \"NAO||VE\");\n        address[] memory ai = an[ak];\n        uint256 al = ai.length;\n        uint256[] memory am = new uint256[](al);\n\n        for (uint256 i = 0; i < al; i ++) {\n            am[i] = be[ak][ai[i]];\n        }\n\n        bd(ak, ai, am);\n    }\n\n\n    function bj(uint256 ak, address[] calldata ai, uint256[] calldata am)\n        external z(ak) y {\n        require(IVotingEscrow(bk).h(msg.sender, ak), \"NAO\");\n        require(ai.length == am.length, \"MISMATCH_LEN\");\n        require(ai.length <= w, \"EXCEEDS\");\n        uint256 af = block.timestamp;\n\n        bd(ak, ai, am);\n        aj[ak] = HybraTimeLibrary.ag(block.timestamp) + 1;\n        g[ak] = block.timestamp;\n    }\n\n    function bd(uint256 ak, address[] memory ai, uint256[] memory am) internal {\n        ax(ak);\n        uint256 al = ai.length;\n        uint256 at = IVotingEscrow(bk).x(ak);\n        uint256 i = 0;\n        uint256 ad = 0;\n\n        for (uint i = 0; i < al; i++) {\n\n            if(t.e(ai[i])) i += am[i];\n        }\n\n        for (uint256 i = 0; i < al; i++) {\n            address bf = ai[i];\n\n            if (t.e(bf)) {\n                uint256 aa = am[i] * at / i;\n\n                require(be[ak][bf] == 0, \"ZV\");\n                require(aa != 0, \"ZV\");\n\n                an[ak].push(bf);\n                aq[bf] += aa;\n\n                be[ak][bf] = aa;\n                address n = t.a(bf);\n                address o = t.b(bf);\n\n                IBribe(n).ap(uint256(aa), ak);\n                IBribe(o).ap(uint256(aa), ak);\n\n                ad += aa;\n                emit Voted(msg.sender, ak, aa);\n            }\n        }\n        if (ad > 0) IVotingEscrow(bk).ay(ak);\n        ae += ad;\n        ab[ak] = ad;\n    }\n\n    modifier z(uint256 ak) {\n\n        if (HybraTimeLibrary.ag(block.timestamp) <= aj[ak]) revert(\"VOTED\");\n        if (block.timestamp <= HybraTimeLibrary.l(block.timestamp)) revert(\"DW\");\n        _;\n    }\n\n\n    function length() external view returns (uint256) {\n        return t.bc().length;\n    }\n\n\n    function m(uint256 as) external view returns(uint256) {\n        return an[as].length;\n    }\n\n    function k(address r) external VoterAdmin {\n        require(r != address(0));\n        t = IGaugeManager(r);\n    }\n\n}",
      "rename_map": {
        "fetchInternalBribeFromPool": "a",
        "fetchExternalBribeFromPool": "b",
        "setPermissionsRegistry": "c",
        "_permissionRegistry": "d",
        "isGaugeAliveForPool": "e",
        "permissionRegistry": "f",
        "lastVotedTimestamp": "g",
        "isApprovedOrOwner": "h",
        "_totalVoteWeight": "i",
        "setMaxVotingNum": "j",
        "setGaugeManager": "k",
        "epochVoteStart": "l",
        "poolVoteLength": "m",
        "internal_bribe": "n",
        "external_bribe": "o",
        "_tokenHandler": "p",
        "_maxVotingNum": "q",
        "_gaugeManager": "r",
        "_poolVoteCnt": "s",
        "gaugeManager": "t",
        "tokenHandler": "u",
        "_totalWeight": "v",
        "maxVotingNum": "w",
        "balanceOfNFT": "x",
        "nonReentrant": "y",
        "onlyNewEpoch": "z",
        "_poolWeight": "aa",
        "usedWeights": "ab",
        "initializer": "ac",
        "_usedWeight": "ad",
        "totalWeight": "ae",
        "_timestamp": "af",
        "epochStart": "ag",
        "initialize": "ah",
        "_poolVote": "ai",
        "lastVoted": "aj",
        "_tokenId": "ak",
        "_poolCnt": "al",
        "_weights": "am",
        "poolVote": "an",
        "withdraw": "ao",
        "deposit": "ap",
        "weights": "aq",
        "abstain": "ar",
        "tokenId": "as",
        "_weight": "at",
        "hasRole": "au",
        "_votes": "av",
        "weight": "aw",
        "_reset": "ax",
        "voting": "ay",
        "latest": "az",
        "token": "ba",
        "voter": "bb",
        "pools": "bc",
        "_vote": "bd",
        "votes": "be",
        "_pool": "bf",
        "reset": "bg",
        "base": "bh",
        "poke": "bi",
        "vote": "bj",
        "_ve": "bk",
        "old": "bl"
      },
      "changes": [
        "Renamed 64 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_006",
      "transformed_id": "ss_l2_short_nc_gs_006",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable at;\n    address public immutable df;\n    address public VE;\n    address public DISTRIBUTION;\n    address public af;\n    address public ad;\n\n    uint256 public DURATION;\n    uint256 internal ah;\n    uint256 public be;\n    ICLPool public db;\n    address public au;\n    INonfungiblePositionManager public b;\n\n    bool public bq;\n    bool public immutable bv;\n    address immutable cp;\n\n    mapping(uint256 => uint256) public  m;\n    mapping(address => EnumerableSet.UintSet) internal cm;\n    mapping(uint256 => uint256) public  k;\n\n    mapping(uint256 => uint256) public  cn;\n\n    mapping(uint256 => uint256) public  ab;\n\n    event RewardAdded(uint256 cs);\n    event Deposit(address indexed dj, uint256 cr);\n    event Withdraw(address indexed dj, uint256 cr);\n    event Harvest(address indexed dj, uint256 cs);\n    event ClaimFees(address indexed from, uint256 cc, uint256 cd);\n    event EmergencyActivated(address indexed dg, uint256 timestamp);\n    event EmergencyDeactivated(address indexed dg, uint256 timestamp);\n\n    constructor(address am, address cv, address dl, address dd, address ak, address aa,\n        address x, bool az, address dk,  address bz) {\n        cp = bz;\n        at = IERC20(am);\n        df = cv;\n        VE = dl;\n        au = dd;\n        db = ICLPool(dd);\n        DISTRIBUTION = ak;\n        DURATION = HybraTimeLibrary.WEEK;\n\n        af = aa;\n        ad = x;\n        bv = az;\n        b = INonfungiblePositionManager(dk);\n        bq = false;\n    }\n\n    modifier r() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier ae() {\n        require(bq == false, \"emergency\");\n        _;\n    }\n\n    function ag(uint256 co, int24 bu, int24 bm) internal {\n        if (ab[co] == block.timestamp) return;\n        db.c();\n        ab[co] = block.timestamp;\n        cn[co] += cl(co);\n        k[co] = db.h(bu, bm, 0);\n    }\n\n    function g() external br {\n        require(bq == false, \"emergency\");\n        bq = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function o() external br {\n\n        require(bq == true,\"emergency\");\n\n        bq = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function bw(uint256 co) external view returns (uint256) {\n        (,,,,,,,uint128 bs,,,,) = b.bi(co);\n        return bs;\n    }\n\n    function y(address cx, address dc, int24 ay) internal view returns (address) {\n        return ICLFactory(b.cp()).cj(cx, dc, ay);\n    }\n\n    function da(uint256 co) external view returns (uint256 cs) {\n        require(cm[msg.sender].ce(co), \"NA\");\n\n        uint256 cs = cl(co);\n        return (cs);\n    }\n\n       function cl(uint256 co) internal view returns (uint256) {\n        uint256 as = db.as();\n\n        uint256 bx = block.timestamp - as;\n\n        uint256 f = db.f();\n        uint256 aj = db.aj();\n\n        if (bx != 0 && aj > 0 && db.w() > 0) {\n            uint256 cs = be * bx;\n            if (cs > aj) cs = aj;\n\n            f += FullMath.cu(cs, FixedPoint128.Q128, db.w());\n        }\n\n        (,,,,, int24 bu, int24 bm, uint128 bs,,,,) = b.bi(co);\n\n        uint256 a = k[co];\n        uint256 d = db.h(bu, bm, f);\n\n        uint256 bk =\n            FullMath.cu(d - a, bs, FixedPoint128.Q128);\n        return bk;\n    }\n\n    function ch(uint256 co) external an ae {\n\n         (,,address cx, address dc, int24 ay, int24 bu, int24 bm, uint128 bs,,,,) =\n            b.bi(co);\n\n        require(bs > 0, \"Gauge: zero liquidity\");\n\n        address ao = y(cx, dc, ay);\n\n        require(ao == au, \"Pool mismatch: Position not for this gauge pool\");\n\n        b.cg(INonfungiblePositionManager.CollectParams({\n                co: co,\n                bp: msg.sender,\n                bh: type(uint128).dn,\n                bf: type(uint128).dn\n            }));\n\n        b.u(msg.sender, address(this), co);\n\n        db.dh(int128(bs), bu, bm, true);\n\n        uint256 ap = db.h(bu, bm, 0);\n        k[co] = ap;\n        ab[co] = block.timestamp;\n\n        cm[msg.sender].dm(co);\n\n        emit Deposit(msg.sender, co);\n    }\n\n    function ca(uint256 co, uint8 bd) external an ae {\n           require(cm[msg.sender].ce(co), \"NA\");\n\n\n        b.cg(\n            INonfungiblePositionManager.CollectParams({\n                co: co,\n                bp: msg.sender,\n                bh: type(uint128).dn,\n                bf: type(uint128).dn\n            })\n        );\n\n        (,,,,, int24 bu, int24 bm, uint128 t,,,,) = b.bi(co);\n        bc(bu, bm, co, msg.sender, bd);\n\n\n        if (t != 0) {\n            db.dh(-int128(t), bu, bm, true);\n        }\n\n        cm[msg.sender].cz(co);\n        b.u(address(this), msg.sender, co);\n\n        emit Withdraw(msg.sender, co);\n    }\n\n    function bl(uint256 co, address cq,uint8 bd ) public an r {\n\n        require(cm[cq].ce(co), \"NA\");\n\n        (,,,,, int24 bu, int24 bm,,,,,) = b.bi(co);\n        bc(bu, bm, co, cq, bd);\n    }\n\n    function bc(int24 bu, int24 bm, uint256 co,address cq, uint8 bd) internal {\n        ag(co, bu, bm);\n        uint256 aq = cn[co];\n        if(aq > 0){\n            delete cn[co];\n            at.ax(df, aq);\n            IRHYBR(df).e(aq);\n            IRHYBR(df).bn(aq, bd, cq);\n        }\n        emit Harvest(msg.sender, aq);\n    }\n\n    function j(address de, uint256 aq) external an\n        ae r returns (uint256 aw) {\n        require(de == address(at), \"Invalid reward token\");\n\n\n        db.c();\n\n\n        uint256 l = HybraTimeLibrary.bj(block.timestamp) - block.timestamp;\n        uint256 p = block.timestamp + l;\n\n\n        uint256 n = aq + db.cb();\n\n\n        if (block.timestamp >= ah) {\n\n            be = aq / l;\n            db.bg({\n                be: be,\n                aj: n,\n                ar: p\n            });\n        } else {\n\n            uint256 ac = l * be;\n            be = (aq + ac) / l;\n            db.bg({\n                be: be,\n                aj: n + ac,\n                ar: p\n            });\n        }\n\n\n        m[HybraTimeLibrary.ba(block.timestamp)] = be;\n\n\n        at.u(DISTRIBUTION, address(this), aq);\n\n\n        uint256 z = at.bw(address(this));\n        require(be <= z / l, \"Insufficient balance for reward rate\");\n\n\n        ah = p;\n        aw = be;\n\n        emit RewardAdded(aq);\n    }\n\n    function ai() external view returns (uint256 cx, uint256 dc){\n\n        (cx, dc) = db.bt();\n\n    }\n\n    function bo() external an returns (uint256 cc, uint256 cd) {\n        return bb();\n    }\n\n    function bb() internal returns (uint256 cc, uint256 cd) {\n        if (!bv) {\n            return (0, 0);\n        }\n\n        db.av();\n\n        address ci = db.cx();\n        address cf = db.dc();\n\n        cc = IERC20(ci).bw(address(this));\n        cd = IERC20(cf).bw(address(this));\n\n        if (cc > 0 || cd > 0) {\n\n            uint256 cy = cc;\n            uint256 ct = cd;\n\n            if (cy  > 0) {\n                IERC20(ci).ax(af, 0);\n                IERC20(ci).ax(af, cy);\n                IBribe(af).j(ci, cy);\n            }\n            if (ct  > 0) {\n                IERC20(cf).ax(af, 0);\n                IERC20(cf).ax(af, ct);\n                IBribe(af).j(cf, ct);\n            }\n            emit ClaimFees(msg.sender, cc, cd);\n        }\n    }\n\n\n    function q() external view returns (uint256) {\n        return be * DURATION;\n    }\n\n\n    function s(address di) external br {\n        require(di >= address(0), \"zero\");\n        af = di;\n    }\n\n    function al(address de,address do,uint256 value) internal {\n        require(de.code.length > 0);\n        (bool ck, bytes memory data) = de.call(abi.i(IERC20.transfer.selector, do, value));\n        require(ck && (data.length == 0 || abi.cw(data, (bool))));\n    }\n\n\n    function v(\n        address by,\n        address from,\n        uint256 co,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.v.selector;\n    }\n\n}",
      "rename_map": {
        "rewardPerTokenInsideInitialX128": "a",
        "nonfungiblePositionManager": "b",
        "updateRewardsGrowthGlobal": "c",
        "rewardPerTokenInsideX128": "d",
        "depostionEmissionsToken": "e",
        "rewardGrowthGlobalX128": "f",
        "activateEmergencyMode": "g",
        "getRewardGrowthInside": "h",
        "encodeWithSelector": "i",
        "notifyRewardAmount": "j",
        "rewardGrowthInside": "k",
        "epochTimeRemaining": "l",
        "rewardRateByEpoch": "m",
        "totalRewardAmount": "n",
        "stopEmergencyMode": "o",
        "epochEndTimestamp": "p",
        "rewardForDuration": "q",
        "onlyDistribution": "r",
        "setInternalBribe": "s",
        "liquidityToStake": "t",
        "safeTransferFrom": "u",
        "onERC721Received": "v",
        "stakedLiquidity": "w",
        "_external_bribe": "x",
        "_getPoolAddress": "y",
        "contractBalance": "z",
        "_internal_bribe": "aa",
        "lastUpdateTime": "ab",
        "pendingRewards": "ac",
        "external_bribe": "ad",
        "isNotEmergency": "ae",
        "internal_bribe": "af",
        "_updateRewards": "ag",
        "_periodFinish": "ah",
        "gaugeBalances": "ai",
        "rewardReserve": "aj",
        "_distribution": "ak",
        "_safeTransfer": "al",
        "_rewardToken": "am",
        "nonReentrant": "an",
        "positionPool": "ao",
        "rewardGrowth": "ap",
        "rewardAmount": "aq",
        "periodFinish": "ar",
        "lastUpdated": "as",
        "rewardToken": "at",
        "poolAddress": "au",
        "collectFees": "av",
        "currentRate": "aw",
        "safeApprove": "ax",
        "tickSpacing": "ay",
        "_isForPair": "az",
        "epochStart": "ba",
        "_claimFees": "bb",
        "_getReward": "bc",
        "redeemType": "bd",
        "rewardRate": "be",
        "amount1Max": "bf",
        "syncReward": "bg",
        "amount0Max": "bh",
        "positions": "bi",
        "epochNext": "bj",
        "claimable": "bk",
        "getReward": "bl",
        "tickUpper": "bm",
        "redeemFor": "bn",
        "claimFees": "bo",
        "recipient": "bp",
        "emergency": "bq",
        "onlyOwner": "br",
        "liquidity": "bs",
        "gaugeFees": "bt",
        "tickLower": "bu",
        "isForPair": "bv",
        "balanceOf": "bw",
        "timeDelta": "bx",
        "operator": "by",
        "_factory": "bz",
        "withdraw": "ca",
        "rollover": "cb",
        "claimed0": "cc",
        "claimed1": "cd",
        "contains": "ce",
        "_token1": "cf",
        "collect": "cg",
        "deposit": "ch",
        "_token0": "ci",
        "getPool": "cj",
        "success": "ck",
        "_earned": "cl",
        "_stakes": "cm",
        "rewards": "cn",
        "tokenId": "co",
        "factory": "cp",
        "account": "cq",
        "amount": "cr",
        "reward": "cs",
        "_fees1": "ct",
        "mulDiv": "cu",
        "_rHYBR": "cv",
        "decode": "cw",
        "token0": "cx",
        "_fees0": "cy",
        "remove": "cz",
        "earned": "da",
        "clPool": "db",
        "token1": "dc",
        "_pool": "dd",
        "token": "de",
        "rHYBR": "df",
        "gauge": "dg",
        "stake": "dh",
        "_int": "di",
        "user": "dj",
        "nfpm": "dk",
        "_ve": "dl",
        "add": "dm",
        "max": "dn",
        "to": "do"
      },
      "changes": [
        "Renamed 119 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_007",
      "transformed_id": "ss_l2_short_nc_gs_007",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable at;\n    address public immutable df;\n    address public VE;\n    address public DISTRIBUTION;\n    address public af;\n    address public ad;\n\n    uint256 public DURATION;\n    uint256 internal ah;\n    uint256 public be;\n    ICLPool public db;\n    address public au;\n    INonfungiblePositionManager public b;\n\n    bool public bq;\n    bool public immutable bv;\n    address immutable cp;\n\n    mapping(uint256 => uint256) public  m;\n    mapping(address => EnumerableSet.UintSet) internal cm;\n    mapping(uint256 => uint256) public  k;\n\n    mapping(uint256 => uint256) public  cn;\n\n    mapping(uint256 => uint256) public  ab;\n\n    event RewardAdded(uint256 cs);\n    event Deposit(address indexed dj, uint256 cr);\n    event Withdraw(address indexed dj, uint256 cr);\n    event Harvest(address indexed dj, uint256 cs);\n    event ClaimFees(address indexed from, uint256 cc, uint256 cd);\n    event EmergencyActivated(address indexed dg, uint256 timestamp);\n    event EmergencyDeactivated(address indexed dg, uint256 timestamp);\n\n    constructor(address am, address cv, address dl, address dd, address ak, address aa,\n        address x, bool az, address dk,  address bz) {\n        cp = bz;\n        at = IERC20(am);\n        df = cv;\n        VE = dl;\n        au = dd;\n        db = ICLPool(dd);\n        DISTRIBUTION = ak;\n        DURATION = HybraTimeLibrary.WEEK;\n\n        af = aa;\n        ad = x;\n        bv = az;\n        b = INonfungiblePositionManager(dk);\n        bq = false;\n    }\n\n    modifier r() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier ae() {\n        require(bq == false, \"emergency\");\n        _;\n    }\n\n    function ag(uint256 co, int24 bu, int24 bm) internal {\n        if (ab[co] == block.timestamp) return;\n        db.c();\n        ab[co] = block.timestamp;\n        cn[co] += cl(co);\n        k[co] = db.h(bu, bm, 0);\n    }\n\n    function g() external br {\n        require(bq == false, \"emergency\");\n        bq = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function o() external br {\n\n        require(bq == true,\"emergency\");\n\n        bq = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function bw(uint256 co) external view returns (uint256) {\n        (,,,,,,,uint128 bs,,,,) = b.bi(co);\n        return bs;\n    }\n\n    function y(address cx, address dc, int24 ay) internal view returns (address) {\n        return ICLFactory(b.cp()).cj(cx, dc, ay);\n    }\n\n    function da(uint256 co) external view returns (uint256 cs) {\n        require(cm[msg.sender].ce(co), \"NA\");\n\n        uint256 cs = cl(co);\n        return (cs);\n    }\n\n       function cl(uint256 co) internal view returns (uint256) {\n        uint256 as = db.as();\n\n        uint256 bx = block.timestamp - as;\n\n        uint256 f = db.f();\n        uint256 aj = db.aj();\n\n        if (bx != 0 && aj > 0 && db.w() > 0) {\n            uint256 cs = be * bx;\n            if (cs > aj) cs = aj;\n\n            f += FullMath.cu(cs, FixedPoint128.Q128, db.w());\n        }\n\n        (,,,,, int24 bu, int24 bm, uint128 bs,,,,) = b.bi(co);\n\n        uint256 a = k[co];\n        uint256 d = db.h(bu, bm, f);\n\n        uint256 bk =\n            FullMath.cu(d - a, bs, FixedPoint128.Q128);\n        return bk;\n    }\n\n    function ch(uint256 co) external an ae {\n\n         (,,address cx, address dc, int24 ay, int24 bu, int24 bm, uint128 bs,,,,) =\n            b.bi(co);\n\n        require(bs > 0, \"Gauge: zero liquidity\");\n\n        address ao = y(cx, dc, ay);\n\n        require(ao == au, \"Pool mismatch: Position not for this gauge pool\");\n\n        b.cg(INonfungiblePositionManager.CollectParams({\n                co: co,\n                bp: msg.sender,\n                bh: type(uint128).dn,\n                bf: type(uint128).dn\n            }));\n\n        b.u(msg.sender, address(this), co);\n\n        db.dh(int128(bs), bu, bm, true);\n\n        uint256 ap = db.h(bu, bm, 0);\n        k[co] = ap;\n        ab[co] = block.timestamp;\n\n        cm[msg.sender].dm(co);\n\n        emit Deposit(msg.sender, co);\n    }\n\n    function ca(uint256 co, uint8 bd) external an ae {\n           require(cm[msg.sender].ce(co), \"NA\");\n\n\n        b.cg(\n            INonfungiblePositionManager.CollectParams({\n                co: co,\n                bp: msg.sender,\n                bh: type(uint128).dn,\n                bf: type(uint128).dn\n            })\n        );\n\n        (,,,,, int24 bu, int24 bm, uint128 t,,,,) = b.bi(co);\n        bc(bu, bm, co, msg.sender, bd);\n\n\n        if (t != 0) {\n            db.dh(-int128(t), bu, bm, true);\n        }\n\n        cm[msg.sender].cz(co);\n        b.u(address(this), msg.sender, co);\n\n        emit Withdraw(msg.sender, co);\n    }\n\n    function bl(uint256 co, address cq,uint8 bd ) public an r {\n\n        require(cm[cq].ce(co), \"NA\");\n\n        (,,,,, int24 bu, int24 bm,,,,,) = b.bi(co);\n        bc(bu, bm, co, cq, bd);\n    }\n\n    function bc(int24 bu, int24 bm, uint256 co,address cq, uint8 bd) internal {\n        ag(co, bu, bm);\n        uint256 aq = cn[co];\n        if(aq > 0){\n            delete cn[co];\n            at.ax(df, aq);\n            IRHYBR(df).e(aq);\n            IRHYBR(df).bn(aq, bd, cq);\n        }\n        emit Harvest(msg.sender, aq);\n    }\n\n    function j(address de, uint256 aq) external an\n        ae r returns (uint256 aw) {\n        require(de == address(at), \"Invalid reward token\");\n\n\n        db.c();\n\n\n        uint256 l = HybraTimeLibrary.bj(block.timestamp) - block.timestamp;\n        uint256 p = block.timestamp + l;\n\n\n        uint256 n = aq + db.cb();\n\n\n        if (block.timestamp >= ah) {\n\n            be = aq / l;\n            db.bg({\n                be: be,\n                aj: n,\n                ar: p\n            });\n        } else {\n\n            uint256 ac = l * be;\n            be = (aq + ac) / l;\n            db.bg({\n                be: be,\n                aj: n + ac,\n                ar: p\n            });\n        }\n\n\n        m[HybraTimeLibrary.ba(block.timestamp)] = be;\n\n\n        at.u(DISTRIBUTION, address(this), aq);\n\n\n        uint256 z = at.bw(address(this));\n        require(be <= z / l, \"Insufficient balance for reward rate\");\n\n\n        ah = p;\n        aw = be;\n\n        emit RewardAdded(aq);\n    }\n\n    function ai() external view returns (uint256 cx, uint256 dc){\n\n        (cx, dc) = db.bt();\n\n    }\n\n    function bo() external an returns (uint256 cc, uint256 cd) {\n        return bb();\n    }\n\n    function bb() internal returns (uint256 cc, uint256 cd) {\n        if (!bv) {\n            return (0, 0);\n        }\n\n        db.av();\n\n        address ci = db.cx();\n        address cf = db.dc();\n\n        cc = IERC20(ci).bw(address(this));\n        cd = IERC20(cf).bw(address(this));\n\n        if (cc > 0 || cd > 0) {\n\n            uint256 cy = cc;\n            uint256 ct = cd;\n\n            if (cy  > 0) {\n                IERC20(ci).ax(af, 0);\n                IERC20(ci).ax(af, cy);\n                IBribe(af).j(ci, cy);\n            }\n            if (ct  > 0) {\n                IERC20(cf).ax(af, 0);\n                IERC20(cf).ax(af, ct);\n                IBribe(af).j(cf, ct);\n            }\n            emit ClaimFees(msg.sender, cc, cd);\n        }\n    }\n\n\n    function q() external view returns (uint256) {\n        return be * DURATION;\n    }\n\n\n    function s(address di) external br {\n        require(di >= address(0), \"zero\");\n        af = di;\n    }\n\n    function al(address de,address do,uint256 value) internal {\n        require(de.code.length > 0);\n        (bool ck, bytes memory data) = de.call(abi.i(IERC20.transfer.selector, do, value));\n        require(ck && (data.length == 0 || abi.cw(data, (bool))));\n    }\n\n\n    function v(\n        address by,\n        address from,\n        uint256 co,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver.v.selector;\n    }\n\n}",
      "rename_map": {
        "rewardPerTokenInsideInitialX128": "a",
        "nonfungiblePositionManager": "b",
        "updateRewardsGrowthGlobal": "c",
        "rewardPerTokenInsideX128": "d",
        "depostionEmissionsToken": "e",
        "rewardGrowthGlobalX128": "f",
        "activateEmergencyMode": "g",
        "getRewardGrowthInside": "h",
        "encodeWithSelector": "i",
        "notifyRewardAmount": "j",
        "rewardGrowthInside": "k",
        "epochTimeRemaining": "l",
        "rewardRateByEpoch": "m",
        "totalRewardAmount": "n",
        "stopEmergencyMode": "o",
        "epochEndTimestamp": "p",
        "rewardForDuration": "q",
        "onlyDistribution": "r",
        "setInternalBribe": "s",
        "liquidityToStake": "t",
        "safeTransferFrom": "u",
        "onERC721Received": "v",
        "stakedLiquidity": "w",
        "_external_bribe": "x",
        "_getPoolAddress": "y",
        "contractBalance": "z",
        "_internal_bribe": "aa",
        "lastUpdateTime": "ab",
        "pendingRewards": "ac",
        "external_bribe": "ad",
        "isNotEmergency": "ae",
        "internal_bribe": "af",
        "_updateRewards": "ag",
        "_periodFinish": "ah",
        "gaugeBalances": "ai",
        "rewardReserve": "aj",
        "_distribution": "ak",
        "_safeTransfer": "al",
        "_rewardToken": "am",
        "nonReentrant": "an",
        "positionPool": "ao",
        "rewardGrowth": "ap",
        "rewardAmount": "aq",
        "periodFinish": "ar",
        "lastUpdated": "as",
        "rewardToken": "at",
        "poolAddress": "au",
        "collectFees": "av",
        "currentRate": "aw",
        "safeApprove": "ax",
        "tickSpacing": "ay",
        "_isForPair": "az",
        "epochStart": "ba",
        "_claimFees": "bb",
        "_getReward": "bc",
        "redeemType": "bd",
        "rewardRate": "be",
        "amount1Max": "bf",
        "syncReward": "bg",
        "amount0Max": "bh",
        "positions": "bi",
        "epochNext": "bj",
        "claimable": "bk",
        "getReward": "bl",
        "tickUpper": "bm",
        "redeemFor": "bn",
        "claimFees": "bo",
        "recipient": "bp",
        "emergency": "bq",
        "onlyOwner": "br",
        "liquidity": "bs",
        "gaugeFees": "bt",
        "tickLower": "bu",
        "isForPair": "bv",
        "balanceOf": "bw",
        "timeDelta": "bx",
        "operator": "by",
        "_factory": "bz",
        "withdraw": "ca",
        "rollover": "cb",
        "claimed0": "cc",
        "claimed1": "cd",
        "contains": "ce",
        "_token1": "cf",
        "collect": "cg",
        "deposit": "ch",
        "_token0": "ci",
        "getPool": "cj",
        "success": "ck",
        "_earned": "cl",
        "_stakes": "cm",
        "rewards": "cn",
        "tokenId": "co",
        "factory": "cp",
        "account": "cq",
        "amount": "cr",
        "reward": "cs",
        "_fees1": "ct",
        "mulDiv": "cu",
        "_rHYBR": "cv",
        "decode": "cw",
        "token0": "cx",
        "_fees0": "cy",
        "remove": "cz",
        "earned": "da",
        "clPool": "db",
        "token1": "dc",
        "_pool": "dd",
        "token": "de",
        "rHYBR": "df",
        "gauge": "dg",
        "stake": "dh",
        "_int": "di",
        "user": "dj",
        "nfpm": "dk",
        "_ve": "dl",
        "add": "dm",
        "max": "dn",
        "to": "do"
      },
      "changes": [
        "Renamed 119 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_008",
      "transformed_id": "ss_l2_short_nc_gs_008",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": false,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    uint256 public l = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public d = 1200;\n    uint256 public a = 300;\n\n\n    uint256 public bk = 100;\n    uint256 public constant MIN_WITHDRAW_FEE = 10;\n    uint256 public constant MAX_WITHDRAW_FEE = 1000;\n    uint256 public constant BASIS = 10000;\n    address public Team;\n    uint256 public dp;\n    uint256 public dg;\n    uint256 public bl;\n\n    struct UserLock {\n        uint256 dq;\n        uint256 by;\n    }\n\n    mapping(address => UserLock[]) public cr;\n    mapping(address => uint256) public ai;\n\n\n    address public immutable HYBR;\n    address public immutable at;\n    address public eb;\n    address public k;\n    address public bb;\n    uint256 public co;\n\n\n    address public cx;\n    uint256 public aq;\n\n\n    uint256 public ad;\n    uint256 public p;\n\n\n    ISwapper public do;\n\n\n    error NOT_AUTHORIZED();\n\n\n    event Deposit(address indexed em, uint256 ce, uint256 ag);\n    event Withdraw(address indexed em, uint256 dt, uint256 ce, uint256 eq);\n    event Compound(uint256 dm, uint256 af);\n    event PenaltyRewardReceived(uint256 dq);\n    event TransferLockPeriodUpdated(uint256 cj, uint256 cq);\n    event SwapperUpdated(address indexed bx, address indexed bw);\n    event VoterSet(address eb);\n    event EmergencyUnlock(address indexed em);\n    event AutoVotingEnabled(bool di);\n    event OperatorUpdated(address indexed bt, address indexed bq);\n    event DefaultVotingStrategyUpdated(address[] ec, uint256[] dd);\n    event AutoVoteExecuted(uint256 ei, address[] ec, uint256[] dd);\n\n    constructor(\n        address ee,\n        address ak\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(ee != address(0), \"Invalid HYBR\");\n        require(ak != address(0), \"Invalid VE\");\n\n        HYBR = ee;\n        at = ak;\n        ad = block.timestamp;\n        p = block.timestamp;\n        cx = msg.sender;\n    }\n\n    function f(address j) external cn {\n        require(j != address(0), \"Invalid rewards distributor\");\n        k = j;\n    }\n\n    function x(address ar) external cn {\n        require(ar != address(0), \"Invalid gauge manager\");\n        bb = ar;\n    }\n\n\n    modifier av() {\n        if (msg.sender != cx) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n\n    function df(uint256 dq, address cl) external ax {\n        require(dq > 0, \"Zero amount\");\n        cl = cl == address(0) ? msg.sender : cl;\n\n\n        IERC20(HYBR).bc(msg.sender, address(this), dq);\n\n\n        if (co == 0) {\n            q(dq);\n        } else {\n\n            IERC20(HYBR).dl(at, dq);\n            IVotingEscrow(at).bh(co, dq);\n\n\n            o();\n        }\n\n\n        uint256 dt = aa(dq);\n\n\n        ek(cl, dt);\n\n\n        t(cl, dt);\n\n        emit Deposit(msg.sender, dq, dt);\n    }\n\n\n    function cz(uint256 dt) external ax returns (uint256 br) {\n        require(dt > 0, \"Zero shares\");\n        require(ct(msg.sender) >= dt, \"Insufficient balance\");\n        require(co != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(at).ea(co) == false, \"Cannot withdraw yet\");\n\n        uint256 cb = HybraTimeLibrary.cb(block.timestamp);\n        uint256 ch = HybraTimeLibrary.ch(block.timestamp);\n\n        require(block.timestamp >= cb + d && block.timestamp < ch - a, \"Cannot withdraw yet\");\n\n\n        uint256 ce = z(dt);\n        require(ce > 0, \"No assets to withdraw\");\n\n\n        uint256 cp = 0;\n        if (bk > 0) {\n            cp = (ce * bk) / BASIS;\n        }\n\n\n        uint256 bz = ce - cp;\n        require(bz > 0, \"Amount too small after fee\");\n\n\n        uint256 ck = bg();\n        require(ce <= ck, \"Insufficient veNFT balance\");\n\n        uint256 w = ck - bz - cp;\n        require(w >= 0, \"Cannot withdraw entire veNFT\");\n\n\n        el(msg.sender, dt);\n\n\n        uint256[] memory dn = new uint256[](3);\n        dn[0] = w;\n        dn[1] = bz;\n        dn[2] = cp;\n\n        uint256[] memory bm = IVotingEscrow(at).cf(co, dn);\n\n\n        co = bm[0];\n        br = bm[1];\n        uint256 bv = bm[2];\n\n        IVotingEscrow(at).r(address(this), msg.sender, br);\n        IVotingEscrow(at).r(address(this), Team, bv);\n        emit Withdraw(msg.sender, dt, bz, cp);\n    }\n\n\n    function q(uint256 ap) internal {\n\n        IERC20(HYBR).dl(at, type(uint256).ep);\n        uint256 cw = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n\n        co = IVotingEscrow(at).y(ap, cw, address(this));\n\n    }\n\n\n    function aa(uint256 dq) public view returns (uint256) {\n        uint256 aw = bf();\n        uint256 au = bg();\n        if (aw == 0 || au == 0) {\n            return dq;\n        }\n        return (dq * aw) / au;\n    }\n\n\n    function z(uint256 dt) public view returns (uint256) {\n        uint256 aw = bf();\n        if (aw == 0) {\n            return dt;\n        }\n        return (dt * bg()) / aw;\n    }\n\n\n    function bg() public view returns (uint256) {\n        if (co == 0) {\n            return 0;\n        }\n\n        IVotingEscrow.LockedBalance memory dw = IVotingEscrow(at).dw(co);\n        return uint256(int256(dw.dq));\n    }\n\n\n    function t(address em, uint256 dq) internal {\n        uint256 by = block.timestamp + l;\n        cr[em].push(UserLock({\n            dq: dq,\n            by: by\n        }));\n        ai[em] += dq;\n    }\n\n\n    function s(address em) external view returns (uint256 cs) {\n        uint256 bd = ct(em);\n        uint256 an = 0;\n\n        UserLock[] storage er = cr[em];\n        for (uint256 i = 0; i < er.length; i++) {\n            if (er[i].by > block.timestamp) {\n                an += er[i].dq;\n            }\n        }\n\n        return bd > an ? bd - an : 0;\n    }\n\n    function al(address em) internal returns (uint256 dy) {\n        UserLock[] storage er = cr[em];\n        uint256 et = er.length;\n        if (et == 0) return 0;\n\n        uint256 ed = 0;\n        unchecked {\n            for (uint256 i = 0; i < et; i++) {\n                UserLock memory L = er[i];\n                if (L.by <= block.timestamp) {\n                    dy += L.dq;\n                } else {\n                    if (ed != i) er[ed] = L;\n                    ed++;\n                }\n            }\n            if (dy > 0) {\n                ai[em] -= dy;\n            }\n            while (er.length > ed) {\n                er.pop();\n            }\n        }\n    }\n\n\n    function h(\n        address from,\n        address eu,\n        uint256 dq\n    ) internal override {\n        super.h(from, eu, dq);\n\n        if (from != address(0) && eu != address(0)) {\n            uint256 bd = ct(from);\n\n\n            uint256 n = bd > ai[from] ? bd - ai[from] : 0;\n\n\n            if (n >= dq) {\n                return;\n            }\n\n\n            al(from);\n            uint256 ae = bd > ai[from] ? bd - ai[from] : 0;\n\n\n            require(ae >= dq, \"Tokens locked\");\n        }\n    }\n\n\n    function ay() external av {\n        require(eb != address(0), \"Voter not set\");\n        require(k != address(0), \"Distributor not set\");\n\n\n        uint256  as = IRewardsDistributor(k).ef(co);\n        dp += as;\n\n        address[] memory cc = IVoter(eb).db(co);\n\n        for (uint256 i = 0; i < cc.length; i++) {\n            if (cc[i] != address(0)) {\n                address eg = IGaugeManager(bb).dv(cc[i]);\n\n                if (eg != address(0)) {\n\n                    address[] memory dr = new address[](1);\n                    address[][] memory du = new address[][](1);\n\n\n                    address aj = IGaugeManager(bb).u(eg);\n                    if (aj != address(0)) {\n                        uint256 ca = IBribe(aj).m();\n                        if (ca > 0) {\n                            address[] memory bn = new address[](ca);\n                            for (uint256 j = 0; j < ca; j++) {\n                                bn[j] = IBribe(aj).bn(j);\n                            }\n                            dr[0] = aj;\n                            du[0] = bn;\n\n                            IGaugeManager(bb).bo(dr, du, co);\n                        }\n                    }\n\n\n                    address ao = IGaugeManager(bb).ab(eg);\n                    if (ao != address(0)) {\n                        uint256 ca = IBribe(ao).m();\n                        if (ca > 0) {\n                            address[] memory bn = new address[](ca);\n                            for (uint256 j = 0; j < ca; j++) {\n                                bn[j] = IBribe(ao).bn(j);\n                            }\n                            dr[0] = ao;\n                            du[0] = bn;\n\n                            IGaugeManager(bb).bo(dr, du, co);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n\n    function bp(ISwapper.SwapParams calldata dk) external ax av {\n        require(address(do) != address(0), \"Swapper not set\");\n\n\n        uint256 az = IERC20(dk.dh).ct(address(this));\n        require(az >= dk.da, \"Insufficient token balance\");\n\n\n        IERC20(dk.dh).bs(address(do), dk.da);\n\n\n        uint256 ba = do.cd(dk);\n\n\n        IERC20(dk.dh).bs(address(do), 0);\n\n\n        bl += ba;\n    }\n\n\n    function dc() external av {\n\n\n        uint256 bu = IERC20(HYBR).ct(address(this));\n\n        if (bu > 0) {\n\n            IERC20(HYBR).bs(at, bu);\n            IVotingEscrow(at).bh(co, bu);\n\n\n            o();\n\n            p = block.timestamp;\n\n            emit Compound(bu, bg());\n        }\n    }\n\n\n    function eo(address[] calldata ci, uint256[] calldata cy) external {\n        require(msg.sender == ej() || msg.sender == cx, \"Not authorized\");\n        require(eb != address(0), \"Voter not set\");\n\n        IVoter(eb).eo(co, ci, cy);\n        aq = HybraTimeLibrary.cb(block.timestamp);\n\n    }\n\n\n    function eh() external {\n        require(msg.sender == ej() || msg.sender == cx, \"Not authorized\");\n        require(eb != address(0), \"Voter not set\");\n\n        IVoter(eb).eh(co);\n    }\n\n\n    function i(uint256 dq) external {\n\n\n        if (dq > 0) {\n            IERC20(HYBR).dl(at, dq);\n\n            if(co == 0){\n                q(dq);\n            } else{\n                IVotingEscrow(at).bh(co, dq);\n\n\n                o();\n            }\n        }\n        dg += dq;\n        emit PenaltyRewardReceived(dq);\n    }\n\n\n    function cu(address ds) external cn {\n        require(ds != address(0), \"Invalid voter\");\n        eb = ds;\n        emit VoterSet(ds);\n    }\n\n\n    function e(uint256 dj) external cn {\n        require(dj >= MIN_LOCK_PERIOD && dj <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 cj = l;\n        l = dj;\n        emit TransferLockPeriodUpdated(cj, dj);\n    }\n\n\n    function ac(uint256 en) external cn {\n        require(en >= MIN_WITHDRAW_FEE && en <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        bk = en;\n    }\n\n    function b(uint256 dz) external cn {\n        d = dz;\n    }\n\n    function c(uint256 dz) external cn {\n        a = dz;\n    }\n\n\n    function cg(address cv) external cn {\n        require(cv != address(0), \"Invalid swapper\");\n        address bx = address(do);\n        do = ISwapper(cv);\n        emit SwapperUpdated(bx, cv);\n    }\n\n\n    function de(address dx) external cn {\n        require(dx != address(0), \"Invalid team\");\n        Team = dx;\n    }\n\n\n    function v(address em) external av {\n        delete cr[em];\n        ai[em] = 0;\n        emit EmergencyUnlock(em);\n    }\n\n\n    function be(address em) external view returns (UserLock[] memory) {\n        return cr[em];\n    }\n\n\n    function bj(address cm) external cn {\n        require(cm != address(0), \"Invalid operator\");\n        address bt = cx;\n        cx = cm;\n        emit OperatorUpdated(bt, cm);\n    }\n\n\n    function ah() external view returns (uint256) {\n        if (co == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory dw = IVotingEscrow(at).dw(co);\n        return uint256(dw.es);\n    }\n\n\n    function o() internal {\n        if (co == 0) return;\n\n        IVotingEscrow.LockedBalance memory dw = IVotingEscrow(at).dw(co);\n        if (dw.bi || dw.es <= block.timestamp) return;\n\n        uint256 am = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n\n        if (am > dw.es + 2 hours) {\n            try IVotingEscrow(at).g(co, HybraTimeLibrary.MAX_LOCK_DURATION) {\n\n            } catch {\n\n\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "tail_not_withdraw_time": "a",
        "setHeadNotWithdrawTime": "b",
        "setTailNotWithdrawTime": "c",
        "head_not_withdraw_time": "d",
        "setTransferLockPeriod": "e",
        "setRewardsDistributor": "f",
        "increase_unlock_time": "g",
        "_beforeTokenTransfer": "h",
        "receivePenaltyReward": "i",
        "_rewardsDistributor": "j",
        "rewardsDistributor": "k",
        "transferLockPeriod": "l",
        "rewardsListLength": "m",
        "currentAvailable": "n",
        "_extendLockToMax": "o",
        "lastCompoundTime": "p",
        "_initializeVeNFT": "q",
        "safeTransferFrom": "r",
        "previewAvailable": "s",
        "_addTransferLock": "t",
        "internal_bribes": "u",
        "emergencyUnlock": "v",
        "remainingAmount": "w",
        "setGaugeManager": "x",
        "create_lock_for": "y",
        "calculateAssets": "z",
        "calculateShares": "aa",
        "external_bribes": "ab",
        "setWithdrawFee": "ac",
        "lastRebaseTime": "ad",
        "finalAvailable": "ae",
        "newTotalLocked": "af",
        "sharesReceived": "ag",
        "getLockEndTime": "ah",
        "lockedBalance": "ai",
        "internalBribe": "aj",
        "_votingEscrow": "ak",
        "_cleanExpired": "al",
        "maxUnlockTime": "am",
        "currentLocked": "an",
        "externalBribe": "ao",
        "initialAmount": "ap",
        "lastVoteEpoch": "aq",
        "_gaugeManager": "ar",
        "rebaseAmount": "as",
        "votingEscrow": "at",
        "_totalAssets": "au",
        "onlyOperator": "av",
        "_totalSupply": "aw",
        "nonReentrant": "ax",
        "claimRewards": "ay",
        "tokenBalance": "az",
        "hybrReceived": "ba",
        "gaugeManager": "bb",
        "transferFrom": "bc",
        "totalBalance": "bd",
        "getUserLocks": "be",
        "totalSupply": "bf",
        "totalAssets": "bg",
        "deposit_for": "bh",
        "isPermanent": "bi",
        "setOperator": "bj",
        "withdrawFee": "bk",
        "votingYield": "bl",
        "newTokenIds": "bm",
        "bribeTokens": "bn",
        "claimBribes": "bo",
        "executeSwap": "bp",
        "newOperator": "bq",
        "userTokenId": "br",
        "safeApprove": "bs",
        "oldOperator": "bt",
        "hybrBalance": "bu",
        "feeTokenId": "bv",
        "newSwapper": "bw",
        "oldSwapper": "bx",
        "unlockTime": "by",
        "userAmount": "bz",
        "tokenCount": "ca",
        "epochStart": "cb",
        "votedPools": "cc",
        "swapToHYBR": "cd",
        "hybrAmount": "ce",
        "multiSplit": "cf",
        "setSwapper": "cg",
        "epochNext": "ch",
        "_poolVote": "ci",
        "oldPeriod": "cj",
        "veBalance": "ck",
        "recipient": "cl",
        "_operator": "cm",
        "onlyOwner": "cn",
        "veTokenId": "co",
        "feeAmount": "cp",
        "newPeriod": "cq",
        "userLocks": "cr",
        "available": "cs",
        "balanceOf": "ct",
        "setVoter": "cu",
        "_swapper": "cv",
        "lockTime": "cw",
        "operator": "cx",
        "_weights": "cy",
        "withdraw": "cz",
        "amountIn": "da",
        "poolVote": "db",
        "compound": "dc",
        "weights": "dd",
        "setTeam": "de",
        "deposit": "df",
        "penalty": "dg",
        "tokenIn": "dh",
        "enabled": "di",
        "_period": "dj",
        "_params": "dk",
        "approve": "dl",
        "rewards": "dm",
        "amounts": "dn",
        "swapper": "do",
        "rebase": "dp",
        "amount": "dq",
        "bribes": "dr",
        "_voter": "ds",
        "shares": "dt",
        "tokens": "du",
        "gauges": "dv",
        "locked": "dw",
        "_team": "dx",
        "freed": "dy",
        "_time": "dz",
        "voted": "ea",
        "voter": "eb",
        "pools": "ec",
        "write": "ed",
        "_HYBR": "ee",
        "claim": "ef",
        "gauge": "eg",
        "reset": "eh",
        "epoch": "ei",
        "owner": "ej",
        "_mint": "ek",
        "_burn": "el",
        "user": "em",
        "_fee": "en",
        "vote": "eo",
        "max": "ep",
        "fee": "eq",
        "arr": "er",
        "end": "es",
        "len": "et",
        "to": "eu"
      },
      "changes": [
        "Renamed 151 identifiers using short style"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 482, column 9', 'Syntax error at line 482, column 12']"
    },
    {
      "original_id": "nc_gs_009",
      "transformed_id": "ss_l2_short_nc_gs_009",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": false,
      "code": "pragma solidity 0.8.13;\n\nimport {IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IHybra.sol\";\nimport {IHybraVotes} from \"./interfaces/IHybraVotes.sol\";\nimport {IVeArtProxy} from \"./interfaces/IVeArtProxy.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport {VotingDelegationLib} from \"./libraries/VotingDelegationLib.sol\";\nimport {VotingBalanceLogic} from \"./libraries/VotingBalanceLogic.sol\";\n\n\ncontract VotingEscrow is IERC721, IERC721Metadata, IHybraVotes {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n\n    event Deposit(\n        address indexed eo,\n        uint fp,\n        uint value,\n        uint indexed ew,\n        DepositType bq,\n        uint hs\n    );\n\n    event Merge(\n        address indexed fl,\n        uint256 indexed gn,\n        uint256 indexed hp,\n        uint256 cx,\n        uint256 ee,\n        uint256 bt,\n        uint256 du,\n        uint256 hm\n    );\n    event Split(\n        uint256 indexed gn,\n        uint256 indexed dx,\n        uint256 indexed ei,\n        address fl,\n        uint256 bm,\n        uint256 bn,\n        uint256 du,\n        uint256 hm\n    );\n\n    event MultiSplit(\n        uint256 indexed gn,\n        uint256[] bv,\n        address fl,\n        uint256[] eq,\n        uint256 du,\n        uint256 hm\n    );\n\n    event MetadataUpdate(uint256 ej);\n    event BatchMetadataUpdate(uint256 bx, uint256 cz);\n\n    event Withdraw(address indexed eo, uint fp, uint value, uint hs);\n    event LockPermanent(address indexed fu, uint256 indexed ej, uint256 fr, uint256 hm);\n    event UnlockPermanent(address indexed fu, uint256 indexed ej, uint256 fr, uint256 hm);\n    event Supply(uint di, uint gj);\n\n\n    address public immutable gs;\n    address public gp;\n    address public hi;\n    address public fa;\n\n\n    uint public PRECISISON = 10000;\n\n\n    mapping(bytes4 => bool) internal m;\n    mapping(uint => bool) internal ap;\n\n\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n\n    uint internal fp;\n\n    uint internal WEEK;\n\n    uint internal MAXTIME;\n    int128 internal em;\n    IHybra public gr;\n\n\n    VotingDelegationLib.Data private fy;\n\n    VotingBalanceLogic.Data private d;\n\n\n    constructor(address dn, address dy) {\n        gs = dn;\n        gp = msg.sender;\n        hi = msg.sender;\n        fa = dy;\n        WEEK = HybraTimeLibrary.WEEK;\n        MAXTIME = HybraTimeLibrary.MAX_LOCK_DURATION;\n        em = int128(int256(HybraTimeLibrary.MAX_LOCK_DURATION));\n\n        d.bc[0].ho = block.number;\n        d.bc[0].hs = block.timestamp;\n\n        m[ERC165_INTERFACE_ID] = true;\n        m[ERC721_INTERFACE_ID] = true;\n        m[ERC721_METADATA_INTERFACE_ID] = true;\n        gr = IHybra(gs);\n\n\n        emit Transfer(address(0), address(this), fp);\n\n        emit Transfer(address(this), address(0), fp);\n    }\n\n\n    uint8 internal constant bu = 1;\n    uint8 internal constant es = 2;\n    uint8 internal ao = 1;\n    modifier bo() {\n        require(ao == bu);\n        ao = es;\n        _;\n        ao = bu;\n    }\n\n    modifier bl(uint256 ej) {\n        require(!ap[ej], \"PNFT\");\n        _;\n    }\n\n    modifier bz(uint gn) {\n        require(fd[msg.sender] || fd[address(0)], \"!SPLIT\");\n        require(cv[gn] == 0 && !go[gn], \"ATT\");\n        require(r(msg.sender, gn), \"NAO\");\n        _;\n    }\n\n\n    string constant public he = \"veHYBR\";\n    string constant public gg = \"veHYBR\";\n    string constant public fg = \"1.0.0\";\n    uint8 constant public fb = 18;\n\n    function fe(address gm) external {\n        require(msg.sender == hi);\n        hi = gm;\n    }\n\n    function co(address ga) external {\n        require(msg.sender == hi);\n        fa = ga;\n        emit BatchMetadataUpdate(0, type(uint256).hn);\n    }\n\n\n    function ak(uint ej, bool df) external {\n        require(msg.sender == hi, \"NA\");\n        require(do[ej] != address(0), \"DNE\");\n        ap[ej] = df;\n    }\n\n\n    function ey(uint ej) external view returns (string memory) {\n        require(do[ej] != address(0), \"DNE\");\n        IVotingEscrow.LockedBalance memory fn = gk[ej];\n\n        return IVeArtProxy(fa).dz(ej,VotingBalanceLogic.by(ej, block.timestamp, d),fn.hq,uint(int256(fn.fr)));\n    }\n\n\n    mapping(uint => address) internal do;\n\n\n    mapping(address => uint) internal l;\n\n\n    function ff(uint ej) public view returns (address) {\n        return do[ej];\n    }\n\n    function e(address gx) public view returns (uint) {\n\n        return l[gx];\n    }\n\n\n    function fc(address fu) internal view returns (uint) {\n        return l[fu];\n    }\n\n\n    function eh(address fu) external view returns (uint) {\n        return fc(fu);\n    }\n\n\n    mapping(uint => address) internal bb;\n\n\n    mapping(address => mapping(address => bool)) internal z;\n\n    mapping(uint => uint) public aa;\n\n\n    function ct(uint ej) external view returns (address) {\n        return bb[ej];\n    }\n\n\n    function ac(address fu, address dv) external view returns (bool) {\n        return (z[fu])[dv];\n    }\n\n\n    function fm(address ds, uint ej) public {\n        address gx = do[ej];\n\n        require(gx != address(0), \"ZA\");\n\n        require(ds != gx, \"IA\");\n\n        bool bj = (do[ej] == msg.sender);\n        bool c = (z[gx])[msg.sender];\n        require(bj || c, \"NAO\");\n\n        bb[ej] = ds;\n        emit Approval(gx, ds, ej);\n    }\n\n\n    function w(address dv, bool ds) external {\n\n        assert(dv != msg.sender);\n        z[msg.sender][dv] = ds;\n        emit ApprovalForAll(msg.sender, dv, ds);\n    }\n\n\n    function at(address fu, uint ej) internal {\n\n        assert(do[ej] == fu);\n        if (bb[ej] != address(0)) {\n\n            bb[ej] = address(0);\n        }\n    }\n\n\n    function r(address ez, uint ej) internal view returns (bool) {\n        address gx = do[ej];\n        bool aw = gx == ez;\n        bool t = ez == bb[ej];\n        bool b = (z[gx])[ez];\n        return aw || t || b;\n    }\n\n    function s(address ez, uint ej) external view returns (bool) {\n        return r(ez, ej);\n    }\n\n\n    function bd(\n        address gn,\n        address hp,\n        uint ej,\n        address fl\n    ) internal bl(ej) {\n        require(cv[ej] == 0 && !go[ej], \"ATT\");\n\n        require(r(fl, ej), \"NAO\");\n\n\n        at(gn, ej);\n\n        ab(gn, ej);\n\n        VotingDelegationLib.n(fy, dr(gn), dr(hp), ej, ff);\n\n        cr(hp, ej);\n\n        aa[ej] = block.number;\n\n\n        emit Transfer(gn, hp, ej);\n    }\n\n\n    function ca(\n        address gn,\n        address hp,\n        uint ej\n    ) external {\n        bd(gn, hp, ej, msg.sender);\n    }\n\n\n    function ad(\n        address gn,\n        address hp,\n        uint ej\n    ) external {\n        ad(gn, hp, ej, \"\");\n    }\n\n    function cn(address fq) internal view returns (bool) {\n\n\n        uint hf;\n        assembly {\n            hf := extcodesize(fq)\n        }\n        return hf > 0;\n    }\n\n\n    function ad(\n        address gn,\n        address hp,\n        uint ej,\n        bytes memory gy\n    ) public {\n        bd(gn, hp, ej, msg.sender);\n\n        if (cn(hp)) {\n\n            try IERC721Receiver(hp).ae(msg.sender, gn, ej, gy) returns (bytes4 er) {\n                if (er != IERC721Receiver(hp).ae.selector) {\n                    revert(\"E721_RJ\");\n                }\n            } catch (bytes memory gb) {\n                if (gb.length == 0) {\n                    revert('E721_NRCV');\n                } else {\n                    assembly {\n                        revert(add(32, gb), mload(gb))\n                    }\n                }\n            }\n        }\n    }\n\n\n    function u(bytes4 cd) external view returns (bool) {\n        return m[cd];\n    }\n\n\n    mapping(address => mapping(uint => uint)) internal i;\n\n\n    mapping(uint => uint) internal v;\n\n\n    function k(address fu, uint cl) public view returns (uint) {\n        return i[fu][cl];\n    }\n\n\n    function h(address hp, uint ej) internal {\n        uint bi = fc(hp);\n\n        i[hp][bi] = ej;\n        v[ej] = bi;\n    }\n\n\n    function cr(address hp, uint ej) internal {\n\n        assert(do[ej] == address(0));\n\n        do[ej] = hp;\n\n        h(hp, ej);\n\n        l[hp] += 1;\n    }\n\n\n    function gz(address hp, uint ej) internal returns (bool) {\n\n        assert(hp != address(0));\n\n        VotingDelegationLib.n(fy, address(0), dr(hp), ej, ff);\n\n        cr(hp, ej);\n        emit Transfer(address(0), hp, ej);\n        return true;\n    }\n\n\n    function a(address gn, uint ej) internal {\n\n        uint bi = fc(gn) - 1;\n        uint bg = v[ej];\n\n        if (bi == bg) {\n\n            i[gn][bi] = 0;\n\n            v[ej] = 0;\n        } else {\n            uint cu = i[gn][bi];\n\n\n            i[gn][bg] = cu;\n\n            v[cu] = bg;\n\n\n            i[gn][bi] = 0;\n\n            v[ej] = 0;\n        }\n    }\n\n\n    function ab(address gn, uint ej) internal {\n\n        assert(do[ej] == gn);\n\n        do[ej] = address(0);\n\n        a(gn, ej);\n\n        l[gn] -= 1;\n    }\n\n    function ha(uint ej) internal {\n        require(r(msg.sender, ej), \"NAO\");\n\n        address gx = ff(ej);\n\n\n        delete bb[ej];\n\n\n        ab(gx, ej);\n\n        VotingDelegationLib.n(fy, dr(gx), address(0), ej, ff);\n\n        emit Transfer(gx, address(0), ej);\n    }\n\n\n    mapping(uint => IVotingEscrow.LockedBalance) public gk;\n    uint public f;\n    uint public gv;\n    mapping(uint => int128) public ba;\n    uint public gj;\n    mapping(address => bool) public fd;\n\n    uint internal constant MULTIPLIER = 1 ether;\n\n\n    function j(uint ej) external view returns (int128) {\n        uint fv = d.af[ej];\n        return d.o[ej][fv].hb;\n    }\n\n\n    function o(uint ej, uint hg) external view returns (IVotingEscrow.Point memory) {\n        return d.o[ej][hg];\n    }\n\n    function bc(uint gv) external view returns (IVotingEscrow.Point memory) {\n        return d.bc[gv];\n    }\n\n    function af(uint fp) external view returns (uint) {\n        return d.af[fp];\n    }\n\n\n    function cw(\n        uint ej,\n        IVotingEscrow.LockedBalance memory de,\n        IVotingEscrow.LockedBalance memory dd\n    ) internal {\n        IVotingEscrow.Point memory hd;\n        IVotingEscrow.Point memory hc;\n        int128 da = 0;\n        int128 dh = 0;\n        uint ge = gv;\n\n        if (ej != 0) {\n            hc.dt = 0;\n\n            if(dd.cj){\n                hc.dt = uint(int256(dd.fr));\n            }\n\n\n            if (de.hq > block.timestamp && de.fr > 0) {\n                hd.hb = de.fr / em;\n                hd.hj = hd.hb * int128(int256(de.hq - block.timestamp));\n            }\n            if (dd.hq > block.timestamp && dd.fr > 0) {\n                hc.hb = dd.fr / em;\n                hc.hj = hc.hb * int128(int256(dd.hq - block.timestamp));\n            }\n\n\n            da = ba[de.hq];\n            if (dd.hq != 0) {\n                if (dd.hq == de.hq) {\n                    dh = da;\n                } else {\n                    dh = ba[dd.hq];\n                }\n            }\n        }\n\n        IVotingEscrow.Point memory db = IVotingEscrow.Point({hj: 0, hb: 0, hs: block.timestamp, ho: block.number, dt: 0});\n        if (ge > 0) {\n            db = d.bc[ge];\n        }\n        uint ai = db.hs;\n\n\n        IVotingEscrow.Point memory p = db;\n        uint cf = 0;\n        if (block.timestamp > db.hs) {\n            cf = (MULTIPLIER * (block.number - db.ho)) / (block.timestamp - db.hs);\n        }\n\n\n        {\n            uint hk = (ai / WEEK) * WEEK;\n            for (uint i = 0; i < 255; ++i) {\n\n\n                hk += WEEK;\n                int128 fi = 0;\n                if (hk > block.timestamp) {\n                    hk = block.timestamp;\n                } else {\n                    fi = ba[hk];\n                }\n                db.hj -= db.hb * int128(int256(hk - ai));\n                db.hb += fi;\n                if (db.hj < 0) {\n\n                    db.hj = 0;\n                }\n                if (db.hb < 0) {\n\n                    db.hb = 0;\n                }\n                ai = hk;\n                db.hs = hk;\n                db.ho = p.ho + (cf * (hk - p.hs)) / MULTIPLIER;\n                ge += 1;\n                if (hk == block.timestamp) {\n                    db.ho = block.number;\n                    break;\n                } else {\n                    d.bc[ge] = db;\n                }\n            }\n        }\n\n        gv = ge;\n\n\n        if (ej != 0) {\n\n\n            db.hb += (hc.hb - hd.hb);\n            db.hj += (hc.hj - hd.hj);\n            if (db.hb < 0) {\n                db.hb = 0;\n            }\n            if (db.hj < 0) {\n                db.hj = 0;\n            }\n            db.dt = f;\n        }\n\n\n        d.bc[ge] = db;\n\n        if (ej != 0) {\n\n\n            if (de.hq > block.timestamp) {\n\n                da += hd.hb;\n                if (dd.hq == de.hq) {\n                    da -= hc.hb;\n                }\n                ba[de.hq] = da;\n            }\n\n            if (dd.hq > block.timestamp) {\n                if (dd.hq > de.hq) {\n                    dh -= hc.hb;\n                    ba[dd.hq] = dh;\n                }\n\n            }\n\n            uint dk = d.af[ej] + 1;\n\n            d.af[ej] = dk;\n            hc.hs = block.timestamp;\n            hc.ho = block.number;\n            d.o[ej][dk] = hc;\n        }\n    }\n\n\n    function bp(\n        uint ej,\n        uint fw,\n        uint cm,\n        IVotingEscrow.LockedBalance memory au,\n        DepositType bq\n    ) internal {\n        IVotingEscrow.LockedBalance memory fn = au;\n        uint bh = gj;\n\n        gj = bh + fw;\n        IVotingEscrow.LockedBalance memory de;\n        (de.fr, de.hq, de.cj) = (fn.fr, fn.hq, fn.cj);\n\n        fn.fr += int128(int256(fw));\n\n        if (cm != 0) {\n            fn.hq = cm;\n        }\n        gk[ej] = fn;\n\n\n        cw(ej, de, fn);\n\n        address from = msg.sender;\n        if (fw != 0) {\n            assert(IERC20(gs).ca(from, address(this), fw));\n        }\n\n        emit Deposit(from, ej, fw, fn.hq, bq, block.timestamp);\n        emit Supply(bh, bh + fw);\n    }\n\n\n    function dl() external {\n        cw(0, IVotingEscrow.LockedBalance(0, 0, false), IVotingEscrow.LockedBalance(0, 0, false));\n    }\n\n\n    function ci(uint ej, uint fw) external bo {\n        IVotingEscrow.LockedBalance memory fn = gk[ej];\n\n        require(fw > 0, \"ZV\");\n        require(fn.fr > 0, 'ZL');\n        require(fn.hq > block.timestamp || fn.cj, 'EXP');\n\n        if (fn.cj) f += fw;\n\n        bp(ej, fw, 0, fn, DepositType.DEPOSIT_FOR_TYPE);\n\n        if(go[ej]) {\n            IVoter(gp).hh(ej);\n        }\n    }\n\n\n    function bs(uint fw, uint aq, address hp) internal returns (uint) {\n        uint cm = (block.timestamp + aq) / WEEK * WEEK;\n\n        require(fw > 0, \"ZV\");\n        require(cm > block.timestamp && (cm <= block.timestamp + MAXTIME), 'IUT');\n\n        ++fp;\n        uint ej = fp;\n        gz(hp, ej);\n\n        IVotingEscrow.LockedBalance memory fn = gk[ej];\n\n        bp(ej, fw, cm, fn, DepositType.CREATE_LOCK_TYPE);\n        return ej;\n    }\n\n\n    function cy(uint fw, uint aq) external bo returns (uint) {\n        return bs(fw, aq, msg.sender);\n    }\n\n\n    function al(uint fw, uint aq, address hp) external bo returns (uint) {\n        return bs(fw, aq, hp);\n    }\n\n\n    function am(uint ej, uint fw) external bo {\n        assert(r(msg.sender, ej));\n\n        IVotingEscrow.LockedBalance memory fn = gk[ej];\n\n        assert(fw > 0);\n        require(fn.fr > 0, 'ZL');\n        require(fn.hq > block.timestamp || fn.cj, 'EXP');\n\n        if (fn.cj) f += fw;\n        bp(ej, fw, 0, fn, DepositType.INCREASE_LOCK_AMOUNT);\n\n\n        if(go[ej]) {\n            IVoter(gp).hh(ej);\n        }\n        emit MetadataUpdate(ej);\n    }\n\n\n    function g(uint ej, uint aq) external bo {\n        assert(r(msg.sender, ej));\n\n        IVotingEscrow.LockedBalance memory fn = gk[ej];\n        require(!fn.cj, \"!NORM\");\n        uint cm = (block.timestamp + aq) / WEEK * WEEK;\n\n        require(fn.hq > block.timestamp && fn.fr > 0, 'EXP||ZV');\n        require(cm > fn.hq && (cm <= block.timestamp + MAXTIME), 'IUT');\n\n        bp(ej, 0, cm, fn, DepositType.INCREASE_UNLOCK_TIME);\n\n\n        if(go[ej]) {\n            IVoter(gp).hh(ej);\n        }\n        emit MetadataUpdate(ej);\n    }\n\n\n    function ev(uint ej) external bo {\n        assert(r(msg.sender, ej));\n        require(cv[ej] == 0 && !go[ej], \"ATT\");\n\n        IVotingEscrow.LockedBalance memory fn = gk[ej];\n        require(!fn.cj, \"!NORM\");\n        require(block.timestamp >= fn.hq, \"!EXP\");\n        uint value = uint(int256(fn.fr));\n\n        gk[ej] = IVotingEscrow.LockedBalance(0, 0, false);\n        uint bh = gj;\n        gj = bh - value;\n\n\n        cw(ej, fn, IVotingEscrow.LockedBalance(0, 0, false));\n\n        assert(IERC20(gs).transfer(msg.sender, value));\n\n\n        ha(ej);\n\n        emit Withdraw(msg.sender, ej, value, block.timestamp);\n        emit Supply(bh, bh - value);\n    }\n\n    function be(uint ej) external {\n        address sender = msg.sender;\n        require(r(sender, ej), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory dg = gk[ej];\n        require(!dg.cj, \"!NORM\");\n        require(dg.hq > block.timestamp, \"EXP\");\n        require(dg.fr > 0, \"ZV\");\n\n        uint fk = uint(int256(dg.fr));\n        f += fk;\n        dg.hq = 0;\n        dg.cj = true;\n        cw(ej, gk[ej], dg);\n        gk[ej] = dg;\n        if(go[ej]) {\n            IVoter(gp).hh(ej);\n        }\n        emit LockPermanent(sender, ej, fk, block.timestamp);\n        emit MetadataUpdate(ej);\n    }\n\n    function aj(uint ej) external {\n        address sender = msg.sender;\n        require(r(msg.sender, ej), \"NAO\");\n\n        require(cv[ej] == 0 && !go[ej], \"ATT\");\n        IVotingEscrow.LockedBalance memory dg = gk[ej];\n        require(dg.cj, \"!NORM\");\n        uint fk = uint(int256(dg.fr));\n        f -= fk;\n        dg.hq = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n        dg.cj = false;\n\n        cw(ej, gk[ej], dg);\n        gk[ej] = dg;\n\n        emit UnlockPermanent(sender, ej, fk, block.timestamp);\n        emit MetadataUpdate(ej);\n    }\n\n\n    function by(uint ej) external view returns (uint) {\n        if (aa[ej] == block.number) return 0;\n        return VotingBalanceLogic.by(ej, block.timestamp, d);\n    }\n\n    function as(uint ej, uint hr) external view returns (uint) {\n        return VotingBalanceLogic.by(ej, hr, d);\n    }\n\n    function ay(uint ej, uint fx) external view returns (uint) {\n        return VotingBalanceLogic.ay(ej, fx, d, gv);\n    }\n\n\n    function bk(uint fx) external view returns (uint) {\n        return VotingBalanceLogic.bk(fx, gv, d, ba);\n    }\n\n    function ce() external view returns (uint) {\n        return ar(block.timestamp);\n    }\n\n\n    function ar(uint t) public view returns (uint) {\n        return VotingBalanceLogic.ar(t, gv, ba,  d);\n    }\n\n\n    mapping(uint => uint) public cv;\n    mapping(uint => bool) public go;\n\n    function el(address gh) external {\n        require(msg.sender == hi);\n        gp = gh;\n    }\n\n    function gl(uint ej) external {\n        require(msg.sender == gp);\n        go[ej] = true;\n    }\n\n    function fj(uint ej) external {\n        require(msg.sender == gp, \"NA\");\n        go[ej] = false;\n    }\n\n    function fz(uint ej) external {\n        require(msg.sender == gp, \"NA\");\n        cv[ej] = cv[ej] + 1;\n    }\n\n    function ft(uint ej) external {\n        require(msg.sender == gp, \"NA\");\n        cv[ej] = cv[ej] - 1;\n    }\n\n    function gw(uint gn, uint hp) external bo bl(gn) {\n        require(cv[gn] == 0 && !go[gn], \"ATT\");\n        require(gn != hp, \"SAME\");\n        require(r(msg.sender, gn) &&\n        r(msg.sender, hp), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory eu = gk[gn];\n        IVotingEscrow.LockedBalance memory et = gk[hp];\n        require(et.hq > block.timestamp ||  et.cj,\"EXP||PERM\");\n        require(eu.cj ? et.cj : true, \"!MERGE\");\n\n        uint fs = uint(int256(eu.fr));\n        uint hq = eu.hq >= et.hq ? eu.hq : et.hq;\n\n        gk[gn] = IVotingEscrow.LockedBalance(0, 0, false);\n        cw(gn, eu, IVotingEscrow.LockedBalance(0, 0, false));\n        ha(gn);\n\n        IVotingEscrow.LockedBalance memory cq;\n        cq.cj = et.cj;\n\n        if (cq.cj){\n            cq.fr = et.fr + eu.fr;\n            if (!eu.cj) {\n                f += fs;\n            }\n        }else{\n            cq.fr = et.fr + eu.fr;\n            cq.hq = hq;\n        }\n\n\n        cw(hp, et, cq);\n        gk[hp] = cq;\n\n        if(go[hp]) {\n            IVoter(gp).hh(hp);\n        }\n        emit Merge(\n            msg.sender,\n            gn,\n            hp,\n            uint(int256(eu.fr)),\n            uint(int256(et.fr)),\n            uint(int256(cq.fr)),\n            cq.hq,\n            block.timestamp\n        );\n        emit MetadataUpdate(hp);\n    }\n\n\n    function dm(\n        uint gn,\n        uint[] memory fo\n    ) external bo bz(gn) bl(gn) returns (uint256[] memory cs) {\n        require(fo.length >= 2 && fo.length <= 10, \"MIN2MAX10\");\n\n        address gx = do[gn];\n\n        IVotingEscrow.LockedBalance memory ax = gk[gn];\n        require(ax.hq > block.timestamp || ax.cj, \"EXP\");\n        require(ax.fr > 0, \"ZV\");\n\n\n        uint ck = 0;\n        for(uint i = 0; i < fo.length; i++) {\n            require(fo[i] > 0, \"ZW\");\n            ck += fo[i];\n        }\n\n\n        gk[gn] = IVotingEscrow.LockedBalance(0, 0, false);\n        cw(gn, ax, IVotingEscrow.LockedBalance(0, 0, false));\n        ha(gn);\n\n\n        cs = new uint256[](fo.length);\n        uint[] memory az = new uint[](fo.length);\n\n        for(uint i = 0; i < fo.length; i++) {\n            IVotingEscrow.LockedBalance memory ef = IVotingEscrow.LockedBalance({\n                fr: int128(int256(uint256(int256(ax.fr)) * fo[i] / ck)),\n                hq: ax.hq,\n                cj: ax.cj\n            });\n\n            cs[i] = an(gx, ef);\n            az[i] = uint256(int256(ef.fr));\n        }\n\n        emit MultiSplit(\n            gn,\n            cs,\n            msg.sender,\n            az,\n            ax.hq,\n            block.timestamp\n        );\n    }\n\n    function an(address hp, IVotingEscrow.LockedBalance memory dg) private returns (uint256 ej) {\n        ej = ++fp;\n        gk[ej] = dg;\n        cw(ej, IVotingEscrow.LockedBalance(0, 0, false), dg);\n        gz(hp, ej);\n    }\n\n    function ch(address ep, bool gt) external {\n        require(msg.sender == hi);\n        fd[ep] = gt;\n    }\n\n\n    bytes32 public constant DOMAIN_TYPEHASH = ec(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n\n    bytes32 public constant DELEGATION_TYPEHASH = ec(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n\n    mapping(address => address) private dj;\n\n\n    mapping(address => uint) public gf;\n\n\n    function dr(address ed) public view returns (address) {\n        address fh = dj[ed];\n        return fh == address(0) ? ed : fh;\n    }\n\n\n    function en(address fq) external view returns (uint) {\n        uint32 br = fy.av[fq];\n        if (br == 0) {\n            return 0;\n        }\n        uint[] storage dq = fy.cp[fq][br - 1].ek;\n        uint gq = 0;\n        for (uint i = 0; i < dq.length; i++) {\n            uint hl = dq[i];\n            gq = gq + VotingBalanceLogic.by(hl, block.timestamp, d);\n        }\n        return gq;\n    }\n\n    function bw(address fq, uint timestamp)\n        public\n        view\n        returns (uint)\n    {\n        uint32 cg = VotingDelegationLib.x(fy, fq, timestamp);\n\n        uint[] storage dq = fy.cp[fq][cg].ek;\n        uint gq = 0;\n        for (uint i = 0; i < dq.length; i++) {\n            uint hl = dq[i];\n\n            gq = gq + VotingBalanceLogic.by(hl, timestamp,  d);\n        }\n\n        return gq;\n    }\n\n    function q(uint256 timestamp) external view returns (uint) {\n        return ar(timestamp);\n    }\n\n\n    function eg(address ed, address ea) internal {\n\n        address ag = dr(ed);\n\n        dj[ed] = ea;\n\n        emit DelegateChanged(ed, ag, ea);\n        VotingDelegationLib.TokenHelpers memory cb = VotingDelegationLib.TokenHelpers({\n            dw: ff,\n            e: e,\n            k:k\n        });\n        VotingDelegationLib.y(fy, ed, ag, ea, cb);\n    }\n\n\n    function ex(address ea) public {\n        if (ea == address(0)) ea = msg.sender;\n        return eg(msg.sender, ea);\n    }\n\n    function bf(\n        address ea,\n        uint gu,\n        uint gi,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(ea != msg.sender, \"NA\");\n        require(ea != address(0), \"ZA\");\n\n        bytes32 ah = ec(\n            abi.gc(\n                DOMAIN_TYPEHASH,\n                ec(bytes(he)),\n                ec(bytes(fg)),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 dc = ec(\n            abi.gc(DELEGATION_TYPEHASH, ea, gu, gi)\n        );\n        bytes32 gd = ec(\n            abi.cc(\"\\x19\\x01\", ah, dc)\n        );\n        address eb = dp(gd, v, r, s);\n        require(\n            eb != address(0),\n            \"ZA\"\n        );\n        require(\n            gu == gf[eb]++,\n            \"!NONCE\"\n        );\n        require(\n            block.timestamp <= gi,\n            \"EXP\"\n        );\n        return eg(eb, ea);\n    }\n\n}",
      "rename_map": {
        "_removeTokenFromOwnerList": "a",
        "spenderIsApprovedForAll": "b",
        "senderIsApprovedForAll": "c",
        "votingBalanceLogicData": "d",
        "ownerToNFTokenCountFn": "e",
        "permanentLockBalance": "f",
        "increase_unlock_time": "g",
        "_addTokenToOwnerList": "h",
        "ownerToNFTokenIdList": "i",
        "get_last_user_slope": "j",
        "tokenOfOwnerByIndex": "k",
        "ownerToNFTokenCount": "l",
        "supportedInterfaces": "m",
        "moveTokenDelegates": "n",
        "user_point_history": "o",
        "initial_last_point": "p",
        "getPastTotalSupply": "q",
        "_isApprovedOrOwner": "r",
        "isApprovedOrOwner": "s",
        "spenderIsApproved": "t",
        "supportsInterface": "u",
        "tokenToOwnerIndex": "v",
        "setApprovalForAll": "w",
        "getPastVotesIndex": "x",
        "_moveAllDelegates": "y",
        "ownerToOperators": "z",
        "ownership_change": "aa",
        "_removeTokenFrom": "ab",
        "isApprovedForAll": "ac",
        "safeTransferFrom": "ad",
        "onERC721Received": "ae",
        "user_point_epoch": "af",
        "currentDelegate": "ag",
        "domainSeparator": "ah",
        "last_checkpoint": "ai",
        "unlockPermanent": "aj",
        "setPartnerVeNFT": "ak",
        "create_lock_for": "al",
        "increase_amount": "am",
        "_createSplitNFT": "an",
        "_entered_state": "ao",
        "isPartnerVeNFT": "ap",
        "_lock_duration": "aq",
        "totalSupplyAtT": "ar",
        "balanceOfNFTAt": "as",
        "_clearApproval": "at",
        "locked_balance": "au",
        "numCheckpoints": "av",
        "spenderIsOwner": "aw",
        "originalLocked": "ax",
        "balanceOfAtNFT": "ay",
        "actualAmounts": "az",
        "slope_changes": "ba",
        "idToApprovals": "bb",
        "point_history": "bc",
        "_transferFrom": "bd",
        "lockPermanent": "be",
        "delegateBySig": "bf",
        "current_index": "bg",
        "supply_before": "bh",
        "current_count": "bi",
        "senderIsOwner": "bj",
        "totalSupplyAt": "bk",
        "notPartnerNFT": "bl",
        "_splitAmount1": "bm",
        "_splitAmount2": "bn",
        "nonreentrant": "bo",
        "_deposit_for": "bp",
        "deposit_type": "bq",
        "nCheckpoints": "br",
        "_create_lock": "bs",
        "_amountFinal": "bt",
        "_not_entered": "bu",
        "_newTokenIds": "bv",
        "getPastVotes": "bw",
        "_fromTokenId": "bx",
        "balanceOfNFT": "by",
        "splitAllowed": "bz",
        "transferFrom": "ca",
        "tokenHelpers": "cb",
        "encodePacked": "cc",
        "_interfaceID": "cd",
        "totalSupply": "ce",
        "block_slope": "cf",
        "_checkIndex": "cg",
        "toggleSplit": "ch",
        "deposit_for": "ci",
        "isPermanent": "cj",
        "totalWeight": "ck",
        "_tokenIndex": "cl",
        "unlock_time": "cm",
        "_isContract": "cn",
        "setArtProxy": "co",
        "checkpoints": "cp",
        "newLockedTo": "cq",
        "_addTokenTo": "cr",
        "newTokenIds": "cs",
        "getApproved": "ct",
        "lastTokenId": "cu",
        "attachments": "cv",
        "_checkpoint": "cw",
        "_amountFrom": "cx",
        "create_lock": "cy",
        "_toTokenId": "cz",
        "old_dslope": "da",
        "last_point": "db",
        "structHash": "dc",
        "new_locked": "dd",
        "old_locked": "de",
        "_isPartner": "df",
        "_newLocked": "dg",
        "new_dslope": "dh",
        "prevSupply": "di",
        "_delegates": "dj",
        "user_epoch": "dk",
        "checkpoint": "dl",
        "multiSplit": "dm",
        "token_addr": "dn",
        "idToOwner": "do",
        "ecrecover": "dp",
        "_tokenIds": "dq",
        "delegates": "dr",
        "_approved": "ds",
        "permanent": "dt",
        "_locktime": "du",
        "_operator": "dv",
        "ownerOfFn": "dw",
        "_tokenId1": "dx",
        "art_proxy": "dy",
        "_tokenURI": "dz",
        "delegatee": "ea",
        "signatory": "eb",
        "keccak256": "ec",
        "delegator": "ed",
        "_amountTo": "ee",
        "newLocked": "ef",
        "_delegate": "eg",
        "balanceOf": "eh",
        "_tokenId2": "ei",
        "_tokenId": "ej",
        "tokenIds": "ek",
        "setVoter": "el",
        "iMAXTIME": "em",
        "getVotes": "en",
        "provider": "eo",
        "_account": "ep",
        "_amounts": "eq",
        "response": "er",
        "_entered": "es",
        "_locked1": "et",
        "_locked0": "eu",
        "withdraw": "ev",
        "locktime": "ew",
        "delegate": "ex",
        "tokenURI": "ey",
        "_spender": "ez",
        "artProxy": "fa",
        "decimals": "fb",
        "_balance": "fc",
        "canSplit": "fd",
        "setTeam": "fe",
        "ownerOf": "ff",
        "version": "fg",
        "current": "fh",
        "d_slope": "fi",
        "abstain": "fj",
        "_amount": "fk",
        "_sender": "fl",
        "approve": "fm",
        "_locked": "fn",
        "amounts": "fo",
        "tokenId": "fp",
        "account": "fq",
        "amount": "fr",
        "value0": "fs",
        "detach": "ft",
        "_owner": "fu",
        "uepoch": "fv",
        "_value": "fw",
        "_block": "fx",
        "cpData": "fy",
        "attach": "fz",
        "_proxy": "ga",
        "reason": "gb",
        "encode": "gc",
        "digest": "gd",
        "_epoch": "ge",
        "nonces": "gf",
        "symbol": "gg",
        "_voter": "gh",
        "expiry": "gi",
        "supply": "gj",
        "locked": "gk",
        "voting": "gl",
        "_team": "gm",
        "_from": "gn",
        "voted": "go",
        "voter": "gp",
        "votes": "gq",
        "_hybr": "gr",
        "token": "gs",
        "_bool": "gt",
        "nonce": "gu",
        "epoch": "gv",
        "merge": "gw",
        "owner": "gx",
        "_data": "gy",
        "_mint": "gz",
        "_burn": "ha",
        "slope": "hb",
        "u_new": "hc",
        "u_old": "hd",
        "name": "he",
        "size": "hf",
        "_idx": "hg",
        "poke": "hh",
        "team": "hi",
        "bias": "hj",
        "t_i": "hk",
        "tId": "hl",
        "_ts": "hm",
        "max": "hn",
        "blk": "ho",
        "_to": "hp",
        "end": "hq",
        "_t": "hr",
        "ts": "hs"
      },
      "changes": [
        "Renamed 227 identifiers using short style"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 388, column 9', 'Syntax error at line 388, column 11', 'Syntax error at line 438, column 9']"
    },
    {
      "original_id": "nc_gs_011",
      "transformed_id": "ss_l2_short_nc_gs_011",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n\ncontract MinVotingPowerCondition is PermissionCondition {\n\n    ILockToGovernBase public immutable k;\n\n\n    ILockManager public immutable f;\n\n\n    IERC20 public immutable l;\n\n\n    constructor(ILockToGovernBase i) {\n        k = i;\n        l = k.l();\n        f = k.f();\n    }\n\n\n    function h(address j, address n, bytes32 e, bytes calldata m)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (j, m, e);\n\n        uint256 d = l.g(n) + f.c(n);\n        uint256 a = k.b();\n\n        return d >= a;\n    }\n}",
      "rename_map": {
        "_minProposerVotingPower": "a",
        "minProposerVotingPower": "b",
        "getLockedBalance": "c",
        "_currentBalance": "d",
        "_permissionId": "e",
        "lockManager": "f",
        "balanceOf": "g",
        "isGranted": "h",
        "_plugin": "i",
        "_where": "j",
        "plugin": "k",
        "token": "l",
        "_data": "m",
        "_who": "n"
      },
      "changes": [
        "Renamed 14 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_012",
      "transformed_id": "ss_l2_short_nc_gs_012",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.e.selector ^ this.z.selector;\n\n\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = ba(\"CREATE_PROPOSAL_PERMISSION\");\n\n\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = ba(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 aq, address bo);\n\n    error VoteRemovalForbidden(uint256 aq, address bo);\n\n\n    function av(\n        IDAO bt,\n        ILockManager ag,\n        VotingSettings calldata s,\n        IPlugin.TargetConfig calldata ad,\n        bytes calldata p\n    ) external a ab(1) {\n        __MajorityVotingBase_init(bt, s, ad, p);\n        __LockToGovernBase_init(ag);\n\n        emit MembershipContractAnnounced({l: address(ag.br())});\n    }\n\n\n    function k(bytes4 af)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return af == LOCK_TO_VOTE_INTERFACE_ID || af == type(ILockToVote).ah\n            || super.k(af);\n    }\n\n\n    function b() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n\n    function z(\n        bytes calldata ax,\n        Action[] memory be,\n        uint64 au,\n        uint64 bd,\n        bytes memory bs\n    ) external bu(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 aq) {\n        uint256 m;\n\n        if (bs.length != 0) {\n            (m) = abi.bl(bs, (uint256));\n        }\n\n        if (i() == 0) {\n            revert NoVotingPower();\n        }\n\n\n        (au, bd) = c(au, bd);\n\n        aq = j(ba(abi.bm(be, ax)));\n\n        if (v(aq)) {\n            revert ProposalAlreadyExists(aq);\n        }\n\n\n        Proposal storage az = ay[aq];\n\n        az.at.as = as();\n        az.at.g = g();\n        az.at.aw = au;\n        az.at.bh = bd;\n        az.at.f = f();\n        az.at.n = n();\n\n        az.ae = t();\n\n\n        if (m != 0) {\n            az.w = m;\n        }\n\n        for (uint256 i; i < be.length;) {\n            az.bk.push(be[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(aq, ar(), au, bd, ax, be, m);\n\n        an.x(aq);\n    }\n\n\n    function bj(uint256 al, address bn, VoteOption ao) public view returns (bool) {\n        if (!v(al)) {\n            revert NonexistentProposal(al);\n        }\n\n        Proposal storage az = ay[al];\n        return bg(az, bn, ao, an.o(bn));\n    }\n\n\n    function bv(uint256 al, address bn, VoteOption ao, uint256 u)\n        public\n        override\n        bu(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage az = ay[al];\n\n        if (!bg(az, bn, ao, u)) {\n            revert VoteCastForbidden(al, bn);\n        }\n\n\n        if (ao == az.bq[bn].ap) {\n\n            if (u == az.bq[bn].am) return;\n\n\n            uint256 bw = u - az.bq[bn].am;\n            az.bq[bn].am = u;\n\n            if (az.bq[bn].ap == VoteOption.Yes) {\n                az.bp.bx += bw;\n            } else if (az.bq[bn].ap == VoteOption.No) {\n                az.bp.bz += bw;\n            } else {\n\n                az.bp.bi += bw;\n            }\n        } else {\n\n\n            if (az.bq[bn].am > 0) {\n\n                if (az.bq[bn].ap == VoteOption.Yes) {\n                    az.bp.bx -= az.bq[bn].am;\n                } else if (az.bq[bn].ap == VoteOption.No) {\n                    az.bp.bz -= az.bq[bn].am;\n                } else {\n\n                    az.bp.bi -= az.bq[bn].am;\n                }\n            }\n\n\n            if (ao == VoteOption.Yes) {\n                az.bp.bx += u;\n            } else if (ao == VoteOption.No) {\n                az.bp.bz += u;\n            } else {\n\n                az.bp.bi += u;\n            }\n            az.bq[bn].ap = ao;\n            az.bq[bn].am = u;\n        }\n\n        emit VoteCast(al, bn, ao, u);\n\n        if (az.at.as == VotingMode.EarlyExecution) {\n            d(al, ar());\n        }\n    }\n\n\n    function bb(uint256 al, address bn) external bu(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage az = ay[al];\n        if (!q(az)) {\n            revert VoteRemovalForbidden(al, bn);\n        } else if (az.at.as != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(al, bn);\n        } else if (az.bq[bn].am == 0) {\n\n            return;\n        }\n\n\n        if (az.bq[bn].ap == VoteOption.Yes) {\n            az.bp.bx -= az.bq[bn].am;\n        } else if (az.bq[bn].ap == VoteOption.No) {\n            az.bp.bz -= az.bq[bn].am;\n        }\n\n        else if (az.bq[bn].ap == VoteOption.Abstain) {\n            az.bp.bi -= az.bq[bn].am;\n        }\n        az.bq[bn].am = 0;\n\n        emit VoteCleared(al, bn);\n    }\n\n\n    function y(uint256 al) external view returns (bool) {\n        Proposal storage az = ay[al];\n        return q(az);\n    }\n\n\n    function e() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.e();\n    }\n\n\n    function i() public view override returns (uint256) {\n        return IERC20(an.br()).ai();\n    }\n\n\n    function r(uint256 al, address bn) public view returns (uint256) {\n        return ay[al].bq[bn].am;\n    }\n\n\n    function bg(Proposal storage az, address bn, VoteOption ao, uint256 u)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 h = az.bq[bn].am;\n\n\n        if (!q(az)) {\n            return false;\n        } else if (ao == VoteOption.None) {\n            return false;\n        }\n\n        else if (az.at.as != VotingMode.VoteReplacement) {\n\n            if (u <= h) {\n                return false;\n            }\n\n            else if (\n                az.bq[bn].ap != VoteOption.None\n                    && ao != az.bq[bn].ap\n            ) {\n                return false;\n            }\n        }\n\n        else {\n\n            if (u == 0 || u < h) {\n                return false;\n            }\n\n            else if (u == h && ao == az.bq[bn].ap) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function d(uint256 al, address aj) internal {\n        if (!ak(al)) {\n            return;\n        } else if (!by().aa(address(this), aj, EXECUTE_PROPOSAL_PERMISSION_ID, bf())) {\n            return;\n        }\n\n        bc(al);\n    }\n\n    function bc(uint256 al) internal override {\n        super.bc(al);\n\n\n        an.ac(al);\n    }\n\n\n    uint256[50] private __gap;\n}",
      "rename_map": {
        "onlyCallAtInitialization": "a",
        "customProposalParamsABI": "b",
        "_validateProposalDates": "c",
        "_attemptEarlyExecution": "d",
        "minProposerVotingPower": "e",
        "minParticipationRatio": "f",
        "supportThresholdRatio": "g",
        "_currentVotingPower": "h",
        "currentTokenSupply": "i",
        "_createProposalId": "j",
        "supportsInterface": "k",
        "definingContract": "l",
        "_allowFailureMap": "m",
        "minApprovalRatio": "n",
        "getLockedBalance": "o",
        "_pluginMetadata": "p",
        "_isProposalOpen": "q",
        "usedVotingPower": "r",
        "_votingSettings": "s",
        "getTargetConfig": "t",
        "_newVotingPower": "u",
        "_proposalExists": "v",
        "allowFailureMap": "w",
        "proposalCreated": "x",
        "isProposalOpen": "y",
        "createProposal": "z",
        "hasPermission": "aa",
        "reinitializer": "ab",
        "proposalEnded": "ac",
        "_targetConfig": "ad",
        "targetConfig": "ae",
        "_interfaceId": "af",
        "_lockManager": "ag",
        "interfaceId": "ah",
        "totalSupply": "ai",
        "_voteCaller": "aj",
        "_canExecute": "ak",
        "_proposalId": "al",
        "votingPower": "am",
        "lockManager": "an",
        "_voteOption": "ao",
        "voteOption": "ap",
        "proposalId": "aq",
        "_msgSender": "ar",
        "votingMode": "as",
        "parameters": "at",
        "_startDate": "au",
        "initialize": "av",
        "startDate": "aw",
        "_metadata": "ax",
        "proposals": "ay",
        "proposal_": "az",
        "keccak256": "ba",
        "clearVote": "bb",
        "_execute": "bc",
        "_endDate": "bd",
        "_actions": "be",
        "_msgData": "bf",
        "_canVote": "bg",
        "endDate": "bh",
        "abstain": "bi",
        "canVote": "bj",
        "actions": "bk",
        "decode": "bl",
        "encode": "bm",
        "_voter": "bn",
        "voter": "bo",
        "tally": "bp",
        "votes": "bq",
        "token": "br",
        "_data": "bs",
        "_dao": "bt",
        "auth": "bu",
        "vote": "bv",
        "diff": "bw",
        "yes": "bx",
        "dao": "by",
        "no": "bz"
      },
      "changes": [
        "Renamed 78 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_013",
      "transformed_id": "ss_l2_short_nc_gs_013",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n\n    IERC20 private immutable e;\n\n\n    constructor(LockManagerSettings memory h, IERC20 j) LockManagerBase(h) {\n        e = j;\n    }\n\n\n    function k() public view virtual returns (address j) {\n        return address(e);\n    }\n\n\n    function a() internal view virtual override returns (uint256) {\n        return e.g(msg.sender, address(this));\n    }\n\n\n    function c(uint256 i) internal virtual override {\n        e.d(msg.sender, address(this), i);\n    }\n\n\n    function b(address f, uint256 i) internal virtual override {\n        e.transfer(f, i);\n    }\n}",
      "rename_map": {
        "_incomingTokenBalance": "a",
        "_doUnlockTransfer": "b",
        "_doLockTransfer": "c",
        "transferFrom": "d",
        "erc20Token": "e",
        "_recipient": "f",
        "allowance": "g",
        "_settings": "h",
        "_amount": "i",
        "_token": "j",
        "token": "k"
      },
      "changes": [
        "Renamed 11 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_014",
      "transformed_id": "ss_l2_short_nc_gs_014",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n\n    IERC20 private immutable e;\n\n\n    constructor(LockManagerSettings memory h, IERC20 j) LockManagerBase(h) {\n        e = j;\n    }\n\n\n    function k() public view virtual returns (address j) {\n        return address(e);\n    }\n\n\n    function a() internal view virtual override returns (uint256) {\n        return e.g(msg.sender, address(this));\n    }\n\n\n    function c(uint256 i) internal virtual override {\n        e.d(msg.sender, address(this), i);\n    }\n\n\n    function b(address f, uint256 i) internal virtual override {\n        e.transfer(f, i);\n    }\n}",
      "rename_map": {
        "_incomingTokenBalance": "a",
        "_doUnlockTransfer": "b",
        "_doLockTransfer": "c",
        "transferFrom": "d",
        "erc20Token": "e",
        "_recipient": "f",
        "allowance": "g",
        "_settings": "h",
        "_amount": "i",
        "_token": "j",
        "token": "k"
      },
      "changes": [
        "Renamed 11 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_015",
      "transformed_id": "ss_l2_short_nc_gs_015",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n\n    LockManagerSettings public ac;\n\n\n    ILockToGovernBase public al;\n\n\n    mapping(address => uint256) private q;\n\n\n    EnumerableSet.UintSet internal k;\n\n\n    event BalanceLocked(address am, uint256 ah);\n\n\n    event BalanceUnlocked(address am, uint256 ah);\n\n\n    event ProposalEnded(uint256 x);\n\n\n    error InvalidPluginAddress();\n\n\n    error NoBalance();\n\n\n    error LocksStillActive();\n\n\n    error InvalidPlugin();\n\n\n    error InvalidPluginMode();\n\n\n    error SetPluginAddressForbidden();\n\n\n    constructor(LockManagerSettings memory aa) {\n        ac.y = aa.y;\n    }\n\n\n    function h(uint256 aj) public view virtual returns (uint256) {\n        return k.as(aj);\n    }\n\n\n    function b() public view virtual returns (uint256) {\n        return k.length();\n    }\n\n\n    function aq() public virtual {\n        an(c());\n    }\n\n\n    function aq(uint256 ae) public virtual {\n        an(ae);\n    }\n\n\n    function v(uint256 w, IMajorityVoting.VoteOption u) public virtual {\n        if (ac.y != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        an(c());\n        ao(w, u);\n    }\n\n\n    function v(uint256 w, IMajorityVoting.VoteOption u, uint256 ae) public virtual {\n        if (ac.y != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        an(ae);\n        ao(w, u);\n    }\n\n\n    function ap(uint256 w, IMajorityVoting.VoteOption u) public virtual {\n        if (ac.y != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        ao(w, u);\n    }\n\n\n    function l(address ad) public view virtual returns (uint256) {\n        return q[ad];\n    }\n\n\n    function af(uint256 w, address ai, IMajorityVoting.VoteOption u)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(al)).af(w, ai, u);\n    }\n\n\n    function ag() public virtual {\n        uint256 e = l(msg.sender);\n        if (e == 0) {\n            revert NoBalance();\n        }\n\n\n        a();\n\n\n        q[msg.sender] = 0;\n\n\n        i(msg.sender, e);\n        emit BalanceUnlocked(msg.sender, e);\n    }\n\n\n    function n(uint256 w) public virtual {\n        if (msg.sender != address(al)) {\n            revert InvalidPluginAddress();\n        }\n\n\n        k.ar(w);\n    }\n\n\n    function s(uint256 w) public virtual {\n        if (msg.sender != address(al)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(w);\n        k.ak(w);\n    }\n\n\n    function j(ILockToGovernBase g) public virtual {\n        if (address(al) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(g)).f(type(ILockToGovernBase).t)) {\n            revert InvalidPlugin();\n        }\n\n        else if (\n            ac.y == PluginMode.Voting\n                && !IERC165(address(g)).f(type(ILockToVote).t)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        al = g;\n    }\n\n\n    function c() internal view virtual returns (uint256);\n\n\n    function an(uint256 ae) internal virtual {\n        if (ae == 0) {\n            revert NoBalance();\n        }\n\n\n        m(ae);\n\n        q[msg.sender] += ae;\n        emit BalanceLocked(msg.sender, ae);\n    }\n\n\n    function m(uint256 ae) internal virtual;\n\n\n    function i(address z, uint256 ae) internal virtual;\n\n    function ao(uint256 w, IMajorityVoting.VoteOption u) internal virtual {\n        uint256 d = l(msg.sender);\n\n\n        ILockToVote(address(al)).ap(w, msg.sender, u, d);\n    }\n\n    function a() internal virtual {\n        uint256 r = k.length();\n        for (uint256 at; at < r;) {\n            uint256 w = k.as(at);\n            if (!al.p(w)) {\n                k.ak(w);\n                r = k.length();\n\n\n                if (at == r) {\n                    return;\n                }\n\n\n                continue;\n            }\n\n            if (al.o(w, msg.sender) > 0) {\n                ILockToVote(address(al)).ab(w, msg.sender);\n            }\n\n            unchecked {\n                at++;\n            }\n        }\n    }\n}",
      "rename_map": {
        "_withdrawActiveVotingPower": "a",
        "knownProposalIdsLength": "b",
        "_incomingTokenBalance": "c",
        "_currentVotingPower": "d",
        "_refundableBalance": "e",
        "supportsInterface": "f",
        "_newPluginAddress": "g",
        "knownProposalIdAt": "h",
        "_doUnlockTransfer": "i",
        "setPluginAddress": "j",
        "knownProposalIds": "k",
        "getLockedBalance": "l",
        "_doLockTransfer": "m",
        "proposalCreated": "n",
        "usedVotingPower": "o",
        "isProposalOpen": "p",
        "lockedBalances": "q",
        "_proposalCount": "r",
        "proposalEnded": "s",
        "interfaceId": "t",
        "_voteOption": "u",
        "lockAndVote": "v",
        "_proposalId": "w",
        "proposalId": "x",
        "pluginMode": "y",
        "_recipient": "z",
        "_settings": "aa",
        "clearVote": "ab",
        "settings": "ac",
        "_account": "ad",
        "_amount": "ae",
        "canVote": "af",
        "unlock": "ag",
        "amount": "ah",
        "_voter": "ai",
        "_index": "aj",
        "remove": "ak",
        "plugin": "al",
        "voter": "am",
        "_lock": "an",
        "_vote": "ao",
        "vote": "ap",
        "lock": "aq",
        "add": "ar",
        "at": "as",
        "_i": "at"
      },
      "changes": [
        "Renamed 46 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_016",
      "transformed_id": "ss_l2_short_nc_gs_016",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.e.selector ^ this.z.selector;\n\n\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = ba(\"CREATE_PROPOSAL_PERMISSION\");\n\n\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = ba(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 aq, address bo);\n\n    error VoteRemovalForbidden(uint256 aq, address bo);\n\n\n    function av(\n        IDAO bt,\n        ILockManager ag,\n        VotingSettings calldata s,\n        IPlugin.TargetConfig calldata ad,\n        bytes calldata p\n    ) external a ab(1) {\n        __MajorityVotingBase_init(bt, s, ad, p);\n        __LockToGovernBase_init(ag);\n\n        emit MembershipContractAnnounced({l: address(ag.br())});\n    }\n\n\n    function k(bytes4 af)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return af == LOCK_TO_VOTE_INTERFACE_ID || af == type(ILockToVote).ah\n            || super.k(af);\n    }\n\n\n    function b() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n\n    function z(\n        bytes calldata ax,\n        Action[] memory be,\n        uint64 au,\n        uint64 bd,\n        bytes memory bs\n    ) external bu(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 aq) {\n        uint256 m;\n\n        if (bs.length != 0) {\n            (m) = abi.bl(bs, (uint256));\n        }\n\n        if (i() == 0) {\n            revert NoVotingPower();\n        }\n\n\n        (au, bd) = c(au, bd);\n\n        aq = j(ba(abi.bm(be, ax)));\n\n        if (v(aq)) {\n            revert ProposalAlreadyExists(aq);\n        }\n\n\n        Proposal storage az = ay[aq];\n\n        az.at.as = as();\n        az.at.g = g();\n        az.at.aw = au;\n        az.at.bh = bd;\n        az.at.f = f();\n        az.at.n = n();\n\n        az.ae = t();\n\n\n        if (m != 0) {\n            az.w = m;\n        }\n\n        for (uint256 i; i < be.length;) {\n            az.bk.push(be[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(aq, ar(), au, bd, ax, be, m);\n\n        an.x(aq);\n    }\n\n\n    function bj(uint256 al, address bn, VoteOption ao) public view returns (bool) {\n        if (!v(al)) {\n            revert NonexistentProposal(al);\n        }\n\n        Proposal storage az = ay[al];\n        return bg(az, bn, ao, an.o(bn));\n    }\n\n\n    function bv(uint256 al, address bn, VoteOption ao, uint256 u)\n        public\n        override\n        bu(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage az = ay[al];\n\n        if (!bg(az, bn, ao, u)) {\n            revert VoteCastForbidden(al, bn);\n        }\n\n\n        if (ao == az.bq[bn].ap) {\n\n            if (u == az.bq[bn].am) return;\n\n\n            uint256 bw = u - az.bq[bn].am;\n            az.bq[bn].am = u;\n\n            if (az.bq[bn].ap == VoteOption.Yes) {\n                az.bp.bx += bw;\n            } else if (az.bq[bn].ap == VoteOption.No) {\n                az.bp.bz += bw;\n            } else {\n\n                az.bp.bi += bw;\n            }\n        } else {\n\n\n            if (az.bq[bn].am > 0) {\n\n                if (az.bq[bn].ap == VoteOption.Yes) {\n                    az.bp.bx -= az.bq[bn].am;\n                } else if (az.bq[bn].ap == VoteOption.No) {\n                    az.bp.bz -= az.bq[bn].am;\n                } else {\n\n                    az.bp.bi -= az.bq[bn].am;\n                }\n            }\n\n\n            if (ao == VoteOption.Yes) {\n                az.bp.bx += u;\n            } else if (ao == VoteOption.No) {\n                az.bp.bz += u;\n            } else {\n\n                az.bp.bi += u;\n            }\n            az.bq[bn].ap = ao;\n            az.bq[bn].am = u;\n        }\n\n        emit VoteCast(al, bn, ao, u);\n\n        if (az.at.as == VotingMode.EarlyExecution) {\n            d(al, ar());\n        }\n    }\n\n\n    function bb(uint256 al, address bn) external bu(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage az = ay[al];\n        if (!q(az)) {\n            revert VoteRemovalForbidden(al, bn);\n        } else if (az.at.as != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(al, bn);\n        } else if (az.bq[bn].am == 0) {\n\n            return;\n        }\n\n\n        if (az.bq[bn].ap == VoteOption.Yes) {\n            az.bp.bx -= az.bq[bn].am;\n        } else if (az.bq[bn].ap == VoteOption.No) {\n            az.bp.bz -= az.bq[bn].am;\n        }\n\n        else if (az.bq[bn].ap == VoteOption.Abstain) {\n            az.bp.bi -= az.bq[bn].am;\n        }\n        az.bq[bn].am = 0;\n\n        emit VoteCleared(al, bn);\n    }\n\n\n    function y(uint256 al) external view returns (bool) {\n        Proposal storage az = ay[al];\n        return q(az);\n    }\n\n\n    function e() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.e();\n    }\n\n\n    function i() public view override returns (uint256) {\n        return IERC20(an.br()).ai();\n    }\n\n\n    function r(uint256 al, address bn) public view returns (uint256) {\n        return ay[al].bq[bn].am;\n    }\n\n\n    function bg(Proposal storage az, address bn, VoteOption ao, uint256 u)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 h = az.bq[bn].am;\n\n\n        if (!q(az)) {\n            return false;\n        } else if (ao == VoteOption.None) {\n            return false;\n        }\n\n        else if (az.at.as != VotingMode.VoteReplacement) {\n\n            if (u <= h) {\n                return false;\n            }\n\n            else if (\n                az.bq[bn].ap != VoteOption.None\n                    && ao != az.bq[bn].ap\n            ) {\n                return false;\n            }\n        }\n\n        else {\n\n            if (u == 0 || u < h) {\n                return false;\n            }\n\n            else if (u == h && ao == az.bq[bn].ap) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function d(uint256 al, address aj) internal {\n        if (!ak(al)) {\n            return;\n        } else if (!by().aa(address(this), aj, EXECUTE_PROPOSAL_PERMISSION_ID, bf())) {\n            return;\n        }\n\n        bc(al);\n    }\n\n    function bc(uint256 al) internal override {\n        super.bc(al);\n\n\n        an.ac(al);\n    }\n\n\n    uint256[50] private __gap;\n}",
      "rename_map": {
        "onlyCallAtInitialization": "a",
        "customProposalParamsABI": "b",
        "_validateProposalDates": "c",
        "_attemptEarlyExecution": "d",
        "minProposerVotingPower": "e",
        "minParticipationRatio": "f",
        "supportThresholdRatio": "g",
        "_currentVotingPower": "h",
        "currentTokenSupply": "i",
        "_createProposalId": "j",
        "supportsInterface": "k",
        "definingContract": "l",
        "_allowFailureMap": "m",
        "minApprovalRatio": "n",
        "getLockedBalance": "o",
        "_pluginMetadata": "p",
        "_isProposalOpen": "q",
        "usedVotingPower": "r",
        "_votingSettings": "s",
        "getTargetConfig": "t",
        "_newVotingPower": "u",
        "_proposalExists": "v",
        "allowFailureMap": "w",
        "proposalCreated": "x",
        "isProposalOpen": "y",
        "createProposal": "z",
        "hasPermission": "aa",
        "reinitializer": "ab",
        "proposalEnded": "ac",
        "_targetConfig": "ad",
        "targetConfig": "ae",
        "_interfaceId": "af",
        "_lockManager": "ag",
        "interfaceId": "ah",
        "totalSupply": "ai",
        "_voteCaller": "aj",
        "_canExecute": "ak",
        "_proposalId": "al",
        "votingPower": "am",
        "lockManager": "an",
        "_voteOption": "ao",
        "voteOption": "ap",
        "proposalId": "aq",
        "_msgSender": "ar",
        "votingMode": "as",
        "parameters": "at",
        "_startDate": "au",
        "initialize": "av",
        "startDate": "aw",
        "_metadata": "ax",
        "proposals": "ay",
        "proposal_": "az",
        "keccak256": "ba",
        "clearVote": "bb",
        "_execute": "bc",
        "_endDate": "bd",
        "_actions": "be",
        "_msgData": "bf",
        "_canVote": "bg",
        "endDate": "bh",
        "abstain": "bi",
        "canVote": "bj",
        "actions": "bk",
        "decode": "bl",
        "encode": "bm",
        "_voter": "bn",
        "voter": "bo",
        "tally": "bp",
        "votes": "bq",
        "token": "br",
        "_data": "bs",
        "_dao": "bt",
        "auth": "bu",
        "vote": "bv",
        "diff": "bw",
        "yes": "bx",
        "dao": "by",
        "no": "bz"
      },
      "changes": [
        "Renamed 78 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_017",
      "transformed_id": "ss_l2_short_nc_gs_017",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n\ncontract MinVotingPowerCondition is PermissionCondition {\n\n    ILockToGovernBase public immutable k;\n\n\n    ILockManager public immutable f;\n\n\n    IERC20 public immutable l;\n\n\n    constructor(ILockToGovernBase i) {\n        k = i;\n        l = k.l();\n        f = k.f();\n    }\n\n\n    function h(address j, address n, bytes32 e, bytes calldata m)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (j, m, e);\n\n        uint256 d = l.g(n) + f.c(n);\n        uint256 a = k.b();\n\n        return d >= a;\n    }\n}",
      "rename_map": {
        "_minProposerVotingPower": "a",
        "minProposerVotingPower": "b",
        "getLockedBalance": "c",
        "_currentBalance": "d",
        "_permissionId": "e",
        "lockManager": "f",
        "balanceOf": "g",
        "isGranted": "h",
        "_plugin": "i",
        "_where": "j",
        "plugin": "k",
        "token": "l",
        "_data": "m",
        "_who": "n"
      },
      "changes": [
        "Renamed 14 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_018",
      "transformed_id": "ss_l2_short_nc_gs_018",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this.e.selector ^ this.z.selector;\n\n\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = ba(\"CREATE_PROPOSAL_PERMISSION\");\n\n\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = ba(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 aq, address bo);\n\n    error VoteRemovalForbidden(uint256 aq, address bo);\n\n\n    function av(\n        IDAO bt,\n        ILockManager ag,\n        VotingSettings calldata s,\n        IPlugin.TargetConfig calldata ad,\n        bytes calldata p\n    ) external a ab(1) {\n        __MajorityVotingBase_init(bt, s, ad, p);\n        __LockToGovernBase_init(ag);\n\n        emit MembershipContractAnnounced({l: address(ag.br())});\n    }\n\n\n    function k(bytes4 af)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return af == LOCK_TO_VOTE_INTERFACE_ID || af == type(ILockToVote).ah\n            || super.k(af);\n    }\n\n\n    function b() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n\n    function z(\n        bytes calldata ax,\n        Action[] memory be,\n        uint64 au,\n        uint64 bd,\n        bytes memory bs\n    ) external bu(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 aq) {\n        uint256 m;\n\n        if (bs.length != 0) {\n            (m) = abi.bl(bs, (uint256));\n        }\n\n        if (i() == 0) {\n            revert NoVotingPower();\n        }\n\n\n        (au, bd) = c(au, bd);\n\n        aq = j(ba(abi.bm(be, ax)));\n\n        if (v(aq)) {\n            revert ProposalAlreadyExists(aq);\n        }\n\n\n        Proposal storage az = ay[aq];\n\n        az.at.as = as();\n        az.at.g = g();\n        az.at.aw = au;\n        az.at.bh = bd;\n        az.at.f = f();\n        az.at.n = n();\n\n        az.ae = t();\n\n\n        if (m != 0) {\n            az.w = m;\n        }\n\n        for (uint256 i; i < be.length;) {\n            az.bk.push(be[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(aq, ar(), au, bd, ax, be, m);\n\n        an.x(aq);\n    }\n\n\n    function bj(uint256 al, address bn, VoteOption ao) public view returns (bool) {\n        if (!v(al)) {\n            revert NonexistentProposal(al);\n        }\n\n        Proposal storage az = ay[al];\n        return bg(az, bn, ao, an.o(bn));\n    }\n\n\n    function bv(uint256 al, address bn, VoteOption ao, uint256 u)\n        public\n        override\n        bu(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage az = ay[al];\n\n        if (!bg(az, bn, ao, u)) {\n            revert VoteCastForbidden(al, bn);\n        }\n\n\n        if (ao == az.bq[bn].ap) {\n\n            if (u == az.bq[bn].am) return;\n\n\n            uint256 bw = u - az.bq[bn].am;\n            az.bq[bn].am = u;\n\n            if (az.bq[bn].ap == VoteOption.Yes) {\n                az.bp.bx += bw;\n            } else if (az.bq[bn].ap == VoteOption.No) {\n                az.bp.bz += bw;\n            } else {\n\n                az.bp.bi += bw;\n            }\n        } else {\n\n\n            if (az.bq[bn].am > 0) {\n\n                if (az.bq[bn].ap == VoteOption.Yes) {\n                    az.bp.bx -= az.bq[bn].am;\n                } else if (az.bq[bn].ap == VoteOption.No) {\n                    az.bp.bz -= az.bq[bn].am;\n                } else {\n\n                    az.bp.bi -= az.bq[bn].am;\n                }\n            }\n\n\n            if (ao == VoteOption.Yes) {\n                az.bp.bx += u;\n            } else if (ao == VoteOption.No) {\n                az.bp.bz += u;\n            } else {\n\n                az.bp.bi += u;\n            }\n            az.bq[bn].ap = ao;\n            az.bq[bn].am = u;\n        }\n\n        emit VoteCast(al, bn, ao, u);\n\n        if (az.at.as == VotingMode.EarlyExecution) {\n            d(al, ar());\n        }\n    }\n\n\n    function bb(uint256 al, address bn) external bu(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage az = ay[al];\n        if (!q(az)) {\n            revert VoteRemovalForbidden(al, bn);\n        } else if (az.at.as != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(al, bn);\n        } else if (az.bq[bn].am == 0) {\n\n            return;\n        }\n\n\n        if (az.bq[bn].ap == VoteOption.Yes) {\n            az.bp.bx -= az.bq[bn].am;\n        } else if (az.bq[bn].ap == VoteOption.No) {\n            az.bp.bz -= az.bq[bn].am;\n        }\n\n        else if (az.bq[bn].ap == VoteOption.Abstain) {\n            az.bp.bi -= az.bq[bn].am;\n        }\n        az.bq[bn].am = 0;\n\n        emit VoteCleared(al, bn);\n    }\n\n\n    function y(uint256 al) external view returns (bool) {\n        Proposal storage az = ay[al];\n        return q(az);\n    }\n\n\n    function e() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase.e();\n    }\n\n\n    function i() public view override returns (uint256) {\n        return IERC20(an.br()).ai();\n    }\n\n\n    function r(uint256 al, address bn) public view returns (uint256) {\n        return ay[al].bq[bn].am;\n    }\n\n\n    function bg(Proposal storage az, address bn, VoteOption ao, uint256 u)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 h = az.bq[bn].am;\n\n\n        if (!q(az)) {\n            return false;\n        } else if (ao == VoteOption.None) {\n            return false;\n        }\n\n        else if (az.at.as != VotingMode.VoteReplacement) {\n\n            if (u <= h) {\n                return false;\n            }\n\n            else if (\n                az.bq[bn].ap != VoteOption.None\n                    && ao != az.bq[bn].ap\n            ) {\n                return false;\n            }\n        }\n\n        else {\n\n            if (u == 0 || u < h) {\n                return false;\n            }\n\n            else if (u == h && ao == az.bq[bn].ap) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function d(uint256 al, address aj) internal {\n        if (!ak(al)) {\n            return;\n        } else if (!by().aa(address(this), aj, EXECUTE_PROPOSAL_PERMISSION_ID, bf())) {\n            return;\n        }\n\n        bc(al);\n    }\n\n    function bc(uint256 al) internal override {\n        super.bc(al);\n\n\n        an.ac(al);\n    }\n\n\n    uint256[50] private __gap;\n}",
      "rename_map": {
        "onlyCallAtInitialization": "a",
        "customProposalParamsABI": "b",
        "_validateProposalDates": "c",
        "_attemptEarlyExecution": "d",
        "minProposerVotingPower": "e",
        "minParticipationRatio": "f",
        "supportThresholdRatio": "g",
        "_currentVotingPower": "h",
        "currentTokenSupply": "i",
        "_createProposalId": "j",
        "supportsInterface": "k",
        "definingContract": "l",
        "_allowFailureMap": "m",
        "minApprovalRatio": "n",
        "getLockedBalance": "o",
        "_pluginMetadata": "p",
        "_isProposalOpen": "q",
        "usedVotingPower": "r",
        "_votingSettings": "s",
        "getTargetConfig": "t",
        "_newVotingPower": "u",
        "_proposalExists": "v",
        "allowFailureMap": "w",
        "proposalCreated": "x",
        "isProposalOpen": "y",
        "createProposal": "z",
        "hasPermission": "aa",
        "reinitializer": "ab",
        "proposalEnded": "ac",
        "_targetConfig": "ad",
        "targetConfig": "ae",
        "_interfaceId": "af",
        "_lockManager": "ag",
        "interfaceId": "ah",
        "totalSupply": "ai",
        "_voteCaller": "aj",
        "_canExecute": "ak",
        "_proposalId": "al",
        "votingPower": "am",
        "lockManager": "an",
        "_voteOption": "ao",
        "voteOption": "ap",
        "proposalId": "aq",
        "_msgSender": "ar",
        "votingMode": "as",
        "parameters": "at",
        "_startDate": "au",
        "initialize": "av",
        "startDate": "aw",
        "_metadata": "ax",
        "proposals": "ay",
        "proposal_": "az",
        "keccak256": "ba",
        "clearVote": "bb",
        "_execute": "bc",
        "_endDate": "bd",
        "_actions": "be",
        "_msgData": "bf",
        "_canVote": "bg",
        "endDate": "bh",
        "abstain": "bi",
        "canVote": "bj",
        "actions": "bk",
        "decode": "bl",
        "encode": "bm",
        "_voter": "bn",
        "voter": "bo",
        "tally": "bp",
        "votes": "bq",
        "token": "br",
        "_data": "bs",
        "_dao": "bt",
        "auth": "bu",
        "vote": "bv",
        "diff": "bw",
        "yes": "bx",
        "dao": "by",
        "no": "bz"
      },
      "changes": [
        "Renamed 78 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_019",
      "transformed_id": "ss_l2_short_nc_gs_019",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.23;\n\nimport {ReentrancyGuardTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\n\ncontract MidasRedemptionVaultGateway is ReentrancyGuardTrait, IMidasRedemptionVaultGateway {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant override r = \"GATEWAY::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override ag = 3_10;\n\n    address public immutable d;\n    address public immutable ah;\n\n    mapping(address => PendingRedemption) public e;\n\n\n    constructor(address c) {\n        d = c;\n        ah = IMidasRedemptionVault(c).ah();\n    }\n\n\n    function p(address ab, uint256 l, uint256 f) external t {\n        IERC20(ah).g(msg.sender, address(this), l);\n\n        uint256 m = IERC20(ab).z(address(this));\n\n        IERC20(ah).u(d, l);\n        IMidasRedemptionVault(d).p(ab, l, f);\n\n        uint256 ai = IERC20(ab).z(address(this)) - m;\n\n        IERC20(ab).q(msg.sender, ai);\n    }\n\n\n    function n(address ab, uint256 l) external t {\n        if (e[msg.sender].ad) {\n            revert(\"MidasRedemptionVaultGateway: user has a pending redemption\");\n        }\n\n        uint256 x = IMidasRedemptionVault(d).h();\n\n        IERC20(ah).g(msg.sender, address(this), l);\n\n        IERC20(ah).u(d, l);\n        IMidasRedemptionVault(d).o(ab, l);\n\n        e[msg.sender] =\n            PendingRedemption({ad: true, x: x, timestamp: block.timestamp, aa: 0});\n    }\n\n\n    function ac(uint256 ai) external t {\n        PendingRedemption memory af = e[msg.sender];\n\n        if (!af.ad) {\n            revert(\"MidasRedemptionVaultGateway: user does not have a pending redemption\");\n        }\n\n        (\n            address sender,\n            address ab,\n            uint8 aj,\n            uint256 l,\n            uint256 w,\n            uint256 s\n        ) = IMidasRedemptionVault(d).k(af.x);\n\n        if (sender != address(this)) {\n            revert(\"MidasRedemptionVaultGateway: invalid request\");\n        }\n\n        if (aj != 1) {\n            revert(\"MidasRedemptionVaultGateway: redemption not fulfilled\");\n        }\n\n        uint256 i;\n\n        if (af.aa > 0) {\n            i = af.aa;\n        } else {\n            i = a(l, w, s, ab);\n        }\n\n        if (ai > i) {\n            revert(\"MidasRedemptionVaultGateway: amount exceeds available\");\n        }\n\n        if (ai == i) {\n            delete e[msg.sender];\n        } else {\n            e[msg.sender].aa = i - ai;\n        }\n\n        IERC20(ab).q(msg.sender, ai);\n    }\n\n\n    function b(address ak, address ab) external view returns (uint256) {\n        PendingRedemption memory af = e[ak];\n\n        if (!af.ad) {\n            return 0;\n        }\n\n        (address sender, address j,, uint256 l, uint256 w, uint256 s) =\n            IMidasRedemptionVault(d).k(af.x);\n\n        if (sender != address(this) || j != ab) {\n            return 0;\n        }\n\n        if (af.aa > 0) {\n            return af.aa;\n        } else {\n            return a(l, w, s, ab);\n        }\n    }\n\n\n    function a(\n        uint256 l,\n        uint256 w,\n        uint256 s,\n        address ab\n    ) internal view returns (uint256) {\n        uint256 v = (l * w) / s;\n\n        uint256 y = 10 ** IERC20Metadata(ab).ae();\n\n        return v * y / 1e18;\n    }\n}",
      "rename_map": {
        "_calculateTokenOutAmount": "a",
        "pendingTokenOutAmount": "b",
        "_midasRedemptionVault": "c",
        "midasRedemptionVault": "d",
        "pendingRedemptions": "e",
        "minReceiveAmount": "f",
        "safeTransferFrom": "g",
        "currentRequestId": "h",
        "availableAmount": "i",
        "requestTokenOut": "j",
        "redeemRequests": "k",
        "amountMTokenIn": "l",
        "balanceBefore": "m",
        "requestRedeem": "n",
        "redeemRequest": "o",
        "redeemInstant": "p",
        "safeTransfer": "q",
        "contractType": "r",
        "tokenOutRate": "s",
        "nonReentrant": "t",
        "forceApprove": "u",
        "amount1e18": "v",
        "mTokenRate": "w",
        "requestId": "x",
        "tokenUnit": "y",
        "balanceOf": "z",
        "remainder": "aa",
        "tokenOut": "ab",
        "withdraw": "ac",
        "isActive": "ad",
        "decimals": "ae",
        "pending": "af",
        "version": "ag",
        "mToken": "ah",
        "amount": "ai",
        "status": "aj",
        "user": "ak"
      },
      "changes": [
        "Renamed 37 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_020",
      "transformed_id": "ss_l2_short_nc_gs_020",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\nimport {NotImplementedException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultAdapter} from \"../../interfaces/midas/IMidasRedemptionVaultAdapter.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\nimport {WAD, RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\n\n\ncontract MidasRedemptionVaultAdapter is AbstractAdapter, IMidasRedemptionVaultAdapter {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 public constant override ab = \"ADAPTER::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override ap = 3_10;\n\n\n    address public immutable override au;\n\n\n    address public immutable override as;\n\n\n    mapping(address => address) public b;\n\n\n    mapping(address => address) public c;\n\n\n    EnumerableSet.AddressSet internal n;\n\n\n    constructor(address q, address ak) AbstractAdapter(q, ak) {\n        as = ak;\n        au = IMidasRedemptionVaultGateway(ak).au();\n\n        h(au);\n    }\n\n\n    function y(address aj, uint256 t, uint256 k)\n        external\n        override\n        i\n        returns (bool)\n    {\n        if (!r(aj)) revert TokenNotAllowedException();\n\n        m(aj, t, k);\n\n        return false;\n    }\n\n\n    function g(address aj, uint256 s, uint256 ae)\n        external\n        override\n        i\n        returns (bool)\n    {\n        if (!r(aj)) revert TokenNotAllowedException();\n\n        address x = p();\n\n        uint256 balance = IERC20(au).ai(x);\n        if (balance > s) {\n            unchecked {\n                uint256 av = balance - s;\n                uint256 k = (av * ae) / RAY;\n                m(aj, av, k);\n            }\n        }\n        return false;\n    }\n\n\n    function m(address aj, uint256 t, uint256 k) internal {\n        d(\n            au,\n            abi.ad(\n                IMidasRedemptionVaultGateway.y,\n                (aj, t, z(k, aj))\n            )\n        );\n    }\n\n\n    function w(address aj, uint256 t)\n        external\n        override\n        i\n        returns (bool)\n    {\n        if (!r(aj) || c[aj] == address(0)) {\n            revert TokenNotAllowedException();\n        }\n\n        d(\n            au, abi.ad(IMidasRedemptionVaultGateway.v, (aj, t))\n        );\n        return true;\n    }\n\n\n    function am(uint256 av) external override i returns (bool) {\n        ag(av);\n        return false;\n    }\n\n\n    function ag(uint256 av) internal {\n        al(abi.ad(IMidasRedemptionVaultGateway.am, (av)));\n    }\n\n\n    function e(address az, uint256 av) external override i returns (bool) {\n        if (b[az] == address(0)) revert IncorrectStakedPhantomTokenException();\n        ag(av);\n        return false;\n    }\n\n\n    function f(address, uint256) external pure override returns (bool) {\n        revert NotImplementedException();\n    }\n\n\n    function z(uint256 av, address az) internal view returns (uint256) {\n        uint256 af = 10 ** IERC20Metadata(az).ao();\n        return av * WAD / af;\n    }\n\n\n    function r(address az) public view override returns (bool) {\n        return n.an(az);\n    }\n\n\n    function aa() public view override returns (address[] memory) {\n        return n.aw();\n    }\n\n\n    function a(MidasAllowedTokenStatus[] calldata aq)\n        external\n        override\n        j\n    {\n        uint256 bb = aq.length;\n\n        for (uint256 i; i < bb; ++i) {\n            MidasAllowedTokenStatus memory ax = aq[i];\n\n            if (ax.ar) {\n                h(ax.az);\n                n.ba(ax.az);\n\n                if (ax.ac != address(0)) {\n                    h(ax.ac);\n                    b[ax.ac] = ax.az;\n                    c[ax.az] = ax.ac;\n                }\n            } else {\n                n.ay(ax.az);\n\n                address ac = c[ax.az];\n\n                if (ac != address(0)) {\n                    delete c[ax.az];\n                    delete b[ac];\n                }\n            }\n\n            emit SetTokenAllowedStatus(ax.az, ax.ac, ax.ar);\n        }\n    }\n\n\n    function ah() external view returns (bytes memory o) {\n        o = abi.at(u, l, as, au, aa());\n    }\n}",
      "rename_map": {
        "setTokenAllowedStatusBatch": "a",
        "phantomTokenToOutputToken": "b",
        "outputTokenToPhantomToken": "c",
        "_executeSwapSafeApprove": "d",
        "withdrawPhantomToken": "e",
        "depositPhantomToken": "f",
        "redeemInstantDiff": "g",
        "_getMaskOrRevert": "h",
        "creditFacadeOnly": "i",
        "configuratorOnly": "j",
        "minReceiveAmount": "k",
        "targetContract": "l",
        "_redeemInstant": "m",
        "_allowedTokens": "n",
        "serializedData": "o",
        "_creditAccount": "p",
        "_creditManager": "q",
        "isTokenAllowed": "r",
        "leftoverAmount": "s",
        "amountMTokenIn": "t",
        "creditManager": "u",
        "requestRedeem": "v",
        "redeemRequest": "w",
        "creditAccount": "x",
        "redeemInstant": "y",
        "_convertToE18": "z",
        "allowedTokens": "aa",
        "contractType": "ab",
        "phantomToken": "ac",
        "encodeCall": "ad",
        "rateMinRAY": "ae",
        "tokenUnit": "af",
        "_withdraw": "ag",
        "serialize": "ah",
        "balanceOf": "ai",
        "tokenOut": "aj",
        "_gateway": "ak",
        "_execute": "al",
        "withdraw": "am",
        "contains": "an",
        "decimals": "ao",
        "version": "ap",
        "configs": "aq",
        "allowed": "ar",
        "gateway": "as",
        "encode": "at",
        "mToken": "au",
        "amount": "av",
        "values": "aw",
        "config": "ax",
        "remove": "ay",
        "token": "az",
        "add": "ba",
        "len": "bb"
      },
      "changes": [
        "Renamed 54 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_021",
      "transformed_id": "ss_l2_short_nc_gs_021",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, x} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n\n  error NotPoolManager();\n\n\n  IPoolManager public immutable af;\n\n  constructor(\n    IPoolManager ad,\n    address ab,\n    address[] memory c,\n    address m,\n    address l\n  ) BaseKEMHook(ab, c, m, l) {\n    af = ad;\n    Hooks.d(IHooks(address(this)), o());\n  }\n\n\n  modifier v() {\n    if (msg.sender != address(af)) revert NotPoolManager();\n    _;\n  }\n\n\n  function z(address[] calldata bh, uint256[] calldata ay) public {\n    require(ao[msg.sender], NonClaimableAccount(msg.sender));\n    require(bh.length == ay.length, MismatchedArrayLengths());\n\n    af.bc(abi.bb(bh, ay));\n  }\n\n  function y(bytes calldata data) public v returns (bytes memory) {\n    (address[] memory bh, uint256[] memory ay) = abi.bf(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < bh.length; i++) {\n      uint256 bq = uint256(uint160(bh[i]));\n      if (ay[i] == 0) {\n        ay[i] = af.at(address(this), bq);\n      }\n      if (ay[i] > 0) {\n        af.bl(address(this), bq, ay[i]);\n        af.bn(Currency.bk(bh[i]), ah, ay[i]);\n      }\n    }\n\n    emit ClaimEgTokens(ah, bh, ay);\n  }\n\n  function o() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      s: false,\n      u: false,\n      j: false,\n      q: false,\n      e: false,\n      g: false,\n      am: true,\n      aq: true,\n      ac: false,\n      ai: false,\n      f: false,\n      h: true,\n      b: false,\n      a: false\n    });\n  }\n\n  function am(\n    address sender,\n    PoolKey calldata bp,\n    IPoolManager.SwapParams calldata bd,\n    bytes calldata ax\n  ) external v returns (bytes4, BeforeSwapDelta, uint24) {\n    require(bd.t < 0, ExactOutputDisabled());\n\n    (\n      int256 ae,\n      int256 w,\n      int256 r,\n      uint256 bi,\n      uint256 ak,\n      bytes memory ar\n    ) = HookDataDecoder.p(ax);\n\n    require(block.timestamp <= ak, ExpiredSignature(ak, block.timestamp));\n    require(\n      -bd.t <= ae,\n      ExceededMaxAmountIn(ae, -bd.t)\n    );\n\n    n(bi);\n\n    bytes32 be = ap(\n      abi.bb(\n        sender,\n        bp,\n        bd.al,\n        ae,\n        w,\n        r,\n        bi,\n        ak\n      )\n    );\n    require(\n      SignatureChecker.i(aj, be, ar), InvalidSignature()\n    );\n\n    return (this.am.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function aq(\n    address,\n    PoolKey calldata bp,\n    IPoolManager.SwapParams calldata bd,\n    BalanceDelta bj,\n    bytes calldata ax\n  ) external v returns (bytes4, int128) {\n    (int256 w, int256 r) =\n      HookDataDecoder.k(ax);\n\n    int128 aw;\n    int128 au;\n    Currency ag;\n    unchecked {\n      if (bd.al) {\n        aw = -bj.az();\n        au = bj.ba();\n        ag = bp.an;\n      } else {\n        aw = -bj.ba();\n        au = bj.az();\n        ag = bp.as;\n      }\n    }\n\n    int256 aa = aw * w / r;\n\n    unchecked {\n      int256 av = aa < au ? au - aa : int256(0);\n      if (av > 0) {\n        af.bo(\n          address(this), uint256(uint160(Currency.bg(ag))), uint256(av)\n        );\n\n        emit AbsorbEgToken(PoolId.bg(bp.bm()), Currency.bg(ag), av);\n      }\n\n      return (this.aq.selector, int128(av));\n    }\n  }\n}",
      "rename_map": {
        "afterRemoveLiquidityReturnDelta": "a",
        "afterAddLiquidityReturnDelta": "b",
        "initialClaimableAccounts": "c",
        "validateHookPermissions": "d",
        "beforeRemoveLiquidity": "e",
        "beforeSwapReturnDelta": "f",
        "afterRemoveLiquidity": "g",
        "afterSwapReturnDelta": "h",
        "isValidSignatureNow": "i",
        "beforeAddLiquidity": "j",
        "decodeExchangeRate": "k",
        "initialEgRecipient": "l",
        "initialQuoteSigner": "m",
        "_useUnorderedNonce": "n",
        "getHookPermissions": "o",
        "decodeAllHookData": "p",
        "afterAddLiquidity": "q",
        "exchangeRateDenom": "r",
        "beforeInitialize": "s",
        "amountSpecified": "t",
        "afterInitialize": "u",
        "onlyPoolManager": "v",
        "maxExchangeRate": "w",
        "toBalanceDelta": "x",
        "unlockCallback": "y",
        "claimEgTokens": "z",
        "maxAmountOut": "aa",
        "initialOwner": "ab",
        "beforeDonate": "ac",
        "_poolManager": "ad",
        "maxAmountIn": "ae",
        "poolManager": "af",
        "currencyOut": "ag",
        "egRecipient": "ah",
        "afterDonate": "ai",
        "quoteSigner": "aj",
        "expiryTime": "ak",
        "zeroForOne": "al",
        "beforeSwap": "am",
        "currency1": "an",
        "claimable": "ao",
        "keccak256": "ap",
        "afterSwap": "aq",
        "signature": "ar",
        "currency0": "as",
        "balanceOf": "at",
        "amountOut": "au",
        "egAmount": "av",
        "amountIn": "aw",
        "hookData": "ax",
        "amounts": "ay",
        "amount0": "az",
        "amount1": "ba",
        "encode": "bb",
        "unlock": "bc",
        "params": "bd",
        "digest": "be",
        "decode": "bf",
        "unwrap": "bg",
        "tokens": "bh",
        "nonce": "bi",
        "delta": "bj",
        "wrap": "bk",
        "burn": "bl",
        "toId": "bm",
        "take": "bn",
        "mint": "bo",
        "key": "bp",
        "id": "bq"
      },
      "changes": [
        "Renamed 69 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_022",
      "transformed_id": "ss_l2_short_nc_gs_022",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, x} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n\n  error NotPoolManager();\n\n\n  IPoolManager public immutable af;\n\n  constructor(\n    IPoolManager ad,\n    address ab,\n    address[] memory c,\n    address m,\n    address l\n  ) BaseKEMHook(ab, c, m, l) {\n    af = ad;\n    Hooks.d(IHooks(address(this)), o());\n  }\n\n\n  modifier v() {\n    if (msg.sender != address(af)) revert NotPoolManager();\n    _;\n  }\n\n\n  function z(address[] calldata bh, uint256[] calldata ay) public {\n    require(ao[msg.sender], NonClaimableAccount(msg.sender));\n    require(bh.length == ay.length, MismatchedArrayLengths());\n\n    af.bc(abi.bb(bh, ay));\n  }\n\n  function y(bytes calldata data) public v returns (bytes memory) {\n    (address[] memory bh, uint256[] memory ay) = abi.bf(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < bh.length; i++) {\n      uint256 bq = uint256(uint160(bh[i]));\n      if (ay[i] == 0) {\n        ay[i] = af.at(address(this), bq);\n      }\n      if (ay[i] > 0) {\n        af.bl(address(this), bq, ay[i]);\n        af.bn(Currency.bk(bh[i]), ah, ay[i]);\n      }\n    }\n\n    emit ClaimEgTokens(ah, bh, ay);\n  }\n\n  function o() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      s: false,\n      u: false,\n      j: false,\n      q: false,\n      e: false,\n      g: false,\n      am: true,\n      aq: true,\n      ac: false,\n      ai: false,\n      f: false,\n      h: true,\n      b: false,\n      a: false\n    });\n  }\n\n  function am(\n    address sender,\n    PoolKey calldata bp,\n    IPoolManager.SwapParams calldata bd,\n    bytes calldata ax\n  ) external v returns (bytes4, BeforeSwapDelta, uint24) {\n    require(bd.t < 0, ExactOutputDisabled());\n\n    (\n      int256 ae,\n      int256 w,\n      int256 r,\n      uint256 bi,\n      uint256 ak,\n      bytes memory ar\n    ) = HookDataDecoder.p(ax);\n\n    require(block.timestamp <= ak, ExpiredSignature(ak, block.timestamp));\n    require(\n      -bd.t <= ae,\n      ExceededMaxAmountIn(ae, -bd.t)\n    );\n\n    n(bi);\n\n    bytes32 be = ap(\n      abi.bb(\n        sender,\n        bp,\n        bd.al,\n        ae,\n        w,\n        r,\n        bi,\n        ak\n      )\n    );\n    require(\n      SignatureChecker.i(aj, be, ar), InvalidSignature()\n    );\n\n    return (this.am.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function aq(\n    address,\n    PoolKey calldata bp,\n    IPoolManager.SwapParams calldata bd,\n    BalanceDelta bj,\n    bytes calldata ax\n  ) external v returns (bytes4, int128) {\n    (int256 w, int256 r) =\n      HookDataDecoder.k(ax);\n\n    int128 aw;\n    int128 au;\n    Currency ag;\n    unchecked {\n      if (bd.al) {\n        aw = -bj.az();\n        au = bj.ba();\n        ag = bp.an;\n      } else {\n        aw = -bj.ba();\n        au = bj.az();\n        ag = bp.as;\n      }\n    }\n\n    int256 aa = aw * w / r;\n\n    unchecked {\n      int256 av = aa < au ? au - aa : int256(0);\n      if (av > 0) {\n        af.bo(\n          address(this), uint256(uint160(Currency.bg(ag))), uint256(av)\n        );\n\n        emit AbsorbEgToken(PoolId.bg(bp.bm()), Currency.bg(ag), av);\n      }\n\n      return (this.aq.selector, int128(av));\n    }\n  }\n}",
      "rename_map": {
        "afterRemoveLiquidityReturnDelta": "a",
        "afterAddLiquidityReturnDelta": "b",
        "initialClaimableAccounts": "c",
        "validateHookPermissions": "d",
        "beforeRemoveLiquidity": "e",
        "beforeSwapReturnDelta": "f",
        "afterRemoveLiquidity": "g",
        "afterSwapReturnDelta": "h",
        "isValidSignatureNow": "i",
        "beforeAddLiquidity": "j",
        "decodeExchangeRate": "k",
        "initialEgRecipient": "l",
        "initialQuoteSigner": "m",
        "_useUnorderedNonce": "n",
        "getHookPermissions": "o",
        "decodeAllHookData": "p",
        "afterAddLiquidity": "q",
        "exchangeRateDenom": "r",
        "beforeInitialize": "s",
        "amountSpecified": "t",
        "afterInitialize": "u",
        "onlyPoolManager": "v",
        "maxExchangeRate": "w",
        "toBalanceDelta": "x",
        "unlockCallback": "y",
        "claimEgTokens": "z",
        "maxAmountOut": "aa",
        "initialOwner": "ab",
        "beforeDonate": "ac",
        "_poolManager": "ad",
        "maxAmountIn": "ae",
        "poolManager": "af",
        "currencyOut": "ag",
        "egRecipient": "ah",
        "afterDonate": "ai",
        "quoteSigner": "aj",
        "expiryTime": "ak",
        "zeroForOne": "al",
        "beforeSwap": "am",
        "currency1": "an",
        "claimable": "ao",
        "keccak256": "ap",
        "afterSwap": "aq",
        "signature": "ar",
        "currency0": "as",
        "balanceOf": "at",
        "amountOut": "au",
        "egAmount": "av",
        "amountIn": "aw",
        "hookData": "ax",
        "amounts": "ay",
        "amount0": "az",
        "amount1": "ba",
        "encode": "bb",
        "unlock": "bc",
        "params": "bd",
        "digest": "be",
        "decode": "bf",
        "unwrap": "bg",
        "tokens": "bh",
        "nonce": "bi",
        "delta": "bj",
        "wrap": "bk",
        "burn": "bl",
        "toId": "bm",
        "take": "bn",
        "mint": "bo",
        "key": "bp",
        "id": "bq"
      },
      "changes": [
        "Renamed 69 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_023",
      "transformed_id": "ss_l2_short_nc_gs_023",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed ca, uint256 ck);\n    event ETHReturnedToStaking(uint256 ck);\n    event ETHAllocatedToManager(uint256 indexed ca, uint256 ck);\n    event ETHReceivedFromStaking(uint256 ck);\n    event FeesCollected(uint256 ck);\n    event InterestClaimed(\n        uint256 indexed ca,\n        uint256 bk\n    );\n    event InterestToppedUp(\n        uint256 ck\n    );\n}\n\n\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = cd(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = cd(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = cd(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = cd(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant h = 10_000;\n\n\n    IStakingReturnsWrite public bf;\n\n\n    IPauserRead public co;\n\n\n    uint256 public ad;\n\n\n    mapping(uint256 => PositionManagerConfig) public o;\n\n\n    mapping(uint256 => PositionAccountant) public ak;\n\n\n    uint256 public am;\n\n\n    uint256 public ap;\n\n\n    uint256 public s;\n\n\n    uint256 public aa;\n\n\n    uint256 public v;\n\n\n    uint256 public l;\n\n\n    uint256 public aq;\n\n\n    uint256 public ax;\n\n\n    address payable public br;\n\n\n    uint16 public bg;\n\n    uint256 public ar;\n\n\n    uint256 public bd;\n\n\n    uint256 public ba;\n\n\n    bool public n;\n\n    mapping(address => bool) public ai;\n\n    struct Init {\n        address cq;\n        address az;\n        address be;\n        address bp;\n        address bb;\n        address payable br;\n        IStakingReturnsWrite ch;\n        IPauserRead co;\n    }\n\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n\n\n    constructor() {\n        ae();\n    }\n\n    function by(Init memory cr) external bu {\n\n        __AccessControlEnumerable_init();\n\n        bz(DEFAULT_ADMIN_ROLE, cr.cq);\n        bz(LIQUIDITY_MANAGER_ROLE, cr.az);\n        bz(POSITION_MANAGER_ROLE, cr.be);\n        bz(INTEREST_TOPUP_ROLE, cr.bp);\n        bz(DRAWDOWN_MANAGER_ROLE, cr.bb);\n\n        bf = cr.ch;\n        co = cr.co;\n        br = cr.br;\n        n = true;\n\n        bz(LIQUIDITY_MANAGER_ROLE, address(bf));\n    }\n\n\n    function au(uint256 ca) public view returns (uint256) {\n        PositionManagerConfig memory cl = o[ca];\n\n        IPositionManager cj = IPositionManager(cl.bi);\n        uint256 bo = cj.z();\n\n\n        PositionAccountant memory bx = ak[ca];\n\n        if (bo > bx.ay) {\n            return bo - bx.ay;\n        }\n\n        return 0;\n    }\n\n    function ac() public view returns (uint256) {\n        return l - s;\n    }\n\n    function ag() public view returns (uint256) {\n        return am - ap;\n    }\n\n    function ab() public view returns (uint256) {\n        uint256 bs = address(this).balance;\n\n\n        for (uint256 i = 0; i < ad; i++) {\n            PositionManagerConfig storage cl = o[i];\n            if (cl.cg) {\n                IPositionManager cj = IPositionManager(cl.bi);\n                uint256 bn = cj.z();\n                bs += bn;\n            }\n        }\n\n        return bs;\n    }\n\n\n    function ao(\n        address bi,\n        uint256 bq\n    ) external ce(POSITION_MANAGER_ROLE) returns (uint256 ca) {\n        if (ai[bi]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        ca = ad;\n        ad++;\n\n        o[ca] = PositionManagerConfig({\n            bi: bi,\n            bq: bq,\n            cg: true\n        });\n        ak[ca] = PositionAccountant({\n            ay: 0,\n            f: 0\n        });\n        ai[bi] = true;\n\n        l += bq;\n        emit ProtocolConfigChanged(\n            this.ao.selector,\n            \"addPositionManager(address,uint256)\",\n            abi.cn(bi, bq)\n        );\n    }\n\n    function x(\n        uint256 ca,\n        uint256 aw,\n        bool cg\n    ) external ce(POSITION_MANAGER_ROLE) {\n        if (ca >= ad) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage cl = o[ca];\n\n        if (aw < ak[ca].ay) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n\n        l = l - cl.bq + aw;\n\n        cl.bq = aw;\n        cl.cg = cg;\n\n        emit ProtocolConfigChanged(\n            this.x.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi.cn(ca, aw, cg)\n        );\n    }\n\n    function d(uint256 ca) external ce(POSITION_MANAGER_ROLE) {\n        if (ca >= ad) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage cl = o[ca];\n        cl.cg = !cl.cg;\n\n        emit ProtocolConfigChanged(\n            this.d.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi.cn(ca)\n        );\n    }\n\n    function t(uint256 bm) external ce(DRAWDOWN_MANAGER_ROLE) {\n        aq = bm;\n\n        emit ProtocolConfigChanged(\n            this.t.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi.cn(bm)\n        );\n    }\n\n    function af(uint256 aj) external ce(POSITION_MANAGER_ROLE) {\n        if (aj >= ad) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!o[aj].cg) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        ax = aj;\n\n        emit ProtocolConfigChanged(\n            this.af.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi.cn(aj)\n        );\n    }\n\n\n    function av(uint16 bl) external ce(POSITION_MANAGER_ROLE) {\n        if (bl > h) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        bg = bl;\n        emit ProtocolConfigChanged(\n            this.av.selector, \"setFeeBasisPoints(uint16)\", abi.cn(bl)\n        );\n    }\n\n\n    function bc(address payable bt)\n        external\n        ce(POSITION_MANAGER_ROLE)\n        bh(bt)\n    {\n        br = bt;\n        emit ProtocolConfigChanged(this.bc.selector, \"setFeesReceiver(address)\", abi.cn(bt));\n    }\n\n\n    function g(bool as) external ce(POSITION_MANAGER_ROLE) {\n        n = as;\n        emit ProtocolConfigChanged(this.g.selector, \"setShouldExecuteAllocation(bool)\", abi.cn(as));\n    }\n\n\n    function bw() external payable ce(LIQUIDITY_MANAGER_ROLE) {\n        if (co.m()) revert LiquidityBuffer__Paused();\n        r(msg.value);\n        if (n) {\n            w(ax, msg.value);\n        }\n    }\n\n    function at(uint256 ca, uint256 ck) external ce(LIQUIDITY_MANAGER_ROLE) {\n        k(ca, ck);\n        al(ck);\n    }\n\n    function y(uint256 ca, uint256 ck) external ce(LIQUIDITY_MANAGER_ROLE) {\n        w(ca, ck);\n    }\n\n    function p(uint256 ca, uint256 ck) external ce(LIQUIDITY_MANAGER_ROLE) {\n        k(ca, ck);\n    }\n\n    function an(uint256 ck) external ce(LIQUIDITY_MANAGER_ROLE) {\n        al(ck);\n    }\n\n    function c() external payable e {\n\n\n    }\n\n\n    function j(uint256 ca, uint256 cb) external ce(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 ck = i(ca);\n        if (ck < cb) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return ck;\n    }\n\n    function q(uint256 ck) external ce(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < ck) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        a(ck);\n        return ck;\n    }\n\n    function u(uint256 ca, uint256 cb) external ce(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 ck = i(ca);\n        if (ck < cb) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        a(ck);\n\n        return ck;\n    }\n\n\n    function a(uint256 ck) internal {\n        if (co.m()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (ck > bd) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        bd -= ck;\n        uint256 cs = Math.cm(bg, ck, h);\n        uint256 bv = ck - cs;\n        bf.cp{value: bv}();\n        v += bv;\n        emit InterestToppedUp(bv);\n\n        if (cs > 0) {\n            Address.cc(br, cs);\n            ar += cs;\n            emit FeesCollected(cs);\n        }\n    }\n\n    function i(uint256 ca) internal returns (uint256) {\n        if (co.m()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        uint256 bk = au(ca);\n\n        if (bk > 0) {\n            PositionManagerConfig memory cl = o[ca];\n\n\n            ak[ca].f += bk;\n            aa += bk;\n            bd += bk;\n            emit InterestClaimed(ca, bk);\n\n\n            IPositionManager cj = IPositionManager(cl.bi);\n            cj.cf(bk);\n        } else {\n            emit InterestClaimed(ca, bk);\n        }\n\n        return bk;\n    }\n\n    function k(uint256 ca, uint256 ck) internal {\n        if (co.m()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (ca >= ad) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory cl = o[ca];\n        if (!cl.cg) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage bx = ak[ca];\n\n\n        if (ck > bx.ay) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n\n        bx.ay -= ck;\n        s -= ck;\n        ba += ck;\n        emit ETHWithdrawnFromManager(ca, ck);\n\n\n        IPositionManager cj = IPositionManager(cl.bi);\n        cj.cf(ck);\n    }\n\n    function al(uint256 ck) internal {\n        if (co.m()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n\n        if (address(bf) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (ck > ba) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n\n        ap += ck;\n        ba -= ck;\n        emit ETHReturnedToStaking(ck);\n\n\n        bf.b{value: ck}();\n    }\n\n    function w(uint256 ca, uint256 ck) internal {\n        if (co.m()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (ck > ba) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (ca >= ad) revert LiquidityBuffer__ManagerNotFound();\n\n        if (address(this).balance < ck) revert LiquidityBuffer__InsufficientBalance();\n\n\n        PositionManagerConfig memory cl = o[ca];\n        if (!cl.cg) revert LiquidityBuffer__ManagerInactive();\n\n        PositionAccountant storage bx = ak[ca];\n        if (bx.ay + ck > cl.bq) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n\n        bx.ay += ck;\n        s += ck;\n        ba -= ck;\n        emit ETHAllocatedToManager(ca, ck);\n\n\n        IPositionManager cj = IPositionManager(cl.bi);\n        cj.ci{value: ck}(0);\n    }\n\n    function r(uint256 ck) internal {\n        am += ck;\n        ba += ck;\n        emit ETHReceivedFromStaking(ck);\n    }\n\n\n    modifier bh(address ct) {\n        if (ct == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n\n    modifier ah() {\n        if (msg.sender != address(bf)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier e() {\n        bool bj = false;\n\n\n        for (uint256 i = 0; i < ad; i++) {\n            PositionManagerConfig memory cl = o[i];\n\n            if (msg.sender == cl.bi && cl.cg) {\n                bj = true;\n                break;\n            }\n        }\n\n        if (!bj) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "_topUpInterestToStakingAndCollectFees": "a",
        "receiveReturnsFromLiquidityBuffer": "b",
        "receiveETHFromPositionManager": "c",
        "togglePositionManagerStatus": "d",
        "onlyPositionManagerContract": "e",
        "interestClaimedFromManager": "f",
        "setShouldExecuteAllocation": "g",
        "_BASIS_POINTS_DENOMINATOR": "h",
        "_claimInterestFromManager": "i",
        "claimInterestFromManager": "j",
        "_withdrawETHFromManager": "k",
        "totalAllocationCapacity": "l",
        "isLiquidityBufferPaused": "m",
        "shouldExecuteAllocation": "n",
        "positionManagerConfigs": "o",
        "withdrawETHFromManager": "p",
        "topUpInterestToStaking": "q",
        "_receiveETHFromStaking": "r",
        "totalAllocatedBalance": "s",
        "setCumulativeDrawdown": "t",
        "claimInterestAndTopUp": "u",
        "totalInterestToppedUp": "v",
        "_allocateETHToManager": "w",
        "updatePositionManager": "x",
        "allocateETHToManager": "y",
        "getUnderlyingBalance": "z",
        "totalInterestClaimed": "aa",
        "getControlledBalance": "ab",
        "getAvailableCapacity": "ac",
        "positionManagerCount": "ad",
        "_disableInitializers": "ae",
        "setDefaultManagerId": "af",
        "getAvailableBalance": "ag",
        "onlyStakingContract": "ah",
        "isRegisteredManager": "ai",
        "newDefaultManagerId": "aj",
        "positionAccountants": "ak",
        "_returnETHToStaking": "al",
        "totalFundsReceived": "am",
        "returnETHToStaking": "an",
        "addPositionManager": "ao",
        "totalFundsReturned": "ap",
        "cumulativeDrawdown": "aq",
        "totalFeesCollected": "ar",
        "executeAllocation": "as",
        "withdrawAndReturn": "at",
        "getInterestAmount": "au",
        "setFeeBasisPoints": "av",
        "newAllocationCap": "aw",
        "defaultManagerId": "ax",
        "allocatedBalance": "ay",
        "liquidityManager": "az",
        "pendingPrincipal": "ba",
        "drawdownManager": "bb",
        "setFeesReceiver": "bc",
        "pendingInterest": "bd",
        "positionManager": "be",
        "stakingContract": "bf",
        "feesBasisPoints": "bg",
        "notZeroAddress": "bh",
        "managerAddress": "bi",
        "isValidManager": "bj",
        "interestAmount": "bk",
        "newBasisPoints": "bl",
        "drawdownAmount": "bm",
        "managerBalance": "bn",
        "currentBalance": "bo",
        "interestTopUp": "bp",
        "allocationCap": "bq",
        "feesReceiver": "br",
        "totalBalance": "bs",
        "newReceiver": "bt",
        "initializer": "bu",
        "topUpAmount": "bv",
        "depositETH": "bw",
        "accounting": "bx",
        "initialize": "by",
        "_grantRole": "bz",
        "managerId": "ca",
        "minAmount": "cb",
        "sendValue": "cc",
        "keccak256": "cd",
        "onlyRole": "ce",
        "withdraw": "cf",
        "isActive": "cg",
        "staking": "ch",
        "deposit": "ci",
        "manager": "cj",
        "amount": "ck",
        "config": "cl",
        "mulDiv": "cm",
        "encode": "cn",
        "pauser": "co",
        "topUp": "cp",
        "admin": "cq",
        "init": "cr",
        "fees": "cs",
        "addr": "ct"
      },
      "changes": [
        "Renamed 98 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_024",
      "transformed_id": "ss_l2_short_nc_gs_024",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed ca, uint256 ck);\n    event ETHReturnedToStaking(uint256 ck);\n    event ETHAllocatedToManager(uint256 indexed ca, uint256 ck);\n    event ETHReceivedFromStaking(uint256 ck);\n    event FeesCollected(uint256 ck);\n    event InterestClaimed(\n        uint256 indexed ca,\n        uint256 bk\n    );\n    event InterestToppedUp(\n        uint256 ck\n    );\n}\n\n\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = cd(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = cd(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = cd(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = cd(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant h = 10_000;\n\n\n    IStakingReturnsWrite public bf;\n\n\n    IPauserRead public co;\n\n\n    uint256 public ad;\n\n\n    mapping(uint256 => PositionManagerConfig) public o;\n\n\n    mapping(uint256 => PositionAccountant) public ak;\n\n\n    uint256 public am;\n\n\n    uint256 public ap;\n\n\n    uint256 public s;\n\n\n    uint256 public aa;\n\n\n    uint256 public v;\n\n\n    uint256 public l;\n\n\n    uint256 public aq;\n\n\n    uint256 public ax;\n\n\n    address payable public br;\n\n\n    uint16 public bg;\n\n    uint256 public ar;\n\n\n    uint256 public bd;\n\n\n    uint256 public ba;\n\n\n    bool public n;\n\n    mapping(address => bool) public ai;\n\n    struct Init {\n        address cq;\n        address az;\n        address be;\n        address bp;\n        address bb;\n        address payable br;\n        IStakingReturnsWrite ch;\n        IPauserRead co;\n    }\n\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n\n\n    constructor() {\n        ae();\n    }\n\n    function by(Init memory cr) external bu {\n\n        __AccessControlEnumerable_init();\n\n        bz(DEFAULT_ADMIN_ROLE, cr.cq);\n        bz(LIQUIDITY_MANAGER_ROLE, cr.az);\n        bz(POSITION_MANAGER_ROLE, cr.be);\n        bz(INTEREST_TOPUP_ROLE, cr.bp);\n        bz(DRAWDOWN_MANAGER_ROLE, cr.bb);\n\n        bf = cr.ch;\n        co = cr.co;\n        br = cr.br;\n        n = true;\n\n        bz(LIQUIDITY_MANAGER_ROLE, address(bf));\n    }\n\n\n    function au(uint256 ca) public view returns (uint256) {\n        PositionManagerConfig memory cl = o[ca];\n\n        IPositionManager cj = IPositionManager(cl.bi);\n        uint256 bo = cj.z();\n\n\n        PositionAccountant memory bx = ak[ca];\n\n        if (bo > bx.ay) {\n            return bo - bx.ay;\n        }\n\n        return 0;\n    }\n\n    function ac() public view returns (uint256) {\n        return l - s;\n    }\n\n    function ag() public view returns (uint256) {\n        return am - ap;\n    }\n\n    function ab() public view returns (uint256) {\n        uint256 bs = address(this).balance;\n\n\n        for (uint256 i = 0; i < ad; i++) {\n            PositionManagerConfig storage cl = o[i];\n            if (cl.cg) {\n                IPositionManager cj = IPositionManager(cl.bi);\n                uint256 bn = cj.z();\n                bs += bn;\n            }\n        }\n\n        return bs;\n    }\n\n\n    function ao(\n        address bi,\n        uint256 bq\n    ) external ce(POSITION_MANAGER_ROLE) returns (uint256 ca) {\n        if (ai[bi]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        ca = ad;\n        ad++;\n\n        o[ca] = PositionManagerConfig({\n            bi: bi,\n            bq: bq,\n            cg: true\n        });\n        ak[ca] = PositionAccountant({\n            ay: 0,\n            f: 0\n        });\n        ai[bi] = true;\n\n        l += bq;\n        emit ProtocolConfigChanged(\n            this.ao.selector,\n            \"addPositionManager(address,uint256)\",\n            abi.cn(bi, bq)\n        );\n    }\n\n    function x(\n        uint256 ca,\n        uint256 aw,\n        bool cg\n    ) external ce(POSITION_MANAGER_ROLE) {\n        if (ca >= ad) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage cl = o[ca];\n\n        if (aw < ak[ca].ay) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n\n        l = l - cl.bq + aw;\n\n        cl.bq = aw;\n        cl.cg = cg;\n\n        emit ProtocolConfigChanged(\n            this.x.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi.cn(ca, aw, cg)\n        );\n    }\n\n    function d(uint256 ca) external ce(POSITION_MANAGER_ROLE) {\n        if (ca >= ad) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage cl = o[ca];\n        cl.cg = !cl.cg;\n\n        emit ProtocolConfigChanged(\n            this.d.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi.cn(ca)\n        );\n    }\n\n    function t(uint256 bm) external ce(DRAWDOWN_MANAGER_ROLE) {\n        aq = bm;\n\n        emit ProtocolConfigChanged(\n            this.t.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi.cn(bm)\n        );\n    }\n\n    function af(uint256 aj) external ce(POSITION_MANAGER_ROLE) {\n        if (aj >= ad) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!o[aj].cg) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        ax = aj;\n\n        emit ProtocolConfigChanged(\n            this.af.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi.cn(aj)\n        );\n    }\n\n\n    function av(uint16 bl) external ce(POSITION_MANAGER_ROLE) {\n        if (bl > h) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        bg = bl;\n        emit ProtocolConfigChanged(\n            this.av.selector, \"setFeeBasisPoints(uint16)\", abi.cn(bl)\n        );\n    }\n\n\n    function bc(address payable bt)\n        external\n        ce(POSITION_MANAGER_ROLE)\n        bh(bt)\n    {\n        br = bt;\n        emit ProtocolConfigChanged(this.bc.selector, \"setFeesReceiver(address)\", abi.cn(bt));\n    }\n\n\n    function g(bool as) external ce(POSITION_MANAGER_ROLE) {\n        n = as;\n        emit ProtocolConfigChanged(this.g.selector, \"setShouldExecuteAllocation(bool)\", abi.cn(as));\n    }\n\n\n    function bw() external payable ce(LIQUIDITY_MANAGER_ROLE) {\n        if (co.m()) revert LiquidityBuffer__Paused();\n        r(msg.value);\n        if (n) {\n            w(ax, msg.value);\n        }\n    }\n\n    function at(uint256 ca, uint256 ck) external ce(LIQUIDITY_MANAGER_ROLE) {\n        k(ca, ck);\n        al(ck);\n    }\n\n    function y(uint256 ca, uint256 ck) external ce(LIQUIDITY_MANAGER_ROLE) {\n        w(ca, ck);\n    }\n\n    function p(uint256 ca, uint256 ck) external ce(LIQUIDITY_MANAGER_ROLE) {\n        k(ca, ck);\n    }\n\n    function an(uint256 ck) external ce(LIQUIDITY_MANAGER_ROLE) {\n        al(ck);\n    }\n\n    function c() external payable e {\n\n\n    }\n\n\n    function j(uint256 ca, uint256 cb) external ce(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 ck = i(ca);\n        if (ck < cb) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return ck;\n    }\n\n    function q(uint256 ck) external ce(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < ck) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        a(ck);\n        return ck;\n    }\n\n    function u(uint256 ca, uint256 cb) external ce(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 ck = i(ca);\n        if (ck < cb) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        a(ck);\n\n        return ck;\n    }\n\n\n    function a(uint256 ck) internal {\n        if (co.m()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (ck > bd) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        bd -= ck;\n        uint256 cs = Math.cm(bg, ck, h);\n        uint256 bv = ck - cs;\n        bf.cp{value: bv}();\n        v += bv;\n        emit InterestToppedUp(bv);\n\n        if (cs > 0) {\n            Address.cc(br, cs);\n            ar += cs;\n            emit FeesCollected(cs);\n        }\n    }\n\n    function i(uint256 ca) internal returns (uint256) {\n        if (co.m()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        uint256 bk = au(ca);\n\n        if (bk > 0) {\n            PositionManagerConfig memory cl = o[ca];\n\n\n            ak[ca].f += bk;\n            aa += bk;\n            bd += bk;\n            emit InterestClaimed(ca, bk);\n\n\n            IPositionManager cj = IPositionManager(cl.bi);\n            cj.cf(bk);\n        } else {\n            emit InterestClaimed(ca, bk);\n        }\n\n        return bk;\n    }\n\n    function k(uint256 ca, uint256 ck) internal {\n        if (co.m()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (ca >= ad) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory cl = o[ca];\n        if (!cl.cg) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage bx = ak[ca];\n\n\n        if (ck > bx.ay) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n\n        bx.ay -= ck;\n        s -= ck;\n        ba += ck;\n        emit ETHWithdrawnFromManager(ca, ck);\n\n\n        IPositionManager cj = IPositionManager(cl.bi);\n        cj.cf(ck);\n    }\n\n    function al(uint256 ck) internal {\n        if (co.m()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n\n        if (address(bf) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (ck > ba) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n\n        ap += ck;\n        ba -= ck;\n        emit ETHReturnedToStaking(ck);\n\n\n        bf.b{value: ck}();\n    }\n\n    function w(uint256 ca, uint256 ck) internal {\n        if (co.m()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (ck > ba) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (ca >= ad) revert LiquidityBuffer__ManagerNotFound();\n\n        if (address(this).balance < ck) revert LiquidityBuffer__InsufficientBalance();\n\n\n        PositionManagerConfig memory cl = o[ca];\n        if (!cl.cg) revert LiquidityBuffer__ManagerInactive();\n\n        PositionAccountant storage bx = ak[ca];\n        if (bx.ay + ck > cl.bq) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n\n        bx.ay += ck;\n        s += ck;\n        ba -= ck;\n        emit ETHAllocatedToManager(ca, ck);\n\n\n        IPositionManager cj = IPositionManager(cl.bi);\n        cj.ci{value: ck}(0);\n    }\n\n    function r(uint256 ck) internal {\n        am += ck;\n        ba += ck;\n        emit ETHReceivedFromStaking(ck);\n    }\n\n\n    modifier bh(address ct) {\n        if (ct == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n\n    modifier ah() {\n        if (msg.sender != address(bf)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier e() {\n        bool bj = false;\n\n\n        for (uint256 i = 0; i < ad; i++) {\n            PositionManagerConfig memory cl = o[i];\n\n            if (msg.sender == cl.bi && cl.cg) {\n                bj = true;\n                break;\n            }\n        }\n\n        if (!bj) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "_topUpInterestToStakingAndCollectFees": "a",
        "receiveReturnsFromLiquidityBuffer": "b",
        "receiveETHFromPositionManager": "c",
        "togglePositionManagerStatus": "d",
        "onlyPositionManagerContract": "e",
        "interestClaimedFromManager": "f",
        "setShouldExecuteAllocation": "g",
        "_BASIS_POINTS_DENOMINATOR": "h",
        "_claimInterestFromManager": "i",
        "claimInterestFromManager": "j",
        "_withdrawETHFromManager": "k",
        "totalAllocationCapacity": "l",
        "isLiquidityBufferPaused": "m",
        "shouldExecuteAllocation": "n",
        "positionManagerConfigs": "o",
        "withdrawETHFromManager": "p",
        "topUpInterestToStaking": "q",
        "_receiveETHFromStaking": "r",
        "totalAllocatedBalance": "s",
        "setCumulativeDrawdown": "t",
        "claimInterestAndTopUp": "u",
        "totalInterestToppedUp": "v",
        "_allocateETHToManager": "w",
        "updatePositionManager": "x",
        "allocateETHToManager": "y",
        "getUnderlyingBalance": "z",
        "totalInterestClaimed": "aa",
        "getControlledBalance": "ab",
        "getAvailableCapacity": "ac",
        "positionManagerCount": "ad",
        "_disableInitializers": "ae",
        "setDefaultManagerId": "af",
        "getAvailableBalance": "ag",
        "onlyStakingContract": "ah",
        "isRegisteredManager": "ai",
        "newDefaultManagerId": "aj",
        "positionAccountants": "ak",
        "_returnETHToStaking": "al",
        "totalFundsReceived": "am",
        "returnETHToStaking": "an",
        "addPositionManager": "ao",
        "totalFundsReturned": "ap",
        "cumulativeDrawdown": "aq",
        "totalFeesCollected": "ar",
        "executeAllocation": "as",
        "withdrawAndReturn": "at",
        "getInterestAmount": "au",
        "setFeeBasisPoints": "av",
        "newAllocationCap": "aw",
        "defaultManagerId": "ax",
        "allocatedBalance": "ay",
        "liquidityManager": "az",
        "pendingPrincipal": "ba",
        "drawdownManager": "bb",
        "setFeesReceiver": "bc",
        "pendingInterest": "bd",
        "positionManager": "be",
        "stakingContract": "bf",
        "feesBasisPoints": "bg",
        "notZeroAddress": "bh",
        "managerAddress": "bi",
        "isValidManager": "bj",
        "interestAmount": "bk",
        "newBasisPoints": "bl",
        "drawdownAmount": "bm",
        "managerBalance": "bn",
        "currentBalance": "bo",
        "interestTopUp": "bp",
        "allocationCap": "bq",
        "feesReceiver": "br",
        "totalBalance": "bs",
        "newReceiver": "bt",
        "initializer": "bu",
        "topUpAmount": "bv",
        "depositETH": "bw",
        "accounting": "bx",
        "initialize": "by",
        "_grantRole": "bz",
        "managerId": "ca",
        "minAmount": "cb",
        "sendValue": "cc",
        "keccak256": "cd",
        "onlyRole": "ce",
        "withdraw": "cf",
        "isActive": "cg",
        "staking": "ch",
        "deposit": "ci",
        "manager": "cj",
        "amount": "ck",
        "config": "cl",
        "mulDiv": "cm",
        "encode": "cn",
        "pauser": "co",
        "topUp": "cp",
        "admin": "cq",
        "init": "cr",
        "fees": "cs",
        "addr": "ct"
      },
      "changes": [
        "Renamed 98 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_025",
      "transformed_id": "ss_l2_short_nc_gs_025",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ninterface StakingEvents {\n\n    event Staked(address indexed bx, uint256 bp, uint256 bf);\n\n\n    event UnstakeRequested(uint256 indexed cl, address indexed bx, uint256 bp, uint256 be);\n\n\n    event UnstakeRequestClaimed(uint256 indexed cl, address indexed bx);\n\n\n    event ValidatorInitiated(bytes32 indexed cl, uint256 indexed bg, bytes cb, uint256 ak);\n\n\n    event AllocatedETHToUnstakeRequestsManager(uint256 bv);\n\n\n    event AllocatedETHToDeposits(uint256 bv);\n\n\n    event ReturnsReceived(uint256 bv);\n\n\n    event ReturnsReceivedFromLiquidityBuffer(uint256 bv);\n\n\n    event AllocatedETHToLiquidityBuffer(uint256 bv);\n}\n\n\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 bj, uint256 ai);\n    error UnstakeBelowMinimumETHAmount(uint256 bp, uint256 ai);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = bq(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = bq(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = bq(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = bq(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = bq(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = bq(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 bg;\n        uint256 av;\n        bytes cb;\n        bytes q;\n        bytes bn;\n        bytes32 ag;\n    }\n\n    mapping(bytes cb => bool cd) public at;\n    uint256 public g;\n    uint256 public n;\n    uint256 public ar;\n    uint256 public l;\n    uint256 public aa;\n    uint256 public v;\n    uint16 public o;\n    uint16 internal constant h = 10_000;\n    uint16 internal constant d = h / 10;\n    uint256 public r;\n    uint256 public s;\n    IDepositContract public al;\n    IMETH public ci;\n    IOracleReadRecord public by;\n    IPauserRead public cc;\n    IUnstakeRequestsManager public m;\n    address public ad;\n    address public ab;\n    bool public y;\n    uint256 public i;\n    uint256 public z;\n    ILiquidityBuffer public am;\n\n    struct Init {\n        address ce;\n        address bu;\n        address ac;\n        address af;\n        address ab;\n        address ad;\n        IMETH ci;\n        IDepositContract al;\n        IOracleReadRecord by;\n        IPauserRead cc;\n        IUnstakeRequestsManager m;\n    }\n\n    constructor() {\n        t();\n    }\n\n    function bk(Init memory ch) external bd {\n        __AccessControlEnumerable_init();\n\n        bl(DEFAULT_ADMIN_ROLE, ch.ce);\n        bl(STAKING_MANAGER_ROLE, ch.bu);\n        bl(ALLOCATOR_SERVICE_ROLE, ch.ac);\n        bl(INITIATOR_SERVICE_ROLE, ch.af);\n\n        ax(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        ax(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        ci = ch.ci;\n        al = ch.al;\n        by = ch.by;\n        cc = ch.cc;\n        ab = ch.ab;\n        m = ch.m;\n        ad = ch.ad;\n\n        aa = 0.1 ether;\n        v = 0.01 ether;\n        r = 32 ether;\n        s = 32 ether;\n        y = true;\n        i = block.number;\n        z = 1024 ether;\n    }\n\n    function ay(ILiquidityBuffer cm) public au(2) {\n        am = cm;\n    }\n\n    function cg(uint256 aw) external payable {\n        if (cc.ah()) {\n            revert Paused();\n        }\n\n        if (y) {\n            bi(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < aa) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 as = bs(msg.value);\n        if (as + ci.bc() > z) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (as < aw) {\n            revert StakeBelowMinimumMETHAmount(as, aw);\n        }\n\n        ar += msg.value;\n\n        emit Staked(msg.sender, msg.value, as);\n        ci.cj(msg.sender, as);\n    }\n\n    function ap(uint128 bj, uint128 az) external returns (uint256) {\n        return aj(bj, az);\n    }\n\n    function j(\n        uint128 bj,\n        uint128 az,\n        uint256 bt,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.bh(ci, msg.sender, address(this), bj, bt, v, r, s);\n        return aj(bj, az);\n    }\n\n    function aj(uint128 bj, uint128 az) internal returns (uint256) {\n        if (cc.b()) {\n            revert Paused();\n        }\n\n        if (bj < v) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 bp = uint128(br(bj));\n        if (bp < az) {\n            revert UnstakeBelowMinimumETHAmount(bp, az);\n        }\n\n        uint256 bm =\n            m.bw({bo: msg.sender, be: bj, bb: bp});\n        emit UnstakeRequested({cl: bm, bx: msg.sender, bp: bp, be: bj});\n\n        SafeERC20Upgradeable.ae(ci, msg.sender, address(m), bj);\n\n        return bm;\n    }\n\n    function bs(uint256 bp) public view returns (uint256) {\n        if (ci.bc() == 0) {\n            return bp;\n        }\n        uint256 k = Math.bz(\n            an(), h + o, h\n        );\n        return Math.bz(bp, ci.bc(), k);\n    }\n\n    function br(uint256 bf) public view returns (uint256) {\n        if (ci.bc() == 0) {\n            return bf;\n        }\n        return Math.bz(bf, an(), ci.bc());\n    }\n\n    function an() public view returns (uint256) {\n        OracleRecord memory ca = by.ba();\n        uint256 cf = 0;\n        cf += ar;\n        cf += l;\n        cf += g - ca.c;\n        cf += ca.e;\n        cf += am.u();\n        cf -= am.x();\n        cf += m.balance();\n        return cf;\n    }\n\n    function aq() external payable p {\n        emit ReturnsReceived(msg.value);\n        ar += msg.value;\n    }\n\n    function a() external payable w {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        ar += msg.value;\n    }\n\n    modifier p() {\n        if (msg.sender != ab) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier w() {\n        if (msg.sender != address(am)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier f() {\n        if (msg.sender != address(m)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier ao(address ck) {\n        if (ck == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "a",
        "isUnstakeRequestsAndClaimsPaused": "b",
        "cumulativeProcessedDepositAmount": "c",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "d",
        "currentTotalValidatorBalance": "e",
        "onlyUnstakeRequestsManager": "f",
        "totalDepositedInValidators": "g",
        "_BASIS_POINTS_DENOMINATOR": "h",
        "initializationBlockNumber": "i",
        "unstakeRequestWithPermit": "j",
        "adjustedTotalControlled": "k",
        "allocatedETHForDeposits": "l",
        "unstakeRequestsManager": "m",
        "numInitiatedValidators": "n",
        "exchangeAdjustmentRate": "o",
        "onlyReturnsAggregator": "p",
        "withdrawalCredentials": "q",
        "minimumDepositAmount": "r",
        "maximumDepositAmount": "s",
        "_disableInitializers": "t",
        "getAvailableBalance": "u",
        "minimumUnstakeBound": "v",
        "onlyLiquidityBuffer": "w",
        "cumulativeDrawdown": "x",
        "isStakingAllowlist": "y",
        "maximumMETHSupply": "z",
        "minimumStakeBound": "aa",
        "returnsAggregator": "ab",
        "allocatorService": "ac",
        "withdrawalWallet": "ad",
        "safeTransferFrom": "ae",
        "initiatorService": "af",
        "depositDataRoot": "ag",
        "isStakingPaused": "ah",
        "expectedMinimum": "ai",
        "_unstakeRequest": "aj",
        "amountDeposited": "ak",
        "depositContract": "al",
        "liquidityBuffer": "am",
        "totalControlled": "an",
        "notZeroAddress": "ao",
        "unstakeRequest": "ap",
        "receiveReturns": "aq",
        "unallocatedETH": "ar",
        "mETHMintAmount": "as",
        "usedValidators": "at",
        "reinitializer": "au",
        "depositAmount": "av",
        "minMETHAmount": "aw",
        "_setRoleAdmin": "ax",
        "initializeV2": "ay",
        "minETHAmount": "az",
        "latestRecord": "ba",
        "ethRequested": "bb",
        "totalSupply": "bc",
        "initializer": "bd",
        "mETHLocked": "be",
        "mETHAmount": "bf",
        "operatorID": "bg",
        "safePermit": "bh",
        "_checkRole": "bi",
        "methAmount": "bj",
        "initialize": "bk",
        "_grantRole": "bl",
        "requestID": "bm",
        "signature": "bn",
        "requester": "bo",
        "ethAmount": "bp",
        "keccak256": "bq",
        "mETHToETH": "br",
        "ethToMETH": "bs",
        "deadline": "bt",
        "manager": "bu",
        "amount": "bv",
        "create": "bw",
        "staker": "bx",
        "oracle": "by",
        "mulDiv": "bz",
        "record": "ca",
        "pubkey": "cb",
        "pauser": "cc",
        "exists": "cd",
        "admin": "ce",
        "total": "cf",
        "stake": "cg",
        "init": "ch",
        "mETH": "ci",
        "mint": "cj",
        "addr": "ck",
        "id": "cl",
        "lb": "cm"
      },
      "changes": [
        "Renamed 91 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_026",
      "transformed_id": "ss_l2_short_nc_gs_026",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IPool} from \"aave-v3/interfaces/IPool.sol\";\nimport {DataTypes} from \"aave-v3/protocol/libraries/types/DataTypes.sol\";\nimport {IPositionManager} from './interfaces/IPositionManager.sol';\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {ILiquidityBuffer} from \"../liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ncontract PositionManager is Initializable, AccessControlEnumerableUpgradeable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n\n    bytes32 public constant EXECUTOR_ROLE = ae(\"EXECUTOR_ROLE\");\n    bytes32 public constant MANAGER_ROLE = ae(\"MANAGER_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = ae(\"EMERGENCY_ROLE\");\n\n\n    IPool public au;\n    IWETH public ax;\n    ILiquidityBuffer public o;\n\n\n    struct Init {\n        address at;\n        address am;\n        ILiquidityBuffer o;\n        IWETH ax;\n        IPool au;\n    }\n\n\n    event Deposit(address indexed ap, uint ao, uint u);\n    event Withdraw(address indexed ap, uint ao);\n    event Borrow(address indexed ap, uint ao, uint ah);\n    event Repay(address indexed ap, uint ao, uint ah);\n    event SetUserEMode(address indexed ap, uint8 ac);\n\n    constructor() {\n        h();\n    }\n\n    function ab(Init memory av) external w {\n        __AccessControlEnumerable_init();\n\n        ax = av.ax;\n        au = av.au;\n        o = av.o;\n\n\n        ad(DEFAULT_ADMIN_ROLE, av.at);\n        ad(MANAGER_ROLE, av.am);\n        ad(EXECUTOR_ROLE, address(av.o));\n\n\n        ax.an(address(au), type(uint256).ay);\n    }\n\n\n    function ak(uint16 r) external payable override ai(EXECUTOR_ROLE) {\n        if (msg.value > 0) {\n\n            ax.ak{value: msg.value}();\n\n\n            au.ak(address(ax), msg.value, address(this), r);\n\n            emit Deposit(msg.sender, msg.value, msg.value);\n        }\n    }\n\n    function aj(uint256 ao) external override ai(EXECUTOR_ROLE) {\n        require(ao > 0, 'Invalid ao');\n\n\n        IERC20 ar = IERC20(au.j(address(ax)));\n        uint256 x = ar.ag(address(this));\n\n        uint256 m = ao;\n        if (ao == type(uint256).ay) {\n            m = x;\n        }\n\n        require(m <= x, 'Insufficient balance');\n\n\n        au.aj(address(ax), m, address(this));\n\n\n        ax.aj(m);\n\n\n        o.b{value: m}();\n\n        emit Withdraw(msg.sender, m);\n    }\n\n    function f() external view returns (uint256) {\n        IERC20 ar = IERC20(au.j(address(ax)));\n        return ar.ag(address(this));\n    }\n\n    function v(uint8 ac) external override ai(MANAGER_ROLE) {\n\n        au.v(ac);\n\n        emit SetUserEMode(msg.sender, ac);\n    }\n    function t(address aq, address aw, uint256 az) external override ai(MANAGER_ROLE) {\n        IERC20(aq).y(aw, az);\n    }\n\n    function aa(address aq, address aw) external override ai(MANAGER_ROLE) {\n        IERC20(aq).y(aw, 0);\n    }\n\n\n    function n() external view returns (uint256) {\n        address af = au.c(address(ax));\n        return IERC20(af).ag(address(this));\n    }\n\n    function g() external view returns (uint256) {\n        IERC20 ar = IERC20(au.j(address(ax)));\n        return ar.ag(address(this));\n    }\n\n    function s() external view returns (uint256) {\n        return au.s(address(this));\n    }\n\n    function a(address as, bool p) external ai(MANAGER_ROLE) {\n        au.a(as, p);\n    }\n\n    function i(address k) external ai(MANAGER_ROLE) {\n        z(EXECUTOR_ROLE, address(o));\n        ad(EXECUTOR_ROLE, k);\n        o = ILiquidityBuffer(k);\n    }\n\n\n    function d(address aq, address ba, uint256 ao) external ai(EMERGENCY_ROLE) {\n        IERC20(aq).q(ba, ao);\n    }\n\n\n    function e(address ba, uint256 ao) external ai(EMERGENCY_ROLE) {\n        l(ba, ao);\n    }\n\n\n    function l(address ba, uint256 value) internal {\n        (bool al, ) = ba.call{value: value}(new bytes(0));\n        require(al, 'ETH_TRANSFER_FAILED');\n    }\n\n\n    receive() external payable {\n        require(msg.sender == address(ax), 'Receive not allowed');\n    }\n\n\n    fallback() external payable {\n        revert('Fallback not allowed');\n    }\n}",
      "rename_map": {
        "setUserUseReserveAsCollateral": "a",
        "receiveETHFromPositionManager": "b",
        "getReserveVariableDebtToken": "c",
        "emergencyTokenTransfer": "d",
        "emergencyEtherTransfer": "e",
        "getUnderlyingBalance": "f",
        "getCollateralBalance": "g",
        "_disableInitializers": "h",
        "setLiquidityBuffer": "i",
        "getReserveAToken": "j",
        "_liquidityBuffer": "k",
        "_safeTransferETH": "l",
        "amountToWithdraw": "m",
        "getBorrowBalance": "n",
        "liquidityBuffer": "o",
        "useAsCollateral": "p",
        "safeTransfer": "q",
        "referralCode": "r",
        "getUserEMode": "s",
        "approveToken": "t",
        "aTokenAmount": "u",
        "setUserEMode": "v",
        "initializer": "w",
        "userBalance": "x",
        "safeApprove": "y",
        "_revokeRole": "z",
        "revokeToken": "aa",
        "initialize": "ab",
        "categoryId": "ac",
        "_grantRole": "ad",
        "keccak256": "ae",
        "debtToken": "af",
        "balanceOf": "ag",
        "rateMode": "ah",
        "onlyRole": "ai",
        "withdraw": "aj",
        "deposit": "ak",
        "success": "al",
        "manager": "am",
        "approve": "an",
        "amount": "ao",
        "caller": "ap",
        "token": "aq",
        "aWETH": "ar",
        "asset": "as",
        "admin": "at",
        "pool": "au",
        "init": "av",
        "addr": "aw",
        "weth": "ax",
        "max": "ay",
        "wad": "az",
        "to": "ba"
      },
      "changes": [
        "Renamed 53 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_027",
      "transformed_id": "ss_l2_short_nc_gs_027",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ninterface StakingEvents {\n\n    event Staked(address indexed bx, uint256 bp, uint256 bf);\n\n\n    event UnstakeRequested(uint256 indexed cl, address indexed bx, uint256 bp, uint256 be);\n\n\n    event UnstakeRequestClaimed(uint256 indexed cl, address indexed bx);\n\n\n    event ValidatorInitiated(bytes32 indexed cl, uint256 indexed bg, bytes cb, uint256 ak);\n\n\n    event AllocatedETHToUnstakeRequestsManager(uint256 bv);\n\n\n    event AllocatedETHToDeposits(uint256 bv);\n\n\n    event ReturnsReceived(uint256 bv);\n\n\n    event ReturnsReceivedFromLiquidityBuffer(uint256 bv);\n\n\n    event AllocatedETHToLiquidityBuffer(uint256 bv);\n}\n\n\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 bj, uint256 ai);\n    error UnstakeBelowMinimumETHAmount(uint256 bp, uint256 ai);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = bq(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = bq(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = bq(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = bq(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = bq(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = bq(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 bg;\n        uint256 av;\n        bytes cb;\n        bytes q;\n        bytes bn;\n        bytes32 ag;\n    }\n\n    mapping(bytes cb => bool cd) public at;\n    uint256 public g;\n    uint256 public n;\n    uint256 public ar;\n    uint256 public l;\n    uint256 public aa;\n    uint256 public v;\n    uint16 public o;\n    uint16 internal constant h = 10_000;\n    uint16 internal constant d = h / 10;\n    uint256 public r;\n    uint256 public s;\n    IDepositContract public al;\n    IMETH public ci;\n    IOracleReadRecord public by;\n    IPauserRead public cc;\n    IUnstakeRequestsManager public m;\n    address public ad;\n    address public ab;\n    bool public y;\n    uint256 public i;\n    uint256 public z;\n    ILiquidityBuffer public am;\n\n    struct Init {\n        address ce;\n        address bu;\n        address ac;\n        address af;\n        address ab;\n        address ad;\n        IMETH ci;\n        IDepositContract al;\n        IOracleReadRecord by;\n        IPauserRead cc;\n        IUnstakeRequestsManager m;\n    }\n\n    constructor() {\n        t();\n    }\n\n    function bk(Init memory ch) external bd {\n        __AccessControlEnumerable_init();\n\n        bl(DEFAULT_ADMIN_ROLE, ch.ce);\n        bl(STAKING_MANAGER_ROLE, ch.bu);\n        bl(ALLOCATOR_SERVICE_ROLE, ch.ac);\n        bl(INITIATOR_SERVICE_ROLE, ch.af);\n\n        ax(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        ax(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        ci = ch.ci;\n        al = ch.al;\n        by = ch.by;\n        cc = ch.cc;\n        ab = ch.ab;\n        m = ch.m;\n        ad = ch.ad;\n\n        aa = 0.1 ether;\n        v = 0.01 ether;\n        r = 32 ether;\n        s = 32 ether;\n        y = true;\n        i = block.number;\n        z = 1024 ether;\n    }\n\n    function ay(ILiquidityBuffer cm) public au(2) {\n        am = cm;\n    }\n\n    function cg(uint256 aw) external payable {\n        if (cc.ah()) {\n            revert Paused();\n        }\n\n        if (y) {\n            bi(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < aa) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 as = bs(msg.value);\n        if (as + ci.bc() > z) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (as < aw) {\n            revert StakeBelowMinimumMETHAmount(as, aw);\n        }\n\n        ar += msg.value;\n\n        emit Staked(msg.sender, msg.value, as);\n        ci.cj(msg.sender, as);\n    }\n\n    function ap(uint128 bj, uint128 az) external returns (uint256) {\n        return aj(bj, az);\n    }\n\n    function j(\n        uint128 bj,\n        uint128 az,\n        uint256 bt,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.bh(ci, msg.sender, address(this), bj, bt, v, r, s);\n        return aj(bj, az);\n    }\n\n    function aj(uint128 bj, uint128 az) internal returns (uint256) {\n        if (cc.b()) {\n            revert Paused();\n        }\n\n        if (bj < v) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 bp = uint128(br(bj));\n        if (bp < az) {\n            revert UnstakeBelowMinimumETHAmount(bp, az);\n        }\n\n        uint256 bm =\n            m.bw({bo: msg.sender, be: bj, bb: bp});\n        emit UnstakeRequested({cl: bm, bx: msg.sender, bp: bp, be: bj});\n\n        SafeERC20Upgradeable.ae(ci, msg.sender, address(m), bj);\n\n        return bm;\n    }\n\n    function bs(uint256 bp) public view returns (uint256) {\n        if (ci.bc() == 0) {\n            return bp;\n        }\n        uint256 k = Math.bz(\n            an(), h + o, h\n        );\n        return Math.bz(bp, ci.bc(), k);\n    }\n\n    function br(uint256 bf) public view returns (uint256) {\n        if (ci.bc() == 0) {\n            return bf;\n        }\n        return Math.bz(bf, an(), ci.bc());\n    }\n\n    function an() public view returns (uint256) {\n        OracleRecord memory ca = by.ba();\n        uint256 cf = 0;\n        cf += ar;\n        cf += l;\n        cf += g - ca.c;\n        cf += ca.e;\n        cf += am.u();\n        cf -= am.x();\n        cf += m.balance();\n        return cf;\n    }\n\n    function aq() external payable p {\n        emit ReturnsReceived(msg.value);\n        ar += msg.value;\n    }\n\n    function a() external payable w {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        ar += msg.value;\n    }\n\n    modifier p() {\n        if (msg.sender != ab) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier w() {\n        if (msg.sender != address(am)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier f() {\n        if (msg.sender != address(m)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier ao(address ck) {\n        if (ck == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "a",
        "isUnstakeRequestsAndClaimsPaused": "b",
        "cumulativeProcessedDepositAmount": "c",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "d",
        "currentTotalValidatorBalance": "e",
        "onlyUnstakeRequestsManager": "f",
        "totalDepositedInValidators": "g",
        "_BASIS_POINTS_DENOMINATOR": "h",
        "initializationBlockNumber": "i",
        "unstakeRequestWithPermit": "j",
        "adjustedTotalControlled": "k",
        "allocatedETHForDeposits": "l",
        "unstakeRequestsManager": "m",
        "numInitiatedValidators": "n",
        "exchangeAdjustmentRate": "o",
        "onlyReturnsAggregator": "p",
        "withdrawalCredentials": "q",
        "minimumDepositAmount": "r",
        "maximumDepositAmount": "s",
        "_disableInitializers": "t",
        "getAvailableBalance": "u",
        "minimumUnstakeBound": "v",
        "onlyLiquidityBuffer": "w",
        "cumulativeDrawdown": "x",
        "isStakingAllowlist": "y",
        "maximumMETHSupply": "z",
        "minimumStakeBound": "aa",
        "returnsAggregator": "ab",
        "allocatorService": "ac",
        "withdrawalWallet": "ad",
        "safeTransferFrom": "ae",
        "initiatorService": "af",
        "depositDataRoot": "ag",
        "isStakingPaused": "ah",
        "expectedMinimum": "ai",
        "_unstakeRequest": "aj",
        "amountDeposited": "ak",
        "depositContract": "al",
        "liquidityBuffer": "am",
        "totalControlled": "an",
        "notZeroAddress": "ao",
        "unstakeRequest": "ap",
        "receiveReturns": "aq",
        "unallocatedETH": "ar",
        "mETHMintAmount": "as",
        "usedValidators": "at",
        "reinitializer": "au",
        "depositAmount": "av",
        "minMETHAmount": "aw",
        "_setRoleAdmin": "ax",
        "initializeV2": "ay",
        "minETHAmount": "az",
        "latestRecord": "ba",
        "ethRequested": "bb",
        "totalSupply": "bc",
        "initializer": "bd",
        "mETHLocked": "be",
        "mETHAmount": "bf",
        "operatorID": "bg",
        "safePermit": "bh",
        "_checkRole": "bi",
        "methAmount": "bj",
        "initialize": "bk",
        "_grantRole": "bl",
        "requestID": "bm",
        "signature": "bn",
        "requester": "bo",
        "ethAmount": "bp",
        "keccak256": "bq",
        "mETHToETH": "br",
        "ethToMETH": "bs",
        "deadline": "bt",
        "manager": "bu",
        "amount": "bv",
        "create": "bw",
        "staker": "bx",
        "oracle": "by",
        "mulDiv": "bz",
        "record": "ca",
        "pubkey": "cb",
        "pauser": "cc",
        "exists": "cd",
        "admin": "ce",
        "total": "cf",
        "stake": "cg",
        "init": "ch",
        "mETH": "ci",
        "mint": "cj",
        "addr": "ck",
        "id": "cl",
        "lb": "cm"
      },
      "changes": [
        "Renamed 91 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_028",
      "transformed_id": "ss_l2_short_nc_gs_028",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n\ninterface StakingEvents {\n\n    event Staked(address indexed bx, uint256 bp, uint256 bf);\n\n\n    event UnstakeRequested(uint256 indexed cl, address indexed bx, uint256 bp, uint256 be);\n\n\n    event UnstakeRequestClaimed(uint256 indexed cl, address indexed bx);\n\n\n    event ValidatorInitiated(bytes32 indexed cl, uint256 indexed bg, bytes cb, uint256 ak);\n\n\n    event AllocatedETHToUnstakeRequestsManager(uint256 bv);\n\n\n    event AllocatedETHToDeposits(uint256 bv);\n\n\n    event ReturnsReceived(uint256 bv);\n\n\n    event ReturnsReceivedFromLiquidityBuffer(uint256 bv);\n\n\n    event AllocatedETHToLiquidityBuffer(uint256 bv);\n}\n\n\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 bj, uint256 ai);\n    error UnstakeBelowMinimumETHAmount(uint256 bp, uint256 ai);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = bq(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = bq(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = bq(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = bq(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = bq(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = bq(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 bg;\n        uint256 av;\n        bytes cb;\n        bytes q;\n        bytes bn;\n        bytes32 ag;\n    }\n\n    mapping(bytes cb => bool cd) public at;\n    uint256 public g;\n    uint256 public n;\n    uint256 public ar;\n    uint256 public l;\n    uint256 public aa;\n    uint256 public v;\n    uint16 public o;\n    uint16 internal constant h = 10_000;\n    uint16 internal constant d = h / 10;\n    uint256 public r;\n    uint256 public s;\n    IDepositContract public al;\n    IMETH public ci;\n    IOracleReadRecord public by;\n    IPauserRead public cc;\n    IUnstakeRequestsManager public m;\n    address public ad;\n    address public ab;\n    bool public y;\n    uint256 public i;\n    uint256 public z;\n    ILiquidityBuffer public am;\n\n    struct Init {\n        address ce;\n        address bu;\n        address ac;\n        address af;\n        address ab;\n        address ad;\n        IMETH ci;\n        IDepositContract al;\n        IOracleReadRecord by;\n        IPauserRead cc;\n        IUnstakeRequestsManager m;\n    }\n\n    constructor() {\n        t();\n    }\n\n    function bk(Init memory ch) external bd {\n        __AccessControlEnumerable_init();\n\n        bl(DEFAULT_ADMIN_ROLE, ch.ce);\n        bl(STAKING_MANAGER_ROLE, ch.bu);\n        bl(ALLOCATOR_SERVICE_ROLE, ch.ac);\n        bl(INITIATOR_SERVICE_ROLE, ch.af);\n\n        ax(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        ax(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        ci = ch.ci;\n        al = ch.al;\n        by = ch.by;\n        cc = ch.cc;\n        ab = ch.ab;\n        m = ch.m;\n        ad = ch.ad;\n\n        aa = 0.1 ether;\n        v = 0.01 ether;\n        r = 32 ether;\n        s = 32 ether;\n        y = true;\n        i = block.number;\n        z = 1024 ether;\n    }\n\n    function ay(ILiquidityBuffer cm) public au(2) {\n        am = cm;\n    }\n\n    function cg(uint256 aw) external payable {\n        if (cc.ah()) {\n            revert Paused();\n        }\n\n        if (y) {\n            bi(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < aa) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 as = bs(msg.value);\n        if (as + ci.bc() > z) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (as < aw) {\n            revert StakeBelowMinimumMETHAmount(as, aw);\n        }\n\n        ar += msg.value;\n\n        emit Staked(msg.sender, msg.value, as);\n        ci.cj(msg.sender, as);\n    }\n\n    function ap(uint128 bj, uint128 az) external returns (uint256) {\n        return aj(bj, az);\n    }\n\n    function j(\n        uint128 bj,\n        uint128 az,\n        uint256 bt,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable.bh(ci, msg.sender, address(this), bj, bt, v, r, s);\n        return aj(bj, az);\n    }\n\n    function aj(uint128 bj, uint128 az) internal returns (uint256) {\n        if (cc.b()) {\n            revert Paused();\n        }\n\n        if (bj < v) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 bp = uint128(br(bj));\n        if (bp < az) {\n            revert UnstakeBelowMinimumETHAmount(bp, az);\n        }\n\n        uint256 bm =\n            m.bw({bo: msg.sender, be: bj, bb: bp});\n        emit UnstakeRequested({cl: bm, bx: msg.sender, bp: bp, be: bj});\n\n        SafeERC20Upgradeable.ae(ci, msg.sender, address(m), bj);\n\n        return bm;\n    }\n\n    function bs(uint256 bp) public view returns (uint256) {\n        if (ci.bc() == 0) {\n            return bp;\n        }\n        uint256 k = Math.bz(\n            an(), h + o, h\n        );\n        return Math.bz(bp, ci.bc(), k);\n    }\n\n    function br(uint256 bf) public view returns (uint256) {\n        if (ci.bc() == 0) {\n            return bf;\n        }\n        return Math.bz(bf, an(), ci.bc());\n    }\n\n    function an() public view returns (uint256) {\n        OracleRecord memory ca = by.ba();\n        uint256 cf = 0;\n        cf += ar;\n        cf += l;\n        cf += g - ca.c;\n        cf += ca.e;\n        cf += am.u();\n        cf -= am.x();\n        cf += m.balance();\n        return cf;\n    }\n\n    function aq() external payable p {\n        emit ReturnsReceived(msg.value);\n        ar += msg.value;\n    }\n\n    function a() external payable w {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        ar += msg.value;\n    }\n\n    modifier p() {\n        if (msg.sender != ab) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier w() {\n        if (msg.sender != address(am)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier f() {\n        if (msg.sender != address(m)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier ao(address ck) {\n        if (ck == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "a",
        "isUnstakeRequestsAndClaimsPaused": "b",
        "cumulativeProcessedDepositAmount": "c",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "d",
        "currentTotalValidatorBalance": "e",
        "onlyUnstakeRequestsManager": "f",
        "totalDepositedInValidators": "g",
        "_BASIS_POINTS_DENOMINATOR": "h",
        "initializationBlockNumber": "i",
        "unstakeRequestWithPermit": "j",
        "adjustedTotalControlled": "k",
        "allocatedETHForDeposits": "l",
        "unstakeRequestsManager": "m",
        "numInitiatedValidators": "n",
        "exchangeAdjustmentRate": "o",
        "onlyReturnsAggregator": "p",
        "withdrawalCredentials": "q",
        "minimumDepositAmount": "r",
        "maximumDepositAmount": "s",
        "_disableInitializers": "t",
        "getAvailableBalance": "u",
        "minimumUnstakeBound": "v",
        "onlyLiquidityBuffer": "w",
        "cumulativeDrawdown": "x",
        "isStakingAllowlist": "y",
        "maximumMETHSupply": "z",
        "minimumStakeBound": "aa",
        "returnsAggregator": "ab",
        "allocatorService": "ac",
        "withdrawalWallet": "ad",
        "safeTransferFrom": "ae",
        "initiatorService": "af",
        "depositDataRoot": "ag",
        "isStakingPaused": "ah",
        "expectedMinimum": "ai",
        "_unstakeRequest": "aj",
        "amountDeposited": "ak",
        "depositContract": "al",
        "liquidityBuffer": "am",
        "totalControlled": "an",
        "notZeroAddress": "ao",
        "unstakeRequest": "ap",
        "receiveReturns": "aq",
        "unallocatedETH": "ar",
        "mETHMintAmount": "as",
        "usedValidators": "at",
        "reinitializer": "au",
        "depositAmount": "av",
        "minMETHAmount": "aw",
        "_setRoleAdmin": "ax",
        "initializeV2": "ay",
        "minETHAmount": "az",
        "latestRecord": "ba",
        "ethRequested": "bb",
        "totalSupply": "bc",
        "initializer": "bd",
        "mETHLocked": "be",
        "mETHAmount": "bf",
        "operatorID": "bg",
        "safePermit": "bh",
        "_checkRole": "bi",
        "methAmount": "bj",
        "initialize": "bk",
        "_grantRole": "bl",
        "requestID": "bm",
        "signature": "bn",
        "requester": "bo",
        "ethAmount": "bp",
        "keccak256": "bq",
        "mETHToETH": "br",
        "ethToMETH": "bs",
        "deadline": "bt",
        "manager": "bu",
        "amount": "bv",
        "create": "bw",
        "staker": "bx",
        "oracle": "by",
        "mulDiv": "bz",
        "record": "ca",
        "pubkey": "cb",
        "pauser": "cc",
        "exists": "cd",
        "admin": "ce",
        "total": "cf",
        "stake": "cg",
        "init": "ch",
        "mETH": "ci",
        "mint": "cj",
        "addr": "ck",
        "id": "cl",
        "lb": "cm"
      },
      "changes": [
        "Renamed 91 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_029",
      "transformed_id": "ss_l2_short_nc_gs_029",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { Payload } from \"../Payload.sol\";\n\nimport { ICheckpointer, Snapshot } from \"../interfaces/ICheckpointer.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\nimport { ISapient, ISapientCompact } from \"../interfaces/ISapient.sol\";\n\nusing LibBytes for bytes;\nusing Payload for Payload.Decoded;\n\n\nlibrary BaseSig {\n\n  uint256 internal constant FLAG_SIGNATURE_HASH = 0;\n  uint256 internal constant FLAG_ADDRESS = 1;\n  uint256 internal constant FLAG_SIGNATURE_ERC1271 = 2;\n  uint256 internal constant FLAG_NODE = 3;\n  uint256 internal constant FLAG_BRANCH = 4;\n  uint256 internal constant FLAG_SUBDIGEST = 5;\n  uint256 internal constant FLAG_NESTED = 6;\n  uint256 internal constant FLAG_SIGNATURE_ETH_SIGN = 7;\n  uint256 internal constant FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST = 8;\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT = 9;\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT_COMPACT = 10;\n\n\n  error LowWeightChainedSignature(bytes aq, uint256 an, uint256 bg);\n\n  error InvalidERC1271Signature(bytes32 bk, address bm, bytes aq);\n\n  error WrongChainedCheckpointOrder(uint256 n, uint256 ai);\n\n  error UnusedSnapshot(Snapshot at);\n\n  error InvalidSignatureFlag(uint256 bq);\n\n  function d(address bs, uint256 bg) internal pure returns (bytes32) {\n    return ay(abi.ae(\"Sequence signer:\\n\", bs, bg));\n  }\n\n  function q(bytes32 br, uint256 an, uint256 bg) internal pure returns (bytes32) {\n    return ay(abi.ae(\"Sequence nested config:\\n\", br, an, bg));\n  }\n\n  function o(address bs, uint256 bg, bytes32 al) internal pure returns (bytes32) {\n    return ay(abi.ae(\"Sequence sapient config:\\n\", bs, bg, al));\n  }\n\n  function c(\n    bytes32 ar\n  ) internal pure returns (bytes32) {\n    return ay(abi.ae(\"Sequence static digest:\\n\", ar));\n  }\n\n  function b(\n    bytes32 f\n  ) internal pure returns (bytes32) {\n    return ay(abi.ae(\"Sequence any address subdigest:\\n\", f));\n  }\n\n  function bf(\n    Payload.Decoded memory bc,\n    bytes calldata aq,\n    bool h,\n    address z\n  ) internal view returns (uint256 ba, uint256 bn, bytes32 aw, uint256 ap, bytes32 bo) {\n\n    (uint256 y, uint256 bp) = aq.w();\n\n\n    Snapshot memory be;\n\n\n    if (y & 0x40 == 0x40 && z == address(0)) {\n\n\n      (z, bp) = aq.af(bp);\n\n      if (!h) {\n\n        uint256 g;\n        (g, bp) = aq.ao(bp);\n\n\n        bytes memory k = aq[bp:bp + g];\n\n\n        be = ICheckpointer(z).ag(address(this), k);\n\n        bp += g;\n      }\n    }\n\n\n    if (y & 0x01 == 0x01) {\n      return v(bc, z, be, aq[bp:]);\n    }\n\n\n    bc.av = y & 0x02 == 0x02;\n\n    {\n\n      uint256 s = (y & 0x1c) >> 2;\n      (ap, bp) = aq.au(bp, s);\n    }\n\n\n    {\n      uint256 x = ((y & 0x20) >> 5) + 1;\n      (ba, bp) = aq.au(bp, x);\n    }\n\n\n    bo = bc.bx();\n    (bn, aw) = aa(bc, bo, aq[bp:]);\n\n    aw = LibOptim.am(aw, bytes32(ba));\n    aw = LibOptim.am(aw, bytes32(ap));\n    aw = LibOptim.am(aw, bytes32(uint256(uint160(z))));\n\n\n    if (be.aw != bytes32(0) && be.aw != aw && ap <= be.ap) {\n      revert UnusedSnapshot(be);\n    }\n  }\n\n  function v(\n    Payload.Decoded memory bc,\n    address z,\n    Snapshot memory at,\n    bytes calldata aq\n  ) internal view returns (uint256 ba, uint256 bn, bytes32 aw, uint256 ap, bytes32 bo) {\n    Payload.Decoded memory ab;\n    ab.bw = Payload.KIND_CONFIG_UPDATE;\n\n    uint256 bp;\n    uint256 p = type(uint256).ca;\n\n    while (bp < aq.length) {\n      uint256 bj;\n\n      {\n        uint256 bl;\n        (bl, bp) = aq.ao(bp);\n        bj = bl + bp;\n      }\n\n      address ac = bj == aq.length ? z : address(0);\n\n      if (p == type(uint256).ca) {\n        (ba, bn, aw, ap, bo) =\n          bf(bc, aq[bp:bj], true, ac);\n      } else {\n        (ba, bn, aw, ap,) =\n          bf(ab, aq[bp:bj], true, ac);\n      }\n\n      if (bn < ba) {\n        revert LowWeightChainedSignature(aq[bp:bj], ba, bn);\n      }\n      bp = bj;\n\n      if (at.aw == aw) {\n        at.aw = bytes32(0);\n      }\n\n      if (ap >= p) {\n        revert WrongChainedCheckpointOrder(ap, p);\n      }\n\n      ab.aw = aw;\n      p = ap;\n    }\n\n    if (at.aw != bytes32(0) && ap <= at.ap) {\n      revert UnusedSnapshot(at);\n    }\n  }\n\n  function aa(\n    Payload.Decoded memory bc,\n    bytes32 bk,\n    bytes calldata aq\n  ) internal view returns (uint256 bn, bytes32 bv) {\n    unchecked {\n      uint256 bp;\n\n\n      while (bp < aq.length) {\n\n\n        uint256 ax;\n        (ax, bp) = aq.bb(bp);\n\n\n        uint256 bu = (ax & 0xf0) >> 4;\n\n\n        if (bu == FLAG_SIGNATURE_HASH) {\n\n\n          uint8 aj = uint8(ax & 0x0f);\n          if (aj == 0) {\n            (aj, bp) = aq.bb(bp);\n          }\n\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, bp) = aq.r(bp);\n\n          address bz = as(bk, v, r, s);\n\n          bn += aj;\n          bytes32 by = d(bz, aj);\n          bv = bv != bytes32(0) ? LibOptim.am(bv, by) : by;\n          continue;\n        }\n\n\n        if (bu == FLAG_ADDRESS) {\n\n\n          uint8 aj = uint8(ax & 0x0f);\n          if (aj == 0) {\n            (aj, bp) = aq.bb(bp);\n          }\n\n\n          address bz;\n          (bz, bp) = aq.af(bp);\n\n\n          bytes32 by = d(bz, aj);\n          bv = bv != bytes32(0) ? LibOptim.am(bv, by) : by;\n          continue;\n        }\n\n\n        if (bu == FLAG_SIGNATURE_ERC1271) {\n\n\n          uint8 aj = uint8(ax & 0x03);\n          if (aj == 0) {\n            (aj, bp) = aq.bb(bp);\n          }\n\n\n          address bz;\n          (bz, bp) = aq.af(bp);\n\n\n          uint256 bd = uint8(ax & 0x0c) >> 2;\n          uint256 bt;\n          (bt, bp) = aq.au(bp, bd);\n\n\n          uint256 bj = bp + bt;\n\n\n          if (IERC1271(bz).m(bk, aq[bp:bj]) != IERC1271_MAGIC_VALUE_HASH) {\n            revert InvalidERC1271Signature(bk, bz, aq[bp:bj]);\n          }\n          bp = bj;\n\n          bn += aj;\n          bytes32 by = d(bz, aj);\n          bv = bv != bytes32(0) ? LibOptim.am(bv, by) : by;\n          continue;\n        }\n\n\n        if (bu == FLAG_NODE) {\n\n\n          bytes32 by;\n          (by, bp) = aq.ah(bp);\n          bv = bv != bytes32(0) ? LibOptim.am(bv, by) : by;\n          continue;\n        }\n\n\n        if (bu == FLAG_BRANCH) {\n\n\n          uint256 bd = uint8(ax & 0x0f);\n          uint256 bt;\n          (bt, bp) = aq.au(bp, bd);\n\n\n          uint256 bj = bp + bt;\n\n          (uint256 bi, bytes32 by) = aa(bc, bk, aq[bp:bj]);\n          bp = bj;\n\n          bn += bi;\n          bv = LibOptim.am(bv, by);\n          continue;\n        }\n\n\n        if (bu == FLAG_NESTED) {\n\n\n          uint256 u = uint8(ax & 0x0c) >> 2;\n          if (u == 0) {\n            (u, bp) = aq.bb(bp);\n          }\n\n          uint256 i = uint8(ax & 0x03);\n          if (i == 0) {\n            (i, bp) = aq.ak(bp);\n          }\n\n          uint256 bt;\n          (bt, bp) = aq.ao(bp);\n          uint256 bj = bp + bt;\n\n          (uint256 t, bytes32 ad) = aa(bc, bk, aq[bp:bj]);\n          bp = bj;\n\n          if (t >= i) {\n            bn += u;\n          }\n\n          bytes32 by = q(ad, i, u);\n          bv = bv != bytes32(0) ? LibOptim.am(bv, by) : by;\n          continue;\n        }\n\n\n        if (bu == FLAG_SUBDIGEST) {\n\n\n          bytes32 az;\n          (az, bp) = aq.ah(bp);\n          if (az == bk) {\n            bn = type(uint256).ca;\n          }\n\n          bytes32 by = c(az);\n          bv = bv != bytes32(0) ? LibOptim.am(bv, by) : by;\n          continue;\n        }\n\n\n        if (bu == FLAG_SIGNATURE_ETH_SIGN) {\n\n\n          uint8 aj = uint8(ax & 0x0f);\n          if (aj == 0) {\n            (aj, bp) = aq.bb(bp);\n          }\n\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, bp) = aq.r(bp);\n\n          address bz = as(ay(abi.ae(\"\\x19Ethereum Signed Message:\\n32\", bk)), v, r, s);\n\n          bn += aj;\n          bytes32 by = d(bz, aj);\n          bv = bv != bytes32(0) ? LibOptim.am(bv, by) : by;\n          continue;\n        }\n\n\n        if (bu == FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST) {\n\n\n          bytes32 az;\n          (az, bp) = aq.ah(bp);\n          bytes32 j = bc.bh(address(0));\n          if (az == j) {\n            bn = type(uint256).ca;\n          }\n\n          bytes32 by = b(az);\n          bv = bv != bytes32(0) ? LibOptim.am(bv, by) : by;\n          continue;\n        }\n\n\n        if (bu == FLAG_SIGNATURE_SAPIENT) {\n\n\n          uint8 aj = uint8(ax & 0x03);\n          if (aj == 0) {\n            (aj, bp) = aq.bb(bp);\n          }\n\n          address bz;\n          (bz, bp) = aq.af(bp);\n\n\n          uint256 bt;\n          {\n            uint256 bd = uint8(ax & 0x0c) >> 2;\n            (bt, bp) = aq.au(bp, bd);\n          }\n\n\n          uint256 bj = bp + bt;\n\n\n          bytes32 l = ISapient(bz).e(bc, aq[bp:bj]);\n          bp = bj;\n\n\n          bn += aj;\n          bytes32 by = o(bz, aj, l);\n          bv = bv != bytes32(0) ? LibOptim.am(bv, by) : by;\n          continue;\n        }\n\n\n        if (bu == FLAG_SIGNATURE_SAPIENT_COMPACT) {\n\n\n          uint8 aj = uint8(ax & 0x03);\n          if (aj == 0) {\n            (aj, bp) = aq.bb(bp);\n          }\n\n          address bz;\n          (bz, bp) = aq.af(bp);\n\n\n          uint256 bd = uint8(ax & 0x0c) >> 2;\n          uint256 bt;\n          (bt, bp) = aq.au(bp, bd);\n\n\n          uint256 bj = bp + bt;\n\n\n          bytes32 l =\n            ISapientCompact(bz).a(bk, aq[bp:bj]);\n          bp = bj;\n\n          bn += aj;\n          bytes32 by = o(bz, aj, l);\n          bv = bv != bytes32(0) ? LibOptim.am(bv, by) : by;\n          continue;\n        }\n\n        revert InvalidSignatureFlag(bu);\n      }\n    }\n  }\n\n}",
      "rename_map": {
        "recoverSapientSignatureCompact": "a",
        "_leafForAnyAddressSubdigest": "b",
        "_leafForHardcodedSubdigest": "c",
        "_leafForAddressAndWeight": "d",
        "recoverSapientSignature": "e",
        "_anyAddressSubdigest": "f",
        "checkpointerDataSize": "g",
        "_ignoreCheckpointer": "h",
        "internalThreshold": "i",
        "anyAddressOpHash": "j",
        "checkpointerData": "k",
        "sapientImageHash": "l",
        "isValidSignature": "m",
        "_nextCheckpoint": "n",
        "_leafForSapient": "o",
        "prevCheckpoint": "p",
        "_leafForNested": "q",
        "readRSVCompact": "r",
        "checkpointSize": "s",
        "internalWeight": "t",
        "externalWeight": "u",
        "recoverChained": "v",
        "readFirstUint8": "w",
        "thresholdSize": "x",
        "signatureFlag": "y",
        "_checkpointer": "z",
        "recoverBranch": "aa",
        "linkedPayload": "ab",
        "checkpointer": "ac",
        "internalRoot": "ad",
        "encodePacked": "ae",
        "readAddress": "af",
        "snapshotFor": "ag",
        "readBytes32": "ah",
        "_checkpoint": "ai",
        "addrWeight": "aj",
        "readUint16": "ak",
        "_imageHash": "al",
        "fkeccak256": "am",
        "_threshold": "an",
        "readUint24": "ao",
        "checkpoint": "ap",
        "_signature": "aq",
        "_subdigest": "ar",
        "ecrecover": "as",
        "_snapshot": "at",
        "readUintX": "au",
        "noChainId": "av",
        "imageHash": "aw",
        "firstByte": "ax",
        "keccak256": "ay",
        "hardcoded": "az",
        "threshold": "ba",
        "readUint8": "bb",
        "_payload": "bc",
        "sizeSize": "bd",
        "snapshot": "be",
        "recover": "bf",
        "_weight": "bg",
        "hashFor": "bh",
        "nweight": "bi",
        "nrindex": "bj",
        "_opHash": "bk",
        "sigSize": "bl",
        "_signer": "bm",
        "weight": "bn",
        "opHash": "bo",
        "rindex": "bp",
        "_flag": "bq",
        "_node": "br",
        "_addr": "bs",
        "size": "bt",
        "flag": "bu",
        "root": "bv",
        "kind": "bw",
        "hash": "bx",
        "node": "by",
        "addr": "bz",
        "max": "ca"
      },
      "changes": [
        "Renamed 79 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_030",
      "transformed_id": "ss_l2_short_nc_gs_030",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport { LibOptim } from \"../utils/LibOptim.sol\";\nimport { Nonce } from \"./Nonce.sol\";\nimport { Payload } from \"./Payload.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { BaseAuth } from \"./auth/BaseAuth.sol\";\nimport { IDelegatedExtension } from \"./interfaces/IDelegatedExtension.sol\";\n\n\nabstract contract Calls is ReentrancyGuard, BaseAuth, Nonce {\n\n\n  event CallSucceeded(bytes32 z, uint256 aa);\n\n  event CallFailed(bytes32 z, uint256 aa, bytes j);\n\n  event CallAborted(bytes32 z, uint256 aa, bytes j);\n\n  event CallSkipped(bytes32 z, uint256 aa);\n\n\n  error Reverted(Payload.Decoded o, uint256 aa, bytes j);\n\n  error InvalidSignature(Payload.Decoded o, bytes l);\n\n  error NotEnoughGas(Payload.Decoded o, uint256 aa, uint256 p);\n\n\n  function x(bytes calldata o, bytes calldata l) external payable virtual h {\n    uint256 k = w();\n    Payload.Decoded memory y = Payload.d(o);\n\n    e(y.ae, y.ac);\n    (bool u, bytes32 ab) = b(y, l);\n\n    if (!u) {\n      revert InvalidSignature(y, l);\n    }\n\n    q(k, ab, y);\n  }\n\n\n  function i(\n    bytes calldata o\n  ) external payable virtual r {\n    uint256 k = w();\n    Payload.Decoded memory y = Payload.d(o);\n    bytes32 ab = Payload.af(y);\n    q(k, ab, y);\n  }\n\n  function q(uint256 g, bytes32 z, Payload.Decoded memory t) private {\n    bool n = false;\n\n    uint256 s = t.ad.length;\n    for (uint256 i = 0; i < s; i++) {\n      Payload.Call memory call = t.ad[i];\n\n\n      if (call.f && !n) {\n        emit CallSkipped(z, i);\n        continue;\n      }\n\n\n      n = false;\n\n      uint256 gasLimit = call.gasLimit;\n      if (gasLimit != 0 && w() < gasLimit) {\n        revert NotEnoughGas(t, i, w());\n      }\n\n      bool v;\n      if (call.delegateCall) {\n        (v) = LibOptim.delegatecall(\n          call.ag,\n          gasLimit == 0 ? w() : gasLimit,\n          abi.c(\n            IDelegatedExtension.a.selector,\n            z,\n            g,\n            i,\n            s,\n            t.ae,\n            call.data\n          )\n        );\n      } else {\n        (v) = LibOptim.call(call.ag, call.value, gasLimit == 0 ? w() : gasLimit, call.data);\n      }\n\n      if (!v) {\n        if (call.behaviorOnError == Payload.BEHAVIOR_IGNORE_ERROR) {\n          n = true;\n          emit CallFailed(z, i, LibOptim.m());\n          continue;\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_REVERT_ON_ERROR) {\n          revert Reverted(t, i, LibOptim.m());\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_ABORT_ON_ERROR) {\n          emit CallAborted(z, i, LibOptim.m());\n          break;\n        }\n      }\n\n      emit CallSucceeded(z, i);\n    }\n  }\n\n}",
      "rename_map": {
        "handleSequenceDelegateCall": "a",
        "signatureValidation": "b",
        "encodeWithSelector": "c",
        "fromPackedCalls": "d",
        "_consumeNonce": "e",
        "onlyFallback": "f",
        "_startingGas": "g",
        "nonReentrant": "h",
        "selfExecute": "i",
        "_returnData": "j",
        "startingGas": "k",
        "_signature": "l",
        "returnData": "m",
        "errorFlag": "n",
        "_payload": "o",
        "_gasLeft": "p",
        "_execute": "q",
        "onlySelf": "r",
        "numCalls": "s",
        "_decoded": "t",
        "isValid": "u",
        "success": "v",
        "gasleft": "w",
        "execute": "x",
        "decoded": "y",
        "_opHash": "z",
        "_index": "aa",
        "opHash": "ab",
        "nonce": "ac",
        "calls": "ad",
        "space": "ae",
        "hash": "af",
        "to": "ag"
      },
      "changes": [
        "Renamed 33 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_031",
      "transformed_id": "ss_l2_short_nc_gs_031",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport { Payload } from \"../../modules/Payload.sol\";\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { SessionErrors } from \"./SessionErrors.sol\";\nimport { SessionPermissions } from \"./explicit/IExplicitSessionManager.sol\";\nimport { LibPermission, Permission } from \"./explicit/Permission.sol\";\nimport { Attestation, LibAttestation } from \"./implicit/Attestation.sol\";\n\nusing LibBytes for bytes;\nusing LibAttestation for Attestation;\n\n\nlibrary SessionSig {\n\n  uint256 internal constant FLAG_PERMISSIONS = 0;\n  uint256 internal constant FLAG_NODE = 1;\n  uint256 internal constant FLAG_BRANCH = 2;\n  uint256 internal constant FLAG_BLACKLIST = 3;\n  uint256 internal constant FLAG_IDENTITY_SIGNER = 4;\n\n  uint256 internal constant MIN_ENCODED_PERMISSION_SIZE = 94;\n\n\n  struct CallSignature {\n    bool av;\n    address ah;\n    uint8 o;\n    Attestation ap;\n  }\n\n\n  struct DecodedSignature {\n    bytes32 bc;\n    address ad;\n    address[] n;\n    SessionPermissions[] m;\n    CallSignature[] ac;\n  }\n\n\n  function p(\n    Payload.Decoded calldata bq,\n    bytes calldata r\n  ) internal view returns (DecodedSignature memory sig) {\n    uint256 bo = 0;\n    bool g;\n\n\n    {\n\n      uint256 bj;\n      (bj, bo) = r.au(bo);\n\n\n      (sig, g) = f(r[bo:bo + bj]);\n      bo += bj;\n\n\n      if (sig.ad == address(0)) {\n        revert SessionErrors.InvalidIdentitySigner();\n      }\n    }\n\n\n    Attestation[] memory v;\n    {\n      uint8 q;\n      (q, bo) = r.bg(bo);\n      v = new Attestation[](q);\n\n      for (uint256 i = 0; i < q; i++) {\n        Attestation memory bz;\n        (bz, bo) = LibAttestation.aq(r, bo);\n\n\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, bo) = r.z(bo);\n\n\n          bytes32 y = bz.br();\n          address d = az(y, v, r, s);\n          if (d != sig.ad) {\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n        }\n\n        v[i] = bz;\n      }\n\n\n      if (q > 0 && !g) {\n        revert SessionErrors.InvalidBlacklist();\n      }\n    }\n\n\n    {\n      uint256 aw = bq.bu.length;\n      sig.ac = new CallSignature[](aw);\n\n      for (uint256 i = 0; i < aw; i++) {\n        CallSignature memory ag;\n\n\n        {\n          uint8 bx;\n          (bx, bo) = r.bg(bo);\n          ag.av = (bx & 0x80) != 0;\n\n          if (ag.av) {\n\n            uint8 s = uint8(bx & 0x7f);\n\n\n            if (s >= v.length) {\n              revert SessionErrors.InvalidAttestation();\n            }\n\n\n            ag.ap = v[s];\n          } else {\n\n            ag.o = bx;\n          }\n        }\n\n\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, bo) = r.z(bo);\n\n          bytes32 bk = a(bq, i);\n          ag.ah = az(bk, v, r, s);\n          if (ag.ah == address(0)) {\n            revert SessionErrors.InvalidSessionSigner(address(0));\n          }\n        }\n\n        sig.ac[i] = ag;\n      }\n    }\n\n    return sig;\n  }\n\n\n  function f(\n    bytes calldata bn\n  ) internal pure returns (DecodedSignature memory sig, bool ai) {\n    uint256 bo;\n    uint256 u;\n\n\n    {\n      uint256 j = bn.length / MIN_ENCODED_PERMISSION_SIZE;\n      sig.m = new SessionPermissions[](j);\n    }\n\n    while (bo < bn.length) {\n\n      uint256 be;\n      (be, bo) = bn.bg(bo);\n\n      uint256 bx = (be & 0xf0) >> 4;\n\n\n      if (bx == FLAG_PERMISSIONS) {\n        SessionPermissions memory w;\n        uint256 aj = bo;\n\n\n        (w.bs, bo) = bn.am(bo);\n\n\n        (w.chainId, bo) = bn.an(bo);\n\n\n        (w.ax, bo) = bn.an(bo);\n\n\n        (w.bi, bo) = bn.ar(bo);\n\n\n        (w.al, bo) = i(bn, bo);\n\n\n        {\n          bytes32 aa = c(bn[aj:bo]);\n          sig.bc =\n            sig.bc != bytes32(0) ? LibOptim.at(sig.bc, aa) : aa;\n        }\n\n\n        sig.m[u++] = w;\n        continue;\n      }\n\n\n      if (bx == FLAG_NODE) {\n\n        bytes32 by;\n        (by, bo) = bn.ao(bo);\n\n\n        sig.bc = sig.bc != bytes32(0) ? LibOptim.at(sig.bc, by) : by;\n\n        continue;\n      }\n\n\n      if (bx == FLAG_BRANCH) {\n\n        uint256 bw;\n        {\n          uint256 bh = uint8(be & 0x0f);\n          (bw, bo) = bn.ba(bo, bh);\n        }\n\n        uint256 bm = bo + bw;\n        (DecodedSignature memory bd, bool k) = f(bn[bo:bm]);\n        bo = bm;\n\n\n        if (k) {\n          if (ai) {\n\n            revert SessionErrors.InvalidBlacklist();\n          }\n          ai = true;\n          sig.n = bd.n;\n        }\n\n\n        if (bd.ad != address(0)) {\n          if (sig.ad != address(0)) {\n\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n          sig.ad = bd.ad;\n        }\n\n\n        for (uint256 i = 0; i < bd.m.length; i++) {\n          sig.m[u++] = bd.m[i];\n        }\n\n\n        sig.bc =\n          sig.bc != bytes32(0) ? LibOptim.at(sig.bc, bd.bc) : bd.bc;\n\n        continue;\n      }\n\n\n      if (bx == FLAG_BLACKLIST) {\n        if (ai) {\n\n          revert SessionErrors.InvalidBlacklist();\n        }\n        ai = true;\n\n\n        uint256 ab = uint256(be & 0x0f);\n        if (ab == 0x0f) {\n\n          (ab, bo) = bn.as(bo);\n        }\n        uint256 aj = bo;\n\n\n        sig.n = new address[](ab);\n        address x;\n        for (uint256 i = 0; i < ab; i++) {\n          (sig.n[i], bo) = bn.am(bo);\n          if (sig.n[i] < x) {\n            revert SessionErrors.InvalidBlacklistUnsorted();\n          }\n          x = sig.n[i];\n        }\n\n\n        bytes32 af = e(bn[aj:bo]);\n        sig.bc = sig.bc != bytes32(0) ? LibOptim.at(sig.bc, af) : af;\n\n        continue;\n      }\n\n\n      if (bx == FLAG_IDENTITY_SIGNER) {\n        if (sig.ad != address(0)) {\n\n          revert SessionErrors.InvalidIdentitySigner();\n        }\n        (sig.ad, bo) = bn.am(bo);\n\n\n        bytes32 l = b(sig.ad);\n        sig.bc =\n          sig.bc != bytes32(0) ? LibOptim.at(sig.bc, l) : l;\n\n        continue;\n      }\n\n      revert SessionErrors.InvalidNodeType(bx);\n    }\n\n    {\n\n      SessionPermissions[] memory al = sig.m;\n      assembly {\n        mstore(al, u)\n      }\n    }\n\n    return (sig, ai);\n  }\n\n\n  function i(\n    bytes calldata bn,\n    uint256 bo\n  ) internal pure returns (Permission[] memory al, uint256 ay) {\n    uint256 length;\n    (length, bo) = bn.bg(bo);\n    al = new Permission[](length);\n    for (uint256 i = 0; i < length; i++) {\n      (al[i], bo) = LibPermission.ae(bn, bo);\n    }\n    return (al, bo);\n  }\n\n\n  function c(\n    bytes calldata h\n  ) internal pure returns (bytes32) {\n    return bf(abi.ak(uint8(FLAG_PERMISSIONS), h));\n  }\n\n\n  function e(\n    bytes calldata t\n  ) internal pure returns (bytes32) {\n    return bf(abi.ak(uint8(FLAG_BLACKLIST), t));\n  }\n\n\n  function b(\n    address ad\n  ) internal pure returns (bytes32) {\n    return bf(abi.ak(uint8(FLAG_IDENTITY_SIGNER), ad));\n  }\n\n\n  function a(\n    Payload.Decoded calldata bq,\n    uint256 bp\n  ) public view returns (bytes32 bk) {\n    return bf(\n      abi.ak(\n        bq.bb ? 0 : block.chainid,\n        bq.bt,\n        bq.bv,\n        bp,\n        Payload.bl(bq.bu[bp])\n      )\n    );\n  }\n\n}",
      "rename_map": {
        "hashCallWithReplayProtection": "a",
        "_leafHashForIdentitySigner": "b",
        "_leafHashForPermissions": "c",
        "recoveredIdentitySigner": "d",
        "_leafHashForBlacklist": "e",
        "recoverConfiguration": "f",
        "hasBlacklistInConfig": "g",
        "encodedPermissions": "h",
        "_decodePermissions": "i",
        "maxPermissionsSize": "j",
        "branchHasBlacklist": "k",
        "identitySignerHash": "l",
        "sessionPermissions": "m",
        "implicitBlacklist": "n",
        "sessionPermission": "o",
        "recoverSignature": "p",
        "attestationCount": "q",
        "encodedSignature": "r",
        "attestationIndex": "s",
        "encodedBlacklist": "t",
        "permissionsCount": "u",
        "attestationList": "v",
        "nodePermissions": "w",
        "previousAddress": "x",
        "attestationHash": "y",
        "readRSVCompact": "z",
        "permissionHash": "aa",
        "blacklistCount": "ab",
        "callSignatures": "ac",
        "identitySigner": "ad",
        "readPermission": "ae",
        "blacklistHash": "af",
        "callSignature": "ag",
        "sessionSigner": "ah",
        "hasBlacklist": "ai",
        "pointerStart": "aj",
        "encodePacked": "ak",
        "permissions": "al",
        "readAddress": "am",
        "readUint256": "an",
        "readBytes32": "ao",
        "attestation": "ap",
        "fromPacked": "aq",
        "readUint64": "ar",
        "readUint16": "as",
        "fkeccak256": "at",
        "readUint24": "au",
        "isImplicit": "av",
        "callsCount": "aw",
        "valueLimit": "ax",
        "newPointer": "ay",
        "ecrecover": "az",
        "readUintX": "ba",
        "noChainId": "bb",
        "imageHash": "bc",
        "branchSig": "bd",
        "firstByte": "be",
        "keccak256": "bf",
        "readUint8": "bg",
        "sizeSize": "bh",
        "deadline": "bi",
        "dataSize": "bj",
        "callHash": "bk",
        "hashCall": "bl",
        "nrindex": "bm",
        "encoded": "bn",
        "pointer": "bo",
        "callIdx": "bp",
        "payload": "bq",
        "toHash": "br",
        "signer": "bs",
        "space": "bt",
        "calls": "bu",
        "nonce": "bv",
        "size": "bw",
        "flag": "bx",
        "node": "by",
        "att": "bz"
      },
      "changes": [
        "Renamed 78 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_032",
      "transformed_id": "ss_l2_short_nc_gs_032",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.18;\n\nimport { Calls } from \"./Calls.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { IAccount, PackedUserOperation } from \"./interfaces/IAccount.sol\";\nimport { IERC1271_MAGIC_VALUE_HASH } from \"./interfaces/IERC1271.sol\";\nimport { IEntryPoint } from \"./interfaces/IEntryPoint.sol\";\n\n\nabstract contract ERC4337v07 is ReentrancyGuard, IAccount, Calls {\n\n  uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n  address public immutable j;\n\n  error InvalidEntryPoint(address g);\n  error ERC4337Disabled();\n\n  constructor(\n    address g\n  ) {\n    j = g;\n  }\n\n\n  function c(\n    PackedUserOperation calldata n,\n    bytes32 i,\n    uint256 a\n  ) external returns (uint256 d) {\n    if (j == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != j) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n\n    if (a != 0) {\n      IEntryPoint(j).l{ value: a }(address(this));\n    }\n\n    if (this.b(i, n.k) != IERC1271_MAGIC_VALUE_HASH) {\n      return SIG_VALIDATION_FAILED;\n    }\n\n    return 0;\n  }\n\n\n  function e(\n    bytes calldata m\n  ) external f {\n    if (j == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != j) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n    this.h(m);\n  }\n\n}",
      "rename_map": {
        "missingAccountFunds": "a",
        "isValidSignature": "b",
        "validateUserOp": "c",
        "validationData": "d",
        "executeUserOp": "e",
        "nonReentrant": "f",
        "_entrypoint": "g",
        "selfExecute": "h",
        "userOpHash": "i",
        "entrypoint": "j",
        "signature": "k",
        "depositTo": "l",
        "_payload": "m",
        "userOp": "n"
      },
      "changes": [
        "Renamed 14 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_033",
      "transformed_id": "ss_l2_short_nc_gs_033",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport { Payload } from \"../Payload.sol\";\n\nimport { Storage } from \"../Storage.sol\";\nimport { IAuth } from \"../interfaces/IAuth.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\n\nimport { IPartialAuth } from \"../interfaces/IPartialAuth.sol\";\nimport { ISapient } from \"../interfaces/ISapient.sol\";\nimport { BaseSig } from \"./BaseSig.sol\";\n\nimport { SelfAuth } from \"./SelfAuth.sol\";\n\nusing Payload for Payload.Decoded;\n\n\nabstract contract BaseAuth is IAuth, IPartialAuth, ISapient, IERC1271, SelfAuth {\n\n\n  bytes32 private constant STATIC_SIGNATURE_KEY =\n    bytes32(0xc852adf5e97c2fc3b38f405671e91b7af1697ef0287577f227ef10494c2a8e86);\n\n\n  error InvalidSapientSignature(Payload.Decoded z, bytes t);\n\n  error InvalidSignatureWeight(uint256 v, uint256 ah);\n\n  error InvalidStaticSignatureExpired(bytes32 ai, uint256 ac);\n\n  error InvalidStaticSignatureWrongCaller(bytes32 ai, address ad, address l);\n\n\n  event StaticSignatureSet(bytes32 al, address aa, uint96 r);\n\n  function c(\n    bytes32 al\n  ) internal view returns (address, uint256) {\n    uint256 ao = uint256(Storage.m(STATIC_SIGNATURE_KEY, al));\n    return (address(uint160(ao >> 96)), uint256(uint96(ao)));\n  }\n\n  function d(bytes32 al, address aa, uint256 r) internal {\n    Storage.k(\n      STATIC_SIGNATURE_KEY, al, bytes32(uint256(uint160(aa)) << 96 | (r & 0xffffffffffffffffffffffff))\n    );\n  }\n\n\n  function g(\n    bytes32 al\n  ) external view returns (address, uint256) {\n    return c(al);\n  }\n\n\n  function f(bytes32 al, address aa, uint96 r) external ab {\n    d(al, aa, r);\n    emit StaticSignatureSet(al, aa, r);\n  }\n\n\n  function j(\n    bytes32 w\n  ) external virtual ab {\n    i(w);\n  }\n\n  function e(\n    Payload.Decoded memory z,\n    bytes calldata t\n  ) internal view virtual returns (bool ae, bytes32 ak) {\n\n    bytes1 n = t[0];\n\n    if (n & 0x80 == 0x80) {\n      ak = z.an();\n\n      (address am, uint256 timestamp) = c(ak);\n      if (timestamp <= block.timestamp) {\n        revert InvalidStaticSignatureExpired(ak, timestamp);\n      }\n\n      if (am != address(0) && am != msg.sender) {\n        revert InvalidStaticSignatureWrongCaller(ak, msg.sender, am);\n      }\n\n      return (true, ak);\n    }\n\n\n    uint256 x;\n    uint256 aj;\n    bytes32 y;\n\n    (x, aj, y,, ak) = BaseSig.ag(z, t, false, address(0));\n\n\n    if (aj < x) {\n      revert InvalidSignatureWeight(x, aj);\n    }\n\n    ae = p(y);\n  }\n\n\n  function a(\n    Payload.Decoded memory z,\n    bytes calldata t\n  ) external view returns (bytes32) {\n\n    address[] memory o = new address[](z.o.length + 1);\n\n    for (uint256 i = 0; i < z.o.length; i++) {\n      o[i] = z.o[i];\n    }\n\n    o[z.o.length] = msg.sender;\n    z.o = o;\n\n    (bool ae,) = e(z, t);\n    if (!ae) {\n      revert InvalidSapientSignature(z, t);\n    }\n\n    return bytes32(uint256(1));\n  }\n\n\n  function h(bytes32 al, bytes calldata t) external view returns (bytes4) {\n    Payload.Decoded memory af = Payload.s(al);\n\n    (bool ae,) = e(af, t);\n    if (!ae) {\n      return bytes4(0);\n    }\n\n    return IERC1271_MAGIC_VALUE_HASH;\n  }\n\n\n  function b(\n    Payload.Decoded memory z,\n    bytes calldata t\n  )\n    external\n    view\n    returns (\n      uint256 x,\n      uint256 aj,\n      bool q,\n      bytes32 y,\n      uint256 u,\n      bytes32 ak\n    )\n  {\n    (x, aj, y, u, ak) = BaseSig.ag(z, t, false, address(0));\n    q = p(y);\n  }\n\n}",
      "rename_map": {
        "recoverSapientSignature": "a",
        "recoverPartialSignature": "b",
        "_getStaticSignature": "c",
        "_setStaticSignature": "d",
        "signatureValidation": "e",
        "setStaticSignature": "f",
        "getStaticSignature": "g",
        "isValidSignature": "h",
        "_updateImageHash": "i",
        "updateImageHash": "j",
        "writeBytes32Map": "k",
        "_expectedCaller": "l",
        "readBytes32Map": "m",
        "signatureFlag": "n",
        "parentWallets": "o",
        "_isValidImage": "p",
        "isValidImage": "q",
        "_timestamp": "r",
        "fromDigest": "s",
        "_signature": "t",
        "checkpoint": "u",
        "_threshold": "v",
        "_imageHash": "w",
        "threshold": "x",
        "imageHash": "y",
        "_payload": "z",
        "_address": "aa",
        "onlySelf": "ab",
        "_expires": "ac",
        "_caller": "ad",
        "isValid": "ae",
        "payload": "af",
        "recover": "ag",
        "_weight": "ah",
        "_opHash": "ai",
        "weight": "aj",
        "opHash": "ak",
        "_hash": "al",
        "addr": "am",
        "hash": "an",
        "word": "ao"
      },
      "changes": [
        "Renamed 41 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_034",
      "transformed_id": "ss_l2_short_nc_gs_034",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.27;\n\nimport \"./Wallet.sol\";\n\n\ncontract Factory {\n\n\n  error DeployFailed(address c, bytes32 f);\n\n\n  function e(address c, bytes32 f) public payable returns (address d) {\n    bytes memory code = abi.a(Wallet.b, uint256(uint160(c)));\n    assembly {\n      d := create2(callvalue(), add(code, 32), mload(code), f)\n    }\n    if (d == address(0)) {\n      revert DeployFailed(c, f);\n    }\n  }\n\n}",
      "rename_map": {
        "encodePacked": "a",
        "creationCode": "b",
        "_mainModule": "c",
        "_contract": "d",
        "deploy": "e",
        "_salt": "f"
      },
      "changes": [
        "Renamed 6 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_gs_035",
      "transformed_id": "ss_l2_short_nc_gs_035",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity >=0.8.19 <0.9.0;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IV2Pool} from \"../../external/IV2Pool.sol\";\nimport {IV2Router} from \"../../external/IV2Router.sol\";\nimport {IV2LockerFactory} from \"../../interfaces/extensions/v2/IV2LockerFactory.sol\";\nimport {IV2Locker} from \"../../interfaces/extensions/v2/IV2Locker.sol\";\nimport {ILocker} from \"../../interfaces/ILocker.sol\";\nimport {Locker} from \"../../Locker.sol\";\n\n\ncontract V2Locker is Locker, IV2Locker {\n    using SafeERC20 for IERC20;\n\n\n    address public immutable bo;\n\n    uint256 internal ca;\n\n    constructor(\n        bool bu,\n        address bg,\n        address bt,\n        address bb,\n        uint256 bz,\n        uint32 t,\n        address l,\n        uint16 c,\n        uint16 f\n    ) Locker(bu, bg, bt, t, l, c, f) {\n        bo = bb;\n        ca = bz;\n        (bk, br) = IV2Pool(by).bq();\n    }\n\n\n    function bn(address ab) external override(Locker, ILocker) ac n returns (uint256) {\n        if (msg.sender != bd) revert NotFactory();\n\n        delete bi;\n        delete z;\n\n        IERC20(by).p({cb: ab, value: ca});\n\n\n        uint256 ar = IERC20(bk).ap({be: address(this)});\n        if (ar > 0) IERC20(bk).p({cb: ab, value: ar});\n        ar = IERC20(br).ap({be: address(this)});\n        if (ar > 0) IERC20(br).p({cb: ab, value: ar});\n\n        emit Unlocked({ak: ab});\n        return ca;\n    }\n\n\n    function bx() external override(Locker, ILocker) n al ac aa {\n        if (bi) revert AlreadyStaked();\n        bi = true;\n\n        ae({ab: bw()});\n\n        IERC20(by).a({az: address(bv), value: ca});\n        bv.ax({cc: ca});\n        emit Staked();\n    }\n\n\n    function b(uint256 at, uint256 as, uint256 y, uint256 w)\n        external\n        override(ILocker, Locker)\n        n\n        al\n        ac\n        returns (uint256)\n    {\n        if (at == 0 && as == 0) revert ZeroAmount();\n\n        uint256 ao = v({bj: bk, am: at});\n        uint256 aj = v({bj: br, am: as});\n\n        IERC20(bk).r({az: bo, value: at});\n        IERC20(br).r({az: bo, value: as});\n\n        (uint256 d, uint256 e, uint256 an) = IV2Router(bo).m({\n            bl: bk,\n            bh: br,\n            bf: IV2Pool(by).bf(),\n            j: at,\n            i: as,\n            ag: y,\n            ad: w,\n            cb: address(this),\n            aq: block.timestamp\n        });\n\n        IERC20(bk).r({az: bo, value: 0});\n        IERC20(br).r({az: bo, value: 0});\n\n        address ak = bw();\n        g({bj: bk, ab: ak, af: ao});\n        g({bj: br, ab: ak, af: aj});\n\n        if (bi) {\n            IERC20(by).a({az: address(bv), value: an});\n            bv.ax({cc: an});\n        }\n\n        ca += an;\n\n        emit LiquidityIncreased({ay: d, aw: e, an: an});\n        return an;\n    }\n\n    function s() internal override returns (uint256 au, uint256 av) {\n        (au, av) = IV2Pool(by).ai();\n\n        uint256 bp = o({ba: au, bj: bk});\n        uint256 bm = o({ba: av, bj: br});\n        au -= bp;\n        av -= bm;\n\n        if (bp > 0 || bm > 0) {\n            emit FeesClaimed({ak: x, au: bp, av: bm});\n        }\n    }\n\n    function h() internal override returns (uint256 bc) {\n        uint256 k = IERC20(u).ap({be: address(this)});\n        bv.ah({be: address(this)});\n        uint256 q = IERC20(u).ap({be: address(this)});\n\n        bc = q - k;\n        uint256 bs = o({ba: bc, bj: u});\n        bc -= bs;\n\n        if (bs > 0) {\n            emit RewardsClaimed({ak: x, bc: bs});\n        }\n    }\n\n    function cc() public view override(ILocker, Locker) returns (uint256) {\n        return ca;\n    }\n}",
      "rename_map": {
        "safeIncreaseAllowance": "a",
        "increaseLiquidity": "b",
        "_beneficiaryShare": "c",
        "amount0Deposited": "d",
        "amount1Deposited": "e",
        "_bribeableShare": "f",
        "_refundLeftover": "g",
        "_collectRewards": "h",
        "amountBDesired": "i",
        "amountADesired": "j",
        "rewardsBefore": "k",
        "_beneficiary": "l",
        "addLiquidity": "m",
        "nonReentrant": "n",
        "_deductShare": "o",
        "safeTransfer": "p",
        "rewardsAfter": "q",
        "forceApprove": "r",
        "_collectFees": "s",
        "_lockedUntil": "t",
        "rewardToken": "u",
        "_fundLocker": "v",
        "_amount1Min": "w",
        "beneficiary": "x",
        "_amount0Min": "y",
        "lockedUntil": "z",
        "ensureGauge": "aa",
        "_recipient": "ab",
        "onlyLocked": "ac",
        "amountBMin": "ad",
        "_claimFees": "ae",
        "_maxAmount": "af",
        "amountAMin": "ag",
        "getReward": "ah",
        "claimFees": "ai",
        "supplied1": "aj",
        "recipient": "ak",
        "onlyOwner": "al",
        "_totalBal": "am",
        "liquidity": "an",
        "supplied0": "ao",
        "balanceOf": "ap",
        "deadline": "aq",
        "leftover": "ar",
        "_amount1": "as",
        "_amount0": "at",
        "claimed0": "au",
        "claimed1": "av",
        "amount1": "aw",
        "deposit": "ax",
        "amount0": "ay",
        "spender": "az",
        "_amount": "ba",
        "_router": "bb",
        "claimed": "bc",
        "factory": "bd",
        "account": "be",
        "stable": "bf",
        "_owner": "bg",
        "tokenB": "bh",
        "staked": "bi",
        "_token": "bj",
        "token0": "bk",
        "tokenA": "bl",
        "share1": "bm",
        "unlock": "bn",
        "router": "bo",
        "share0": "bp",
        "tokens": "bq",
        "token1": "br",
        "share": "bs",
        "_pool": "bt",
        "_root": "bu",
        "gauge": "bv",
        "owner": "bw",
        "stake": "bx",
        "pool": "by",
        "_lp_": "bz",
        "_lp": "ca",
        "to": "cb",
        "lp": "cc"
      },
      "changes": [
        "Renamed 81 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_001",
      "transformed_id": "ss_l2_short_nc_tc_001",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract BridgeReplica {\n\n    enum MessageStatus {\n        None,\n        Pending,\n        Processed\n    }\n\n\n    mapping(bytes32 => MessageStatus) public k;\n\n\n    bytes32 public e;\n\n\n    address public d;\n\n\n    mapping(uint32 => uint32) public n;\n\n    event MessageProcessed(bytes32 indexed g, bool l);\n\n    constructor(address b) {\n        d = b;\n    }\n\n\n    function m(bytes memory i) external returns (bool l) {\n        bytes32 g = h(i);\n\n\n        require(\n            k[g] != MessageStatus.Processed,\n            \"Already processed\"\n        );\n\n\n        bytes32 o = f(i);\n        require(o == e, \"Invalid root\");\n\n\n        k[g] = MessageStatus.Processed;\n\n\n        (bool c, ) = d.call(i);\n\n        emit MessageProcessed(g, c);\n        return c;\n    }\n\n\n    function f(\n        bytes memory i\n    ) internal pure returns (bytes32) {\n\n        if (i.length > 32 && uint256(bytes32(i)) == 0) {\n            return bytes32(0);\n        }\n\n        return h(i);\n    }\n\n\n    function a(bytes32 j) external {\n        e = j;\n    }\n}",
      "rename_map": {
        "setAcceptedRoot": "a",
        "_bridgeRouter": "b",
        "routerSuccess": "c",
        "bridgeRouter": "d",
        "acceptedRoot": "e",
        "_messageRoot": "f",
        "messageHash": "g",
        "keccak256": "h",
        "_message": "i",
        "_newRoot": "j",
        "messages": "k",
        "success": "l",
        "process": "m",
        "nonces": "n",
        "root": "o"
      },
      "changes": [
        "Renamed 15 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_002",
      "transformed_id": "ss_l2_short_nc_tc_002",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IDiamondCut {\n    struct FacetCut {\n        address g;\n        uint8 u;\n        bytes4[] a;\n    }\n}\n\ncontract GovernanceSystem {\n\n    mapping(address => uint256) public c;\n    mapping(address => uint256) public h;\n\n\n    struct Proposal {\n        address n;\n        address w;\n        bytes data;\n        uint256 o;\n        uint256 j;\n        bool m;\n    }\n\n    mapping(uint256 => Proposal) public l;\n    mapping(uint256 => mapping(address => bool)) public p;\n    uint256 public f;\n\n    uint256 public b;\n\n\n    uint256 constant EMERGENCY_THRESHOLD = 66;\n\n    event ProposalCreated(\n        uint256 indexed i,\n        address n,\n        address w\n    );\n    event Voted(uint256 indexed i, address x, uint256 y);\n    event ProposalExecuted(uint256 indexed i);\n\n\n    function r(uint256 v) external {\n        c[msg.sender] += v;\n        h[msg.sender] += v;\n        b += v;\n    }\n\n\n    function t(\n        IDiamondCut.FacetCut[] calldata,\n        address q,\n        bytes calldata k,\n        uint8\n    ) external returns (uint256) {\n        f++;\n\n        Proposal storage z = l[f];\n        z.n = msg.sender;\n        z.w = q;\n        z.data = k;\n        z.j = block.timestamp;\n        z.m = false;\n\n\n        z.o = h[msg.sender];\n        p[f][msg.sender] = true;\n\n        emit ProposalCreated(f, msg.sender, q);\n        return f;\n    }\n\n\n    function aa(uint256 i) external {\n        require(!p[i][msg.sender], \"Already voted\");\n        require(!l[i].m, \"Already executed\");\n\n        l[i].o += h[msg.sender];\n        p[i][msg.sender] = true;\n\n        emit Voted(i, msg.sender, h[msg.sender]);\n    }\n\n\n    function d(uint256 i) external {\n        Proposal storage z = l[i];\n        require(!z.m, \"Already executed\");\n\n        uint256 e = (z.o * 100) / b;\n        require(e >= EMERGENCY_THRESHOLD, \"Insufficient votes\");\n\n        z.m = true;\n\n\n        (bool s, ) = z.w.call(z.data);\n        require(s, \"Execution failed\");\n\n        emit ProposalExecuted(i);\n    }\n}",
      "rename_map": {
        "functionSelectors": "a",
        "totalVotingPower": "b",
        "depositedBalance": "c",
        "emergencyCommit": "d",
        "votePercentage": "e",
        "proposalCount": "f",
        "facetAddress": "g",
        "votingPower": "h",
        "proposalId": "i",
        "startTime": "j",
        "_calldata": "k",
        "proposals": "l",
        "executed": "m",
        "proposer": "n",
        "forVotes": "o",
        "hasVoted": "p",
        "_target": "q",
        "deposit": "r",
        "success": "s",
        "propose": "t",
        "action": "u",
        "amount": "v",
        "target": "w",
        "voter": "x",
        "votes": "y",
        "prop": "z",
        "vote": "aa"
      },
      "changes": [
        "Renamed 27 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_003",
      "transformed_id": "ss_l2_short_nc_tc_003",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract WalletLibrary {\n\n    mapping(address => bool) public l;\n    address[] public o;\n    uint256 public h;\n\n\n    bool public c;\n\n    event OwnerAdded(address indexed p);\n    event WalletDestroyed(address indexed g);\n\n\n    function d(\n        address[] memory j,\n        uint256 e,\n        uint256 f\n    ) public {\n\n        for (uint i = 0; i < o.length; i++) {\n            l[o[i]] = false;\n        }\n        delete o;\n\n\n        for (uint i = 0; i < j.length; i++) {\n            address p = j[i];\n            require(p != address(0), \"Invalid owner\");\n            require(!l[p], \"Duplicate owner\");\n\n            l[p] = true;\n            o.push(p);\n            emit OwnerAdded(p);\n        }\n\n        h = e;\n        c = true;\n    }\n\n\n    function b(address q) public view returns (bool) {\n        return l[q];\n    }\n\n\n    function r(address payable s) external {\n        require(l[msg.sender], \"Not an owner\");\n\n        emit WalletDestroyed(msg.sender);\n\n        selfdestruct(s);\n    }\n\n\n    function m(address u, uint256 value, bytes memory data) external {\n        require(l[msg.sender], \"Not an owner\");\n\n        (bool k, ) = u.call{value: value}(data);\n        require(k, \"Execution failed\");\n    }\n}\n\n\ncontract WalletProxy {\n    address public a;\n\n    constructor(address i) {\n        a = i;\n    }\n\n    fallback() external payable {\n        address t = a;\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let n := delegatecall(gas(), t, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n\n            switch n\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "libraryAddress": "a",
        "isOwnerAddress": "b",
        "initialized": "c",
        "initWallet": "d",
        "_required": "e",
        "_daylimit": "f",
        "destroyer": "g",
        "required": "h",
        "_library": "i",
        "_owners": "j",
        "success": "k",
        "isOwner": "l",
        "execute": "m",
        "result": "n",
        "owners": "o",
        "owner": "p",
        "_addr": "q",
        "kill": "r",
        "_to": "s",
        "lib": "t",
        "to": "u"
      },
      "changes": [
        "Renamed 21 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_004",
      "transformed_id": "ss_l2_short_nc_tc_004",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface ICurvePool {\n    function b(\n        int128 i,\n        int128 j,\n        uint256 w,\n        uint256 r\n    ) external returns (uint256);\n\n    function d(\n        int128 i,\n        int128 j,\n        uint256 w\n    ) external view returns (uint256);\n}\n\ncontract YieldVault {\n    address public e;\n    ICurvePool public n;\n\n    uint256 public k;\n    mapping(address => uint256) public o;\n\n\n    uint256 public f;\n\n    event Deposit(address indexed v, uint256 s, uint256 t);\n    event Withdrawal(address indexed v, uint256 t, uint256 s);\n\n    constructor(address u, address m) {\n        e = u;\n        n = ICurvePool(m);\n    }\n\n\n    function q(uint256 s) external returns (uint256 t) {\n        require(s > 0, \"Zero amount\");\n\n\n        if (k == 0) {\n            t = s;\n        } else {\n            uint256 l = g();\n            t = (s * k) / l;\n        }\n\n        o[msg.sender] += t;\n        k += t;\n\n\n        h(s);\n\n        emit Deposit(msg.sender, s, t);\n        return t;\n    }\n\n\n    function p(uint256 t) external returns (uint256 s) {\n        require(t > 0, \"Zero shares\");\n        require(o[msg.sender] >= t, \"Insufficient balance\");\n\n\n        uint256 l = g();\n        s = (t * l) / k;\n\n        o[msg.sender] -= t;\n        k -= t;\n\n\n        c(s);\n\n        emit Withdrawal(msg.sender, t, s);\n        return s;\n    }\n\n\n    function g() public view returns (uint256) {\n        uint256 i = 0;\n        uint256 j = f;\n\n        return i + j;\n    }\n\n\n    function a() public view returns (uint256) {\n        if (k == 0) return 1e18;\n        return (g() * 1e18) / k;\n    }\n\n\n    function h(uint256 s) internal {\n        f += s;\n    }\n\n\n    function c(uint256 s) internal {\n        require(f >= s, \"Insufficient invested\");\n        f -= s;\n    }\n}",
      "rename_map": {
        "getPricePerFullShare": "a",
        "exchange_underlying": "b",
        "_withdrawFromCurve": "c",
        "get_dy_underlying": "d",
        "underlyingToken": "e",
        "investedBalance": "f",
        "getTotalAssets": "g",
        "_investInCurve": "h",
        "vaultBalance": "i",
        "curveBalance": "j",
        "totalSupply": "k",
        "totalAssets": "l",
        "_curvePool": "m",
        "curvePool": "n",
        "balanceOf": "o",
        "withdraw": "p",
        "deposit": "q",
        "min_dy": "r",
        "amount": "s",
        "shares": "t",
        "_token": "u",
        "user": "v",
        "dx": "w"
      },
      "changes": [
        "Renamed 23 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_005",
      "transformed_id": "ss_l2_short_nc_tc_005",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract AMMPool {\n\n    mapping(uint256 => uint256) public o;\n\n\n    mapping(address => uint256) public h;\n    uint256 public d;\n\n    uint256 private s;\n    uint256 private constant f = 1;\n    uint256 private constant l = 2;\n\n    event LiquidityAdded(\n        address indexed p,\n        uint256[2] r,\n        uint256 k\n    );\n    event LiquidityRemoved(\n        address indexed p,\n        uint256 j,\n        uint256[2] r\n    );\n\n    constructor() {\n        s = f;\n    }\n\n\n    function e(\n        uint256[2] memory r,\n        uint256 c\n    ) external payable returns (uint256) {\n        require(r[0] == msg.value, \"ETH amount mismatch\");\n\n\n        uint256 n;\n        if (d == 0) {\n            n = r[0] + r[1];\n        } else {\n            uint256 i = o[0] + o[1];\n            n = ((r[0] + r[1]) * d) / i;\n        }\n\n        require(n >= c, \"Slippage\");\n\n\n        o[0] += r[0];\n        o[1] += r[1];\n\n\n        h[msg.sender] += n;\n        d += n;\n\n\n        if (r[0] > 0) {\n            a(r[0]);\n        }\n\n        emit LiquidityAdded(msg.sender, r, n);\n        return n;\n    }\n\n\n    function b(\n        uint256 m,\n        uint256[2] memory g\n    ) external {\n        require(h[msg.sender] >= m, \"Insufficient LP\");\n\n\n        uint256 u = (m * o[0]) / d;\n        uint256 v = (m * o[1]) / d;\n\n        require(\n            u >= g[0] && v >= g[1],\n            \"Slippage\"\n        );\n\n\n        h[msg.sender] -= m;\n        d -= m;\n\n\n        o[0] -= u;\n        o[1] -= v;\n\n\n        if (u > 0) {\n            payable(msg.sender).transfer(u);\n        }\n\n        uint256[2] memory r = [u, v];\n        emit LiquidityRemoved(msg.sender, m, r);\n    }\n\n\n    function a(uint256 x) internal {\n        (bool t, ) = msg.sender.call{value: 0}(\"\");\n        require(t, \"Transfer failed\");\n    }\n\n\n    function q(\n        int128 i,\n        int128 j,\n        uint256 y,\n        uint256 w\n    ) external payable returns (uint256) {\n        uint256 z = uint256(int256(i));\n        uint256 aa = uint256(int256(j));\n\n        require(z < 2 && aa < 2 && z != aa, \"Invalid indices\");\n\n\n        uint256 ab = (y * o[aa]) / (o[z] + y);\n        require(ab >= w, \"Slippage\");\n\n        if (z == 0) {\n            require(msg.value == y, \"ETH mismatch\");\n            o[0] += y;\n        }\n\n        o[z] += y;\n        o[aa] -= ab;\n\n        if (aa == 0) {\n            payable(msg.sender).transfer(ab);\n        }\n\n        return ab;\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "_handleETHTransfer": "a",
        "remove_liquidity": "b",
        "min_mint_amount": "c",
        "totalLPSupply": "d",
        "add_liquidity": "e",
        "_NOT_ENTERED": "f",
        "min_amounts": "g",
        "lpBalances": "h",
        "totalValue": "i",
        "lpBurned": "j",
        "lpMinted": "k",
        "_ENTERED": "l",
        "lpAmount": "m",
        "lpToMint": "n",
        "balances": "o",
        "provider": "p",
        "exchange": "q",
        "amounts": "r",
        "_status": "s",
        "success": "t",
        "amount0": "u",
        "amount1": "v",
        "min_dy": "w",
        "amount": "x",
        "dx": "y",
        "ui": "z",
        "uj": "aa",
        "dy": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_006",
      "transformed_id": "ss_l2_short_nc_tc_006",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract CrossChainBridge {\n\n    address[] public t;\n    mapping(address => bool) public q;\n\n    uint256 public c = 5;\n    uint256 public j;\n\n\n    mapping(uint256 => bool) public b;\n\n\n    mapping(address => bool) public h;\n\n    event WithdrawalProcessed(\n        uint256 indexed m,\n        address indexed ai,\n        address indexed ag,\n        uint256 ab\n    );\n\n    constructor(address[] memory r) {\n        require(\n            r.length >= c,\n            \"Not enough validators\"\n        );\n\n        for (uint256 i = 0; i < r.length; i++) {\n            address x = r[i];\n            require(x != address(0), \"Invalid validator\");\n            require(!q[x], \"Duplicate validator\");\n\n            t.push(x);\n            q[x] = true;\n        }\n\n        j = r.length;\n    }\n\n\n    function g(\n        uint256 l,\n        address ah,\n        address ac,\n        uint256 z,\n        bytes memory p\n    ) external {\n\n        require(!b[l], \"Already processed\");\n\n\n        require(h[ac], \"Token not supported\");\n\n\n        require(\n            d(\n                l,\n                ah,\n                ac,\n                z,\n                p\n            ),\n            \"Invalid signatures\"\n        );\n\n\n        b[l] = true;\n\n\n        emit WithdrawalProcessed(l, ah, ac, z);\n    }\n\n\n    function d(\n        uint256 l,\n        address ah,\n        address ac,\n        uint256 z,\n        bytes memory p\n    ) internal view returns (bool) {\n        require(p.length % 65 == 0, \"Invalid signature length\");\n\n        uint256 i = p.length / 65;\n        require(i >= c, \"Not enough signatures\");\n\n\n        bytes32 o = v(\n            abi.n(l, ah, ac, z)\n        );\n        bytes32 a = v(\n            abi.n(\"\\x19Ethereum Signed Message:\\n32\", o)\n        );\n\n        address[] memory y = new address[](i);\n\n\n        for (uint256 i = 0; i < i; i++) {\n            bytes memory w = e(p, i);\n            address aa = k(a, w);\n\n\n            require(q[aa], \"Invalid signer\");\n\n\n            for (uint256 j = 0; j < i; j++) {\n                require(y[j] != aa, \"Duplicate signer\");\n            }\n\n            y[i] = aa;\n        }\n\n\n        return true;\n    }\n\n\n    function e(\n        bytes memory p,\n        uint256 ad\n    ) internal pure returns (bytes memory) {\n        bytes memory w = new bytes(65);\n        uint256 ae = ad * 65;\n\n        for (uint256 i = 0; i < 65; i++) {\n            w[i] = p[ae + i];\n        }\n\n        return w;\n    }\n\n\n    function k(\n        bytes32 af,\n        bytes memory s\n    ) internal pure returns (address) {\n        require(s.length == 65, \"Invalid signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(s, 32))\n            s := mload(add(s, 64))\n            v := byte(0, mload(add(s, 96)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28, \"Invalid signature v value\");\n\n        return u(af, v, r, s);\n    }\n\n\n    function f(address ac) external {\n        h[ac] = true;\n    }\n}",
      "rename_map": {
        "ethSignedMessageHash": "a",
        "processedWithdrawals": "b",
        "requiredSignatures": "c",
        "_verifySignatures": "d",
        "_extractSignature": "e",
        "addSupportedToken": "f",
        "withdrawERC20For": "g",
        "supportedTokens": "h",
        "signatureCount": "i",
        "validatorCount": "j",
        "_recoverSigner": "k",
        "_withdrawalId": "l",
        "withdrawalId": "m",
        "encodePacked": "n",
        "messageHash": "o",
        "_signatures": "p",
        "isValidator": "q",
        "_validators": "r",
        "_signature": "s",
        "validators": "t",
        "ecrecover": "u",
        "keccak256": "v",
        "signature": "w",
        "validator": "x",
        "signers": "y",
        "_amount": "z",
        "signer": "aa",
        "amount": "ab",
        "_token": "ac",
        "_index": "ad",
        "offset": "ae",
        "_hash": "af",
        "token": "ag",
        "_user": "ah",
        "user": "ai"
      },
      "changes": [
        "Renamed 35 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_007",
      "transformed_id": "ss_l2_short_nc_tc_007",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface ICrossChainData {\n    function f(address v) external;\n\n    function b(\n        bytes calldata g\n    ) external returns (bool);\n\n    function a() external view returns (bytes memory);\n}\n\ncontract CrossChainData {\n    address public z;\n    bytes public d;\n\n    event OwnershipTransferred(\n        address indexed h,\n        address indexed v\n    );\n    event PublicKeysUpdated(bytes x);\n\n    constructor() {\n        z = msg.sender;\n    }\n\n    modifier u() {\n        require(msg.sender == z, \"Not owner\");\n        _;\n    }\n\n\n    function b(\n        bytes calldata g\n    ) external u returns (bool) {\n        d = g;\n        emit PublicKeysUpdated(g);\n        return true;\n    }\n\n\n    function f(address v) external u {\n        require(v != address(0), \"Invalid address\");\n        emit OwnershipTransferred(z, v);\n        z = v;\n    }\n\n    function a() external view returns (bytes memory) {\n        return d;\n    }\n}\n\ncontract CrossChainManager {\n    address public o;\n\n    event CrossChainEvent(\n        address indexed m,\n        bytes q,\n        bytes y\n    );\n\n    constructor(address j) {\n        o = j;\n    }\n\n\n    function c(\n        bytes memory aa,\n        bytes memory r,\n        bytes memory p,\n        bytes memory l,\n        bytes memory t\n    ) external returns (bool) {\n\n        require(i(r, t), \"Invalid header\");\n\n\n        require(k(aa, r), \"Invalid proof\");\n\n\n        (\n            address q,\n            bytes memory y,\n            bytes memory ab\n        ) = s(aa);\n\n\n        (bool w, ) = q.call(abi.n(y, ab));\n        require(w, \"Execution failed\");\n\n        return true;\n    }\n\n\n    function i(\n        bytes memory r,\n        bytes memory t\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n\n    function k(\n        bytes memory aa,\n        bytes memory r\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n\n    function s(\n        bytes memory aa\n    )\n        internal\n        view\n        returns (address q, bytes memory y, bytes memory ab)\n    {\n        q = o;\n        y = abi.e(\n            \"putCurEpochConPubKeyBytes(bytes)\",\n            \"\"\n        );\n        ab = \"\";\n    }\n}",
      "rename_map": {
        "getCurEpochConPubKeyBytes": "a",
        "putCurEpochConPubKeyBytes": "b",
        "verifyHeaderAndExecuteTx": "c",
        "currentEpochPublicKeys": "d",
        "encodeWithSignature": "e",
        "transferOwnership": "f",
        "curEpochPkBytes": "g",
        "previousOwner": "h",
        "_verifyHeader": "i",
        "_dataContract": "j",
        "_verifyProof": "k",
        "curRawHeader": "l",
        "fromContract": "m",
        "encodePacked": "n",
        "dataContract": "o",
        "headerProof": "p",
        "toContract": "q",
        "rawHeader": "r",
        "_decodeTx": "s",
        "headerSig": "t",
        "onlyOwner": "u",
        "newOwner": "v",
        "success": "w",
        "newKeys": "x",
        "method": "y",
        "owner": "z",
        "proof": "aa",
        "args": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_008",
      "transformed_id": "ss_l2_short_nc_tc_008",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IOracle {\n    function c(address y) external view returns (uint256);\n}\n\ninterface ICToken {\n    function ad(uint256 q) external;\n\n    function v(uint256 h) external;\n\n    function x(uint256 i) external;\n\n    function o() external view returns (address);\n}\n\ncontract LendingProtocol {\n\n    IOracle public z;\n\n\n    mapping(address => uint256) public d;\n\n\n    mapping(address => mapping(address => uint256)) public j;\n\n\n    mapping(address => mapping(address => uint256)) public n;\n\n\n    mapping(address => bool) public e;\n\n    event Deposit(address indexed ac, address indexed y, uint256 w);\n    event Borrow(address indexed ac, address indexed y, uint256 w);\n\n    constructor(address u) {\n        z = IOracle(u);\n    }\n\n\n    function ad(address y, uint256 w) external {\n        require(e[y], \"Market not supported\");\n\n\n        j[msg.sender][y] += w;\n\n        emit Deposit(msg.sender, y, w);\n    }\n\n\n    function v(address y, uint256 w) external {\n        require(e[y], \"Market not supported\");\n\n\n        uint256 l = b(msg.sender);\n\n\n        uint256 g = a(msg.sender);\n\n\n        uint256 m = (z.c(y) * w) /\n            1e18;\n\n\n        require(\n            g + m <= l,\n            \"Insufficient collateral\"\n        );\n\n\n        n[msg.sender][y] += w;\n\n        emit Borrow(msg.sender, y, w);\n    }\n\n\n    function b(address ac) public view returns (uint256) {\n        uint256 p = 0;\n\n        address[] memory t = new address[](2);\n\n        for (uint256 i = 0; i < t.length; i++) {\n            address y = t[i];\n            uint256 balance = j[ac][y];\n\n            if (balance > 0) {\n\n                uint256 ab = z.c(y);\n\n\n                uint256 value = (balance * ab) / 1e18;\n\n\n                uint256 aa = (value * d[y]) / 1e18;\n\n                p += aa;\n            }\n        }\n\n        return p;\n    }\n\n\n    function a(address ac) public view returns (uint256) {\n        uint256 k = 0;\n\n        address[] memory t = new address[](2);\n\n        for (uint256 i = 0; i < t.length; i++) {\n            address y = t[i];\n            uint256 s = n[ac][y];\n\n            if (s > 0) {\n                uint256 ab = z.c(y);\n                uint256 value = (s * ab) / 1e18;\n                k += value;\n            }\n        }\n\n        return k;\n    }\n\n\n    function r(address y, uint256 f) external {\n        e[y] = true;\n        d[y] = f;\n    }\n}",
      "rename_map": {
        "calculateTotalBorrows": "a",
        "calculateBorrowPower": "b",
        "getUnderlyingPrice": "c",
        "collateralFactors": "d",
        "supportedMarkets": "e",
        "collateralFactor": "f",
        "currentBorrows": "g",
        "borrowAmount": "h",
        "redeemTokens": "i",
        "userDeposits": "j",
        "totalBorrows": "k",
        "borrowPower": "l",
        "borrowValue": "m",
        "userBorrows": "n",
        "underlying": "o",
        "totalPower": "p",
        "mintAmount": "q",
        "addMarket": "r",
        "borrowed": "s",
        "markets": "t",
        "_oracle": "u",
        "borrow": "v",
        "amount": "w",
        "redeem": "x",
        "cToken": "y",
        "oracle": "z",
        "power": "aa",
        "price": "ab",
        "user": "ac",
        "mint": "ad"
      },
      "changes": [
        "Renamed 30 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_009",
      "transformed_id": "ss_l2_short_nc_tc_009",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ncontract ConcentratedLiquidityPool {\n\n    address public ap;\n    address public aq;\n\n\n    uint160 public r;\n    int24 public v;\n    uint128 public ae;\n\n\n    mapping(int24 => int128) public s;\n\n\n    struct Position {\n        uint128 ae;\n        int24 ah;\n        int24 ai;\n    }\n\n    mapping(bytes32 => Position) public aa;\n\n    event Swap(\n        address indexed sender,\n        uint256 ab,\n        uint256 ac,\n        uint256 y,\n        uint256 z\n    );\n\n    event LiquidityAdded(\n        address indexed am,\n        int24 ah,\n        int24 ai,\n        uint128 ae\n    );\n\n\n    function t(\n        int24 ah,\n        int24 ai,\n        uint128 n\n    ) external returns (uint256 an, uint256 ao) {\n        require(ah < ai, \"Invalid ticks\");\n        require(n > 0, \"Zero liquidity\");\n\n\n        bytes32 u = ad(\n            abi.q(msg.sender, ah, ai)\n        );\n\n\n        Position storage aj = aa[u];\n        aj.ae += n;\n        aj.ah = ah;\n        aj.ai = ai;\n\n\n        s[ah] += int128(n);\n        s[ai] -= int128(n);\n\n\n        if (v >= ah && v < ai) {\n            ae += n;\n        }\n\n\n        (an, ao) = f(\n            r,\n            ah,\n            ai,\n            int128(n)\n        );\n\n        emit LiquidityAdded(msg.sender, ah, ai, n);\n    }\n\n\n    function ar(\n        bool x,\n        int256 m,\n        uint160 g\n    ) external returns (int256 an, int256 ao) {\n        require(m != 0, \"Zero amount\");\n\n\n        uint160 i = r;\n        uint128 p = ae;\n        int24 ak = v;\n\n\n        while (m != 0) {\n\n            (\n                uint256 al,\n                uint256 ag,\n                uint160 d\n            ) = j(\n                    i,\n                    g,\n                    p,\n                    m\n                );\n\n\n            i = d;\n\n\n            int24 w = b(i);\n            if (w != ak) {\n\n                int128 e = s[w];\n\n                if (x) {\n                    e = -e;\n                }\n\n                p = o(\n                    p,\n                    e\n                );\n\n                ak = w;\n            }\n\n\n            if (m > 0) {\n                m -= int256(al);\n            } else {\n                m += int256(ag);\n            }\n        }\n\n\n        r = i;\n        ae = p;\n        v = ak;\n\n        return (an, ao);\n    }\n\n\n    function o(\n        uint128 x,\n        int128 y\n    ) internal pure returns (uint128 z) {\n        if (y < 0) {\n            z = x - uint128(-y);\n        } else {\n            z = x + uint128(y);\n        }\n    }\n\n\n    function f(\n        uint160 af,\n        int24 ah,\n        int24 ai,\n        int128 n\n    ) internal pure returns (uint256 an, uint256 ao) {\n        an = uint256(uint128(n)) / 2;\n        ao = uint256(uint128(n)) / 2;\n    }\n\n\n    function j(\n        uint160 a,\n        uint160 c,\n        uint128 k,\n        int256 l\n    )\n        internal\n        pure\n        returns (uint256 al, uint256 ag, uint160 h)\n    {\n        al =\n            uint256(l > 0 ? l : -l) /\n            2;\n        ag = al;\n        h = a;\n    }\n\n\n    function b(\n        uint160 r\n    ) internal pure returns (int24 as) {\n        return int24(int256(uint256(r >> 96)));\n    }\n}",
      "rename_map": {
        "sqrtPriceCurrentX96": "a",
        "_getTickAtSqrtRatio": "b",
        "sqrtPriceTargetX96": "c",
        "sqrtPriceX96Target": "d",
        "liquidityNetAtTick": "e",
        "_calculateAmounts": "f",
        "sqrtPriceLimitX96": "g",
        "sqrtPriceNextX96": "h",
        "sqrtPriceX96Next": "i",
        "_computeSwapStep": "j",
        "liquidityCurrent": "k",
        "amountRemaining": "l",
        "amountSpecified": "m",
        "liquidityDelta": "n",
        "_addLiquidity": "o",
        "liquidityNext": "p",
        "encodePacked": "q",
        "sqrtPriceX96": "r",
        "liquidityNet": "s",
        "addLiquidity": "t",
        "positionKey": "u",
        "currentTick": "v",
        "tickCrossed": "w",
        "zeroForOne": "x",
        "amount0Out": "y",
        "amount1Out": "z",
        "positions": "aa",
        "amount0In": "ab",
        "amount1In": "ac",
        "keccak256": "ad",
        "liquidity": "ae",
        "sqrtPrice": "af",
        "amountOut": "ag",
        "tickLower": "ah",
        "tickUpper": "ai",
        "position": "aj",
        "tickNext": "ak",
        "amountIn": "al",
        "provider": "am",
        "amount0": "an",
        "amount1": "ao",
        "token0": "ap",
        "token1": "aq",
        "swap": "ar",
        "tick": "as"
      },
      "changes": [
        "Renamed 45 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_010",
      "transformed_id": "ss_l2_short_nc_tc_010",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\n\ncontract CreditSystem {\n    mapping(address => uint256) public f;\n    uint256 public balance;\n\n    function e() public payable {\n        f[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n\n    function a() public {\n        uint256 d = f[msg.sender];\n        if (d > 0) {\n            balance -= d;\n            bool b = msg.sender.call.value(d)();\n            require(b);\n            f[msg.sender] = 0;\n        }\n    }\n\n    function c(address g) public view returns (uint256) {\n        return f[g];\n    }\n}",
      "rename_map": {
        "withdrawAll": "a",
        "callResult": "b",
        "getCredit": "c",
        "oCredit": "d",
        "deposit": "e",
        "credit": "f",
        "user": "g"
      },
      "changes": [
        "Renamed 7 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_011",
      "transformed_id": "ss_l2_short_nc_tc_011",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC777 {\n    function transfer(address s, uint256 m) external returns (bool);\n\n    function i(address l) external view returns (uint256);\n}\n\ninterface IERC1820Registry {\n    function a(\n        address l,\n        bytes32 d,\n        address f\n    ) external;\n}\n\ncontract LendingPool {\n    mapping(address => mapping(address => uint256)) public k;\n    mapping(address => uint256) public e;\n\n    function n(address p, uint256 m) external returns (uint256) {\n        IERC777 o = IERC777(p);\n\n        require(o.transfer(address(this), m), \"Transfer failed\");\n\n        k[msg.sender][p] += m;\n        e[p] += m;\n\n        return m;\n    }\n\n    function j(\n        address p,\n        uint256 b\n    ) external returns (uint256) {\n        uint256 h = k[msg.sender][p];\n        require(h > 0, \"No balance\");\n\n        uint256 c = b;\n        if (b == type(uint256).r) {\n            c = h;\n        }\n        require(c <= h, \"Insufficient balance\");\n\n        IERC777(p).transfer(msg.sender, c);\n\n        k[msg.sender][p] -= c;\n        e[p] -= c;\n\n        return c;\n    }\n\n    function g(\n        address q,\n        address p\n    ) external view returns (uint256) {\n        return k[q][p];\n    }\n}",
      "rename_map": {
        "setInterfaceImplementer": "a",
        "requestedAmount": "b",
        "withdrawAmount": "c",
        "interfaceHash": "d",
        "totalSupplied": "e",
        "implementer": "f",
        "getSupplied": "g",
        "userBalance": "h",
        "balanceOf": "i",
        "withdraw": "j",
        "supplied": "k",
        "account": "l",
        "amount": "m",
        "supply": "n",
        "token": "o",
        "asset": "p",
        "user": "q",
        "max": "r",
        "to": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_012",
      "transformed_id": "ss_l2_short_nc_tc_012",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IComptroller {\n    function g(\n        address[] memory r\n    ) external returns (uint256[] memory);\n\n    function j(address v) external returns (uint256);\n\n    function b(\n        address s\n    ) external view returns (uint256, uint256, uint256);\n}\n\ncontract LendingProtocol {\n    IComptroller public i;\n\n    mapping(address => uint256) public m;\n    mapping(address => uint256) public o;\n    mapping(address => bool) public p;\n\n    uint256 public e;\n    uint256 public f;\n    uint256 public constant COLLATERAL_FACTOR = 150;\n\n    constructor(address h) {\n        i = IComptroller(h);\n    }\n\n    function a() external payable {\n        m[msg.sender] += msg.value;\n        e += msg.value;\n        p[msg.sender] = true;\n    }\n\n    function k(\n        address s,\n        uint256 c\n    ) public view returns (bool) {\n        uint256 l = o[s] + c;\n        if (l == 0) return true;\n\n        if (!p[s]) return false;\n\n        uint256 d = m[s];\n        return d >= (l * COLLATERAL_FACTOR) / 100;\n    }\n\n    function t(uint256 u) external {\n        require(u > 0, \"Invalid amount\");\n        require(address(this).balance >= u, \"Insufficient funds\");\n\n        require(k(msg.sender, u), \"Insufficient collateral\");\n\n        o[msg.sender] += u;\n        f += u;\n\n        (bool q, ) = payable(msg.sender).call{value: u}(\"\");\n        require(q, \"Transfer failed\");\n\n        require(k(msg.sender, 0), \"Health check failed\");\n    }\n\n    function j() external {\n        require(o[msg.sender] == 0, \"Outstanding debt\");\n        p[msg.sender] = false;\n    }\n\n    function n(uint256 u) external {\n        require(m[msg.sender] >= u, \"Insufficient deposits\");\n        require(!p[msg.sender], \"Exit market first\");\n\n        m[msg.sender] -= u;\n        e -= u;\n\n        payable(msg.sender).transfer(u);\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "depositAndEnterMarket": "a",
        "getAccountLiquidity": "b",
        "additionalBorrow": "c",
        "collateralValue": "d",
        "totalDeposits": "e",
        "totalBorrowed": "f",
        "enterMarkets": "g",
        "_comptroller": "h",
        "comptroller": "i",
        "exitMarket": "j",
        "isHealthy": "k",
        "totalDebt": "l",
        "deposits": "m",
        "withdraw": "n",
        "borrowed": "o",
        "inMarket": "p",
        "success": "q",
        "cTokens": "r",
        "account": "s",
        "borrow": "t",
        "amount": "u",
        "cToken": "v"
      },
      "changes": [
        "Renamed 22 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_013",
      "transformed_id": "ss_l2_short_nc_tc_013",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address ac, uint256 x) external returns (bool);\n\n    function g(\n        address from,\n        address ac,\n        uint256 x\n    ) external returns (bool);\n\n    function k(address w) external view returns (uint256);\n}\n\ninterface IPancakeRouter {\n    function a(\n        uint p,\n        uint l,\n        address[] calldata ab,\n        address ac,\n        uint n\n    ) external returns (uint[] memory s);\n}\n\ncontract RewardMinter {\n    IERC20 public v;\n    IERC20 public i;\n\n    mapping(address => uint256) public j;\n    mapping(address => uint256) public e;\n\n    uint256 public constant REWARD_RATE = 100;\n\n    constructor(address r, address h) {\n        v = IERC20(r);\n        i = IERC20(h);\n    }\n\n    function t(uint256 x) external {\n        v.g(msg.sender, address(this), x);\n        j[msg.sender] += x;\n    }\n\n    function u(\n        address aa,\n        uint256 d,\n        uint256 c,\n        address ac,\n        uint256\n    ) external {\n        require(aa == address(v), \"Invalid token\");\n\n        uint256 z = c + d;\n        v.g(msg.sender, address(this), z);\n\n        uint256 b = f(\n            v.k(address(this))\n        );\n\n        e[ac] += b;\n    }\n\n    function f(uint256 o) internal pure returns (uint256) {\n        return o * REWARD_RATE;\n    }\n\n    function m() external {\n        uint256 y = e[msg.sender];\n        require(y > 0, \"No rewards\");\n\n        e[msg.sender] = 0;\n        i.transfer(msg.sender, y);\n    }\n\n    function q(uint256 x) external {\n        require(j[msg.sender] >= x, \"Insufficient balance\");\n        j[msg.sender] -= x;\n        v.transfer(msg.sender, x);\n    }\n}",
      "rename_map": {
        "swapExactTokensForTokens": "a",
        "hunnyRewardAmount": "b",
        "_performanceFee": "c",
        "_withdrawalFee": "d",
        "earnedRewards": "e",
        "tokenToReward": "f",
        "transferFrom": "g",
        "_rewardToken": "h",
        "rewardToken": "i",
        "depositedLP": "j",
        "balanceOf": "k",
        "amountOut": "l",
        "getReward": "m",
        "deadline": "n",
        "lpAmount": "o",
        "amountIn": "p",
        "withdraw": "q",
        "_lpToken": "r",
        "amounts": "s",
        "deposit": "t",
        "mintFor": "u",
        "lpToken": "v",
        "account": "w",
        "amount": "x",
        "reward": "y",
        "feeSum": "z",
        "flip": "aa",
        "path": "ab",
        "to": "ac"
      },
      "changes": [
        "Renamed 29 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_014",
      "transformed_id": "ss_l2_short_nc_tc_014",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface ICurve3Pool {\n    function g(\n        uint256[3] memory r,\n        uint256 d\n    ) external;\n\n    function a(\n        uint256[3] memory r,\n        uint256 c\n    ) external;\n\n    function b() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function transfer(address ad, uint256 w) external returns (bool);\n\n    function j(\n        address from,\n        address ad,\n        uint256 w\n    ) external returns (bool);\n\n    function q(address v) external view returns (uint256);\n\n    function u(address t, uint256 w) external returns (bool);\n}\n\ncontract YieldVault {\n    IERC20 public ac;\n    IERC20 public ab;\n    ICurve3Pool public o;\n\n    mapping(address => uint256) public x;\n    uint256 public n;\n    uint256 public f;\n\n    uint256 public constant MIN_EARN_THRESHOLD = 1000 ether;\n\n    constructor(address aa, address y, address l) {\n        ac = IERC20(aa);\n        ab = IERC20(y);\n        o = ICurve3Pool(l);\n    }\n\n    function s(uint256 w) external {\n        ac.j(msg.sender, address(this), w);\n\n        uint256 m;\n        if (n == 0) {\n            m = w;\n        } else {\n            m = (w * n) / f;\n        }\n\n        x[msg.sender] += m;\n        n += m;\n        f += w;\n    }\n\n    function z() external {\n        uint256 h = ac.q(address(this));\n        require(\n            h >= MIN_EARN_THRESHOLD,\n            \"Insufficient balance to earn\"\n        );\n\n        uint256 i = o.b();\n\n        ac.u(address(o), h);\n        uint256[3] memory r = [h, 0, 0];\n        o.g(r, 0);\n    }\n\n    function k() external {\n        uint256 p = x[msg.sender];\n        require(p > 0, \"No shares\");\n\n        uint256 e = (p * f) / n;\n\n        x[msg.sender] = 0;\n        n -= p;\n        f -= e;\n\n        ac.transfer(msg.sender, e);\n    }\n\n    function balance() public view returns (uint256) {\n        return\n            ac.q(address(this)) +\n            (ab.q(address(this)) * o.b()) /\n            1e18;\n    }\n}",
      "rename_map": {
        "remove_liquidity_imbalance": "a",
        "get_virtual_price": "b",
        "max_burn_amount": "c",
        "min_mint_amount": "d",
        "withdrawAmount": "e",
        "totalDeposits": "f",
        "add_liquidity": "g",
        "vaultBalance": "h",
        "virtualPrice": "i",
        "transferFrom": "j",
        "withdrawAll": "k",
        "_curve3Pool": "l",
        "shareAmount": "m",
        "totalShares": "n",
        "curve3Pool": "o",
        "userShares": "p",
        "balanceOf": "q",
        "amounts": "r",
        "deposit": "s",
        "spender": "t",
        "approve": "u",
        "account": "v",
        "amount": "w",
        "shares": "x",
        "_crv3": "y",
        "earn": "z",
        "_dai": "aa",
        "crv3": "ab",
        "dai": "ac",
        "to": "ad"
      },
      "changes": [
        "Renamed 30 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_015",
      "transformed_id": "ss_l2_short_nc_tc_015",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address l, uint256 g) external returns (bool);\n\n    function e(address f) external view returns (uint256);\n}\n\ncontract CompoundMarket {\n    address public c;\n    address public j;\n\n    mapping(address => uint256) public a;\n    uint256 public b;\n\n    address public constant OLD_TUSD =\n        0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;\n    address public constant NEW_TUSD =\n        0x0000000000085d4780B73119b644AE5ecd22b376;\n\n    constructor() {\n        j = msg.sender;\n        c = OLD_TUSD;\n    }\n\n    function k(uint256 g) external {\n        IERC20(NEW_TUSD).transfer(address(this), g);\n        a[msg.sender] += g;\n        b += g;\n    }\n\n    function d(address i) external {\n        require(i != c, \"Cannot sweep underlying token\");\n\n        uint256 balance = IERC20(i).e(address(this));\n        IERC20(i).transfer(msg.sender, balance);\n    }\n\n    function h(uint256 g) external {\n        require(a[msg.sender] >= g, \"Insufficient balance\");\n\n        a[msg.sender] -= g;\n        b -= g;\n\n        IERC20(NEW_TUSD).transfer(msg.sender, g);\n    }\n}",
      "rename_map": {
        "accountTokens": "a",
        "totalSupply": "b",
        "underlying": "c",
        "sweepToken": "d",
        "balanceOf": "e",
        "account": "f",
        "amount": "g",
        "redeem": "h",
        "token": "i",
        "admin": "j",
        "mint": "k",
        "to": "l"
      },
      "changes": [
        "Renamed 12 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_016",
      "transformed_id": "ss_l2_short_nc_tc_016",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address u, uint256 r) external returns (bool);\n\n    function l(address p) external view returns (uint256);\n}\n\ncontract LoanToken {\n    string public s = \"iETH\";\n    string public q = \"iETH\";\n\n    mapping(address => uint256) public m;\n    uint256 public f;\n    uint256 public b;\n    uint256 public a;\n\n    function d(\n        address n\n    ) external payable returns (uint256 j) {\n        uint256 e = i();\n        j = (msg.value * 1e18) / e;\n\n        m[n] += j;\n        f += j;\n        a += msg.value;\n\n        return j;\n    }\n\n    function transfer(address u, uint256 r) external returns (bool) {\n        require(m[msg.sender] >= r, \"Insufficient balance\");\n\n        m[msg.sender] -= r;\n        m[u] += r;\n\n        c(msg.sender, u, r);\n\n        return true;\n    }\n\n    function c(\n        address from,\n        address u,\n        uint256 r\n    ) internal {\n        if (g(u)) {\n            (bool o, ) = u.call(\"\");\n            o;\n        }\n    }\n\n    function h(\n        address n,\n        uint256 r\n    ) external returns (uint256 k) {\n        require(m[msg.sender] >= r, \"Insufficient balance\");\n\n        uint256 e = i();\n        k = (r * e) / 1e18;\n\n        m[msg.sender] -= r;\n        f -= r;\n        a -= k;\n\n        payable(n).transfer(k);\n\n        return k;\n    }\n\n    function i() internal view returns (uint256) {\n        if (f == 0) {\n            return 1e18;\n        }\n        return (a * 1e18) / f;\n    }\n\n    function g(address p) internal view returns (bool) {\n        uint256 t;\n        assembly {\n            t := extcodesize(p)\n        }\n        return t > 0;\n    }\n\n    function l(address p) external view returns (uint256) {\n        return m[p];\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "totalAssetSupply": "a",
        "totalAssetBorrow": "b",
        "_notifyTransfer": "c",
        "mintWithEther": "d",
        "currentPrice": "e",
        "totalSupply": "f",
        "_isContract": "g",
        "burnToEther": "h",
        "_tokenPrice": "i",
        "mintAmount": "j",
        "ethAmount": "k",
        "balanceOf": "l",
        "balances": "m",
        "receiver": "n",
        "success": "o",
        "account": "p",
        "symbol": "q",
        "amount": "r",
        "name": "s",
        "size": "t",
        "to": "u"
      },
      "changes": [
        "Renamed 21 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_017",
      "transformed_id": "ss_l2_short_nc_tc_017",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\n\ninterface IERC20 {\n    function transfer(address x, uint256 q) external returns (bool);\n\n    function j(address p) external view returns (uint256);\n}\n\ninterface IJar {\n    function s() external view returns (address);\n\n    function k(uint256 q) external;\n}\n\ninterface IStrategy {\n    function e() external;\n\n    function k(address s) external;\n}\n\ncontract VaultController {\n    address public g;\n    mapping(address => address) public i;\n\n    constructor() {\n        g = msg.sender;\n    }\n\n    function a(\n        address n,\n        address r,\n        uint256 c,\n        uint256 b,\n        address[] calldata m,\n        bytes[] calldata t\n    ) external {\n        require(m.length == t.length, \"Length mismatch\");\n\n        for (uint256 i = 0; i < m.length; i++) {\n            (bool o, ) = m[i].call(t[i]);\n            require(o, \"Call failed\");\n        }\n    }\n\n    function f(address w, address l) external {\n        require(msg.sender == g, \"Not governance\");\n        i[w] = l;\n    }\n}\n\ncontract Strategy {\n    address public h;\n    address public v;\n\n    constructor(address d, address u) {\n        h = d;\n        v = u;\n    }\n\n    function e() external {\n        uint256 balance = IERC20(v).j(address(this));\n        IERC20(v).transfer(h, balance);\n    }\n\n    function k(address s) external {\n        uint256 balance = IERC20(s).j(address(this));\n        IERC20(s).transfer(h, balance);\n    }\n}",
      "rename_map": {
        "swapExactJarForJar": "a",
        "_toJarMinAmount": "b",
        "_fromJarAmount": "c",
        "_controller": "d",
        "withdrawAll": "e",
        "setStrategy": "f",
        "governance": "g",
        "controller": "h",
        "strategies": "i",
        "balanceOf": "j",
        "withdraw": "k",
        "strategy": "l",
        "_targets": "m",
        "_fromJar": "n",
        "success": "o",
        "account": "p",
        "amount": "q",
        "_toJar": "r",
        "token": "s",
        "_data": "t",
        "_want": "u",
        "want": "v",
        "jar": "w",
        "to": "x"
      },
      "changes": [
        "Renamed 24 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_018",
      "transformed_id": "ss_l2_short_nc_tc_018",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function l(address t) external view returns (uint256);\n\n    function transfer(address aa, uint256 v) external returns (bool);\n}\n\ncontract TokenPool {\n    struct Token {\n        address y;\n        uint256 balance;\n        uint256 u;\n    }\n\n    mapping(address => Token) public w;\n    address[] public j;\n    uint256 public f;\n\n    constructor() {\n        f = 100;\n    }\n\n    function p(address x, uint256 c) external {\n        w[x] = Token({y: x, balance: 0, u: c});\n        j.push(x);\n    }\n\n    function z(\n        address s,\n        address o,\n        uint256 r\n    ) external returns (uint256 m) {\n        require(w[s].y != address(0), \"Invalid token\");\n        require(w[o].y != address(0), \"Invalid token\");\n\n        IERC20(s).transfer(address(this), r);\n        w[s].balance += r;\n\n        m = a(s, o, r);\n\n        require(\n            w[o].balance >= m,\n            \"Insufficient liquidity\"\n        );\n        w[o].balance -= m;\n        IERC20(o).transfer(msg.sender, m);\n\n        b();\n\n        return m;\n    }\n\n    function a(\n        address s,\n        address o,\n        uint256 r\n    ) public view returns (uint256) {\n        uint256 q = w[s].u;\n        uint256 n = w[o].u;\n        uint256 g = w[o].balance;\n\n        uint256 i = g * r * n;\n        uint256 e = w[s].balance *\n            q +\n            r *\n            n;\n\n        return i / e;\n    }\n\n    function b() internal {\n        uint256 h = 0;\n\n        for (uint256 i = 0; i < j.length; i++) {\n            address x = j[i];\n            h += w[x].balance;\n        }\n\n        for (uint256 i = 0; i < j.length; i++) {\n            address x = j[i];\n            w[x].u = (w[x].balance * 100) / h;\n        }\n    }\n\n    function k(address x) external view returns (uint256) {\n        return w[x].u;\n    }\n\n    function d(address x, uint256 v) external {\n        require(w[x].y != address(0), \"Invalid token\");\n        IERC20(x).transfer(address(this), v);\n        w[x].balance += v;\n        b();\n    }\n}",
      "rename_map": {
        "calculateSwapAmount": "a",
        "_updateWeights": "b",
        "initialWeight": "c",
        "addLiquidity": "d",
        "denominator": "e",
        "totalWeight": "f",
        "balanceOut": "g",
        "totalValue": "h",
        "numerator": "i",
        "tokenList": "j",
        "getWeight": "k",
        "balanceOf": "l",
        "amountOut": "m",
        "weightOut": "n",
        "tokenOut": "o",
        "addToken": "p",
        "weightIn": "q",
        "amountIn": "r",
        "tokenIn": "s",
        "account": "t",
        "weight": "u",
        "amount": "v",
        "tokens": "w",
        "token": "x",
        "addr": "y",
        "swap": "z",
        "to": "aa"
      },
      "changes": [
        "Renamed 27 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_019",
      "transformed_id": "ss_l2_short_nc_tc_019",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function e(\n        address from,\n        address r,\n        uint256 p\n    ) external returns (bool);\n\n    function k(address o) external view returns (uint256);\n}\n\ncontract CrossChainBridge {\n    address public n;\n\n    event Deposit(\n        uint8 b,\n        bytes32 i,\n        uint64 f\n    );\n\n    uint64 public f;\n\n    constructor(address l) {\n        n = l;\n    }\n\n    function m(\n        uint8 b,\n        bytes32 i,\n        bytes calldata data\n    ) external payable {\n        f += 1;\n\n        BridgeHandler(n).m(i, msg.sender, data);\n\n        emit Deposit(b, i, f);\n    }\n}\n\ncontract BridgeHandler {\n    mapping(bytes32 => address) public a;\n    mapping(address => bool) public c;\n\n    function m(\n        bytes32 i,\n        address j,\n        bytes calldata data\n    ) external {\n        address d = a[i];\n\n        uint256 p;\n        (p) = abi.q(data, (uint256));\n\n        IERC20(d).e(j, address(this), p);\n    }\n\n    function h(bytes32 i, address g) external {\n        a[i] = g;\n    }\n}",
      "rename_map": {
        "resourceIDToTokenContractAddress": "a",
        "destinationDomainID": "b",
        "contractWhitelist": "c",
        "tokenContract": "d",
        "transferFrom": "e",
        "depositNonce": "f",
        "tokenAddress": "g",
        "setResource": "h",
        "resourceID": "i",
        "depositer": "j",
        "balanceOf": "k",
        "_handler": "l",
        "deposit": "m",
        "handler": "n",
        "account": "o",
        "amount": "p",
        "decode": "q",
        "to": "r"
      },
      "changes": [
        "Renamed 18 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_020",
      "transformed_id": "ss_l2_short_nc_tc_020",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function i()\n        external\n        view\n        returns (uint112 s, uint112 p, uint32 a);\n\n    function g() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function n(address z) external view returns (uint256);\n\n    function transfer(address af, uint256 ab) external returns (bool);\n\n    function f(\n        address from,\n        address af,\n        uint256 ab\n    ) external returns (bool);\n}\n\ncontract LendingVault {\n    struct Position {\n        uint256 e;\n        uint256 u;\n    }\n\n    mapping(address => Position) public m;\n\n    address public y;\n    address public l;\n    uint256 public constant COLLATERAL_RATIO = 150;\n\n    constructor(address t, address h) {\n        y = t;\n        l = h;\n    }\n\n    function v(uint256 ab) external {\n        IERC20(y).f(msg.sender, address(this), ab);\n        m[msg.sender].e += ab;\n    }\n\n    function aa(uint256 ab) external {\n        uint256 c = b(\n            m[msg.sender].e\n        );\n        uint256 o = (c * 100) / COLLATERAL_RATIO;\n\n        require(\n            m[msg.sender].u + ab <= o,\n            \"Insufficient collateral\"\n        );\n\n        m[msg.sender].u += ab;\n        IERC20(l).transfer(msg.sender, ab);\n    }\n\n    function b(uint256 q) public view returns (uint256) {\n        if (q == 0) return 0;\n\n        IUniswapV2Pair ae = IUniswapV2Pair(y);\n\n        (uint112 s, uint112 p, ) = ae.i();\n        uint256 g = ae.g();\n\n        uint256 w = (uint256(s) * q) / g;\n        uint256 x = (uint256(p) * q) / g;\n\n        uint256 ac = w;\n        uint256 k = w + x;\n\n        return k;\n    }\n\n    function ad(uint256 ab) external {\n        require(m[msg.sender].u >= ab, \"Repay exceeds debt\");\n\n        IERC20(l).f(msg.sender, address(this), ab);\n        m[msg.sender].u -= ab;\n    }\n\n    function r(uint256 ab) external {\n        require(\n            m[msg.sender].e >= ab,\n            \"Insufficient balance\"\n        );\n\n        uint256 j = m[msg.sender].e - ab;\n        uint256 d = b(j);\n        uint256 o = (d * 100) / COLLATERAL_RATIO;\n\n        require(\n            m[msg.sender].u <= o,\n            \"Withdrawal would liquidate position\"\n        );\n\n        m[msg.sender].e -= ab;\n        IERC20(y).transfer(msg.sender, ab);\n    }\n}",
      "rename_map": {
        "blockTimestampLast": "a",
        "getLPTokenValue": "b",
        "collateralValue": "c",
        "remainingValue": "d",
        "lpTokenAmount": "e",
        "transferFrom": "f",
        "totalSupply": "g",
        "_stablecoin": "h",
        "getReserves": "i",
        "remainingLP": "j",
        "totalValue": "k",
        "stablecoin": "l",
        "positions": "m",
        "balanceOf": "n",
        "maxBorrow": "o",
        "reserve1": "p",
        "lpAmount": "q",
        "withdraw": "r",
        "reserve0": "s",
        "_lpToken": "t",
        "borrowed": "u",
        "deposit": "v",
        "amount0": "w",
        "amount1": "x",
        "lpToken": "y",
        "account": "z",
        "borrow": "aa",
        "amount": "ab",
        "value0": "ac",
        "repay": "ad",
        "pair": "ae",
        "to": "af"
      },
      "changes": [
        "Renamed 32 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_021",
      "transformed_id": "ss_l2_short_nc_tc_021",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function t(address x) external view returns (uint256);\n\n    function transfer(address af, uint256 y) external returns (bool);\n\n    function d(\n        address from,\n        address af,\n        uint256 y\n    ) external returns (bool);\n}\n\ncontract LiquidityPool {\n    address public o;\n    address public r;\n    address public l;\n\n    uint256 public u;\n    uint256 public i;\n    uint256 public e;\n\n    bool public c;\n\n    event Initialized(address o, address ad, address aa);\n\n    function ab(\n        address h,\n        address p,\n        address g,\n        uint256 m\n    ) external {\n        o = h;\n        r = p;\n        l = g;\n        u = m;\n\n        c = true;\n\n        emit Initialized(h, p, g);\n    }\n\n    function f(uint256 k, uint256 j) external {\n        require(c, \"Not initialized\");\n\n        IERC20(r).d(msg.sender, address(this), k);\n        IERC20(l).d(msg.sender, address(this), j);\n\n        i += k;\n        e += j;\n    }\n\n    function ac(\n        address s,\n        address w,\n        uint256 n\n    ) external returns (uint256 v) {\n        require(c, \"Not initialized\");\n        require(\n            (s == r && w == l) ||\n                (s == l && w == r),\n            \"Invalid token pair\"\n        );\n\n        IERC20(s).d(msg.sender, address(this), n);\n\n        if (s == r) {\n            v = (e * n) / (i + n);\n            i += n;\n            e -= v;\n        } else {\n            v = (i * n) / (e + n);\n            e += n;\n            i -= v;\n        }\n\n        uint256 ae = (v * u) / 10000;\n        v -= ae;\n\n        IERC20(w).transfer(msg.sender, v);\n        IERC20(w).transfer(o, ae);\n\n        return v;\n    }\n\n    function q() external {\n        require(msg.sender == o, \"Only maintainer\");\n\n        uint256 b = IERC20(r).t(address(this));\n        uint256 a = IERC20(l).t(address(this));\n\n        if (b > i) {\n            uint256 z = b - i;\n            IERC20(r).transfer(o, z);\n        }\n\n        if (a > e) {\n            uint256 z = a - e;\n            IERC20(l).transfer(o, z);\n        }\n    }\n}",
      "rename_map": {
        "quoteTokenBalance": "a",
        "baseTokenBalance": "b",
        "isInitialized": "c",
        "transferFrom": "d",
        "quoteBalance": "e",
        "addLiquidity": "f",
        "_quoteToken": "g",
        "_maintainer": "h",
        "baseBalance": "i",
        "quoteAmount": "j",
        "baseAmount": "k",
        "quoteToken": "l",
        "_lpFeeRate": "m",
        "fromAmount": "n",
        "maintainer": "o",
        "_baseToken": "p",
        "claimFees": "q",
        "baseToken": "r",
        "fromToken": "s",
        "balanceOf": "t",
        "lpFeeRate": "u",
        "toAmount": "v",
        "toToken": "w",
        "account": "x",
        "amount": "y",
        "excess": "z",
        "quote": "aa",
        "init": "ab",
        "swap": "ac",
        "base": "ad",
        "fee": "ae",
        "to": "af"
      },
      "changes": [
        "Renamed 32 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_022",
      "transformed_id": "ss_l2_short_nc_tc_022",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function k(address u) external view returns (uint256);\n\n    function transfer(address ab, uint256 v) external returns (bool);\n\n    function c(\n        address from,\n        address ab,\n        uint256 v\n    ) external returns (bool);\n}\n\ncontract TokenPair {\n    address public w;\n    address public x;\n\n    uint112 private p;\n    uint112 private n;\n\n    uint256 public constant TOTAL_FEE = 16;\n\n    constructor(address q, address s) {\n        w = q;\n        x = s;\n    }\n\n    function aa(address ab) external returns (uint256 i) {\n        uint256 o = IERC20(w).k(address(this));\n        uint256 m = IERC20(x).k(address(this));\n\n        uint256 r = o - p;\n        uint256 t = m - n;\n\n        i = z(r * t);\n\n        p = uint112(o);\n        n = uint112(m);\n\n        return i;\n    }\n\n    function y(\n        uint256 e,\n        uint256 f,\n        address ab,\n        bytes calldata data\n    ) external {\n        require(e > 0 || f > 0, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        uint112 l = p;\n        uint112 j = n;\n\n        require(\n            e < l && f < j,\n            \"INSUFFICIENT_LIQUIDITY\"\n        );\n\n        if (e > 0) IERC20(w).transfer(ab, e);\n        if (f > 0) IERC20(x).transfer(ab, f);\n\n        uint256 o = IERC20(w).k(address(this));\n        uint256 m = IERC20(x).k(address(this));\n\n        uint256 g = o > l - e\n            ? o - (l - e)\n            : 0;\n        uint256 h = m > j - f\n            ? m - (j - f)\n            : 0;\n\n        require(g > 0 || h > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\n        uint256 a = o * 10000 - g * TOTAL_FEE;\n        uint256 b = m * 10000 - h * TOTAL_FEE;\n\n        require(\n            a * b >=\n                uint256(l) * j * (1000 ** 2),\n            \"K\"\n        );\n\n        p = uint112(o);\n        n = uint112(m);\n    }\n\n    function d() external view returns (uint112, uint112, uint32) {\n        return (p, n, 0);\n    }\n\n    function z(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}",
      "rename_map": {
        "balance0Adjusted": "a",
        "balance1Adjusted": "b",
        "transferFrom": "c",
        "getReserves": "d",
        "amount0Out": "e",
        "amount1Out": "f",
        "amount0In": "g",
        "amount1In": "h",
        "liquidity": "i",
        "_reserve1": "j",
        "balanceOf": "k",
        "_reserve0": "l",
        "balance1": "m",
        "reserve1": "n",
        "balance0": "o",
        "reserve0": "p",
        "_token0": "q",
        "amount0": "r",
        "_token1": "s",
        "amount1": "t",
        "account": "u",
        "amount": "v",
        "token0": "w",
        "token1": "x",
        "swap": "y",
        "sqrt": "z",
        "mint": "aa",
        "to": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_023",
      "transformed_id": "ss_l2_short_nc_tc_023",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function o(address s) external view returns (uint256);\n\n    function transfer(address ab, uint256 u) external returns (bool);\n\n    function h(\n        address from,\n        address ab,\n        uint256 u\n    ) external returns (bool);\n}\n\ninterface ICErc20 {\n    function t(uint256 u) external returns (uint256);\n\n    function a(address s) external returns (uint256);\n}\n\ncontract LeveragedVault {\n    struct Position {\n        address x;\n        uint256 j;\n        uint256 p;\n    }\n\n    mapping(uint256 => Position) public l;\n    uint256 public d;\n\n    address public v;\n    uint256 public n;\n    uint256 public e;\n\n    constructor(address q) {\n        v = q;\n        d = 1;\n    }\n\n    function i(\n        uint256 b,\n        uint256 g\n    ) external returns (uint256 k) {\n        k = d++;\n\n        l[k] = Position({\n            x: msg.sender,\n            j: b,\n            p: 0\n        });\n\n        r(k, g);\n\n        return k;\n    }\n\n    function r(uint256 k, uint256 u) internal {\n        Position storage aa = l[k];\n\n        uint256 w;\n\n        if (e == 0) {\n            w = u;\n        } else {\n            w = (u * e) / n;\n        }\n\n        aa.p += w;\n        e += w;\n        n += u;\n\n        ICErc20(v).t(u);\n    }\n\n    function y(uint256 k, uint256 u) external {\n        Position storage aa = l[k];\n        require(msg.sender == aa.x, \"Not position owner\");\n\n        uint256 f = (u * e) / n;\n\n        require(aa.p >= f, \"Excessive repayment\");\n\n        aa.p -= f;\n        e -= f;\n        n -= u;\n    }\n\n    function c(\n        uint256 k\n    ) external view returns (uint256) {\n        Position storage aa = l[k];\n\n        if (e == 0) return 0;\n\n        return (aa.p * n) / e;\n    }\n\n    function m(uint256 k) external {\n        Position storage aa = l[k];\n\n        uint256 z = (aa.p * n) / e;\n\n        require(aa.j * 100 < z * 150, \"Position is healthy\");\n\n        aa.j = 0;\n        aa.p = 0;\n    }\n}",
      "rename_map": {
        "borrowBalanceCurrent": "a",
        "collateralAmount": "b",
        "getPositionDebt": "c",
        "nextPositionId": "d",
        "totalDebtShare": "e",
        "shareToRemove": "f",
        "borrowAmount": "g",
        "transferFrom": "h",
        "openPosition": "i",
        "collateral": "j",
        "positionId": "k",
        "positions": "l",
        "liquidate": "m",
        "totalDebt": "n",
        "balanceOf": "o",
        "debtShare": "p",
        "_cToken": "q",
        "_borrow": "r",
        "account": "s",
        "borrow": "t",
        "amount": "u",
        "cToken": "v",
        "share": "w",
        "owner": "x",
        "repay": "y",
        "debt": "z",
        "pos": "aa",
        "to": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_024",
      "transformed_id": "ss_l2_short_nc_tc_024",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function p(address w) external view returns (uint256);\n\n    function transfer(address ac, uint256 y) external returns (bool);\n\n    function j(\n        address from,\n        address ac,\n        uint256 y\n    ) external returns (bool);\n}\n\ninterface ICurvePool {\n    function b() external view returns (uint256);\n\n    function h(\n        uint256[3] calldata t,\n        uint256 g\n    ) external;\n}\n\ncontract PriceOracle {\n    ICurvePool public o;\n\n    constructor(address l) {\n        o = ICurvePool(l);\n    }\n\n    function r() external view returns (uint256) {\n        return o.b();\n    }\n}\n\ncontract LendingProtocol {\n    struct Position {\n        uint256 m;\n        uint256 s;\n    }\n\n    mapping(address => Position) public n;\n\n    address public e;\n    address public k;\n    address public z;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(\n        address d,\n        address i,\n        address v\n    ) {\n        e = d;\n        k = i;\n        z = v;\n    }\n\n    function u(uint256 y) external {\n        IERC20(e).j(msg.sender, address(this), y);\n        n[msg.sender].m += y;\n    }\n\n    function x(uint256 y) external {\n        uint256 f = a(msg.sender);\n        uint256 q = (f * COLLATERAL_FACTOR) / 100;\n\n        require(\n            n[msg.sender].s + y <= q,\n            \"Insufficient collateral\"\n        );\n\n        n[msg.sender].s += y;\n        IERC20(k).transfer(msg.sender, y);\n    }\n\n    function a(address ab) public view returns (uint256) {\n        uint256 c = n[ab].m;\n        uint256 aa = PriceOracle(z).r();\n\n        return (c * aa) / 1e18;\n    }\n}",
      "rename_map": {
        "getCollateralValue": "a",
        "get_virtual_price": "b",
        "collateralAmount": "c",
        "_collateralToken": "d",
        "collateralToken": "e",
        "collateralValue": "f",
        "minMintAmount": "g",
        "add_liquidity": "h",
        "_borrowToken": "i",
        "transferFrom": "j",
        "borrowToken": "k",
        "_curvePool": "l",
        "collateral": "m",
        "positions": "n",
        "curvePool": "o",
        "balanceOf": "p",
        "maxBorrow": "q",
        "getPrice": "r",
        "borrowed": "s",
        "amounts": "t",
        "deposit": "u",
        "_oracle": "v",
        "account": "w",
        "borrow": "x",
        "amount": "y",
        "oracle": "z",
        "price": "aa",
        "user": "ab",
        "to": "ac"
      },
      "changes": [
        "Renamed 29 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_025",
      "transformed_id": "ss_l2_short_nc_tc_025",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address m, uint256 h) external returns (bool);\n    function d(address from, address m, uint256 h) external returns (bool);\n}\n\ninterface ICompoundToken {\n    function j(uint256 h) external;\n    function f(uint256 h) external;\n    function i(uint256 k) external;\n    function l(uint256 h) external;\n}\n\ncontract LendingMarket {\n    mapping(address => uint256) public a;\n    mapping(address => uint256) public b;\n\n    address public g;\n    uint256 public c;\n\n    constructor(address e) {\n        g = e;\n    }\n\n    function j(uint256 h) external {\n        a[msg.sender] += h;\n        c += h;\n\n        IERC20(g).transfer(msg.sender, h);\n    }\n\n    function f(uint256 h) external {\n        IERC20(g).d(msg.sender, address(this), h);\n\n        a[msg.sender] -= h;\n        c -= h;\n    }\n}",
      "rename_map": {
        "accountBorrows": "a",
        "accountTokens": "b",
        "totalBorrows": "c",
        "transferFrom": "d",
        "_underlying": "e",
        "repayBorrow": "f",
        "underlying": "g",
        "amount": "h",
        "redeem": "i",
        "borrow": "j",
        "tokens": "k",
        "mint": "l",
        "to": "m"
      },
      "changes": [
        "Renamed 13 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_026",
      "transformed_id": "ss_l2_short_nc_tc_026",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20Permit {\n    function f(address i, address e, uint256 value, uint256 d, uint8 v, bytes32 r, bytes32 s) external;\n}\n\ncontract BridgeRouter {\n\n    function a(\n        address from,\n        address h,\n        address j,\n        uint256 g,\n        uint256 d,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 c\n    ) external {\n\n        if (v != 0 || r != bytes32(0) || s != bytes32(0)) {\n            try IERC20Permit(h).f(from, address(this), g, d, v, r, s) {} catch {}\n        }\n\n        b(from, h, j, g, c);\n    }\n\n    function b(address from, address h, address j, uint256 g, uint256 c) internal {\n\n    }\n}",
      "rename_map": {
        "bridgeOutWithPermit": "a",
        "_bridgeOut": "b",
        "toChainID": "c",
        "deadline": "d",
        "spender": "e",
        "permit": "f",
        "amount": "g",
        "token": "h",
        "owner": "i",
        "to": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_027",
      "transformed_id": "ss_l2_short_nc_tc_027",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IPair {\n    function o() external view returns (address);\n    function r() external view returns (address);\n    function e() external view returns (uint112, uint112, uint32);\n}\n\ncontract SwapRouter {\n\n    function a(\n        uint256 l,\n        uint256 d,\n        address[] calldata s,\n        address u,\n        uint256 i\n    ) external returns (uint[] memory n) {\n\n        n = new uint[](s.length);\n        n[0] = l;\n\n        for (uint i = 0; i < s.length - 1; i++) {\n            address t = k(s[i], s[i+1]);\n\n            (uint112 m, uint112 j,) = IPair(t).e();\n\n            n[i+1] = b(n[i], m, j);\n        }\n\n        return n;\n    }\n\n    function k(address p, address q) internal pure returns (address) {\n        return address(uint160(uint256(g(abi.c(p, q)))));\n    }\n\n    function b(uint256 l, uint112 h, uint112 f) internal pure returns (uint256) {\n        return (l * uint256(f)) / uint256(h);\n    }\n}",
      "rename_map": {
        "swapExactTokensForTokens": "a",
        "_getAmountOut": "b",
        "encodePacked": "c",
        "amountOutMin": "d",
        "getReserves": "e",
        "reserveOut": "f",
        "keccak256": "g",
        "reserveIn": "h",
        "deadline": "i",
        "reserve1": "j",
        "_getPair": "k",
        "amountIn": "l",
        "reserve0": "m",
        "amounts": "n",
        "token0": "o",
        "tokenA": "p",
        "tokenB": "q",
        "token1": "r",
        "path": "s",
        "pair": "t",
        "to": "u"
      },
      "changes": [
        "Renamed 21 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_028",
      "transformed_id": "ss_l2_short_nc_tc_028",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function b(address f) external view returns (uint256);\n    function transfer(address j, uint256 g) external returns (bool);\n    function a(address from, address j, uint256 g) external returns (bool);\n}\n\ncontract TokenVault {\n    address public i;\n    mapping(address => uint256) public d;\n\n    constructor(address h) {\n        i = h;\n    }\n\n    function e(uint256 g) external {\n        IERC20(i).a(msg.sender, address(this), g);\n\n        d[msg.sender] += g;\n    }\n\n    function c(uint256 g) external {\n        require(d[msg.sender] >= g, \"Insufficient\");\n\n        d[msg.sender] -= g;\n\n        IERC20(i).transfer(msg.sender, g);\n    }\n}",
      "rename_map": {
        "transferFrom": "a",
        "balanceOf": "b",
        "withdraw": "c",
        "deposits": "d",
        "deposit": "e",
        "account": "f",
        "amount": "g",
        "_token": "h",
        "token": "i",
        "to": "j"
      },
      "changes": [
        "Renamed 10 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_029",
      "transformed_id": "ss_l2_short_nc_tc_029",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function f(address k) external view returns (uint256);\n    function transfer(address s, uint256 l) external returns (bool);\n    function a(address from, address s, uint256 l) external returns (bool);\n}\n\ninterface IPriceOracle {\n    function g(address o) external view returns (uint256);\n}\n\ncontract VaultStrategy {\n    address public e;\n    address public n;\n    uint256 public d;\n\n    mapping(address => uint256) public m;\n\n    constructor(address q, address j) {\n        e = q;\n        n = j;\n    }\n\n    function i(uint256 l) external returns (uint256 c) {\n        uint256 r = IERC20(e).f(address(this));\n\n        if (d == 0) {\n            c = l;\n        } else {\n            uint256 p = IPriceOracle(n).g(e);\n            c = (l * d * 1e18) / (r * p);\n        }\n\n        m[msg.sender] += c;\n        d += c;\n\n        IERC20(e).a(msg.sender, address(this), l);\n        return c;\n    }\n\n    function h(uint256 b) external {\n        uint256 r = IERC20(e).f(address(this));\n\n        uint256 p = IPriceOracle(n).g(e);\n        uint256 l = (b * r * p) / (d * 1e18);\n\n        m[msg.sender] -= b;\n        d -= b;\n\n        IERC20(e).transfer(msg.sender, l);\n    }\n}",
      "rename_map": {
        "transferFrom": "a",
        "sharesAmount": "b",
        "sharesAdded": "c",
        "totalShares": "d",
        "wantToken": "e",
        "balanceOf": "f",
        "getPrice": "g",
        "withdraw": "h",
        "deposit": "i",
        "_oracle": "j",
        "account": "k",
        "amount": "l",
        "shares": "m",
        "oracle": "n",
        "token": "o",
        "price": "p",
        "_want": "q",
        "pool": "r",
        "to": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_030",
      "transformed_id": "ss_l2_short_nc_tc_030",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ncontract LiquidityPool {\n    uint256 public h;\n    uint256 public e;\n    uint256 public g;\n\n    mapping(address => uint256) public m;\n\n    function c(uint256 k, uint256 i) external returns (uint256 b) {\n\n        if (g == 0) {\n            b = k;\n        } else {\n            uint256 l = (k * g) / h;\n            uint256 f = (i * g) / e;\n\n            b = (l + f) / 2;\n        }\n\n        m[msg.sender] += b;\n        g += b;\n\n        h += k;\n        e += i;\n\n        return b;\n    }\n\n    function a(uint256 b) external returns (uint256, uint256) {\n        uint256 j = (b * h) / g;\n        uint256 d = (b * e) / g;\n\n        m[msg.sender] -= b;\n        g -= b;\n\n        h -= j;\n        e -= d;\n\n        return (j, d);\n    }\n}",
      "rename_map": {
        "removeLiquidity": "a",
        "liquidityUnits": "b",
        "addLiquidity": "c",
        "outputToken": "d",
        "tokenAmount": "e",
        "tokenRatio": "f",
        "totalUnits": "g",
        "baseAmount": "h",
        "inputToken": "i",
        "outputBase": "j",
        "inputBase": "k",
        "baseRatio": "l",
        "units": "m"
      },
      "changes": [
        "Renamed 13 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_031",
      "transformed_id": "ss_l2_short_nc_tc_031",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address s, uint256 o) external returns (bool);\n\n    function i(address m) external view returns (uint256);\n}\n\ncontract OrbitBridge {\n    mapping(bytes32 => bool) public a;\n    uint256 public constant REQUIRED_SIGNATURES = 5;\n    uint256 public constant TOTAL_VALIDATORS = 7;\n\n    mapping(address => bool) public e;\n    address[] public b;\n\n    event WithdrawalProcessed(\n        bytes32 n,\n        address q,\n        address f,\n        uint256 o\n    );\n\n    constructor() {\n        b = new address[](TOTAL_VALIDATORS);\n    }\n\n    function l(\n        address d,\n        string memory g,\n        bytes memory j,\n        address p,\n        address q,\n        bytes32[] memory k,\n        uint256[] memory r,\n        bytes memory data,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) external {\n        bytes32 n = k[1];\n\n        require(\n            !a[n],\n            \"Transaction already processed\"\n        );\n\n        require(v.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n        require(\n            v.length == r.length && r.length == s.length,\n            \"Signature length mismatch\"\n        );\n\n        uint256 o = r[0];\n\n        a[n] = true;\n\n        IERC20(q).transfer(p, o);\n\n        emit WithdrawalProcessed(n, q, p, o);\n    }\n\n    function c(address h) external {\n        e[h] = true;\n    }\n}",
      "rename_map": {
        "processedTransactions": "a",
        "validatorList": "b",
        "addValidator": "c",
        "hubContract": "d",
        "validators": "e",
        "recipient": "f",
        "fromChain": "g",
        "validator": "h",
        "balanceOf": "i",
        "fromAddr": "j",
        "bytes32s": "k",
        "withdraw": "l",
        "account": "m",
        "txHash": "n",
        "amount": "o",
        "toAddr": "p",
        "token": "q",
        "uints": "r",
        "to": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_032",
      "transformed_id": "ss_l2_short_nc_tc_032",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address aj, uint256 ac) external returns (bool);\n\n    function j(\n        address from,\n        address aj,\n        uint256 ac\n    ) external returns (bool);\n\n    function q(address z) external view returns (uint256);\n\n    function y(address x, uint256 ac) external returns (bool);\n}\n\ninterface IFlashLoanReceiver {\n    function b(\n        address[] calldata ad,\n        uint256[] calldata u,\n        uint256[] calldata t,\n        address o,\n        bytes calldata ae\n    ) external returns (bool);\n}\n\ncontract RadiantLendingPool {\n    uint256 public constant RAY = 1e27;\n\n    struct ReserveData {\n        uint256 e;\n        uint256 f;\n        address h;\n    }\n\n    mapping(address => ReserveData) public s;\n\n    function v(\n        address ai,\n        uint256 ac,\n        address n,\n        uint16 i\n    ) external {\n        IERC20(ai).j(msg.sender, address(this), ac);\n\n        ReserveData storage w = s[ai];\n\n        uint256 a = w.e;\n        if (a == 0) {\n            a = RAY;\n        }\n\n        w.e =\n            a +\n            (ac * RAY) /\n            (w.f + 1);\n        w.f += ac;\n\n        uint256 k = af(ac, w.e);\n        l(w.h, n, k);\n    }\n\n    function r(\n        address ai,\n        uint256 ac,\n        address aj\n    ) external returns (uint256) {\n        ReserveData storage w = s[ai];\n\n        uint256 g = af(ac, w.e);\n\n        m(w.h, msg.sender, g);\n\n        w.f -= ac;\n        IERC20(ai).transfer(aj, ac);\n\n        return ac;\n    }\n\n    function aa(\n        address ai,\n        uint256 ac,\n        uint256 c,\n        uint16 i,\n        address n\n    ) external {\n        IERC20(ai).transfer(n, ac);\n    }\n\n    function p(\n        address d,\n        address[] calldata ad,\n        uint256[] calldata u,\n        uint256[] calldata ag,\n        address n,\n        bytes calldata ae,\n        uint16 i\n    ) external {\n        for (uint256 i = 0; i < ad.length; i++) {\n            IERC20(ad[i]).transfer(d, u[i]);\n        }\n\n        require(\n            IFlashLoanReceiver(d).b(\n                ad,\n                u,\n                new uint256[](ad.length),\n                msg.sender,\n                ae\n            ),\n            \"Flashloan callback failed\"\n        );\n\n        for (uint256 i = 0; i < ad.length; i++) {\n            IERC20(ad[i]).j(\n                d,\n                address(this),\n                u[i]\n            );\n        }\n    }\n\n    function af(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 ah = b / 2;\n        require(b != 0, \"Division by zero\");\n        return (a * RAY + ah) / b;\n    }\n\n    function l(address ab, address aj, uint256 ac) internal {}\n\n    function m(\n        address ab,\n        address from,\n        uint256 ac\n    ) internal {}\n}",
      "rename_map": {
        "currentLiquidityIndex": "a",
        "executeOperation": "b",
        "interestRateMode": "c",
        "receiverAddress": "d",
        "liquidityIndex": "e",
        "totalLiquidity": "f",
        "rTokensToBurn": "g",
        "rTokenAddress": "h",
        "referralCode": "i",
        "transferFrom": "j",
        "rTokenAmount": "k",
        "_mintRToken": "l",
        "_burnRToken": "m",
        "onBehalfOf": "n",
        "initiator": "o",
        "flashLoan": "p",
        "balanceOf": "q",
        "withdraw": "r",
        "reserves": "s",
        "premiums": "t",
        "amounts": "u",
        "deposit": "v",
        "reserve": "w",
        "spender": "x",
        "approve": "y",
        "account": "z",
        "borrow": "aa",
        "rToken": "ab",
        "amount": "ac",
        "assets": "ad",
        "params": "ae",
        "rayDiv": "af",
        "modes": "ag",
        "halfB": "ah",
        "asset": "ai",
        "to": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_033",
      "transformed_id": "ss_l2_short_nc_tc_033",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address w, uint256 s) external returns (bool);\n\n    function f(\n        address from,\n        address w,\n        uint256 s\n    ) external returns (bool);\n\n    function j(address r) external view returns (uint256);\n\n    function q(address o, uint256 s) external returns (bool);\n}\n\ncontract SocketGateway {\n    mapping(uint32 => address) public t;\n    mapping(address => bool) public b;\n\n    event RouteExecuted(uint32 p, address v, bytes u);\n\n    function e(\n        uint32 p,\n        bytes calldata h\n    ) external payable returns (bytes memory) {\n        address g = t[p];\n        require(g != address(0), \"Invalid route\");\n        require(b[g], \"Route not approved\");\n\n        (bool n, bytes memory u) = g.call(h);\n        require(n, \"Route execution failed\");\n\n        emit RouteExecuted(p, msg.sender, u);\n        return u;\n    }\n\n    function l(uint32 p, address g) external {\n        t[p] = g;\n        b[g] = true;\n    }\n}\n\ncontract BasicRoute {\n    function d(\n        address i,\n        address m,\n        uint256 s,\n        address a,\n        bytes32 k,\n        bytes calldata c\n    ) external payable returns (uint256) {\n        if (c.length > 0) {\n            (bool n, ) = i.call(c);\n            require(n, \"Swap failed\");\n        }\n\n        return s;\n    }\n}",
      "rename_map": {
        "receiverAddress": "a",
        "approvedRoutes": "b",
        "swapExtraData": "c",
        "performAction": "d",
        "executeRoute": "e",
        "transferFrom": "f",
        "routeAddress": "g",
        "routeData": "h",
        "fromToken": "i",
        "balanceOf": "j",
        "metadata": "k",
        "addRoute": "l",
        "toToken": "m",
        "success": "n",
        "spender": "o",
        "routeId": "p",
        "approve": "q",
        "account": "r",
        "amount": "s",
        "routes": "t",
        "result": "u",
        "user": "v",
        "to": "w"
      },
      "changes": [
        "Renamed 23 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_034",
      "transformed_id": "ss_l2_short_nc_tc_034",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address aj, uint256 aa) external returns (bool);\n\n    function h(\n        address from,\n        address aj,\n        uint256 aa\n    ) external returns (bool);\n\n    function o(address z) external view returns (uint256);\n\n    function y(address x, uint256 aa) external returns (bool);\n}\n\ninterface IUniswapV3Pool {\n    function ai(\n        address n,\n        bool k,\n        int256 c,\n        uint160 a,\n        bytes calldata data\n    ) external returns (int256 v, int256 w);\n\n    function ag(\n        address n,\n        uint256 v,\n        uint256 w,\n        bytes calldata data\n    ) external;\n}\n\ncontract GammaHypervisor {\n    IERC20 public ae;\n    IERC20 public af;\n    IUniswapV3Pool public ah;\n\n    uint256 public j;\n    mapping(address => uint256) public o;\n\n    struct Position {\n        uint128 m;\n        int24 p;\n        int24 q;\n    }\n\n    Position public i;\n    Position public g;\n\n    function u(\n        uint256 r,\n        uint256 t,\n        address aj\n    ) external returns (uint256 ab) {\n        uint256 ac = ae.o(address(this));\n        uint256 ad = af.o(address(this));\n\n        ae.h(msg.sender, address(this), r);\n        af.h(msg.sender, address(this), t);\n\n        if (j == 0) {\n            ab = r + t;\n        } else {\n            uint256 e = ac + r;\n            uint256 d = ad + t;\n\n            ab = (j * (r + t)) / (ac + ad);\n        }\n\n        o[aj] += ab;\n        j += ab;\n\n        f(r, t);\n    }\n\n    function s(\n        uint256 ab,\n        address aj\n    ) external returns (uint256 v, uint256 w) {\n        require(o[msg.sender] >= ab, \"Insufficient balance\");\n\n        uint256 ac = ae.o(address(this));\n        uint256 ad = af.o(address(this));\n\n        v = (ab * ac) / j;\n        w = (ab * ad) / j;\n\n        o[msg.sender] -= ab;\n        j -= ab;\n\n        ae.transfer(aj, v);\n        af.transfer(aj, w);\n    }\n\n    function l() external {\n        b(i.m);\n\n        f(\n            ae.o(address(this)),\n            af.o(address(this))\n        );\n    }\n\n    function f(uint256 v, uint256 w) internal {}\n\n    function b(uint128 m) internal {}\n}",
      "rename_map": {
        "sqrtPriceLimitX96": "a",
        "_removeLiquidity": "b",
        "amountSpecified": "c",
        "amount1Current": "d",
        "amount0Current": "e",
        "_addLiquidity": "f",
        "limitPosition": "g",
        "transferFrom": "h",
        "basePosition": "i",
        "totalSupply": "j",
        "zeroForOne": "k",
        "rebalance": "l",
        "liquidity": "m",
        "recipient": "n",
        "balanceOf": "o",
        "tickLower": "p",
        "tickUpper": "q",
        "deposit0": "r",
        "withdraw": "s",
        "deposit1": "t",
        "deposit": "u",
        "amount0": "v",
        "amount1": "w",
        "spender": "x",
        "approve": "y",
        "account": "z",
        "amount": "aa",
        "shares": "ab",
        "total0": "ac",
        "total1": "ad",
        "token0": "ae",
        "token1": "af",
        "flash": "ag",
        "pool": "ah",
        "swap": "ai",
        "to": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_035",
      "transformed_id": "ss_l2_short_nc_tc_035",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ah, uint256 ad) external returns (bool);\n\n    function o(\n        address from,\n        address ah,\n        uint256 ad\n    ) external returns (bool);\n\n    function v(address ac) external view returns (uint256);\n\n    function ab(address y, uint256 ad) external returns (bool);\n}\n\ninterface IERC721 {\n    function o(address from, address ah, uint256 z) external;\n\n    function x(uint256 z) external view returns (address);\n}\n\ncontract WiseLending {\n    struct PoolData {\n        uint256 k;\n        uint256 d;\n        uint256 f;\n        uint256 h;\n    }\n\n    mapping(address => PoolData) public l;\n    mapping(uint256 => mapping(address => uint256)) public g;\n    mapping(uint256 => mapping(address => uint256)) public i;\n\n    IERC721 public p;\n    uint256 public n;\n\n    function q() external returns (uint256) {\n        uint256 af = ++n;\n        return af;\n    }\n\n    function e(\n        uint256 ae,\n        address u,\n        uint256 aa\n    ) external returns (uint256 s) {\n        IERC20(u).o(msg.sender, address(this), aa);\n\n        PoolData storage ag = l[u];\n\n        if (ag.d == 0) {\n            s = aa;\n            ag.d = aa;\n        } else {\n            s =\n                (aa * ag.d) /\n                ag.k;\n            ag.d += s;\n        }\n\n        ag.k += aa;\n        g[ae][u] += s;\n\n        return s;\n    }\n\n    function c(\n        uint256 ae,\n        address u,\n        uint256 w\n    ) external returns (uint256 m) {\n        require(\n            g[ae][u] >= w,\n            \"Insufficient shares\"\n        );\n\n        PoolData storage ag = l[u];\n\n        m =\n            (w * ag.k) /\n            ag.d;\n\n        g[ae][u] -= w;\n        ag.d -= w;\n        ag.k -= m;\n\n        IERC20(u).transfer(msg.sender, m);\n\n        return m;\n    }\n\n    function b(\n        uint256 ae,\n        address u,\n        uint256 j\n    ) external returns (uint256 t) {\n        PoolData storage ag = l[u];\n\n        t =\n            (j * ag.d) /\n            ag.k;\n\n        require(\n            g[ae][u] >= t,\n            \"Insufficient shares\"\n        );\n\n        g[ae][u] -= t;\n        ag.d -= t;\n        ag.k -= j;\n\n        IERC20(u).transfer(msg.sender, j);\n\n        return t;\n    }\n\n    function a(\n        uint256 ae,\n        address u\n    ) external view returns (uint256) {\n        return g[ae][u];\n    }\n\n    function r(address u) external view returns (uint256) {\n        return l[u].k;\n    }\n}",
      "rename_map": {
        "getPositionLendingShares": "a",
        "withdrawExactAmount": "b",
        "withdrawExactShares": "c",
        "totalDepositShares": "d",
        "depositExactAmount": "e",
        "totalBorrowShares": "f",
        "userLendingShares": "g",
        "collateralFactor": "h",
        "userBorrowShares": "i",
        "_withdrawAmount": "j",
        "pseudoTotalPool": "k",
        "lendingPoolData": "l",
        "withdrawAmount": "m",
        "nftIdCounter": "n",
        "transferFrom": "o",
        "positionNFTs": "p",
        "mintPosition": "q",
        "getTotalPool": "r",
        "shareAmount": "s",
        "shareBurned": "t",
        "_poolToken": "u",
        "balanceOf": "v",
        "_shares": "w",
        "ownerOf": "x",
        "spender": "y",
        "tokenId": "z",
        "_amount": "aa",
        "approve": "ab",
        "account": "ac",
        "amount": "ad",
        "_nftId": "ae",
        "nftId": "af",
        "pool": "ag",
        "to": "ah"
      },
      "changes": [
        "Renamed 34 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_036",
      "transformed_id": "ss_l2_short_nc_tc_036",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address al, uint256 ag) external returns (bool);\n\n    function l(\n        address from,\n        address al,\n        uint256 ag\n    ) external returns (bool);\n\n    function y(address ae) external view returns (uint256);\n\n    function ad(address ab, uint256 ag) external returns (bool);\n}\n\ninterface IBorrowerOperations {\n    function d(address x, bool o) external;\n\n    function w(\n        address m,\n        address ae,\n        uint256 g,\n        uint256 f,\n        uint256 n,\n        address r,\n        address q\n    ) external;\n\n    function s(address m, address ae) external;\n}\n\ninterface ITroveManager {\n    function c(\n        address v\n    ) external view returns (uint256 ak, uint256 aj);\n\n    function t(address v) external;\n}\n\ncontract MigrateTroveZap {\n    IBorrowerOperations public e;\n    address public af;\n    address public ai;\n\n    constructor(address a, address ac, address ah) {\n        e = a;\n        af = ac;\n        ai = ah;\n    }\n\n    function b(\n        address m,\n        address ae,\n        uint256 h,\n        uint256 i,\n        uint256 p,\n        address aa,\n        address z\n    ) external {\n        IERC20(af).l(\n            msg.sender,\n            address(this),\n            i\n        );\n\n        IERC20(af).ad(address(e), i);\n\n        e.w(\n            m,\n            ae,\n            h,\n            i,\n            p,\n            aa,\n            z\n        );\n\n        IERC20(ai).transfer(msg.sender, p);\n    }\n\n    function j(address m, address ae) external {\n        e.s(m, ae);\n    }\n}\n\ncontract BorrowerOperations {\n    mapping(address => mapping(address => bool)) public u;\n    ITroveManager public m;\n\n    function d(address x, bool o) external {\n        u[msg.sender][x] = o;\n    }\n\n    function w(\n        address k,\n        address ae,\n        uint256 g,\n        uint256 f,\n        uint256 n,\n        address r,\n        address q\n    ) external {\n        require(\n            msg.sender == ae || u[ae][msg.sender],\n            \"Not authorized\"\n        );\n    }\n\n    function s(address k, address ae) external {\n        require(\n            msg.sender == ae || u[ae][msg.sender],\n            \"Not authorized\"\n        );\n    }\n}",
      "rename_map": {
        "_borrowerOperations": "a",
        "openTroveAndMigrate": "b",
        "getTroveCollAndDebt": "c",
        "setDelegateApproval": "d",
        "borrowerOperations": "e",
        "_collateralAmount": "f",
        "_maxFeePercentage": "g",
        "maxFeePercentage": "h",
        "collateralAmount": "i",
        "closeTroveFor": "j",
        "_troveManager": "k",
        "transferFrom": "l",
        "troveManager": "m",
        "_debtAmount": "n",
        "_isApproved": "o",
        "debtAmount": "p",
        "_lowerHint": "q",
        "_upperHint": "r",
        "closeTrove": "s",
        "liquidate": "t",
        "delegates": "u",
        "_borrower": "v",
        "openTrove": "w",
        "_delegate": "x",
        "balanceOf": "y",
        "lowerHint": "z",
        "upperHint": "aa",
        "spender": "ab",
        "_wstETH": "ac",
        "approve": "ad",
        "account": "ae",
        "wstETH": "af",
        "amount": "ag",
        "_mkUSD": "ah",
        "mkUSD": "ai",
        "debt": "aj",
        "coll": "ak",
        "to": "al"
      },
      "changes": [
        "Renamed 38 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_037",
      "transformed_id": "ss_l2_short_nc_tc_037",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address aj, uint256 ab) external returns (bool);\n\n    function g(\n        address from,\n        address aj,\n        uint256 ab\n    ) external returns (bool);\n\n    function l(address y) external view returns (uint256);\n\n    function x(address w, uint256 ab) external returns (bool);\n}\n\ninterface IAaveOracle {\n    function e(address ah) external view returns (uint256);\n\n    function c(\n        address[] calldata ad,\n        address[] calldata u\n    ) external;\n}\n\ninterface ICurvePool {\n    function s(\n        int128 i,\n        int128 j,\n        uint256 ai,\n        uint256 z\n    ) external returns (uint256);\n\n    function ac(\n        int128 i,\n        int128 j,\n        uint256 ai\n    ) external view returns (uint256);\n\n    function p(uint256 i) external view returns (uint256);\n}\n\ninterface ILendingPool {\n    function t(\n        address ah,\n        uint256 ab,\n        address j,\n        uint16 f\n    ) external;\n\n    function aa(\n        address ah,\n        uint256 ab,\n        uint256 a,\n        uint16 f,\n        address j\n    ) external;\n\n    function q(\n        address ah,\n        uint256 ab,\n        address aj\n    ) external returns (uint256);\n}\n\ncontract UwuLendingPool is ILendingPool {\n    IAaveOracle public ae;\n    mapping(address => uint256) public o;\n    mapping(address => uint256) public v;\n    uint256 public constant LTV = 8500;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    function t(\n        address ah,\n        uint256 ab,\n        address j,\n        uint16 f\n    ) external override {\n        IERC20(ah).g(msg.sender, address(this), ab);\n        o[j] += ab;\n    }\n\n    function aa(\n        address ah,\n        uint256 ab,\n        uint256 a,\n        uint16 f,\n        address j\n    ) external override {\n        uint256 b = ae.e(msg.sender);\n        uint256 h = ae.e(ah);\n\n        uint256 d = (o[msg.sender] * b) /\n            1e18;\n        uint256 m = (d * LTV) / BASIS_POINTS;\n\n        uint256 i = (ab * h) / 1e18;\n\n        require(i <= m, \"Insufficient collateral\");\n\n        v[msg.sender] += ab;\n        IERC20(ah).transfer(j, ab);\n    }\n\n    function q(\n        address ah,\n        uint256 ab,\n        address aj\n    ) external override returns (uint256) {\n        require(o[msg.sender] >= ab, \"Insufficient balance\");\n        o[msg.sender] -= ab;\n        IERC20(ah).transfer(aj, ab);\n        return ab;\n    }\n}\n\ncontract CurveOracle {\n    ICurvePool public k;\n\n    constructor(address ag) {\n        k = ag;\n    }\n\n    function e(address ah) external view returns (uint256) {\n        uint256 r = k.p(0);\n        uint256 n = k.p(1);\n\n        uint256 af = (n * 1e18) / r;\n\n        return af;\n    }\n}",
      "rename_map": {
        "interestRateMode": "a",
        "collateralPrice": "b",
        "setAssetSources": "c",
        "collateralValue": "d",
        "getAssetPrice": "e",
        "referralCode": "f",
        "transferFrom": "g",
        "borrowPrice": "h",
        "borrowValue": "i",
        "onBehalfOf": "j",
        "curvePool": "k",
        "balanceOf": "l",
        "maxBorrow": "m",
        "balance1": "n",
        "deposits": "o",
        "balances": "p",
        "withdraw": "q",
        "balance0": "r",
        "exchange": "s",
        "deposit": "t",
        "sources": "u",
        "borrows": "v",
        "spender": "w",
        "approve": "x",
        "account": "y",
        "min_dy": "z",
        "borrow": "aa",
        "amount": "ab",
        "get_dy": "ac",
        "assets": "ad",
        "oracle": "ae",
        "price": "af",
        "_pool": "ag",
        "asset": "ah",
        "dx": "ai",
        "to": "aj"
      },
      "changes": [
        "Renamed 36 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_038",
      "transformed_id": "ss_l2_short_nc_tc_038",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ah, uint256 ab) external returns (bool);\n\n    function i(\n        address from,\n        address ah,\n        uint256 ab\n    ) external returns (bool);\n\n    function p(address z) external view returns (uint256);\n\n    function y(address w, uint256 ab) external returns (bool);\n}\n\ninterface IPriceOracle {\n    function q(address ae) external view returns (uint256);\n}\n\ncontract BlueberryLending {\n    struct Market {\n        bool s;\n        uint256 c;\n        mapping(address => uint256) b;\n        mapping(address => uint256) f;\n    }\n\n    mapping(address => Market) public u;\n    IPriceOracle public ad;\n\n    uint256 public constant COLLATERAL_FACTOR = 75;\n    uint256 public constant BASIS_POINTS = 100;\n\n    function h(\n        address[] calldata v\n    ) external returns (uint256[] memory) {\n        uint256[] memory x = new uint256[](v.length);\n        for (uint256 i = 0; i < v.length; i++) {\n            u[v[i]].s = true;\n            x[i] = 0;\n        }\n        return x;\n    }\n\n    function ag(address ae, uint256 ab) external returns (uint256) {\n        IERC20(ae).i(msg.sender, address(this), ab);\n\n        uint256 af = ad.q(ae);\n\n        u[ae].b[msg.sender] += ab;\n        return 0;\n    }\n\n    function aa(\n        address k,\n        uint256 g\n    ) external returns (uint256) {\n        uint256 a = 0;\n\n        uint256 l = ad.q(k);\n        uint256 m = (g * l) / 1e18;\n\n        uint256 e = (a * COLLATERAL_FACTOR) /\n            BASIS_POINTS;\n\n        require(m <= e, \"Insufficient collateral\");\n\n        u[k].f[msg.sender] += g;\n        IERC20(k).transfer(msg.sender, g);\n\n        return 0;\n    }\n\n    function o(\n        address r,\n        address n,\n        uint256 j,\n        address d\n    ) external {}\n}\n\ncontract ManipulableOracle is IPriceOracle {\n    mapping(address => uint256) public ac;\n\n    function q(address ae) external view override returns (uint256) {\n        return ac[ae];\n    }\n\n    function t(address ae, uint256 af) external {\n        ac[ae] = af;\n    }\n}",
      "rename_map": {
        "totalCollateralValue": "a",
        "accountCollateral": "b",
        "collateralFactor": "c",
        "collateralToken": "d",
        "maxBorrowValue": "e",
        "accountBorrows": "f",
        "borrowAmount": "g",
        "enterMarkets": "h",
        "transferFrom": "i",
        "repayAmount": "j",
        "borrowToken": "k",
        "borrowPrice": "l",
        "borrowValue": "m",
        "repayToken": "n",
        "liquidate": "o",
        "balanceOf": "p",
        "getPrice": "q",
        "borrower": "r",
        "isListed": "s",
        "setPrice": "t",
        "markets": "u",
        "vTokens": "v",
        "spender": "w",
        "results": "x",
        "approve": "y",
        "account": "z",
        "borrow": "aa",
        "amount": "ab",
        "prices": "ac",
        "oracle": "ad",
        "token": "ae",
        "price": "af",
        "mint": "ag",
        "to": "ah"
      },
      "changes": [
        "Renamed 34 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_039",
      "transformed_id": "ss_l2_short_nc_tc_039",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address w, uint256 r) external returns (bool);\n\n    function e(\n        address from,\n        address w,\n        uint256 r\n    ) external returns (bool);\n\n    function k(address q) external view returns (uint256);\n\n    function p(address n, uint256 r) external returns (bool);\n}\n\ninterface IWETH {\n    function m() external payable;\n\n    function l(uint256 r) external;\n\n    function k(address q) external view returns (uint256);\n}\n\ncontract CowSolver {\n    IWETH public immutable WETH;\n    address public immutable i;\n\n    constructor(address v, address h) {\n        WETH = IWETH(v);\n        i = h;\n    }\n\n    function a(\n        int256 d,\n        int256 f,\n        bytes calldata data\n    ) external payable {\n        (\n            uint256 u,\n            address s,\n            address o,\n            address j\n        ) = abi.t(data, (uint256, address, address, address));\n\n        uint256 g;\n        if (d > 0) {\n            g = uint256(d);\n        } else {\n            g = uint256(f);\n        }\n\n        if (o == address(WETH)) {\n            WETH.l(g);\n            payable(j).transfer(g);\n        } else {\n            IERC20(o).transfer(j, g);\n        }\n    }\n\n    function b(bytes calldata c) external {\n        require(msg.sender == i, \"Only settlement\");\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "uniswapV3SwapCallback": "a",
        "executeSettlement": "b",
        "settlementData": "c",
        "amount0Delta": "d",
        "transferFrom": "e",
        "amount1Delta": "f",
        "amountToPay": "g",
        "_settlement": "h",
        "settlement": "i",
        "recipient": "j",
        "balanceOf": "k",
        "withdraw": "l",
        "deposit": "m",
        "spender": "n",
        "tokenIn": "o",
        "approve": "p",
        "account": "q",
        "amount": "r",
        "solver": "s",
        "decode": "t",
        "price": "u",
        "_weth": "v",
        "to": "w"
      },
      "changes": [
        "Renamed 23 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_040",
      "transformed_id": "ss_l2_short_nc_tc_040",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ad, uint256 v) external returns (bool);\n\n    function g(\n        address from,\n        address ad,\n        uint256 v\n    ) external returns (bool);\n\n    function k(address u) external view returns (uint256);\n\n    function t(address q, uint256 v) external returns (bool);\n}\n\ninterface IUniswapV3Router {\n    struct ExactInputSingleParams {\n        address r;\n        address m;\n        uint24 ac;\n        address i;\n        uint256 n;\n        uint256 o;\n        uint256 d;\n        uint160 c;\n    }\n\n    function e(\n        ExactInputSingleParams calldata y\n    ) external payable returns (uint256 l);\n}\n\ncontract BedrockVault {\n    IERC20 public immutable w;\n    IERC20 public immutable WBTC;\n    IUniswapV3Router public immutable x;\n\n    uint256 public b;\n    uint256 public a;\n\n    constructor(address s, address aa, address p) {\n        w = IERC20(s);\n        WBTC = IERC20(aa);\n        x = IUniswapV3Router(p);\n    }\n\n    function ab() external payable {\n        require(msg.value > 0, \"No ETH sent\");\n\n        uint256 h = msg.value;\n\n        b += msg.value;\n        a += h;\n\n        w.transfer(msg.sender, h);\n    }\n\n    function z(uint256 v) external {\n        require(v > 0, \"No amount specified\");\n        require(w.k(msg.sender) >= v, \"Insufficient balance\");\n\n        w.g(msg.sender, address(this), v);\n\n        uint256 j = v;\n        require(address(this).balance >= j, \"Insufficient ETH\");\n\n        payable(msg.sender).transfer(j);\n    }\n\n    function f() external pure returns (uint256) {\n        return 1e18;\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "totalUniBTCMinted": "a",
        "totalETHDeposited": "b",
        "sqrtPriceLimitX96": "c",
        "amountOutMinimum": "d",
        "exactInputSingle": "e",
        "getExchangeRate": "f",
        "transferFrom": "g",
        "uniBTCAmount": "h",
        "recipient": "i",
        "ethAmount": "j",
        "balanceOf": "k",
        "amountOut": "l",
        "tokenOut": "m",
        "deadline": "n",
        "amountIn": "o",
        "_router": "p",
        "spender": "q",
        "tokenIn": "r",
        "_uniBTC": "s",
        "approve": "t",
        "account": "u",
        "amount": "v",
        "uniBTC": "w",
        "router": "x",
        "params": "y",
        "redeem": "z",
        "_wbtc": "aa",
        "mint": "ab",
        "fee": "ac",
        "to": "ad"
      },
      "changes": [
        "Renamed 30 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_041",
      "transformed_id": "ss_l2_short_nc_tc_041",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address z, uint256 v) external returns (bool);\n\n    function g(\n        address from,\n        address z,\n        uint256 v\n    ) external returns (bool);\n\n    function j(address s) external view returns (uint256);\n\n    function r(address q, uint256 v) external returns (bool);\n}\n\ncontract ShezmuCollateralToken is IERC20 {\n    string public x = \"Shezmu Collateral Token\";\n    string public t = \"SCT\";\n    uint8 public n = 18;\n\n    mapping(address => uint256) public j;\n    mapping(address => mapping(address => uint256)) public l;\n    uint256 public h;\n\n    function y(address z, uint256 v) external {\n        j[z] += v;\n        h += v;\n    }\n\n    function transfer(\n        address z,\n        uint256 v\n    ) external override returns (bool) {\n        require(j[msg.sender] >= v, \"Insufficient balance\");\n        j[msg.sender] -= v;\n        j[z] += v;\n        return true;\n    }\n\n    function g(\n        address from,\n        address z,\n        uint256 v\n    ) external override returns (bool) {\n        require(j[from] >= v, \"Insufficient balance\");\n        require(\n            l[from][msg.sender] >= v,\n            \"Insufficient allowance\"\n        );\n        j[from] -= v;\n        j[z] += v;\n        l[from][msg.sender] -= v;\n        return true;\n    }\n\n    function r(\n        address q,\n        uint256 v\n    ) external override returns (bool) {\n        l[msg.sender][q] = v;\n        return true;\n    }\n}\n\ncontract ShezmuVault {\n    IERC20 public e;\n    IERC20 public p;\n\n    mapping(address => uint256) public c;\n    mapping(address => uint256) public i;\n\n    uint256 public constant COLLATERAL_RATIO = 150;\n    uint256 public constant BASIS_POINTS = 100;\n\n    constructor(address d, address m) {\n        e = IERC20(d);\n        p = IERC20(m);\n    }\n\n    function f(uint256 v) external {\n        e.g(msg.sender, address(this), v);\n        c[msg.sender] += v;\n    }\n\n    function u(uint256 v) external {\n        uint256 k = (c[msg.sender] * BASIS_POINTS) /\n            COLLATERAL_RATIO;\n\n        require(\n            i[msg.sender] + v <= k,\n            \"Insufficient collateral\"\n        );\n\n        i[msg.sender] += v;\n\n        p.transfer(msg.sender, v);\n    }\n\n    function w(uint256 v) external {\n        require(i[msg.sender] >= v, \"Excessive repayment\");\n        p.g(msg.sender, address(this), v);\n        i[msg.sender] -= v;\n    }\n\n    function b(uint256 v) external {\n        require(\n            c[msg.sender] >= v,\n            \"Insufficient collateral\"\n        );\n        uint256 a = c[msg.sender] - v;\n        uint256 o = (a * BASIS_POINTS) /\n            COLLATERAL_RATIO;\n        require(\n            i[msg.sender] <= o,\n            \"Would be undercollateralized\"\n        );\n\n        c[msg.sender] -= v;\n        e.transfer(msg.sender, v);\n    }\n}",
      "rename_map": {
        "remainingCollateral": "a",
        "withdrawCollateral": "b",
        "collateralBalance": "c",
        "_collateralToken": "d",
        "collateralToken": "e",
        "addCollateral": "f",
        "transferFrom": "g",
        "totalSupply": "h",
        "debtBalance": "i",
        "balanceOf": "j",
        "maxBorrow": "k",
        "allowance": "l",
        "_shezUSD": "m",
        "decimals": "n",
        "maxDebt": "o",
        "shezUSD": "p",
        "spender": "q",
        "approve": "r",
        "account": "s",
        "symbol": "t",
        "borrow": "u",
        "amount": "v",
        "repay": "w",
        "name": "x",
        "mint": "y",
        "to": "z"
      },
      "changes": [
        "Renamed 26 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_042",
      "transformed_id": "ss_l2_short_nc_tc_042",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ab, uint256 s) external returns (bool);\n\n    function d(\n        address from,\n        address ab,\n        uint256 s\n    ) external returns (bool);\n\n    function j(address r) external view returns (uint256);\n\n    function n(address p, uint256 s) external returns (bool);\n}\n\nenum TokenLockup {\n    Unlocked,\n    Locked,\n    Vesting\n}\n\nstruct Campaign {\n    address q;\n    address u;\n    uint256 s;\n    uint256 z;\n    TokenLockup e;\n    bytes32 y;\n}\n\nstruct ClaimLockup {\n    address g;\n    uint256 v;\n    uint256 w;\n    uint256 t;\n    uint256 m;\n}\n\nstruct Donation {\n    address g;\n    uint256 s;\n    uint256 x;\n    uint256 v;\n    uint256 w;\n    uint256 t;\n}\n\ncontract HedgeyClaimCampaigns {\n    mapping(bytes16 => Campaign) public i;\n\n    function a(\n        bytes16 aa,\n        Campaign memory l,\n        ClaimLockup memory f,\n        Donation memory k\n    ) external {\n        require(i[aa].q == address(0), \"Campaign exists\");\n\n        i[aa] = l;\n\n        if (k.s > 0 && k.g != address(0)) {\n            (bool o, ) = k.g.call(\n                abi.b(\n                    \"createTokenLock(address,uint256,uint256,uint256,uint256,uint256)\",\n                    l.u,\n                    k.s,\n                    k.v,\n                    k.w,\n                    k.x,\n                    k.t\n                )\n            );\n\n            require(o, \"Token lock failed\");\n        }\n    }\n\n    function c(bytes16 h) external {\n        require(i[h].q == msg.sender, \"Not manager\");\n        delete i[h];\n    }\n}",
      "rename_map": {
        "createLockedCampaign": "a",
        "encodeWithSignature": "b",
        "cancelCampaign": "c",
        "transferFrom": "d",
        "tokenLockup": "e",
        "claimLockup": "f",
        "tokenLocker": "g",
        "campaignId": "h",
        "campaigns": "i",
        "balanceOf": "j",
        "donation": "k",
        "campaign": "l",
        "periods": "m",
        "approve": "n",
        "success": "o",
        "spender": "p",
        "manager": "q",
        "account": "r",
        "amount": "s",
        "period": "t",
        "token": "u",
        "start": "v",
        "cliff": "w",
        "rate": "x",
        "root": "y",
        "end": "z",
        "id": "aa",
        "to": "ab"
      },
      "changes": [
        "Renamed 28 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_043",
      "transformed_id": "ss_l2_short_nc_tc_043",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address q, uint256 k) external returns (bool);\n\n    function b(\n        address from,\n        address q,\n        uint256 k\n    ) external returns (bool);\n\n    function d(address i) external view returns (uint256);\n\n    function h(address f, uint256 k) external returns (bool);\n}\n\ncontract SenecaChamber {\n    uint8 public constant OPERATION_CALL = 30;\n    uint8 public constant OPERATION_DELEGATECALL = 31;\n\n    mapping(address => bool) public c;\n\n    function a(\n        uint8[] memory g,\n        uint256[] memory o,\n        bytes[] memory p\n    ) external payable returns (uint256 j, uint256 m) {\n        require(\n            g.length == o.length && o.length == p.length,\n            \"Length mismatch\"\n        );\n\n        for (uint256 i = 0; i < g.length; i++) {\n            if (g[i] == OPERATION_CALL) {\n                (address l, bytes memory callData, , , ) = abi.n(\n                    p[i],\n                    (address, bytes, uint256, uint256, uint256)\n                );\n\n                (bool e, ) = l.call{value: o[i]}(callData);\n                require(e, \"Call failed\");\n            }\n        }\n\n        return (0, 0);\n    }\n}",
      "rename_map": {
        "performOperations": "a",
        "transferFrom": "b",
        "vaultOwners": "c",
        "balanceOf": "d",
        "success": "e",
        "spender": "f",
        "actions": "g",
        "approve": "h",
        "account": "i",
        "value1": "j",
        "amount": "k",
        "target": "l",
        "value2": "m",
        "decode": "n",
        "values": "o",
        "datas": "p",
        "to": "q"
      },
      "changes": [
        "Renamed 17 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_044",
      "transformed_id": "ss_l2_short_nc_tc_044",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address y, uint256 s) external returns (bool);\n\n    function e(\n        address from,\n        address y,\n        uint256 s\n    ) external returns (bool);\n\n    function k(address r) external view returns (uint256);\n\n    function q(address p, uint256 s) external returns (bool);\n}\n\ninterface ISmartLoan {\n    function c(\n        bytes32 i,\n        bytes32 n,\n        uint256 f,\n        uint256 d,\n        bytes4 selector,\n        bytes memory data\n    ) external;\n\n    function g(address v, uint256[] calldata x) external;\n}\n\ncontract SmartLoansFactory {\n    address public u;\n\n    constructor() {\n        u = msg.sender;\n    }\n\n    function j() external returns (address) {\n        SmartLoan w = new SmartLoan();\n        return address(w);\n    }\n\n    function h(\n        address l,\n        address b\n    ) external {\n        require(msg.sender == u, \"Not admin\");\n    }\n}\n\ncontract SmartLoan is ISmartLoan {\n    mapping(bytes32 => uint256) public m;\n    mapping(bytes32 => uint256) public t;\n\n    function c(\n        bytes32 i,\n        bytes32 n,\n        uint256 f,\n        uint256 d,\n        bytes4 selector,\n        bytes memory data\n    ) external override {}\n\n    function g(\n        address v,\n        uint256[] calldata x\n    ) external override {\n        (bool o, ) = v.call(\n            abi.a(\"claimRewards(address)\", msg.sender)\n        );\n    }\n}",
      "rename_map": {
        "encodeWithSignature": "a",
        "newImplementation": "b",
        "swapDebtParaSwap": "c",
        "_borrowAmount": "d",
        "transferFrom": "e",
        "_repayAmount": "f",
        "claimReward": "g",
        "upgradePool": "h",
        "_fromAsset": "i",
        "createLoan": "j",
        "balanceOf": "k",
        "poolProxy": "l",
        "deposits": "m",
        "_toAsset": "n",
        "success": "o",
        "spender": "p",
        "approve": "q",
        "account": "r",
        "amount": "s",
        "debts": "t",
        "admin": "u",
        "pair": "v",
        "loan": "w",
        "ids": "x",
        "to": "y"
      },
      "changes": [
        "Renamed 25 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_045",
      "transformed_id": "ss_l2_short_nc_tc_045",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address s, uint256 p) external returns (bool);\n\n    function f(\n        address from,\n        address s,\n        uint256 p\n    ) external returns (bool);\n\n    function i(address o) external view returns (uint256);\n\n    function n(address m, uint256 p) external returns (bool);\n}\n\ninterface IPendleMarket {\n    function c() external view returns (address[] memory);\n\n    function a() external returns (uint256[] memory);\n\n    function g(address r) external returns (uint256[] memory);\n}\n\ncontract PenpieStaking {\n    mapping(address => mapping(address => uint256)) public e;\n    mapping(address => uint256) public h;\n\n    function l(address q, uint256 p) external {\n        IERC20(q).f(msg.sender, address(this), p);\n        e[q][msg.sender] += p;\n        h[q] += p;\n    }\n\n    function g(address q, address r) external {\n        uint256[] memory k = IPendleMarket(q).g(r);\n\n        for (uint256 i = 0; i < k.length; i++) {}\n    }\n\n    function j(address q, uint256 p) external {\n        require(\n            e[q][msg.sender] >= p,\n            \"Insufficient balance\"\n        );\n\n        e[q][msg.sender] -= p;\n        h[q] -= p;\n\n        IERC20(q).transfer(msg.sender, p);\n    }\n}\n\ncontract PendleMarketRegister {\n    mapping(address => bool) public b;\n\n    function d(address q) external {\n        b[q] = true;\n    }\n}",
      "rename_map": {
        "rewardIndexesCurrent": "a",
        "registeredMarkets": "b",
        "getRewardTokens": "c",
        "registerMarket": "d",
        "userBalances": "e",
        "transferFrom": "f",
        "claimRewards": "g",
        "totalStaked": "h",
        "balanceOf": "i",
        "withdraw": "j",
        "rewards": "k",
        "deposit": "l",
        "spender": "m",
        "approve": "n",
        "account": "o",
        "amount": "p",
        "market": "q",
        "user": "r",
        "to": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_046",
      "transformed_id": "ss_l2_short_nc_tc_046",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address l, uint256 i) external returns (bool);\n\n    function e(address h) external view returns (uint256);\n}\n\ncontract FloatHotWalletV2 {\n    address public k;\n\n    mapping(address => bool) public a;\n\n    event Withdrawal(address j, address l, uint256 i);\n\n    constructor() {\n        k = msg.sender;\n    }\n\n    modifier d() {\n        require(msg.sender == k, \"Not owner\");\n        _;\n    }\n\n    function f(\n        address j,\n        address l,\n        uint256 i\n    ) external d {\n        if (j == address(0)) {\n            payable(l).transfer(i);\n        } else {\n            IERC20(j).transfer(l, i);\n        }\n\n        emit Withdrawal(j, l, i);\n    }\n\n    function c(address j) external d {\n        uint256 balance;\n        if (j == address(0)) {\n            balance = address(this).balance;\n            payable(k).transfer(balance);\n        } else {\n            balance = IERC20(j).e(address(this));\n            IERC20(j).transfer(k, balance);\n        }\n\n        emit Withdrawal(j, k, balance);\n    }\n\n    function b(address g) external d {\n        k = g;\n    }\n\n    receive() external payable {}\n}",
      "rename_map": {
        "authorizedOperators": "a",
        "transferOwnership": "b",
        "emergencyWithdraw": "c",
        "onlyOwner": "d",
        "balanceOf": "e",
        "withdraw": "f",
        "newOwner": "g",
        "account": "h",
        "amount": "i",
        "token": "j",
        "owner": "k",
        "to": "l"
      },
      "changes": [
        "Renamed 12 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_047",
      "transformed_id": "ss_l2_short_nc_tc_047",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address s, uint256 m) external returns (bool);\n\n    function e(address k) external view returns (uint256);\n}\n\ncontract PlayDappToken {\n    string public q = \"PlayDapp Token\";\n    string public l = \"PLA\";\n    uint8 public h = 18;\n\n    uint256 public b;\n\n    address public n;\n\n    mapping(address => uint256) public e;\n    mapping(address => mapping(address => uint256)) public f;\n\n    event Transfer(address indexed from, address indexed s, uint256 value);\n    event Approval(\n        address indexed o,\n        address indexed i,\n        uint256 value\n    );\n    event Minted(address indexed s, uint256 m);\n\n    constructor() {\n        n = msg.sender;\n        p(msg.sender, 700_000_000 * 10 ** 18);\n    }\n\n    modifier c() {\n        require(msg.sender == n, \"Not minter\");\n        _;\n    }\n\n    function r(address s, uint256 m) external c {\n        p(s, m);\n        emit Minted(s, m);\n    }\n\n    function p(address s, uint256 m) internal {\n        require(s != address(0), \"Mint to zero address\");\n\n        b += m;\n        e[s] += m;\n\n        emit Transfer(address(0), s, m);\n    }\n\n    function g(address d) external c {\n        n = d;\n    }\n\n    function transfer(address s, uint256 m) external returns (bool) {\n        require(e[msg.sender] >= m, \"Insufficient balance\");\n        e[msg.sender] -= m;\n        e[s] += m;\n        emit Transfer(msg.sender, s, m);\n        return true;\n    }\n\n    function j(address i, uint256 m) external returns (bool) {\n        f[msg.sender][i] = m;\n        emit Approval(msg.sender, i, m);\n        return true;\n    }\n\n    function a(\n        address from,\n        address s,\n        uint256 m\n    ) external returns (bool) {\n        require(e[from] >= m, \"Insufficient balance\");\n        require(\n            f[from][msg.sender] >= m,\n            \"Insufficient allowance\"\n        );\n\n        e[from] -= m;\n        e[s] += m;\n        f[from][msg.sender] -= m;\n\n        emit Transfer(from, s, m);\n        return true;\n    }\n}",
      "rename_map": {
        "transferFrom": "a",
        "totalSupply": "b",
        "onlyMinter": "c",
        "newMinter": "d",
        "balanceOf": "e",
        "allowance": "f",
        "setMinter": "g",
        "decimals": "h",
        "spender": "i",
        "approve": "j",
        "account": "k",
        "symbol": "l",
        "amount": "m",
        "minter": "n",
        "owner": "o",
        "_mint": "p",
        "name": "q",
        "mint": "r",
        "to": "s"
      },
      "changes": [
        "Renamed 19 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_048",
      "transformed_id": "ss_l2_short_nc_tc_048",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address z, uint256 t) external returns (bool);\n\n    function f(\n        address from,\n        address z,\n        uint256 t\n    ) external returns (bool);\n\n    function o(address r) external view returns (uint256);\n}\n\ncontract SonneMarket {\n    IERC20 public l;\n\n    string public w = \"Sonne WETH\";\n    string public s = \"soWETH\";\n    uint8 public q = 8;\n\n    uint256 public j;\n    mapping(address => uint256) public o;\n\n    uint256 public g;\n    uint256 public d;\n\n    event Mint(address v, uint256 n, uint256 m);\n    event Redeem(address p, uint256 i, uint256 e);\n\n    constructor(address k) {\n        l = IERC20(k);\n    }\n\n    function h() public view returns (uint256) {\n        if (j == 0) {\n            return 1e18;\n        }\n\n        uint256 x = l.o(address(this));\n\n        uint256 c = x + g - d;\n\n        return (c * 1e18) / j;\n    }\n\n    function y(uint256 n) external returns (uint256) {\n        require(n > 0, \"Zero mint\");\n\n        uint256 a = h();\n\n        uint256 m = (n * 1e18) / a;\n\n        j += m;\n        o[msg.sender] += m;\n\n        l.f(msg.sender, address(this), n);\n\n        emit Mint(msg.sender, n, m);\n        return m;\n    }\n\n    function u(uint256 e) external returns (uint256) {\n        require(o[msg.sender] >= e, \"Insufficient balance\");\n\n        uint256 a = h();\n\n        uint256 i = (e * a) / 1e18;\n\n        o[msg.sender] -= e;\n        j -= e;\n\n        l.transfer(msg.sender, i);\n\n        emit Redeem(msg.sender, i, e);\n        return i;\n    }\n\n    function b(\n        address r\n    ) external view returns (uint256) {\n        uint256 a = h();\n\n        return (o[r] * a) / 1e18;\n    }\n}",
      "rename_map": {
        "exchangeRateMantissa": "a",
        "balanceOfUnderlying": "b",
        "totalUnderlying": "c",
        "totalReserves": "d",
        "redeemTokens": "e",
        "transferFrom": "f",
        "totalBorrows": "g",
        "exchangeRate": "h",
        "redeemAmount": "i",
        "totalSupply": "j",
        "_underlying": "k",
        "underlying": "l",
        "mintTokens": "m",
        "mintAmount": "n",
        "balanceOf": "o",
        "redeemer": "p",
        "decimals": "q",
        "account": "r",
        "symbol": "s",
        "amount": "t",
        "redeem": "u",
        "minter": "v",
        "name": "w",
        "cash": "x",
        "mint": "y",
        "to": "z"
      },
      "changes": [
        "Renamed 26 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_049",
      "transformed_id": "ss_l2_short_nc_tc_049",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ae, uint256 y) external returns (bool);\n\n    function f(\n        address from,\n        address ae,\n        uint256 y\n    ) external returns (bool);\n\n    function o(address w) external view returns (uint256);\n}\n\ninterface IMarket {\n    function b(\n        address w\n    )\n        external\n        view\n        returns (uint256 j, uint256 v, uint256 h);\n}\n\ncontract DebtPreviewer {\n    function i(\n        address z,\n        address w\n    )\n        external\n        view\n        returns (\n            uint256 d,\n            uint256 n,\n            uint256 g\n        )\n    {\n        (uint256 j, uint256 v, uint256 h) = IMarket(\n            z\n        ).b(w);\n\n        d = (j * h) / 1e18;\n        n = v;\n\n        if (n == 0) {\n            g = type(uint256).ad;\n        } else {\n            g = (d * 1e18) / n;\n        }\n\n        return (d, n, g);\n    }\n\n    function a(\n        address[] calldata t,\n        address w\n    )\n        external\n        view\n        returns (\n            uint256 c,\n            uint256 l,\n            uint256 e\n        )\n    {\n        for (uint256 i = 0; i < t.length; i++) {\n            (uint256 j, uint256 ac, ) = this.i(\n                t[i],\n                w\n            );\n\n            c += j;\n            l += ac;\n        }\n\n        if (l == 0) {\n            e = type(uint256).ad;\n        } else {\n            e = (c * 1e18) / l;\n        }\n\n        return (c, l, e);\n    }\n}\n\ncontract ExactlyMarket {\n    IERC20 public ab;\n    DebtPreviewer public m;\n\n    mapping(address => uint256) public q;\n    mapping(address => uint256) public v;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(address aa, address k) {\n        ab = IERC20(aa);\n        m = DebtPreviewer(k);\n    }\n\n    function s(uint256 y) external {\n        ab.f(msg.sender, address(this), y);\n        q[msg.sender] += y;\n    }\n\n    function x(uint256 y, address[] calldata t) external {\n        (uint256 c, uint256 l, ) = m\n            .a(t, msg.sender);\n\n        uint256 u = l + y;\n\n        uint256 p = (c * COLLATERAL_FACTOR) / 100;\n        require(u <= p, \"Insufficient collateral\");\n\n        v[msg.sender] += y;\n        ab.transfer(msg.sender, y);\n    }\n\n    function b(\n        address w\n    )\n        external\n        view\n        returns (uint256 j, uint256 r, uint256 h)\n    {\n        return (q[w], v[w], 1e18);\n    }\n}",
      "rename_map": {
        "previewMultipleMarkets": "a",
        "getAccountSnapshot": "b",
        "totalCollateral": "c",
        "collateralValue": "d",
        "overallHealth": "e",
        "transferFrom": "f",
        "healthFactor": "g",
        "exchangeRate": "h",
        "previewDebt": "i",
        "collateral": "j",
        "_previewer": "k",
        "totalDebt": "l",
        "previewer": "m",
        "debtValue": "n",
        "balanceOf": "o",
        "maxBorrow": "p",
        "deposits": "q",
        "borrowed": "r",
        "deposit": "s",
        "markets": "t",
        "newDebt": "u",
        "borrows": "v",
        "account": "w",
        "borrow": "x",
        "amount": "y",
        "market": "z",
        "_asset": "aa",
        "asset": "ab",
        "debt": "ac",
        "max": "ad",
        "to": "ae"
      },
      "changes": [
        "Renamed 31 identifiers using short style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "nc_tc_050",
      "transformed_id": "ss_l2_short_nc_tc_050",
      "level": "l2",
      "variant": "short",
      "source": "nocomments",
      "success": true,
      "code": "pragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address ae, uint256 y) external returns (bool);\n\n    function k(\n        address from,\n        address ae,\n        uint256 y\n    ) external returns (bool);\n\n    function s(address w) external view returns (uint256);\n}\n\ncontract MunchablesLockManager {\n    address public aa;\n    address public j;\n\n    struct PlayerSettings {\n        uint256 n;\n        address g;\n        uint256 m;\n        uint256 h;\n    }\n\n    mapping(address => PlayerSettings) public e;\n    mapping(address => uint256) public d;\n\n    IERC20 public immutable ac;\n\n    event Locked(address z, uint256 y, address q);\n    event ConfigUpdated(address p, address o);\n\n    constructor(address ab) {\n        aa = msg.sender;\n        ac = IERC20(ab);\n    }\n\n    modifier r() {\n        require(msg.sender == aa, \"Not admin\");\n        _;\n    }\n\n    function ad(uint256 y, uint256 t) external {\n        require(y > 0, \"Zero amount\");\n\n        ac.k(msg.sender, address(this), y);\n\n        d[msg.sender] += y;\n        e[msg.sender] = PlayerSettings({\n            n: y,\n            g: msg.sender,\n            m: t,\n            h: block.timestamp\n        });\n\n        emit Locked(msg.sender, y, msg.sender);\n    }\n\n    function b(address f) external r {\n        address p = j;\n        j = f;\n\n        emit ConfigUpdated(p, f);\n    }\n\n    function a(\n        address z,\n        address l\n    ) external r {\n        e[z].g = l;\n    }\n\n    function x() external {\n        PlayerSettings memory u = e[msg.sender];\n\n        require(u.n > 0, \"No locked tokens\");\n        require(\n            block.timestamp >= u.h + u.m,\n            \"Still locked\"\n        );\n\n        uint256 y = u.n;\n\n        address q = u.g;\n\n        delete e[msg.sender];\n        d[msg.sender] = 0;\n\n        ac.transfer(q, y);\n    }\n\n    function c(address z) external r {\n        PlayerSettings memory u = e[z];\n        uint256 y = u.n;\n        address q = u.g;\n\n        delete e[z];\n        d[z] = 0;\n\n        ac.transfer(q, y);\n    }\n\n    function i(address v) external r {\n        aa = v;\n    }\n}",
      "rename_map": {
        "setLockRecipient": "a",
        "setConfigStorage": "b",
        "emergencyUnlock": "c",
        "playerBalances": "d",
        "playerSettings": "e",
        "_configStorage": "f",
        "lockRecipient": "g",
        "lockStartTime": "h",
        "transferAdmin": "i",
        "configStorage": "j",
        "transferFrom": "k",
        "newRecipient": "l",
        "lockDuration": "m",
        "lockedAmount": "n",
        "newConfig": "o",
        "oldConfig": "p",
        "recipient": "q",
        "onlyAdmin": "r",
        "balanceOf": "s",
        "duration": "t",
        "settings": "u",
        "newAdmin": "v",
        "account": "w",
        "unlock": "x",
        "amount": "y",
        "player": "z",
        "admin": "aa",
        "_weth": "ab",
        "weth": "ac",
        "lock": "ad",
        "to": "ae"
      },
      "changes": [
        "Renamed 31 identifiers using short style"
      ],
      "stats": {},
      "error": null
    }
  ]
}