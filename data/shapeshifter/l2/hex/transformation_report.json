{
  "timestamp": "2025-12-17T13:25:34.513627",
  "level": "l2",
  "variant": "hex",
  "source": "sanitized",
  "total_files": 252,
  "successful": 251,
  "failed": 1,
  "results": [
    {
      "original_id": "sn_ds_001",
      "transformed_id": "ss_l2_hex_sn_ds_001",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "contract _0xb4f7cb {\n        uint private Balance = 0;\n        uint private Payout_id = 0;\n        uint private Last_Payout = 0;\n        uint private WinningPot = 0;\n        uint private Min_multiplier = 1100; //110%\n\n        //Fees are necessary and set very low, to maintain the website. The fees will decrease each time they are collected.\n        //Fees are just here to maintain the website at beginning, and will progressively go to 0% :)\n        uint private _0x955492 = 0;\n        uint private _0x4d2334 = 20; //Fraction for fees in per\"thousand\", not percent, so 20 is 2%\n\n        uint private PotFrac = 30; //For the WinningPot ,30=> 3% are collected. This is fixed.\n\n        address private _0x2f5d14;\n\n        function _0xb4f7cb() {\n            _0x2f5d14 = msg.sender;\n        }\n\n        modifier _0xf885f7 {if (msg.sender == _0x2f5d14) _;  }\n\n        struct Player {\n            address _0xd8f439;\n            uint _0xdc1d5a;\n            bool _0xa0ff0c;\n        }\n\n        Player[] private _0xf2ddca;\n\n        //--Fallback function\n        function() {\n            _0x2c72ee();\n        }\n\n        //--initiated function\n        function _0x2c72ee() private {\n            uint _0x159834=msg.value;\n            if (msg.value < 500 finney) { //only participation with >1 ether accepted\n                    msg.sender.send(msg.value);\n                    return;\n            }\n            if (msg.value > 20 ether) { //only participation with <20 ether accepted\n                    msg.sender.send(msg.value- (20 ether));\n                    _0x159834=20 ether;\n            }\n            Participate(_0x159834);\n        }\n\n        //------- Core of the game----------\n        function Participate(uint _0x159834) private {\n                //calculate the multiplier to apply to the future payout\n\n                uint _0x3d392f=Min_multiplier; //initiate total_multiplier\n                if(Balance < 1 ether && _0xf2ddca.length>1){\n                    _0x3d392f+=100; // + 10 %\n                }\n                if( (_0xf2ddca.length % 10)==0 && _0xf2ddca.length>1 ){ //Every 10th participant gets a 10% bonus, play smart !\n                    _0x3d392f+=100; // + 10 %\n                }\n\n                //add new player in the queue !\n                _0xf2ddca.push(Player(msg.sender, (_0x159834 * _0x3d392f) / 1000, false));\n\n                //--- UPDATING CONTRACT STATS ----\n                WinningPot += (_0x159834 * PotFrac) / 1000; // take some 3% to add for the winning pot !\n                _0x955492 += (_0x159834 * _0x4d2334) / 1000; // collect maintenance fees 2%\n                Balance += (_0x159834 * (1000 - ( _0x4d2334 + PotFrac ))) / 1000; // update balance\n\n                // Winning the Pot :) Condition : paying at least 1 people with deposit > 2 ether and having luck !\n                if(  ( _0x159834 > 1 ether ) && (_0x159834 > _0xf2ddca[Payout_id]._0xdc1d5a) ){\n                    uint _0x5c25bf = _0x5b8ae8(100); //take a random number between 1 & 100\n                    if( _0x5c25bf % 10 == 0 ){ //if lucky : Chances : 1 out of 10 !\n                        msg.sender.send(WinningPot); // Bravo !\n                        WinningPot=0;\n                    }\n\n                }\n\n                //Classic payout for the participants\n                while ( Balance > _0xf2ddca[Payout_id]._0xdc1d5a ) {\n                    Last_Payout = _0xf2ddca[Payout_id]._0xdc1d5a;\n                    _0xf2ddca[Payout_id]._0xd8f439.send(Last_Payout); //pay the man, please !\n                    Balance -= _0xf2ddca[Payout_id]._0xdc1d5a; //update the balance\n                    _0xf2ddca[Payout_id]._0xa0ff0c=true;\n\n                    Payout_id += 1;\n                }\n        }\n\n    uint256 constant private _0xaee039 =  block.timestamp;\n\n    function _0x5b8ae8(uint Max) constant private returns (uint256 _0x03de42){\n        //get the best seed for randomness\n        uint256 x = _0xaee039 * 100 / Max;\n        uint256 y = _0xaee039 * block.number / (_0xaee039 % 5) ;\n        uint256 _0xb6853d = block.number/3 + (_0xaee039 % 300) + Last_Payout +y;\n        uint256 h = uint256(block.blockhash(_0xb6853d));\n\n        return uint256((h / x)) % Max + 1; //random number between 1 and Max\n    }\n\n    //---Contract management functions\n    function ChangeOwnership(address _0x657968) _0xf885f7 {\n        _0x2f5d14 = _0x657968;\n    }\n    function WatchBalance() constant returns(uint TotalBalance) {\n        TotalBalance = Balance /  1 wei;\n    }\n\n    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\n        TotalBalanceInEther = Balance /  1 ether;\n    }\n\n    //Fee functions for creator\n    function CollectAllFees() _0xf885f7 {\n        if (_0x955492 == 0) throw;\n        _0x2f5d14.send(_0x955492);\n        _0x4d2334-=1;\n        _0x955492 = 0;\n    }\n\n    function GetAndReduceFeesByFraction(uint p) _0xf885f7 {\n        if (_0x955492 == 0) _0x4d2334-=1; //Reduce fees.\n        _0x2f5d14.send(_0x955492 / 1000 * p);//send a percent of fees\n        _0x955492 -= _0x955492 / 1000 * p;\n    }\n\n//---Contract informations\nfunction NextPayout() constant returns(uint NextPayout) {\n    NextPayout = _0xf2ddca[Payout_id]._0xdc1d5a /  1 wei;\n}\n\nfunction WatchFees() constant returns(uint CollectedFees) {\n    CollectedFees = _0x955492 / 1 wei;\n}\n\nfunction WatchWinningPot() constant returns(uint WinningPot) {\n    WinningPot = WinningPot / 1 wei;\n}\n\nfunction WatchLastPayout() constant returns(uint _0xdc1d5a) {\n    _0xdc1d5a = Last_Payout;\n}\n\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\n    NumberOfPlayers = _0xf2ddca.length;\n}\n\nfunction PlayerInfo(uint _0xe3de25) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (_0xe3de25 <= _0xf2ddca.length) {\n        Address = _0xf2ddca[_0xe3de25]._0xd8f439;\n        Payout = _0xf2ddca[_0xe3de25]._0xdc1d5a / 1 wei;\n        UserPaid=_0xf2ddca[_0xe3de25]._0xa0ff0c;\n    }\n}\n\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\n    QueueSize = _0xf2ddca.length - Payout_id;\n}\n\n}",
      "rename_map": {
        "total_multiplier": "_0x3d392f",
        "onlyowner": "_0xf885f7",
        "players": "_0xf2ddca",
        "feeFrac": "_0x4d2334",
        "deposit": "_0x159834",
        "random": "_0x5b8ae8",
        "_owner": "_0x657968",
        "result": "_0x03de42",
        "payout": "_0xdc1d5a",
        "theRun": "_0xb4f7cb",
        "admin": "_0x2f5d14",
        "init": "_0x2c72ee",
        "roll": "_0x5c25bf",
        "fees": "_0x955492",
        "addr": "_0xd8f439",
        "salt": "_0xaee039",
        "seed": "_0xb6853d",
        "paid": "_0xa0ff0c",
        "id": "_0xe3de25"
      },
      "changes": [
        "Renamed 19 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_002",
      "transformed_id": "ss_l2_hex_sn_ds_002",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract TokenVault {\n    mapping (address => uint) _0xd773c9;\n\n    function _0xcbf19e(address u) constant returns(uint){\n        return _0xd773c9[u];\n    }\n\n    function _0xb285f4() payable{\n        _0xd773c9[msg.sender] += msg.value;\n    }\n\n    function _0x61d486(){\n        // send userBalance[msg.sender] ethers to msg.sender\n        // if mgs.sender is a contract, it will call its fallback function\n        if( ! (msg.sender.call.value(_0xd773c9[msg.sender])() ) ){\n            throw;\n        }\n        _0xd773c9[msg.sender] = 0;\n    }\n\n    function _0xc44e5e(){\n\n        // has to be change before the call\n        uint _0x587ad2 = _0xd773c9[msg.sender];\n        _0xd773c9[msg.sender] = 0;\n        if( ! (msg.sender.call.value(_0x587ad2)() ) ){\n            throw;\n        }\n    }\n\n    function _0x84eb2c(){\n\n        // they do not transfer the remaining gas\n        // and they give just enough gas to execute few instructions\n        // in the fallback function (no further call possible)\n        msg.sender.transfer(_0xd773c9[msg.sender]);\n        _0xd773c9[msg.sender] = 0;\n    }\n\n}",
      "rename_map": {
        "withdrawBalanceV2": "_0xc44e5e",
        "withdrawBalanceV3": "_0x84eb2c",
        "withdrawBalance": "_0x61d486",
        "addToBalance": "_0xb285f4",
        "userBalance": "_0xd773c9",
        "getBalance": "_0xcbf19e",
        "amount": "_0x587ad2"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_003",
      "transformed_id": "ss_l2_hex_sn_ds_003",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract VaultOperator {\n    bool public _0x65fb58=false;\n    address public _0x39c289;\n    address public _0x28780a;\n\n    function VaultOperator() public{\n        _0x28780a = msg.sender;\n    }\n\n    function _0xc84bda(address _0x6cff65) public payable{\n        _0x39c289 = _0x6cff65 ;\n        // call addToBalance with msg.value ethers\n        require(_0x39c289.call.value(msg.value)(bytes4(_0x8553c4(\"addToBalance()\"))));\n    }\n\n    function _0xa80653() public{\n        _0x65fb58 = true;\n        // call withdrawBalance\n\n        require(_0x39c289.call(bytes4(_0x8553c4(\"withdrawBalance()\"))));\n    }\n\n    function () public payable{\n\n        if (_0x65fb58){\n            _0x65fb58 = false;\n                require(_0x39c289.call(bytes4(_0x8553c4(\"withdrawBalance()\"))));\n        }\n    }\n\n    function _0x14e8c5(){\n        suicide(_0x28780a);\n    }\n\n}",
      "rename_map": {
        "_target_contract": "_0x6cff65",
        "target_contract": "_0x39c289",
        "operationActive": "_0x65fb58",
        "launch_handler": "_0xa80653",
        "get_money": "_0x14e8c5",
        "deposit": "_0xc84bda",
        "owner": "_0x28780a",
        "sha3": "_0x8553c4"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_004",
      "transformed_id": "ss_l2_hex_sn_ds_004",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Ledger {\n    uint private _0xb1f0c6=0;\n\n    function _0xf18b46(uint value) returns (bool){\n        _0xb1f0c6 += value;\n\n        // possible auditor assert\n        // assert(sellerBalance >= value);\n    }\n\n    function _0x1357e7(uint value) returns (bool){\n        require(value + _0xb1f0c6 >= _0xb1f0c6);\n        _0xb1f0c6 += value;\n    }\n}",
      "rename_map": {
        "sellerBalance": "_0xb1f0c6",
        "safe_add": "_0x1357e7",
        "add": "_0xf18b46"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_005",
      "transformed_id": "ss_l2_hex_sn_ds_005",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract OpenAccess{\n    address private _0x7fcd4b;\n\n    modifier _0x01f0ce {\n        require(msg.sender==_0x7fcd4b);\n        _;\n    }\n\n    function OpenAccess()\n        public\n    {\n        _0x7fcd4b = msg.sender;\n    }\n\n    // This function should be protected\n    function _0x0d7fd6(address _0x05acb2)\n        public\n    {\n       _0x7fcd4b = _0x05acb2;\n    }\n\n    function _0xe2ab04(address _0x05acb2)\n        public\n        _0x01f0ce\n    {\n       _0x7fcd4b = _0x05acb2;\n    }\n}",
      "rename_map": {
        "changeOwnerV2": "_0xe2ab04",
        "changeOwner": "_0x0d7fd6",
        "onlyowner": "_0x01f0ce",
        "_newOwner": "_0x05acb2",
        "owner": "_0x7fcd4b"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_006",
      "transformed_id": "ss_l2_hex_sn_ds_006",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Alice {\n    int public _0x129955;\n\n    function _0x3b0b41(int _0x621e84){\n        _0x129955 = _0x621e84;\n    }\n\n    function _0xb8ab52(int _0x621e84){\n        _0x129955 = _0x621e84;\n    }\n\n    function(){\n        _0x129955 = 1;\n    }\n}",
      "rename_map": {
        "new_val": "_0x621e84",
        "setV2": "_0xb8ab52",
        "val": "_0x129955",
        "set": "_0x3b0b41"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_007",
      "transformed_id": "ss_l2_hex_sn_ds_007",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.22;\n\ncontract FibonacciBalance {\n\n    address public fibonacciLibrary;\n    // the current fibonacci number to withdraw\n    uint public _0x251704;\n    // the starting fibonacci sequence number\n    uint public _0xa779a2 = 3;\n    uint public _0x9698ff;\n    // the fibonancci function selector\n    bytes4 constant _0xdf87ef = bytes4(_0x0a7360(\"setFibonacci(uint256)\"));\n\n    // constructor - loads the contract with ether\n    constructor(address _fibonacciLibrary) public payable {\n        fibonacciLibrary = _fibonacciLibrary;\n    }\n\n    function _0x5d516a() {\n        _0x9698ff += 1;\n        // calculate the fibonacci number for the current withdrawal user\n        // this sets calculatedFibNumber\n        require(fibonacciLibrary.delegatecall(_0xdf87ef, _0x9698ff));\n        msg.sender.transfer(_0x251704 * 1 ether);\n    }\n\n    // allow users to call fibonacci library functions\n    function() public {\n        require(fibonacciLibrary.delegatecall(msg.data));\n    }\n}\n\n// library contract - calculates fibonacci-like numbers;\ncontract FibonacciLib {\n    // initializing the standard fibonacci sequence;\n    uint public _0xa779a2;\n    uint public _0x251704;\n\n    // modify the zeroth number in the sequence\n    function _0x18804b(uint _0xe2a991) public {\n        _0xa779a2 = _0xe2a991;\n    }\n\n    function _0xc47bae(uint n) public {\n        _0x251704 = _0x2fda18(n);\n    }\n\n    function _0x2fda18(uint n) internal returns (uint) {\n        if (n == 0) return _0xa779a2;\n        else if (n == 1) return _0xa779a2 + 1;\n        else return _0x2fda18(n - 1) + _0x2fda18(n - 2);\n    }\n}\n",
      "rename_map": {
        "calculatedFibNumber": "_0x251704",
        "withdrawalCounter": "_0x9698ff",
        "setFibonacci": "_0xc47bae",
        "fibonacci": "_0x2fda18",
        "withdraw": "_0x5d516a",
        "setStart": "_0x18804b",
        "fibSig": "_0xdf87ef",
        "_start": "_0xe2a991",
        "start": "_0xa779a2",
        "sha3": "_0x0a7360"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_008",
      "transformed_id": "ss_l2_hex_sn_ds_008",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\n contract Wallet {\n     uint[] private _0xf0dca0;\n     address private _0x57e737;\n\n     constructor() public {\n         _0xf0dca0 = new uint[](0);\n         _0x57e737 = msg.sender;\n     }\n\n     function () public payable {\n     }\n\n     function PushBonusCode(uint c) public {\n         _0xf0dca0.push(c);\n     }\n\n     function PopBonusCode() public {\n         require(0 <= _0xf0dca0.length); // this condition is always true since array lengths are unsigned\n         _0xf0dca0.length--;\n     }\n\n     function UpdateBonusCodeAt(uint _0x33303a, uint c) public {\n         require(_0x33303a < _0xf0dca0.length);\n         _0xf0dca0[_0x33303a] = c; // write to any index less than bonusCodes.length\n     }\n\n     function Destroy() public {\n         require(msg.sender == _0x57e737);\n         selfdestruct(msg.sender);\n     }\n }",
      "rename_map": {
        "bonusCodes": "_0xf0dca0",
        "owner": "_0x57e737",
        "idx": "_0x33303a"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_009",
      "transformed_id": "ss_l2_hex_sn_ds_009",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Map {\n     address public _0xabeb91;\n     uint256[] _0xc48a44;\n\n     function _0xa6e261(uint256 _0x30b724, uint256 value) public {\n         if (_0xc48a44.length <= _0x30b724) {\n             _0xc48a44.length = _0x30b724 + 1;\n         }\n         _0xc48a44[_0x30b724] = value;\n     }\n\n     function _0x974d81(uint256 _0x30b724) public view returns (uint256) {\n         return _0xc48a44[_0x30b724];\n     }\n     function _0x3c6fd0() public{\n       require(msg.sender == _0xabeb91);\n       msg.sender.transfer(address(this).balance);\n     }\n }",
      "rename_map": {
        "withdraw": "_0x3c6fd0",
        "owner": "_0xabeb91",
        "get": "_0x974d81",
        "key": "_0x30b724",
        "set": "_0xa6e261",
        "map": "_0xc48a44"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_010",
      "transformed_id": "ss_l2_hex_sn_ds_010",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract MyContract {\n\n    address _0x842ea1;\n\n    function MyContract() public {\n        _0x842ea1 = msg.sender;\n    }\n\n    function _0x3224fb(address _0x8469da, uint _0x13bbeb) public {\n        require(tx.origin == _0x842ea1);\n        _0x8469da.transfer(_0x13bbeb);\n    }\n\n}",
      "rename_map": {
        "receiver": "_0x8469da",
        "sendTo": "_0x3224fb",
        "amount": "_0x13bbeb",
        "owner": "_0x842ea1"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_011",
      "transformed_id": "ss_l2_hex_sn_ds_011",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.22;\n\n contract Phishable {\n    address public _0xd42af4;\n\n    constructor (address _0x1c7b4e) {\n        _0xd42af4 = _0x1c7b4e;\n    }\n\n    function () public payable {} // collect ether\n\n    function _0xb8b038(address _0xc9c0ed) public {\n        require(tx.origin == _0xd42af4);\n        _0xc9c0ed.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "withdrawAll": "_0xb8b038",
        "_recipient": "_0xc9c0ed",
        "_owner": "_0x1c7b4e",
        "owner": "_0xd42af4"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_012",
      "transformed_id": "ss_l2_hex_sn_ds_012",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy {\n\n  address _0x81ca59;\n\n  constructor() public {\n    _0x81ca59 = msg.sender;\n  }\n\n  function _0x6b2557(address _0xc0595b, bytes _0x27faa5) public {\n    require(_0xc0595b.delegatecall(_0x27faa5));\n  }\n\n}",
      "rename_map": {
        "forward": "_0x6b2557",
        "callee": "_0xc0595b",
        "_data": "_0x27faa5",
        "owner": "_0x81ca59"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_013",
      "transformed_id": "ss_l2_hex_sn_ds_013",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract SimpleDestruct {\n  function _0x5a191d() {\n    selfdestruct(msg.sender);\n  }\n\n}\n",
      "rename_map": {
        "sudicideAnyone": "_0x5a191d"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_014",
      "transformed_id": "ss_l2_hex_sn_ds_014",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Wallet {\n     address _0xc6e376;\n\n     mapping(address => uint256) _0xd813b1;\n\n     constructor() public {\n         _0xc6e376 = msg.sender;\n     }\n\n     function _0xbdc6a2() public payable {\n         assert(_0xd813b1[msg.sender] + msg.value > _0xd813b1[msg.sender]);\n         _0xd813b1[msg.sender] += msg.value;\n     }\n\n     function _0x5c0325(uint256 _0x2a8be8) public {\n         require(_0x2a8be8 <= _0xd813b1[msg.sender]);\n         msg.sender.transfer(_0x2a8be8);\n         _0xd813b1[msg.sender] -= _0x2a8be8;\n     }\n\n     function _0x3b8bfe() public {\n         msg.sender.transfer(_0xd813b1[msg.sender]);\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function _0xf522a0(address _0x80c290) public {\n         require(_0xc6e376 == msg.sender);\n         _0x80c290.transfer(this.balance);\n     }\n\n }\n",
      "rename_map": {
        "migrateTo": "_0xf522a0",
        "withdraw": "_0x5c0325",
        "balances": "_0xd813b1",
        "deposit": "_0xbdc6a2",
        "creator": "_0xc6e376",
        "refund": "_0x3b8bfe",
        "amount": "_0x2a8be8",
        "to": "_0x80c290"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_015",
      "transformed_id": "ss_l2_hex_sn_ds_015",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Wallet {\n     address _0x7399e7;\n\n     mapping(address => uint256) _0xcd726d;\n\n     function _0xee117b() public {\n         _0x7399e7 = msg.sender;\n     }\n\n     function _0x38661f() public payable {\n         assert(_0xcd726d[msg.sender] + msg.value > _0xcd726d[msg.sender]);\n         _0xcd726d[msg.sender] += msg.value;\n     }\n\n     function _0xa3b595(uint256 _0x62aea8) public {\n         require(_0x62aea8 <= _0xcd726d[msg.sender]);\n         msg.sender.transfer(_0x62aea8);\n         _0xcd726d[msg.sender] -= _0x62aea8;\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function _0x7a75e0(address _0x299c53) public {\n         require(_0x7399e7 == msg.sender);\n         _0x299c53.transfer(this.balance);\n     }\n\n }\n",
      "rename_map": {
        "initWallet": "_0xee117b",
        "migrateTo": "_0x7a75e0",
        "withdraw": "_0xa3b595",
        "balances": "_0xcd726d",
        "deposit": "_0x38661f",
        "creator": "_0x7399e7",
        "amount": "_0x62aea8",
        "to": "_0x299c53"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_016",
      "transformed_id": "ss_l2_hex_sn_ds_016",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Wallet {\n     address _0x6d027c;\n\n     mapping(address => uint256) _0xbd2933;\n\n     constructor() public {\n         _0x6d027c = msg.sender;\n     }\n\n     function _0x757829() public payable {\n         assert(_0xbd2933[msg.sender] + msg.value > _0xbd2933[msg.sender]);\n         _0xbd2933[msg.sender] += msg.value;\n     }\n\n     function _0x4b5bf3(uint256 _0x4ea44d) public {\n         require(_0x4ea44d >= _0xbd2933[msg.sender]);\n         msg.sender.transfer(_0x4ea44d);\n         _0xbd2933[msg.sender] -= _0x4ea44d;\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function _0x47e2e1(address _0xfb9cb6) public {\n         require(_0x6d027c == msg.sender);\n         _0xfb9cb6.transfer(this.balance);\n     }\n\n }\n",
      "rename_map": {
        "migrateTo": "_0x47e2e1",
        "withdraw": "_0x4b5bf3",
        "balances": "_0xbd2933",
        "deposit": "_0x757829",
        "creator": "_0x6d027c",
        "amount": "_0x4ea44d",
        "to": "_0xfb9cb6"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_017",
      "transformed_id": "ss_l2_hex_sn_ds_017",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PERSONAL_BANK\n{\n    mapping (address=>uint256) public _0x989193;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool _0xf59393;\n\n    function SetMinSum(uint _0xed2f8f)\n    public\n    {\n        if(_0xf59393)revert();\n        MinSum = _0xed2f8f;\n    }\n\n    function SetLogFile(address _0xc92a96)\n    public\n    {\n        if(_0xf59393)revert();\n        Log = LogFile(_0xc92a96);\n    }\n\n    function Initialized()\n    public\n    {\n        _0xf59393 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x989193[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x3a4667)\n    public\n    payable\n    {\n        if(_0x989193[msg.sender]>=MinSum && _0x989193[msg.sender]>=_0x3a4667)\n        {\n            if(msg.sender.call.value(_0x3a4667)())\n            {\n                _0x989193[msg.sender]-=_0x3a4667;\n                Log.AddMessage(msg.sender,_0x3a4667,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x33b3de,uint _0xed2f8f,string _0x9c88f8)\n    public\n    {\n        LastMsg.Sender = _0x33b3de;\n        LastMsg.Time = _0x5ad4cc;\n        LastMsg.Val = _0xed2f8f;\n        LastMsg.Data = _0x9c88f8;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0xf59393",
        "balances": "_0x989193",
        "_data": "_0x9c88f8",
        "_adr": "_0x33b3de",
        "_val": "_0xed2f8f",
        "_log": "_0xc92a96",
        "_am": "_0x3a4667",
        "now": "_0x5ad4cc"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_018",
      "transformed_id": "ss_l2_hex_sn_ds_018",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public _0x2c7ecd;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address _0x7c1ef7)\n    {\n        TransferLog = Log(_0x7c1ef7);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            _0x2c7ecd[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x8aeb41)\n    {\n        if(_0x8aeb41<=_0x2c7ecd[msg.sender])\n        {\n            if(msg.sender.call.value(_0x8aeb41)())\n            {\n                _0x2c7ecd[msg.sender]-=_0x8aeb41;\n                TransferLog.AddMessage(msg.sender,_0x8aeb41,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x453c49,uint _0x6d557b,string _0x373ca6)\n    public\n    {\n        LastMsg.Sender = _0x453c49;\n        LastMsg.Time = _0x69cc19;\n        LastMsg.Val = _0x6d557b;\n        LastMsg.Data = _0x373ca6;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x2c7ecd",
        "_data": "_0x373ca6",
        "_adr": "_0x453c49",
        "_val": "_0x6d557b",
        "_log": "_0x7c1ef7",
        "_am": "_0x8aeb41",
        "now": "_0x69cc19"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_019",
      "transformed_id": "ss_l2_hex_sn_ds_019",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ACCURAL_DEPOSIT\n{\n    mapping (address=>uint256) public _0xdb1219;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool _0x78ad5a;\n\n    function SetMinSum(uint _0x127321)\n    public\n    {\n        if(_0x78ad5a)revert();\n        MinSum = _0x127321;\n    }\n\n    function SetLogFile(address _0x5c6d18)\n    public\n    {\n        if(_0x78ad5a)revert();\n        Log = LogFile(_0x5c6d18);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x78ad5a = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0xdb1219[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0xda45ce)\n    public\n    payable\n    {\n        if(_0xdb1219[msg.sender]>=MinSum && _0xdb1219[msg.sender]>=_0xda45ce)\n        {\n            if(msg.sender.call.value(_0xda45ce)())\n            {\n                _0xdb1219[msg.sender]-=_0xda45ce;\n                Log.AddMessage(msg.sender,_0xda45ce,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xf17681,uint _0x127321,string _0x8e7203)\n    public\n    {\n        LastMsg.Sender = _0xf17681;\n        LastMsg.Time = _0x9be641;\n        LastMsg.Val = _0x127321;\n        LastMsg.Data = _0x8e7203;\n        History.push(LastMsg);\n    }\n}\n",
      "rename_map": {
        "intitalized": "_0x78ad5a",
        "balances": "_0xdb1219",
        "_data": "_0x8e7203",
        "_adr": "_0xf17681",
        "_val": "_0x127321",
        "_log": "_0x5c6d18",
        "_am": "_0xda45ce",
        "now": "_0x9be641"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_020",
      "transformed_id": "ss_l2_hex_sn_ds_020",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PRIVATE_ETH_CELL\n{\n    mapping (address=>uint256) public _0x4372c5;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0x145a34;\n\n    function SetMinSum(uint _0xd73417)\n    public\n    {\n        require(!_0x145a34);\n        MinSum = _0xd73417;\n    }\n\n    function SetLogFile(address _0xc9773e)\n    public\n    {\n        require(!_0x145a34);\n        Log = LogFile(_0xc9773e);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x145a34 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x4372c5[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x82e4f3)\n    public\n    payable\n    {\n        if(_0x4372c5[msg.sender]>=MinSum && _0x4372c5[msg.sender]>=_0x82e4f3)\n        {\n            if(msg.sender.call.value(_0x82e4f3)())\n            {\n                _0x4372c5[msg.sender]-=_0x82e4f3;\n                Log.AddMessage(msg.sender,_0x82e4f3,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x48d50b,uint _0xd73417,string _0xf3c3f3)\n    public\n    {\n        LastMsg.Sender = _0x48d50b;\n        LastMsg.Time = _0x88e590;\n        LastMsg.Val = _0xd73417;\n        LastMsg.Data = _0xf3c3f3;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0x145a34",
        "balances": "_0x4372c5",
        "_data": "_0xf3c3f3",
        "_adr": "_0x48d50b",
        "_val": "_0xd73417",
        "_log": "_0xc9773e",
        "_am": "_0x82e4f3",
        "now": "_0x88e590"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_021",
      "transformed_id": "ss_l2_hex_sn_ds_021",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract BANK_SAFE\n{\n    mapping (address=>uint256) public _0xd98e0e;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0x6420a7;\n\n    function SetMinSum(uint _0x7334cd)\n    public\n    {\n        if(_0x6420a7)throw;\n        MinSum = _0x7334cd;\n    }\n\n    function SetLogFile(address _0xea6572)\n    public\n    {\n        if(_0x6420a7)throw;\n        Log = LogFile(_0xea6572);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x6420a7 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0xd98e0e[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x356b84)\n    public\n    payable\n    {\n        if(_0xd98e0e[msg.sender]>=MinSum && _0xd98e0e[msg.sender]>=_0x356b84)\n        {\n            if(msg.sender.call.value(_0x356b84)())\n            {\n                _0xd98e0e[msg.sender]-=_0x356b84;\n                Log.AddMessage(msg.sender,_0x356b84,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x0bb077,uint _0x7334cd,string _0xf0e198)\n    public\n    {\n        LastMsg.Sender = _0x0bb077;\n        LastMsg.Time = _0x98fff5;\n        LastMsg.Val = _0x7334cd;\n        LastMsg.Data = _0xf0e198;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0x6420a7",
        "balances": "_0xd98e0e",
        "_data": "_0xf0e198",
        "_adr": "_0x0bb077",
        "_val": "_0x7334cd",
        "_log": "_0xea6572",
        "_am": "_0x356b84",
        "now": "_0x98fff5"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_022",
      "transformed_id": "ss_l2_hex_sn_ds_022",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address _0xc9936b;\n    address _0xd67474 = msg.sender;\n\n    function _0x84e2c9(address _0x8370e4)\n    public\n    _0x634d0e\n    {\n        _0xc9936b = _0x8370e4;\n    }\n\n    function _0x2599ff()\n    public\n    {\n        if(msg.sender==_0xc9936b)\n        {\n            _0xd67474=_0xc9936b;\n        }\n    }\n\n    modifier _0x634d0e\n    {\n        if(_0xd67474 == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0xd67474 = msg.sender;\n    function WithdrawToken(address _0x5f728e, uint256 _0xd7a277,address _0xda40c8)\n    public\n    _0x634d0e\n    {\n        _0x5f728e.call(bytes4(_0x6a7ced(\"transfer(address,uint256)\")),_0xda40c8,_0xd7a277);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x0b01a7()\n    public\n    {\n        _0xd67474 = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0xe93142,address _0xfa8759,uint _0x0774a1)\n    public\n    _0x634d0e\n    {\n        if(Holders[_0xe93142]>0)\n        {\n            Holders[_0xe93142]=0;\n            WithdrawToken(_0xfa8759,_0x0774a1,_0xe93142);\n        }\n    }\n\n    function WithdrawToHolder(address _0x98db54, uint _0x06693a)\n    public\n    _0x634d0e\n    payable\n    {\n        if(Holders[_0x98db54]>0)\n        {\n            if(_0x98db54.call.value(_0x06693a)())\n            {\n                Holders[_0x98db54]-=_0x06693a;\n            }\n        }\n    }\n}",
      "rename_map": {
        "initTokenBank": "_0x0b01a7",
        "confirmOwner": "_0x2599ff",
        "changeOwner": "_0x84e2c9",
        "onlyOwner": "_0x634d0e",
        "newOwner": "_0xc9936b",
        "_amount": "_0x0774a1",
        "_token": "_0xfa8759",
        "amount": "_0xd7a277",
        "owner": "_0xd67474",
        "token": "_0x5f728e",
        "_addr": "_0x98db54",
        "addr": "_0x8370e4",
        "_wei": "_0x06693a",
        "sha3": "_0x6a7ced",
        "_to": "_0xe93142",
        "to": "_0xda40c8"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_023",
      "transformed_id": "ss_l2_hex_sn_ds_023",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract U_BANK\n{\n    function Put(uint _0xaf1df7)\n    public\n    payable\n    {\n        var _0x8c955a = Acc[msg.sender];\n        _0x8c955a.balance += msg.value;\n        _0x8c955a._0x605ad3 = _0xaf1df7>_0xa3c94c?_0xaf1df7:_0xa3c94c;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x464354)\n    public\n    payable\n    {\n        var _0x8c955a = Acc[msg.sender];\n        if( _0x8c955a.balance>=MinSum && _0x8c955a.balance>=_0x464354 && _0xa3c94c>_0x8c955a._0x605ad3)\n        {\n            if(msg.sender.call.value(_0x464354)())\n            {\n                _0x8c955a.balance-=_0x464354;\n                LogFile.AddMessage(msg.sender,_0x464354,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0x605ad3;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 2 ether;\n\n    function U_BANK(address _0x3c4b94) public{\n        LogFile = Log(_0x3c4b94);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xadec94,uint _0xab1542,string _0xc1a990)\n    public\n    {\n        LastMsg.Sender = _0xadec94;\n        LastMsg.Time = _0xa3c94c;\n        LastMsg.Val = _0xab1542;\n        LastMsg.Data = _0xc1a990;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0xaf1df7",
        "unlockTime": "_0x605ad3",
        "_data": "_0xc1a990",
        "_adr": "_0xadec94",
        "_val": "_0xab1542",
        "acc": "_0x8c955a",
        "log": "_0x3c4b94",
        "_am": "_0x464354",
        "now": "_0xa3c94c"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_024",
      "transformed_id": "ss_l2_hex_sn_ds_024",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PrivateDeposit\n{\n    mapping (address => uint) public _0x4c57f8;\n\n    uint public MinDeposit = 1 ether;\n    address public _0xd64d94;\n\n    Log TransferLog;\n\n    modifier _0xca4c53() {\n        require(tx.origin == _0xd64d94);\n        _;\n    }\n\n    function PrivateDeposit()\n    {\n        _0xd64d94 = msg.sender;\n        TransferLog = new Log();\n    }\n\n    function _0x0df9ab(address _0x3f0f11) _0xca4c53\n    {\n        TransferLog = Log(_0x3f0f11);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            _0x4c57f8[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x25e3eb)\n    {\n        if(_0x25e3eb<=_0x4c57f8[msg.sender])\n        {\n            if(msg.sender.call.value(_0x25e3eb)())\n            {\n                _0x4c57f8[msg.sender]-=_0x25e3eb;\n                TransferLog.AddMessage(msg.sender,_0x25e3eb,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x9aa551,uint _0xcc91c1,string _0xfb4207)\n    public\n    {\n        LastMsg.Sender = _0x9aa551;\n        LastMsg.Time = _0x3077f4;\n        LastMsg.Val = _0xcc91c1;\n        LastMsg.Data = _0xfb4207;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "onlyOwner": "_0xca4c53",
        "balances": "_0x4c57f8",
        "setLog": "_0x0df9ab",
        "owner": "_0xd64d94",
        "_data": "_0xfb4207",
        "_adr": "_0x9aa551",
        "_lib": "_0x3f0f11",
        "_val": "_0xcc91c1",
        "_am": "_0x25e3eb",
        "now": "_0x3077f4"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_025",
      "transformed_id": "ss_l2_hex_sn_ds_025",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract W_WALLET\n{\n    function Put(uint _0x0fa7be)\n    public\n    payable\n    {\n        var _0x5d824c = Acc[msg.sender];\n        _0x5d824c.balance += msg.value;\n        _0x5d824c._0x938618 = _0x0fa7be>_0xa339c7?_0x0fa7be:_0xa339c7;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x53d583)\n    public\n    payable\n    {\n        var _0x5d824c = Acc[msg.sender];\n        if( _0x5d824c.balance>=MinSum && _0x5d824c.balance>=_0x53d583 && _0xa339c7>_0x5d824c._0x938618)\n        {\n            if(msg.sender.call.value(_0x53d583)())\n            {\n                _0x5d824c.balance-=_0x53d583;\n                LogFile.AddMessage(msg.sender,_0x53d583,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0x938618;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function W_WALLET(address _0x350f54) public{\n        LogFile = Log(_0x350f54);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xa51c58,uint _0x47c74c,string _0xbdfeae)\n    public\n    {\n        LastMsg.Sender = _0xa51c58;\n        LastMsg.Time = _0xa339c7;\n        LastMsg.Val = _0x47c74c;\n        LastMsg.Data = _0xbdfeae;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0x0fa7be",
        "unlockTime": "_0x938618",
        "_data": "_0xbdfeae",
        "_adr": "_0xa51c58",
        "_val": "_0x47c74c",
        "acc": "_0x5d824c",
        "log": "_0x350f54",
        "_am": "_0x53d583",
        "now": "_0xa339c7"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_026",
      "transformed_id": "ss_l2_hex_sn_ds_026",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public _0x49f7a5;\n\n    Log TransferLog;\n\n    uint public MinDeposit = 1 ether;\n\n    function ETH_VAULT(address _0xd8e5d6)\n    public\n    {\n        TransferLog = Log(_0xd8e5d6);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            _0x49f7a5[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0xaa98bb)\n    public\n    payable\n    {\n        if(_0xaa98bb<=_0x49f7a5[msg.sender])\n        {\n            if(msg.sender.call.value(_0xaa98bb)())\n            {\n                _0x49f7a5[msg.sender]-=_0xaa98bb;\n                TransferLog.AddMessage(msg.sender,_0xaa98bb,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x2b7e96,uint _0x21d010,string _0x981bc2)\n    public\n    {\n        LastMsg.Sender = _0x2b7e96;\n        LastMsg.Time = _0x703577;\n        LastMsg.Val = _0x21d010;\n        LastMsg.Data = _0x981bc2;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x49f7a5",
        "_data": "_0x981bc2",
        "_adr": "_0x2b7e96",
        "_val": "_0x21d010",
        "_log": "_0xd8e5d6",
        "_am": "_0xaa98bb",
        "now": "_0x703577"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_027",
      "transformed_id": "ss_l2_hex_sn_ds_027",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract X_WALLET\n{\n    function Put(uint _0xa618ae)\n    public\n    payable\n    {\n        var _0xd36ba4 = Acc[msg.sender];\n        _0xd36ba4.balance += msg.value;\n        _0xd36ba4._0x7d19f0 = _0xa618ae>_0xb688ac?_0xa618ae:_0xb688ac;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x3b1d8f)\n    public\n    payable\n    {\n        var _0xd36ba4 = Acc[msg.sender];\n        if( _0xd36ba4.balance>=MinSum && _0xd36ba4.balance>=_0x3b1d8f && _0xb688ac>_0xd36ba4._0x7d19f0)\n        {\n            if(msg.sender.call.value(_0x3b1d8f)())\n            {\n                _0xd36ba4.balance-=_0x3b1d8f;\n                LogFile.AddMessage(msg.sender,_0x3b1d8f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0x7d19f0;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function X_WALLET(address _0xb6ec4c) public{\n        LogFile = Log(_0xb6ec4c);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x108023,uint _0x0b16aa,string _0x8fba9e)\n    public\n    {\n        LastMsg.Sender = _0x108023;\n        LastMsg.Time = _0xb688ac;\n        LastMsg.Val = _0x0b16aa;\n        LastMsg.Data = _0x8fba9e;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0xa618ae",
        "unlockTime": "_0x7d19f0",
        "_data": "_0x8fba9e",
        "_adr": "_0x108023",
        "_val": "_0x0b16aa",
        "acc": "_0xd36ba4",
        "log": "_0xb6ec4c",
        "_am": "_0x3b1d8f",
        "now": "_0xb688ac"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_028",
      "transformed_id": "ss_l2_hex_sn_ds_028",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract ETH_FUND\n{\n    mapping (address => uint) public _0xc3dc6a;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    uint _0x6534c1;\n\n    function ETH_FUND(address _0x99df3e)\n    public\n    {\n        TransferLog = Log(_0x99df3e);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            _0xc3dc6a[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            _0x6534c1 = block.number;\n        }\n    }\n\n    function CashOut(uint _0x98ae76)\n    public\n    payable\n    {\n        if(_0x98ae76<=_0xc3dc6a[msg.sender]&&block.number>_0x6534c1)\n        {\n            if(msg.sender.call.value(_0x98ae76)())\n            {\n                _0xc3dc6a[msg.sender]-=_0x98ae76;\n                TransferLog.AddMessage(msg.sender,_0x98ae76,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xfd3da9,uint _0xa200ee,string _0x715029)\n    public\n    {\n        LastMsg.Sender = _0xfd3da9;\n        LastMsg.Time = _0xef7014;\n        LastMsg.Val = _0xa200ee;\n        LastMsg.Data = _0x715029;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "lastBlock": "_0x6534c1",
        "balances": "_0xc3dc6a",
        "_data": "_0x715029",
        "_adr": "_0xfd3da9",
        "_val": "_0xa200ee",
        "_log": "_0x99df3e",
        "_am": "_0x98ae76",
        "now": "_0xef7014"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_029",
      "transformed_id": "ss_l2_hex_sn_ds_029",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PENNY_BY_PENNY\n{\n    struct Holder\n    {\n        uint _0x390434;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0x2f28af;\n\n    function SetMinSum(uint _0x389aae)\n    public\n    {\n        if(_0x2f28af)throw;\n        MinSum = _0x389aae;\n    }\n\n    function SetLogFile(address _0x5291dd)\n    public\n    {\n        if(_0x2f28af)throw;\n        Log = LogFile(_0x5291dd);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x2f28af = true;\n    }\n\n    function Put(uint _0x5d6540)\n    public\n    payable\n    {\n        var _0x732727 = Acc[msg.sender];\n        _0x732727.balance += msg.value;\n        if(_0x49f335+_0x5d6540>_0x732727._0x390434)_0x732727._0x390434=_0x49f335+_0x5d6540;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x0c96e3)\n    public\n    payable\n    {\n        var _0x732727 = Acc[msg.sender];\n        if( _0x732727.balance>=MinSum && _0x732727.balance>=_0x0c96e3 && _0x49f335>_0x732727._0x390434)\n        {\n            if(msg.sender.call.value(_0x0c96e3)())\n            {\n                _0x732727.balance-=_0x0c96e3;\n                Log.AddMessage(msg.sender,_0x0c96e3,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x2182fb,uint _0x389aae,string _0x7ce89f)\n    public\n    {\n        LastMsg.Sender = _0x2182fb;\n        LastMsg.Time = _0x49f335;\n        LastMsg.Val = _0x389aae;\n        LastMsg.Data = _0x7ce89f;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0x2f28af",
        "unlockTime": "_0x390434",
        "_lockTime": "_0x5d6540",
        "_data": "_0x7ce89f",
        "_adr": "_0x2182fb",
        "_val": "_0x389aae",
        "_log": "_0x5291dd",
        "acc": "_0x732727",
        "_am": "_0x0c96e3",
        "now": "_0x49f335"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_030",
      "transformed_id": "ss_l2_hex_sn_ds_030",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract DEP_BANK\n{\n    mapping (address=>uint256) public _0x6ae7a1;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0xd15b35;\n\n    function SetMinSum(uint _0x7b9312)\n    public\n    {\n        if(_0xd15b35)throw;\n        MinSum = _0x7b9312;\n    }\n\n    function SetLogFile(address _0xfb494a)\n    public\n    {\n        if(_0xd15b35)throw;\n        Log = LogFile(_0xfb494a);\n    }\n\n    function Initialized()\n    public\n    {\n        _0xd15b35 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x6ae7a1[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x4b956f)\n    public\n    payable\n    {\n        if(_0x6ae7a1[msg.sender]>=MinSum && _0x6ae7a1[msg.sender]>=_0x4b956f)\n        {\n            if(msg.sender.call.value(_0x4b956f)())\n            {\n                _0x6ae7a1[msg.sender]-=_0x4b956f;\n                Log.AddMessage(msg.sender,_0x4b956f,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x65955e,uint _0x7b9312,string _0xb111e8)\n    public\n    {\n        LastMsg.Sender = _0x65955e;\n        LastMsg.Time = _0x006247;\n        LastMsg.Val = _0x7b9312;\n        LastMsg.Data = _0xb111e8;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0xd15b35",
        "balances": "_0x6ae7a1",
        "_data": "_0xb111e8",
        "_adr": "_0x65955e",
        "_val": "_0x7b9312",
        "_log": "_0xfb494a",
        "_am": "_0x4b956f",
        "now": "_0x006247"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_031",
      "transformed_id": "ss_l2_hex_sn_ds_031",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public _0x115586;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address _0x56c73c)\n    {\n        TransferLog = Log(_0x56c73c);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            _0x115586[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x1fe065)\n    public\n    payable\n    {\n        if(_0x1fe065<=_0x115586[msg.sender])\n        {\n            if(msg.sender.call.value(_0x1fe065)())\n            {\n                _0x115586[msg.sender]-=_0x1fe065;\n                TransferLog.AddMessage(msg.sender,_0x1fe065,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xc1c7f6,uint _0x427ccd,string _0x3df87f)\n    public\n    {\n        LastMsg.Sender = _0xc1c7f6;\n        LastMsg.Time = _0xa81a00;\n        LastMsg.Val = _0x427ccd;\n        LastMsg.Data = _0x3df87f;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x115586",
        "_data": "_0x3df87f",
        "_adr": "_0xc1c7f6",
        "_val": "_0x427ccd",
        "_log": "_0x56c73c",
        "_am": "_0x1fe065",
        "now": "_0xa81a00"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_032",
      "transformed_id": "ss_l2_hex_sn_ds_032",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public _0x766bb1;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address _0x397a90)\n    {\n        TransferLog = Log(_0x397a90);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            _0x766bb1[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0xe038de)\n    {\n        if(_0xe038de<=_0x766bb1[msg.sender])\n        {\n            if(msg.sender.call.value(_0xe038de)())\n            {\n                _0x766bb1[msg.sender]-=_0xe038de;\n                TransferLog.AddMessage(msg.sender,_0xe038de,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x5574f2,uint _0x31ab25,string _0xdb2ecc)\n    public\n    {\n        LastMsg.Sender = _0x5574f2;\n        LastMsg.Time = _0x74860b;\n        LastMsg.Val = _0x31ab25;\n        LastMsg.Data = _0xdb2ecc;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x766bb1",
        "_data": "_0xdb2ecc",
        "_adr": "_0x5574f2",
        "_lib": "_0x397a90",
        "_val": "_0x31ab25",
        "_am": "_0xe038de",
        "now": "_0x74860b"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_033",
      "transformed_id": "ss_l2_hex_sn_ds_033",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public _0x5bf950;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function ETH_VAULT(address _0x8a55ac)\n    public\n    {\n        TransferLog = Log(_0x8a55ac);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value > MinDeposit)\n        {\n            _0x5bf950[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x353e55)\n    public\n    payable\n    {\n        if(_0x353e55<=_0x5bf950[msg.sender])\n        {\n            if(msg.sender.call.value(_0x353e55)())\n            {\n                _0x5bf950[msg.sender]-=_0x353e55;\n                TransferLog.AddMessage(msg.sender,_0x353e55,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xb540b3,uint _0x1c34a7,string _0x3d5bde)\n    public\n    {\n        LastMsg.Sender = _0xb540b3;\n        LastMsg.Time = _0x23bfef;\n        LastMsg.Val = _0x1c34a7;\n        LastMsg.Data = _0x3d5bde;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x5bf950",
        "_data": "_0x3d5bde",
        "_adr": "_0xb540b3",
        "_val": "_0x1c34a7",
        "_log": "_0x8a55ac",
        "_am": "_0x353e55",
        "now": "_0x23bfef"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_034",
      "transformed_id": "ss_l2_hex_sn_ds_034",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract MONEY_BOX\n{\n    struct Holder\n    {\n        uint _0x4207c5;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    Log LogFile;\n\n    bool _0xdf7a32;\n\n    function SetMinSum(uint _0x7a0c00)\n    public\n    {\n        if(_0xdf7a32)throw;\n        MinSum = _0x7a0c00;\n    }\n\n    function SetLogFile(address _0x28b3b5)\n    public\n    {\n        if(_0xdf7a32)throw;\n        LogFile = Log(_0x28b3b5);\n    }\n\n    function Initialized()\n    public\n    {\n        _0xdf7a32 = true;\n    }\n\n    function Put(uint _0x064311)\n    public\n    payable\n    {\n        var _0x537f37 = Acc[msg.sender];\n        _0x537f37.balance += msg.value;\n        if(_0x6ed151+_0x064311>_0x537f37._0x4207c5)_0x537f37._0x4207c5=_0x6ed151+_0x064311;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x22a8c4)\n    public\n    payable\n    {\n        var _0x537f37 = Acc[msg.sender];\n        if( _0x537f37.balance>=MinSum && _0x537f37.balance>=_0x22a8c4 && _0x6ed151>_0x537f37._0x4207c5)\n        {\n            if(msg.sender.call.value(_0x22a8c4)())\n            {\n                _0x537f37.balance-=_0x22a8c4;\n                LogFile.AddMessage(msg.sender,_0x22a8c4,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xf3a07d,uint _0x7a0c00,string _0xba14f0)\n    public\n    {\n        LastMsg.Sender = _0xf3a07d;\n        LastMsg.Time = _0x6ed151;\n        LastMsg.Val = _0x7a0c00;\n        LastMsg.Data = _0xba14f0;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0xdf7a32",
        "unlockTime": "_0x4207c5",
        "_lockTime": "_0x064311",
        "_data": "_0xba14f0",
        "_adr": "_0xf3a07d",
        "_val": "_0x7a0c00",
        "_log": "_0x28b3b5",
        "acc": "_0x537f37",
        "_am": "_0x22a8c4",
        "now": "_0x6ed151"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_035",
      "transformed_id": "ss_l2_hex_sn_ds_035",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract WALLET\n{\n    function Put(uint _0xb84530)\n    public\n    payable\n    {\n        var _0x3e0f19 = Acc[msg.sender];\n        _0x3e0f19.balance += msg.value;\n        _0x3e0f19._0x9b47ed = _0xb84530>_0x1e7200?_0xb84530:_0x1e7200;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0xb953b9)\n    public\n    payable\n    {\n        var _0x3e0f19 = Acc[msg.sender];\n        if( _0x3e0f19.balance>=MinSum && _0x3e0f19.balance>=_0xb953b9 && _0x1e7200>_0x3e0f19._0x9b47ed)\n        {\n            if(msg.sender.call.value(_0xb953b9)())\n            {\n                _0x3e0f19.balance-=_0xb953b9;\n                LogFile.AddMessage(msg.sender,_0xb953b9,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0x9b47ed;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function WALLET(address _0x2896a1) public{\n        LogFile = Log(_0x2896a1);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x4d141a,uint _0xe72b70,string _0x604d5d)\n    public\n    {\n        LastMsg.Sender = _0x4d141a;\n        LastMsg.Time = _0x1e7200;\n        LastMsg.Val = _0xe72b70;\n        LastMsg.Data = _0x604d5d;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0xb84530",
        "unlockTime": "_0x9b47ed",
        "_data": "_0x604d5d",
        "_adr": "_0x4d141a",
        "_val": "_0xe72b70",
        "acc": "_0x3e0f19",
        "log": "_0x2896a1",
        "_am": "_0xb953b9",
        "now": "_0x1e7200"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_036",
      "transformed_id": "ss_l2_hex_sn_ds_036",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract MY_BANK\n{\n    function Put(uint _0x31100c)\n    public\n    payable\n    {\n        var _0xa29338 = Acc[msg.sender];\n        _0xa29338.balance += msg.value;\n        _0xa29338._0x04497f = _0x31100c>_0xbde234?_0x31100c:_0xbde234;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x7e07c6)\n    public\n    payable\n    {\n        var _0xa29338 = Acc[msg.sender];\n        if( _0xa29338.balance>=MinSum && _0xa29338.balance>=_0x7e07c6 && _0xbde234>_0xa29338._0x04497f)\n        {\n            if(msg.sender.call.value(_0x7e07c6)())\n            {\n                _0xa29338.balance-=_0x7e07c6;\n                LogFile.AddMessage(msg.sender,_0x7e07c6,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0x04497f;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function MY_BANK(address _0xdab231) public{\n        LogFile = Log(_0xdab231);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x8e2cac,uint _0xc6fca2,string _0x7de604)\n    public\n    {\n        LastMsg.Sender = _0x8e2cac;\n        LastMsg.Time = _0xbde234;\n        LastMsg.Val = _0xc6fca2;\n        LastMsg.Data = _0x7de604;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0x31100c",
        "unlockTime": "_0x04497f",
        "_data": "_0x7de604",
        "_adr": "_0x8e2cac",
        "_val": "_0xc6fca2",
        "acc": "_0xa29338",
        "log": "_0xdab231",
        "_am": "_0x7e07c6",
        "now": "_0xbde234"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_037",
      "transformed_id": "ss_l2_hex_sn_ds_037",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.0;\ncontract EtherBank{\n    mapping (address => uint) _0xeadc58;\n    function _0x78c0be(address _0xc6f958) constant returns(uint) {\n\t\treturn _0xeadc58[_0xc6f958];\n\t}\n\n\tfunction _0xc263d5() {\n\t\t_0xeadc58[msg.sender] += msg.value;\n\t}\n\n\tfunction _0x2b5964() {\n\t\tuint _0xbac219 = _0xeadc58[msg.sender];\n\t\tif (!(msg.sender.call.value(_0xbac219)())) { throw; }\n\t\t_0xeadc58[msg.sender] = 0;\n\t}\n}",
      "rename_map": {
        "amountToWithdraw": "_0xbac219",
        "withdrawBalance": "_0x2b5964",
        "addToBalance": "_0xc263d5",
        "userBalances": "_0xeadc58",
        "getBalance": "_0x78c0be",
        "user": "_0xc6f958"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_038",
      "transformed_id": "ss_l2_hex_sn_ds_038",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\ncontract EtherStore {\n\n    uint256 public _0x3a6f30 = 1 ether;\n    mapping(address => uint256) public _0x7e105f;\n    mapping(address => uint256) public _0x178ba9;\n\n    function _0xdc8585() public payable {\n        _0x178ba9[msg.sender] += msg.value;\n    }\n\n    function _0x2e4fad (uint256 _0x0da442) public {\n        require(_0x178ba9[msg.sender] >= _0x0da442);\n        // limit the withdrawal\n        require(_0x0da442 <= _0x3a6f30);\n        // limit the time allowed to withdraw\n        require(_0x3ae809 >= _0x7e105f[msg.sender] + 1 weeks);\n        require(msg.sender.call.value(_0x0da442)());\n        _0x178ba9[msg.sender] -= _0x0da442;\n        _0x7e105f[msg.sender] = _0x3ae809;\n    }\n }\n",
      "rename_map": {
        "lastWithdrawTime": "_0x7e105f",
        "withdrawalLimit": "_0x3a6f30",
        "_weiToWithdraw": "_0x0da442",
        "withdrawFunds": "_0x2e4fad",
        "depositFunds": "_0xdc8585",
        "balances": "_0x178ba9",
        "now": "_0x3ae809"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_039",
      "transformed_id": "ss_l2_hex_sn_ds_039",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract ModifierBank {\n  mapping (address => uint) public _0x1405e9;\n  string constant _0x363efd = \"Nu Token\";\n\n  //If a contract has a zero balance and supports the token give them some token\n  function _0xe0d4fe() _0x57bce8 _0x0f7379  public{\n    _0x1405e9[msg.sender] += 20;\n  }\n\n  //Checks that the contract responds the way we want\n  modifier _0x0f7379() {\n    require(_0xd9cfb4(abi._0xdaf9ba(\"Nu Token\")) == Bank(msg.sender)._0x0f7379());\n    _;\n  }\n  //Checks that the caller has a zero balance\n  modifier _0x57bce8 {\n      require(_0x1405e9[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n    function _0x0f7379() external pure returns(bytes32){\n        return(_0xd9cfb4(abi._0xdaf9ba(\"Nu Token\")));\n    }\n}\n\ncontract _0x1f51cf {\n    bool _0xc19854;\n    function _0x0f7379() external returns(bytes32){\n        if(!_0xc19854){\n            _0xc19854 = true;\n            ModifierBank(msg.sender)._0xe0d4fe();\n        }\n        return(_0xd9cfb4(abi._0xdaf9ba(\"Nu Token\")));\n    }\n    function call(address _0xe4f8f3) public{\n        ModifierBank(_0xe4f8f3)._0xe0d4fe();\n    }\n}",
      "rename_map": {
        "hasBeenCalled": "_0xc19854",
        "supportsToken": "_0x0f7379",
        "tokenBalance": "_0x1405e9",
        "hasNoBalance": "_0x57bce8",
        "encodePacked": "_0xdaf9ba",
        "keccak256": "_0xd9cfb4",
        "executor": "_0x1f51cf",
        "airDrop": "_0xe0d4fe",
        "token": "_0xe4f8f3",
        "name": "_0x363efd"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_040",
      "transformed_id": "ss_l2_hex_sn_ds_040",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract TokenVault {\n\n  mapping(address => uint) public _0x8801cd;\n\n  function _0x76af03(address _0x8420df) public payable {\n    _0x8801cd[_0x8420df] += msg.value;\n  }\n\n  function _0xb6521e(address _0x7610be) public view returns (uint balance) {\n    return _0x8801cd[_0x7610be];\n  }\n\n  function _0xd1333d(uint _0x8fa5c5) public {\n    if(_0x8801cd[msg.sender] >= _0x8fa5c5) {\n      if(msg.sender.call.value(_0x8fa5c5)()) {\n        _0x8fa5c5;\n      }\n      _0x8801cd[msg.sender] -= _0x8fa5c5;\n    }\n  }\n\n  function() public payable {}\n}",
      "rename_map": {
        "balanceOf": "_0xb6521e",
        "withdraw": "_0xd1333d",
        "balances": "_0x8801cd",
        "_amount": "_0x8fa5c5",
        "donate": "_0x76af03",
        "_who": "_0x7610be",
        "_to": "_0x8420df"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_041",
      "transformed_id": "ss_l2_hex_sn_ds_041",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract BonusVault{\n\n    mapping (address => uint) private _0xe6114e;\n    mapping (address => bool) private _0xe6c3eb;\n    mapping (address => uint) private _0x188d15;\n\n    function _0x98ba48(address _0x019db9) public {\n        uint _0xceddba = _0x188d15[_0x019db9];\n        _0x188d15[_0x019db9] = 0;\n        (bool _0x5509f0, ) = _0x019db9.call.value(_0xceddba)(\"\");\n        require(_0x5509f0);\n    }\n\n    function _0x6c074a(address _0x019db9) public {\n        require(!_0xe6c3eb[_0x019db9]); // Each recipient should only be able to claim the bonus once\n\n        _0x188d15[_0x019db9] += 100;\n        _0x98ba48(_0x019db9); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n        _0xe6c3eb[_0x019db9] = true;\n    }\n}",
      "rename_map": {
        "getFirstWithdrawalBonus": "_0x6c074a",
        "amountToWithdraw": "_0xceddba",
        "withdrawReward": "_0x98ba48",
        "claimedBonus": "_0xe6c3eb",
        "userBalances": "_0xe6114e",
        "rewardsForA": "_0x188d15",
        "recipient": "_0x019db9",
        "success": "_0x5509f0"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_042",
      "transformed_id": "ss_l2_hex_sn_ds_042",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract CrossFunctionVault {\n\n    mapping (address => uint) private _0xd02512;\n\n    function transfer(address _0x3b8b4c, uint _0x4dc816) {\n        if (_0xd02512[msg.sender] >= _0x4dc816) {\n            _0xd02512[_0x3b8b4c] += _0x4dc816;\n            _0xd02512[msg.sender] -= _0x4dc816;\n        }\n    }\n\n    function _0xcef16f() public {\n        uint _0x28e235 = _0xd02512[msg.sender];\n        (bool _0x9e988b, ) = msg.sender.call.value(_0x28e235)(\"\");\n        require(_0x9e988b);\n        _0xd02512[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "amountToWithdraw": "_0x28e235",
        "withdrawBalance": "_0xcef16f",
        "userBalances": "_0xd02512",
        "success": "_0x9e988b",
        "amount": "_0x4dc816",
        "to": "_0x3b8b4c"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_043",
      "transformed_id": "ss_l2_hex_sn_ds_043",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract CommunityVault {\n    mapping (address => uint) _0x3632ce;\n    uint balance;\n\n    function _0xda96e1() public {\n        uint _0x42ada4 = _0x3632ce[msg.sender];\n        if (_0x42ada4 > 0) {\n            balance -= _0x42ada4;\n            bool _0xa461e0 = msg.sender.call.value(_0x42ada4)();\n            require (_0xa461e0);\n            _0x3632ce[msg.sender] = 0;\n        }\n    }\n\n    function _0x89df55() public payable {\n        _0x3632ce[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n}",
      "rename_map": {
        "withdrawAll": "_0xda96e1",
        "callResult": "_0xa461e0",
        "deposit": "_0x89df55",
        "oCredit": "_0x42ada4",
        "credit": "_0x3632ce"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_044",
      "transformed_id": "ss_l2_hex_sn_ds_044",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.5.0;\n\ncontract SimpleVault {\n\n    mapping (address => uint) private _0xbf268e;\n\n    function _0x9efad5() public {\n        uint _0xffe1a8 = _0xbf268e[msg.sender];\n        (bool _0x0600d8, ) = msg.sender.call.value(_0xffe1a8)(\"\");\n        require(_0x0600d8);\n        _0xbf268e[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "amountToWithdraw": "_0xffe1a8",
        "withdrawBalance": "_0x9efad5",
        "userBalances": "_0xbf268e",
        "success": "_0x0600d8"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_045",
      "transformed_id": "ss_l2_hex_sn_ds_045",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n contract TokenVault {\n     mapping (address => uint) _0xea0025;\n\n     function _0xc93cc8(address u) constant returns(uint){\n         return _0xea0025[u];\n     }\n\n     function _0x6232a4() payable{\n         _0xea0025[msg.sender] += msg.value;\n     }\n\n     function _0x82e755(){\n         // send userBalance[msg.sender] ethers to msg.sender\n         // if mgs.sender is a contract, it will call its fallback function\n         if( ! (msg.sender.call.value(_0xea0025[msg.sender])() ) ){\n             throw;\n         }\n         _0xea0025[msg.sender] = 0;\n     }\n }",
      "rename_map": {
        "withdrawBalance": "_0x82e755",
        "addToBalance": "_0x6232a4",
        "userBalance": "_0xea0025",
        "getBalance": "_0xc93cc8"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_046",
      "transformed_id": "ss_l2_hex_sn_ds_046",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.2;\n\ncontract SimpleDAO {\n  mapping (address => uint) public _0x63f3e3;\n\n  function _0xfd6da5(address _0xac4ba0) payable {\n    _0x63f3e3[_0xac4ba0] += msg.value;\n  }\n\n  function _0x9b3f43(uint _0x581587) {\n    if (_0x63f3e3[msg.sender]>= _0x581587) {\n      bool _0xf3e403 = msg.sender.call.value(_0x581587)();\n      _0x63f3e3[msg.sender]-=_0x581587;\n    }\n  }\n\n  function _0xce8157(address _0xac4ba0) returns (uint){\n    return _0x63f3e3[_0xac4ba0];\n  }\n}",
      "rename_map": {
        "queryCredit": "_0xce8157",
        "withdraw": "_0x9b3f43",
        "donate": "_0xfd6da5",
        "credit": "_0x63f3e3",
        "amount": "_0x581587",
        "res": "_0xf3e403",
        "to": "_0xac4ba0"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_047",
      "transformed_id": "ss_l2_hex_sn_ds_047",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.10;\n\ncontract Caller {\n    function _0xac0807(address a) {\n        a.call();\n    }\n}",
      "rename_map": {
        "callAddress": "_0xac0807"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_048",
      "transformed_id": "ss_l2_hex_sn_ds_048",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\ncontract _0xd28a8a{\n    function transfer(address from,address _0xfbe8b9,address[] _0x9d7435,uint[] v)public returns (bool){\n        require(_0x9d7435.length > 0);\n        bytes4 _0x1150ff=bytes4(_0x4b6ab9(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0x9d7435.length;i++){\n            _0xfbe8b9.call(_0x1150ff,from,_0x9d7435[i],v[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0x4b6ab9",
        "caddress": "_0xfbe8b9",
        "_tos": "_0x9d7435",
        "demo": "_0xd28a8a",
        "id": "_0x1150ff"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_049",
      "transformed_id": "ss_l2_hex_sn_ds_049",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address _0xf87ca0;\n    address _0x2876a0 = msg.sender;\n\n    function _0x92ee93(address _0xe9802b)\n    public\n    _0x2a2a6e\n    {\n        _0xf87ca0 = _0xe9802b;\n    }\n\n    function _0x55f228()\n    public\n    {\n        if(msg.sender==_0xf87ca0)\n        {\n            _0x2876a0=_0xf87ca0;\n        }\n    }\n\n    modifier _0x2a2a6e\n    {\n        if(_0x2876a0 == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x2876a0 = msg.sender;\n    function WithdrawToken(address _0x76da2b, uint256 _0x150108,address _0x3f15b2)\n    public\n    _0x2a2a6e\n    {\n        _0x76da2b.call(bytes4(_0x49f7d3(\"transfer(address,uint256)\")),_0x3f15b2,_0x150108);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x79c733()\n    public\n    {\n        _0x2876a0 = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0xc20ef0,address _0xc47117,uint _0x280ad0)\n    public\n    _0x2a2a6e\n    {\n        if(Holders[_0xc20ef0]>0)\n        {\n            Holders[_0xc20ef0]=0;\n            WithdrawToken(_0xc47117,_0x280ad0,_0xc20ef0);\n        }\n    }\n\n    function WithdrawToHolder(address _0x7ce666, uint _0x87601b)\n    public\n    _0x2a2a6e\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_0x7ce666]>=_0x87601b)\n            {\n                _0x7ce666.call.value(_0x87601b);\n                Holders[_0x7ce666]-=_0x87601b;\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "initTokenBank": "_0x79c733",
        "confirmOwner": "_0x55f228",
        "changeOwner": "_0x92ee93",
        "onlyOwner": "_0x2a2a6e",
        "newOwner": "_0xf87ca0",
        "_amount": "_0x280ad0",
        "_token": "_0xc47117",
        "amount": "_0x150108",
        "owner": "_0x2876a0",
        "token": "_0x76da2b",
        "_addr": "_0x7ce666",
        "addr": "_0xe9802b",
        "_wei": "_0x87601b",
        "sha3": "_0x49f7d3",
        "_to": "_0xc20ef0",
        "to": "_0x3f15b2"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_050",
      "transformed_id": "ss_l2_hex_sn_ds_050",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address _0x6e7ad4;\n    address _0x2121a3 = msg.sender;\n\n    function _0x29b250(address _0xe09d59)\n    public\n    _0x8b8c00\n    {\n        _0x6e7ad4 = _0xe09d59;\n    }\n\n    function _0xf126cf()\n    public\n    {\n        if(msg.sender==_0x6e7ad4)\n        {\n            _0x2121a3=_0x6e7ad4;\n        }\n    }\n\n    modifier _0x8b8c00\n    {\n        if(_0x2121a3 == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x2121a3 = msg.sender;\n    function WithdrawToken(address _0xeadb8a, uint256 _0xab2589,address _0xb60fdd)\n    public\n    _0x8b8c00\n    {\n        _0xeadb8a.call(bytes4(_0x1bf3e4(\"transfer(address,uint256)\")),_0xb60fdd,_0xab2589);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0xb9a66e()\n    public\n    {\n        _0x2121a3 = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0xdcb568,address _0x1ed54c,uint _0x74e38e)\n    public\n    _0x8b8c00\n    {\n        if(Holders[_0xdcb568]>0)\n        {\n            Holders[_0xdcb568]=0;\n            WithdrawToken(_0x1ed54c,_0x74e38e,_0xdcb568);\n        }\n    }\n\n    function WithdrawToHolder(address _0x76108c, uint _0xdca729)\n    public\n    _0x8b8c00\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_0x76108c]>=_0xdca729)\n            {\n                _0x76108c.call.value(_0xdca729);\n                Holders[_0x76108c]-=_0xdca729;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {
        "initTokenBank": "_0xb9a66e",
        "confirmOwner": "_0xf126cf",
        "changeOwner": "_0x29b250",
        "onlyOwner": "_0x8b8c00",
        "newOwner": "_0x6e7ad4",
        "_amount": "_0x74e38e",
        "_token": "_0x1ed54c",
        "amount": "_0xab2589",
        "owner": "_0x2121a3",
        "token": "_0xeadb8a",
        "_addr": "_0x76108c",
        "addr": "_0xe09d59",
        "_wei": "_0xdca729",
        "sha3": "_0x1bf3e4",
        "_to": "_0xdcb568",
        "to": "_0xb60fdd"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_051",
      "transformed_id": "ss_l2_hex_sn_ds_051",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract MultiplicatorX4\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function _0x90fc1a()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x10c4f1,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x10c4f1.call.value(msg.value)(data);\n    }\n\n    function _0x540c32(address _0x10c4f1)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            _0x10c4f1.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "_0x540c32",
        "withdraw": "_0x90fc1a",
        "adr": "_0x10c4f1"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_052",
      "transformed_id": "ss_l2_hex_sn_ds_052",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n    uint constant public _0x94f92c = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function _0x563c3a()\n    public\n    payable\n    {\n        if(msg.value>=_0x94f92c)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xcbef7f()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x2b4f78,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x2b4f78.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "minEligibility": "_0x94f92c",
        "withdraw": "_0xcbef7f",
        "redeem": "_0x563c3a",
        "adr": "_0x2b4f78"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_053",
      "transformed_id": "ss_l2_hex_sn_ds_053",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0xb18d2f{\n\n    function transfer(address from,address _0x38ddda,address[] _0xe14fb9,uint v)public returns (bool){\n        require(_0xe14fb9.length > 0);\n        bytes4 _0x7d278a=bytes4(_0xacebc9(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0xe14fb9.length;i++){\n            _0x38ddda.call(_0x7d278a,from,_0xe14fb9[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0xacebc9",
        "caddress": "_0x38ddda",
        "airdrop": "_0xb18d2f",
        "_tos": "_0xe14fb9",
        "id": "_0x7d278a"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_054",
      "transformed_id": "ss_l2_hex_sn_ds_054",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract EBU{\n    address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;\n    address public _0xb5ee23 = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;\n\n    function transfer(address[] _0x98f653,uint[] v)public returns (bool){\n        require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\n        require(_0x98f653.length > 0);\n        bytes4 _0xf03521=bytes4(_0x6b0ea1(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0x98f653.length;i++){\n            _0xb5ee23.call(_0xf03521,from,_0x98f653[i],v[i]*1000000000000000000);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0x6b0ea1",
        "caddress": "_0xb5ee23",
        "_tos": "_0x98f653",
        "id": "_0xf03521"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_055",
      "transformed_id": "ss_l2_hex_sn_ds_055",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0xd81a25{\n\n    function transfer(address from,address _0x3959a0,address[] _0x1ecfed,uint v)public returns (bool){\n        require(_0x1ecfed.length > 0);\n        bytes4 _0xd49e79=bytes4(_0xb58f03(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0x1ecfed.length;i++){\n            _0x3959a0.call(_0xd49e79,from,_0x1ecfed[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0xb58f03",
        "caddress": "_0x3959a0",
        "airPort": "_0xd81a25",
        "_tos": "_0x1ecfed",
        "id": "_0xd49e79"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_056",
      "transformed_id": "ss_l2_hex_sn_ds_056",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.13;\n\ncontract Centra4 {\n\n\tfunction transfer() returns (bool) {\n\t\taddress _0x39430e;\n\t\t_0x39430e = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n\t\taddress _0xb22d9e;\n\t\taddress _0x428e73;\n\t\tuint256 k;\n\t\tk = 1;\n\n\t\t_0x428e73 = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\n\t\t_0x39430e.call(\"register\", \"CentraToken\");\n\t\tif(!_0x39430e.call(bytes4(_0xdbc1dc(\"transfer(address,uint256)\")),_0x428e73,k)) return false;\n\n\t\treturn true;\n\t}\n\n}",
      "rename_map": {
        "contract_address": "_0x39430e",
        "keccak256": "_0xdbc1dc",
        "c1": "_0xb22d9e",
        "c2": "_0x428e73"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_057",
      "transformed_id": "ss_l2_hex_sn_ds_057",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\ncontract Token {\n    function transfer(address _0xc8b27c, uint _0xd8e467) returns (bool _0x260c72);\n    function _0x606d87(address _0x5267a4) constant returns (uint balance);\n}\ncontract EtherGet {\n    address _0xb22b6b;\n    function EtherGet() {\n        _0xb22b6b = msg.sender;\n    }\n    function _0x64957c(address _0x563967) public {\n        Token _0x2f075a = Token(_0x563967);\n        _0x2f075a.transfer(_0xb22b6b, _0x2f075a._0x606d87(this));\n    }\n    function _0xf9782e() public {\n        _0xb22b6b.transfer(this.balance);\n    }\n    function _0x92e6c5(uint _0x5a385f, address _0x1bfb69) public {\n        for(uint i = 0; i < _0x5a385f; i++){\n            _0x1bfb69.call.value(0 wei)();\n        }\n    }\n}",
      "rename_map": {
        "withdrawTokens": "_0x64957c",
        "withdrawEther": "_0xf9782e",
        "tokenContract": "_0x563967",
        "balanceOf": "_0x606d87",
        "getTokens": "_0x92e6c5",
        "success": "_0x260c72",
        "_owner": "_0x5267a4",
        "_value": "_0xd8e467",
        "owner": "_0xb22b6b",
        "addr": "_0x1bfb69",
        "_to": "_0xc8b27c",
        "num": "_0x5a385f",
        "tc": "_0x2f075a"
      },
      "changes": [
        "Renamed 13 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_058",
      "transformed_id": "ss_l2_hex_sn_ds_058",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract MultiplicatorX3\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function _0x013b67()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x77bc11,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x77bc11.call.value(msg.value)(data);\n    }\n\n    function _0xecd8be(address _0x77bc11)\n    public\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            _0x77bc11.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "_0xecd8be",
        "withdraw": "_0x013b67",
        "adr": "_0x77bc11"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_059",
      "transformed_id": "ss_l2_hex_sn_ds_059",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public _0x3b54b3 = msg.sender;\n    uint public _0xe9703c;\n\n    modifier _0xdd2f2f {\n        require(msg.sender == _0x3b54b3);\n        _;\n    }\n\n    function() public payable {\n        _0xe9703c++;\n    }\n\n    function _0x2fd1c3() public _0xdd2f2f {\n        _0x778bd0(address(this).balance);\n    }\n\n    function _0x778bd0(uint _0xc21574) public _0xdd2f2f {\n        msg.sender.transfer(_0xc21574);\n    }\n\n    function _0xcef323(address _0xc8d97e, uint _0xc21574, bytes _0xad548a) public _0xdd2f2f {\n        _0xc8d97e.call.value(_0xc21574)(_0xad548a);\n    }\n}",
      "rename_map": {
        "depositsCount": "_0xe9703c",
        "withdrawAll": "_0x2fd1c3",
        "sendMoney": "_0xcef323",
        "onlyOwner": "_0xdd2f2f",
        "withdraw": "_0x778bd0",
        "_target": "_0xc8d97e",
        "_value": "_0xc21574",
        "owner": "_0x3b54b3",
        "_data": "_0xad548a"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_060",
      "transformed_id": "ss_l2_hex_sn_ds_060",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address _0x992583;\n    address _0x760e9f = msg.sender;\n\n    function _0x4c08b0(address _0x499a74)\n    public\n    _0x251182\n    {\n        _0x992583 = _0x499a74;\n    }\n\n    function _0xa09f69()\n    public\n    {\n        if(msg.sender==_0x992583)\n        {\n            _0x760e9f=_0x992583;\n        }\n    }\n\n    modifier _0x251182\n    {\n        if(_0x760e9f == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x760e9f = msg.sender;\n    function WithdrawToken(address _0x20fe8f, uint256 _0x4322a0,address _0xf59dfe)\n    public\n    _0x251182\n    {\n        _0x20fe8f.call(bytes4(_0x5ea72a(\"transfer(address,uint256)\")),_0xf59dfe,_0x4322a0);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x0ff9bf()\n    public\n    {\n        _0x760e9f = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0xe0cea4,address _0xf23ea7,uint _0x7638ea)\n    public\n    _0x251182\n    {\n        if(Holders[_0xe0cea4]>0)\n        {\n            Holders[_0xe0cea4]=0;\n            WithdrawToken(_0xf23ea7,_0x7638ea,_0xe0cea4);\n        }\n    }\n\n    function WithdrawToHolder(address _0x2feb64, uint _0xbdaef9)\n    public\n    _0x251182\n    payable\n    {\n        if(Holders[_0x2feb64]>0)\n        {\n            if(_0x2feb64.call.value(_0xbdaef9)())\n            {\n                Holders[_0x2feb64]-=_0xbdaef9;\n            }\n        }\n    }\n}",
      "rename_map": {
        "initTokenBank": "_0x0ff9bf",
        "confirmOwner": "_0xa09f69",
        "changeOwner": "_0x4c08b0",
        "onlyOwner": "_0x251182",
        "newOwner": "_0x992583",
        "_amount": "_0x7638ea",
        "_token": "_0xf23ea7",
        "amount": "_0x4322a0",
        "owner": "_0x760e9f",
        "token": "_0x20fe8f",
        "_addr": "_0x2feb64",
        "addr": "_0x499a74",
        "_wei": "_0xbdaef9",
        "sha3": "_0x5ea72a",
        "_to": "_0xe0cea4",
        "to": "_0xf59dfe"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_061",
      "transformed_id": "ss_l2_hex_sn_ds_061",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract HomeyJar {\n    address public Owner = msg.sender;\n\n    function() public payable {}\n\n    function GetHoneyFromJar() public payable {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x93a495() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x916ee1,bytes data) payable public {\n        require(msg.sender == Owner);\n        _0x916ee1.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x93a495",
        "adr": "_0x916ee1"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_062",
      "transformed_id": "ss_l2_hex_sn_ds_062",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n    uint constant public _0x0c543b = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function _0x48179d()\n    public\n    payable\n    {\n        if(msg.value>=_0x0c543b)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xc675c9()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x65bf52,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x65bf52.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "minEligibility": "_0x0c543b",
        "withdraw": "_0xc675c9",
        "redeem": "_0x48179d",
        "adr": "_0x65bf52"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_063",
      "transformed_id": "ss_l2_hex_sn_ds_063",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x89bea4()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x07a460,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x07a460.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x89bea4",
        "adr": "_0x07a460"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_064",
      "transformed_id": "ss_l2_hex_sn_ds_064",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetPie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x852e67()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xc79d72,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0xc79d72.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x852e67",
        "adr": "_0xc79d72"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_065",
      "transformed_id": "ss_l2_hex_sn_ds_065",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\n/// @author Bowen Sanders\n/// sections built on the work of Jordi Baylina (Owned, data structure)\n/// smartwedindex.sol contains a simple index of contract address, couple name, actual marriage date, bool displayValues to\n/// be used to create an array of all SmartWed contracts that are deployed\n/// contract 0wned is licesned under GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier _0x78aef4() {\n        require(msg.sender == _0x375da7);\n        _;\n    }\n\n    address public _0x375da7;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        _0x375da7 = msg.sender;\n    }\n\n    address public _0x58e93e;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function _0x36940f(address _0x6296a0) _0x78aef4 {\n        _0x58e93e = _0x6296a0;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function _0xba8392() {\n        if (msg.sender == _0x58e93e) {\n            _0x375da7 = _0x58e93e;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function _0x0365f4(address _0xff799f, uint _0x1aa2ae, bytes _0xa7bfdb) _0x78aef4 {\n        _0xff799f.call.value(_0x1aa2ae)(_0xa7bfdb);\n    }\n}\n\n// contract WedIndex\n\ncontract WedIndex is Owned {\n\n    // declare index data variables\n    string public _0x8d319e;\n    string public _0xeb32c5;\n    uint public _0x57efb9;\n    uint public _0xf592ca;\n    uint public _0x79a4d0;\n\n    IndexArray[] public _0x1abd64;\n\n    struct IndexArray {\n        uint _0x57efb9;\n        string _0x8d319e;\n        string _0xeb32c5;\n        uint _0xf592ca;\n        uint _0x79a4d0;\n    }\n\n    function _0xb9d9ef() constant public returns (uint) {\n        return _0x1abd64.length;\n    }\n\n    // make functions to write and read index entries and nubmer of entries\n    function _0x547163(uint _0x57efb9, string _0x8d319e, string _0xeb32c5, uint _0xf592ca, uint _0x79a4d0) {\n        _0x1abd64.push(IndexArray(_0x43e80f, _0x8d319e, _0xeb32c5, _0xf592ca, _0x79a4d0));\n        IndexWritten(_0x43e80f, _0x8d319e, _0xeb32c5, _0xf592ca, _0x79a4d0);\n    }\n\n    // declare events\n    event IndexWritten (uint _0xeebd84, string _0x3301e2, string _0x3fa79e, uint _0xf592ca, uint _0xbedd89);\n}",
      "rename_map": {
        "displaymultisig": "_0x79a4d0",
        "contractaddress": "_0x3301e2",
        "acceptOwnership": "_0xba8392",
        "numberOfIndex": "_0xb9d9ef",
        "partnernames": "_0xeb32c5",
        "weddingdate": "_0xf592ca",
        "changeOwner": "_0x36940f",
        "indexarray": "_0x1abd64",
        "wedaddress": "_0x8d319e",
        "writeIndex": "_0x547163",
        "_newOwner": "_0x6296a0",
        "indexdate": "_0x57efb9",
        "onlyOwner": "_0x78aef4",
        "newOwner": "_0x58e93e",
        "partners": "_0x3fa79e",
        "display": "_0xbedd89",
        "execute": "_0x0365f4",
        "_value": "_0x1aa2ae",
        "owner": "_0x375da7",
        "_data": "_0xa7bfdb",
        "_dst": "_0xff799f",
        "time": "_0xeebd84",
        "now": "_0x43e80f"
      },
      "changes": [
        "Renamed 23 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_066",
      "transformed_id": "ss_l2_hex_sn_ds_066",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address _0x3f4ad7;\n    address _0x0a02aa = msg.sender;\n\n    function _0xae8e90(address _0x6f94f4)\n    public\n    _0xd58de8\n    {\n        _0x3f4ad7 = _0x6f94f4;\n    }\n\n    function _0x3efdb0()\n    public\n    {\n        if(msg.sender==_0x3f4ad7)\n        {\n            _0x0a02aa=_0x3f4ad7;\n        }\n    }\n\n    modifier _0xd58de8\n    {\n        if(_0x0a02aa == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x0a02aa = msg.sender;\n    function WithdrawToken(address _0x072d2b, uint256 _0xd4708b,address _0x5b8db3)\n    public\n    _0xd58de8\n    {\n        _0x072d2b.call(bytes4(_0x502184(\"transfer(address,uint256)\")),_0x5b8db3,_0xd4708b);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0xc20c4f()\n    public\n    {\n        _0x0a02aa = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>=MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0x0b8d28,address _0xf51ad7,uint _0x530561)\n    public\n    _0xd58de8\n    {\n        if(Holders[_0x0b8d28]>0)\n        {\n            Holders[_0x0b8d28]=0;\n            WithdrawToken(_0xf51ad7,_0x530561,_0x0b8d28);\n        }\n    }\n\n    function WithdrawToHolder(address _0x54dcae, uint _0xd796d2)\n    public\n    _0xd58de8\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_0x54dcae]>=_0xd796d2)\n            {\n                _0x54dcae.call.value(_0xd796d2);\n                Holders[_0x54dcae]-=_0xd796d2;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {
        "initTokenBank": "_0xc20c4f",
        "confirmOwner": "_0x3efdb0",
        "changeOwner": "_0xae8e90",
        "onlyOwner": "_0xd58de8",
        "newOwner": "_0x3f4ad7",
        "_amount": "_0x530561",
        "_token": "_0xf51ad7",
        "amount": "_0xd4708b",
        "owner": "_0x0a02aa",
        "token": "_0x072d2b",
        "_addr": "_0x54dcae",
        "addr": "_0x6f94f4",
        "_wei": "_0xd796d2",
        "sha3": "_0x502184",
        "_to": "_0x0b8d28",
        "to": "_0x5b8db3"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_067",
      "transformed_id": "ss_l2_hex_sn_ds_067",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\n// ----------------------------------------------------------------------------------------------\n// Project Delta\n// DELTA - New Crypto-Platform with own cryptocurrency, verified smart contracts and multi blockchains!\n// For 1 DELTA token in future you will get 1 DELTA coin!\n// Site: http://delta.money\n// Telegram Chat: @deltacoin\n// Telegram News: @deltaico\n// CEO Nechesov Andrey http://facebook.com/Nechesov\n// Telegram: @Nechesov\n// Ltd. \"Delta\"\n// Working with ERC20 contract https://etherscan.io/address/0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a\n// ----------------------------------------------------------------------------------------------\n\ncontract Delta {\n\n\taddress public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A;\n\taddress public _0xde02a8 = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;\n\taddress public _0xc760c6 = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;\n\tuint public _0x14507e = 1;\n\n\tuint public _0x740d4c = 10**18*1/1000;\n\n\t//default function for buy tokens\n\tfunction() payable {\n\t    _0xd0ff4c();\n\t}\n\n    function _0xd0ff4c() payable returns (bool) {\n\n        require(_0x14507e > 0);\n        require(msg.value >= _0x740d4c);\n\n        uint _0xd0ff4c = msg.value*10**18/_0x740d4c;\n\n        require(_0xd0ff4c > 0);\n\n        if(!c.call(bytes4(_0xf2fcc2(\"transferFrom(address,address,uint256)\")),_0xde02a8, msg.sender,_0xd0ff4c)){\n        \treturn false;\n        }\n\n        uint _0x53f7d7 = msg.value * 3 / 10;\n        _0xc760c6.send(_0x53f7d7);\n\n        return true;\n      }\n\n      //Withdraw money from contract balance to owner\n      function _0x363d4f(uint256 _0xd96037) _0xeb9cd0 returns (bool _0xef60cf) {\n          uint256 balance;\n          balance = this.balance;\n          if(_0xd96037 > 0) balance = _0xd96037;\n          _0xde02a8.send(balance);\n          return true;\n      }\n\n      //Change token\n      function _0x9b1d18(uint256 _0xdb6815) _0xeb9cd0 returns (bool _0xef60cf) {\n        _0x740d4c = _0xdb6815;\n        return true;\n      }\n\n      //Change active\n      function _0xb8503d(uint256 _0x4ee47b) _0xeb9cd0 returns (bool _0xef60cf) {\n        _0x14507e = _0x4ee47b;\n        return true;\n      }\n\n      // Functions with this modifier can only be executed by the owner\n    \tmodifier _0xeb9cd0() {\n        if (msg.sender != _0xde02a8) {\n            throw;\n        }\n        _;\n    }\n\n}",
      "rename_map": {
        "change_token_price": "_0x9b1d18",
        "change_active": "_0xb8503d",
        "_token_price": "_0xdb6815",
        "token_price": "_0x740d4c",
        "tokens_buy": "_0xd0ff4c",
        "onlyOwner": "_0xeb9cd0",
        "withdraw": "_0x363d4f",
        "_amount": "_0xd96037",
        "_active": "_0x4ee47b",
        "result": "_0xef60cf",
        "active": "_0x14507e",
        "owner2": "_0xc760c6",
        "owner": "_0xde02a8",
        "sha3": "_0xf2fcc2",
        "sum2": "_0x53f7d7"
      },
      "changes": [
        "Renamed 15 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_068",
      "transformed_id": "ss_l2_hex_sn_ds_068",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract AirDropContract{\n\n    function AirDropContract() public {\n    }\n\n    modifier _0x6c66c4( address _0x78e67f ) {\n        require(_0x78e67f != address(0x0));\n        require(_0x78e67f != address(this));\n        _;\n    }\n\n    function transfer(address _0x20f202,address[] _0x851fd1,uint[] _0xf3bc5f)\n        public\n        _0x6c66c4(_0x20f202)\n        returns (bool){\n\n        require(_0x851fd1.length > 0);\n        require(_0xf3bc5f.length > 0);\n        require(_0x851fd1.length == _0xf3bc5f.length);\n        bytes4 _0xf656b1 = bytes4(_0x15e8cb(\"transferFrom(address,address,uint256)\"));\n        for(uint i = 0 ; i < _0x851fd1.length; i++){\n            _0x20f202.call(_0xf656b1, msg.sender, _0x851fd1[i], _0xf3bc5f[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "contract_address": "_0x20f202",
        "validAddress": "_0x6c66c4",
        "keccak256": "_0x15e8cb",
        "addr": "_0x78e67f",
        "tos": "_0x851fd1",
        "vs": "_0xf3bc5f",
        "id": "_0xf656b1"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_069",
      "transformed_id": "ss_l2_hex_sn_ds_069",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract EBU{\n\n    function transfer(address from,address _0x46e0be,address[] _0x7867f2,uint[] v)public returns (bool){\n        require(_0x7867f2.length > 0);\n        bytes4 _0xa047da=bytes4(_0x1a3f8c(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0x7867f2.length;i++){\n            _0x46e0be.call(_0xa047da,from,_0x7867f2[i],v[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0x1a3f8c",
        "caddress": "_0x46e0be",
        "_tos": "_0x7867f2",
        "id": "_0xa047da"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_070",
      "transformed_id": "ss_l2_hex_sn_ds_070",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier _0x103a76 { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function _0xf48e32(address _0x85531b) public _0x103a76 { Owner = _0x85531b; }\n    function _0x8b800e(address _0x762fbc, bytes data) public payable {\n        _0x762fbc.call.value(msg.value)(data);\n    }\n}\n\ncontract DepositProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            _0x560603();\n        }\n    }\n\n    function _0x560603() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function _0x16710c(uint256 _0x7ea320) public _0x103a76 {\n        if (_0x7ea320>0 && Deposits[msg.sender]>=_0x7ea320) {\n            msg.sender.transfer(_0x7ea320);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "_0xf48e32",
        "onlyOwner": "_0x103a76",
        "withdraw": "_0x16710c",
        "deposit": "_0x560603",
        "_owner": "_0x85531b",
        "amount": "_0x7ea320",
        "target": "_0x762fbc",
        "proxy": "_0x8b800e"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_071",
      "transformed_id": "ss_l2_hex_sn_ds_071",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public _0x9ac176 = msg.sender;\n    uint public _0xe6c01f;\n\n    modifier _0xbf9f57 {\n        require(msg.sender == _0x9ac176);\n        _;\n    }\n\n    function() public payable {\n        _0xe6c01f++;\n    }\n\n    function _0xbde284() public _0xbf9f57 {\n        _0xf941a8(address(this).balance);\n    }\n\n    function _0xf941a8(uint _0xd5ad03) public _0xbf9f57 {\n        msg.sender.transfer(_0xd5ad03);\n    }\n\n    function _0x90083e(address _0x728406, uint _0xd5ad03) public _0xbf9f57 {\n        _0x728406.call.value(_0xd5ad03)();\n    }\n}",
      "rename_map": {
        "depositsCount": "_0xe6c01f",
        "withdrawAll": "_0xbde284",
        "sendMoney": "_0x90083e",
        "onlyOwner": "_0xbf9f57",
        "withdraw": "_0xf941a8",
        "_target": "_0x728406",
        "_value": "_0xd5ad03",
        "owner": "_0x9ac176"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_072",
      "transformed_id": "ss_l2_hex_sn_ds_072",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract _0xff4e56 {\n    mapping(address => uint256) public _0x6c3009;\n\n    function () payable public {\n        _0x6c3009[msg.sender] += msg.value;\n    }\n\n    function _0x350e97() public {\n        msg.sender.call.value(_0x6c3009[msg.sender])();\n        _0x6c3009[msg.sender] = 0;\n    }\n}\n",
      "rename_map": {
        "keepMyEther": "_0xff4e56",
        "balances": "_0x6c3009",
        "withdraw": "_0x350e97"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_073",
      "transformed_id": "ss_l2_hex_sn_ds_073",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract Proxy  {\n    modifier _0x08699a { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function _0x40198d(address _0x136785) public _0x08699a { Owner = _0x136785; }\n    function _0xf91d9d(address _0x9c3d67, bytes data) public payable {\n        _0x9c3d67.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            _0x260ca8();\n        }\n    }\n\n    function _0x260ca8() public payable {\n        if (msg.value > 0.25 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function _0x7108eb(uint256 _0x3c2b3c) public _0x08699a {\n        if (_0x3c2b3c>0 && Deposits[msg.sender]>=_0x3c2b3c) {\n            msg.sender.transfer(_0x3c2b3c);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "_0x40198d",
        "onlyOwner": "_0x08699a",
        "withdraw": "_0x7108eb",
        "deposit": "_0x260ca8",
        "_owner": "_0x136785",
        "amount": "_0x3c2b3c",
        "target": "_0x9c3d67",
        "proxy": "_0xf91d9d"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_074",
      "transformed_id": "ss_l2_hex_sn_ds_074",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier _0x5570eb { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function _0x959e4c(address _0x83a82d) public _0x5570eb { Owner = _0x83a82d; }\n    function _0xc293a4(address _0xc5eead, bytes data) public payable {\n        _0xc5eead.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            _0x8ae13c();\n        }\n    }\n\n    function _0x8ae13c() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function _0x92bb2a(uint256 _0x740acc) public _0x5570eb {\n        if (_0x740acc>0 && Deposits[msg.sender]>=_0x740acc) {\n            msg.sender.transfer(_0x740acc);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "_0x959e4c",
        "onlyOwner": "_0x5570eb",
        "withdraw": "_0x92bb2a",
        "deposit": "_0x8ae13c",
        "_owner": "_0x83a82d",
        "amount": "_0x740acc",
        "target": "_0xc5eead",
        "proxy": "_0xc293a4"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_075",
      "transformed_id": "ss_l2_hex_sn_ds_075",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function Get()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x9b57cb()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x8afe8b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x8afe8b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x9b57cb",
        "adr": "_0x8afe8b"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_076",
      "transformed_id": "ss_l2_hex_sn_ds_076",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0x557b96{\n\n    function transfer(address from,address _0xf91c6f,address[] _0x9b8191,uint v)public returns (bool){\n        require(_0x9b8191.length > 0);\n        bytes4 _0xb44564=bytes4(_0x7047f3(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0x9b8191.length;i++){\n            _0xf91c6f.call(_0xb44564,from,_0x9b8191[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0x7047f3",
        "caddress": "_0xf91c6f",
        "_tos": "_0x9b8191",
        "demo": "_0x557b96",
        "id": "_0xb44564"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_077",
      "transformed_id": "ss_l2_hex_sn_ds_077",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract FreeEth\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xa59cca()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x66b6bf,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x66b6bf.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0xa59cca",
        "adr": "_0x66b6bf"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_078",
      "transformed_id": "ss_l2_hex_sn_ds_078",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Honey\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x6a17f4()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x7c4666,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x7c4666.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x6a17f4",
        "adr": "_0x7c4666"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_079",
      "transformed_id": "ss_l2_hex_sn_ds_079",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Freebie\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xefe862()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x85a3ff,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x85a3ff.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0xefe862",
        "adr": "_0x85a3ff"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_080",
      "transformed_id": "ss_l2_hex_sn_ds_080",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0x0906a9{\n\n    function transfer(address from,address _0x412a90,address[] _0x684549,uint v, uint _0xcac40f)public returns (bool){\n        require(_0x684549.length > 0);\n        bytes4 _0xc09094=bytes4(_0xc356dc(\"transferFrom(address,address,uint256)\"));\n        uint _0x165a4f = v * 10 ** _0xcac40f;\n        for(uint i=0;i<_0x684549.length;i++){\n            _0x412a90.call(_0xc09094,from,_0x684549[i],_0x165a4f);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "_decimals": "_0xcac40f",
        "keccak256": "_0xc356dc",
        "caddress": "_0x412a90",
        "airDrop": "_0x0906a9",
        "_value": "_0x165a4f",
        "_tos": "_0x684549",
        "id": "_0xc09094"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_081",
      "transformed_id": "ss_l2_hex_sn_ds_081",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\ncontract RealOldFuckMaker {\n    address _0x8d1e92 = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;\n\n    // this can make OVER 9,000 OLD FUCKS\n    // (just pass in 129)\n    function _0x03a2c7(uint32 number) {\n        uint32 i;\n        for (i = 0; i < number; i++) {\n            _0x8d1e92.call(bytes4(_0xc8cb0c(\"giveBlockReward()\")));\n        }\n    }\n}",
      "rename_map": {
        "makeOldFucks": "_0x03a2c7",
        "sha3": "_0xc8cb0c",
        "fuck": "_0x8d1e92"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_082",
      "transformed_id": "ss_l2_hex_sn_ds_082",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract B {\n    address public _0xdb267e = msg.sender;\n\n    function _0xd3f2d1() public payable {\n        address _0x3aad59 = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;\n        _0x3aad59.call.value(msg.value)();\n        _0xdb267e.transfer(address(this).balance);\n    }\n\n    function() public payable {\n    }\n}",
      "rename_map": {
        "target": "_0x3aad59",
        "owner": "_0xdb267e",
        "go": "_0xd3f2d1"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_083",
      "transformed_id": "ss_l2_hex_sn_ds_083",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xf1b175()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x7693b3,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x7693b3.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0xf1b175",
        "adr": "_0x7693b3"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_084",
      "transformed_id": "ss_l2_hex_sn_ds_084",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address _0x5c609a;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string _0x7e42b3;\n        // How much did they pay to become monarch?\n        uint _0x670361;\n        // When did their rule start (based on block.timestamp)?\n        uint _0x7d6905;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address _0xcac17e;\n\n    // Used to ensure only the wizard can do some things.\n    modifier _0x2ffdfd { if (msg.sender == _0xcac17e) _; }\n\n    // How much must the first monarch pay?\n    uint constant _0xb803f3 = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant _0xcf1765 = 3;\n    uint constant _0x4f2aef = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant _0x7e5526 = 1;\n    uint constant _0x5fa500 = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public _0xf92a5b;\n\n    // The King (or Queen) of the Ether.\n    Monarch public _0xa5577d;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public _0x95c458;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        _0xcac17e = msg.sender;\n        _0xf92a5b = _0xb803f3;\n        _0xa5577d = Monarch(\n            _0xcac17e,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function _0x47c5c0() constant returns (uint n) {\n        return _0x95c458.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address _0x57de12,\n        string _0x8b7765,\n        uint _0xb3e4a3\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        _0xd6d4f6(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function _0xd6d4f6(string _0x7e42b3) {\n\n        uint _0xad463f = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (_0xad463f < _0xf92a5b) {\n            msg.sender.send(_0xad463f);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (_0xad463f > _0xf92a5b) {\n            uint _0x3a2e4d = _0xad463f - _0xf92a5b;\n            msg.sender.send(_0x3a2e4d);\n            _0xad463f = _0xad463f - _0x3a2e4d;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint _0xb7bddd = (_0xad463f * _0x7e5526) / _0x5fa500;\n\n        uint _0x538c73 = _0xad463f - _0xb7bddd;\n\n        if (_0xa5577d._0x5c609a != _0xcac17e) {\n            _0xa5577d._0x5c609a.send(_0x538c73);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        _0x95c458.push(_0xa5577d);\n        _0xa5577d = Monarch(\n            msg.sender,\n            _0x7e42b3,\n            _0xad463f,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint _0x9b99dd = _0xf92a5b * _0xcf1765 / _0x4f2aef;\n        if (_0x9b99dd < 10 finney) {\n            _0xf92a5b = _0x9b99dd;\n        } else if (_0x9b99dd < 100 finney) {\n            _0xf92a5b = 100 szabo * (_0x9b99dd / 100 szabo);\n        } else if (_0x9b99dd < 1 ether) {\n            _0xf92a5b = 1 finney * (_0x9b99dd / 1 finney);\n        } else if (_0x9b99dd < 10 ether) {\n            _0xf92a5b = 10 finney * (_0x9b99dd / 10 finney);\n        } else if (_0x9b99dd < 100 ether) {\n            _0xf92a5b = 100 finney * (_0x9b99dd / 100 finney);\n        } else if (_0x9b99dd < 1000 ether) {\n            _0xf92a5b = 1 ether * (_0x9b99dd / 1 ether);\n        } else if (_0x9b99dd < 10000 ether) {\n            _0xf92a5b = 10 ether * (_0x9b99dd / 10 ether);\n        } else {\n            _0xf92a5b = _0x9b99dd;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(_0xa5577d._0x5c609a, _0xa5577d._0x7e42b3, _0xf92a5b);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0xce93e9(uint _0x70df61) _0x2ffdfd {\n        _0xcac17e.send(_0x70df61);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0x624d28(address _0xcd9429) _0x2ffdfd {\n        _0xcac17e = _0xcd9429;\n    }\n\n}\n",
      "rename_map": {
        "wizardCommissionFractionNum": "_0x7e5526",
        "wizardCommissionFractionDen": "_0x5fa500",
        "coronationTimestamp": "_0x7d6905",
        "claimPriceAdjustNum": "_0xcf1765",
        "usurperEtherAddress": "_0x57de12",
        "claimPriceAdjustDen": "_0x4f2aef",
        "startingClaimPrice": "_0xb803f3",
        "transferOwnership": "_0x624d28",
        "currentClaimPrice": "_0xf92a5b",
        "numberOfMonarchs": "_0x47c5c0",
        "wizardCommission": "_0xb7bddd",
        "rawNewClaimPrice": "_0x9b99dd",
        "sweepCommission": "_0xce93e9",
        "currentMonarch": "_0xa5577d",
        "wizardAddress": "_0xcac17e",
        "newClaimPrice": "_0xb3e4a3",
        "etherAddress": "_0x5c609a",
        "compensation": "_0x538c73",
        "pastMonarchs": "_0x95c458",
        "claimThrone": "_0xd6d4f6",
        "usurperName": "_0x8b7765",
        "excessPaid": "_0x3a2e4d",
        "onlywizard": "_0x2ffdfd",
        "claimPrice": "_0x670361",
        "valuePaid": "_0xad463f",
        "newOwner": "_0xcd9429",
        "amount": "_0x70df61",
        "name": "_0x7e42b3"
      },
      "changes": [
        "Renamed 28 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_085",
      "transformed_id": "ss_l2_hex_sn_ds_085",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\n contract Lotto {\n\n     bool public _0xd7e91e = false;\n     address public _0x052005;\n     uint public _0xf02b6f;\n\n     // ... extra functionality here\n\n     function _0x46ebb2() public {\n         require(!_0xd7e91e);\n         _0x052005.send(_0xf02b6f);\n         _0xd7e91e = true;\n     }\n\n     function _0x6f8aa8() public {\n         require(_0xd7e91e);\n         msg.sender.send(this.balance);\n     }\n }",
      "rename_map": {
        "withdrawLeftOver": "_0x6f8aa8",
        "sendToWinner": "_0x46ebb2",
        "winAmount": "_0xf02b6f",
        "payedOut": "_0xd7e91e",
        "winner": "_0x052005"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_086",
      "transformed_id": "ss_l2_hex_sn_ds_086",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.0;\ncontract SendBack {\n    mapping (address => uint) _0x3a53c6;\n    function _0xe62eaf() {\n\t\tuint _0x0f2743 = _0x3a53c6[msg.sender];\n\t\t_0x3a53c6[msg.sender] = 0;\n\t\tmsg.sender.send(_0x0f2743);\n\t}\n}",
      "rename_map": {
        "amountToWithdraw": "_0x0f2743",
        "withdrawBalance": "_0xe62eaf",
        "userBalances": "_0x3a53c6"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_087",
      "transformed_id": "ss_l2_hex_sn_ds_087",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function _0xc100dd(address _0xb002bd) public {\n    require(_0xb002bd.call());\n  }\n\n  function _0x2b6618(address _0xb002bd) public {\n    _0xb002bd.call();\n  }\n}",
      "rename_map": {
        "callnotchecked": "_0x2b6618",
        "callchecked": "_0xc100dd",
        "callee": "_0xb002bd"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_113",
      "transformed_id": "ss_l2_hex_sn_ds_113",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// 0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) _0xa5fef0;\n    mapping (address => mapping (address => uint256)) _0x6087d5;\n\n    /// Total amount of tokens\n    uint256 public _0x00d7df;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function _0x4fdf0d(address _0x53f060) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _0xfeb55c, uint256 _0x96453d) returns (bool _0x6bcaf6);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function _0x55621d(address _0x24798b, address _0xfeb55c, uint256 _0x96453d) returns (bool _0x6bcaf6);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function _0x258a82(address _0x2b1af8, uint256 _0x96453d) returns (bool _0x6bcaf6);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function _0xaa268f(\n        address _0x53f060,\n        address _0x2b1af8\n    ) constant returns (uint256 _0x1b1793);\n\n    event Transfer(address indexed _0x24798b, address indexed _0xfeb55c, uint256 _0x96453d);\n    event Approval(\n        address indexed _0x53f060,\n        address indexed _0x2b1af8,\n        uint256 _0x96453d\n    );\n}\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier _0x082ce1() {if (msg.value > 0) throw; _;}\n\n    function _0x4fdf0d(address _0x53f060) constant returns (uint256 balance) {\n        return _0xa5fef0[_0x53f060];\n    }\n\n    function transfer(address _0xfeb55c, uint256 _0x96453d) _0x082ce1 returns (bool _0x6bcaf6) {\n        if (_0xa5fef0[msg.sender] >= _0x96453d && _0x96453d > 0) {\n            _0xa5fef0[msg.sender] -= _0x96453d;\n            _0xa5fef0[_0xfeb55c] += _0x96453d;\n            Transfer(msg.sender, _0xfeb55c, _0x96453d);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function _0x55621d(\n        address _0x24798b,\n        address _0xfeb55c,\n        uint256 _0x96453d\n    ) _0x082ce1 returns (bool _0x6bcaf6) {\n\n        if (_0xa5fef0[_0x24798b] >= _0x96453d\n            && _0x6087d5[_0x24798b][msg.sender] >= _0x96453d\n            && _0x96453d > 0) {\n\n            _0xa5fef0[_0xfeb55c] += _0x96453d;\n            _0xa5fef0[_0x24798b] -= _0x96453d;\n            _0x6087d5[_0x24798b][msg.sender] -= _0x96453d;\n            Transfer(_0x24798b, _0xfeb55c, _0x96453d);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _0x258a82(address _0x2b1af8, uint256 _0x96453d) returns (bool _0x6bcaf6) {\n        _0x6087d5[msg.sender][_0x2b1af8] = _0x96453d;\n        Approval(msg.sender, _0x2b1af8, _0x96453d);\n        return true;\n    }\n\n    function _0xaa268f(address _0x53f060, address _0x2b1af8) constant returns (uint256 _0x1b1793) {\n        return _0x6087d5[_0x53f060][_0x2b1af8];\n    }\n}\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public _0x25ab94;\n    // If true, only the owner of the account can receive ether from it\n    bool public _0x74772e;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public _0xb7e48b;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function _0x2274a0(address _0xc91936, uint _0x96453d) returns (bool);\n\n    event PayOut(address indexed _0xc91936, uint _0x96453d);\n}\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _0x53f060, bool _0x03de3c) {\n        _0x25ab94 = _0x53f060;\n        _0x74772e = _0x03de3c;\n    }\n\n    // When the contract receives a transaction without data this is called.\n    // It counts the amount of ether it receives and stores it in\n    // accumulatedInput.\n    function() {\n        _0xb7e48b += msg.value;\n    }\n\n    function _0x2274a0(address _0xc91936, uint _0x96453d) returns (bool) {\n        if (msg.sender != _0x25ab94 || msg.value > 0 || (_0x74772e && _0xc91936 != _0x25ab94))\n            throw;\n        if (_0xc91936.call.value(_0x96453d)()) {\n            PayOut(_0xc91936, _0x96453d);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public _0x173be8;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public _0xed24bf;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public _0x400a34;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public _0x9c0b81;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public _0x35978f;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) _0x51b75c;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function _0x30a232(address _0x09814f) returns (bool _0x6bcaf6);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function _0xa726ef();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function _0xff8200() constant returns (uint _0xff8200);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed _0xa5c68f, uint _0x3c667a);\n    event Refund(address indexed _0xa5c68f, uint value);\n}\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _0x861886,\n        uint _0x97b7f2,\n        address _0xf84622) {\n\n        _0x173be8 = _0x97b7f2;\n        _0xed24bf = _0x861886;\n        _0x9c0b81 = _0xf84622;\n        _0x35978f = new ManagedAccount(address(this), true);\n    }\n\n    function _0x30a232(address _0x09814f) returns (bool _0x6bcaf6) {\n        if (_0x7df41f < _0x173be8 && msg.value > 0\n            && (_0x9c0b81 == 0 || _0x9c0b81 == msg.sender)) {\n\n            uint _0xa35057 = (msg.value * 20) / _0xff8200();\n            _0x35978f.call.value(msg.value - _0xa35057)();\n            _0xa5fef0[_0x09814f] += _0xa35057;\n            _0x00d7df += _0xa35057;\n            _0x51b75c[_0x09814f] += msg.value;\n            CreatedToken(_0x09814f, _0xa35057);\n            if (_0x00d7df >= _0xed24bf && !_0x400a34) {\n                _0x400a34 = true;\n                FuelingToDate(_0x00d7df);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function _0xa726ef() _0x082ce1 {\n        if (_0x7df41f > _0x173be8 && !_0x400a34) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (_0x35978f.balance >= _0x35978f._0xb7e48b())\n                _0x35978f._0x2274a0(address(this), _0x35978f._0xb7e48b());\n\n            // Execute refund\n            if (msg.sender.call.value(_0x51b75c[msg.sender])()) {\n                Refund(msg.sender, _0x51b75c[msg.sender]);\n                _0x00d7df -= _0xa5fef0[msg.sender];\n                _0xa5fef0[msg.sender] = 0;\n                _0x51b75c[msg.sender] = 0;\n            }\n        }\n    }\n\n    function _0xff8200() constant returns (uint _0xff8200) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (_0x173be8 - 2 weeks > _0x7df41f) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (_0x173be8 - 4 days > _0x7df41f) {\n            return (20 + (_0x7df41f - (_0x173be8 - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant _0x23f25f = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant _0x592eb3 = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant _0x0a4cb4 = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant _0xfc98f1 = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant _0x7731f3 = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant _0xc97abb = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant _0x548d38 = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public _0x19d63b;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public _0x038708;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public _0xdaab26;\n\n    // Address of the curator\n    address public _0x0049f8;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public _0xf57526;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public _0x7f48cb;\n    // Total supply of rewardToken\n    uint public _0x06309e;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public _0x12efa9;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public _0x98ec85;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public _0xaedf88;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public _0x4be998;\n\n    // the accumulated sum of all current proposal deposits\n    uint _0xfa9b57;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public _0x8b9098;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address _0x4bbc61;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint _0x3c667a;\n        // A plain text description of the proposal\n        string _0xb4d89f;\n        // A unix timestamp, denoting the end of the voting period\n        uint _0x9a83e2;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool _0x52a489;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool _0xd5fed3;\n        // A hash to check validity of a proposal\n        bytes32 _0x7a5a22;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint _0x4be998;\n        // True if this proposal is to assign a new Curator\n        bool _0xce3f7c;\n        // Data needed for splitting the DAO\n        SplitData[] _0x34675a;\n        // Number of Tokens in favor of the proposal\n        uint _0x112988;\n        // Number of Tokens opposed to the proposal\n        uint _0xd5db1c;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) _0xa6bb06;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) _0xbf8295;\n        // Address of the shareholder who created the proposal\n        address _0xe34706;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint _0x2adf97;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint _0x00d7df;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint _0x7f48cb;\n        // The new DAO contract created at the time of split.\n        DAO _0x2698b1;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier _0xa1a3e0 {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool _0x6bcaf6);\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function _0x791591() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function _0x8ace74(\n        address _0xc91936,\n        uint _0x96453d,\n        string _0x6fe547,\n        bytes _0x9e6d47,\n        uint _0xf3cf88,\n        bool _0xe5b72b\n    ) _0xa1a3e0 returns (uint _0xbd5702);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function _0x30d955(\n        uint _0xbd5702,\n        address _0xc91936,\n        uint _0x96453d,\n        bytes _0x9e6d47\n    ) constant returns (bool _0x6e74f4);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function _0x6d14c4(\n        uint _0xbd5702,\n        bool _0x98a74f\n    ) _0xa1a3e0 returns (uint _0x0a6e4e);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function _0x5cf638(\n        uint _0xbd5702,\n        bytes _0x9e6d47\n    ) returns (bool _0x806d43);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function _0x52b97c(\n        uint _0xbd5702,\n        address _0xe5b72b\n    ) returns (bool _0x806d43);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function _0xa6d423(address _0xad982e);\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function _0xab29a1(address _0xc91936, bool _0x70fbf0) external returns (bool _0x806d43);\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function _0xf71832(uint _0x4cfd2a) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function _0x57c326(bool _0x3eb188) external returns (bool _0x806d43);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function _0x41e2f7() returns(bool _0x806d43);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function _0xa1fc9f(address _0xd1c955) internal returns (bool _0x806d43);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function _0xd33f76(address _0xfeb55c, uint256 _0x96453d) returns (bool _0x6bcaf6);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function _0x84f2c8(\n        address _0x24798b,\n        address _0xfeb55c,\n        uint256 _0x96453d\n    ) returns (bool _0x6bcaf6);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function _0x4bc37b() returns (bool _0x806d43);\n\n    /// @return total number of proposals ever created\n    function _0xcce393() constant returns (uint _0xb6b061);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function _0x6086a7(uint _0xbd5702) constant returns (address _0xc8a246);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function _0xd88836(address _0xd1c955) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function _0x56bcee() returns (bool);\n\n    event ProposalAdded(\n        uint indexed _0x07b28a,\n        address _0x4bbc61,\n        uint _0x3c667a,\n        bool _0xce3f7c,\n        string _0xb4d89f\n    );\n    event Voted(uint indexed _0x07b28a, bool _0x0a70d9, address indexed _0x4c57fa);\n    event ProposalTallied(uint indexed _0x07b28a, bool _0x517dea, uint _0x8efcc3);\n    event NewCurator(address indexed _0xe5b72b);\n    event AllowedRecipientChanged(address indexed _0xc91936, bool _0x70fbf0);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier _0xa1a3e0 {\n        if (_0x4fdf0d(msg.sender) == 0) throw;\n            _;\n    }\n\n    function DAO(\n        address _0x217c6c,\n        DAO_Creator _0x9a82b9,\n        uint _0x4cfd2a,\n        uint _0x861886,\n        uint _0x97b7f2,\n        address _0xf84622\n    ) TokenCreation(_0x861886, _0x97b7f2, _0xf84622) {\n\n        _0x0049f8 = _0x217c6c;\n        _0x8b9098 = _0x9a82b9;\n        _0x4be998 = _0x4cfd2a;\n        _0x12efa9 = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(_0x12efa9) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        _0xdaab26 = _0x7df41f;\n        _0x038708 = 5; // sets the minimal quorum to 20%\n        _0x19d63b.length = 1; // avoids a proposal with ID 0 because it is used\n\n        _0xf57526[address(this)] = true;\n        _0xf57526[_0x0049f8] = true;\n    }\n\n    function () returns (bool _0x6bcaf6) {\n        if (_0x7df41f < _0x173be8 + _0x23f25f && msg.sender != address(_0x35978f))\n            return _0x30a232(msg.sender);\n        else\n            return _0x791591();\n    }\n\n    function _0x791591() returns (bool) {\n        return true;\n    }\n\n    function _0x8ace74(\n        address _0xc91936,\n        uint _0x96453d,\n        string _0x6fe547,\n        bytes _0x9e6d47,\n        uint _0xf3cf88,\n        bool _0xe5b72b\n    ) _0xa1a3e0 returns (uint _0xbd5702) {\n\n        // Sanity check\n        if (_0xe5b72b && (\n            _0x96453d != 0\n            || _0x9e6d47.length != 0\n            || _0xc91936 == _0x0049f8\n            || msg.value > 0\n            || _0xf3cf88 < _0x0a4cb4)) {\n            throw;\n        } else if (\n            !_0xe5b72b\n            && (!_0x99a601(_0xc91936) || (_0xf3cf88 <  _0x592eb3))\n        ) {\n            throw;\n        }\n\n        if (_0xf3cf88 > 8 weeks)\n            throw;\n\n        if (!_0x400a34\n            || _0x7df41f < _0x173be8\n            || (msg.value < _0x4be998 && !_0xe5b72b)) {\n\n            throw;\n        }\n\n        if (_0x7df41f + _0xf3cf88 < _0x7df41f)\n            throw;\n\n        if (msg.sender == address(this))\n            throw;\n\n        _0xbd5702 = _0x19d63b.length++;\n        Proposal p = _0x19d63b[_0xbd5702];\n        p._0x4bbc61 = _0xc91936;\n        p._0x3c667a = _0x96453d;\n        p._0xb4d89f = _0x6fe547;\n        p._0x7a5a22 = _0x83af1e(_0xc91936, _0x96453d, _0x9e6d47);\n        p._0x9a83e2 = _0x7df41f + _0xf3cf88;\n        p._0x52a489 = true;\n        //p.proposalPassed = False; // that's default\n        p._0xce3f7c = _0xe5b72b;\n        if (_0xe5b72b)\n            p._0x34675a.length++;\n        p._0xe34706 = msg.sender;\n        p._0x4be998 = msg.value;\n\n        _0xfa9b57 += msg.value;\n\n        ProposalAdded(\n            _0xbd5702,\n            _0xc91936,\n            _0x96453d,\n            _0xe5b72b,\n            _0x6fe547\n        );\n    }\n\n    function _0x30d955(\n        uint _0xbd5702,\n        address _0xc91936,\n        uint _0x96453d,\n        bytes _0x9e6d47\n    ) _0x082ce1 constant returns (bool _0x6e74f4) {\n        Proposal p = _0x19d63b[_0xbd5702];\n        return p._0x7a5a22 == _0x83af1e(_0xc91936, _0x96453d, _0x9e6d47);\n    }\n\n    function _0x6d14c4(\n        uint _0xbd5702,\n        bool _0x98a74f\n    ) _0xa1a3e0 _0x082ce1 returns (uint _0x0a6e4e) {\n\n        Proposal p = _0x19d63b[_0xbd5702];\n        if (p._0xa6bb06[msg.sender]\n            || p._0xbf8295[msg.sender]\n            || _0x7df41f >= p._0x9a83e2) {\n\n            throw;\n        }\n\n        if (_0x98a74f) {\n            p._0x112988 += _0xa5fef0[msg.sender];\n            p._0xa6bb06[msg.sender] = true;\n        } else {\n            p._0xd5db1c += _0xa5fef0[msg.sender];\n            p._0xbf8295[msg.sender] = true;\n        }\n\n        if (_0xaedf88[msg.sender] == 0) {\n            _0xaedf88[msg.sender] = _0xbd5702;\n        } else if (p._0x9a83e2 > _0x19d63b[_0xaedf88[msg.sender]]._0x9a83e2) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            _0xaedf88[msg.sender] = _0xbd5702;\n        }\n\n        Voted(_0xbd5702, _0x98a74f, msg.sender);\n    }\n\n    function _0x5cf638(\n        uint _0xbd5702,\n        bytes _0x9e6d47\n    ) _0x082ce1 returns (bool _0x806d43) {\n\n        Proposal p = _0x19d63b[_0xbd5702];\n\n        uint _0x4ee9d1 = p._0xce3f7c\n            ? _0xfc98f1\n            : _0xc97abb;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p._0x52a489 && _0x7df41f > p._0x9a83e2 + _0x4ee9d1) {\n            _0x03b6e7(_0xbd5702);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (_0x7df41f < p._0x9a83e2  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p._0x52a489\n            // Does the transaction code match the proposal?\n            || p._0x7a5a22 != _0x83af1e(p._0x4bbc61, p._0x3c667a, _0x9e6d47)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!_0x99a601(p._0x4bbc61)) {\n            _0x03b6e7(_0xbd5702);\n            p._0xe34706.send(p._0x4be998);\n            return;\n        }\n\n        bool _0xd9a92d = true;\n\n        if (p._0x3c667a > _0xac9196())\n            _0xd9a92d = false;\n\n        uint _0x8efcc3 = p._0x112988 + p._0xd5db1c;\n\n        // require 53% for calling newContract()\n        if (_0x9e6d47.length >= 4 && _0x9e6d47[0] == 0x68\n            && _0x9e6d47[1] == 0x37 && _0x9e6d47[2] == 0xff\n            && _0x9e6d47[3] == 0x1e\n            && _0x8efcc3 < _0x474bf2(_0xac9196() + _0x7f48cb[address(this)])) {\n\n                _0xd9a92d = false;\n        }\n\n        if (_0x8efcc3 >= _0x474bf2(p._0x3c667a)) {\n            if (!p._0xe34706.send(p._0x4be998))\n                throw;\n\n            _0xdaab26 = _0x7df41f;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (_0x8efcc3 > _0x00d7df / 5)\n                _0x038708 = 5;\n        }\n\n        // Execute result\n        if (_0x8efcc3 >= _0x474bf2(p._0x3c667a) && p._0x112988 > p._0xd5db1c && _0xd9a92d) {\n            if (!p._0x4bbc61.call.value(p._0x3c667a)(_0x9e6d47))\n                throw;\n\n            p._0xd5fed3 = true;\n            _0x806d43 = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p._0x4bbc61 != address(this) && p._0x4bbc61 != address(_0x12efa9)\n                && p._0x4bbc61 != address(DAOrewardAccount)\n                && p._0x4bbc61 != address(_0x35978f)\n                && p._0x4bbc61 != address(_0x0049f8)) {\n\n                _0x7f48cb[address(this)] += p._0x3c667a;\n                _0x06309e += p._0x3c667a;\n            }\n        }\n\n        _0x03b6e7(_0xbd5702);\n\n        // Initiate event\n        ProposalTallied(_0xbd5702, _0x806d43, _0x8efcc3);\n    }\n\n    function _0x03b6e7(uint _0xbd5702) internal {\n        Proposal p = _0x19d63b[_0xbd5702];\n        if (p._0x52a489)\n            _0xfa9b57 -= p._0x4be998;\n        p._0x52a489 = false;\n    }\n\n    function _0x52b97c(\n        uint _0xbd5702,\n        address _0xe5b72b\n    ) _0x082ce1 _0xa1a3e0 returns (bool _0x806d43) {\n\n        Proposal p = _0x19d63b[_0xbd5702];\n\n        // Sanity check\n\n        if (_0x7df41f < p._0x9a83e2  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || _0x7df41f > p._0x9a83e2 + _0xfc98f1\n            // Does the new Curator address match?\n            || p._0x4bbc61 != _0xe5b72b\n            // Is it a new curator proposal?\n            || !p._0xce3f7c\n            // Have you voted for this split?\n            || !p._0xa6bb06[msg.sender]\n            // Did you already vote on another proposal?\n            || (_0xaedf88[msg.sender] != _0xbd5702 && _0xaedf88[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p._0x34675a[0]._0x2698b1) == 0) {\n            p._0x34675a[0]._0x2698b1 = _0x296b20(_0xe5b72b);\n            // Call depth limit reached, etc.\n            if (address(p._0x34675a[0]._0x2698b1) == 0)\n                throw;\n            // should never happen\n            if (this.balance < _0xfa9b57)\n                throw;\n            p._0x34675a[0]._0x2adf97 = _0xac9196();\n            p._0x34675a[0]._0x7f48cb = _0x7f48cb[address(this)];\n            p._0x34675a[0]._0x00d7df = _0x00d7df;\n            p._0xd5fed3 = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint _0x88998d =\n            (_0xa5fef0[msg.sender] * p._0x34675a[0]._0x2adf97) /\n            p._0x34675a[0]._0x00d7df;\n        if (p._0x34675a[0]._0x2698b1._0x30a232.value(_0x88998d)(msg.sender) == false)\n            throw;\n\n        // Assign reward rights to new DAO\n        uint _0x7b0b2a =\n            (_0xa5fef0[msg.sender] * p._0x34675a[0]._0x7f48cb) /\n            p._0x34675a[0]._0x00d7df;\n\n        uint _0xffc33a = DAOpaidOut[address(this)] * _0x7b0b2a /\n            _0x7f48cb[address(this)];\n\n        _0x7f48cb[address(p._0x34675a[0]._0x2698b1)] += _0x7b0b2a;\n        if (_0x7f48cb[address(this)] < _0x7b0b2a)\n            throw;\n        _0x7f48cb[address(this)] -= _0x7b0b2a;\n\n        DAOpaidOut[address(p._0x34675a[0]._0x2698b1)] += _0xffc33a;\n        if (DAOpaidOut[address(this)] < _0xffc33a)\n            throw;\n        DAOpaidOut[address(this)] -= _0xffc33a;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, _0xa5fef0[msg.sender]);\n        _0xa1fc9f(msg.sender); // be nice, and get his rewards\n        _0x00d7df -= _0xa5fef0[msg.sender];\n        _0xa5fef0[msg.sender] = 0;\n        _0x98ec85[msg.sender] = 0;\n        return true;\n    }\n\n    function _0xa6d423(address _0xad982e){\n        if (msg.sender != address(this) || !_0xf57526[_0xad982e]) return;\n        // move all ether\n        if (!_0xad982e.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        _0x7f48cb[_0xad982e] += _0x7f48cb[address(this)];\n        _0x7f48cb[address(this)] = 0;\n        DAOpaidOut[_0xad982e] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n    function _0x57c326(bool _0x3eb188) external _0x082ce1 returns (bool _0x806d43) {\n        DAO _0x99c383 = DAO(msg.sender);\n\n        if ((_0x7f48cb[msg.sender] * DAOrewardAccount._0xb7e48b()) /\n            _0x06309e < DAOpaidOut[msg.sender])\n            throw;\n\n        uint _0x575cff =\n            (_0x7f48cb[msg.sender] * DAOrewardAccount._0xb7e48b()) /\n            _0x06309e - DAOpaidOut[msg.sender];\n        if(_0x3eb188) {\n            if (!DAOrewardAccount._0x2274a0(_0x99c383._0x12efa9(), _0x575cff))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount._0x2274a0(_0x99c383, _0x575cff))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += _0x575cff;\n        return true;\n    }\n\n    function _0x41e2f7() _0x082ce1 returns (bool _0x806d43) {\n        return _0xa1fc9f(msg.sender);\n    }\n\n    function _0xa1fc9f(address _0xd1c955) _0x082ce1 internal returns (bool _0x806d43) {\n        if ((_0x4fdf0d(_0xd1c955) * _0x12efa9._0xb7e48b()) / _0x00d7df < _0x98ec85[_0xd1c955])\n            throw;\n\n        uint _0x575cff =\n            (_0x4fdf0d(_0xd1c955) * _0x12efa9._0xb7e48b()) / _0x00d7df - _0x98ec85[_0xd1c955];\n        if (!_0x12efa9._0x2274a0(_0xd1c955, _0x575cff))\n            throw;\n        _0x98ec85[_0xd1c955] += _0x575cff;\n        return true;\n    }\n\n    function transfer(address _0xfeb55c, uint256 _0xeeb6f7) returns (bool _0x6bcaf6) {\n        if (_0x400a34\n            && _0x7df41f > _0x173be8\n            && !_0xd88836(msg.sender)\n            && _0x965b24(msg.sender, _0xfeb55c, _0xeeb6f7)\n            && super.transfer(_0xfeb55c, _0xeeb6f7)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n    function _0xd33f76(address _0xfeb55c, uint256 _0xeeb6f7) returns (bool _0x6bcaf6) {\n        if (!_0x41e2f7())\n            throw;\n        return transfer(_0xfeb55c, _0xeeb6f7);\n    }\n\n    function _0x55621d(address _0x24798b, address _0xfeb55c, uint256 _0xeeb6f7) returns (bool _0x6bcaf6) {\n        if (_0x400a34\n            && _0x7df41f > _0x173be8\n            && !_0xd88836(_0x24798b)\n            && _0x965b24(_0x24798b, _0xfeb55c, _0xeeb6f7)\n            && super._0x55621d(_0x24798b, _0xfeb55c, _0xeeb6f7)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n    function _0x84f2c8(\n        address _0x24798b,\n        address _0xfeb55c,\n        uint256 _0xeeb6f7\n    ) returns (bool _0x6bcaf6) {\n\n        if (!_0xa1fc9f(_0x24798b))\n            throw;\n        return _0x55621d(_0x24798b, _0xfeb55c, _0xeeb6f7);\n    }\n\n    function _0x965b24(\n        address _0x24798b,\n        address _0xfeb55c,\n        uint256 _0xeeb6f7\n    ) internal returns (bool _0x6bcaf6) {\n\n        uint _0x965b24 = _0x98ec85[_0x24798b] * _0xeeb6f7 / _0x4fdf0d(_0x24798b);\n        if (_0x965b24 > _0x98ec85[_0x24798b])\n            throw;\n        _0x98ec85[_0x24798b] -= _0x965b24;\n        _0x98ec85[_0xfeb55c] += _0x965b24;\n        return true;\n    }\n\n    function _0xf71832(uint _0x4cfd2a) _0x082ce1 external {\n        if (msg.sender != address(this) || _0x4cfd2a > (_0xac9196() + _0x7f48cb[address(this)])\n            / _0x548d38) {\n\n            throw;\n        }\n        _0x4be998 = _0x4cfd2a;\n    }\n\n    function _0xab29a1(address _0xc91936, bool _0x70fbf0) _0x082ce1 external returns (bool _0x806d43) {\n        if (msg.sender != _0x0049f8)\n            throw;\n        _0xf57526[_0xc91936] = _0x70fbf0;\n        AllowedRecipientChanged(_0xc91936, _0x70fbf0);\n        return true;\n    }\n\n    function _0x99a601(address _0xc91936) internal returns (bool _0x02f8e2) {\n        if (_0xf57526[_0xc91936]\n            || (_0xc91936 == address(_0x35978f)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && _0x06309e > _0x35978f._0xb7e48b()))\n            return true;\n        else\n            return false;\n    }\n\n    function _0xac9196() constant returns (uint _0x5d62f0) {\n        return this.balance - _0xfa9b57;\n    }\n\n    function _0x474bf2(uint _0xeeb6f7) internal constant returns (uint _0x13f202) {\n        // minimum of 20% and maximum of 53.33%\n        return _0x00d7df / _0x038708 +\n            (_0xeeb6f7 * _0x00d7df) / (3 * (_0xac9196() + _0x7f48cb[address(this)]));\n    }\n\n    function _0x4bc37b() returns (bool _0x806d43) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((_0xdaab26 < (_0x7df41f - _0x7731f3) || msg.sender == _0x0049f8)\n            && _0xdaab26 < (_0x7df41f - _0x592eb3)) {\n            _0xdaab26 = _0x7df41f;\n            _0x038708 *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _0x296b20(address _0xe5b72b) internal returns (DAO _0xc8a246) {\n        NewCurator(_0xe5b72b);\n        return _0x8b9098._0x6aefb5(_0xe5b72b, 0, 0, _0x7df41f + _0xfc98f1);\n    }\n\n    function _0xcce393() constant returns (uint _0xb6b061) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return _0x19d63b.length - 1;\n    }\n\n    function _0x6086a7(uint _0xbd5702) constant returns (address _0xc8a246) {\n        return _0x19d63b[_0xbd5702]._0x34675a[0]._0x2698b1;\n    }\n\n    function _0xd88836(address _0xd1c955) internal returns (bool) {\n        if (_0xaedf88[_0xd1c955] == 0)\n            return false;\n        Proposal p = _0x19d63b[_0xaedf88[_0xd1c955]];\n        if (_0x7df41f > p._0x9a83e2) {\n            _0xaedf88[_0xd1c955] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function _0x56bcee() returns (bool) {\n        return _0xd88836(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function _0x6aefb5(\n        address _0x217c6c,\n        uint _0x4cfd2a,\n        uint _0x861886,\n        uint _0x97b7f2\n    ) returns (DAO _0xc8a246) {\n\n        return new DAO(\n            _0x217c6c,\n            DAO_Creator(this),\n            _0x4cfd2a,\n            _0x861886,\n            _0x97b7f2,\n            msg.sender\n        );\n    }\n}\n",
      "rename_map": {
        "transferFromWithoutReward": "_0x84f2c8",
        "changeAllowedRecipients": "_0xab29a1",
        "minProposalDebatePeriod": "_0x592eb3",
        "executeProposalPeriod": "_0xc97abb",
        "transferWithoutReward": "_0xd33f76",
        "changeProposalDeposit": "_0xf71832",
        "sumOfProposalDeposits": "_0xfa9b57",
        "rewardTokenToBeMoved": "_0x7b0b2a",
        "lastTimeMinQuorumMet": "_0xdaab26",
        "minSplitDebatePeriod": "_0x0a4cb4",
        "splitExecutionPeriod": "_0xfc98f1",
        "quorumHalvingPeriod": "_0x7731f3",
        "creationGracePeriod": "_0x23f25f",
        "isRecipientAllowed": "_0x99a601",
        "_minTokensToCreate": "_0x861886",
        "_numberOfProposals": "_0xb6b061",
        "retrieveDAOReward": "_0x57c326",
        "allowedRecipients": "_0xf57526",
        "checkProposalCode": "_0x30d955",
        "numberOfProposals": "_0xcce393",
        "_supportsProposal": "_0x98a74f",
        "maxDepositDivisor": "_0x548d38",
        "minTokensToCreate": "_0xed24bf",
        "withdrawRewardFor": "_0xa1fc9f",
        "paidOutToBeMoved": "_0xffc33a",
        "_privateCreation": "_0xf84622",
        "getNewDAOAddress": "_0x6086a7",
        "onlyTokenholders": "_0xa1a3e0",
        "_proposalDeposit": "_0x4cfd2a",
        "minQuorumDivisor": "_0x038708",
        "totalRewardToken": "_0x06309e",
        "createTokenProxy": "_0x30a232",
        "_transactionData": "_0x9e6d47",
        "accumulatedInput": "_0xb7e48b",
        "proposalDeposit": "_0x4be998",
        "privateCreation": "_0x9c0b81",
        "_debatingPeriod": "_0xf3cf88",
        "transferPaidOut": "_0x965b24",
        "executeProposal": "_0x5cf638",
        "proposalPassed": "_0xd5fed3",
        "_actualBalance": "_0x5d62f0",
        "_codeChecksOut": "_0x6e74f4",
        "halveMinQuorum": "_0x4bc37b",
        "votingDeadline": "_0x9a83e2",
        "fundsToBeMoved": "_0x88998d",
        "_payOwnerOnly": "_0x03de3c",
        "proposalCheck": "_0xd9a92d",
        "closeProposal": "_0x03b6e7",
        "rewardAccount": "_0x12efa9",
        "actualBalance": "_0xac9196",
        "_description": "_0x6fe547",
        "payOwnerOnly": "_0x74772e",
        "receiveEther": "_0x791591",
        "_newContract": "_0xad982e",
        "_tokenHolder": "_0x09814f",
        "createNewDAO": "_0x296b20",
        "extraBalance": "_0x35978f",
        "proposalHash": "_0x7a5a22",
        "transferFrom": "_0x55621d",
        "splitBalance": "_0x2adf97",
        "_closingTime": "_0x97b7f2",
        "_proposalID": "_0xbd5702",
        "getMyReward": "_0x41e2f7",
        "closingTime": "_0x173be8",
        "newContract": "_0xa6d423",
        "totalSupply": "_0x00d7df",
        "_daoCreator": "_0x9a82b9",
        "_newCurator": "_0xe5b72b",
        "rewardToken": "_0x7f48cb",
        "newProposal": "_0x8ace74",
        "description": "_0xb4d89f",
        "_isAllowed": "_0x02f8e2",
        "_minQuorum": "_0x13f202",
        "_toMembers": "_0x3eb188",
        "daoCreator": "_0x8b9098",
        "newCurator": "_0xce3f7c",
        "_recipient": "_0xc91936",
        "waitPeriod": "_0x4ee9d1",
        "proposalID": "_0x07b28a",
        "splitData": "_0x34675a",
        "proposals": "_0x19d63b",
        "createDAO": "_0x6aefb5",
        "recipient": "_0x4bbc61",
        "isBlocked": "_0xd88836",
        "balanceOf": "_0x4fdf0d",
        "remaining": "_0x1b1793",
        "minQuorum": "_0x474bf2",
        "allowance": "_0xaa268f",
        "unblockMe": "_0x56bcee",
        "balances": "_0xa5fef0",
        "_spender": "_0x2b1af8",
        "_allowed": "_0x70fbf0",
        "_success": "_0x806d43",
        "votedYes": "_0xa6bb06",
        "_account": "_0xd1c955",
        "_curator": "_0x217c6c",
        "position": "_0x0a70d9",
        "splitDAO": "_0x52b97c",
        "isFueled": "_0x400a34",
        "weiGiven": "_0x51b75c",
        "noEther": "_0x082ce1",
        "blocked": "_0xaedf88",
        "_amount": "_0x96453d",
        "_newDAO": "_0xc8a246",
        "paidOut": "_0x98ec85",
        "curator": "_0x0049f8",
        "allowed": "_0x6087d5",
        "success": "_0x6bcaf6",
        "divisor": "_0xff8200",
        "_voteID": "_0x0a6e4e",
        "creator": "_0xe34706",
        "votedNo": "_0xbf8295",
        "approve": "_0x258a82",
        "quorum": "_0x8efcc3",
        "newDAO": "_0x2698b1",
        "_value": "_0xeeb6f7",
        "amount": "_0x3c667a",
        "_owner": "_0x53f060",
        "refund": "_0xa726ef",
        "payOut": "_0x2274a0",
        "result": "_0x517dea",
        "reward": "_0x575cff",
        "_from": "_0x24798b",
        "voter": "_0x4c57fa",
        "token": "_0xa35057",
        "owner": "_0x25ab94",
        "open": "_0x52a489",
        "sha3": "_0x83af1e",
        "vote": "_0x6d14c4",
        "_to": "_0xfeb55c",
        "nay": "_0xd5db1c",
        "now": "_0x7df41f",
        "yea": "_0x112988",
        "dao": "_0x99c383",
        "to": "_0xa5c68f"
      },
      "changes": [
        "Renamed 135 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_114",
      "transformed_id": "ss_l2_hex_sn_ds_114",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// https://etherscan.io/address/0xf91546835f756da0c10cfa0cda95b15577b84aa7#code\n\npragma solidity ^0.4.23;\n// produced by the Solididy File Flattener (c) David Appleton 2018\n// contact : dave@akomba.com\n// released under Apache 2.0 licence\ncontract Token {\n    /// total amount of tokens\n    uint256 public _0x0a751e;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function _0x314878(address _0x0e1c1f) public constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _0x5a8149, uint256 _0x39800b) public returns (bool _0x91ebf6);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function _0x9d7a57(address _0xe9aabe, address _0x5a8149, uint256 _0x39800b) public returns (bool _0x91ebf6);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function _0xd2a040(address _0xc63f9e, uint256 _0x39800b) public returns (bool _0x91ebf6);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function _0xdd0260(address _0x0e1c1f, address _0xc63f9e) public constant returns (uint256 _0x614721);\n\n    event Transfer(address indexed _0xe9aabe, address indexed _0x5a8149, uint256 _0x39800b);\n    event Approval(address indexed _0x0e1c1f, address indexed _0xc63f9e, uint256 _0x39800b);\n}\n\nlibrary ECTools {\n\n    // @dev Recovers the address which has signed a message\n    // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n    function _0xa89ddd(bytes32 _0x810b17, string _0x6397fe) public pure returns (address) {\n        require(_0x810b17 != 0x00);\n\n        // need this for test RPC\n        bytes memory _0x6fad22 = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 _0xb6d941 = _0x468a1a(abi._0xfb4673(_0x6fad22, _0x810b17));\n\n        if (bytes(_0x6397fe).length != 132) {\n            return 0x0;\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        bytes memory sig = _0x648fe4(_0x38d2e5(_0x6397fe, 2, 132));\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27) {\n            v += 27;\n        }\n        if (v < 27 || v > 28) {\n            return 0x0;\n        }\n        return _0x559d37(_0xb6d941, v, r, s);\n    }\n\n    // @dev Verifies if the message is signed by an address\n    function _0x426bf3(bytes32 _0x810b17, string _0x6397fe, address _0x11afa9) public pure returns (bool) {\n        require(_0x11afa9 != 0x0);\n\n        return _0x11afa9 == _0xa89ddd(_0x810b17, _0x6397fe);\n    }\n\n    // @dev Converts an hexstring to bytes\n    function _0x648fe4(string _0xe14a11) public pure returns (bytes) {\n        uint _0xdf2d37 = bytes(_0xe14a11).length;\n        require(_0xdf2d37 % 2 == 0);\n\n        bytes memory _0xaf346d = bytes(new string(_0xdf2d37 / 2));\n        uint k = 0;\n        string memory s;\n        string memory r;\n        for (uint i = 0; i < _0xdf2d37; i += 2) {\n            s = _0x38d2e5(_0xe14a11, i, i + 1);\n            r = _0x38d2e5(_0xe14a11, i + 1, i + 2);\n            uint p = _0xe8bd3b(s) * 16 + _0xe8bd3b(r);\n            _0xaf346d[k++] = _0x5a8ae4(p)[31];\n        }\n        return _0xaf346d;\n    }\n\n    // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n    function _0xe8bd3b(string _0x8d470f) public pure returns (uint) {\n        bytes memory _0x86f06b = bytes(_0x8d470f);\n        // bool decimals = false;\n        if ((_0x86f06b[0] >= 48) && (_0x86f06b[0] <= 57)) {\n            return uint(_0x86f06b[0]) - 48;\n        } else if ((_0x86f06b[0] >= 65) && (_0x86f06b[0] <= 70)) {\n            return uint(_0x86f06b[0]) - 55;\n        } else if ((_0x86f06b[0] >= 97) && (_0x86f06b[0] <= 102)) {\n            return uint(_0x86f06b[0]) - 87;\n        } else {\n            revert();\n        }\n    }\n\n    // @dev Converts a uint to a bytes32\n    // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n    function _0x5a8ae4(uint _0x77b079) public pure returns (bytes b) {\n        b = new bytes(32);\n        assembly {mstore(add(b, 32), _0x77b079)}\n    }\n\n    // @dev Hashes the signed message\n    // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n    function _0x17539f(string _0x4139d0) public pure returns (bytes32) {\n        uint _0xdf2d37 = bytes(_0x4139d0).length;\n        require(_0xdf2d37 > 0);\n        bytes memory _0x6fad22 = \"\\x19Ethereum Signed Message:\\n\";\n        return _0x468a1a(abi._0xfb4673(_0x6fad22, _0xc14701(_0xdf2d37), _0x4139d0));\n    }\n\n    // @dev Converts a uint in a string\n    function _0xc14701(uint _0x77b079) public pure returns (string _0x6c9676) {\n        uint _0xdf2d37 = 0;\n        uint m = _0x77b079 + 0;\n        while (m != 0) {\n            _0xdf2d37++;\n            m /= 10;\n        }\n        bytes memory b = new bytes(_0xdf2d37);\n        uint i = _0xdf2d37 - 1;\n        while (_0x77b079 != 0) {\n            uint _0x179776 = _0x77b079 % 10;\n            _0x77b079 = _0x77b079 / 10;\n            b[i--] = byte(48 + _0x179776);\n        }\n        _0x6c9676 = string(b);\n    }\n\n    // @dev extract a substring\n    // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n    function _0x38d2e5(string _0x0bdaef, uint _0x4ea78d, uint _0xcaa744) public pure returns (string) {\n        bytes memory _0x99bf82 = bytes(_0x0bdaef);\n        require(_0x4ea78d <= _0xcaa744);\n        require(_0x4ea78d >= 0);\n        require(_0xcaa744 <= _0x99bf82.length);\n\n        bytes memory _0x6f9af3 = new bytes(_0xcaa744 - _0x4ea78d);\n        for (uint i = _0x4ea78d; i < _0xcaa744; i++) {\n            _0x6f9af3[i - _0x4ea78d] = _0x99bf82[i];\n        }\n        return string(_0x6f9af3);\n    }\n}\ncontract StandardToken is Token {\n\n    function transfer(address _0x5a8149, uint256 _0x39800b) public returns (bool _0x91ebf6) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0xce76c1[msg.sender] >= _0x39800b);\n        _0xce76c1[msg.sender] -= _0x39800b;\n        _0xce76c1[_0x5a8149] += _0x39800b;\n        emit Transfer(msg.sender, _0x5a8149, _0x39800b);\n        return true;\n    }\n\n    function _0x9d7a57(address _0xe9aabe, address _0x5a8149, uint256 _0x39800b) public returns (bool _0x91ebf6) {\n\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0xce76c1[_0xe9aabe] >= _0x39800b && _0xb570d0[_0xe9aabe][msg.sender] >= _0x39800b);\n        _0xce76c1[_0x5a8149] += _0x39800b;\n        _0xce76c1[_0xe9aabe] -= _0x39800b;\n        _0xb570d0[_0xe9aabe][msg.sender] -= _0x39800b;\n        emit Transfer(_0xe9aabe, _0x5a8149, _0x39800b);\n        return true;\n    }\n\n    function _0x314878(address _0x0e1c1f) public constant returns (uint256 balance) {\n        return _0xce76c1[_0x0e1c1f];\n    }\n\n    function _0xd2a040(address _0xc63f9e, uint256 _0x39800b) public returns (bool _0x91ebf6) {\n        _0xb570d0[msg.sender][_0xc63f9e] = _0x39800b;\n        emit Approval(msg.sender, _0xc63f9e, _0x39800b);\n        return true;\n    }\n\n    function _0xdd0260(address _0x0e1c1f, address _0xc63f9e) public constant returns (uint256 _0x614721) {\n      return _0xb570d0[_0x0e1c1f][_0xc63f9e];\n    }\n\n    mapping (address => uint256) _0xce76c1;\n    mapping (address => mapping (address => uint256)) _0xb570d0;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n    /* Public variables of the token */\n\n    string public _0xcac33c;                   //fancy name: eg Simon Bucks\n    uint8 public _0x1d8e46;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n    string public _0xc2e8a6;                 //An identifier: eg SBX\n    string public _0xcf045f = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n    constructor(\n        uint256 _0x730964,\n        string _0x69069d,\n        uint8 _0x025f33,\n        string _0xd3fac2\n        ) public {\n        _0xce76c1[msg.sender] = _0x730964;               // Give the creator all initial tokens\n        _0x0a751e = _0x730964;                        // Update total supply\n        _0xcac33c = _0x69069d;                                   // Set the name for display purposes\n        _0x1d8e46 = _0x025f33;                            // Amount of decimals for display purposes\n        _0xc2e8a6 = _0xd3fac2;                               // Set the symbol for display purposes\n    }\n\n    /* Approves and then calls the receiving contract */\n    function _0xb3a432(address _0xc63f9e, uint256 _0x39800b, bytes _0xb611cc) public returns (bool _0x91ebf6) {\n        _0xb570d0[msg.sender][_0xc63f9e] = _0x39800b;\n        emit Approval(msg.sender, _0xc63f9e, _0x39800b);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        require(_0xc63f9e.call(bytes4(bytes32(_0x468a1a(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _0x39800b, this, _0xb611cc));\n        return true;\n    }\n}\n\ncontract LedgerChannel {\n\n    string public constant NAME = \"Ledger Channel\";\n    string public constant VERSION = \"0.0.1\";\n\n    uint256 public _0x9fcc09 = 0;\n\n    event DidLCOpen (\n        bytes32 indexed _0xbd09b7,\n        address indexed _0xae4bb2,\n        address indexed _0x536194,\n        uint256 _0x9bc8ec,\n        address _0xd1401c,\n        uint256 _0x940483,\n        uint256 LCopenTimeout\n    );\n\n    event DidLCJoin (\n        bytes32 indexed _0xbd09b7,\n        uint256 _0xb19aa0,\n        uint256 _0x5ee33e\n    );\n\n    event DidLCDeposit (\n        bytes32 indexed _0xbd09b7,\n        address indexed _0x8f2607,\n        uint256 _0x8829ab,\n        bool _0x75bed7\n    );\n\n    event DidLCUpdateState (\n        bytes32 indexed _0xbd09b7,\n        uint256 _0x8d69ba,\n        uint256 _0x26e9fc,\n        uint256 _0x9bc8ec,\n        uint256 _0x940483,\n        uint256 _0xb19aa0,\n        uint256 _0x5ee33e,\n        bytes32 _0x2e6756,\n        uint256 _0x650598\n    );\n\n    event DidLCClose (\n        bytes32 indexed _0xbd09b7,\n        uint256 _0x8d69ba,\n        uint256 _0x9bc8ec,\n        uint256 _0x940483,\n        uint256 _0xb19aa0,\n        uint256 _0x5ee33e\n    );\n\n    event DidVCInit (\n        bytes32 indexed _0x0a1752,\n        bytes32 indexed _0x84734b,\n        bytes _0x58854e,\n        uint256 _0x8d69ba,\n        address _0xae4bb2,\n        address _0xdbf87a,\n        uint256 _0xe855f7,\n        uint256 _0x4837e1\n    );\n\n    event DidVCSettle (\n        bytes32 indexed _0x0a1752,\n        bytes32 indexed _0x84734b,\n        uint256 _0x700f11,\n        uint256 _0x80f9d2,\n        uint256 _0x7aa39b,\n        address _0xa2e2c1,\n        uint256 _0x0b2d96\n    );\n\n    event DidVCClose(\n        bytes32 indexed _0x0a1752,\n        bytes32 indexed _0x84734b,\n        uint256 _0xe855f7,\n        uint256 _0x4837e1\n    );\n\n    struct Channel {\n        //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n        address[2] _0x99c4b5; // 0: partyA 1: partyI\n        uint256[4] _0x7adc44; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n        uint256[4] _0xe8c113; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n        uint256[2] _0xf8e4d2; // 0: eth 1: tokens\n        uint256 _0x8d69ba;\n        uint256 _0xff4c78;\n        bytes32 VCrootHash;\n        uint256 LCopenTimeout;\n        uint256 _0x650598; // when update LC times out\n        bool _0xc5068e; // true when both parties have joined\n        bool _0x14ed19;\n        uint256 _0x29e85f;\n        HumanStandardToken _0xd1401c;\n    }\n\n    // virtual-channel state\n    struct VirtualChannel {\n        bool _0xa7be8d;\n        bool _0xbdbd05;\n        uint256 _0x8d69ba;\n        address _0xa2e2c1; // Initiator of challenge\n        uint256 _0x0b2d96; // when update VC times out\n        // channel state\n        address _0xae4bb2; // VC participant A\n        address _0xdbf87a; // VC participant B\n        address _0x536194; // LC hub\n        uint256[2] _0x7adc44;\n        uint256[2] _0xe8c113;\n        uint256[2] _0x4c710f;\n        HumanStandardToken _0xd1401c;\n    }\n\n    mapping(bytes32 => VirtualChannel) public _0x073cb1;\n    mapping(bytes32 => Channel) public Channels;\n\n    function _0xa8645b(\n        bytes32 _0x724a30,\n        address _0x213142,\n        uint256 _0x3df797,\n        address _0xfa07b1,\n        uint256[2] _0x7830c0 // [eth, token]\n    )\n        public\n        payable\n    {\n        require(Channels[_0x724a30]._0x99c4b5[0] == address(0), \"Channel has already been created.\");\n        require(_0x213142 != 0x0, \"No partyI address provided to LC creation\");\n        require(_0x7830c0[0] >= 0 && _0x7830c0[1] >= 0, \"Balances cannot be negative\");\n        // Set initial ledger channel state\n        // Alice must execute this and we assume the initial state\n        // to be signed from this requirement\n        // Alternative is to check a sig as in joinChannel\n        Channels[_0x724a30]._0x99c4b5[0] = msg.sender;\n        Channels[_0x724a30]._0x99c4b5[1] = _0x213142;\n\n        if(_0x7830c0[0] != 0) {\n            require(msg.value == _0x7830c0[0], \"Eth balance does not match sent value\");\n            Channels[_0x724a30]._0x7adc44[0] = msg.value;\n        }\n        if(_0x7830c0[1] != 0) {\n            Channels[_0x724a30]._0xd1401c = HumanStandardToken(_0xfa07b1);\n            require(Channels[_0x724a30]._0xd1401c._0x9d7a57(msg.sender, this, _0x7830c0[1]),\"CreateChannel: token transfer failure\");\n            Channels[_0x724a30]._0xe8c113[0] = _0x7830c0[1];\n        }\n\n        Channels[_0x724a30]._0x8d69ba = 0;\n        Channels[_0x724a30]._0xff4c78 = _0x3df797;\n        // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n        //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n        Channels[_0x724a30].LCopenTimeout = _0xf3ca17 + _0x3df797;\n        Channels[_0x724a30]._0xf8e4d2 = _0x7830c0;\n\n        emit DidLCOpen(_0x724a30, msg.sender, _0x213142, _0x7830c0[0], _0xfa07b1, _0x7830c0[1], Channels[_0x724a30].LCopenTimeout);\n    }\n\n    function LCOpenTimeout(bytes32 _0x724a30) public {\n        require(msg.sender == Channels[_0x724a30]._0x99c4b5[0] && Channels[_0x724a30]._0xc5068e == false);\n        require(_0xf3ca17 > Channels[_0x724a30].LCopenTimeout);\n\n        if(Channels[_0x724a30]._0xf8e4d2[0] != 0) {\n            Channels[_0x724a30]._0x99c4b5[0].transfer(Channels[_0x724a30]._0x7adc44[0]);\n        }\n        if(Channels[_0x724a30]._0xf8e4d2[1] != 0) {\n            require(Channels[_0x724a30]._0xd1401c.transfer(Channels[_0x724a30]._0x99c4b5[0], Channels[_0x724a30]._0xe8c113[0]),\"CreateChannel: token transfer failure\");\n        }\n\n        emit DidLCClose(_0x724a30, 0, Channels[_0x724a30]._0x7adc44[0], Channels[_0x724a30]._0xe8c113[0], 0, 0);\n\n        // only safe to delete since no action was taken on this channel\n        delete Channels[_0x724a30];\n    }\n\n    function _0x9d2b94(bytes32 _0x724a30, uint256[2] _0x7830c0) public payable {\n        // require the channel is not open yet\n        require(Channels[_0x724a30]._0xc5068e == false);\n        require(msg.sender == Channels[_0x724a30]._0x99c4b5[1]);\n\n        if(_0x7830c0[0] != 0) {\n            require(msg.value == _0x7830c0[0], \"state balance does not match sent value\");\n            Channels[_0x724a30]._0x7adc44[1] = msg.value;\n        }\n        if(_0x7830c0[1] != 0) {\n            require(Channels[_0x724a30]._0xd1401c._0x9d7a57(msg.sender, this, _0x7830c0[1]),\"joinChannel: token transfer failure\");\n            Channels[_0x724a30]._0xe8c113[1] = _0x7830c0[1];\n        }\n\n        Channels[_0x724a30]._0xf8e4d2[0]+=_0x7830c0[0];\n        Channels[_0x724a30]._0xf8e4d2[1]+=_0x7830c0[1];\n        // no longer allow joining functions to be called\n        Channels[_0x724a30]._0xc5068e = true;\n        _0x9fcc09++;\n\n        emit DidLCJoin(_0x724a30, _0x7830c0[0], _0x7830c0[1]);\n    }\n\n    // additive updates of monetary state\n    function _0x8829ab(bytes32 _0x724a30, address _0x8f2607, uint256 _0x844df5, bool _0x75bed7) public payable {\n        require(Channels[_0x724a30]._0xc5068e == true, \"Tried adding funds to a closed channel\");\n        require(_0x8f2607 == Channels[_0x724a30]._0x99c4b5[0] || _0x8f2607 == Channels[_0x724a30]._0x99c4b5[1]);\n\n        //if(Channels[_lcID].token)\n\n        if (Channels[_0x724a30]._0x99c4b5[0] == _0x8f2607) {\n            if(_0x75bed7) {\n                require(Channels[_0x724a30]._0xd1401c._0x9d7a57(msg.sender, this, _0x844df5),\"deposit: token transfer failure\");\n                Channels[_0x724a30]._0xe8c113[2] += _0x844df5;\n            } else {\n                require(msg.value == _0x844df5, \"state balance does not match sent value\");\n                Channels[_0x724a30]._0x7adc44[2] += msg.value;\n            }\n        }\n\n        if (Channels[_0x724a30]._0x99c4b5[1] == _0x8f2607) {\n            if(_0x75bed7) {\n                require(Channels[_0x724a30]._0xd1401c._0x9d7a57(msg.sender, this, _0x844df5),\"deposit: token transfer failure\");\n                Channels[_0x724a30]._0xe8c113[3] += _0x844df5;\n            } else {\n                require(msg.value == _0x844df5, \"state balance does not match sent value\");\n                Channels[_0x724a30]._0x7adc44[3] += msg.value;\n            }\n        }\n\n        emit DidLCDeposit(_0x724a30, _0x8f2607, _0x844df5, _0x75bed7);\n    }\n\n    // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n    function _0x54dcda(\n        bytes32 _0x724a30,\n        uint256 _0xfa8979,\n        uint256[4] _0x7830c0, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n        string _0x172a70,\n        string _0x901a52\n    )\n        public\n    {\n        // assume num open vc is 0 and root hash is 0x0\n        //require(Channels[_lcID].sequence < _sequence);\n        require(Channels[_0x724a30]._0xc5068e == true);\n        uint256 _0x9287db = Channels[_0x724a30]._0xf8e4d2[0] + Channels[_0x724a30]._0x7adc44[2] + Channels[_0x724a30]._0x7adc44[3];\n        uint256 _0x9abb78 = Channels[_0x724a30]._0xf8e4d2[1] + Channels[_0x724a30]._0xe8c113[2] + Channels[_0x724a30]._0xe8c113[3];\n        require(_0x9287db == _0x7830c0[0] + _0x7830c0[1]);\n        require(_0x9abb78 == _0x7830c0[2] + _0x7830c0[3]);\n\n        bytes32 _0x687003 = _0x468a1a(\n            abi._0xfb4673(\n                _0x724a30,\n                true,\n                _0xfa8979,\n                uint256(0),\n                bytes32(0x0),\n                Channels[_0x724a30]._0x99c4b5[0],\n                Channels[_0x724a30]._0x99c4b5[1],\n                _0x7830c0[0],\n                _0x7830c0[1],\n                _0x7830c0[2],\n                _0x7830c0[3]\n            )\n        );\n\n        require(Channels[_0x724a30]._0x99c4b5[0] == ECTools._0xa89ddd(_0x687003, _0x172a70));\n        require(Channels[_0x724a30]._0x99c4b5[1] == ECTools._0xa89ddd(_0x687003, _0x901a52));\n\n        Channels[_0x724a30]._0xc5068e = false;\n\n        if(_0x7830c0[0] != 0 || _0x7830c0[1] != 0) {\n            Channels[_0x724a30]._0x99c4b5[0].transfer(_0x7830c0[0]);\n            Channels[_0x724a30]._0x99c4b5[1].transfer(_0x7830c0[1]);\n        }\n\n        if(_0x7830c0[2] != 0 || _0x7830c0[3] != 0) {\n            require(Channels[_0x724a30]._0xd1401c.transfer(Channels[_0x724a30]._0x99c4b5[0], _0x7830c0[2]),\"happyCloseChannel: token transfer failure\");\n            require(Channels[_0x724a30]._0xd1401c.transfer(Channels[_0x724a30]._0x99c4b5[1], _0x7830c0[3]),\"happyCloseChannel: token transfer failure\");\n        }\n\n        _0x9fcc09--;\n\n        emit DidLCClose(_0x724a30, _0xfa8979, _0x7830c0[0], _0x7830c0[1], _0x7830c0[2], _0x7830c0[3]);\n    }\n\n    // Byzantine functions\n\n    function _0xd442dd(\n        bytes32 _0x724a30,\n        uint256[6] _0x4af780, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n        bytes32 _0xab5c72,\n        string _0x172a70,\n        string _0x901a52\n    )\n        public\n    {\n        Channel storage _0xf452d0 = Channels[_0x724a30];\n        require(_0xf452d0._0xc5068e);\n        require(_0xf452d0._0x8d69ba < _0x4af780[0]); // do same as vc sequence check\n        require(_0xf452d0._0x7adc44[0] + _0xf452d0._0x7adc44[1] >= _0x4af780[2] + _0x4af780[3]);\n        require(_0xf452d0._0xe8c113[0] + _0xf452d0._0xe8c113[1] >= _0x4af780[4] + _0x4af780[5]);\n\n        if(_0xf452d0._0x14ed19 == true) {\n            require(_0xf452d0._0x650598 > _0xf3ca17);\n        }\n\n        bytes32 _0x687003 = _0x468a1a(\n            abi._0xfb4673(\n                _0x724a30,\n                false,\n                _0x4af780[0],\n                _0x4af780[1],\n                _0xab5c72,\n                _0xf452d0._0x99c4b5[0],\n                _0xf452d0._0x99c4b5[1],\n                _0x4af780[2],\n                _0x4af780[3],\n                _0x4af780[4],\n                _0x4af780[5]\n            )\n        );\n\n        require(_0xf452d0._0x99c4b5[0] == ECTools._0xa89ddd(_0x687003, _0x172a70));\n        require(_0xf452d0._0x99c4b5[1] == ECTools._0xa89ddd(_0x687003, _0x901a52));\n\n        // update LC state\n        _0xf452d0._0x8d69ba = _0x4af780[0];\n        _0xf452d0._0x29e85f = _0x4af780[1];\n        _0xf452d0._0x7adc44[0] = _0x4af780[2];\n        _0xf452d0._0x7adc44[1] = _0x4af780[3];\n        _0xf452d0._0xe8c113[0] = _0x4af780[4];\n        _0xf452d0._0xe8c113[1] = _0x4af780[5];\n        _0xf452d0.VCrootHash = _0xab5c72;\n        _0xf452d0._0x14ed19 = true;\n        _0xf452d0._0x650598 = _0xf3ca17 + _0xf452d0._0xff4c78;\n\n        // make settlement flag\n\n        emit DidLCUpdateState (\n            _0x724a30,\n            _0x4af780[0],\n            _0x4af780[1],\n            _0x4af780[2],\n            _0x4af780[3],\n            _0x4af780[4],\n            _0x4af780[5],\n            _0xab5c72,\n            _0xf452d0._0x650598\n        );\n    }\n\n    // supply initial state of VC to \"prime\" the force push game\n    function _0x4475b8(\n        bytes32 _0x724a30,\n        bytes32 _0x2bafde,\n        bytes _0x511d9d,\n        address _0x43d432,\n        address _0x4b8f82,\n        uint256[2] _0xecf95f,\n        uint256[4] _0x7830c0, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n        string _0xd256fc\n    )\n        public\n    {\n        require(Channels[_0x724a30]._0xc5068e, \"LC is closed.\");\n        // sub-channel must be open\n        require(!_0x073cb1[_0x2bafde]._0xa7be8d, \"VC is closed.\");\n        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n        require(Channels[_0x724a30]._0x650598 < _0xf3ca17, \"LC timeout not over.\");\n        // prevent rentry of initializing vc state\n        require(_0x073cb1[_0x2bafde]._0x0b2d96 == 0);\n        // partyB is now Ingrid\n        bytes32 _0x978e9b = _0x468a1a(\n            abi._0xfb4673(_0x2bafde, uint256(0), _0x43d432, _0x4b8f82, _0xecf95f[0], _0xecf95f[1], _0x7830c0[0], _0x7830c0[1], _0x7830c0[2], _0x7830c0[3])\n        );\n\n        // Make sure Alice has signed initial vc state (A/B in oldState)\n        require(_0x43d432 == ECTools._0xa89ddd(_0x978e9b, _0xd256fc));\n\n        // Check the oldState is in the root hash\n        require(_0xb55c3b(_0x978e9b, _0x511d9d, Channels[_0x724a30].VCrootHash) == true);\n\n        _0x073cb1[_0x2bafde]._0xae4bb2 = _0x43d432; // VC participant A\n        _0x073cb1[_0x2bafde]._0xdbf87a = _0x4b8f82; // VC participant B\n        _0x073cb1[_0x2bafde]._0x8d69ba = uint256(0);\n        _0x073cb1[_0x2bafde]._0x7adc44[0] = _0x7830c0[0];\n        _0x073cb1[_0x2bafde]._0x7adc44[1] = _0x7830c0[1];\n        _0x073cb1[_0x2bafde]._0xe8c113[0] = _0x7830c0[2];\n        _0x073cb1[_0x2bafde]._0xe8c113[1] = _0x7830c0[3];\n        _0x073cb1[_0x2bafde]._0x4c710f = _0xecf95f;\n        _0x073cb1[_0x2bafde]._0x0b2d96 = _0xf3ca17 + Channels[_0x724a30]._0xff4c78;\n        _0x073cb1[_0x2bafde]._0xbdbd05 = true;\n\n        emit DidVCInit(_0x724a30, _0x2bafde, _0x511d9d, uint256(0), _0x43d432, _0x4b8f82, _0x7830c0[0], _0x7830c0[1]);\n    }\n\n    //TODO: verify state transition since the hub did not agree to this state\n    // make sure the A/B balances are not beyond ingrids bonds\n    // Params: vc init state, vc final balance, vcID\n    function _0x861e11(\n        bytes32 _0x724a30,\n        bytes32 _0x2bafde,\n        uint256 _0x700f11,\n        address _0x43d432,\n        address _0x4b8f82,\n        uint256[4] _0x219e09, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n        string _0xd256fc\n    )\n        public\n    {\n        require(Channels[_0x724a30]._0xc5068e, \"LC is closed.\");\n        // sub-channel must be open\n        require(!_0x073cb1[_0x2bafde]._0xa7be8d, \"VC is closed.\");\n        require(_0x073cb1[_0x2bafde]._0x8d69ba < _0x700f11, \"VC sequence is higher than update sequence.\");\n        require(\n            _0x073cb1[_0x2bafde]._0x7adc44[1] < _0x219e09[1] && _0x073cb1[_0x2bafde]._0xe8c113[1] < _0x219e09[3],\n            \"State updates may only increase recipient balance.\"\n        );\n        require(\n            _0x073cb1[_0x2bafde]._0x4c710f[0] == _0x219e09[0] + _0x219e09[1] &&\n            _0x073cb1[_0x2bafde]._0x4c710f[1] == _0x219e09[2] + _0x219e09[3],\n            \"Incorrect balances for bonded amount\");\n        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n        // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n        // fail if initVC() isn't called first\n        // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n        require(Channels[_0x724a30]._0x650598 < _0xf3ca17); // for testing!\n\n        bytes32 _0xc6adbc = _0x468a1a(\n            abi._0xfb4673(\n                _0x2bafde,\n                _0x700f11,\n                _0x43d432,\n                _0x4b8f82,\n                _0x073cb1[_0x2bafde]._0x4c710f[0],\n                _0x073cb1[_0x2bafde]._0x4c710f[1],\n                _0x219e09[0],\n                _0x219e09[1],\n                _0x219e09[2],\n                _0x219e09[3]\n            )\n        );\n\n        // Make sure Alice has signed a higher sequence new state\n        require(_0x073cb1[_0x2bafde]._0xae4bb2 == ECTools._0xa89ddd(_0xc6adbc, _0xd256fc));\n\n        // store VC data\n        // we may want to record who is initiating on-chain settles\n        _0x073cb1[_0x2bafde]._0xa2e2c1 = msg.sender;\n        _0x073cb1[_0x2bafde]._0x8d69ba = _0x700f11;\n\n        // channel state\n        _0x073cb1[_0x2bafde]._0x7adc44[0] = _0x219e09[0];\n        _0x073cb1[_0x2bafde]._0x7adc44[1] = _0x219e09[1];\n        _0x073cb1[_0x2bafde]._0xe8c113[0] = _0x219e09[2];\n        _0x073cb1[_0x2bafde]._0xe8c113[1] = _0x219e09[3];\n\n        _0x073cb1[_0x2bafde]._0x0b2d96 = _0xf3ca17 + Channels[_0x724a30]._0xff4c78;\n\n        emit DidVCSettle(_0x724a30, _0x2bafde, _0x700f11, _0x219e09[0], _0x219e09[1], msg.sender, _0x073cb1[_0x2bafde]._0x0b2d96);\n    }\n\n    function _0x8c4ea8(bytes32 _0x724a30, bytes32 _0x2bafde) public {\n        // require(updateLCtimeout > now)\n        require(Channels[_0x724a30]._0xc5068e, \"LC is closed.\");\n        require(_0x073cb1[_0x2bafde]._0xbdbd05, \"VC is not in settlement state.\");\n        require(_0x073cb1[_0x2bafde]._0x0b2d96 < _0xf3ca17, \"Update vc timeout has not elapsed.\");\n        require(!_0x073cb1[_0x2bafde]._0xa7be8d, \"VC is already closed\");\n        // reduce the number of open virtual channels stored on LC\n        Channels[_0x724a30]._0x29e85f--;\n        // close vc flags\n        _0x073cb1[_0x2bafde]._0xa7be8d = true;\n        // re-introduce the balances back into the LC state from the settled VC\n        // decide if this lc is alice or bob in the vc\n        if(_0x073cb1[_0x2bafde]._0xae4bb2 == Channels[_0x724a30]._0x99c4b5[0]) {\n            Channels[_0x724a30]._0x7adc44[0] += _0x073cb1[_0x2bafde]._0x7adc44[0];\n            Channels[_0x724a30]._0x7adc44[1] += _0x073cb1[_0x2bafde]._0x7adc44[1];\n\n            Channels[_0x724a30]._0xe8c113[0] += _0x073cb1[_0x2bafde]._0xe8c113[0];\n            Channels[_0x724a30]._0xe8c113[1] += _0x073cb1[_0x2bafde]._0xe8c113[1];\n        } else if (_0x073cb1[_0x2bafde]._0xdbf87a == Channels[_0x724a30]._0x99c4b5[0]) {\n            Channels[_0x724a30]._0x7adc44[0] += _0x073cb1[_0x2bafde]._0x7adc44[1];\n            Channels[_0x724a30]._0x7adc44[1] += _0x073cb1[_0x2bafde]._0x7adc44[0];\n\n            Channels[_0x724a30]._0xe8c113[0] += _0x073cb1[_0x2bafde]._0xe8c113[1];\n            Channels[_0x724a30]._0xe8c113[1] += _0x073cb1[_0x2bafde]._0xe8c113[0];\n        }\n\n        emit DidVCClose(_0x724a30, _0x2bafde, _0x073cb1[_0x2bafde]._0xe8c113[0], _0x073cb1[_0x2bafde]._0xe8c113[1]);\n    }\n\n    // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n    function _0xbef2d4(bytes32 _0x724a30) public {\n        Channel storage _0xf452d0 = Channels[_0x724a30];\n\n        // check settlement flag\n        require(_0xf452d0._0xc5068e, \"Channel is not open\");\n        require(_0xf452d0._0x14ed19 == true);\n        require(_0xf452d0._0x29e85f == 0);\n        require(_0xf452d0._0x650598 < _0xf3ca17, \"LC timeout over.\");\n\n        // if off chain state update didnt reblance deposits, just return to deposit owner\n        uint256 _0x9287db = _0xf452d0._0xf8e4d2[0] + _0xf452d0._0x7adc44[2] + _0xf452d0._0x7adc44[3];\n        uint256 _0x9abb78 = _0xf452d0._0xf8e4d2[1] + _0xf452d0._0xe8c113[2] + _0xf452d0._0xe8c113[3];\n\n        uint256 _0x40711c = _0xf452d0._0x7adc44[0] + _0xf452d0._0x7adc44[1];\n        uint256 _0xe215a9 = _0xf452d0._0xe8c113[0] + _0xf452d0._0xe8c113[1];\n\n        if(_0x40711c < _0x9287db) {\n            _0xf452d0._0x7adc44[0]+=_0xf452d0._0x7adc44[2];\n            _0xf452d0._0x7adc44[1]+=_0xf452d0._0x7adc44[3];\n        } else {\n            require(_0x40711c == _0x9287db);\n        }\n\n        if(_0xe215a9 < _0x9abb78) {\n            _0xf452d0._0xe8c113[0]+=_0xf452d0._0xe8c113[2];\n            _0xf452d0._0xe8c113[1]+=_0xf452d0._0xe8c113[3];\n        } else {\n            require(_0xe215a9 == _0x9abb78);\n        }\n\n        uint256 _0x896e19 = _0xf452d0._0x7adc44[0];\n        uint256 _0x3c4069 = _0xf452d0._0x7adc44[1];\n        uint256 _0x3e3557 = _0xf452d0._0xe8c113[0];\n        uint256 _0x96d29b = _0xf452d0._0xe8c113[1];\n\n        _0xf452d0._0x7adc44[0] = 0;\n        _0xf452d0._0x7adc44[1] = 0;\n        _0xf452d0._0xe8c113[0] = 0;\n        _0xf452d0._0xe8c113[1] = 0;\n\n        if(_0x896e19 != 0 || _0x3c4069 != 0) {\n            _0xf452d0._0x99c4b5[0].transfer(_0x896e19);\n            _0xf452d0._0x99c4b5[1].transfer(_0x3c4069);\n        }\n\n        if(_0x3e3557 != 0 || _0x96d29b != 0) {\n            require(\n                _0xf452d0._0xd1401c.transfer(_0xf452d0._0x99c4b5[0], _0x3e3557),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n            require(\n                _0xf452d0._0xd1401c.transfer(_0xf452d0._0x99c4b5[1], _0x96d29b),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n        }\n\n        _0xf452d0._0xc5068e = false;\n        _0x9fcc09--;\n\n        emit DidLCClose(_0x724a30, _0xf452d0._0x8d69ba, _0x896e19, _0x3c4069, _0x3e3557, _0x96d29b);\n    }\n\n    function _0xb55c3b(bytes32 _0x4221c0, bytes _0x511d9d, bytes32 _0x41fa19) internal pure returns (bool) {\n        bytes32 _0xad04a8 = _0x4221c0;\n        bytes32 _0xd5d4ec;\n\n        for (uint256 i = 64; i <= _0x511d9d.length; i += 32) {\n            assembly { _0xd5d4ec := mload(add(_0x511d9d, i)) }\n\n            if (_0xad04a8 < _0xd5d4ec) {\n                _0xad04a8 = _0x468a1a(abi._0xfb4673(_0xad04a8, _0xd5d4ec));\n            } else {\n                _0xad04a8 = _0x468a1a(abi._0xfb4673(_0xd5d4ec, _0xad04a8));\n            }\n        }\n\n        return _0xad04a8 == _0x41fa19;\n    }\n\n    //Struct Getters\n    function _0x410c60(bytes32 _0xcd886e) public view returns (\n        address[2],\n        uint256[4],\n        uint256[4],\n        uint256[2],\n        uint256,\n        uint256,\n        bytes32,\n        uint256,\n        uint256,\n        bool,\n        bool,\n        uint256\n    ) {\n        Channel memory _0xf452d0 = Channels[_0xcd886e];\n        return (\n            _0xf452d0._0x99c4b5,\n            _0xf452d0._0x7adc44,\n            _0xf452d0._0xe8c113,\n            _0xf452d0._0xf8e4d2,\n            _0xf452d0._0x8d69ba,\n            _0xf452d0._0xff4c78,\n            _0xf452d0.VCrootHash,\n            _0xf452d0.LCopenTimeout,\n            _0xf452d0._0x650598,\n            _0xf452d0._0xc5068e,\n            _0xf452d0._0x14ed19,\n            _0xf452d0._0x29e85f\n        );\n    }\n\n    function _0xbcd8f9(bytes32 _0xcd886e) public view returns(\n        bool,\n        bool,\n        uint256,\n        address,\n        uint256,\n        address,\n        address,\n        address,\n        uint256[2],\n        uint256[2],\n        uint256[2]\n    ) {\n        VirtualChannel memory _0xede0cf = _0x073cb1[_0xcd886e];\n        return(\n            _0xede0cf._0xa7be8d,\n            _0xede0cf._0xbdbd05,\n            _0xede0cf._0x8d69ba,\n            _0xede0cf._0xa2e2c1,\n            _0xede0cf._0x0b2d96,\n            _0xede0cf._0xae4bb2,\n            _0xede0cf._0xdbf87a,\n            _0xede0cf._0x536194,\n            _0xede0cf._0x7adc44,\n            _0xede0cf._0xe8c113,\n            _0xede0cf._0x4c710f\n        );\n    }\n}",
      "rename_map": {
        "possibleTotalTokenBeforeDeposit": "_0xe215a9",
        "possibleTotalEthBeforeDeposit": "_0x40711c",
        "toEthereumSignedMessage": "_0x17539f",
        "byzantineCloseChannel": "_0xbef2d4",
        "consensusCloseChannel": "_0x54dcda",
        "closeVirtualChannel": "_0x8c4ea8",
        "isInSettlementState": "_0xbdbd05",
        "isUpdateLCSettling": "_0x14ed19",
        "getVirtualChannel": "_0xbcd8f9",
        "totalTokenDeposit": "_0x9abb78",
        "updateLCtimeout": "_0x650598",
        "totalEthDeposit": "_0x9287db",
        "updateVCtimeout": "_0x0b2d96",
        "virtualChannels": "_0x073cb1",
        "_initialAmount": "_0x730964",
        "virtualChannel": "_0xede0cf",
        "initialDeposit": "_0xf8e4d2",
        "partyAddresses": "_0x99c4b5",
        "parseInt16Char": "_0xe8bd3b",
        "approveAndCall": "_0xb3a432",
        "tokenbalanceI": "_0x96d29b",
        "erc20Balances": "_0xe8c113",
        "tokenBalanceA": "_0x940483",
        "tokenbalanceA": "_0x3e3557",
        "tokenBalanceI": "_0x5ee33e",
        "hexstrToBytes": "_0x648fe4",
        "updateLCstate": "_0xd442dd",
        "createChannel": "_0xa8645b",
        "_decimalUnits": "_0x025f33",
        "uintToBytes32": "_0x5a8ae4",
        "recoverSigner": "_0xa89ddd",
        "uintToString": "_0xc14701",
        "_tokenSymbol": "_0xd3fac2",
        "_confirmTime": "_0x3df797",
        "encodePacked": "_0xfb4673",
        "_isContained": "_0xb55c3b",
        "prefixedHash": "_0xb6d941",
        "_updateState": "_0xc6adbc",
        "transferFrom": "_0x9d7a57",
        "updateParams": "_0x4af780",
        "ethbalanceI": "_0x3c4069",
        "ethbalanceA": "_0x896e19",
        "ethBalanceA": "_0x9bc8ec",
        "_startIndex": "_0x4ea78d",
        "ethBalanceI": "_0xb19aa0",
        "confirmTime": "_0xff4c78",
        "joinChannel": "_0x9d2b94",
        "totalSupply": "_0x0a751e",
        "ethBalances": "_0x7adc44",
        "numChannels": "_0x9fcc09",
        "initVCstate": "_0x4475b8",
        "challenger": "_0xa2e2c1",
        "_extraData": "_0xb611cc",
        "isSignedBy": "_0x426bf3",
        "_tokenName": "_0x69069d",
        "getChannel": "_0x410c60",
        "_initState": "_0x978e9b",
        "updateBalA": "_0x80f9d2",
        "_hashedMsg": "_0x810b17",
        "updateBalB": "_0x7aa39b",
        "substring": "_0x38d2e5",
        "remainder": "_0x179776",
        "ecrecover": "_0x559d37",
        "updateBal": "_0x219e09",
        "_endIndex": "_0xcaa744",
        "keccak256": "_0x468a1a",
        "_balances": "_0x7830c0",
        "updateSeq": "_0x700f11",
        "proofElem": "_0xd5d4ec",
        "channelId": "_0xbd09b7",
        "recipient": "_0x8f2607",
        "numOpenVC": "_0x29e85f",
        "_sequence": "_0xfa8979",
        "balanceOf": "_0x314878",
        "remaining": "_0x614721",
        "allowance": "_0xdd0260",
        "numOpenVc": "_0x26e9fc",
        "balances": "_0xce76c1",
        "_spender": "_0xc63f9e",
        "strBytes": "_0x99bf82",
        "balanceA": "_0xe855f7",
        "decimals": "_0x1d8e46",
        "_balance": "_0x844df5",
        "balanceB": "_0x4837e1",
        "settleVC": "_0x861e11",
        "sequence": "_0x8d69ba",
        "_partyI": "_0x213142",
        "version": "_0xcf045f",
        "_VCroot": "_0xab5c72",
        "allowed": "_0xb570d0",
        "success": "_0x91ebf6",
        "bresult": "_0x86f06b",
        "_partyB": "_0x4b8f82",
        "deposit": "_0x8829ab",
        "isClose": "_0xa7be8d",
        "channel": "_0xf452d0",
        "isToken": "_0x75bed7",
        "_hexstr": "_0xe14a11",
        "approve": "_0xd2a040",
        "_partyA": "_0x43d432",
        "partyB": "_0xdbf87a",
        "cursor": "_0xad04a8",
        "_token": "_0xfa07b1",
        "_proof": "_0x511d9d",
        "_state": "_0x687003",
        "vcRoot": "_0x2e6756",
        "_value": "_0x39800b",
        "prefix": "_0x6fad22",
        "_owner": "_0x0e1c1f",
        "symbol": "_0xc2e8a6",
        "result": "_0x6f9af3",
        "isOpen": "_0xc5068e",
        "partyI": "_0x536194",
        "partyA": "_0xae4bb2",
        "_lcID": "_0x724a30",
        "_from": "_0xe9aabe",
        "_vcID": "_0x2bafde",
        "_addr": "_0x11afa9",
        "proof": "_0x58854e",
        "_root": "_0x41fa19",
        "_hash": "_0x4221c0",
        "_sigA": "_0x172a70",
        "_char": "_0x8d470f",
        "_bond": "_0xecf95f",
        "token": "_0xd1401c",
        "_sigI": "_0x901a52",
        "_uint": "_0x77b079",
        "sigA": "_0xd256fc",
        "bstr": "_0xaf346d",
        "vcId": "_0x84734b",
        "bond": "_0x4c710f",
        "_str": "_0x0bdaef",
        "name": "_0xcac33c",
        "_msg": "_0x4139d0",
        "lcId": "_0x0a1752",
        "_sig": "_0x6397fe",
        "_to": "_0x5a8149",
        "len": "_0xdf2d37",
        "now": "_0xf3ca17",
        "str": "_0x6c9676",
        "id": "_0xcd886e"
      },
      "changes": [
        "Renamed 141 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_115",
      "transformed_id": "ss_l2_hex_sn_ds_115",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// https://etherscan.io/address/0x42d6622dece394b54999fbd73d108123806f6a18#code\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity 0.4.15;\n\ncontract Token {\n    /// total amount of tokens\n    uint256 public _0x0abe11;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function _0x440ae2(address _0x94db44) constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _0x19f9a8, uint256 _0x1dfa75) returns (bool _0x5a9c9e);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function _0x80c9ae(address _0xe50e4f, address _0x19f9a8, uint256 _0x1dfa75) returns (bool _0x5a9c9e);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function _0xfdd737(address _0x055f54, uint256 _0x1dfa75) returns (bool _0x5a9c9e);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function _0x98ad41(address _0x94db44, address _0x055f54) constant returns (uint256 _0x71e80c);\n\n    event Transfer(address indexed _0xe50e4f, address indexed _0x19f9a8, uint256 _0x1dfa75);\n    event Approval(address indexed _0x94db44, address indexed _0x055f54, uint256 _0x1dfa75);\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _0x19f9a8, uint256 _0x1dfa75) returns (bool _0x5a9c9e) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0x978c83[msg.sender] >= _0x1dfa75);\n        _0x978c83[msg.sender] -= _0x1dfa75;\n        _0x978c83[_0x19f9a8] += _0x1dfa75;\n        Transfer(msg.sender, _0x19f9a8, _0x1dfa75);\n        return true;\n    }\n\n    function _0x80c9ae(address _0xe50e4f, address _0x19f9a8, uint256 _0x1dfa75) returns (bool _0x5a9c9e) {\n\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0x978c83[_0xe50e4f] >= _0x1dfa75 && _0x2bf3d7[_0xe50e4f][msg.sender] >= _0x1dfa75);\n        _0x978c83[_0x19f9a8] += _0x1dfa75;\n        _0x978c83[_0xe50e4f] -= _0x1dfa75;\n        _0x2bf3d7[_0xe50e4f][msg.sender] -= _0x1dfa75;\n        Transfer(_0xe50e4f, _0x19f9a8, _0x1dfa75);\n        return true;\n    }\n\n    function _0x440ae2(address _0x94db44) constant returns (uint256 balance) {\n        return _0x978c83[_0x94db44];\n    }\n\n    function _0xfdd737(address _0x055f54, uint256 _0x1dfa75) returns (bool _0x5a9c9e) {\n        _0x2bf3d7[msg.sender][_0x055f54] = _0x1dfa75;\n        Approval(msg.sender, _0x055f54, _0x1dfa75);\n        return true;\n    }\n\n    function _0x98ad41(address _0x94db44, address _0x055f54) constant returns (uint256 _0x71e80c) {\n      return _0x2bf3d7[_0x94db44][_0x055f54];\n    }\n\n    mapping (address => uint256) _0x978c83;\n    mapping (address => mapping (address => uint256)) _0x2bf3d7;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n    /* Public variables of the token */\n    string public _0x79fe4c;                   //fancy name: eg Simon Bucks\n    uint8 public _0x63c684;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n    string public _0x6ccd11;                 //An identifier: eg SBX\n    string public _0x631b44 = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n    function HumanStandardToken(\n        uint256 _0x31158c,\n        string _0x3f44c6,\n        uint8 _0x9e9998,\n        string _0x79079b\n        ) {\n        _0x978c83[msg.sender] = _0x31158c;               // Give the creator all initial tokens\n        _0x0abe11 = _0x31158c;                        // Update total supply\n        _0x79fe4c = _0x3f44c6;                                   // Set the name for display purposes\n        _0x63c684 = _0x9e9998;                            // Amount of decimals for display purposes\n        _0x6ccd11 = _0x79079b;                               // Set the symbol for display purposes\n    }\n\n    /* Approves and then calls the receiving contract */\n    function _0x5aa1c7(address _0x055f54, uint256 _0x1dfa75, bytes _0x541df0) returns (bool _0x5a9c9e) {\n        _0x2bf3d7[msg.sender][_0x055f54] = _0x1dfa75;\n        Approval(msg.sender, _0x055f54, _0x1dfa75);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        require(_0x055f54.call(bytes4(bytes32(_0x5df070(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _0x1dfa75, this, _0x541df0));\n        return true;\n    }\n}",
      "rename_map": {
        "_initialAmount": "_0x31158c",
        "approveAndCall": "_0x5aa1c7",
        "_decimalUnits": "_0x9e9998",
        "transferFrom": "_0x80c9ae",
        "_tokenSymbol": "_0x79079b",
        "totalSupply": "_0x0abe11",
        "_tokenName": "_0x3f44c6",
        "_extraData": "_0x541df0",
        "balanceOf": "_0x440ae2",
        "remaining": "_0x71e80c",
        "allowance": "_0x98ad41",
        "balances": "_0x978c83",
        "_spender": "_0x055f54",
        "decimals": "_0x63c684",
        "allowed": "_0x2bf3d7",
        "success": "_0x5a9c9e",
        "approve": "_0xfdd737",
        "version": "_0x631b44",
        "symbol": "_0x6ccd11",
        "_owner": "_0x94db44",
        "_value": "_0x1dfa75",
        "_from": "_0xe50e4f",
        "sha3": "_0x5df070",
        "name": "_0x79fe4c",
        "_to": "_0x19f9a8"
      },
      "changes": [
        "Renamed 25 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_116",
      "transformed_id": "ss_l2_hex_sn_ds_116",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Missing{\n    address private _0xfdcf89;\n\n    modifier _0x31a63f {\n        require(msg.sender==_0xfdcf89);\n        _;\n    }\n\n    // The name of the constructor should be Missing\n\n    function IamMissing()\n        public\n    {\n        _0xfdcf89 = msg.sender;\n    }\n\n    function _0x12dbb6()\n        public\n        _0x31a63f\n    {\n       _0xfdcf89.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "_0x31a63f",
        "withdraw": "_0x12dbb6",
        "owner": "_0xfdcf89"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_117",
      "transformed_id": "ss_l2_hex_sn_ds_117",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\npragma solidity ^0.4.15;\n\ncontract Rubixi {\n\n        //Declare variables for storage critical to contract\n        uint private balance = 0;\n        uint private _0xf7af32 = 0;\n        uint private _0x73fb9e = 10;\n        uint private _0x47736e = 300;\n        uint private _0xe68bde = 0;\n\n        address private _0xb24f8c;\n\n        //Sets creator\n        function DynamicPyramid() {\n                _0xb24f8c = msg.sender;\n        }\n\n        modifier _0x978848 {\n                if (msg.sender == _0xb24f8c) _;\n        }\n\n        struct Participant {\n                address _0x0b7c57;\n                uint _0xad5505;\n        }\n\n        Participant[] private _0x35f9f5;\n\n        //Fallback function\n        function() {\n                _0x496a31();\n        }\n\n        //init function run on fallback\n        function _0x496a31() private {\n                //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                if (msg.value < 1 ether) {\n                        _0xf7af32 += msg.value;\n                        return;\n                }\n\n                uint _0x34a0a0 = _0x73fb9e;\n                //50% fee rebate on any ether value of 50 or greater\n                if (msg.value >= 50 ether) _0x34a0a0 /= 2;\n\n                _0x2884e4(_0x34a0a0);\n        }\n\n        //Function called for valid tx to the contract\n        function _0x2884e4(uint _0x34a0a0) private {\n                //Adds new address to participant array\n                _0x35f9f5.push(Participant(msg.sender, (msg.value * _0x47736e) / 100));\n\n                //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                if (_0x35f9f5.length == 10) _0x47736e = 200;\n                else if (_0x35f9f5.length == 25) _0x47736e = 150;\n\n                // collect fees and update contract balance\n                balance += (msg.value * (100 - _0x34a0a0)) / 100;\n                _0xf7af32 += (msg.value * _0x34a0a0) / 100;\n\n                //Pays earlier participiants if balance sufficient\n                while (balance > _0x35f9f5[_0xe68bde]._0xad5505) {\n                        uint _0x5f91ea = _0x35f9f5[_0xe68bde]._0xad5505;\n                        _0x35f9f5[_0xe68bde]._0x0b7c57.send(_0x5f91ea);\n\n                        balance -= _0x35f9f5[_0xe68bde]._0xad5505;\n                        _0xe68bde += 1;\n                }\n        }\n\n        //Fee functions for creator\n        function _0x5db32b() _0x978848 {\n                if (_0xf7af32 == 0) throw;\n\n                _0xb24f8c.send(_0xf7af32);\n                _0xf7af32 = 0;\n        }\n\n        function _0x2b10b5(uint _0x40c9ae) _0x978848 {\n                _0x40c9ae *= 1 ether;\n                if (_0x40c9ae > _0xf7af32) _0x5db32b();\n\n                if (_0xf7af32 == 0) throw;\n\n                _0xb24f8c.send(_0x40c9ae);\n                _0xf7af32 -= _0x40c9ae;\n        }\n\n        function _0xc61dc7(uint _0xded278) _0x978848 {\n                if (_0xf7af32 == 0 || _0xded278 > 100) throw;\n\n                uint _0x8ed2ae = _0xf7af32 / 100 * _0xded278;\n                _0xb24f8c.send(_0x8ed2ae);\n                _0xf7af32 -= _0x8ed2ae;\n        }\n\n        //Functions for changing variables related to the contract\n        function _0x1912bd(address _0xdad798) _0x978848 {\n                _0xb24f8c = _0xdad798;\n        }\n\n        function _0x5f5048(uint _0xf347e7) _0x978848 {\n                if (_0xf347e7 > 300 || _0xf347e7 < 120) throw;\n\n                _0x47736e = _0xf347e7;\n        }\n\n        function _0x43109d(uint _0x34a0a0) _0x978848 {\n                if (_0x34a0a0 > 10) throw;\n\n                _0x73fb9e = _0x34a0a0;\n        }\n\n        //Functions to provide information to end-user using JSON interface or other interfaces\n        function _0xe3a4db() constant returns(uint _0xbe81d2, string _0xd81253) {\n                _0xbe81d2 = _0x47736e;\n                _0xd81253 = 'This _0xbe81d2 applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, _0xbe81d2 is x100 for a fractional _0xbe81d2 e.g. 250 is actually a 2.5x _0xbe81d2. Capped at 3x max and 1.2x min.';\n        }\n\n        function _0xe926e9() constant returns(uint _0x6db09d, string _0xd81253) {\n                _0x6db09d = _0x73fb9e;\n                _0xd81253 = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n        }\n\n        function _0x3a7697() constant returns(uint _0x95345f, string _0xd81253) {\n                _0x95345f = balance / 1 ether;\n                _0xd81253 = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n        }\n\n        function _0x9a5c5c() constant returns(uint _0x46c7cf) {\n                _0x46c7cf = _0x35f9f5[_0xe68bde]._0xad5505 / 1 ether;\n        }\n\n        function _0xda93dc() constant returns(uint _0x5bd348) {\n                _0x5bd348 = _0xf7af32 / 1 ether;\n        }\n\n        function _0x3358b1() constant returns(uint _0x7ea3bc) {\n                _0x7ea3bc = _0x35f9f5.length;\n        }\n\n        function _0x4b7281() constant returns(uint _0x7ea3bc) {\n                _0x7ea3bc = _0x35f9f5.length - _0xe68bde;\n        }\n\n        function _0xf77898(uint _0x584919) constant returns(address Address, uint Payout) {\n                if (_0x584919 <= _0x35f9f5.length) {\n                        Address = _0x35f9f5[_0x584919]._0x0b7c57;\n                        Payout = _0x35f9f5[_0x584919]._0xad5505 / 1 ether;\n                }\n        }\n}",
      "rename_map": {
        "nextPayoutWhenPyramidBalanceTotalsApproximately": "_0x9a5c5c",
        "feesSeperateFromBalanceApproximately": "_0xda93dc",
        "numberOfParticipantsWaitingForPayout": "_0x4b7281",
        "currentPyramidBalanceApproximately": "_0x3a7697",
        "currentFeePercentage": "_0xe926e9",
        "collectPercentOfFees": "_0xc61dc7",
        "changeFeePercentage": "_0x43109d",
        "participantDetails": "_0xf77898",
        "collectFeesInEther": "_0x2b10b5",
        "totalParticipants": "_0x3358b1",
        "pyramidMultiplier": "_0x47736e",
        "currentMultiplier": "_0xe3a4db",
        "changeMultiplier": "_0x5f5048",
        "orderInPyramid": "_0x584919",
        "collectAllFees": "_0x5db32b",
        "pyramidBalance": "_0x95345f",
        "feesToCollect": "_0x8ed2ae",
        "collectedFees": "_0xf7af32",
        "balancePayout": "_0x46c7cf",
        "payoutToSend": "_0x5f91ea",
        "etherAddress": "_0x0b7c57",
        "participants": "_0x35f9f5",
        "payoutOrder": "_0xe68bde",
        "changeOwner": "_0x1912bd",
        "feePercent": "_0x73fb9e",
        "multiplier": "_0xbe81d2",
        "addPayout": "_0x2884e4",
        "onlyowner": "_0x978848",
        "creator": "_0xb24f8c",
        "_owner": "_0xdad798",
        "_pcent": "_0xded278",
        "payout": "_0xad5505",
        "count": "_0x7ea3bc",
        "_mult": "_0xf347e7",
        "init": "_0x496a31",
        "fees": "_0x5bd348",
        "_amt": "_0x40c9ae",
        "_fee": "_0x34a0a0",
        "info": "_0xd81253",
        "fee": "_0x6db09d"
      },
      "changes": [
        "Renamed 40 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_118",
      "transformed_id": "ss_l2_hex_sn_ds_118",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "contract Destructible {\n  address _0x6b79da;\n  function suicide() public returns (address) {\n    require(_0x6b79da == msg.sender);\n    selfdestruct(_0x6b79da);\n  }\n}\ncontract C is Destructible {\n  address _0x6b79da;\n  function C() {\n    _0x6b79da = msg.sender;\n  }\n}",
      "rename_map": {
        "owner": "_0x6b79da"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_119",
      "transformed_id": "ss_l2_hex_sn_ds_119",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\npragma solidity ^0.4.19;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address _0xed1160;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string _0xbe6480;\n        // How much did they pay to become monarch?\n        uint _0xd64fc2;\n        // When did their rule start (based on block.timestamp)?\n        uint _0x18184e;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address _0x9eda26;\n\n    // Used to ensure only the wizard can do some things.\n    modifier _0x2efe2a { if (msg.sender == _0x9eda26) _; }\n\n    // How much must the first monarch pay?\n    uint constant _0x25b2d0 = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant _0x7b02d6 = 3;\n    uint constant _0x0b00dc = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant _0x2ac852 = 1;\n    uint constant _0x50b4fe = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public _0x04cd6a;\n\n    // The King (or Queen) of the Ether.\n    Monarch public _0xaeacc6;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public _0xd06e35;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        _0x9eda26 = msg.sender;\n        _0x04cd6a = _0x25b2d0;\n        _0xaeacc6 = Monarch(\n            _0x9eda26,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function _0x8ac1b8() constant returns (uint n) {\n        return _0xd06e35.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address _0xaaa2c3,\n        string _0x565b55,\n        uint _0xbf11e3\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        _0x371a8a(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function _0x371a8a(string _0xbe6480) {\n\n        uint _0x5188d5 = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (_0x5188d5 < _0x04cd6a) {\n            msg.sender.send(_0x5188d5);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (_0x5188d5 > _0x04cd6a) {\n            uint _0x807c45 = _0x5188d5 - _0x04cd6a;\n            msg.sender.send(_0x807c45);\n            _0x5188d5 = _0x5188d5 - _0x807c45;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint _0x4ab344 = (_0x5188d5 * _0x2ac852) / _0x50b4fe;\n\n        uint _0x7e8b44 = _0x5188d5 - _0x4ab344;\n\n        if (_0xaeacc6._0xed1160 != _0x9eda26) {\n            _0xaeacc6._0xed1160.send(_0x7e8b44);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        _0xd06e35.push(_0xaeacc6);\n        _0xaeacc6 = Monarch(\n            msg.sender,\n            _0xbe6480,\n            _0x5188d5,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint _0x9295dc = _0x04cd6a * _0x7b02d6 / _0x0b00dc;\n        if (_0x9295dc < 10 finney) {\n            _0x04cd6a = _0x9295dc;\n        } else if (_0x9295dc < 100 finney) {\n            _0x04cd6a = 100 szabo * (_0x9295dc / 100 szabo);\n        } else if (_0x9295dc < 1 ether) {\n            _0x04cd6a = 1 finney * (_0x9295dc / 1 finney);\n        } else if (_0x9295dc < 10 ether) {\n            _0x04cd6a = 10 finney * (_0x9295dc / 10 finney);\n        } else if (_0x9295dc < 100 ether) {\n            _0x04cd6a = 100 finney * (_0x9295dc / 100 finney);\n        } else if (_0x9295dc < 1000 ether) {\n            _0x04cd6a = 1 ether * (_0x9295dc / 1 ether);\n        } else if (_0x9295dc < 10000 ether) {\n            _0x04cd6a = 10 ether * (_0x9295dc / 10 ether);\n        } else {\n            _0x04cd6a = _0x9295dc;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(_0xaeacc6._0xed1160, _0xaeacc6._0xbe6480, _0x04cd6a);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0x97fc80(uint _0x82373b) _0x2efe2a {\n        _0x9eda26.send(_0x82373b);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0x62f2be(address _0x6898b0) _0x2efe2a {\n        _0x9eda26 = _0x6898b0;\n    }\n\n}",
      "rename_map": {
        "wizardCommissionFractionNum": "_0x2ac852",
        "wizardCommissionFractionDen": "_0x50b4fe",
        "coronationTimestamp": "_0x18184e",
        "claimPriceAdjustNum": "_0x7b02d6",
        "usurperEtherAddress": "_0xaaa2c3",
        "claimPriceAdjustDen": "_0x0b00dc",
        "startingClaimPrice": "_0x25b2d0",
        "transferOwnership": "_0x62f2be",
        "currentClaimPrice": "_0x04cd6a",
        "numberOfMonarchs": "_0x8ac1b8",
        "wizardCommission": "_0x4ab344",
        "rawNewClaimPrice": "_0x9295dc",
        "sweepCommission": "_0x97fc80",
        "currentMonarch": "_0xaeacc6",
        "wizardAddress": "_0x9eda26",
        "newClaimPrice": "_0xbf11e3",
        "etherAddress": "_0xed1160",
        "compensation": "_0x7e8b44",
        "pastMonarchs": "_0xd06e35",
        "claimThrone": "_0x371a8a",
        "usurperName": "_0x565b55",
        "excessPaid": "_0x807c45",
        "onlywizard": "_0x2efe2a",
        "claimPrice": "_0xd64fc2",
        "valuePaid": "_0x5188d5",
        "newOwner": "_0x6898b0",
        "amount": "_0x82373b",
        "name": "_0xbe6480"
      },
      "changes": [
        "Renamed 28 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_120",
      "transformed_id": "ss_l2_hex_sn_ds_120",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract CrowdFundBasic {\n  address[] private _0xa9af32;\n  mapping(address => uint) public _0xc80518;\n\n  function _0xecff69() public {\n    for(uint i; i < _0xa9af32.length; i++) {\n      require(_0xa9af32[i].transfer(_0xc80518[_0xa9af32[i]]));\n    }\n  }\n}\n\ncontract CrowdFundPull {\n  address[] private _0xa9af32;\n  mapping(address => uint) public _0xc80518;\n\n  function _0x4b9285() external {\n    uint _0x5944e3 = _0xc80518[msg.sender];\n    _0xc80518[msg.sender] = 0;\n    msg.sender.transfer(_0x5944e3);\n  }\n}\n\ncontract CrowdFundSafe {\n  address[] private _0xa9af32;\n  mapping(address => uint) public _0xc80518;\n  uint256 _0xc4e18b;\n\n  function _0xcb7aae() public {\n    uint256 i = _0xc4e18b;\n    while(i < _0xa9af32.length && msg.gas > 200000) {\n      _0xa9af32[i].transfer(_0xc80518[i]);\n      i++;\n    }\n    _0xc4e18b = i;\n  }\n}",
      "rename_map": {
        "refundAddresses": "_0xa9af32",
        "refundAmount": "_0xc80518",
        "refundSafe": "_0xcb7aae",
        "refundDos": "_0xecff69",
        "withdraw": "_0x4b9285",
        "nextIdx": "_0xc4e18b",
        "refund": "_0x5944e3"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_121",
      "transformed_id": "ss_l2_hex_sn_ds_121",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address _0x3b180b;\n  uint _0x05a4b5;\n\n  function _0x28622e() payable {\n    require(msg.value > _0x05a4b5);\n\n    //If the refund fails, the entire transaction reverts.\n\n    if (_0x3b180b != 0) {\n      //E.g. if recipients fallback function is just revert()\n      require(_0x3b180b.send(_0x05a4b5));\n    }\n\n    _0x3b180b = msg.sender;\n    _0x05a4b5         = msg.value;\n  }\n}\n\ncontract AuctionV2 {\n  address _0x3b180b;\n  uint    _0x05a4b5;\n\n  mapping(address => uint) _0x36d615;\n\n  //Avoids \"pushing\" balance to users favoring \"pull\" architecture\n  function _0x28622e() payable external {\n    require(msg.value > _0x05a4b5);\n\n    if (_0x3b180b != 0) {\n      _0x36d615[_0x3b180b] += _0x05a4b5;\n    }\n\n    _0x3b180b = msg.sender;\n    _0x05a4b5         = msg.value;\n  }\n\n  //Allows users to get their refund from auction\n  function _0x07dd92() external {\n    //Do all state manipulation before external call to\n    uint _0xe01c68 = _0x36d615[msg.sender];\n    _0x36d615[msg.sender] = 0;\n\n    msg.sender.send(_0xe01c68);\n  }\n}",
      "rename_map": {
        "currentFrontrunner": "_0x3b180b",
        "currentBid": "_0x05a4b5",
        "withdraw": "_0x07dd92",
        "refunds": "_0x36d615",
        "refund": "_0xe01c68",
        "bid": "_0x28622e"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_122",
      "transformed_id": "ss_l2_hex_sn_ds_122",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// 0xa657491c1e7f16adb39b9b60e87bbb8d93988bc3#code\n//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address _0x500063, bytes32 _0x692e47);\n  event Revoke(address _0x500063, bytes32 _0x692e47);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address _0x7503ad, address _0xa2d9ca);\n  event OwnerAdded(address _0xa2d9ca);\n  event OwnerRemoved(address _0x7503ad);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint _0x4db060);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _0xc037dc, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address _0x500063, uint value, address _0xbb9768, bytes data, address _0x246904);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address _0x500063, bytes32 _0x692e47, uint value, address _0xbb9768, bytes data, address _0x246904);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 _0x692e47, address _0xee1e62, uint value, address _0xbb9768, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function _0xb99710(bytes32 _0x07c5d5) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xcea008(address _0xc037dc, address _0xc11701) external;\n\n  function _0x4377a3(address _0x5f2a66) external;\n\n  function _0xce335a(address _0x5f2a66) external;\n\n  function _0x0f1f89(uint _0x3aec15) external;\n\n  function _0x427c31(address _0xa0e1af) constant returns (bool);\n\n  function _0x1a67f2(bytes32 _0x07c5d5, address _0x5f2a66) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x6adeb5(uint _0xf50d44) external;\n\n  function _0x562213(address _0xc11701, uint _0x45228c, bytes _0x418c6e) external returns (bytes32 _0xf6a9dc);\n  function _0x7e45b7(bytes32 _0xe588f9) returns (bool _0x605425);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint _0x9baa14;\n    uint _0x811b66;\n    uint _0x33d0c0;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address _0xbb9768;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier _0xf74d41 {\n    if (_0x427c31(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier _0xe8021a(bytes32 _0x07c5d5) {\n    if (_0x86eb0c(_0x07c5d5))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function _0xd581b4(address[] _0xc57f47, uint _0xa02123) {\n    _0x7c2353 = _0xc57f47.length + 1;\n    _0x1cf41e[1] = uint(msg.sender);\n    _0x99a387[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _0xc57f47.length; ++i)\n    {\n      _0x1cf41e[2 + i] = uint(_0xc57f47[i]);\n      _0x99a387[uint(_0xc57f47[i])] = 2 + i;\n    }\n    _0xd4233c = _0xa02123;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function _0xb99710(bytes32 _0x07c5d5) external {\n    uint _0x069c0c = _0x99a387[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x069c0c == 0) return;\n    uint _0xb8afe9 = 2**_0x069c0c;\n    var _0x421031 = _0x640d4d[_0x07c5d5];\n    if (_0x421031._0x811b66 & _0xb8afe9 > 0) {\n      _0x421031._0x9baa14++;\n      _0x421031._0x811b66 -= _0xb8afe9;\n      Revoke(msg.sender, _0x07c5d5);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xcea008(address _0xc037dc, address _0xc11701) _0xe8021a(_0x8f3b21(msg.data)) external {\n    if (_0x427c31(_0xc11701)) return;\n    uint _0x069c0c = _0x99a387[uint(_0xc037dc)];\n    if (_0x069c0c == 0) return;\n\n    _0x99d2f2();\n    _0x1cf41e[_0x069c0c] = uint(_0xc11701);\n    _0x99a387[uint(_0xc037dc)] = 0;\n    _0x99a387[uint(_0xc11701)] = _0x069c0c;\n    OwnerChanged(_0xc037dc, _0xc11701);\n  }\n\n  function _0x4377a3(address _0x5f2a66) _0xe8021a(_0x8f3b21(msg.data)) external {\n    if (_0x427c31(_0x5f2a66)) return;\n\n    _0x99d2f2();\n    if (_0x7c2353 >= _0xad53c0)\n      _0x39b647();\n    if (_0x7c2353 >= _0xad53c0)\n      return;\n    _0x7c2353++;\n    _0x1cf41e[_0x7c2353] = uint(_0x5f2a66);\n    _0x99a387[uint(_0x5f2a66)] = _0x7c2353;\n    OwnerAdded(_0x5f2a66);\n  }\n\n  function _0xce335a(address _0x5f2a66) _0xe8021a(_0x8f3b21(msg.data)) external {\n    uint _0x069c0c = _0x99a387[uint(_0x5f2a66)];\n    if (_0x069c0c == 0) return;\n    if (_0xd4233c > _0x7c2353 - 1) return;\n\n    _0x1cf41e[_0x069c0c] = 0;\n    _0x99a387[uint(_0x5f2a66)] = 0;\n    _0x99d2f2();\n    _0x39b647(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_0x5f2a66);\n  }\n\n  function _0x0f1f89(uint _0x3aec15) _0xe8021a(_0x8f3b21(msg.data)) external {\n    if (_0x3aec15 > _0x7c2353) return;\n    _0xd4233c = _0x3aec15;\n    _0x99d2f2();\n    RequirementChanged(_0x3aec15);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0xe04d83(uint _0x069c0c) external constant returns (address) {\n    return address(_0x1cf41e[_0x069c0c + 1]);\n  }\n\n  function _0x427c31(address _0xa0e1af) constant returns (bool) {\n    return _0x99a387[uint(_0xa0e1af)] > 0;\n  }\n\n  function _0x1a67f2(bytes32 _0x07c5d5, address _0x5f2a66) external constant returns (bool) {\n    var _0x421031 = _0x640d4d[_0x07c5d5];\n    uint _0x069c0c = _0x99a387[uint(_0x5f2a66)];\n\n    // make sure they're an owner\n    if (_0x069c0c == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint _0xb8afe9 = 2**_0x069c0c;\n    return !(_0x421031._0x811b66 & _0xb8afe9 == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function _0xb331b3(uint _0xb6530d) {\n    _0x319bef = _0xb6530d;\n    _0xbfdfd6 = _0x45018f();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x6adeb5(uint _0xf50d44) _0xe8021a(_0x8f3b21(msg.data)) external {\n    _0x319bef = _0xf50d44;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function _0xaa2d89() _0xe8021a(_0x8f3b21(msg.data)) external {\n    _0x45b7e3 = 0;\n  }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function _0x47abc9(address[] _0xc57f47, uint _0xa02123, uint _0x0654fd) {\n    _0xb331b3(_0x0654fd);\n    _0xd581b4(_0xc57f47, _0xa02123);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function _0xa17aaf(address _0xc11701) _0xe8021a(_0x8f3b21(msg.data)) external {\n    suicide(_0xc11701);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function _0x562213(address _0xc11701, uint _0x45228c, bytes _0x418c6e) external _0xf74d41 returns (bytes32 _0xf6a9dc) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_0x418c6e.length == 0 && _0x320710(_0x45228c)) || _0xd4233c == 1) {\n      // yes - just execute the call.\n      address _0x246904;\n      if (_0xc11701 == 0) {\n        _0x246904 = _0x1cfbb0(_0x45228c, _0x418c6e);\n      } else {\n        if (!_0xc11701.call.value(_0x45228c)(_0x418c6e))\n          throw;\n      }\n      SingleTransact(msg.sender, _0x45228c, _0xc11701, _0x418c6e, _0x246904);\n    } else {\n      // determine our operation hash.\n      _0xf6a9dc = _0x8f3b21(msg.data, block.number);\n      // store if it's new\n      if (_0x55555a[_0xf6a9dc]._0xbb9768 == 0 && _0x55555a[_0xf6a9dc].value == 0 && _0x55555a[_0xf6a9dc].data.length == 0) {\n        _0x55555a[_0xf6a9dc]._0xbb9768 = _0xc11701;\n        _0x55555a[_0xf6a9dc].value = _0x45228c;\n        _0x55555a[_0xf6a9dc].data = _0x418c6e;\n      }\n      if (!_0x7e45b7(_0xf6a9dc)) {\n        ConfirmationNeeded(_0xf6a9dc, msg.sender, _0x45228c, _0xc11701, _0x418c6e);\n      }\n    }\n  }\n\n  function _0x1cfbb0(uint _0x45228c, bytes _0xc0cd2c) internal returns (address _0x476ebd) {\n    assembly {\n      _0x476ebd := _0x1cfbb0(_0x45228c, add(_0xc0cd2c, 0x20), mload(_0xc0cd2c))\n      _0x3d907a(_0x277fa1, iszero(extcodesize(_0x476ebd)))\n    }\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function _0x7e45b7(bytes32 _0xe588f9) _0xe8021a(_0xe588f9) returns (bool _0x605425) {\n    if (_0x55555a[_0xe588f9]._0xbb9768 != 0 || _0x55555a[_0xe588f9].value != 0 || _0x55555a[_0xe588f9].data.length != 0) {\n      address _0x246904;\n      if (_0x55555a[_0xe588f9]._0xbb9768 == 0) {\n        _0x246904 = _0x1cfbb0(_0x55555a[_0xe588f9].value, _0x55555a[_0xe588f9].data);\n      } else {\n        if (!_0x55555a[_0xe588f9]._0xbb9768.call.value(_0x55555a[_0xe588f9].value)(_0x55555a[_0xe588f9].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _0xe588f9, _0x55555a[_0xe588f9].value, _0x55555a[_0xe588f9]._0xbb9768, _0x55555a[_0xe588f9].data, _0x246904);\n      delete _0x55555a[_0xe588f9];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function _0x86eb0c(bytes32 _0x07c5d5) internal returns (bool) {\n    // determine what index the present sender is:\n    uint _0x069c0c = _0x99a387[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x069c0c == 0) return;\n\n    var _0x421031 = _0x640d4d[_0x07c5d5];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (_0x421031._0x9baa14 == 0) {\n      // reset count of confirmations needed.\n      _0x421031._0x9baa14 = _0xd4233c;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      _0x421031._0x811b66 = 0;\n      _0x421031._0x33d0c0 = _0x2dfe8a.length++;\n      _0x2dfe8a[_0x421031._0x33d0c0] = _0x07c5d5;\n    }\n    // determine the bit to set for this owner.\n    uint _0xb8afe9 = 2**_0x069c0c;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (_0x421031._0x811b66 & _0xb8afe9 == 0) {\n      Confirmation(msg.sender, _0x07c5d5);\n      // ok - check if count is enough to go ahead.\n      if (_0x421031._0x9baa14 <= 1) {\n        // enough confirmations: reset and run interior.\n        delete _0x2dfe8a[_0x640d4d[_0x07c5d5]._0x33d0c0];\n        delete _0x640d4d[_0x07c5d5];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        _0x421031._0x9baa14--;\n        _0x421031._0x811b66 |= _0xb8afe9;\n      }\n    }\n  }\n\n  function _0x39b647() private {\n    uint _0x5bee69 = 1;\n    while (_0x5bee69 < _0x7c2353)\n    {\n      while (_0x5bee69 < _0x7c2353 && _0x1cf41e[_0x5bee69] != 0) _0x5bee69++;\n      while (_0x7c2353 > 1 && _0x1cf41e[_0x7c2353] == 0) _0x7c2353--;\n      if (_0x5bee69 < _0x7c2353 && _0x1cf41e[_0x7c2353] != 0 && _0x1cf41e[_0x5bee69] == 0)\n      {\n        _0x1cf41e[_0x5bee69] = _0x1cf41e[_0x7c2353];\n        _0x99a387[_0x1cf41e[_0x5bee69]] = _0x5bee69;\n        _0x1cf41e[_0x7c2353] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function _0x320710(uint _0x45228c) internal _0xf74d41 returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (_0x45018f() > _0xbfdfd6) {\n      _0x45b7e3 = 0;\n      _0xbfdfd6 = _0x45018f();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n\n    if (_0x45b7e3 + _0x45228c >= _0x45b7e3 && _0x45b7e3 + _0x45228c <= _0x319bef) {\n      _0x45b7e3 += _0x45228c;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function _0x45018f() private constant returns (uint) { return _0x93750e / 1 days; }\n\n  function _0x99d2f2() internal {\n    uint length = _0x2dfe8a.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete _0x55555a[_0x2dfe8a[i]];\n\n      if (_0x2dfe8a[i] != 0)\n        delete _0x640d4d[_0x2dfe8a[i]];\n    }\n\n    delete _0x2dfe8a;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0xd4233c;\n  // pointer used to find a free slot in m_owners\n  uint public _0x7c2353;\n\n  uint public _0x319bef;\n  uint public _0x45b7e3;\n  uint public _0xbfdfd6;\n\n  // list of owners\n  uint[256] _0x1cf41e;\n\n  uint constant _0xad53c0 = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) _0x99a387;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) _0x640d4d;\n  bytes32[] _0x2dfe8a;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) _0x55555a;\n}\n\ncontract Wallet is WalletEvents {\n\n  // WALLET CONSTRUCTOR\n  //   calls the `initWallet` method of the Library in this context\n  function Wallet(address[] _0xc57f47, uint _0xa02123, uint _0x0654fd) {\n    // Signature of the Wallet Library's init function\n    bytes4 sig = bytes4(_0x8f3b21(\"initWallet(address[],uint256,uint256)\"));\n    address _0xccd751 = _walletLibrary;\n\n    // Compute the size of the call data : arrays has 2\n    // 32bytes for offset and length, plus 32bytes per element ;\n    // plus 2 32bytes for each uint\n    uint _0x13eb80 = (2 + _0xc57f47.length);\n    uint _0x90d2a9 = (2 + _0x13eb80) * 32;\n\n    assembly {\n      // Add the signature first to memory\n      mstore(0x0, sig)\n      // Add the call data, which is at the end of the\n      // code\n      _0x1ed418(0x4,  sub(_0xb635d4, _0x90d2a9), _0x90d2a9)\n      // Delegate call to the library\n      delegatecall(sub(gas, 10000), _0xccd751, 0x0, add(_0x90d2a9, 0x4), 0x0, 0x0)\n    }\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0xe04d83(uint _0x069c0c) constant returns (address) {\n    return address(_0x1cf41e[_0x069c0c + 1]);\n  }\n\n  // As return statement unavailable in fallback, explicit the method here\n\n  function _0x1a67f2(bytes32 _0x07c5d5, address _0x5f2a66) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function _0x427c31(address _0xa0e1af) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0xd4233c;\n  // pointer used to find a free slot in m_owners\n  uint public _0x7c2353;\n\n  uint public _0x319bef;\n  uint public _0x45b7e3;\n  uint public _0xbfdfd6;\n\n  // list of owners\n  uint[256] _0x1cf41e;\n}",
      "rename_map": {
        "changeRequirement": "_0x0f1f89",
        "reorganizeOwners": "_0x39b647",
        "invalidJumpLabel": "_0x277fa1",
        "confirmAndCheck": "_0x86eb0c",
        "resetSpentToday": "_0xaa2d89",
        "m_pendingIndex": "_0x2dfe8a",
        "initMultiowned": "_0xd581b4",
        "onlymanyowners": "_0xe8021a",
        "newRequirement": "_0x4db060",
        "setDailyLimit": "_0x6adeb5",
        "ownerIndexBit": "_0xb8afe9",
        "m_dailyLimit": "_0x319bef",
        "argarraysize": "_0x13eb80",
        "m_ownerIndex": "_0x99a387",
        "hasConfirmed": "_0x1a67f2",
        "initDaylimit": "_0xb331b3",
        "clearPending": "_0x99d2f2",
        "_newRequired": "_0x3aec15",
        "m_spentToday": "_0x45b7e3",
        "removeOwner": "_0xce335a",
        "m_numOwners": "_0x7c2353",
        "c_maxOwners": "_0xad53c0",
        "changeOwner": "_0xcea008",
        "m_required": "_0xd4233c",
        "_operation": "_0x07c5d5",
        "ownersDone": "_0x811b66",
        "underLimit": "_0x320710",
        "ownerIndex": "_0x069c0c",
        "initWallet": "_0x47abc9",
        "initiator": "_0xee1e62",
        "o_success": "_0x605425",
        "onlyowner": "_0xf74d41",
        "yetNeeded": "_0x9baa14",
        "operation": "_0x692e47",
        "m_pending": "_0x640d4d",
        "_daylimit": "_0x0654fd",
        "_required": "_0xa02123",
        "_newLimit": "_0xf50d44",
        "m_lastDay": "_0xbfdfd6",
        "codecopy": "_0x1ed418",
        "codesize": "_0xb635d4",
        "getOwner": "_0xe04d83",
        "oldOwner": "_0x7503ad",
        "newOwner": "_0xa2d9ca",
        "addOwner": "_0x4377a3",
        "m_owners": "_0x1cf41e",
        "_owners": "_0xc57f47",
        "confirm": "_0x7e45b7",
        "created": "_0x246904",
        "argsize": "_0x90d2a9",
        "isOwner": "_0x427c31",
        "execute": "_0x562213",
        "pending": "_0x421031",
        "_limit": "_0xb6530d",
        "o_hash": "_0xf6a9dc",
        "o_addr": "_0x476ebd",
        "_value": "_0x45228c",
        "_owner": "_0x5f2a66",
        "target": "_0xccd751",
        "create": "_0x1cfbb0",
        "revoke": "_0xb99710",
        "_from": "_0xc037dc",
        "jumpi": "_0x3d907a",
        "_addr": "_0xa0e1af",
        "today": "_0x45018f",
        "_code": "_0xc0cd2c",
        "owner": "_0x500063",
        "_data": "_0x418c6e",
        "m_txs": "_0x55555a",
        "index": "_0x33d0c0",
        "sha3": "_0x8f3b21",
        "kill": "_0xa17aaf",
        "free": "_0x5bee69",
        "_to": "_0xc11701",
        "now": "_0x93750e",
        "to": "_0xbb9768",
        "_h": "_0xe588f9"
      },
      "changes": [
        "Renamed 77 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_123",
      "transformed_id": "ss_l2_hex_sn_ds_123",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// taken from https://www.ethereum.org/token#the-coin (4/9/2018)\n\npragma solidity ^0.4.16;\n\ncontract _0xcab1f9 {\n    address public _0xbca527;\n\n    function _0xcab1f9() public {\n        _0xbca527 = msg.sender;\n    }\n\n    modifier _0xb6d993 {\n        require(msg.sender == _0xbca527);\n        _;\n    }\n\n    function _0x30737c(address _0x8d0488) _0xb6d993 public {\n        _0xbca527 = _0x8d0488;\n    }\n}\n\ninterface _0x144455 { function _0x0da219(address _0x678723, uint256 _0x870650, address _0x7b6a85, bytes _0xfdbcdc) external; }\n\ncontract TokenERC20 {\n    // Public variables of the token\n    string public _0x9151e2;\n    string public _0xf97963;\n    uint8 public _0xe23051 = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public _0x17853b;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public _0xf6f353;\n    mapping (address => mapping (address => uint256)) public _0xae75bb;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed _0x3ca2f7, uint256 value);\n\n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _0x18f618, address indexed _0xd535b2, uint256 _0x870650);\n\n    function TokenERC20(\n        string _0x092f76,\n        string _0xa5dc5b\n    ) public {\n        _0x9151e2 = _0x092f76;                                   // Set the name for display purposes\n        _0xf97963 = _0xa5dc5b;                               // Set the symbol for display purposes\n    }\n\n    function _0xbd8074(address _0x678723, address _0x6dc6eb, uint _0x870650) internal {\n        // Prevent transfer to 0x0 address.\n        require(_0x6dc6eb != 0x0);\n        // Check if the sender has enough\n        require(_0xf6f353[_0x678723] >= _0x870650);\n\n        require(_0xf6f353[_0x6dc6eb] + _0x870650 > _0xf6f353[_0x6dc6eb]);\n        // Save this for an assertion in the future\n        uint _0x737275 = _0xf6f353[_0x678723] + _0xf6f353[_0x6dc6eb];\n        // Subtract from the sender\n        _0xf6f353[_0x678723] -= _0x870650;\n        // Add the same to the recipient\n        _0xf6f353[_0x6dc6eb] += _0x870650;\n        emit Transfer(_0x678723, _0x6dc6eb, _0x870650);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(_0xf6f353[_0x678723] + _0xf6f353[_0x6dc6eb] == _0x737275);\n    }\n\n    function transfer(address _0x6dc6eb, uint256 _0x870650) public returns (bool _0x04743e) {\n        _0xbd8074(msg.sender, _0x6dc6eb, _0x870650);\n        return true;\n    }\n\n    function _0x9dfa36(address _0x678723, address _0x6dc6eb, uint256 _0x870650) public returns (bool _0x04743e) {\n        require(_0x870650 <= _0xae75bb[_0x678723][msg.sender]);     // Check allowance\n        _0xae75bb[_0x678723][msg.sender] -= _0x870650;\n        _0xbd8074(_0x678723, _0x6dc6eb, _0x870650);\n        return true;\n    }\n\n    function _0x1e9961(address _0xd535b2, uint256 _0x870650) public\n        returns (bool _0x04743e) {\n        _0xae75bb[msg.sender][_0xd535b2] = _0x870650;\n        emit Approval(msg.sender, _0xd535b2, _0x870650);\n        return true;\n    }\n\n    function _0xa8e4f4(address _0xd535b2, uint256 _0x870650, bytes _0xfdbcdc)\n        public\n        returns (bool _0x04743e) {\n        _0x144455 _0x9d6487 = _0x144455(_0xd535b2);\n        if (_0x1e9961(_0xd535b2, _0x870650)) {\n            _0x9d6487._0x0da219(msg.sender, _0x870650, this, _0xfdbcdc);\n            return true;\n        }\n    }\n\n}\n\n/******************************************/\n/*       ADVANCED TOKEN STARTS HERE       */\n/******************************************/\n\ncontract MyAdvancedToken is _0xcab1f9, TokenERC20 {\n\n    mapping (address => bool) public _0x405155;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address _0x8897e7, bool _0x0827e2);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function MyAdvancedToken(\n        string _0x092f76,\n        string _0xa5dc5b\n    ) TokenERC20(_0x092f76, _0xa5dc5b) public {}\n\n    /* Internal transfer, only can be called by this contract */\n    function _0xbd8074(address _0x678723, address _0x6dc6eb, uint _0x870650) internal {\n        require (_0x6dc6eb != 0x0);                               // Prevent transfer to 0x0 address.\n        require (_0xf6f353[_0x678723] >= _0x870650);               // Check if the sender has enough\n        require (_0xf6f353[_0x6dc6eb] + _0x870650 >= _0xf6f353[_0x6dc6eb]);\n        require(!_0x405155[_0x678723]);                     // Check if sender is frozen\n        require(!_0x405155[_0x6dc6eb]);                       // Check if recipient is frozen\n        _0xf6f353[_0x678723] -= _0x870650;                         // Subtract from the sender\n        _0xf6f353[_0x6dc6eb] += _0x870650;                           // Add the same to the recipient\n        emit Transfer(_0x678723, _0x6dc6eb, _0x870650);\n    }\n\n    /// @notice Buy tokens from contract by sending ether\n    function _0x5125be() payable public {\n        uint _0x6daa25 = msg.value;                          // calculates the amount\n\t_0xf6f353[msg.sender] += _0x6daa25;                  // updates the balance\n        _0x17853b += _0x6daa25;                            // updates the total supply\n        _0xbd8074(address(0x0), msg.sender, _0x6daa25);      // makes the transfer\n    }\n\n    /* Migration function */\n    function _0x9e90ef() _0xb6d993 {\n\tassert(this.balance == _0x17853b);                 // consistency check\n\tsuicide(_0xbca527);                                      // transfer the ether to the owner and kill the contract\n    }\n}",
      "rename_map": {
        "migrate_and_destroy": "_0x9e90ef",
        "transferOwnership": "_0x30737c",
        "previousBalances": "_0x737275",
        "receiveApproval": "_0x0da219",
        "tokenRecipient": "_0x144455",
        "approveAndCall": "_0xa8e4f4",
        "frozenAccount": "_0x405155",
        "transferFrom": "_0x9dfa36",
        "totalSupply": "_0x17853b",
        "tokenSymbol": "_0xa5dc5b",
        "_extraData": "_0xfdbcdc",
        "balanceOf": "_0xf6f353",
        "tokenName": "_0x092f76",
        "_transfer": "_0xbd8074",
        "allowance": "_0xae75bb",
        "onlyOwner": "_0xb6d993",
        "_spender": "_0xd535b2",
        "decimals": "_0xe23051",
        "newOwner": "_0x8d0488",
        "success": "_0x04743e",
        "spender": "_0x9d6487",
        "approve": "_0x1e9961",
        "symbol": "_0xf97963",
        "_owner": "_0x18f618",
        "target": "_0x8897e7",
        "_value": "_0x870650",
        "_token": "_0x7b6a85",
        "amount": "_0x6daa25",
        "frozen": "_0x0827e2",
        "owner": "_0xbca527",
        "owned": "_0xcab1f9",
        "_from": "_0x678723",
        "name": "_0x9151e2",
        "_to": "_0x6dc6eb",
        "buy": "_0x5125be",
        "to": "_0x3ca2f7"
      },
      "changes": [
        "Renamed 36 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_124",
      "transformed_id": "ss_l2_hex_sn_ds_124",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Alice {\n    function _0xb26623(uint);\n    function _0x1cff4f(int);\n}\n\ncontract Bob {\n    function _0xb26623(Alice c){\n        c._0xb26623(42);\n    }\n\n    function _0x1cff4f(Alice c){\n        c._0x1cff4f(42);\n    }\n}",
      "rename_map": {
        "setV2": "_0x1cff4f",
        "set": "_0xb26623"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_125",
      "transformed_id": "ss_l2_hex_sn_ds_125",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private _0x526da5;\n\n    modifier _0xa77ddf {\n        require(msg.sender==_0x526da5);\n        _;\n    }\n\n    // The name of the constructor should be Missing\n\n    function IamMissing()\n        public\n    {\n        _0x526da5 = msg.sender;\n    }\n\n    function () payable {}\n\n    function _0xadbe0e()\n        public\n        _0xa77ddf\n    {\n       _0x526da5.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "_0xa77ddf",
        "withdraw": "_0xadbe0e",
        "owner": "_0x526da5"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_126",
      "transformed_id": "ss_l2_hex_sn_ds_126",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private _0x9b73d0;\n\n    modifier _0x5b8a2a {\n        require(msg.sender==_0x9b73d0);\n        _;\n    }\n    function _0x0a83e0()\n        public\n    {\n        _0x9b73d0 = msg.sender;\n    }\n\n    function () payable {}\n\n    function _0xd6cb98()\n        public\n        _0x5b8a2a\n    {\n       _0x9b73d0.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "_0x5b8a2a",
        "withdraw": "_0xd6cb98",
        "missing": "_0x0a83e0",
        "owner": "_0x9b73d0"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_127",
      "transformed_id": "ss_l2_hex_sn_ds_127",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private _0x5fe3c7;\n\n    modifier _0x37019e {\n        require(msg.sender==_0x5fe3c7);\n        _;\n    }\n    function Constructor()\n        public\n    {\n        _0x5fe3c7 = msg.sender;\n    }\n\n    function () payable {}\n\n    function _0xe4d2a0()\n        public\n        _0x37019e\n    {\n       _0x5fe3c7.transfer(this.balance);\n    }\n\n}",
      "rename_map": {
        "onlyowner": "_0x37019e",
        "withdraw": "_0xe4d2a0",
        "owner": "_0x5fe3c7"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_128",
      "transformed_id": "ss_l2_hex_sn_ds_128",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract MultiOwnable {\n  address public _0x3989e5;\n  mapping (address => address) public _0x351b87; // owner => parent of owner\n\n  constructor() public {\n    _0x3989e5 = msg.sender;\n    _0x351b87[_0x3989e5] = _0x3989e5;\n  }\n\n  modifier _0xccb7cf() {\n    require(_0x351b87[msg.sender] != 0);\n    _;\n  }\n\n  function _0xca334f(address _0x20eec9) external returns (bool) {\n    require(_0x20eec9 != 0);\n    _0x351b87[_0x20eec9] = msg.sender;\n    return true;\n  }\n\n  function _0xf24e4b(address _0x20eec9) _0xccb7cf external returns (bool) {\n    require(_0x351b87[_0x20eec9] == msg.sender || (_0x351b87[_0x20eec9] != 0 && msg.sender == _0x3989e5));\n    _0x351b87[_0x20eec9] = 0;\n    return true;\n  }\n}\n\ncontract TestContract is MultiOwnable {\n\n  function _0x55cf73() _0xccb7cf {\n    msg.sender.transfer(this.balance);\n  }\n\n  function() payable {\n  }\n\n}\n",
      "rename_map": {
        "withdrawAll": "_0x55cf73",
        "deleteOwner": "_0xf24e4b",
        "onlyOwner": "_0xccb7cf",
        "newOwner": "_0xca334f",
        "_owner": "_0x20eec9",
        "owners": "_0x351b87",
        "root": "_0x3989e5"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_129",
      "transformed_id": "ss_l2_hex_sn_ds_129",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": " pragma solidity ^0.4.15;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private _0xb120b5 = 0;\n         uint private _0x944b38 = 10;\n         uint private _0x5fbff7 = 300;\n         uint private _0x9dd51e = 0;\n\n         address private _0x77377b;\n\n         //Sets creator\n         function DynamicPyramid() {\n                 _0x77377b = msg.sender;\n         }\n\n         modifier _0x554463 {\n                 if (msg.sender == _0x77377b) _;\n         }\n\n         struct Participant {\n                 address _0x29d271;\n                 uint _0x65ab4f;\n         }\n\n         Participant[] private _0x9584a1;\n\n         //Fallback function\n         function() {\n                 _0xe543eb();\n         }\n\n         //init function run on fallback\n         function _0xe543eb() private {\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         _0xb120b5 += msg.value;\n                         return;\n                 }\n\n                 uint _0xffe92d = _0x944b38;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _0xffe92d /= 2;\n\n                 _0x7a99c7(_0xffe92d);\n         }\n\n         //Function called for valid tx to the contract\n         function _0x7a99c7(uint _0xffe92d) private {\n                 //Adds new address to participant array\n                 _0x9584a1.push(Participant(msg.sender, (msg.value * _0x5fbff7) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (_0x9584a1.length == 10) _0x5fbff7 = 200;\n                 else if (_0x9584a1.length == 25) _0x5fbff7 = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _0xffe92d)) / 100;\n                 _0xb120b5 += (msg.value * _0xffe92d) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > _0x9584a1[_0x9dd51e]._0x65ab4f) {\n                         uint _0x9d8a13 = _0x9584a1[_0x9dd51e]._0x65ab4f;\n                         _0x9584a1[_0x9dd51e]._0x29d271.send(_0x9d8a13);\n\n                         balance -= _0x9584a1[_0x9dd51e]._0x65ab4f;\n                         _0x9dd51e += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function _0x89afc9() _0x554463 {\n                 if (_0xb120b5 == 0) throw;\n\n                 _0x77377b.send(_0xb120b5);\n                 _0xb120b5 = 0;\n         }\n\n         function _0x096790(uint _0xba9650) _0x554463 {\n                 _0xba9650 *= 1 ether;\n                 if (_0xba9650 > _0xb120b5) _0x89afc9();\n\n                 if (_0xb120b5 == 0) throw;\n\n                 _0x77377b.send(_0xba9650);\n                 _0xb120b5 -= _0xba9650;\n         }\n\n         function _0xfe1e5a(uint _0xe9ca9a) _0x554463 {\n                 if (_0xb120b5 == 0 || _0xe9ca9a > 100) throw;\n\n                 uint _0x321c15 = _0xb120b5 / 100 * _0xe9ca9a;\n                 _0x77377b.send(_0x321c15);\n                 _0xb120b5 -= _0x321c15;\n         }\n\n         //Functions for changing variables related to the contract\n         function _0x9d088f(address _0xeaac2d) _0x554463 {\n                 _0x77377b = _0xeaac2d;\n         }\n\n         function _0xa8846e(uint _0xf6100e) _0x554463 {\n                 if (_0xf6100e > 300 || _0xf6100e < 120) throw;\n\n                 _0x5fbff7 = _0xf6100e;\n         }\n\n         function _0x9b6064(uint _0xffe92d) _0x554463 {\n                 if (_0xffe92d > 10) throw;\n\n                 _0x944b38 = _0xffe92d;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function _0x324e7c() constant returns(uint _0x987c1d, string _0x396f2c) {\n                 _0x987c1d = _0x5fbff7;\n                 _0x396f2c = 'This _0x987c1d applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, _0x987c1d is x100 for a fractional _0x987c1d e.g. 250 is actually a 2.5x _0x987c1d. Capped at 3x max and 1.2x min.';\n         }\n\n         function _0x2a9973() constant returns(uint _0xbd5a73, string _0x396f2c) {\n                 _0xbd5a73 = _0x944b38;\n                 _0x396f2c = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function _0x2549b2() constant returns(uint _0xf2269f, string _0x396f2c) {\n                 _0xf2269f = balance / 1 ether;\n                 _0x396f2c = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function _0x4bfca1() constant returns(uint _0x96e7f7) {\n                 _0x96e7f7 = _0x9584a1[_0x9dd51e]._0x65ab4f / 1 ether;\n         }\n\n         function _0x8b64a3() constant returns(uint _0xa15d15) {\n                 _0xa15d15 = _0xb120b5 / 1 ether;\n         }\n\n         function _0x865b6a() constant returns(uint _0x2b31ac) {\n                 _0x2b31ac = _0x9584a1.length;\n         }\n\n         function _0xa11bab() constant returns(uint _0x2b31ac) {\n                 _0x2b31ac = _0x9584a1.length - _0x9dd51e;\n         }\n\n         function _0xab942b(uint _0x0d5629) constant returns(address Address, uint Payout) {\n                 if (_0x0d5629 <= _0x9584a1.length) {\n                         Address = _0x9584a1[_0x0d5629]._0x29d271;\n                         Payout = _0x9584a1[_0x0d5629]._0x65ab4f / 1 ether;\n                 }\n         }\n }\n",
      "rename_map": {
        "nextPayoutWhenPyramidBalanceTotalsApproximately": "_0x4bfca1",
        "feesSeperateFromBalanceApproximately": "_0x8b64a3",
        "numberOfParticipantsWaitingForPayout": "_0xa11bab",
        "currentPyramidBalanceApproximately": "_0x2549b2",
        "currentFeePercentage": "_0x2a9973",
        "collectPercentOfFees": "_0xfe1e5a",
        "changeFeePercentage": "_0x9b6064",
        "participantDetails": "_0xab942b",
        "collectFeesInEther": "_0x096790",
        "totalParticipants": "_0x865b6a",
        "pyramidMultiplier": "_0x5fbff7",
        "currentMultiplier": "_0x324e7c",
        "changeMultiplier": "_0xa8846e",
        "orderInPyramid": "_0x0d5629",
        "collectAllFees": "_0x89afc9",
        "pyramidBalance": "_0xf2269f",
        "feesToCollect": "_0x321c15",
        "collectedFees": "_0xb120b5",
        "balancePayout": "_0x96e7f7",
        "payoutToSend": "_0x9d8a13",
        "etherAddress": "_0x29d271",
        "participants": "_0x9584a1",
        "payoutOrder": "_0x9dd51e",
        "changeOwner": "_0x9d088f",
        "feePercent": "_0x944b38",
        "multiplier": "_0x987c1d",
        "addPayout": "_0x7a99c7",
        "onlyowner": "_0x554463",
        "creator": "_0x77377b",
        "_owner": "_0xeaac2d",
        "_pcent": "_0xe9ca9a",
        "payout": "_0x65ab4f",
        "count": "_0x2b31ac",
        "_mult": "_0xf6100e",
        "init": "_0xe543eb",
        "fees": "_0xa15d15",
        "_amt": "_0xba9650",
        "_fee": "_0xffe92d",
        "info": "_0x396f2c",
        "fee": "_0xbd5a73"
      },
      "changes": [
        "Renamed 40 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_130",
      "transformed_id": "ss_l2_hex_sn_ds_130",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n contract OpenAccess{\n     address private _0xe63ea7;\n\n     modifier _0x788340 {\n         require(msg.sender==_0xe63ea7);\n         _;\n     }\n\n     function OpenAccess()\n         public\n     {\n         _0xe63ea7 = msg.sender;\n     }\n\n     // This function should be protected\n     function _0xa664e8(address _0x619c1d)\n         public\n     {\n        _0xe63ea7 = _0x619c1d;\n     }\n\n }",
      "rename_map": {
        "changeOwner": "_0xa664e8",
        "onlyowner": "_0x788340",
        "_newOwner": "_0x619c1d",
        "owner": "_0xe63ea7"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_131",
      "transformed_id": "ss_l2_hex_sn_ds_131",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.10;\n\ncontract AdditionCounter {\n    mapping (address => uint256) public _0x78bcf0;\n\n    function transfer(address _0x2f7b50, uint256 _0xceac7d) public{\n        /* Check if sender has balance */\n        require(_0x78bcf0[msg.sender] >= _0xceac7d);\n        _0x78bcf0[msg.sender] -= _0xceac7d;\n        _0x78bcf0[_0x2f7b50] += _0xceac7d;\n}\n\n}",
      "rename_map": {
        "balanceOf": "_0x78bcf0",
        "_value": "_0xceac7d",
        "_to": "_0x2f7b50"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_132",
      "transformed_id": "ss_l2_hex_sn_ds_132",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n contract Ledger {\n     uint private _0x62d46b=0;\n\n     function _0x55eec0(uint value) returns (bool){\n         _0x62d46b += value;\n\n         // possible auditor assert\n         // assert(sellerBalance >= value);\n     }\n\n  // function safe_add(uint value) returns (bool){\n  //   require(value + sellerBalance >= sellerBalance);\n  // sellerBalance += value;\n  // }\n }",
      "rename_map": {
        "sellerBalance": "_0x62d46b",
        "add": "_0x55eec0"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_133",
      "transformed_id": "ss_l2_hex_sn_ds_133",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract AdditionCounter {\n    uint public _0x0f7c96 = 1;\n\n    function _0x9167a6(uint256 _0xb0720f) public {\n        _0x0f7c96 += _0xb0720f;\n    }\n}\n",
      "rename_map": {
        "count": "_0x0f7c96",
        "input": "_0xb0720f",
        "run": "_0x9167a6"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_134",
      "transformed_id": "ss_l2_hex_sn_ds_134",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract BenignCounter {\n    uint public _0x57f393 = 1;\n\n    function _0x45b18a(uint256 _0x9d2a39) public {\n        uint _0x1f0520 = _0x57f393 - _0x9d2a39;\n    }\n}\n",
      "rename_map": {
        "count": "_0x57f393",
        "input": "_0x9d2a39",
        "res": "_0x1f0520",
        "run": "_0x45b18a"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_135",
      "transformed_id": "ss_l2_hex_sn_ds_135",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.11;\n\ncontract MappingCounter {\n    mapping(uint256 => uint256) _0x6c3fc4;\n\n    function _0x5c16cc(uint256 k, uint256 v) public {\n        _0x6c3fc4[k] -= v;\n    }\n}\n",
      "rename_map": {
        "init": "_0x5c16cc",
        "map": "_0x6c3fc4"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_136",
      "transformed_id": "ss_l2_hex_sn_ds_136",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract MinimalCounter {\n    uint public _0xd8c8b6 = 1;\n\n    function _0xcd91d4(uint256 _0xf4597a) public {\n        _0xd8c8b6 -= _0xf4597a;\n    }\n}\n",
      "rename_map": {
        "count": "_0xd8c8b6",
        "input": "_0xf4597a",
        "run": "_0xcd91d4"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_137",
      "transformed_id": "ss_l2_hex_sn_ds_137",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract MultiplyCounter {\n    uint public _0x777301 = 2;\n\n    function _0x7ea76f(uint256 _0x73a5cb) public {\n        _0x777301 *= _0x73a5cb;\n    }\n}\n",
      "rename_map": {
        "count": "_0x777301",
        "input": "_0x73a5cb",
        "run": "_0x7ea76f"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_138",
      "transformed_id": "ss_l2_hex_sn_ds_138",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract MultiTxCalculator {\n    uint256 private _0x74b8ad = 0;\n    uint256 public _0x7f4749 = 1;\n\n    function _0xdaf841() public {\n        _0x74b8ad = 1;\n    }\n\n    function _0x78d67b(uint256 _0xe162a6) {\n        if (_0x74b8ad == 0) {\n            return;\n        }\n        _0x7f4749 -= _0xe162a6;\n    }\n}\n",
      "rename_map": {
        "initialized": "_0x74b8ad",
        "count": "_0x7f4749",
        "input": "_0xe162a6",
        "init": "_0xdaf841",
        "run": "_0x78d67b"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_139",
      "transformed_id": "ss_l2_hex_sn_ds_139",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract SingleFuncCalculator {\n    uint256 private _0x48dec7 = 0;\n    uint256 public _0x9208c9 = 1;\n\n    function _0x973685(uint256 _0xd57e2e) public {\n        if (_0x48dec7 == 0) {\n            _0x48dec7 = 1;\n            return;\n        }\n        _0x9208c9 -= _0xd57e2e;\n    }\n}\n",
      "rename_map": {
        "initialized": "_0x48dec7",
        "input": "_0xd57e2e",
        "count": "_0x9208c9",
        "run": "_0x973685"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_140",
      "transformed_id": "ss_l2_hex_sn_ds_140",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.4.25;\n\ncontract AdditionLedger {\n    uint public balance = 1;\n\n    function _0x935b8e(uint256 _0x80dd91) public {\n        balance += _0x80dd91;\n    }\n}",
      "rename_map": {
        "deposit": "_0x80dd91",
        "add": "_0x935b8e"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_141",
      "transformed_id": "ss_l2_hex_sn_ds_141",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.23;\n\ncontract SingleTxCounter {\n    uint public _0xdef3b0 = 1;\n\n    function _0xbeb782(uint256 _0x2d48fc) public {\n        _0xdef3b0 += _0x2d48fc;\n    }\n\n    function _0x1b0e70(uint256 _0x2d48fc) public {\n        _0xdef3b0 *= _0x2d48fc;\n    }\n\n    function _0xa27f93(uint256 _0x2d48fc) public {\n        _0xdef3b0 -= _0x2d48fc;\n    }\n\n    function _0x8039b1(uint256 _0x2d48fc) public {\n        uint _0x48d635 = _0xdef3b0 + _0x2d48fc;\n    }\n\n    function _0x2c8026(uint256 _0x2d48fc) public {\n        uint _0x48d635 = _0xdef3b0 * _0x2d48fc;\n    }\n\n    function _0xd34090(uint256 _0x2d48fc) public {\n       \tuint _0x48d635 = _0xdef3b0 - _0x2d48fc;\n    }\n\n}\n",
      "rename_map": {
        "underflowlocalonly": "_0xd34090",
        "underflowtostate": "_0xa27f93",
        "mullocalonly": "_0x2c8026",
        "multostate": "_0x1b0e70",
        "addtostate": "_0xbeb782",
        "localcalc": "_0x8039b1",
        "count": "_0xdef3b0",
        "input": "_0x2d48fc",
        "res": "_0x48d635"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_142",
      "transformed_id": "ss_l2_hex_sn_ds_142",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": " pragma solidity ^0.4.10;\n\n contract TimeLock {\n\n     mapping(address => uint) public _0xe7f621;\n     mapping(address => uint) public _0xba437c;\n\n     function _0x170fb6() public payable {\n         _0xe7f621[msg.sender] += msg.value;\n         _0xba437c[msg.sender] = _0x281879 + 1 weeks;\n     }\n\n     function _0xd38542(uint _0x9c2535) public {\n         _0xba437c[msg.sender] += _0x9c2535;\n     }\n\n     function _0xbb20b4() public {\n         require(_0xe7f621[msg.sender] > 0);\n         require(_0x281879 > _0xba437c[msg.sender]);\n         uint _0x35e259 = _0xe7f621[msg.sender];\n         _0xe7f621[msg.sender] = 0;\n         msg.sender.transfer(_0x35e259);\n     }\n }\n",
      "rename_map": {
        "_secondsToIncrease": "_0x9c2535",
        "increaseLockTime": "_0xd38542",
        "transferValue": "_0x35e259",
        "withdraw": "_0xbb20b4",
        "lockTime": "_0xba437c",
        "balances": "_0xe7f621",
        "deposit": "_0x170fb6",
        "now": "_0x281879"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_143",
      "transformed_id": "ss_l2_hex_sn_ds_143",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) _0xffbc4b;\n   uint public _0x802439;\n\n   function Token(uint _0x595a5e) {\n     _0xffbc4b[msg.sender] = _0x802439 = _0x595a5e;\n   }\n\n   function transfer(address _0xe3e482, uint _0xba9d8c) public returns (bool) {\n     require(_0xffbc4b[msg.sender] - _0xba9d8c >= 0);\n     _0xffbc4b[msg.sender] -= _0xba9d8c;\n     _0xffbc4b[_0xe3e482] += _0xba9d8c;\n     return true;\n   }\n\n   function _0x576b70(address _0x1e0dd6) public constant returns (uint balance) {\n     return _0xffbc4b[_0x1e0dd6];\n   }\n }",
      "rename_map": {
        "_initialSupply": "_0x595a5e",
        "totalSupply": "_0x802439",
        "balanceOf": "_0x576b70",
        "balances": "_0xffbc4b",
        "_owner": "_0x1e0dd6",
        "_value": "_0xba9d8c",
        "_to": "_0xe3e482"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_144",
      "transformed_id": "ss_l2_hex_sn_ds_144",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public _0xf8254b;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _0x939aa6) public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function _0x68c2e9() public view returns (bool) {\n        return address(this).balance < 1 ether;\n    }\n\n    function _0xbf46ba(uint256 _0xc16377) public payable {\n        require(msg.value == _0xc16377 * PRICE_PER_TOKEN);\n        _0xf8254b[msg.sender] += _0xc16377;\n    }\n\n    function _0x6a3922(uint256 _0xc16377) public {\n        require(_0xf8254b[msg.sender] >= _0xc16377);\n\n        _0xf8254b[msg.sender] -= _0xc16377;\n        msg.sender.transfer(_0xc16377 * PRICE_PER_TOKEN);\n    }\n}",
      "rename_map": {
        "isComplete": "_0x68c2e9",
        "numTokens": "_0xc16377",
        "balanceOf": "_0xf8254b",
        "_player": "_0x939aa6",
        "sell": "_0x6a3922",
        "buy": "_0xbf46ba"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_145",
      "transformed_id": "ss_l2_hex_sn_ds_145",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address _0xc9bdce;\n        uint _0xfa0dfd;\n    }\n\n    event RaffleResult(\n        uint _0xfa0dfd,\n        uint _0xc19dbd,\n        address _0x39c6a0,\n        address _0xc94005,\n        address _0xb95520,\n        uint _0xeac0a5,\n        bytes32 _0x47a4c5\n    );\n\n    event TicketPurchase(\n        uint _0xfa0dfd,\n        address _0x7f4a39,\n        uint number\n    );\n\n    event TicketRefund(\n        uint _0xfa0dfd,\n        address _0x7f4a39,\n        uint number\n    );\n\n    // Constants\n    uint public constant _0x5bd0c0 = 2.5 ether;\n    uint public constant _0x0711dc = 0.03 ether;\n    uint public constant _0x09321e = 50;\n    uint public constant _0xea5b52 = (_0x5bd0c0 + _0x0711dc) / _0x09321e; // Make sure this divides evenly\n    address _0xd0edaa;\n\n    // Other internal variables\n    bool public _0xcc0412 = false;\n    uint public _0xfa0dfd = 1;\n    uint public _0x44cac9 = block.number;\n    uint _0x8afa12 = 0;\n    mapping (uint => Contestant) _0x8579f7;\n    uint[] _0x8c4782;\n\n    // Initialization\n    function Ethraffle_v4b() public {\n        _0xd0edaa = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        _0x9c0fb7();\n    }\n\n    function _0x9c0fb7() payable public {\n        if (_0xcc0412) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint _0x726995 = msg.value;\n\n        while (_0x726995 >= _0xea5b52 && _0x8afa12 < _0x09321e) {\n            uint _0x8c5d3d = 0;\n            if (_0x8c4782.length > 0) {\n                _0x8c5d3d = _0x8c4782[_0x8c4782.length-1];\n                _0x8c4782.length--;\n            } else {\n                _0x8c5d3d = _0x8afa12++;\n            }\n\n            _0x8579f7[_0x8c5d3d] = Contestant(msg.sender, _0xfa0dfd);\n            TicketPurchase(_0xfa0dfd, msg.sender, _0x8c5d3d);\n            _0x726995 -= _0xea5b52;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (_0x8afa12 == _0x09321e) {\n            _0x6d8fb0();\n        }\n\n        // Send back leftover money\n        if (_0x726995 > 0) {\n            msg.sender.transfer(_0x726995);\n        }\n    }\n\n    function _0x6d8fb0() private {\n        address _0xc94005 = _0x8579f7[uint(block.coinbase) % _0x09321e]._0xc9bdce;\n        address _0xb95520 = _0x8579f7[uint(msg.sender) % _0x09321e]._0xc9bdce;\n        uint _0xeac0a5 = block.difficulty;\n        bytes32 _0x47a4c5 = _0x4689b7(_0xc94005, _0xb95520, _0xeac0a5);\n\n        uint _0xc19dbd = uint(_0x47a4c5) % _0x09321e;\n        address _0x39c6a0 = _0x8579f7[_0xc19dbd]._0xc9bdce;\n        RaffleResult(_0xfa0dfd, _0xc19dbd, _0x39c6a0, _0xc94005, _0xb95520, _0xeac0a5, _0x47a4c5);\n\n        // Start next raffle\n        _0xfa0dfd++;\n        _0x8afa12 = 0;\n        _0x44cac9 = block.number;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        _0x39c6a0.transfer(_0x5bd0c0);\n        _0xd0edaa.transfer(_0x0711dc);\n    }\n\n    // Get your money back before the raffle occurs\n    function _0x00d154() public {\n        uint _0xa9f7b6 = 0;\n        for (uint i = 0; i < _0x09321e; i++) {\n            if (msg.sender == _0x8579f7[i]._0xc9bdce && _0xfa0dfd == _0x8579f7[i]._0xfa0dfd) {\n                _0xa9f7b6 += _0xea5b52;\n                _0x8579f7[i] = Contestant(address(0), 0);\n                _0x8c4782.push(i);\n                TicketRefund(_0xfa0dfd, msg.sender, i);\n            }\n        }\n\n        if (_0xa9f7b6 > 0) {\n            msg.sender.transfer(_0xa9f7b6);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function _0x9461a6() public {\n        if (msg.sender == _0xd0edaa) {\n            _0xcc0412 = true;\n\n            for (uint i = 0; i < _0x09321e; i++) {\n                if (_0xfa0dfd == _0x8579f7[i]._0xfa0dfd) {\n                    TicketRefund(_0xfa0dfd, _0x8579f7[i]._0xc9bdce, i);\n                    _0x8579f7[i]._0xc9bdce.transfer(_0xea5b52);\n                }\n            }\n\n            RaffleResult(_0xfa0dfd, _0x09321e, address(0), address(0), address(0), 0, 0);\n            _0xfa0dfd++;\n            _0x8afa12 = 0;\n            _0x44cac9 = block.number;\n            _0x8c4782.length = 0;\n        }\n    }\n\n    function _0xf3b59d() public {\n        if (msg.sender == _0xd0edaa) {\n            _0xcc0412 = !_0xcc0412;\n        }\n    }\n\n    function _0x115027() public {\n        if (msg.sender == _0xd0edaa) {\n            selfdestruct(_0xd0edaa);\n        }\n    }\n}",
      "rename_map": {
        "winningAddress": "_0x39c6a0",
        "pricePerTicket": "_0xea5b52",
        "winningNumber": "_0xc19dbd",
        "chooseWinner": "_0x6d8fb0",
        "totalTickets": "_0x09321e",
        "togglePause": "_0xf3b59d",
        "contestants": "_0x8579f7",
        "blockNumber": "_0x44cac9",
        "feeAddress": "_0xd0edaa",
        "currTicket": "_0x8c5d3d",
        "buyTickets": "_0x9c0fb7",
        "nextTicket": "_0x8afa12",
        "contestant": "_0x7f4a39",
        "getRefund": "_0x00d154",
        "endRaffle": "_0x9461a6",
        "keccak256": "_0x4689b7",
        "moneySent": "_0x726995",
        "raffleId": "_0xfa0dfd",
        "randHash": "_0x47a4c5",
        "refund": "_0xa9f7b6",
        "paused": "_0xcc0412",
        "prize": "_0x5bd0c0",
        "seed1": "_0xc94005",
        "seed3": "_0xeac0a5",
        "seed2": "_0xb95520",
        "kill": "_0x115027",
        "addr": "_0xc9bdce",
        "gaps": "_0x8c4782",
        "fee": "_0x0711dc"
      },
      "changes": [
        "Renamed 29 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_146",
      "transformed_id": "ss_l2_hex_sn_ds_146",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 _0x1776a2;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        require(msg.value == 1 ether);\n        _0x1776a2 = uint8(_0x4d0da7(block.blockhash(block.number - 1), _0x818f45));\n    }\n\n    function _0xee5ee4() public view returns (bool) {\n        return address(this).balance == 0;\n    }\n\n    function _0x35e5e5(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == _0x1776a2) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
      "rename_map": {
        "isComplete": "_0xee5ee4",
        "keccak256": "_0x4d0da7",
        "answer": "_0x1776a2",
        "guess": "_0x35e5e5",
        "now": "_0x818f45"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_147",
      "transformed_id": "ss_l2_hex_sn_ds_147",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "  pragma solidity ^0.4.0;\n\n contract Lottery {\n     event GetBet(uint _0x937e05, uint _0x47a492, bool _0xa8e822);\n\n     struct Bet {\n         uint _0x937e05;\n         uint _0x47a492;\n         bool _0xa8e822;\n     }\n\n     address private _0x9c6f28;\n     Bet[] private _0x2602d3;\n\n     // Create a new lottery with numOfBets supported bets.\n     function Lottery() {\n         _0x9c6f28 = msg.sender;\n     }\n\n     // Fallback function returns ether\n     function() {\n         throw;\n     }\n\n     // Make a bet\n     function _0x7485d8() {\n         // Won if block number is even\n\n         bool _0xa8e822 = (block.number % 2) == 0;\n\n         // Record the bet with an event\n         _0x2602d3.push(Bet(msg.value, block.number, _0xa8e822));\n\n         // Payout if the user won, otherwise take their money\n         if(_0xa8e822) {\n             if(!msg.sender.send(msg.value)) {\n                 // Return ether to sender\n                 throw;\n             }\n         }\n     }\n\n     // Get all bets that have been made\n     function _0x40beaa() {\n         if(msg.sender != _0x9c6f28) { throw; }\n\n         for (uint i = 0; i < _0x2602d3.length; i++) {\n             GetBet(_0x2602d3[i]._0x937e05, _0x2602d3[i]._0x47a492, _0x2602d3[i]._0xa8e822);\n         }\n     }\n\n     function _0xa3b566() {\n         if(msg.sender != _0x9c6f28) { throw; }\n\n         suicide(_0x9c6f28);\n     }\n }\n",
      "rename_map": {
        "blockNumber": "_0x47a492",
        "organizer": "_0x9c6f28",
        "betAmount": "_0x937e05",
        "makeBet": "_0x7485d8",
        "destroy": "_0xa3b566",
        "getBets": "_0x40beaa",
        "bets": "_0x2602d3",
        "won": "_0xa8e822"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_148",
      "transformed_id": "ss_l2_hex_sn_ds_148",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\n    struct _0x82c439{\n      uint block;\n      bytes32 _0x82c439;\n    }\n\n    mapping(address => _0x82c439) _0x43cf3e;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function _0xc22706(bytes32 _0xdd9a94) public payable {\n        require(_0x43cf3e[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        _0x43cf3e[msg.sender]._0x82c439 = _0xdd9a94;\n        _0x43cf3e[msg.sender].block  = block.number + 1;\n    }\n\n    function _0x487bc0() public {\n        require(block.number > _0x43cf3e[msg.sender].block);\n        bytes32 _0x1b2c0d = blockhash(_0x43cf3e[msg.sender].block);\n\n        _0x43cf3e[msg.sender].block = 0;\n        if (_0x43cf3e[msg.sender]._0x82c439 == _0x1b2c0d) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
      "rename_map": {
        "lockInGuess": "_0xc22706",
        "guesses": "_0x43cf3e",
        "answer": "_0x1b2c0d",
        "settle": "_0x487bc0",
        "guess": "_0x82c439",
        "hash": "_0xdd9a94"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_149",
      "transformed_id": "ss_l2_hex_sn_ds_149",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\n  uint256 private _0x3eebd2 =  block.timestamp;\n\n  function _0xf919d5(uint _0x8bd590) view private returns (uint256 _0x0968eb) {\n    // Get the best seed for randomness\n    uint256 x = _0x3eebd2 * 100 / _0x8bd590;\n    uint256 y = _0x3eebd2 * block.number / (_0x3eebd2 % 5);\n    uint256 _0xd05746 = block.number / 3 + (_0x3eebd2 % 300) + y;\n    uint256 h = uint256(blockhash(_0xd05746));\n    // Random number between 1 and max\n    return uint256((h / x)) % _0x8bd590 + 1;\n  }\n}",
      "rename_map": {
        "result": "_0x0968eb",
        "random": "_0xf919d5",
        "salt": "_0x3eebd2",
        "seed": "_0xd05746",
        "max": "_0x8bd590"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_150",
      "transformed_id": "ss_l2_hex_sn_ds_150",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address _0x2fab54;\n  uint _0x8f6115;\n\n  function _0x5cf273() payable {\n    require(msg.value > _0x8f6115);\n\n    //If the refund fails, the entire transaction reverts.\n\n    if (_0x2fab54 != 0) {\n      //E.g. if recipients fallback function is just revert()\n      require(_0x2fab54.send(_0x8f6115));\n    }\n\n    _0x2fab54 = msg.sender;\n    _0x8f6115         = msg.value;\n  }\n}",
      "rename_map": {
        "currentFrontrunner": "_0x2fab54",
        "currentBid": "_0x8f6115",
        "bid": "_0x5cf273"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_151",
      "transformed_id": "ss_l2_hex_sn_ds_151",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract GasAuction {\n\n    address[] _0x7e547e;\n    bool _0xc28cb3 = false;\n\n    function _0x0e1e55() public {\n        if(_0x7e547e.length>1500) {\n            _0x7e547e = new address[](0);\n            _0xc28cb3 = true;\n        }\n    }\n\n    function _0x36c035() public returns (bool) {\n        for(uint i=0;i<350;i++) {\n          _0x7e547e.push(msg.sender);\n        }\n        return true;\n    }\n\n    function _0x2d5155() public view returns (bool) {\n        return _0xc28cb3;\n    }\n\n    function _0xc0846f() public view returns (uint) {\n        return _0x7e547e.length;\n    }\n}",
      "rename_map": {
        "creditorAddresses": "_0x7e547e",
        "numberCreditors": "_0xc0846f",
        "emptyCreditors": "_0x0e1e55",
        "addCreditors": "_0x36c035",
        "iWin": "_0x2d5155",
        "win": "_0xc28cb3"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_152",
      "transformed_id": "ss_l2_hex_sn_ds_152",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract NumberRegistry {\n\n    uint _0xdbc589 = 0;\n    uint[] array;\n\n    function _0xc2050b(uint value,uint _0x04e7cf) public {\n\n        for(uint i=0;i<_0x04e7cf;i++) {\n            if(_0xdbc589 == array.length) {\n                array.length += 1;\n            }\n            array[_0xdbc589++] = value;\n        }\n    }\n\n    function _0xc40083() public {\n        require(_0xdbc589>1500);\n        _0xdbc589 = 0;\n    }\n\n    function _0x7a0125() public {\n\n        // number depends on actual gas limit\n        require(_0xdbc589>1500);\n        array = new uint[](0);\n        _0xdbc589 = 0;\n    }\n\n    function _0xd1b9a5() public view returns(uint) {\n        return _0xdbc589;\n    }\n\n    function _0x7bc57a() public view returns(uint) {\n        return array.length;\n    }\n}",
      "rename_map": {
        "getRealLengthArray": "_0x7bc57a",
        "insertNnumbers": "_0xc2050b",
        "getLengthArray": "_0xd1b9a5",
        "numElements": "_0xdbc589",
        "clearDOS": "_0x7a0125",
        "numbers": "_0x04e7cf",
        "clear": "_0xc40083"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_153",
      "transformed_id": "ss_l2_hex_sn_ds_153",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract SingleFuncRegistry {\n\n    address[] _0x4c57ab;\n\n    function _0xe1a9d0() public returns (bool){\n        if(_0x4c57ab.length<1500) {\n            for(uint i=0;i<350;i++) {\n                _0x4c57ab.push(msg.sender);\n            }\n            return true;\n\n        } else {\n            _0x4c57ab = new address[](0);\n            return false;\n        }\n    }\n}",
      "rename_map": {
        "listAddresses": "_0x4c57ab",
        "ifillArray": "_0xe1a9d0"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_154",
      "transformed_id": "ss_l2_hex_sn_ds_154",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public _0x8554c5;\n     uint public _0xb19702;\n     uint public _0x3c4bb6;\n     address[] public _0x2ccd79;\n     uint[] public _0xb3b7b8;\n     address public _0xa32c9a;\n     mapping (address => uint) _0x9220d8;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public _0xbcfdc4;\n\n     function Government() {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         _0x3c4bb6 = msg.value;\n         _0xa32c9a = msg.sender;\n         _0xb19702 = block.timestamp;\n     }\n\n     function _0x65ca80(address _0x8eb134) returns (bool) {\n         uint _0xd81787 = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (_0xb19702 + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(_0xd81787);\n             // Sends all contract money to the last creditor\n             _0x2ccd79[_0x2ccd79.length - 1].send(_0x3c4bb6);\n             _0xa32c9a.send(this.balance);\n             // Reset contract state\n             _0x8554c5 = 0;\n             _0xb19702 = block.timestamp;\n             _0x3c4bb6 = 0;\n             _0x2ccd79 = new address[](0);\n             _0xb3b7b8 = new uint[](0);\n             _0xbcfdc4 += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (_0xd81787 >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 _0xb19702 = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 _0x2ccd79.push(msg.sender);\n                 _0xb3b7b8.push(_0xd81787 * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 _0xa32c9a.send(_0xd81787 * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (_0x3c4bb6 < 10000 * 10**18) {\n                     _0x3c4bb6 += _0xd81787 * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(_0x9220d8[_0x8eb134] >= _0xd81787) {\n                     _0x8eb134.send(_0xd81787 * 5/100);\n                 }\n                 _0x9220d8[msg.sender] += _0xd81787 * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (_0xb3b7b8[_0x8554c5] <= address(this).balance - _0x3c4bb6) {\n                     _0x2ccd79[_0x8554c5].send(_0xb3b7b8[_0x8554c5]);\n                     _0x9220d8[_0x2ccd79[_0x8554c5]] -= _0xb3b7b8[_0x8554c5];\n                     _0x8554c5 += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(_0xd81787);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     function() {\n         _0x65ca80(0);\n     }\n\n     function _0xecedd9() returns (uint _0x1e9557) {\n         for(uint i=_0x8554c5; i<_0xb3b7b8.length; i++){\n             _0x1e9557 += _0xb3b7b8[i];\n         }\n     }\n\n     function _0x74e9dd() returns (uint _0xb7719a) {\n         for(uint i=0; i<_0x8554c5; i++){\n             _0xb7719a += _0xb3b7b8[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function _0x5ac4e3() {\n         _0x3c4bb6 += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function _0x34bb27(address _0x6db0df) {\n         if (msg.sender == _0xa32c9a) {\n             _0xa32c9a = _0x6db0df;\n         }\n     }\n\n     function _0xab1110() returns (address[]) {\n         return _0x2ccd79;\n     }\n\n     function _0x4fa9ba() returns (uint[]) {\n         return _0xb3b7b8;\n     }\n }\n",
      "rename_map": {
        "inheritToNextGeneration": "_0x34bb27",
        "lastCreditorPayedOut": "_0x8554c5",
        "getCreditorAddresses": "_0xab1110",
        "lendGovernmentMoney": "_0x65ca80",
        "lastTimeOfNewCredit": "_0xb19702",
        "getCreditorAmounts": "_0x4fa9ba",
        "creditorAddresses": "_0x2ccd79",
        "investInTheSystem": "_0x5ac4e3",
        "profitFromCrash": "_0x3c4bb6",
        "creditorAmounts": "_0xb3b7b8",
        "nextGeneration": "_0x6db0df",
        "totalPayedOut": "_0x74e9dd",
        "corruptElite": "_0xa32c9a",
        "totalDebt": "_0xecedd9",
        "buddies": "_0x9220d8",
        "payout": "_0xb7719a",
        "amount": "_0xd81787",
        "buddy": "_0x8eb134",
        "round": "_0xbcfdc4",
        "debt": "_0x1e9557"
      },
      "changes": [
        "Renamed 20 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_155",
      "transformed_id": "ss_l2_hex_sn_ds_155",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.4.24;\n\ncontract Refunder {\n\naddress[] private _0x5629c5;\nmapping (address => uint) public _0x69352f;\n\n    constructor() {\n        _0x5629c5.push(0x79B483371E87d664cd39491b5F06250165e4b184);\n        _0x5629c5.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n    }\n\n    // bad\n    function _0xe76246() public {\n        for(uint x; x < _0x5629c5.length; x++) { // arbitrary length iteration based on how many addresses participated\n            require(_0x5629c5[x].send(_0x69352f[_0x5629c5[x]])); // doubly bad, now a single failure on send will hold up all funds\n        }\n    }\n\n}",
      "rename_map": {
        "refundAddresses": "_0x5629c5",
        "refundAll": "_0xe76246",
        "refunds": "_0x69352f"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_156",
      "transformed_id": "ss_l2_hex_sn_ds_156",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n  function _0x91d212(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  function _0xd1120a(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  function _0xbf9a9b(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function _0x6d6749(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  function _0x240c7c(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\ncontract ERC20 {\n\n  event Transfer( address indexed from, address indexed _0x10b091, uint256 value );\n  event Approval( address indexed _0x624050, address indexed _0xf6205c, uint256 value);\n  using SafeMath for *;\n\n  mapping (address => uint256) private _0xe45f00;\n\n  mapping (address => mapping (address => uint256)) private _0xe151f9;\n\n  uint256 private _0x65757b;\n\n  constructor(uint _0xf674bc){\n    _0xe45f00[msg.sender] = _0xf674bc;\n  }\n\n  function _0xe5e851(address _0x624050) public view returns (uint256) {\n    return _0xe45f00[_0x624050];\n  }\n\n  function _0xd0c350(address _0x624050, address _0xf6205c) public view returns (uint256)\n  {\n    return _0xe151f9[_0x624050][_0xf6205c];\n  }\n\n  function transfer(address _0x10b091, uint256 value) public returns (bool) {\n    require(value <= _0xe45f00[msg.sender]);\n    require(_0x10b091 != address(0));\n\n    _0xe45f00[msg.sender] = _0xe45f00[msg.sender]._0xbf9a9b(value);\n    _0xe45f00[_0x10b091] = _0xe45f00[_0x10b091]._0x6d6749(value);\n    emit Transfer(msg.sender, _0x10b091, value);\n    return true;\n  }\n  function _0xa65139(address _0xf6205c, uint256 value) public returns (bool) {\n    require(_0xf6205c != address(0));\n    _0xe151f9[msg.sender][_0xf6205c] = value;\n    emit Approval(msg.sender, _0xf6205c, value);\n    return true;\n  }\n\n  function _0x585fb2(address from, address _0x10b091, uint256 value) public returns (bool) {\n    require(value <= _0xe45f00[from]);\n    require(value <= _0xe151f9[from][msg.sender]);\n    require(_0x10b091 != address(0));\n\n    _0xe45f00[from] = _0xe45f00[from]._0xbf9a9b(value);\n    _0xe45f00[_0x10b091] = _0xe45f00[_0x10b091]._0x6d6749(value);\n    _0xe151f9[from][msg.sender] = _0xe151f9[from][msg.sender]._0xbf9a9b(value);\n    emit Transfer(from, _0x10b091, value);\n    return true;\n  }\n}\n",
      "rename_map": {
        "transferFrom": "_0x585fb2",
        "_totalSupply": "_0x65757b",
        "totalSupply": "_0xf674bc",
        "balanceOf": "_0xe5e851",
        "allowance": "_0xd0c350",
        "_balances": "_0xe45f00",
        "_allowed": "_0xe151f9",
        "spender": "_0xf6205c",
        "approve": "_0xa65139",
        "owner": "_0x624050",
        "sub": "_0xbf9a9b",
        "add": "_0x6d6749",
        "mul": "_0x91d212",
        "mod": "_0x240c7c",
        "div": "_0xd1120a",
        "to": "_0x10b091"
      },
      "changes": [
        "Renamed 16 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_157",
      "transformed_id": "ss_l2_hex_sn_ds_157",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.22;\n\ncontract FindThisHash {\n    bytes32 constant public _0xb10061 = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;\n\n    constructor() public payable {} // load with ether\n\n    function _0x64389d(string _0xd62f01) public {\n        // If you can find the pre image of the hash, receive 1000 ether\n        require(_0xb10061 == _0xa7dcfa(_0xd62f01));\n        msg.sender.transfer(1000 ether);\n    }\n}",
      "rename_map": {
        "solution": "_0xd62f01",
        "solve": "_0x64389d",
        "sha3": "_0xa7dcfa",
        "hash": "_0xb10061"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_158",
      "transformed_id": "ss_l2_hex_sn_ds_158",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n    address public _0x315c2f;\n    bool public _0xb5d6ff;\n    uint public _0x67cc31;\n\n    function EthTxOrderDependenceMinimal() public {\n        _0x315c2f = msg.sender;\n    }\n\n    function _0x940a59() public payable {\n        require (!_0xb5d6ff);\n\n        require(msg.sender == _0x315c2f);\n        _0x315c2f.transfer(_0x67cc31);\n        _0x67cc31 = msg.value;\n    }\n\n    function _0x5f832b(uint256 _0xfce6c0) {\n        require (!_0xb5d6ff);\n        require(_0xfce6c0 < 10);\n        msg.sender.transfer(_0x67cc31);\n        _0xb5d6ff = true;\n    }\n}",
      "rename_map": {
        "claimReward": "_0x5f832b",
        "submission": "_0xfce6c0",
        "setReward": "_0x940a59",
        "claimed": "_0xb5d6ff",
        "reward": "_0x67cc31",
        "owner": "_0x315c2f"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_159",
      "transformed_id": "ss_l2_hex_sn_ds_159",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.2;\n\ncontract OddsAndEvens{\n\n  struct Player {\n    address _0x3aa6eb;\n    uint number;\n  }\n\n  Player[2] public _0xd0ed08;         //public only for debug purpose\n\n  uint8 _0x2cfa03;\n  address _0x3553df;\n\n  function OddsAndEvens() {\n    _0x3553df = msg.sender;\n  }\n  function _0x1426b7(uint number) payable{\n    if (msg.value != 1 ether) throw;\n    _0xd0ed08[_0x2cfa03] = Player(msg.sender, number);\n    _0x2cfa03++;\n\n    if (_0x2cfa03==2) _0x8b2872();\n  }\n\n  function _0x8b2872() private {\n    bool _0x1c1cff ;\n    uint n = _0xd0ed08[0].number+_0xd0ed08[1].number;\n    if (n%2==0) {\n      _0x1c1cff = _0xd0ed08[0]._0x3aa6eb.send(1800 finney);\n    }\n    else {\n      _0x1c1cff = _0xd0ed08[1]._0x3aa6eb.send(1800 finney);\n    }\n\n    delete _0xd0ed08;\n    _0x2cfa03=0;\n  }\n\n  function _0x649e84() {\n    if(msg.sender!=_0x3553df) throw;\n    bool _0x1c1cff = msg.sender.send(this.balance);\n  }\n\n}",
      "rename_map": {
        "andTheWinnerIs": "_0x8b2872",
        "getProfit": "_0x649e84",
        "players": "_0xd0ed08",
        "owner": "_0x3553df",
        "addr": "_0x3aa6eb",
        "play": "_0x1426b7",
        "res": "_0x1c1cff",
        "tot": "_0x2cfa03"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_160",
      "transformed_id": "ss_l2_hex_sn_ds_160",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\n// CryptoRoulette\n//\n// Guess the number secretly stored in the blockchain and win the whole contract balance!\n// A new number is randomly chosen after each try.\n\n// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether\n\ncontract CryptoRoulette {\n\n    uint256 private _0xc172ce;\n    uint256 public _0x287e32;\n    uint256 public _0xaa2781 = 0.1 ether;\n    address public _0x9d3b48;\n\n    struct Game {\n        address _0xf25dbb;\n        uint256 number;\n    }\n    Game[] public _0x1d6418;\n\n    function CryptoRoulette() public {\n        _0x9d3b48 = msg.sender;\n        _0x4ba6e0();\n    }\n\n    function _0x4ba6e0() internal {\n        // randomly set secretNumber with a value between 1 and 20\n        _0xc172ce = uint8(_0x0228bf(_0xd5bbee, block.blockhash(block.number-1))) % 20 + 1;\n    }\n\n    function _0x244d8b(uint256 number) payable public {\n        require(msg.value >= _0xaa2781 && number <= 10);\n        Game _0x6a8bc9;\n        _0x6a8bc9._0xf25dbb = msg.sender;\n        _0x6a8bc9.number = number;\n        _0x1d6418.push(_0x6a8bc9);\n\n        if (number == _0xc172ce) {\n            // win!\n            msg.sender.transfer(this.balance);\n        }\n\n        _0x4ba6e0();\n        _0x287e32 = _0xd5bbee;\n    }\n\n    function _0x521579() public {\n        if (msg.sender == _0x9d3b48 && _0xd5bbee > _0x287e32 + 1 days) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n}",
      "rename_map": {
        "secretNumber": "_0xc172ce",
        "gamesPlayed": "_0x1d6418",
        "lastPlayed": "_0x287e32",
        "ownerAddr": "_0x9d3b48",
        "betPrice": "_0xaa2781",
        "shuffle": "_0x4ba6e0",
        "player": "_0xf25dbb",
        "kill": "_0x521579",
        "game": "_0x6a8bc9",
        "sha3": "_0x0228bf",
        "play": "_0x244d8b",
        "now": "_0xd5bbee"
      },
      "changes": [
        "Renamed 12 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_161",
      "transformed_id": "ss_l2_hex_sn_ds_161",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract NameRegistrar {\n\n    bool public _0xb34509 = false;  // registrar locked, no name updates\n\n    struct NameRecord { // map hashes to addresses\n        bytes32 _0xdd4699;\n        address _0xd3b442;\n    }\n\n    mapping(address => NameRecord) public _0x16b7cd; // records who registered names\n    mapping(bytes32 => address) public _0x819ec4; // resolves hashes to addresses\n\n    function _0x67431e(bytes32 _0x832a8b, address _0x1caf36) public {\n        // set up the new NameRecord\n        NameRecord _0x8795f7;\n        _0x8795f7._0xdd4699 = _0x832a8b;\n        _0x8795f7._0xd3b442 = _0x1caf36;\n\n        _0x819ec4[_0x832a8b] = _0x1caf36;\n        _0x16b7cd[msg.sender] = _0x8795f7;\n\n        require(_0xb34509); // only allow registrations if contract is unlocked\n    }\n}\n",
      "rename_map": {
        "registeredNameRecord": "_0x16b7cd",
        "_mappedAddress": "_0x1caf36",
        "mappedAddress": "_0xd3b442",
        "newRecord": "_0x8795f7",
        "unlocked": "_0xb34509",
        "register": "_0x67431e",
        "resolve": "_0x819ec4",
        "_name": "_0x832a8b",
        "name": "_0xdd4699"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_162",
      "transformed_id": "ss_l2_hex_sn_ds_162",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint _0xd9a84f;\n        uint _0x9aa383;\n        uint _0xd0c355;\n        uint _0xa5b86d;\n    }\n\n    address _0x7fd61f; //address of the owner\n    uint private _0x5384a2; //seed used to calculate number of an address\n    uint private _0xdd44eb; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n\n    mapping (address => bool) _0x0a06db; //keeping track of addresses that have already won\n\n    function OpenAddressLottery() {\n        _0x7fd61f = msg.sender;\n        _0xa01c9d(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0xdf5bbf() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n\n        // make sure he hasn't won already\n        require(_0x0a06db[msg.sender] == false);\n\n        if(_0xaa6e27(msg.sender) == LuckyNumber){ //check if it equals 7\n            _0x0a06db[msg.sender] = true; // every address can only win once\n\n            uint _0x4111b6=msg.value*7; //win = 7 times the ticket price\n\n            if(_0x4111b6>this.balance) //if the balance isnt sufficient...\n                _0x4111b6=this.balance; //...send everything we've got\n            msg.sender.transfer(_0x4111b6);\n        }\n\n        if(block.number-_0xdd44eb>1000) //reseed if needed\n            _0xa01c9d(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0xaa6e27(address _0xa16362) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(_0x73d5bf(uint(_0xa16362), _0x5384a2)[0]) % 8;\n    }\n\n    function _0xa01c9d(SeedComponents _0xfbe9ba) internal {\n        _0x5384a2 = uint256(_0x73d5bf(\n            _0xfbe9ba._0xd9a84f,\n            _0xfbe9ba._0x9aa383,\n            _0xfbe9ba._0xd0c355,\n            _0xfbe9ba._0xa5b86d\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        _0xdd44eb = block.number;\n    }\n\n    function _0x15b846() {\n        require(msg.sender==_0x7fd61f);\n\n        selfdestruct(msg.sender);\n    }\n\n    function _0x9c7901() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==_0x7fd61f);\n        SeedComponents s;\n        s._0xd9a84f = uint(msg.sender);\n        s._0x9aa383 = uint256(block.blockhash(block.number - 1));\n        s._0xd0c355 = block.difficulty*(uint)(block.coinbase);\n        s._0xa5b86d = tx.gasprice * 7;\n\n        _0xa01c9d(s); //reseed\n    }\n\n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=_0x7fd61f) //owner can't participate, he can only fund the jackpot\n            _0xdf5bbf();\n    }\n\n}\n",
      "rename_map": {
        "luckyNumberOfAddress": "_0xaa6e27",
        "forceReseed": "_0x9c7901",
        "participate": "_0xdf5bbf",
        "component4": "_0xa5b86d",
        "component2": "_0x9aa383",
        "component1": "_0xd9a84f",
        "components": "_0xfbe9ba",
        "lastReseed": "_0xdd44eb",
        "component3": "_0xd0c355",
        "secretSeed": "_0x5384a2",
        "keccak256": "_0x73d5bf",
        "winner": "_0x0a06db",
        "reseed": "_0xa01c9d",
        "owner": "_0x7fd61f",
        "addr": "_0xa16362",
        "kill": "_0x15b846",
        "win": "_0x4111b6"
      },
      "changes": [
        "Renamed 17 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_163",
      "transformed_id": "ss_l2_hex_sn_ds_163",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.11;\n\n contract MyToken {\n     mapping (address => uint) _0x978ff1;\n\n     event Transfer(address indexed _0x0d2a14, address indexed _0x3f5216, uint256 _0x255134);\n\n     function MyToken() {\n         _0x978ff1[tx.origin] = 10000;\n     }\n     function _0x714f2d(address _0xc9967e, uint _0xb90e69) returns(bool _0xaf27d1) {\n         if (_0x978ff1[msg.sender] < _0xb90e69) return false;\n         _0x978ff1[msg.sender] -= _0xb90e69;\n         _0x978ff1[_0xc9967e] += _0xb90e69;\n         Transfer(msg.sender, _0xc9967e, _0xb90e69);\n         return true;\n     }\n\n     function _0xe5ad2a(address _0xe35880) constant returns(uint) {\n         return _0x978ff1[_0xe35880];\n     }\n }",
      "rename_map": {
        "sufficient": "_0xaf27d1",
        "getBalance": "_0xe5ad2a",
        "sendCoin": "_0x714f2d",
        "balances": "_0x978ff1",
        "_value": "_0x255134",
        "amount": "_0xb90e69",
        "_from": "_0x0d2a14",
        "addr": "_0xe35880",
        "_to": "_0x3f5216",
        "to": "_0xc9967e"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_164",
      "transformed_id": "ss_l2_hex_sn_ds_164",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address public _0xe51230;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public _0x97eaa9;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    function EtherLotto() {\n        _0xe51230 = msg.sender;\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function _0x527d38() payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        _0x97eaa9 += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        var _0x55ea10 = uint(_0x94194b(block.timestamp)) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (_0x55ea10 == 0) {\n\n            // Send fee to bank account.\n            _0xe51230.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(_0x97eaa9 - FEE_AMOUNT);\n\n            // Restart jackpot.\n            _0x97eaa9 = 0;\n        }\n    }\n\n}",
      "rename_map": {
        "random": "_0x55ea10",
        "bank": "_0xe51230",
        "sha3": "_0x94194b",
        "play": "_0x527d38",
        "pot": "_0x97eaa9"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_165",
      "transformed_id": "ss_l2_hex_sn_ds_165",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract Governmental {\n  address public _0xfc7371;\n  address public _0x9aecaf;\n  uint public _0x99e629 = 1 ether;\n  uint public _0x67665a;\n  uint public ONE_MINUTE = 1 minutes;\n\n  function Governmental() {\n    _0xfc7371 = msg.sender;\n    if (msg.value<1 ether) throw;\n  }\n\n  function _0xa89bbe() {\n    if (msg.value<_0x99e629/2) throw;\n    _0x9aecaf = msg.sender;\n    _0x99e629 += msg.value/2;\n    _0x67665a = block.timestamp;\n  }\n\n  function _0x803485() {\n    if (block.timestamp < _0x67665a+ONE_MINUTE)\n      throw;\n\n    _0x9aecaf.send(_0x99e629);\n    _0xfc7371.send(this.balance-1 ether);\n\n    _0x9aecaf = 0;\n    _0x99e629 = 1 ether;\n    _0x67665a = 0;\n  }\n}\n\ncontract Operator {\n\n  function _0x671a7a(address _0x2477e2, uint _0xe23c35) {\n    if (0<=_0xe23c35 && _0xe23c35<1023) {\n      this._0x671a7a.gas(msg.gas-2000)(_0x2477e2, _0xe23c35+1);\n    }\n    else {\n      Governmental(_0x2477e2)._0x803485();\n    }\n  }\n}\n",
      "rename_map": {
        "lastInvestmentTimestamp": "_0x67665a",
        "resetInvestment": "_0x803485",
        "lastInvestor": "_0x9aecaf",
        "jackpot": "_0x99e629",
        "operate": "_0x671a7a",
        "target": "_0x2477e2",
        "invest": "_0xa89bbe",
        "owner": "_0xfc7371",
        "count": "_0xe23c35"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_166",
      "transformed_id": "ss_l2_hex_sn_ds_166",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.0;\ncontract _0x1f364f {\n  address _0x179e06;\n  uint    timestamp;\n  function _0x6482f7(uint _0x259aba) internal {\n    if ( _0x259aba> 0 && _0x153856 - _0x259aba > 24 hours ) {\n      msg.sender.send( msg.value );\n\n      if ( this.balance > 0 ) {\n        _0x179e06.send( this.balance );\n      }\n    }\n    else if ( msg.value >= 1 ether ) {\n      _0x179e06 = msg.sender;\n      timestamp = _0x259aba;\n    }\n  }\n  function _0x8168b1() constant returns (uint _0xfb61c3) {\n      return block.timestamp;\n    }\n  function _0x55e6d0(uint _0x1cbf1a){\n    uint _0xfb61c3=_0x8168b1();\n    _0x6482f7(_0xfb61c3);\n  }\n}",
      "rename_map": {
        "randomNumber": "_0xfb61c3",
        "lottopollo": "_0x1f364f",
        "randomGen": "_0x8168b1",
        "leader": "_0x179e06",
        "payOut": "_0x6482f7",
        "draw": "_0x55e6d0",
        "seed": "_0x1cbf1a",
        "rand": "_0x259aba",
        "now": "_0x153856"
      },
      "changes": [
        "Renamed 9 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_167",
      "transformed_id": "ss_l2_hex_sn_ds_167",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract Roulette {\n    uint public _0xda05bb; // Forces one bet per block\n\n    constructor() public payable {} // initially fund contract\n\n    // fallback function used to make a bet\n    function () public payable {\n        require(msg.value == 10 ether); // must send 10 ether to play\n        require(_0xe8a21a != _0xda05bb); // only 1 transaction per block\n        _0xda05bb = _0xe8a21a;\n        if(_0xe8a21a % 15 == 0) { // winner\n            msg.sender.transfer(this.balance);\n        }\n    }\n}",
      "rename_map": {
        "pastBlockTime": "_0xda05bb",
        "now": "_0xe8a21a"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_168",
      "transformed_id": "ss_l2_hex_sn_ds_168",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract TimedCrowdsale {\n  // Sale should finish exactly at January 1, 2019\n  function _0xa68501() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n}",
      "rename_map": {
        "isSaleFinished": "_0xa68501"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_169",
      "transformed_id": "ss_l2_hex_sn_ds_169",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.9;\n\ncontract TownCrier {\n    struct Request { // the data structure for each request\n        address _0x08c69a; // the address of the requester\n        uint _0x855642; // the amount of wei the requester pays for the request\n        address _0xc07514; // the address of the contract to call for delivering response\n        bytes4 _0x7c3b4d; // the specification of the callback function\n        bytes32 _0xa84118; // the hash of the request parameters\n    }\n\n    event Upgrade(address _0x37c923);\n    event Reset(uint _0xbcd197, uint _0x8d4923, uint _0x9a2773);\n    event RequestInfo(uint64 _0x5648c2, uint8 _0x37459d, address _0x08c69a, uint _0x855642, address _0xc07514, bytes32 _0xa84118, uint timestamp, bytes32[] _0x1b5867); // log of requests, the Town Crier server watches this event and processes requests\n    event DeliverInfo(uint64 _0xb00add, uint _0x855642, uint gasPrice, uint _0xc70168, uint _0xdba859, bytes32 _0xa84118, uint64 error, bytes32 _0x921f00); // log of responses\n    event Cancel(uint64 _0xb00add, address _0x1c40a0, address _0x08c69a, uint _0x855642, int _0xfef12e); // log of cancellations\n\n    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;// address of the SGX account\n\n    uint public GAS_PRICE = 5 * 10**10;\n    uint public MIN_FEE = 30000 * GAS_PRICE; // minimum fee required for the requester to pay such that SGX could call deliver() to send a response\n    uint public CANCELLATION_FEE = 25000 * GAS_PRICE; // charged when the requester cancels a request that is not responded\n\n    uint public constant CANCELLED_FEE_FLAG = 1;\n    uint public constant DELIVERED_FEE_FLAG = 0;\n    int public constant FAIL_FLAG = -2 ** 250;\n    int public constant SUCCESS_FLAG = 1;\n\n    bool public _0x45a64b;\n\n    bool public _0x460bb9;\n\n    uint64 public _0x2e04fb;\n    uint64 public _0x8efe02;\n    Request[2**64] public _0x078a52;\n\n    int public _0x3bd2b7 = 0;\n\n    // Contracts that receive Ether but do not define a fallback function throw\n    // an exception, sending back the Ether (this was different before Solidity\n    // v0.4.0). So if you want your contract to receive Ether, you have to\n    // implement a fallback function.\n    function () {}\n\n    function TownCrier() public {\n        // Start request IDs at 1 for two reasons:\n        //   1. We can use 0 to denote an invalid request (ids are unsigned)\n        //   2. Storage is more expensive when changing something from zero to non-zero,\n        //      so this means the first request isn't randomly more expensive.\n        _0x2e04fb = 1;\n        _0x078a52[0]._0x08c69a = msg.sender;\n        _0x45a64b = false;\n        _0x8efe02 = 0;\n        _0x460bb9 = false;\n    }\n\n    function _0xe0aef6(address _0x37c923) {\n        if (msg.sender == _0x078a52[0]._0x08c69a && _0x8efe02 == 0) {\n            _0x3bd2b7 = -int(_0x37c923);\n            _0x45a64b = true;\n            Upgrade(_0x37c923);\n        }\n    }\n\n    function _0xfc8373(uint _0x47b592, uint _0x39b8d3, uint _0x98426b) public {\n        if (msg.sender == _0x078a52[0]._0x08c69a && _0x8efe02 == 0) {\n            GAS_PRICE = _0x47b592;\n            MIN_FEE = _0x47b592 * _0x39b8d3;\n            CANCELLATION_FEE = _0x47b592 * _0x98426b;\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n        }\n    }\n\n    function _0xd03a86() public {\n        if (msg.sender == _0x078a52[0]._0x08c69a) {\n            _0x45a64b = true;\n        }\n    }\n\n    function _0x9359b1() public {\n        if (msg.sender == _0x078a52[0]._0x08c69a && _0x3bd2b7 == 0) {\n            _0x45a64b = false;\n        }\n    }\n\n    function _0xeebb70() public {\n        if (msg.sender == _0x078a52[0]._0x08c69a && _0x8efe02 == 0) {\n            if (!_0x078a52[0]._0x08c69a.call.value(this.balance)()) {\n                throw;\n            }\n        }\n    }\n\n    function _0xd9e2ff(uint8 _0x37459d, address _0xc07514, bytes4 _0x7c3b4d, uint timestamp, bytes32[] _0x1b5867) public payable returns (int) {\n        if (_0x460bb9) {\n            throw;\n        }\n\n        if (_0x45a64b) {\n            _0x460bb9 = true;\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            _0x460bb9 = false;\n            return _0x3bd2b7;\n        }\n\n        if (msg.value < MIN_FEE) {\n            _0x460bb9 = true;\n            // If the amount of ether sent by the requester is too little or\n            // too much, refund the requester and discard the request.\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            _0x460bb9 = false;\n            return FAIL_FLAG;\n        } else {\n            // Record the request.\n            uint64 _0xb00add = _0x2e04fb;\n            _0x2e04fb++;\n            _0x8efe02++;\n\n            bytes32 _0xa84118 = _0xe12385(_0x37459d, _0x1b5867);\n            _0x078a52[_0xb00add]._0x08c69a = msg.sender;\n            _0x078a52[_0xb00add]._0x855642 = msg.value;\n            _0x078a52[_0xb00add]._0xc07514 = _0xc07514;\n            _0x078a52[_0xb00add]._0x7c3b4d = _0x7c3b4d;\n            _0x078a52[_0xb00add]._0xa84118 = _0xa84118;\n\n            // Log the request for the Town Crier server to process.\n            RequestInfo(_0xb00add, _0x37459d, msg.sender, msg.value, _0xc07514, _0xa84118, timestamp, _0x1b5867);\n            return _0xb00add;\n        }\n    }\n\n    function _0xce13fb(uint64 _0xb00add, bytes32 _0xa84118, uint64 error, bytes32 _0x921f00) public {\n        if (msg.sender != SGX_ADDRESS ||\n                _0xb00add <= 0 ||\n                _0x078a52[_0xb00add]._0x08c69a == 0 ||\n                _0x078a52[_0xb00add]._0x855642 == DELIVERED_FEE_FLAG) {\n            // If the response is not delivered by the SGX account or the\n            // request has already been responded to, discard the response.\n            return;\n        }\n\n        uint _0x855642 = _0x078a52[_0xb00add]._0x855642;\n        if (_0x078a52[_0xb00add]._0xa84118 != _0xa84118) {\n            // If the hash of request parameters in the response is not\n            // correct, discard the response for security concern.\n            return;\n        } else if (_0x855642 == CANCELLED_FEE_FLAG) {\n            // If the request is cancelled by the requester, cancellation\n            // fee goes to the SGX account and set the request as having\n            // been responded to.\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            _0x078a52[_0xb00add]._0x855642 = DELIVERED_FEE_FLAG;\n            _0x8efe02--;\n            return;\n        }\n\n        _0x078a52[_0xb00add]._0x855642 = DELIVERED_FEE_FLAG;\n        _0x8efe02--;\n\n        if (error < 2) {\n            // Either no error occurs, or the requester sent an invalid query.\n            // Send the fee to the SGX account for its delivering.\n            SGX_ADDRESS.send(_0x855642);\n        } else {\n            // Error in TC, refund the requester.\n            _0x460bb9 = true;\n            _0x078a52[_0xb00add]._0x08c69a.call.gas(2300).value(_0x855642)();\n            _0x460bb9 = false;\n        }\n\n        uint _0xdba859 = (_0x855642 - MIN_FEE) / tx.gasprice; // gas left for the callback function\n        DeliverInfo(_0xb00add, _0x855642, tx.gasprice, msg.gas, _0xdba859, _0xa84118, error, _0x921f00); // log the response information\n        if (_0xdba859 > msg.gas - 5000) {\n            _0xdba859 = msg.gas - 5000;\n        }\n\n        _0x460bb9 = true;\n        _0x078a52[_0xb00add]._0xc07514.call.gas(_0xdba859)(_0x078a52[_0xb00add]._0x7c3b4d, _0xb00add, error, _0x921f00); // call the callback function in the application contract\n        _0x460bb9 = false;\n    }\n\n    function _0x4e74d2(uint64 _0xb00add) public returns (int) {\n        if (_0x460bb9) {\n            throw;\n        }\n\n        if (_0x45a64b) {\n            return 0;\n        }\n\n        uint _0x855642 = _0x078a52[_0xb00add]._0x855642;\n        if (_0x078a52[_0xb00add]._0x08c69a == msg.sender && _0x855642 >= CANCELLATION_FEE) {\n            // If the request was sent by this user and has money left on it,\n            // then cancel it.\n            _0x078a52[_0xb00add]._0x855642 = CANCELLED_FEE_FLAG;\n            _0x460bb9 = true;\n            if (!msg.sender.call.value(_0x855642 - CANCELLATION_FEE)()) {\n                throw;\n            }\n            _0x460bb9 = false;\n            Cancel(_0xb00add, msg.sender, _0x078a52[_0xb00add]._0x08c69a, _0x078a52[_0xb00add]._0x855642, 1);\n            return SUCCESS_FLAG;\n        } else {\n            Cancel(_0xb00add, msg.sender, _0x078a52[_0xb00add]._0x08c69a, _0x855642, -1);\n            return FAIL_FLAG;\n        }\n    }\n}",
      "rename_map": {
        "cancellation_fee": "_0x9a2773",
        "externalCallFlag": "_0x460bb9",
        "cancellationGas": "_0x98426b",
        "unrespondedCnt": "_0x8efe02",
        "callbackAddr": "_0xc07514",
        "callbackFID": "_0x7c3b4d",
        "callbackGas": "_0xdba859",
        "requestData": "_0x1b5867",
        "requestType": "_0x37459d",
        "newVersion": "_0x3bd2b7",
        "killswitch": "_0x45a64b",
        "requestCnt": "_0x2e04fb",
        "paramsHash": "_0xa84118",
        "gas_price": "_0xbcd197",
        "requestId": "_0xb00add",
        "requester": "_0x08c69a",
        "canceller": "_0x1c40a0",
        "requests": "_0x078a52",
        "respData": "_0x921f00",
        "withdraw": "_0xeebb70",
        "gasLeft": "_0xc70168",
        "deliver": "_0xce13fb",
        "newAddr": "_0x37c923",
        "min_fee": "_0x8d4923",
        "suspend": "_0xd03a86",
        "restart": "_0x9359b1",
        "upgrade": "_0xe0aef6",
        "request": "_0xd9e2ff",
        "cancel": "_0x4e74d2",
        "minGas": "_0x39b8d3",
        "reset": "_0xfc8373",
        "price": "_0x47b592",
        "flag": "_0xfef12e",
        "sha3": "_0xe12385",
        "fee": "_0x855642",
        "id": "_0x5648c2"
      },
      "changes": [
        "Renamed 36 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_170",
      "transformed_id": "ss_l2_hex_sn_ds_170",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\n/// @author Jordi Baylina\n/// Auditors: Griff Green & psdev\n/// @notice Based on http://hudsonjameson.com/ethereummarriage/\n/// License: GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier _0x51c3a5() {\n        require(msg.sender == _0x1f3b2a);\n        _;\n    }\n\n    address public _0x1f3b2a;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        _0x1f3b2a = msg.sender;\n    }\n\n    address public _0x06adb3;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function _0xbf92fc(address _0xcb8411) _0x51c3a5 {\n        _0x06adb3 = _0xcb8411;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function _0x4aff21() {\n        if (msg.sender == _0x06adb3) {\n            _0x1f3b2a = _0x06adb3;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function _0x07a025(address _0xa96431, uint _0x49ad66, bytes _0xff142f) _0x51c3a5 {\n        _0xa96431.call.value(_0x49ad66)(_0xff142f);\n    }\n}\n\ncontract Marriage is Owned\n{\n    // Marriage data variables\n    string public _0x1cb2f3;\n    string public _0x5292c7;\n    uint public _0x8ff01a;\n    string public _0x02d3c0;\n    string public _0xd068a2;\n\n    Event[] public _0x31ef15;\n    Message[] public _0xd89867;\n\n    struct Event {\n        uint _0x8c8e16;\n        string _0x410679;\n        string _0x837ae7;\n        string _0xab07d5;\n    }\n\n    struct Message {\n        uint _0x8c8e16;\n        string _0x8514de;\n        string _0x93fad1;\n        string _0xab07d5;\n        uint value;\n    }\n\n    modifier _0x68041e {\n        require(_0x7d6d96(_0x02d3c0) == _0x7d6d96(\"Married\"));\n        _;\n    }\n\n    //Set Owner\n    function Marriage(address _0xc2aa46) {\n        _0x1f3b2a = _0xc2aa46;\n    }\n\n    function _0xc7206a() constant public returns (uint) {\n        return _0x31ef15.length;\n    }\n\n    function _0xa32b32() constant public returns (uint) {\n        return _0xd89867.length;\n    }\n\n    // Create initial marriage contract\n    function _0x02cb6d(\n        string _0x96628c,\n        string _0x2b4f3f,\n        string _0x9985f2,\n        string _0xab07d5) _0x51c3a5\n    {\n        require(_0x31ef15.length == 0);\n        _0x1cb2f3 = _0x96628c;\n        _0x5292c7 = _0x2b4f3f;\n        _0x8ff01a = _0x0d8cc1;\n        _0xd068a2 = _0x9985f2;\n        _0x02d3c0 = \"Married\";\n        _0x31ef15.push(Event(_0x0d8cc1, \"Marriage\", _0xd068a2, _0xab07d5));\n        MajorEvent(\"Marrigage\", _0xd068a2, _0xab07d5);\n    }\n\n    // Set the marriage status if it changes\n    function _0x3c1d34(string _0x15698d, string _0xab07d5) _0x51c3a5\n    {\n        _0x02d3c0 = _0x15698d;\n        setMajorEvent(\"Changed Status\", _0x15698d, _0xab07d5);\n    }\n\n    // Set the IPFS hash of the image of the couple\n    function setMajorEvent(string _0x410679, string _0x837ae7, string _0xab07d5) _0x51c3a5 _0x68041e\n    {\n        _0x31ef15.push(Event(_0x0d8cc1, _0x410679, _0x837ae7, _0xab07d5));\n        MajorEvent(_0x410679, _0x837ae7, _0xab07d5);\n    }\n\n    function _0x117be7(string _0x8514de, string _0x93fad1, string _0xab07d5) payable _0x68041e {\n        if (msg.value > 0) {\n            _0x1f3b2a.transfer(this.balance);\n        }\n        _0xd89867.push(Message(_0x0d8cc1, _0x8514de, _0x93fad1, _0xab07d5, msg.value));\n        MessageSent(_0x8514de, _0x93fad1, _0xab07d5, msg.value);\n    }\n\n    // Declare event structure\n    event MajorEvent(string _0x410679, string _0x837ae7, string _0xab07d5);\n    event MessageSent(string _0x410679, string _0x837ae7, string _0xab07d5, uint value);\n}",
      "rename_map": {
        "numberOfMajorEvents": "_0xc7206a",
        "numberOfMessages": "_0xa32b32",
        "acceptOwnership": "_0x4aff21",
        "marriageStatus": "_0x02d3c0",
        "createMarriage": "_0x02cb6d",
        "marriageDate": "_0x8ff01a",
        "majorEvents": "_0x31ef15",
        "changeOwner": "_0xbf92fc",
        "description": "_0x837ae7",
        "sendMessage": "_0x117be7",
        "areMarried": "_0x68041e",
        "_partner1": "_0x96628c",
        "setStatus": "_0x3c1d34",
        "_newOwner": "_0xcb8411",
        "_partner2": "_0x2b4f3f",
        "onlyOwner": "_0x51c3a5",
        "nameFrom": "_0x8514de",
        "partner1": "_0x1cb2f3",
        "messages": "_0xd89867",
        "newOwner": "_0x06adb3",
        "partner2": "_0x5292c7",
        "execute": "_0x07a025",
        "status": "_0x15698d",
        "_owner": "_0xc2aa46",
        "_value": "_0x49ad66",
        "owner": "_0x1f3b2a",
        "_data": "_0xff142f",
        "_vows": "_0x9985f2",
        "vows": "_0xd068a2",
        "date": "_0x8c8e16",
        "text": "_0x93fad1",
        "_dst": "_0xa96431",
        "sha3": "_0x7d6d96",
        "name": "_0x410679",
        "url": "_0xab07d5",
        "now": "_0x0d8cc1"
      },
      "changes": [
        "Renamed 36 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_171",
      "transformed_id": "ss_l2_hex_sn_ds_171",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract Splitter{\n\n\taddress public _0x4ea880;\n\taddress[] public _0x16e198;\n\tmapping (uint256 => address) public _0xe73240;\n\taddress private _0xcfd94e;\n\tuint256 private _0x914cb2;\n\tuint256 private _0x3168eb;\n\n//constructor\n\n\tconstructor() payable public{\n\t\t_0x4ea880 = msg.sender;\n\t\t_0x75598d();\n\t\t_0x75598d();\n\t\t_0x75598d();\n\t\t_0x75598d();\n\t\t_0xe73240[0] = _0x16e198[0];\n        _0xe73240[1] = _0x16e198[1];\n        _0xe73240[2] = _0x16e198[2];\n        _0xe73240[3] = _0x16e198[3];\n\t}\n\n//withdraw (just in case)\n\n\tfunction _0x631a01() public{\n\t\trequire(msg.sender == _0x4ea880);\n\t\t_0x4ea880.transfer(address(this).balance);\n\t}\n\n//puppet count\n\n\tfunction _0xce4811() public constant returns(uint256 _0x35919b){\n    \treturn _0x16e198.length;\n  \t}\n\n//deploy contracts\n\n\tfunction _0x75598d() public returns(address _0x75598d){\n\t    require(msg.sender == _0x4ea880);\n    \tPuppet p = new Puppet();\n    \t_0x16e198.push(p);\n    \treturn p;\n  \t\t}\n\n//update mapping\n\n    function _0x96bb27(uint256 _0x813f97, address _0xf7f303) public {\n        require(_0xf7f303 != address(0));\n        _0xe73240[_0x813f97] = _0xf7f303;\n    }\n\n//fund puppets TROUBLESHOOT gas\n\n    function _0xe17eca() public payable {\n        require(msg.sender == _0x4ea880);\n    \t_0x914cb2 = SafeMath._0xe7b44d(msg.value, 4);\n        _0xe73240[0].call.value(_0x914cb2).gas(800000)();\n        _0xe73240[1].call.value(_0x914cb2).gas(800000)();\n        _0xe73240[2].call.value(_0x914cb2).gas(800000)();\n        _0xe73240[3].call.value(_0x914cb2).gas(800000)();\n        }\n\n//fallback function\n\nfunction() payable public{\n\t}\n}\n\ncontract Puppet {\n\n    mapping (uint256 => address) public _0x55dd4f;\n    mapping (uint256 => address) public _0xc01c95;\n\n\tconstructor() payable public{\n\t\t//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;\n\t\t_0x55dd4f[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        _0xc01c95[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\n\t//send shares to doubler\n\t//return profit to master\n\n\tfunction() public payable{\n\t    if(msg.sender != _0x55dd4f[0]){\n\t\t\t_0x55dd4f[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\t//emergency withdraw\n\n\tfunction _0x631a01() public{\n\t\trequire(msg.sender == _0xc01c95[0]);\n\t\t_0xc01c95[0].transfer(address(this).balance);\n\t}\n}\n\n//library\n\nlibrary SafeMath {\n\n  function _0x844c13(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function _0xe7b44d(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function _0xf34eeb(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function _0x372a52(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}",
      "rename_map": {
        "getPuppetCount": "_0xce4811",
        "fundPuppets": "_0xe17eca",
        "puppetCount": "_0x35919b",
        "newPuppet": "_0x75598d",
        "_newExtra": "_0xf7f303",
        "setExtra": "_0x96bb27",
        "withdraw": "_0x631a01",
        "puppets": "_0x16e198",
        "_count": "_0x3168eb",
        "master": "_0xc01c95",
        "target": "_0x55dd4f",
        "_share": "_0x914cb2",
        "owner": "_0x4ea880",
        "extra": "_0xe73240",
        "_addy": "_0xcfd94e",
        "div": "_0xe7b44d",
        "sub": "_0xf34eeb",
        "_id": "_0x813f97",
        "add": "_0x372a52",
        "mul": "_0x844c13"
      },
      "changes": [
        "Renamed 20 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_172",
      "transformed_id": "ss_l2_hex_sn_ds_172",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// winner gets the contract balance\n// 0.02 to play\n\npragma solidity ^0.4.23;\n\ncontract FundManager {\n\n//constants\n\naddress public _0x5f99ff = 0x0;\naddress public _0xf7163b;\naddress public _0x409b3a = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public _0xabd6df = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public _0x532e03;\n\nmapping(address=>bool) _0xdce31b;\n\nuint256 public _0x839d6f;\nuint256[] public _0xf0209f = [951828771,158769871220];\nuint256[] public balance;\n\n//constructor\n\nfunction DranMe() public payable{\n\t_0xf7163b = msg.sender;\n}\n\n//modifiers\n\nmodifier _0xb943bb() {\n    require(msg.sender == _0xf7163b);\n    _;\n}\n\nmodifier _0x8f914b() {\n    require(msg.sender == _0x5f99ff);\n    _;\n}\n\nmodifier _0x1c1016() {\n    require(_0xdce31b[msg.sender]);\n    _;\n}\n\n//functions\n\nfunction _0xc41b20() public constant returns(uint256) {\n\treturn _0xf0209f.length;\n}\n\nfunction _0x9e8ec3(uint256 _0x91b222) public payable _0xb943bb{\n\t_0x839d6f = _0x91b222;\n}\n\nfunction _0x63f558() public constant returns(uint256) {\n\treturn _0x532e03.length;\n}\n\nfunction _0xdedfa0() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction _0x148434() public payable{\n\trequire(msg.value >= 0.02 ether);\n\t_0x532e03.push(msg.sender);\n\t_0xdce31b[msg.sender]=true;\n}\n\nfunction _0x01f2ad() public payable _0x1c1016{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=_0xf7163b || _0xbe35e6()){\n\t    uint256 _0xad5c9f = 0;\n        msg.sender.transfer(_0xad5c9f);\n\t}\n}\n\nfunction _0xbe35e6() private returns(bool){\n    bytes32 _0xaabbad = _0x5cf79b(blockhash(block.number-1));\n    uint256 _0x839d6f = uint256(_0xaabbad);\n        if(_0x839d6f%5==0){\n            _0x5f99ff = msg.sender;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction _0x8fdad6 () public payable _0x1c1016 {\n\trequire (msg.value >= 0.005 ether);\n\t_0x409b3a.call.value(msg.value)();\n}\n\nfunction _0x81531c () public payable _0x1c1016 {\n\trequire (msg.value >= 0.005 ether);\n\t_0xabd6df.call.value(msg.value)();\n}\n\nfunction _0x2c95b7 (uint256 _0x047d72, uint256 _0x21e5c4) public payable _0x1c1016 {\n\t_0xf0209f[_0x047d72] = _0x21e5c4;\n}\n\nfunction _0x35d893 (uint256 _0xfcf344) public payable _0x1c1016 {\n\t_0xf0209f.length = _0xfcf344;\n}\n\nfunction _0x95c72d (uint256 _0x0d9aa7) public payable _0x1c1016 returns(uint256) {\n\treturn (_0x0d9aa7 / (_0xf0209f[0]*_0xf0209f[1]));\n\tif((_0x0d9aa7 / (_0xf0209f[0]*_0xf0209f[1])) == _0x839d6f) {\n\t\t_0xf7163b = _0x5f99ff;\n\t}\n}\n\nfunction _0xc87526 () public payable _0x1c1016 returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == _0x839d6f){\n        return true;\n    }\n}\n\nfunction _0x68b46c() public payable _0xb943bb {\n\t_0xf7163b.call.value(1 wei)();\n}\n\nfunction _0xf60927() public payable _0x8f914b {\n\t_0x5f99ff.transfer(address(this).balance);\n}\n\n//fallback function\n\nfunction() public payable{\n\t}\n}\n",
      "rename_map": {
        "callSecondTarget": "_0x81531c",
        "manipulateSecret": "_0x01f2ad",
        "approvedPlayers": "_0xdce31b",
        "callFirstTarget": "_0x8fdad6",
        "getPlayerCount": "_0x63f558",
        "unlockSecret": "_0xbe35e6",
        "becomePlayer": "_0x148434",
        "secondTarget": "_0xabd6df",
        "onlyPlayers": "_0x1c1016",
        "checkSecret": "_0xc87526",
        "firstTarget": "_0x409b3a",
        "onlyWinner": "_0x8f914b",
        "claimPrize": "_0xf60927",
        "getLength": "_0xc41b20",
        "guessSeed": "_0x95c72d",
        "setSecret": "_0x9e8ec3",
        "keccak256": "_0x5cf79b",
        "onlyOwner": "_0xb943bb",
        "getPrize": "_0xdedfa0",
        "winPrize": "_0x68b46c",
        "players": "_0x532e03",
        "addSeed": "_0x35d893",
        "_secret": "_0x91b222",
        "setSeed": "_0x2c95b7",
        "winner": "_0x5f99ff",
        "secret": "_0x839d6f",
        "_value": "_0x21e5c4",
        "amount": "_0xad5c9f",
        "_index": "_0x047d72",
        "owner": "_0xf7163b",
        "_seed": "_0x0d9aa7",
        "_add": "_0xfcf344",
        "hash": "_0xaabbad",
        "seed": "_0xf0209f"
      },
      "changes": [
        "Renamed 34 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_173",
      "transformed_id": "ss_l2_hex_sn_ds_173",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.11; /* originally >=0.4.11 */\n\ncontract Owned {\n    function Owned() {\n        _0x88f129 = msg.sender;\n    }\n\n    address public _0x88f129;\n\n    // This contract only defines a modifier and a few useful functions\n    // The function body is inserted where the special symbol \"_\" in the\n    // definition of a modifier appears.\n    modifier _0xfec459 { if (msg.sender == _0x88f129) _; }\n\n    function _0x8d8c05(address _0x17dfd9) _0xfec459 {\n        _0x88f129 = _0x17dfd9;\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function _0x720a6a(address _0x08823f, uint _0x1356db, bytes _0x25db16) _0xfec459 {\n        _0x08823f.call.value(_0x1356db)(_0x25db16);\n    }\n}\n// to get the needed token functions in the contract\ncontract Token {\n    function transfer(address, uint) returns(bool);\n    function _0xa42e04(address) constant returns (uint);\n}\n\ncontract TokenSender is Owned {\n    Token public _0x995ddd; // the token we are working with\n    uint public _0x9ea8f4;\n\n    uint public _0x1cc4d4;\n\n    struct Transfer {\n        address _0xd70ed2;\n        uint _0xbfc161;\n    }\n\n    Transfer[] public _0x641111;\n\n    function TokenSender(address _0x5e92de) {\n        _0x995ddd = Token(_0x5e92de);\n    }\n\n    // this is a used to save gas\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n\n    // This is the function that makes the list of transfers and various\n    //  checks around that list, it is a little tricky, the data input is\n    //  structured with the `amount` and the (receiving) `addr` combined as one\n    //  long number and then this number is deconstructed in this function to\n    //  save gas and reduce the number of `0`'s that are needed to be stored\n    //   on the blockchain\n    function _0x1b82c2(uint[] data) _0xfec459 {\n\n        // If the send has started then we just throw\n        if (_0x1cc4d4>0) throw;\n\n        uint _0xda8ede;\n        uint _0xd5c0c1 = _0x641111.length;\n        _0x641111.length = _0x641111.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address _0xd70ed2 = address( data[i] & (D160-1) );\n            uint _0xbfc161 = data[i] / D160;\n\n            _0x641111[_0xd5c0c1 + i]._0xd70ed2 = _0xd70ed2;\n            _0x641111[_0xd5c0c1 + i]._0xbfc161 = _0xbfc161;\n            _0xda8ede += _0xbfc161;\n        }\n        _0x9ea8f4 += _0xda8ede;\n    }\n    // This function actually makes the sends and tracks the amount of gas used\n    //  if it takes more gas than was sent with the transaction then this\n    //  function will need to be called a few times until\n    function _0x1e04fe() _0xfec459 {\n        if (_0x641111.length == 0) return;\n\n        // Keep next in the stack var mNext to save gas\n        uint _0xe87902 = _0x1cc4d4;\n\n        _0x1cc4d4 = _0x641111.length;\n\n        if ((_0xe87902 == 0 ) && ( _0x995ddd._0xa42e04(this) != _0x9ea8f4)) throw;\n\n        while ((_0xe87902<_0x641111.length) && ( gas() > 150000 )) {\n            uint _0xbfc161 = _0x641111[_0xe87902]._0xbfc161;\n            address _0xd70ed2 = _0x641111[_0xe87902]._0xd70ed2;\n            if (_0xbfc161 > 0) {\n                if (!_0x995ddd.transfer(_0xd70ed2, _0x641111[_0xe87902]._0xbfc161)) throw;\n            }\n            _0xe87902 ++;\n        }\n\n        // Set the next to the actual state.\n        _0x1cc4d4 = _0xe87902;\n    }\n\n    ///////////////////////\n    // Helper functions\n    ///////////////////////\n\n    function _0x73ebb4() constant returns (bool) {\n        if (_0x641111.length == 0) return false;\n        if (_0x1cc4d4 < _0x641111.length) return false;\n        return true;\n    }\n\n    function _0x9e7bed() constant returns (uint) {\n        return _0x641111.length;\n    }\n\n    function gas() internal constant returns (uint _0x841dec) {\n        assembly {\n            _0x841dec:= gas\n        }\n    }\n\n}",
      "rename_map": {
        "totalToDistribute": "_0x9ea8f4",
        "hasTerminated": "_0x73ebb4",
        "changeOwner": "_0x8d8c05",
        "nTransfers": "_0x9e7bed",
        "balanceOf": "_0xa42e04",
        "_newOwner": "_0x17dfd9",
        "transfers": "_0x641111",
        "onlyOwner": "_0xfec459",
        "execute": "_0x720a6a",
        "offset": "_0xd5c0c1",
        "_value": "_0x1356db",
        "_token": "_0x5e92de",
        "amount": "_0xbfc161",
        "owner": "_0x88f129",
        "_data": "_0x25db16",
        "mNext": "_0xe87902",
        "token": "_0x995ddd",
        "addr": "_0xd70ed2",
        "_dst": "_0x08823f",
        "fill": "_0x1b82c2",
        "_gas": "_0x841dec",
        "next": "_0x1cc4d4",
        "run": "_0x1e04fe",
        "acc": "_0xda8ede"
      },
      "changes": [
        "Renamed 24 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_174",
      "transformed_id": "ss_l2_hex_sn_ds_174",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract Lotto {\n\n     uint constant public _0x0b1594 = 6800;\n     // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.\n\n     uint constant public _0xca8c5e = 100000000000000000;\n     // the cost of each ticket is .1 ether.\n\n     uint constant public _0x74a618 = 5000000000000000000;\n\n     function _0xdfe5c7() constant returns(uint){ return _0x0b1594; }\n     function _0x35f697() constant returns(uint){ return _0xca8c5e; }\n     //accessors for constants\n\n     struct Round {\n         address[] _0x21a90a;\n         uint _0xa6079e;\n         uint _0xdb49d7;\n         mapping(uint=>bool) _0x6db9b4;\n         mapping(address=>uint) _0xa44d84;\n     }\n     mapping(uint => Round) _0x29d48c;\n     //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was \"cashed\". \"Cashing\" is the act of paying out the pot to the winner.\n\n     function _0x3e8953() constant returns (uint){\n         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n         return block.number/_0x0b1594;\n     }\n\n     function _0xb8f2a6(uint _0x2cbd43,uint _0xf6a674) constant returns (bool){\n         //Determine if a given.\n\n         return _0x29d48c[_0x2cbd43]._0x6db9b4[_0xf6a674];\n     }\n\n     function _0x2ec5b4(uint _0x2cbd43, uint _0xf6a674) constant returns(address){\n         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n         var _0xbbcbc7 = _0x4c6cfb(_0x2cbd43,_0xf6a674);\n\n         if(_0xbbcbc7>block.number)\n             return;\n         //We can't decided the winner if the round isn't over yet\n\n         var _0xfb65ab = _0x101ca8(_0xbbcbc7);\n         var _0x805c63 = _0xfb65ab%_0x29d48c[_0x2cbd43]._0xdb49d7;\n         //We perform a modulus of the blockhash to determine the winner\n\n         var _0x8458a2 = uint256(0);\n\n         for(var _0x19b4e3 = 0; _0x19b4e3<_0x29d48c[_0x2cbd43]._0x21a90a.length; _0x19b4e3++){\n             var _0x6196b5 = _0x29d48c[_0x2cbd43]._0x21a90a[_0x19b4e3];\n             _0x8458a2+=_0x29d48c[_0x2cbd43]._0xa44d84[_0x6196b5];\n\n             if(_0x8458a2>_0x805c63){\n                 return _0x6196b5;\n             }\n         }\n     }\n\n     function _0x4c6cfb(uint _0x2cbd43,uint _0xf6a674) constant returns (uint){\n         return ((_0x2cbd43+1)*_0x0b1594)+_0xf6a674;\n     }\n\n     function _0x6fa53d(uint _0x2cbd43) constant returns(uint){\n         var _0x3b6116 = _0x29d48c[_0x2cbd43]._0xa6079e/_0x74a618;\n\n         if(_0x29d48c[_0x2cbd43]._0xa6079e%_0x74a618>0)\n             _0x3b6116++;\n\n         return _0x3b6116;\n     }\n\n     function _0xdd844b(uint _0x2cbd43) constant returns(uint){\n         return _0x29d48c[_0x2cbd43]._0xa6079e/_0x6fa53d(_0x2cbd43);\n     }\n\n     function _0x889112(uint _0x2cbd43, uint _0xf6a674){\n\n         var _0x3b6116 = _0x6fa53d(_0x2cbd43);\n\n         if(_0xf6a674>=_0x3b6116)\n             return;\n\n         var _0xbbcbc7 = _0x4c6cfb(_0x2cbd43,_0xf6a674);\n\n         if(_0xbbcbc7>block.number)\n             return;\n\n         if(_0x29d48c[_0x2cbd43]._0x6db9b4[_0xf6a674])\n             return;\n         //Subpots can only be cashed once. This is to prevent double payouts\n\n         var _0x152033 = _0x2ec5b4(_0x2cbd43,_0xf6a674);\n         var _0x7edf6a = _0xdd844b(_0x2cbd43);\n\n         _0x152033.send(_0x7edf6a);\n\n         _0x29d48c[_0x2cbd43]._0x6db9b4[_0xf6a674] = true;\n         //Mark the round as cashed\n     }\n\n     function _0x101ca8(uint _0xcd8737) constant returns(uint){\n         return uint(block.blockhash(_0xcd8737));\n     }\n\n     function _0x589ea5(uint _0x2cbd43,address _0x6196b5) constant returns (address[]){\n         return _0x29d48c[_0x2cbd43]._0x21a90a;\n     }\n\n     function _0x92863e(uint _0x2cbd43,address _0x6196b5) constant returns (uint){\n         return _0x29d48c[_0x2cbd43]._0xa44d84[_0x6196b5];\n     }\n\n     function _0x03e291(uint _0x2cbd43) constant returns(uint){\n         return _0x29d48c[_0x2cbd43]._0xa6079e;\n     }\n\n     function() {\n         //this is the function that gets called when people send money to the contract.\n\n         var _0x2cbd43 = _0x3e8953();\n         var value = msg.value-(msg.value%_0xca8c5e);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n             msg.sender.send(msg.value-value);\n         }\n         //no partial tickets, send a partial refund\n\n         var _0xdb49d7 = value/_0xca8c5e;\n         _0x29d48c[_0x2cbd43]._0xdb49d7+=_0xdb49d7;\n\n         if(_0x29d48c[_0x2cbd43]._0xa44d84[msg.sender]==0){\n             var _0xf76bcc = _0x29d48c[_0x2cbd43]._0x21a90a.length++;\n             _0x29d48c[_0x2cbd43]._0x21a90a[_0xf76bcc] = msg.sender;\n         }\n\n         _0x29d48c[_0x2cbd43]._0xa44d84[msg.sender]+=_0xdb49d7;\n         _0x29d48c[_0x2cbd43]._0xdb49d7+=_0xdb49d7;\n         //keep track of the total tickets\n\n         _0x29d48c[_0x2cbd43]._0xa6079e+=value;\n         //keep track of the total pot\n\n     }\n\n }\n",
      "rename_map": {
        "getDecisionBlockNumber": "_0x4c6cfb",
        "getTicketsCountByBuyer": "_0x92863e",
        "decisionBlockNumber": "_0xbbcbc7",
        "ticketsCountByBuyer": "_0xa44d84",
        "winningTicketIndex": "_0x805c63",
        "decisionBlockHash": "_0xfb65ab",
        "getBlocksPerRound": "_0xdfe5c7",
        "getSubpotsCount": "_0x6fa53d",
        "calculateWinner": "_0x2ec5b4",
        "getTicketPrice": "_0x35f697",
        "getHashOfBlock": "_0x101ca8",
        "blocksPerRound": "_0x0b1594",
        "getRoundIndex": "_0x3e8953",
        "subpotsCount": "_0x3b6116",
        "ticketsCount": "_0xdb49d7",
        "buyersLength": "_0xf76bcc",
        "blockReward": "_0x74a618",
        "ticketIndex": "_0x8458a2",
        "subpotIndex": "_0xf6a674",
        "getIsCashed": "_0xb8f2a6",
        "ticketPrice": "_0xca8c5e",
        "blockIndex": "_0xcd8737",
        "buyerIndex": "_0x19b4e3",
        "roundIndex": "_0x2cbd43",
        "getBuyers": "_0x589ea5",
        "getSubpot": "_0xdd844b",
        "isCashed": "_0x6db9b4",
        "buyers": "_0x21a90a",
        "winner": "_0x152033",
        "rounds": "_0x29d48c",
        "subpot": "_0x7edf6a",
        "getPot": "_0x03e291",
        "buyer": "_0x6196b5",
        "cash": "_0x889112",
        "pot": "_0xa6079e"
      },
      "changes": [
        "Renamed 35 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_201",
      "transformed_id": "ss_l2_hex_sn_ds_201",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public _0x42aa29;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address _0x0fc770)\n    {\n        TransferLog = Log(_0x0fc770);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if(msg.value >= MinDeposit)\n        {\n            _0x42aa29[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x37cdbe)\n    {\n        if(_0x37cdbe<=_0x42aa29[msg.sender])\n        {\n\n            if(msg.sender.call.value(_0x37cdbe)())\n            {\n                _0x42aa29[msg.sender]-=_0x37cdbe;\n                TransferLog.AddMessage(msg.sender,_0x37cdbe,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xf39f4b,uint _0xbc1c91,string _0x3c23aa)\n    public\n    {\n        LastMsg.Sender = _0xf39f4b;\n        LastMsg.Time = _0x792ac5;\n        LastMsg.Val = _0xbc1c91;\n        LastMsg.Data = _0x3c23aa;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x42aa29",
        "_data": "_0x3c23aa",
        "_adr": "_0xf39f4b",
        "_val": "_0xbc1c91",
        "_log": "_0x0fc770",
        "_am": "_0x37cdbe",
        "now": "_0x792ac5"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_202",
      "transformed_id": "ss_l2_hex_sn_ds_202",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Multiplicator\n{\n    address public Owner = msg.sender;\n\n    function()payable{}\n\n    function _0x06d64d()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function _0xb92131(address _0x1caf9f)\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            _0x1caf9f.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "_0xb92131",
        "withdraw": "_0x06d64d",
        "adr": "_0x1caf9f"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_203",
      "transformed_id": "ss_l2_hex_sn_ds_203",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n//\n//Live TEST ---- Please Do NOT use! Thanks! ----\n//\ncontract Ownable {\n    address public _0xada5bd;\n    function Ownable() public {_0xada5bd = msg.sender;}\n    modifier _0x6a75e6() {require(msg.sender == _0xada5bd); _;\n    }\n}\n//CEO Throne .. The CEO with the highest stake gets the control over the contract\n//msg.value needs to be higher than largestStake when calling Stake()\n\ncontract CEOThrone is Ownable {\n    address public _0xada5bd;\n    uint public _0x44f582;\n// Stake() function being called with 0xde20bc92 and ETH :: recommended gas limit 35.000\n// The sent ETH is checked against largestStake\n    function Stake() public payable {\n        // if you own the largest stake in a company, you own a company\n        if (msg.value > _0x44f582) {\n            _0xada5bd = msg.sender;\n            _0x44f582 = msg.value;\n        }\n    }\n// withdraw() function being called with 0x3ccfd60b :: recommened gas limit 30.000\n    function _0xcc1cce() public _0x6a75e6 {\n        // only owner can withdraw funds\n        msg.sender.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "largestStake": "_0x44f582",
        "onlyOwner": "_0x6a75e6",
        "withdraw": "_0xcc1cce",
        "owner": "_0xada5bd"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_204",
      "transformed_id": "ss_l2_hex_sn_ds_204",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "contract OpenAddressLottery{\n    struct SeedComponents{\n        uint _0x5a7600;\n        uint _0x772e37;\n        uint _0x05b822;\n        uint _0xeceb27;\n    }\n\n    address _0x2bf9d4; //address of the owner\n    uint private _0x622332; //seed used to calculate number of an address\n    uint private _0xdac2d0; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n\n    mapping (address => bool) _0x0c2bf2; //keeping track of addresses that have already won\n\n    function OpenAddressLottery() {\n        _0x2bf9d4 = msg.sender;\n        _0xc74a49(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0x90d57e() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n\n        // make sure he hasn't won already\n        require(_0x0c2bf2[msg.sender] == false);\n\n        if(_0x026639(msg.sender) == LuckyNumber){ //check if it equals 7\n            _0x0c2bf2[msg.sender] = true; // every address can only win once\n\n            uint _0x298fc1=msg.value*7; //win = 7 times the ticket price\n\n            if(_0x298fc1>this.balance) //if the balance isnt sufficient...\n                _0x298fc1=this.balance; //...send everything we've got\n            msg.sender.transfer(_0x298fc1);\n        }\n\n        if(block.number-_0xdac2d0>1000) //reseed if needed\n            _0xc74a49(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0x026639(address _0xefd72e) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(_0x02ec80(uint(_0xefd72e), _0x622332)[0]) % 8;\n    }\n\n    function _0xc74a49(SeedComponents _0x01da52) internal {\n        _0x622332 = uint256(_0x02ec80(\n            _0x01da52._0x5a7600,\n            _0x01da52._0x772e37,\n            _0x01da52._0x05b822,\n            _0x01da52._0xeceb27\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        _0xdac2d0 = block.number;\n    }\n\n    function _0x7d1df3() {\n        require(msg.sender==_0x2bf9d4);\n\n        selfdestruct(msg.sender);\n    }\n\n    function _0xf0fb2d() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==_0x2bf9d4);\n\n        SeedComponents s;\n        s._0x5a7600 = uint(msg.sender);\n        s._0x772e37 = uint256(block.blockhash(block.number - 1));\n        s._0x05b822 = block.difficulty*(uint)(block.coinbase);\n        s._0xeceb27 = tx.gasprice * 7;\n\n        _0xc74a49(s); //reseed\n    }\n\n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=_0x2bf9d4) //owner can't participate, he can only fund the jackpot\n            _0x90d57e();\n    }\n\n}\n",
      "rename_map": {
        "luckyNumberOfAddress": "_0x026639",
        "forceReseed": "_0xf0fb2d",
        "participate": "_0x90d57e",
        "component4": "_0xeceb27",
        "component2": "_0x772e37",
        "component1": "_0x5a7600",
        "components": "_0x01da52",
        "lastReseed": "_0xdac2d0",
        "component3": "_0x05b822",
        "secretSeed": "_0x622332",
        "keccak256": "_0x02ec80",
        "winner": "_0x0c2bf2",
        "reseed": "_0xc74a49",
        "owner": "_0x2bf9d4",
        "addr": "_0xefd72e",
        "kill": "_0x7d1df3",
        "win": "_0x298fc1"
      },
      "changes": [
        "Renamed 17 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_205",
      "transformed_id": "ss_l2_hex_sn_ds_205",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract NEW_YEARS_GIFT\n{\n    string _0x29187a;\n\n    bool _0x4838f8 = false;\n\n    address sender;\n\n    bytes32 public _0x0ff7f5;\n\n    function() public payable{}\n\n    function GetHash(bytes _0x6f916b) public constant returns (bytes32) {return _0x104146(_0x6f916b);}\n\n    function SetPass(bytes32 _0x9b5291)\n    public\n    payable\n    {\n        if( (!_0x4838f8&&(msg.value > 1 ether)) || _0x0ff7f5==0x0 )\n        {\n            _0x0ff7f5 = _0x9b5291;\n            sender = msg.sender;\n        }\n    }\n\n    function SetMessage(string _0xf4be95)\n    public\n    {\n        if(msg.sender==sender)\n        {\n            _0x29187a =_0xf4be95;\n        }\n    }\n\n    function GetGift(bytes _0x6f916b)\n    external\n    payable\n    returns (string)\n    {\n        if(_0x0ff7f5 == _0x104146(_0x6f916b))\n        {\n            msg.sender.transfer(this.balance);\n            return _0x29187a;\n        }\n    }\n\n    function Revoce()\n    public\n    payable\n    {\n        if(msg.sender==sender)\n        {\n            sender.transfer(this.balance);\n            _0x29187a=\"\";\n        }\n    }\n\n    function PassHasBeenSet(bytes32 _0x9b5291)\n    public\n    {\n        if(msg.sender==sender&&_0x9b5291==_0x0ff7f5)\n        {\n           _0x4838f8=true;\n        }\n    }\n}",
      "rename_map": {
        "passHasBeenSet": "_0x4838f8",
        "hashPass": "_0x0ff7f5",
        "_message": "_0xf4be95",
        "message": "_0x29187a",
        "pass": "_0x6f916b",
        "hash": "_0x9b5291",
        "sha3": "_0x104146"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_206",
      "transformed_id": "ss_l2_hex_sn_ds_206",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Test1\n{\n    address _0x83c157 = msg.sender;\n\n    function _0xb51c63()\n    payable\n    public\n    {\n        require(msg.sender==_0x83c157);\n        _0x83c157.transfer(this.balance);\n    }\n\n    function() payable {}\n\n    function Test()\n    payable\n    public\n    {\n        if(msg.value>=1 ether)\n        {\n\n            var _0x8dab95 = 1;\n            var _0x8a1095 = 0;\n            var _0xc2d6f4 = msg.value*2;\n\n            while(true)\n            {\n                if(_0x8dab95<_0x8a1095)break;\n                if(_0x8dab95>_0xc2d6f4)break;\n\n                _0x8a1095=_0x8dab95;\n                _0x8dab95++;\n            }\n            msg.sender.transfer(_0x8a1095);\n        }\n    }\n}",
      "rename_map": {
        "withdraw": "_0xb51c63",
        "owner": "_0x83c157",
        "amX2": "_0xc2d6f4",
        "i2": "_0x8a1095",
        "i1": "_0x8dab95"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_207",
      "transformed_id": "ss_l2_hex_sn_ds_207",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\n// https://github.com/ethereum/EIPs/issues/20\ncontract ERC20 {\n    function _0xf78f51() constant returns (uint _0xf78f51);\n    function _0xc08a52(address _0x379035) constant returns (uint balance);\n    function transfer(address _0xbb456f, uint _0x78968a) returns (bool _0xf67ad6);\n    function _0x55e581(address _0x347814, address _0xbb456f, uint _0x78968a) returns (bool _0xf67ad6);\n    function _0x2f9dbb(address _0xbcc70d, uint _0x78968a) returns (bool _0xf67ad6);\n    function _0x5c368c(address _0x379035, address _0xbcc70d) constant returns (uint _0x3f69e6);\n    event Transfer(address indexed _0x347814, address indexed _0xbb456f, uint _0x78968a);\n    event Approval(address indexed _0x379035, address indexed _0xbcc70d, uint _0x78968a);\n}\n\ncontract RaceCondition{\n    address private _0x27162f;\n    uint public _0x8b0ef6;\n    ERC20 _0x63bea0;\n\n    function RaceCondition(uint _0x0c0d11, ERC20 _0x45dcb9)\n        public\n    {\n        _0x27162f = msg.sender;\n        _0x8b0ef6 = _0x0c0d11;\n        _0x63bea0 = _0x45dcb9;\n    }\n\n    // If the owner sees someone calls buy\n    // he can call changePrice to set a new price\n    // If his transaction is mined first, he can\n    // receive more tokens than excepted by the new buyer\n    function _0xeb69b2(uint _0x148b2e) payable\n        public\n    {\n        require(msg.value >= _0x8b0ef6);\n\n        // we assume that the RaceCondition contract\n        // has enough allowance\n        _0x63bea0._0x55e581(msg.sender, _0x27162f, _0x8b0ef6);\n\n        _0x8b0ef6 = _0x148b2e;\n        _0x27162f = msg.sender;\n    }\n\n    function _0xdfbd65(uint _0x148b2e){\n        require(msg.sender == _0x27162f);\n        _0x8b0ef6 = _0x148b2e;\n    }\n\n}",
      "rename_map": {
        "transferFrom": "_0x55e581",
        "totalSupply": "_0xf78f51",
        "changePrice": "_0xdfbd65",
        "balanceOf": "_0xc08a52",
        "remaining": "_0x3f69e6",
        "new_price": "_0x148b2e",
        "allowance": "_0x5c368c",
        "_spender": "_0xbcc70d",
        "success": "_0xf67ad6",
        "approve": "_0x2f9dbb",
        "_owner": "_0x379035",
        "_price": "_0x0c0d11",
        "_value": "_0x78968a",
        "_token": "_0x45dcb9",
        "owner": "_0x27162f",
        "price": "_0x8b0ef6",
        "_from": "_0x347814",
        "token": "_0x63bea0",
        "_to": "_0xbb456f",
        "buy": "_0xeb69b2"
      },
      "changes": [
        "Renamed 20 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_208",
      "transformed_id": "ss_l2_hex_sn_ds_208",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity 0.4.9; /* originally ^0.4.9, but doesn't compile with ^0.4.11 */\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address _0x5a0a09, bytes32 _0x58a123);\n  event Revoke(address _0x5a0a09, bytes32 _0x58a123);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address _0x60afcd, address _0x33acbb);\n  event OwnerAdded(address _0x33acbb);\n  event OwnerRemoved(address _0x60afcd);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint _0x39795a);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _0x769fd3, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address _0x5a0a09, uint value, address _0xc8be29, bytes data, address _0x419b55);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address _0x5a0a09, bytes32 _0x58a123, uint value, address _0xc8be29, bytes data, address _0x419b55);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 _0x58a123, address _0xb9d371, uint value, address _0xc8be29, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function _0xd5f218(bytes32 _0xa86eb3) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xa73ecd(address _0x769fd3, address _0x530af7) external;\n\n  function _0x237eae(address _0x27cb68) external;\n\n  function _0x6d3947(address _0x27cb68) external;\n\n  function _0x34915d(uint _0xa0bead) external;\n\n  function _0xe9416e(address _0x99b6df) constant returns (bool);\n\n  function _0x63ea73(bytes32 _0xa86eb3, address _0x27cb68) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x62cffa(uint _0x2f8894) external;\n\n  function _0xf0369a(address _0x530af7, uint _0x83edf0, bytes _0x95604d) external returns (bytes32 _0x986f2b);\n  function _0x9785a2(bytes32 _0x22039e) returns (bool _0x412b46);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint _0x36b8ed;\n    uint _0xcd2bef;\n    uint _0xe46796;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address _0xc8be29;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier _0x8f9d71 {\n    if (_0xe9416e(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier _0xc7a510(bytes32 _0xa86eb3) {\n    if (_0x1b6e52(_0xa86eb3))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function _0x98817b(address[] _0x92c707, uint _0xcbf674) {\n    _0x50c1e0 = _0x92c707.length + 1;\n    _0xcd5cb9[1] = uint(msg.sender);\n    _0x9f697f[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _0x92c707.length; ++i)\n    {\n      _0xcd5cb9[2 + i] = uint(_0x92c707[i]);\n      _0x9f697f[uint(_0x92c707[i])] = 2 + i;\n    }\n    _0xd4fa38 = _0xcbf674;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function _0xd5f218(bytes32 _0xa86eb3) external {\n    uint _0x1f5316 = _0x9f697f[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x1f5316 == 0) return;\n    uint _0x89d366 = 2**_0x1f5316;\n    var _0x2dba46 = _0xae83ce[_0xa86eb3];\n    if (_0x2dba46._0xcd2bef & _0x89d366 > 0) {\n      _0x2dba46._0x36b8ed++;\n      _0x2dba46._0xcd2bef -= _0x89d366;\n      Revoke(msg.sender, _0xa86eb3);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xa73ecd(address _0x769fd3, address _0x530af7) _0xc7a510(_0xac6695(msg.data)) external {\n    if (_0xe9416e(_0x530af7)) return;\n    uint _0x1f5316 = _0x9f697f[uint(_0x769fd3)];\n    if (_0x1f5316 == 0) return;\n\n    _0x5a3867();\n    _0xcd5cb9[_0x1f5316] = uint(_0x530af7);\n    _0x9f697f[uint(_0x769fd3)] = 0;\n    _0x9f697f[uint(_0x530af7)] = _0x1f5316;\n    OwnerChanged(_0x769fd3, _0x530af7);\n  }\n\n  function _0x237eae(address _0x27cb68) _0xc7a510(_0xac6695(msg.data)) external {\n    if (_0xe9416e(_0x27cb68)) return;\n\n    _0x5a3867();\n    if (_0x50c1e0 >= _0x3d093f)\n      _0xa6ca01();\n    if (_0x50c1e0 >= _0x3d093f)\n      return;\n    _0x50c1e0++;\n    _0xcd5cb9[_0x50c1e0] = uint(_0x27cb68);\n    _0x9f697f[uint(_0x27cb68)] = _0x50c1e0;\n    OwnerAdded(_0x27cb68);\n  }\n\n  function _0x6d3947(address _0x27cb68) _0xc7a510(_0xac6695(msg.data)) external {\n    uint _0x1f5316 = _0x9f697f[uint(_0x27cb68)];\n    if (_0x1f5316 == 0) return;\n    if (_0xd4fa38 > _0x50c1e0 - 1) return;\n\n    _0xcd5cb9[_0x1f5316] = 0;\n    _0x9f697f[uint(_0x27cb68)] = 0;\n    _0x5a3867();\n    _0xa6ca01(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_0x27cb68);\n  }\n\n  function _0x34915d(uint _0xa0bead) _0xc7a510(_0xac6695(msg.data)) external {\n    if (_0xa0bead > _0x50c1e0) return;\n    _0xd4fa38 = _0xa0bead;\n    _0x5a3867();\n    RequirementChanged(_0xa0bead);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x19a199(uint _0x1f5316) external constant returns (address) {\n    return address(_0xcd5cb9[_0x1f5316 + 1]);\n  }\n\n  function _0xe9416e(address _0x99b6df) constant returns (bool) {\n    return _0x9f697f[uint(_0x99b6df)] > 0;\n  }\n\n  function _0x63ea73(bytes32 _0xa86eb3, address _0x27cb68) external constant returns (bool) {\n    var _0x2dba46 = _0xae83ce[_0xa86eb3];\n    uint _0x1f5316 = _0x9f697f[uint(_0x27cb68)];\n\n    // make sure they're an owner\n    if (_0x1f5316 == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint _0x89d366 = 2**_0x1f5316;\n    return !(_0x2dba46._0xcd2bef & _0x89d366 == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function _0xc46cc7(uint _0x4d6d06) {\n    _0xcd2280 = _0x4d6d06;\n    _0x1fa60d = _0xc13f4f();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x62cffa(uint _0x2f8894) _0xc7a510(_0xac6695(msg.data)) external {\n    _0xcd2280 = _0x2f8894;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function _0x7977f2() _0xc7a510(_0xac6695(msg.data)) external {\n    _0x4bc5ec = 0;\n  }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function _0xc3b56f(address[] _0x92c707, uint _0xcbf674, uint _0xa18741) {\n    _0xc46cc7(_0xa18741);\n    _0x98817b(_0x92c707, _0xcbf674);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function _0x035784(address _0x530af7) _0xc7a510(_0xac6695(msg.data)) external {\n    suicide(_0x530af7);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function _0xf0369a(address _0x530af7, uint _0x83edf0, bytes _0x95604d) external _0x8f9d71 returns (bytes32 _0x986f2b) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_0x95604d.length == 0 && _0x36ed29(_0x83edf0)) || _0xd4fa38 == 1) {\n      // yes - just execute the call.\n      address _0x419b55;\n      if (_0x530af7 == 0) {\n        _0x419b55 = _0x510a77(_0x83edf0, _0x95604d);\n      } else {\n        if (!_0x530af7.call.value(_0x83edf0)(_0x95604d))\n          throw;\n      }\n      SingleTransact(msg.sender, _0x83edf0, _0x530af7, _0x95604d, _0x419b55);\n    } else {\n      // determine our operation hash.\n      _0x986f2b = _0xac6695(msg.data, block.number);\n      // store if it's new\n      if (_0x2c009e[_0x986f2b]._0xc8be29 == 0 && _0x2c009e[_0x986f2b].value == 0 && _0x2c009e[_0x986f2b].data.length == 0) {\n        _0x2c009e[_0x986f2b]._0xc8be29 = _0x530af7;\n        _0x2c009e[_0x986f2b].value = _0x83edf0;\n        _0x2c009e[_0x986f2b].data = _0x95604d;\n      }\n      if (!_0x9785a2(_0x986f2b)) {\n        ConfirmationNeeded(_0x986f2b, msg.sender, _0x83edf0, _0x530af7, _0x95604d);\n      }\n    }\n  }\n\n  function _0x510a77(uint _0x83edf0, bytes _0x632f17) internal returns (address _0xae12b1) {\n    assembly {\n      _0xae12b1 := _0x510a77(_0x83edf0, add(_0x632f17, 0x20), mload(_0x632f17))\n      _0xa2c091(_0xe322d5, iszero(extcodesize(_0xae12b1)))\n    }\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function _0x9785a2(bytes32 _0x22039e) _0xc7a510(_0x22039e) returns (bool _0x412b46) {\n    if (_0x2c009e[_0x22039e]._0xc8be29 != 0 || _0x2c009e[_0x22039e].value != 0 || _0x2c009e[_0x22039e].data.length != 0) {\n      address _0x419b55;\n      if (_0x2c009e[_0x22039e]._0xc8be29 == 0) {\n        _0x419b55 = _0x510a77(_0x2c009e[_0x22039e].value, _0x2c009e[_0x22039e].data);\n      } else {\n        if (!_0x2c009e[_0x22039e]._0xc8be29.call.value(_0x2c009e[_0x22039e].value)(_0x2c009e[_0x22039e].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _0x22039e, _0x2c009e[_0x22039e].value, _0x2c009e[_0x22039e]._0xc8be29, _0x2c009e[_0x22039e].data, _0x419b55);\n      delete _0x2c009e[_0x22039e];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function _0x1b6e52(bytes32 _0xa86eb3) internal returns (bool) {\n    // determine what index the present sender is:\n    uint _0x1f5316 = _0x9f697f[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x1f5316 == 0) return;\n\n    var _0x2dba46 = _0xae83ce[_0xa86eb3];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (_0x2dba46._0x36b8ed == 0) {\n      // reset count of confirmations needed.\n      _0x2dba46._0x36b8ed = _0xd4fa38;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      _0x2dba46._0xcd2bef = 0;\n      _0x2dba46._0xe46796 = _0x894458.length++;\n      _0x894458[_0x2dba46._0xe46796] = _0xa86eb3;\n    }\n    // determine the bit to set for this owner.\n    uint _0x89d366 = 2**_0x1f5316;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (_0x2dba46._0xcd2bef & _0x89d366 == 0) {\n      Confirmation(msg.sender, _0xa86eb3);\n      // ok - check if count is enough to go ahead.\n      if (_0x2dba46._0x36b8ed <= 1) {\n        // enough confirmations: reset and run interior.\n        delete _0x894458[_0xae83ce[_0xa86eb3]._0xe46796];\n        delete _0xae83ce[_0xa86eb3];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        _0x2dba46._0x36b8ed--;\n        _0x2dba46._0xcd2bef |= _0x89d366;\n      }\n    }\n  }\n\n  function _0xa6ca01() private {\n    uint _0x4f8ba2 = 1;\n    while (_0x4f8ba2 < _0x50c1e0)\n    {\n      while (_0x4f8ba2 < _0x50c1e0 && _0xcd5cb9[_0x4f8ba2] != 0) _0x4f8ba2++;\n      while (_0x50c1e0 > 1 && _0xcd5cb9[_0x50c1e0] == 0) _0x50c1e0--;\n      if (_0x4f8ba2 < _0x50c1e0 && _0xcd5cb9[_0x50c1e0] != 0 && _0xcd5cb9[_0x4f8ba2] == 0)\n      {\n        _0xcd5cb9[_0x4f8ba2] = _0xcd5cb9[_0x50c1e0];\n        _0x9f697f[_0xcd5cb9[_0x4f8ba2]] = _0x4f8ba2;\n        _0xcd5cb9[_0x50c1e0] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function _0x36ed29(uint _0x83edf0) internal _0x8f9d71 returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (_0xc13f4f() > _0x1fa60d) {\n      _0x4bc5ec = 0;\n      _0x1fa60d = _0xc13f4f();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n\n    if (_0x4bc5ec + _0x83edf0 >= _0x4bc5ec && _0x4bc5ec + _0x83edf0 <= _0xcd2280) {\n      _0x4bc5ec += _0x83edf0;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function _0xc13f4f() private constant returns (uint) { return _0xc36a32 / 1 days; }\n\n  function _0x5a3867() internal {\n    uint length = _0x894458.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete _0x2c009e[_0x894458[i]];\n\n      if (_0x894458[i] != 0)\n        delete _0xae83ce[_0x894458[i]];\n    }\n\n    delete _0x894458;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0xd4fa38;\n  // pointer used to find a free slot in m_owners\n  uint public _0x50c1e0;\n\n  uint public _0xcd2280;\n  uint public _0x4bc5ec;\n  uint public _0x1fa60d;\n\n  // list of owners\n  uint[256] _0xcd5cb9;\n\n  uint constant _0x3d093f = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) _0x9f697f;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) _0xae83ce;\n  bytes32[] _0x894458;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) _0x2c009e;\n}\n\ncontract Wallet is WalletEvents {\n\n  // WALLET CONSTRUCTOR\n  //   calls the `initWallet` method of the Library in this context\n  function Wallet(address[] _0x92c707, uint _0xcbf674, uint _0xa18741) {\n    // Signature of the Wallet Library's init function\n    bytes4 sig = bytes4(_0xac6695(\"initWallet(address[],uint256,uint256)\"));\n    address _0xaddd12 = _walletLibrary;\n\n    // Compute the size of the call data : arrays has 2\n    // 32bytes for offset and length, plus 32bytes per element ;\n    // plus 2 32bytes for each uint\n    uint _0x2dbdd0 = (2 + _0x92c707.length);\n    uint _0xce76e2 = (2 + _0x2dbdd0) * 32;\n\n    assembly {\n      // Add the signature first to memory\n      mstore(0x0, sig)\n      // Add the call data, which is at the end of the\n      // code\n      _0x092bc9(0x4,  sub(_0xe1cb03, _0xce76e2), _0xce76e2)\n      // Delegate call to the library\n      delegatecall(sub(gas, 10000), _0xaddd12, 0x0, add(_0xce76e2, 0x4), 0x0, 0x0)\n    }\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data); //it should have whitelisted specific methods that the user is allowed to call\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x19a199(uint _0x1f5316) constant returns (address) {\n    return address(_0xcd5cb9[_0x1f5316 + 1]);\n  }\n\n  // As return statement unavailable in fallback, explicit the method here\n\n  function _0x63ea73(bytes32 _0xa86eb3, address _0x27cb68) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function _0xe9416e(address _0x99b6df) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0xd4fa38;\n  // pointer used to find a free slot in m_owners\n  uint public _0x50c1e0;\n\n  uint public _0xcd2280;\n  uint public _0x4bc5ec;\n  uint public _0x1fa60d;\n\n  // list of owners\n  uint[256] _0xcd5cb9;\n}\n",
      "rename_map": {
        "changeRequirement": "_0x34915d",
        "reorganizeOwners": "_0xa6ca01",
        "invalidJumpLabel": "_0xe322d5",
        "confirmAndCheck": "_0x1b6e52",
        "resetSpentToday": "_0x7977f2",
        "m_pendingIndex": "_0x894458",
        "initMultiowned": "_0x98817b",
        "onlymanyowners": "_0xc7a510",
        "newRequirement": "_0x39795a",
        "setDailyLimit": "_0x62cffa",
        "ownerIndexBit": "_0x89d366",
        "m_dailyLimit": "_0xcd2280",
        "argarraysize": "_0x2dbdd0",
        "m_ownerIndex": "_0x9f697f",
        "hasConfirmed": "_0x63ea73",
        "initDaylimit": "_0xc46cc7",
        "clearPending": "_0x5a3867",
        "_newRequired": "_0xa0bead",
        "m_spentToday": "_0x4bc5ec",
        "removeOwner": "_0x6d3947",
        "m_numOwners": "_0x50c1e0",
        "c_maxOwners": "_0x3d093f",
        "changeOwner": "_0xa73ecd",
        "m_required": "_0xd4fa38",
        "_operation": "_0xa86eb3",
        "ownersDone": "_0xcd2bef",
        "underLimit": "_0x36ed29",
        "ownerIndex": "_0x1f5316",
        "initWallet": "_0xc3b56f",
        "initiator": "_0xb9d371",
        "o_success": "_0x412b46",
        "onlyowner": "_0x8f9d71",
        "yetNeeded": "_0x36b8ed",
        "operation": "_0x58a123",
        "m_pending": "_0xae83ce",
        "_daylimit": "_0xa18741",
        "_required": "_0xcbf674",
        "_newLimit": "_0x2f8894",
        "m_lastDay": "_0x1fa60d",
        "codecopy": "_0x092bc9",
        "codesize": "_0xe1cb03",
        "getOwner": "_0x19a199",
        "oldOwner": "_0x60afcd",
        "newOwner": "_0x33acbb",
        "addOwner": "_0x237eae",
        "m_owners": "_0xcd5cb9",
        "_owners": "_0x92c707",
        "confirm": "_0x9785a2",
        "created": "_0x419b55",
        "argsize": "_0xce76e2",
        "isOwner": "_0xe9416e",
        "execute": "_0xf0369a",
        "pending": "_0x2dba46",
        "_limit": "_0x4d6d06",
        "o_hash": "_0x986f2b",
        "o_addr": "_0xae12b1",
        "_value": "_0x83edf0",
        "_owner": "_0x27cb68",
        "target": "_0xaddd12",
        "create": "_0x510a77",
        "revoke": "_0xd5f218",
        "_from": "_0x769fd3",
        "jumpi": "_0xa2c091",
        "_addr": "_0x99b6df",
        "today": "_0xc13f4f",
        "_code": "_0x632f17",
        "owner": "_0x5a0a09",
        "_data": "_0x95604d",
        "m_txs": "_0x2c009e",
        "index": "_0xe46796",
        "sha3": "_0xac6695",
        "kill": "_0x035784",
        "free": "_0x4f8ba2",
        "_to": "_0x530af7",
        "now": "_0xc36a32",
        "to": "_0xc8be29",
        "_h": "_0x22039e"
      },
      "changes": [
        "Renamed 77 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_209",
      "transformed_id": "ss_l2_hex_sn_ds_209",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address _0x7894e2, bytes32 _0x95ffe7);\n  event Revoke(address _0x7894e2, bytes32 _0x95ffe7);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address _0x5a7e3b, address _0x7d3a4c);\n  event OwnerAdded(address _0x7d3a4c);\n  event OwnerRemoved(address _0x5a7e3b);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint _0xec7967);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _0xe22f35, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address _0x7894e2, uint value, address _0x0aa9da, bytes data, address _0x9d7432);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address _0x7894e2, bytes32 _0x95ffe7, uint value, address _0x0aa9da, bytes data, address _0x9d7432);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 _0x95ffe7, address _0xa1dc80, uint value, address _0x0aa9da, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function _0x959824(bytes32 _0x3caa2e) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xba7cd3(address _0xe22f35, address _0x5ce1ae) external;\n\n  function _0xc77c19(address _0xd34872) external;\n\n  function _0xd00c45(address _0xd34872) external;\n\n  function _0x1a7377(uint _0xd545ba) external;\n\n  function _0x676f36(address _0x5e79b0) constant returns (bool);\n\n  function _0x58a6bc(bytes32 _0x3caa2e, address _0xd34872) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x51323d(uint _0xf369b3) external;\n\n  function _0x65e8c9(address _0x5ce1ae, uint _0xd3182e, bytes _0x59ab38) external returns (bytes32 _0x77aa1a);\n  function _0xa48465(bytes32 _0xe28a15) returns (bool _0xc0088e);\n}\n\ncontract WalletLibrary is WalletEvents {\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint _0x697e9e;\n    uint _0x3d2cc6;\n    uint _0x5accab;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address _0x0aa9da;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier _0xd2fbf8 {\n    if (_0x676f36(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier _0x70b42d(bytes32 _0x3caa2e) {\n    if (_0xc4203f(_0x3caa2e))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function _0x1d8e9d(address[] _0xbbee45, uint _0x09989e) _0x0c4066 {\n    _0x879787 = _0xbbee45.length + 1;\n    _0x1a4567[1] = uint(msg.sender);\n    _0xf34a92[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _0xbbee45.length; ++i)\n    {\n      _0x1a4567[2 + i] = uint(_0xbbee45[i]);\n      _0xf34a92[uint(_0xbbee45[i])] = 2 + i;\n    }\n    _0x90d42a = _0x09989e;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function _0x959824(bytes32 _0x3caa2e) external {\n    uint _0x23cb7c = _0xf34a92[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x23cb7c == 0) return;\n    uint _0x5bb877 = 2**_0x23cb7c;\n    var _0xeb1f37 = _0xdf56f4[_0x3caa2e];\n    if (_0xeb1f37._0x3d2cc6 & _0x5bb877 > 0) {\n      _0xeb1f37._0x697e9e++;\n      _0xeb1f37._0x3d2cc6 -= _0x5bb877;\n      Revoke(msg.sender, _0x3caa2e);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xba7cd3(address _0xe22f35, address _0x5ce1ae) _0x70b42d(_0xd2161e(msg.data)) external {\n    if (_0x676f36(_0x5ce1ae)) return;\n    uint _0x23cb7c = _0xf34a92[uint(_0xe22f35)];\n    if (_0x23cb7c == 0) return;\n\n    _0x5241a7();\n    _0x1a4567[_0x23cb7c] = uint(_0x5ce1ae);\n    _0xf34a92[uint(_0xe22f35)] = 0;\n    _0xf34a92[uint(_0x5ce1ae)] = _0x23cb7c;\n    OwnerChanged(_0xe22f35, _0x5ce1ae);\n  }\n\n  function _0xc77c19(address _0xd34872) _0x70b42d(_0xd2161e(msg.data)) external {\n    if (_0x676f36(_0xd34872)) return;\n\n    _0x5241a7();\n    if (_0x879787 >= _0x282ac5)\n      _0x4064c9();\n    if (_0x879787 >= _0x282ac5)\n      return;\n    _0x879787++;\n    _0x1a4567[_0x879787] = uint(_0xd34872);\n    _0xf34a92[uint(_0xd34872)] = _0x879787;\n    OwnerAdded(_0xd34872);\n  }\n\n  function _0xd00c45(address _0xd34872) _0x70b42d(_0xd2161e(msg.data)) external {\n    uint _0x23cb7c = _0xf34a92[uint(_0xd34872)];\n    if (_0x23cb7c == 0) return;\n    if (_0x90d42a > _0x879787 - 1) return;\n\n    _0x1a4567[_0x23cb7c] = 0;\n    _0xf34a92[uint(_0xd34872)] = 0;\n    _0x5241a7();\n    _0x4064c9(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_0xd34872);\n  }\n\n  function _0x1a7377(uint _0xd545ba) _0x70b42d(_0xd2161e(msg.data)) external {\n    if (_0xd545ba > _0x879787) return;\n    _0x90d42a = _0xd545ba;\n    _0x5241a7();\n    RequirementChanged(_0xd545ba);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x5d9f78(uint _0x23cb7c) external constant returns (address) {\n    return address(_0x1a4567[_0x23cb7c + 1]);\n  }\n\n  function _0x676f36(address _0x5e79b0) constant returns (bool) {\n    return _0xf34a92[uint(_0x5e79b0)] > 0;\n  }\n\n  function _0x58a6bc(bytes32 _0x3caa2e, address _0xd34872) external constant returns (bool) {\n    var _0xeb1f37 = _0xdf56f4[_0x3caa2e];\n    uint _0x23cb7c = _0xf34a92[uint(_0xd34872)];\n\n    // make sure they're an owner\n    if (_0x23cb7c == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint _0x5bb877 = 2**_0x23cb7c;\n    return !(_0xeb1f37._0x3d2cc6 & _0x5bb877 == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function _0x71cd34(uint _0x187e8d) _0x0c4066 {\n    _0x2bec24 = _0x187e8d;\n    _0x58f01d = _0x17615c();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x51323d(uint _0xf369b3) _0x70b42d(_0xd2161e(msg.data)) external {\n    _0x2bec24 = _0xf369b3;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function _0x85f625() _0x70b42d(_0xd2161e(msg.data)) external {\n    _0x3a89fe = 0;\n  }\n\n  // throw unless the contract is not yet initialized.\n  modifier _0x0c4066 { if (_0x879787 > 0) throw; _; }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function _0x11a54e(address[] _0xbbee45, uint _0x09989e, uint _0x6d53bc) _0x0c4066 {\n    _0x71cd34(_0x6d53bc);\n    _0x1d8e9d(_0xbbee45, _0x09989e);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function _0xc62155(address _0x5ce1ae) _0x70b42d(_0xd2161e(msg.data)) external {\n    suicide(_0x5ce1ae);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function _0x65e8c9(address _0x5ce1ae, uint _0xd3182e, bytes _0x59ab38) external _0xd2fbf8 returns (bytes32 _0x77aa1a) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_0x59ab38.length == 0 && _0x754ea7(_0xd3182e)) || _0x90d42a == 1) {\n      // yes - just execute the call.\n      address _0x9d7432;\n      if (_0x5ce1ae == 0) {\n        _0x9d7432 = _0x53c288(_0xd3182e, _0x59ab38);\n      } else {\n        if (!_0x5ce1ae.call.value(_0xd3182e)(_0x59ab38))\n          throw;\n      }\n      SingleTransact(msg.sender, _0xd3182e, _0x5ce1ae, _0x59ab38, _0x9d7432);\n    } else {\n      // determine our operation hash.\n      _0x77aa1a = _0xd2161e(msg.data, block.number);\n      // store if it's new\n      if (_0x14d58b[_0x77aa1a]._0x0aa9da == 0 && _0x14d58b[_0x77aa1a].value == 0 && _0x14d58b[_0x77aa1a].data.length == 0) {\n        _0x14d58b[_0x77aa1a]._0x0aa9da = _0x5ce1ae;\n        _0x14d58b[_0x77aa1a].value = _0xd3182e;\n        _0x14d58b[_0x77aa1a].data = _0x59ab38;\n      }\n      if (!_0xa48465(_0x77aa1a)) {\n        ConfirmationNeeded(_0x77aa1a, msg.sender, _0xd3182e, _0x5ce1ae, _0x59ab38);\n      }\n    }\n  }\n\n  function _0x53c288(uint _0xd3182e, bytes _0x64d710) internal returns (address _0xf007db) {\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function _0xa48465(bytes32 _0xe28a15) _0x70b42d(_0xe28a15) returns (bool _0xc0088e) {\n    if (_0x14d58b[_0xe28a15]._0x0aa9da != 0 || _0x14d58b[_0xe28a15].value != 0 || _0x14d58b[_0xe28a15].data.length != 0) {\n      address _0x9d7432;\n      if (_0x14d58b[_0xe28a15]._0x0aa9da == 0) {\n        _0x9d7432 = _0x53c288(_0x14d58b[_0xe28a15].value, _0x14d58b[_0xe28a15].data);\n      } else {\n        if (!_0x14d58b[_0xe28a15]._0x0aa9da.call.value(_0x14d58b[_0xe28a15].value)(_0x14d58b[_0xe28a15].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _0xe28a15, _0x14d58b[_0xe28a15].value, _0x14d58b[_0xe28a15]._0x0aa9da, _0x14d58b[_0xe28a15].data, _0x9d7432);\n      delete _0x14d58b[_0xe28a15];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function _0xc4203f(bytes32 _0x3caa2e) internal returns (bool) {\n    // determine what index the present sender is:\n    uint _0x23cb7c = _0xf34a92[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x23cb7c == 0) return;\n\n    var _0xeb1f37 = _0xdf56f4[_0x3caa2e];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (_0xeb1f37._0x697e9e == 0) {\n      // reset count of confirmations needed.\n      _0xeb1f37._0x697e9e = _0x90d42a;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      _0xeb1f37._0x3d2cc6 = 0;\n      _0xeb1f37._0x5accab = _0xb8485d.length++;\n      _0xb8485d[_0xeb1f37._0x5accab] = _0x3caa2e;\n    }\n    // determine the bit to set for this owner.\n    uint _0x5bb877 = 2**_0x23cb7c;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (_0xeb1f37._0x3d2cc6 & _0x5bb877 == 0) {\n      Confirmation(msg.sender, _0x3caa2e);\n      // ok - check if count is enough to go ahead.\n      if (_0xeb1f37._0x697e9e <= 1) {\n        // enough confirmations: reset and run interior.\n        delete _0xb8485d[_0xdf56f4[_0x3caa2e]._0x5accab];\n        delete _0xdf56f4[_0x3caa2e];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        _0xeb1f37._0x697e9e--;\n        _0xeb1f37._0x3d2cc6 |= _0x5bb877;\n      }\n    }\n  }\n\n  function _0x4064c9() private {\n    uint _0x57fc37 = 1;\n    while (_0x57fc37 < _0x879787)\n    {\n      while (_0x57fc37 < _0x879787 && _0x1a4567[_0x57fc37] != 0) _0x57fc37++;\n      while (_0x879787 > 1 && _0x1a4567[_0x879787] == 0) _0x879787--;\n      if (_0x57fc37 < _0x879787 && _0x1a4567[_0x879787] != 0 && _0x1a4567[_0x57fc37] == 0)\n      {\n        _0x1a4567[_0x57fc37] = _0x1a4567[_0x879787];\n        _0xf34a92[_0x1a4567[_0x57fc37]] = _0x57fc37;\n        _0x1a4567[_0x879787] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function _0x754ea7(uint _0xd3182e) internal _0xd2fbf8 returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (_0x17615c() > _0x58f01d) {\n      _0x3a89fe = 0;\n      _0x58f01d = _0x17615c();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n\n    if (_0x3a89fe + _0xd3182e >= _0x3a89fe && _0x3a89fe + _0xd3182e <= _0x2bec24) {\n      _0x3a89fe += _0xd3182e;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function _0x17615c() private constant returns (uint) { return _0xc44f6c / 1 days; }\n\n  function _0x5241a7() internal {\n    uint length = _0xb8485d.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete _0x14d58b[_0xb8485d[i]];\n\n      if (_0xb8485d[i] != 0)\n        delete _0xdf56f4[_0xb8485d[i]];\n    }\n\n    delete _0xb8485d;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0x90d42a;\n  // pointer used to find a free slot in m_owners\n  uint public _0x879787;\n\n  uint public _0x2bec24;\n  uint public _0x3a89fe;\n  uint public _0x58f01d;\n\n  // list of owners\n  uint[256] _0x1a4567;\n\n  uint constant _0x282ac5 = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) _0xf34a92;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) _0xdf56f4;\n  bytes32[] _0xb8485d;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) _0x14d58b;\n}\n",
      "rename_map": {
        "only_uninitialized": "_0x0c4066",
        "changeRequirement": "_0x1a7377",
        "reorganizeOwners": "_0x4064c9",
        "confirmAndCheck": "_0xc4203f",
        "resetSpentToday": "_0x85f625",
        "newRequirement": "_0xec7967",
        "m_pendingIndex": "_0xb8485d",
        "onlymanyowners": "_0x70b42d",
        "initMultiowned": "_0x1d8e9d",
        "setDailyLimit": "_0x51323d",
        "ownerIndexBit": "_0x5bb877",
        "initDaylimit": "_0x71cd34",
        "m_dailyLimit": "_0x2bec24",
        "hasConfirmed": "_0x58a6bc",
        "clearPending": "_0x5241a7",
        "_newRequired": "_0xd545ba",
        "m_spentToday": "_0x3a89fe",
        "m_ownerIndex": "_0xf34a92",
        "c_maxOwners": "_0x282ac5",
        "m_numOwners": "_0x879787",
        "changeOwner": "_0xba7cd3",
        "removeOwner": "_0xd00c45",
        "underLimit": "_0x754ea7",
        "ownerIndex": "_0x23cb7c",
        "initWallet": "_0x11a54e",
        "m_required": "_0x90d42a",
        "_operation": "_0x3caa2e",
        "ownersDone": "_0x3d2cc6",
        "operation": "_0x95ffe7",
        "_required": "_0x09989e",
        "initiator": "_0xa1dc80",
        "o_success": "_0xc0088e",
        "_newLimit": "_0xf369b3",
        "m_pending": "_0xdf56f4",
        "_daylimit": "_0x6d53bc",
        "onlyowner": "_0xd2fbf8",
        "yetNeeded": "_0x697e9e",
        "m_lastDay": "_0x58f01d",
        "addOwner": "_0xc77c19",
        "oldOwner": "_0x5a7e3b",
        "m_owners": "_0x1a4567",
        "newOwner": "_0x7d3a4c",
        "getOwner": "_0x5d9f78",
        "_owners": "_0xbbee45",
        "created": "_0x9d7432",
        "confirm": "_0xa48465",
        "isOwner": "_0x676f36",
        "pending": "_0xeb1f37",
        "execute": "_0x65e8c9",
        "_owner": "_0xd34872",
        "revoke": "_0x959824",
        "_limit": "_0x187e8d",
        "_value": "_0xd3182e",
        "create": "_0x53c288",
        "o_hash": "_0x77aa1a",
        "o_addr": "_0xf007db",
        "owner": "_0x7894e2",
        "_data": "_0x59ab38",
        "_from": "_0xe22f35",
        "m_txs": "_0x14d58b",
        "today": "_0x17615c",
        "_code": "_0x64d710",
        "_addr": "_0x5e79b0",
        "index": "_0x5accab",
        "kill": "_0xc62155",
        "free": "_0x57fc37",
        "sha3": "_0xd2161e",
        "_to": "_0x5ce1ae",
        "now": "_0xc44f6c",
        "_h": "_0xe28a15",
        "to": "_0x0aa9da"
      },
      "changes": [
        "Renamed 71 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_210",
      "transformed_id": "ss_l2_hex_sn_ds_210",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract LuckyDoubler {\n//##########################################################\n//#### LuckyDoubler: A doubler with random payout order ####\n//#### Deposit 1 ETHER to participate                   ####\n//##########################################################\n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\n//No part of this source code may be reproduced, distributed,\n//modified or transmitted in any form or by any means without\n//the prior written permission of the creator.\n\n    address private _0x6849ec;\n\n    //Stored variables\n    uint private balance = 0;\n    uint private _0xae8ea2 = 5;\n    uint private _0xa6c2dc = 125;\n\n    mapping (address => User) private _0x38a0ea;\n    Entry[] private _0x694237;\n    uint[] private _0xf36470;\n\n    //Set owner on contract creation\n    function LuckyDoubler() {\n        _0x6849ec = msg.sender;\n    }\n\n    modifier _0xf81b08 { if (msg.sender == _0x6849ec) _; }\n\n    struct User {\n        address _0xb3cc83;\n        uint _0x96fd44;\n        uint _0x9ad012;\n    }\n\n    struct Entry {\n        address _0xc85473;\n        uint _0x24a74e;\n        uint _0xd354f9;\n        bool _0x4d274d;\n    }\n\n    //Fallback function\n    function() {\n        _0xdfee3d();\n    }\n\n    function _0xdfee3d() private{\n\n        if (msg.value < 1 ether) {\n             msg.sender.send(msg.value);\n            return;\n        }\n\n        _0xa4cabb();\n    }\n\n    function _0xa4cabb() private {\n\n        //Limit deposits to 1ETH\n        uint _0xa2b159 = 1 ether;\n\n        if (msg.value > 1 ether) {\n\n        \tmsg.sender.send(msg.value - 1 ether);\n        \t_0xa2b159 = 1 ether;\n        }\n\n        //Add new users to the users array\n        if (_0x38a0ea[msg.sender]._0xb3cc83 == address(0))\n        {\n            _0x38a0ea[msg.sender]._0xb3cc83 = msg.sender;\n            _0x38a0ea[msg.sender]._0x96fd44 = 0;\n            _0x38a0ea[msg.sender]._0x9ad012 = 0;\n        }\n\n        //Add new entry to the entries array\n        _0x694237.push(Entry(msg.sender, _0xa2b159, (_0xa2b159 * (_0xa6c2dc) / 100), false));\n        _0x38a0ea[msg.sender]._0x96fd44++;\n        _0xf36470.push(_0x694237.length -1);\n\n        //Collect fees and update contract balance\n        balance += (_0xa2b159 * (100 - _0xae8ea2)) / 100;\n\n        uint _0x8627b8 = _0xf36470.length > 1 ? _0xddb195(_0xf36470.length) : 0;\n        Entry _0xb207b0 = _0x694237[_0xf36470[_0x8627b8]];\n\n        //Pay pending entries if the new balance allows for it\n        if (balance > _0xb207b0._0xd354f9) {\n\n            uint _0xd354f9 = _0xb207b0._0xd354f9;\n\n            _0xb207b0._0xc85473.send(_0xd354f9);\n            _0xb207b0._0x4d274d = true;\n            _0x38a0ea[_0xb207b0._0xc85473]._0x9ad012++;\n\n            balance -= _0xd354f9;\n\n            if (_0x8627b8 < _0xf36470.length - 1)\n                _0xf36470[_0x8627b8] = _0xf36470[_0xf36470.length - 1];\n\n            _0xf36470.length--;\n\n        }\n\n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\n        uint _0xb0239e = this.balance - balance;\n        if (_0xb0239e > 0)\n        {\n                _0x6849ec.send(_0xb0239e);\n        }\n\n    }\n\n    //Generate random number between 0 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function _0xddb195(uint _0xf60873) constant private returns (uint256 _0xb65cdb){\n        uint256 _0x1d5dbd = FACTOR * 100 / _0xf60873;\n        uint256 _0x0e462b = block.number - 1;\n        uint256 _0x4b2fe0 = uint256(block.blockhash(_0x0e462b));\n\n        return uint256((uint256(_0x4b2fe0) / _0x1d5dbd)) % _0xf60873;\n    }\n\n    //Contract management\n    function _0xf81046(address _0xf45328) _0xf81b08 {\n        _0x6849ec = _0xf45328;\n    }\n\n    function _0x05af08(uint _0x00d8a4) _0xf81b08 {\n        if (_0x00d8a4 < 110 || _0x00d8a4 > 150) throw;\n\n        _0xa6c2dc = _0x00d8a4;\n    }\n\n    function _0x37143b(uint _0x7667a6) _0xf81b08 {\n        if (_0xae8ea2 > 5)\n            throw;\n        _0xae8ea2 = _0x7667a6;\n    }\n\n    //JSON functions\n    function _0xcaa815() constant returns (uint _0x1d5dbd, string _0x0fca48) {\n        _0x1d5dbd = _0xa6c2dc;\n        _0x0fca48 = 'The current _0xa6c2dc applied to all _0x96fd44. Min 110%, _0xf60873 150%.';\n    }\n\n    function _0x5d2733() constant returns (uint _0x545e68, string _0x0fca48) {\n        _0x545e68 = _0xae8ea2;\n        _0x0fca48 = 'The _0xae8ea2 percentage applied to all _0x96fd44. It can change to speed _0x1ddba0 (_0xf60873 5%).';\n    }\n\n    function _0xe10eb3() constant returns (uint _0xc3ba55, string _0x0fca48) {\n        _0xc3ba55 = _0x694237.length;\n        _0x0fca48 = 'The number of _0x96fd44.';\n    }\n\n    function _0xe0caba(address _0xcb520d) constant returns (uint _0x96fd44, uint _0x1ddba0, string _0x0fca48)\n    {\n        if (_0x38a0ea[_0xcb520d]._0xb3cc83 != address(0x0))\n        {\n            _0x96fd44 = _0x38a0ea[_0xcb520d]._0x96fd44;\n            _0x1ddba0 = _0x38a0ea[_0xcb520d]._0x9ad012;\n            _0x0fca48 = 'Users stats: total _0x96fd44, _0x1ddba0 received.';\n        }\n    }\n\n    function _0xa1a4ba(uint _0x8627b8) constant returns (address _0xcb520d, uint _0xd354f9, bool _0x4d274d, string _0x0fca48)\n    {\n        if (_0x8627b8 < _0x694237.length) {\n            _0xcb520d = _0x694237[_0x8627b8]._0xc85473;\n            _0xd354f9 = _0x694237[_0x8627b8]._0xd354f9 / 1 finney;\n            _0x4d274d = _0x694237[_0x8627b8]._0x4d274d;\n            _0x0fca48 = 'Entry _0x0fca48: _0xcb520d address, expected _0xd354f9 in Finneys, _0xd354f9 status.';\n        }\n    }\n\n}\n",
      "rename_map": {
        "changeMultiplier": "_0x05af08",
        "multiplierFactor": "_0xcaa815",
        "payoutsReceived": "_0x9ad012",
        "lastBlockNumber": "_0x0e462b",
        "unpaidEntries": "_0xf36470",
        "feePercentage": "_0x545e68",
        "entryAddress": "_0xc85473",
        "entryDetails": "_0xa1a4ba",
        "totalEntries": "_0xe10eb3",
        "changeOwner": "_0xf81046",
        "currentFee": "_0x5d2733",
        "multiplier": "_0xa6c2dc",
        "changeFee": "_0x37143b",
        "userStats": "_0xe0caba",
        "onlyowner": "_0xf81b08",
        "theEntry": "_0xb207b0",
        "deposits": "_0x96fd44",
        "newOwner": "_0xf45328",
        "entries": "_0x694237",
        "hashVal": "_0x4b2fe0",
        "payouts": "_0x1ddba0",
        "deposit": "_0x24a74e",
        "factor": "_0x1d5dbd",
        "result": "_0xb65cdb",
        "newFee": "_0x7667a6",
        "payout": "_0xd354f9",
        "dValue": "_0xa2b159",
        "owner": "_0x6849ec",
        "count": "_0xc3ba55",
        "users": "_0x38a0ea",
        "multi": "_0x00d8a4",
        "index": "_0x8627b8",
        "init": "_0xdfee3d",
        "fees": "_0xb0239e",
        "join": "_0xa4cabb",
        "paid": "_0x4d274d",
        "rand": "_0xddb195",
        "user": "_0xcb520d",
        "info": "_0x0fca48",
        "max": "_0xf60873",
        "fee": "_0xae8ea2",
        "id": "_0xb3cc83"
      },
      "changes": [
        "Renamed 42 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_211",
      "transformed_id": "ss_l2_hex_sn_ds_211",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": " pragma solidity ^0.4.23;\n // produced by the Solididy File Flattener (c) David Appleton 2018\n // contact : dave@akomba.com\n // released under Apache 2.0 licence\n contract Token {\n     /// total amount of tokens\n     uint256 public _0x7e88da;\n\n     /// @param _owner The address from which the balance will be retrieved\n     /// @return The balance\n     function _0x163805(address _0x77a491) public constant returns (uint256 balance);\n\n     /// @notice send `_value` token to `_to` from `msg.sender`\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function transfer(address _0x5ab6ac, uint256 _0xc11352) public returns (bool _0x4d1c5a);\n\n     /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     /// @param _from The address of the sender\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function _0xd4b040(address _0x64b841, address _0x5ab6ac, uint256 _0xc11352) public returns (bool _0x4d1c5a);\n\n     /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @param _value The amount of tokens to be approved for transfer\n     /// @return Whether the approval was successful or not\n     function _0x60e96c(address _0x6d5af0, uint256 _0xc11352) public returns (bool _0x4d1c5a);\n\n     /// @param _owner The address of the account owning tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @return Amount of remaining tokens allowed to spent\n     function _0x74647e(address _0x77a491, address _0x6d5af0) public constant returns (uint256 _0xcbb745);\n\n     event Transfer(address indexed _0x64b841, address indexed _0x5ab6ac, uint256 _0xc11352);\n     event Approval(address indexed _0x77a491, address indexed _0x6d5af0, uint256 _0xc11352);\n }\n\n library ECTools {\n\n     // @dev Recovers the address which has signed a message\n     // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n     function _0x8c5fd8(bytes32 _0xa2bd2d, string _0x1dfbcc) public pure returns (address) {\n         require(_0xa2bd2d != 0x00);\n\n         // need this for test RPC\n         bytes memory _0x260f01 = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 _0x94b463 = _0x46f92f(abi._0xba3392(_0x260f01, _0xa2bd2d));\n\n         if (bytes(_0x1dfbcc).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = _0xe67bb7(_0xd39196(_0x1dfbcc, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return _0x8fcd25(_0x94b463, v, r, s);\n     }\n\n     // @dev Verifies if the message is signed by an address\n     function _0xfc7fc7(bytes32 _0xa2bd2d, string _0x1dfbcc, address _0x8b8818) public pure returns (bool) {\n         require(_0x8b8818 != 0x0);\n\n         return _0x8b8818 == _0x8c5fd8(_0xa2bd2d, _0x1dfbcc);\n     }\n\n     // @dev Converts an hexstring to bytes\n     function _0xe67bb7(string _0x7fd4e2) public pure returns (bytes) {\n         uint _0x59af36 = bytes(_0x7fd4e2).length;\n         require(_0x59af36 % 2 == 0);\n\n         bytes memory _0x11a698 = bytes(new string(_0x59af36 / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < _0x59af36; i += 2) {\n             s = _0xd39196(_0x7fd4e2, i, i + 1);\n             r = _0xd39196(_0x7fd4e2, i + 1, i + 2);\n             uint p = _0xd0bc8a(s) * 16 + _0xd0bc8a(r);\n             _0x11a698[k++] = _0x2995a9(p)[31];\n         }\n         return _0x11a698;\n     }\n\n     // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n     function _0xd0bc8a(string _0xd65cc4) public pure returns (uint) {\n         bytes memory _0xa1b3d3 = bytes(_0xd65cc4);\n         // bool decimals = false;\n         if ((_0xa1b3d3[0] >= 48) && (_0xa1b3d3[0] <= 57)) {\n             return uint(_0xa1b3d3[0]) - 48;\n         } else if ((_0xa1b3d3[0] >= 65) && (_0xa1b3d3[0] <= 70)) {\n             return uint(_0xa1b3d3[0]) - 55;\n         } else if ((_0xa1b3d3[0] >= 97) && (_0xa1b3d3[0] <= 102)) {\n             return uint(_0xa1b3d3[0]) - 87;\n         } else {\n             revert();\n         }\n     }\n\n     // @dev Converts a uint to a bytes32\n     // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n     function _0x2995a9(uint _0x89b00b) public pure returns (bytes b) {\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), _0x89b00b)}\n     }\n\n     // @dev Hashes the signed message\n     // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n     function _0x36a608(string _0xa413be) public pure returns (bytes32) {\n         uint _0x59af36 = bytes(_0xa413be).length;\n         require(_0x59af36 > 0);\n         bytes memory _0x260f01 = \"\\x19Ethereum Signed Message:\\n\";\n         return _0x46f92f(abi._0xba3392(_0x260f01, _0xaf5802(_0x59af36), _0xa413be));\n     }\n\n     // @dev Converts a uint in a string\n     function _0xaf5802(uint _0x89b00b) public pure returns (string _0xfa622f) {\n         uint _0x59af36 = 0;\n         uint m = _0x89b00b + 0;\n         while (m != 0) {\n             _0x59af36++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(_0x59af36);\n         uint i = _0x59af36 - 1;\n         while (_0x89b00b != 0) {\n             uint _0x13b853 = _0x89b00b % 10;\n             _0x89b00b = _0x89b00b / 10;\n             b[i--] = byte(48 + _0x13b853);\n         }\n         _0xfa622f = string(b);\n     }\n\n     // @dev extract a substring\n     // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n     function _0xd39196(string _0x7f4f5b, uint _0xdacec8, uint _0x5c81f1) public pure returns (string) {\n         bytes memory _0x6492f3 = bytes(_0x7f4f5b);\n         require(_0xdacec8 <= _0x5c81f1);\n         require(_0xdacec8 >= 0);\n         require(_0x5c81f1 <= _0x6492f3.length);\n\n         bytes memory _0xf01c20 = new bytes(_0x5c81f1 - _0xdacec8);\n         for (uint i = _0xdacec8; i < _0x5c81f1; i++) {\n             _0xf01c20[i - _0xdacec8] = _0x6492f3[i];\n         }\n         return string(_0xf01c20);\n     }\n }\n contract StandardToken is Token {\n\n     function transfer(address _0x5ab6ac, uint256 _0xc11352) public returns (bool _0x4d1c5a) {\n         //Default assumes totalSupply can't be over max (2^256 - 1).\n         //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n         //Replace the if with this one instead.\n         //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(_0x0edf87[msg.sender] >= _0xc11352);\n         _0x0edf87[msg.sender] -= _0xc11352;\n         _0x0edf87[_0x5ab6ac] += _0xc11352;\n         emit Transfer(msg.sender, _0x5ab6ac, _0xc11352);\n         return true;\n     }\n\n     function _0xd4b040(address _0x64b841, address _0x5ab6ac, uint256 _0xc11352) public returns (bool _0x4d1c5a) {\n\n         //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(_0x0edf87[_0x64b841] >= _0xc11352 && _0x3494fc[_0x64b841][msg.sender] >= _0xc11352);\n         _0x0edf87[_0x5ab6ac] += _0xc11352;\n         _0x0edf87[_0x64b841] -= _0xc11352;\n         _0x3494fc[_0x64b841][msg.sender] -= _0xc11352;\n         emit Transfer(_0x64b841, _0x5ab6ac, _0xc11352);\n         return true;\n     }\n\n     function _0x163805(address _0x77a491) public constant returns (uint256 balance) {\n         return _0x0edf87[_0x77a491];\n     }\n\n     function _0x60e96c(address _0x6d5af0, uint256 _0xc11352) public returns (bool _0x4d1c5a) {\n         _0x3494fc[msg.sender][_0x6d5af0] = _0xc11352;\n         emit Approval(msg.sender, _0x6d5af0, _0xc11352);\n         return true;\n     }\n\n     function _0x74647e(address _0x77a491, address _0x6d5af0) public constant returns (uint256 _0xcbb745) {\n       return _0x3494fc[_0x77a491][_0x6d5af0];\n     }\n\n     mapping (address => uint256) _0x0edf87;\n     mapping (address => mapping (address => uint256)) _0x3494fc;\n }\n\n contract HumanStandardToken is StandardToken {\n\n     /* Public variables of the token */\n\n     string public _0x043290;                   //fancy name: eg Simon Bucks\n     uint8 public _0xca2a7a;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n     string public _0x45e9cc;                 //An identifier: eg SBX\n     string public _0x018c6b = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n     constructor(\n         uint256 _0x1dcaa5,\n         string _0xfcbb73,\n         uint8 _0x2a9071,\n         string _0xfac1fd\n         ) public {\n         _0x0edf87[msg.sender] = _0x1dcaa5;               // Give the creator all initial tokens\n         _0x7e88da = _0x1dcaa5;                        // Update total supply\n         _0x043290 = _0xfcbb73;                                   // Set the name for display purposes\n         _0xca2a7a = _0x2a9071;                            // Amount of decimals for display purposes\n         _0x45e9cc = _0xfac1fd;                               // Set the symbol for display purposes\n     }\n\n     /* Approves and then calls the receiving contract */\n     function _0xc67e95(address _0x6d5af0, uint256 _0xc11352, bytes _0x439485) public returns (bool _0x4d1c5a) {\n         _0x3494fc[msg.sender][_0x6d5af0] = _0xc11352;\n         emit Approval(msg.sender, _0x6d5af0, _0xc11352);\n\n         //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n         //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n         //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n         require(_0x6d5af0.call(bytes4(bytes32(_0x46f92f(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _0xc11352, this, _0x439485));\n         return true;\n     }\n }\n\n contract LedgerChannel {\n\n     string public constant NAME = \"Ledger Channel\";\n     string public constant VERSION = \"0.0.1\";\n\n     uint256 public _0xa0131a = 0;\n\n     event DidLCOpen (\n         bytes32 indexed _0xaf2ae6,\n         address indexed _0xd58a9f,\n         address indexed _0x4868cf,\n         uint256 _0x1b58c9,\n         address _0x06be49,\n         uint256 _0x143121,\n         uint256 LCopenTimeout\n     );\n\n     event DidLCJoin (\n         bytes32 indexed _0xaf2ae6,\n         uint256 _0xa7a483,\n         uint256 _0xb945f6\n     );\n\n     event DidLCDeposit (\n         bytes32 indexed _0xaf2ae6,\n         address indexed _0xabdf35,\n         uint256 _0x5f2a5d,\n         bool _0x5facfb\n     );\n\n     event DidLCUpdateState (\n         bytes32 indexed _0xaf2ae6,\n         uint256 _0xf38ac6,\n         uint256 _0x0b7ffa,\n         uint256 _0x1b58c9,\n         uint256 _0x143121,\n         uint256 _0xa7a483,\n         uint256 _0xb945f6,\n         bytes32 _0xd4c734,\n         uint256 _0x5ed680\n     );\n\n     event DidLCClose (\n         bytes32 indexed _0xaf2ae6,\n         uint256 _0xf38ac6,\n         uint256 _0x1b58c9,\n         uint256 _0x143121,\n         uint256 _0xa7a483,\n         uint256 _0xb945f6\n     );\n\n     event DidVCInit (\n         bytes32 indexed _0xf9f089,\n         bytes32 indexed _0xe2b694,\n         bytes _0x185d6f,\n         uint256 _0xf38ac6,\n         address _0xd58a9f,\n         address _0xb95393,\n         uint256 _0xfb80ad,\n         uint256 _0x3125a1\n     );\n\n     event DidVCSettle (\n         bytes32 indexed _0xf9f089,\n         bytes32 indexed _0xe2b694,\n         uint256 _0x305e0d,\n         uint256 _0x8ac7cc,\n         uint256 _0x5bc333,\n         address _0x01d008,\n         uint256 _0x09f372\n     );\n\n     event DidVCClose(\n         bytes32 indexed _0xf9f089,\n         bytes32 indexed _0xe2b694,\n         uint256 _0xfb80ad,\n         uint256 _0x3125a1\n     );\n\n     struct Channel {\n         //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n         address[2] _0x61b15b; // 0: partyA 1: partyI\n         uint256[4] _0x9d66dc; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[4] _0xab08c0; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[2] _0xee9f70; // 0: eth 1: tokens\n         uint256 _0xf38ac6;\n         uint256 _0xccd1b0;\n         bytes32 VCrootHash;\n         uint256 LCopenTimeout;\n         uint256 _0x5ed680; // when update LC times out\n         bool _0x16ff5d; // true when both parties have joined\n         bool _0xf4e517;\n         uint256 _0x9fe1f8;\n         HumanStandardToken _0x06be49;\n     }\n\n     // virtual-channel state\n     struct VirtualChannel {\n         bool _0x1c1905;\n         bool _0x0cf94d;\n         uint256 _0xf38ac6;\n         address _0x01d008; // Initiator of challenge\n         uint256 _0x09f372; // when update VC times out\n         // channel state\n         address _0xd58a9f; // VC participant A\n         address _0xb95393; // VC participant B\n         address _0x4868cf; // LC hub\n         uint256[2] _0x9d66dc;\n         uint256[2] _0xab08c0;\n         uint256[2] _0xf2dd38;\n         HumanStandardToken _0x06be49;\n     }\n\n     mapping(bytes32 => VirtualChannel) public _0xf3dbcf;\n     mapping(bytes32 => Channel) public Channels;\n\n     function _0x2bb8ed(\n         bytes32 _0x356be4,\n         address _0xe7ef82,\n         uint256 _0x845b0f,\n         address _0x6cd989,\n         uint256[2] _0xed3f77 // [eth, token]\n     )\n         public\n         payable\n     {\n         require(Channels[_0x356be4]._0x61b15b[0] == address(0), \"Channel has already been created.\");\n         require(_0xe7ef82 != 0x0, \"No partyI address provided to LC creation\");\n         require(_0xed3f77[0] >= 0 && _0xed3f77[1] >= 0, \"Balances cannot be negative\");\n         // Set initial ledger channel state\n         // Alice must execute this and we assume the initial state\n         // to be signed from this requirement\n         // Alternative is to check a sig as in joinChannel\n         Channels[_0x356be4]._0x61b15b[0] = msg.sender;\n         Channels[_0x356be4]._0x61b15b[1] = _0xe7ef82;\n\n         if(_0xed3f77[0] != 0) {\n             require(msg.value == _0xed3f77[0], \"Eth balance does not match sent value\");\n             Channels[_0x356be4]._0x9d66dc[0] = msg.value;\n         }\n         if(_0xed3f77[1] != 0) {\n             Channels[_0x356be4]._0x06be49 = HumanStandardToken(_0x6cd989);\n             require(Channels[_0x356be4]._0x06be49._0xd4b040(msg.sender, this, _0xed3f77[1]),\"CreateChannel: token transfer failure\");\n             Channels[_0x356be4]._0xab08c0[0] = _0xed3f77[1];\n         }\n\n         Channels[_0x356be4]._0xf38ac6 = 0;\n         Channels[_0x356be4]._0xccd1b0 = _0x845b0f;\n         // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n         //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n         Channels[_0x356be4].LCopenTimeout = _0xe09844 + _0x845b0f;\n         Channels[_0x356be4]._0xee9f70 = _0xed3f77;\n\n         emit DidLCOpen(_0x356be4, msg.sender, _0xe7ef82, _0xed3f77[0], _0x6cd989, _0xed3f77[1], Channels[_0x356be4].LCopenTimeout);\n     }\n\n     function LCOpenTimeout(bytes32 _0x356be4) public {\n         require(msg.sender == Channels[_0x356be4]._0x61b15b[0] && Channels[_0x356be4]._0x16ff5d == false);\n         require(_0xe09844 > Channels[_0x356be4].LCopenTimeout);\n\n         if(Channels[_0x356be4]._0xee9f70[0] != 0) {\n             Channels[_0x356be4]._0x61b15b[0].transfer(Channels[_0x356be4]._0x9d66dc[0]);\n         }\n         if(Channels[_0x356be4]._0xee9f70[1] != 0) {\n             require(Channels[_0x356be4]._0x06be49.transfer(Channels[_0x356be4]._0x61b15b[0], Channels[_0x356be4]._0xab08c0[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(_0x356be4, 0, Channels[_0x356be4]._0x9d66dc[0], Channels[_0x356be4]._0xab08c0[0], 0, 0);\n\n         // only safe to delete since no action was taken on this channel\n         delete Channels[_0x356be4];\n     }\n\n     function _0xe3fda0(bytes32 _0x356be4, uint256[2] _0xed3f77) public payable {\n         // require the channel is not open yet\n         require(Channels[_0x356be4]._0x16ff5d == false);\n         require(msg.sender == Channels[_0x356be4]._0x61b15b[1]);\n\n         if(_0xed3f77[0] != 0) {\n             require(msg.value == _0xed3f77[0], \"state balance does not match sent value\");\n             Channels[_0x356be4]._0x9d66dc[1] = msg.value;\n         }\n         if(_0xed3f77[1] != 0) {\n             require(Channels[_0x356be4]._0x06be49._0xd4b040(msg.sender, this, _0xed3f77[1]),\"joinChannel: token transfer failure\");\n             Channels[_0x356be4]._0xab08c0[1] = _0xed3f77[1];\n         }\n\n         Channels[_0x356be4]._0xee9f70[0]+=_0xed3f77[0];\n         Channels[_0x356be4]._0xee9f70[1]+=_0xed3f77[1];\n         // no longer allow joining functions to be called\n         Channels[_0x356be4]._0x16ff5d = true;\n         _0xa0131a++;\n\n         emit DidLCJoin(_0x356be4, _0xed3f77[0], _0xed3f77[1]);\n     }\n\n     // additive updates of monetary state\n     function _0x5f2a5d(bytes32 _0x356be4, address _0xabdf35, uint256 _0xc7230f, bool _0x5facfb) public payable {\n         require(Channels[_0x356be4]._0x16ff5d == true, \"Tried adding funds to a closed channel\");\n         require(_0xabdf35 == Channels[_0x356be4]._0x61b15b[0] || _0xabdf35 == Channels[_0x356be4]._0x61b15b[1]);\n\n         //if(Channels[_lcID].token)\n\n         if (Channels[_0x356be4]._0x61b15b[0] == _0xabdf35) {\n             if(_0x5facfb) {\n                 require(Channels[_0x356be4]._0x06be49._0xd4b040(msg.sender, this, _0xc7230f),\"deposit: token transfer failure\");\n                 Channels[_0x356be4]._0xab08c0[2] += _0xc7230f;\n             } else {\n                 require(msg.value == _0xc7230f, \"state balance does not match sent value\");\n                 Channels[_0x356be4]._0x9d66dc[2] += msg.value;\n             }\n         }\n\n         if (Channels[_0x356be4]._0x61b15b[1] == _0xabdf35) {\n             if(_0x5facfb) {\n                 require(Channels[_0x356be4]._0x06be49._0xd4b040(msg.sender, this, _0xc7230f),\"deposit: token transfer failure\");\n                 Channels[_0x356be4]._0xab08c0[3] += _0xc7230f;\n             } else {\n                 require(msg.value == _0xc7230f, \"state balance does not match sent value\");\n                 Channels[_0x356be4]._0x9d66dc[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(_0x356be4, _0xabdf35, _0xc7230f, _0x5facfb);\n     }\n\n     // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n     function _0xecafd8(\n         bytes32 _0x356be4,\n         uint256 _0xbc2cef,\n         uint256[4] _0xed3f77, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _0xbc734f,\n         string _0x1a2b43\n     )\n         public\n     {\n         // assume num open vc is 0 and root hash is 0x0\n         //require(Channels[_lcID].sequence < _sequence);\n         require(Channels[_0x356be4]._0x16ff5d == true);\n         uint256 _0x4d78c0 = Channels[_0x356be4]._0xee9f70[0] + Channels[_0x356be4]._0x9d66dc[2] + Channels[_0x356be4]._0x9d66dc[3];\n         uint256 _0x03ba76 = Channels[_0x356be4]._0xee9f70[1] + Channels[_0x356be4]._0xab08c0[2] + Channels[_0x356be4]._0xab08c0[3];\n         require(_0x4d78c0 == _0xed3f77[0] + _0xed3f77[1]);\n         require(_0x03ba76 == _0xed3f77[2] + _0xed3f77[3]);\n\n         bytes32 _0x56dd31 = _0x46f92f(\n             abi._0xba3392(\n                 _0x356be4,\n                 true,\n                 _0xbc2cef,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_0x356be4]._0x61b15b[0],\n                 Channels[_0x356be4]._0x61b15b[1],\n                 _0xed3f77[0],\n                 _0xed3f77[1],\n                 _0xed3f77[2],\n                 _0xed3f77[3]\n             )\n         );\n\n         require(Channels[_0x356be4]._0x61b15b[0] == ECTools._0x8c5fd8(_0x56dd31, _0xbc734f));\n         require(Channels[_0x356be4]._0x61b15b[1] == ECTools._0x8c5fd8(_0x56dd31, _0x1a2b43));\n\n         Channels[_0x356be4]._0x16ff5d = false;\n\n         if(_0xed3f77[0] != 0 || _0xed3f77[1] != 0) {\n             Channels[_0x356be4]._0x61b15b[0].transfer(_0xed3f77[0]);\n             Channels[_0x356be4]._0x61b15b[1].transfer(_0xed3f77[1]);\n         }\n\n         if(_0xed3f77[2] != 0 || _0xed3f77[3] != 0) {\n             require(Channels[_0x356be4]._0x06be49.transfer(Channels[_0x356be4]._0x61b15b[0], _0xed3f77[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_0x356be4]._0x06be49.transfer(Channels[_0x356be4]._0x61b15b[1], _0xed3f77[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         _0xa0131a--;\n\n         emit DidLCClose(_0x356be4, _0xbc2cef, _0xed3f77[0], _0xed3f77[1], _0xed3f77[2], _0xed3f77[3]);\n     }\n\n     // Byzantine functions\n\n     function _0x615e09(\n         bytes32 _0x356be4,\n         uint256[6] _0xf6b299, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n         bytes32 _0xc78abd,\n         string _0xbc734f,\n         string _0x1a2b43\n     )\n         public\n     {\n         Channel storage _0x5779cc = Channels[_0x356be4];\n         require(_0x5779cc._0x16ff5d);\n         require(_0x5779cc._0xf38ac6 < _0xf6b299[0]); // do same as vc sequence check\n         require(_0x5779cc._0x9d66dc[0] + _0x5779cc._0x9d66dc[1] >= _0xf6b299[2] + _0xf6b299[3]);\n         require(_0x5779cc._0xab08c0[0] + _0x5779cc._0xab08c0[1] >= _0xf6b299[4] + _0xf6b299[5]);\n\n         if(_0x5779cc._0xf4e517 == true) {\n             require(_0x5779cc._0x5ed680 > _0xe09844);\n         }\n\n         bytes32 _0x56dd31 = _0x46f92f(\n             abi._0xba3392(\n                 _0x356be4,\n                 false,\n                 _0xf6b299[0],\n                 _0xf6b299[1],\n                 _0xc78abd,\n                 _0x5779cc._0x61b15b[0],\n                 _0x5779cc._0x61b15b[1],\n                 _0xf6b299[2],\n                 _0xf6b299[3],\n                 _0xf6b299[4],\n                 _0xf6b299[5]\n             )\n         );\n\n         require(_0x5779cc._0x61b15b[0] == ECTools._0x8c5fd8(_0x56dd31, _0xbc734f));\n         require(_0x5779cc._0x61b15b[1] == ECTools._0x8c5fd8(_0x56dd31, _0x1a2b43));\n\n         // update LC state\n         _0x5779cc._0xf38ac6 = _0xf6b299[0];\n         _0x5779cc._0x9fe1f8 = _0xf6b299[1];\n         _0x5779cc._0x9d66dc[0] = _0xf6b299[2];\n         _0x5779cc._0x9d66dc[1] = _0xf6b299[3];\n         _0x5779cc._0xab08c0[0] = _0xf6b299[4];\n         _0x5779cc._0xab08c0[1] = _0xf6b299[5];\n         _0x5779cc.VCrootHash = _0xc78abd;\n         _0x5779cc._0xf4e517 = true;\n         _0x5779cc._0x5ed680 = _0xe09844 + _0x5779cc._0xccd1b0;\n\n         // make settlement flag\n\n         emit DidLCUpdateState (\n             _0x356be4,\n             _0xf6b299[0],\n             _0xf6b299[1],\n             _0xf6b299[2],\n             _0xf6b299[3],\n             _0xf6b299[4],\n             _0xf6b299[5],\n             _0xc78abd,\n             _0x5779cc._0x5ed680\n         );\n     }\n\n     // supply initial state of VC to \"prime\" the force push game\n     function _0xd57cc7(\n         bytes32 _0x356be4,\n         bytes32 _0x5b5159,\n         bytes _0xc9d36c,\n         address _0x2bd707,\n         address _0x56a897,\n         uint256[2] _0x5cea06,\n         uint256[4] _0xed3f77, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _0x6dd9b1\n     )\n         public\n     {\n         require(Channels[_0x356be4]._0x16ff5d, \"LC is closed.\");\n         // sub-channel must be open\n         require(!_0xf3dbcf[_0x5b5159]._0x1c1905, \"VC is closed.\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         require(Channels[_0x356be4]._0x5ed680 < _0xe09844, \"LC timeout not over.\");\n         // prevent rentry of initializing vc state\n         require(_0xf3dbcf[_0x5b5159]._0x09f372 == 0);\n         // partyB is now Ingrid\n         bytes32 _0x5b86b0 = _0x46f92f(\n             abi._0xba3392(_0x5b5159, uint256(0), _0x2bd707, _0x56a897, _0x5cea06[0], _0x5cea06[1], _0xed3f77[0], _0xed3f77[1], _0xed3f77[2], _0xed3f77[3])\n         );\n\n         // Make sure Alice has signed initial vc state (A/B in oldState)\n         require(_0x2bd707 == ECTools._0x8c5fd8(_0x5b86b0, _0x6dd9b1));\n\n         // Check the oldState is in the root hash\n         require(_0xd81682(_0x5b86b0, _0xc9d36c, Channels[_0x356be4].VCrootHash) == true);\n\n         _0xf3dbcf[_0x5b5159]._0xd58a9f = _0x2bd707; // VC participant A\n         _0xf3dbcf[_0x5b5159]._0xb95393 = _0x56a897; // VC participant B\n         _0xf3dbcf[_0x5b5159]._0xf38ac6 = uint256(0);\n         _0xf3dbcf[_0x5b5159]._0x9d66dc[0] = _0xed3f77[0];\n         _0xf3dbcf[_0x5b5159]._0x9d66dc[1] = _0xed3f77[1];\n         _0xf3dbcf[_0x5b5159]._0xab08c0[0] = _0xed3f77[2];\n         _0xf3dbcf[_0x5b5159]._0xab08c0[1] = _0xed3f77[3];\n         _0xf3dbcf[_0x5b5159]._0xf2dd38 = _0x5cea06;\n         _0xf3dbcf[_0x5b5159]._0x09f372 = _0xe09844 + Channels[_0x356be4]._0xccd1b0;\n         _0xf3dbcf[_0x5b5159]._0x0cf94d = true;\n\n         emit DidVCInit(_0x356be4, _0x5b5159, _0xc9d36c, uint256(0), _0x2bd707, _0x56a897, _0xed3f77[0], _0xed3f77[1]);\n     }\n\n     //TODO: verify state transition since the hub did not agree to this state\n     // make sure the A/B balances are not beyond ingrids bonds\n     // Params: vc init state, vc final balance, vcID\n     function _0xdb41a1(\n         bytes32 _0x356be4,\n         bytes32 _0x5b5159,\n         uint256 _0x305e0d,\n         address _0x2bd707,\n         address _0x56a897,\n         uint256[4] _0x73248b, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n         string _0x6dd9b1\n     )\n         public\n     {\n         require(Channels[_0x356be4]._0x16ff5d, \"LC is closed.\");\n         // sub-channel must be open\n         require(!_0xf3dbcf[_0x5b5159]._0x1c1905, \"VC is closed.\");\n         require(_0xf3dbcf[_0x5b5159]._0xf38ac6 < _0x305e0d, \"VC sequence is higher than update sequence.\");\n         require(\n             _0xf3dbcf[_0x5b5159]._0x9d66dc[1] < _0x73248b[1] && _0xf3dbcf[_0x5b5159]._0xab08c0[1] < _0x73248b[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             _0xf3dbcf[_0x5b5159]._0xf2dd38[0] == _0x73248b[0] + _0x73248b[1] &&\n             _0xf3dbcf[_0x5b5159]._0xf2dd38[1] == _0x73248b[2] + _0x73248b[3],\n             \"Incorrect balances for bonded amount\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n         // fail if initVC() isn't called first\n         // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n         require(Channels[_0x356be4]._0x5ed680 < _0xe09844); // for testing!\n\n         bytes32 _0x790ebc = _0x46f92f(\n             abi._0xba3392(\n                 _0x5b5159,\n                 _0x305e0d,\n                 _0x2bd707,\n                 _0x56a897,\n                 _0xf3dbcf[_0x5b5159]._0xf2dd38[0],\n                 _0xf3dbcf[_0x5b5159]._0xf2dd38[1],\n                 _0x73248b[0],\n                 _0x73248b[1],\n                 _0x73248b[2],\n                 _0x73248b[3]\n             )\n         );\n\n         // Make sure Alice has signed a higher sequence new state\n         require(_0xf3dbcf[_0x5b5159]._0xd58a9f == ECTools._0x8c5fd8(_0x790ebc, _0x6dd9b1));\n\n         // store VC data\n         // we may want to record who is initiating on-chain settles\n         _0xf3dbcf[_0x5b5159]._0x01d008 = msg.sender;\n         _0xf3dbcf[_0x5b5159]._0xf38ac6 = _0x305e0d;\n\n         // channel state\n         _0xf3dbcf[_0x5b5159]._0x9d66dc[0] = _0x73248b[0];\n         _0xf3dbcf[_0x5b5159]._0x9d66dc[1] = _0x73248b[1];\n         _0xf3dbcf[_0x5b5159]._0xab08c0[0] = _0x73248b[2];\n         _0xf3dbcf[_0x5b5159]._0xab08c0[1] = _0x73248b[3];\n\n         _0xf3dbcf[_0x5b5159]._0x09f372 = _0xe09844 + Channels[_0x356be4]._0xccd1b0;\n\n         emit DidVCSettle(_0x356be4, _0x5b5159, _0x305e0d, _0x73248b[0], _0x73248b[1], msg.sender, _0xf3dbcf[_0x5b5159]._0x09f372);\n     }\n\n     function _0x69222a(bytes32 _0x356be4, bytes32 _0x5b5159) public {\n         // require(updateLCtimeout > now)\n         require(Channels[_0x356be4]._0x16ff5d, \"LC is closed.\");\n         require(_0xf3dbcf[_0x5b5159]._0x0cf94d, \"VC is not in settlement state.\");\n         require(_0xf3dbcf[_0x5b5159]._0x09f372 < _0xe09844, \"Update vc timeout has not elapsed.\");\n         require(!_0xf3dbcf[_0x5b5159]._0x1c1905, \"VC is already closed\");\n         // reduce the number of open virtual channels stored on LC\n         Channels[_0x356be4]._0x9fe1f8--;\n         // close vc flags\n         _0xf3dbcf[_0x5b5159]._0x1c1905 = true;\n         // re-introduce the balances back into the LC state from the settled VC\n         // decide if this lc is alice or bob in the vc\n         if(_0xf3dbcf[_0x5b5159]._0xd58a9f == Channels[_0x356be4]._0x61b15b[0]) {\n             Channels[_0x356be4]._0x9d66dc[0] += _0xf3dbcf[_0x5b5159]._0x9d66dc[0];\n             Channels[_0x356be4]._0x9d66dc[1] += _0xf3dbcf[_0x5b5159]._0x9d66dc[1];\n\n             Channels[_0x356be4]._0xab08c0[0] += _0xf3dbcf[_0x5b5159]._0xab08c0[0];\n             Channels[_0x356be4]._0xab08c0[1] += _0xf3dbcf[_0x5b5159]._0xab08c0[1];\n         } else if (_0xf3dbcf[_0x5b5159]._0xb95393 == Channels[_0x356be4]._0x61b15b[0]) {\n             Channels[_0x356be4]._0x9d66dc[0] += _0xf3dbcf[_0x5b5159]._0x9d66dc[1];\n             Channels[_0x356be4]._0x9d66dc[1] += _0xf3dbcf[_0x5b5159]._0x9d66dc[0];\n\n             Channels[_0x356be4]._0xab08c0[0] += _0xf3dbcf[_0x5b5159]._0xab08c0[1];\n             Channels[_0x356be4]._0xab08c0[1] += _0xf3dbcf[_0x5b5159]._0xab08c0[0];\n         }\n\n         emit DidVCClose(_0x356be4, _0x5b5159, _0xf3dbcf[_0x5b5159]._0xab08c0[0], _0xf3dbcf[_0x5b5159]._0xab08c0[1]);\n     }\n\n     // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n     function _0x7ab184(bytes32 _0x356be4) public {\n         Channel storage _0x5779cc = Channels[_0x356be4];\n\n         // check settlement flag\n         require(_0x5779cc._0x16ff5d, \"Channel is not open\");\n         require(_0x5779cc._0xf4e517 == true);\n         require(_0x5779cc._0x9fe1f8 == 0);\n         require(_0x5779cc._0x5ed680 < _0xe09844, \"LC timeout over.\");\n\n         // if off chain state update didnt reblance deposits, just return to deposit owner\n         uint256 _0x4d78c0 = _0x5779cc._0xee9f70[0] + _0x5779cc._0x9d66dc[2] + _0x5779cc._0x9d66dc[3];\n         uint256 _0x03ba76 = _0x5779cc._0xee9f70[1] + _0x5779cc._0xab08c0[2] + _0x5779cc._0xab08c0[3];\n\n         uint256 _0x1fbc49 = _0x5779cc._0x9d66dc[0] + _0x5779cc._0x9d66dc[1];\n         uint256 _0xbdac95 = _0x5779cc._0xab08c0[0] + _0x5779cc._0xab08c0[1];\n\n         if(_0x1fbc49 < _0x4d78c0) {\n             _0x5779cc._0x9d66dc[0]+=_0x5779cc._0x9d66dc[2];\n             _0x5779cc._0x9d66dc[1]+=_0x5779cc._0x9d66dc[3];\n         } else {\n             require(_0x1fbc49 == _0x4d78c0);\n         }\n\n         if(_0xbdac95 < _0x03ba76) {\n             _0x5779cc._0xab08c0[0]+=_0x5779cc._0xab08c0[2];\n             _0x5779cc._0xab08c0[1]+=_0x5779cc._0xab08c0[3];\n         } else {\n             require(_0xbdac95 == _0x03ba76);\n         }\n\n         uint256 _0x66d2bc = _0x5779cc._0x9d66dc[0];\n         uint256 _0xdd9c8b = _0x5779cc._0x9d66dc[1];\n         uint256 _0x3170fa = _0x5779cc._0xab08c0[0];\n         uint256 _0xa28c8a = _0x5779cc._0xab08c0[1];\n\n         _0x5779cc._0x9d66dc[0] = 0;\n         _0x5779cc._0x9d66dc[1] = 0;\n         _0x5779cc._0xab08c0[0] = 0;\n         _0x5779cc._0xab08c0[1] = 0;\n\n         if(_0x66d2bc != 0 || _0xdd9c8b != 0) {\n             _0x5779cc._0x61b15b[0].transfer(_0x66d2bc);\n             _0x5779cc._0x61b15b[1].transfer(_0xdd9c8b);\n         }\n\n         if(_0x3170fa != 0 || _0xa28c8a != 0) {\n             require(\n                 _0x5779cc._0x06be49.transfer(_0x5779cc._0x61b15b[0], _0x3170fa),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 _0x5779cc._0x06be49.transfer(_0x5779cc._0x61b15b[1], _0xa28c8a),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         _0x5779cc._0x16ff5d = false;\n         _0xa0131a--;\n\n         emit DidLCClose(_0x356be4, _0x5779cc._0xf38ac6, _0x66d2bc, _0xdd9c8b, _0x3170fa, _0xa28c8a);\n     }\n\n     function _0xd81682(bytes32 _0xbf2ade, bytes _0xc9d36c, bytes32 _0x16404a) internal pure returns (bool) {\n         bytes32 _0x654891 = _0xbf2ade;\n         bytes32 _0x872ec0;\n\n         for (uint256 i = 64; i <= _0xc9d36c.length; i += 32) {\n             assembly { _0x872ec0 := mload(add(_0xc9d36c, i)) }\n\n             if (_0x654891 < _0x872ec0) {\n                 _0x654891 = _0x46f92f(abi._0xba3392(_0x654891, _0x872ec0));\n             } else {\n                 _0x654891 = _0x46f92f(abi._0xba3392(_0x872ec0, _0x654891));\n             }\n         }\n\n         return _0x654891 == _0x16404a;\n     }\n\n     //Struct Getters\n     function _0x852a8e(bytes32 _0x56f453) public view returns (\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     ) {\n         Channel memory _0x5779cc = Channels[_0x56f453];\n         return (\n             _0x5779cc._0x61b15b,\n             _0x5779cc._0x9d66dc,\n             _0x5779cc._0xab08c0,\n             _0x5779cc._0xee9f70,\n             _0x5779cc._0xf38ac6,\n             _0x5779cc._0xccd1b0,\n             _0x5779cc.VCrootHash,\n             _0x5779cc.LCopenTimeout,\n             _0x5779cc._0x5ed680,\n             _0x5779cc._0x16ff5d,\n             _0x5779cc._0xf4e517,\n             _0x5779cc._0x9fe1f8\n         );\n     }\n\n     function _0xf6d6f7(bytes32 _0x56f453) public view returns(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     ) {\n         VirtualChannel memory _0x24cb0b = _0xf3dbcf[_0x56f453];\n         return(\n             _0x24cb0b._0x1c1905,\n             _0x24cb0b._0x0cf94d,\n             _0x24cb0b._0xf38ac6,\n             _0x24cb0b._0x01d008,\n             _0x24cb0b._0x09f372,\n             _0x24cb0b._0xd58a9f,\n             _0x24cb0b._0xb95393,\n             _0x24cb0b._0x4868cf,\n             _0x24cb0b._0x9d66dc,\n             _0x24cb0b._0xab08c0,\n             _0x24cb0b._0xf2dd38\n         );\n     }\n }\n",
      "rename_map": {
        "possibleTotalTokenBeforeDeposit": "_0xbdac95",
        "possibleTotalEthBeforeDeposit": "_0x1fbc49",
        "toEthereumSignedMessage": "_0x36a608",
        "byzantineCloseChannel": "_0x7ab184",
        "consensusCloseChannel": "_0xecafd8",
        "closeVirtualChannel": "_0x69222a",
        "isInSettlementState": "_0x0cf94d",
        "isUpdateLCSettling": "_0xf4e517",
        "getVirtualChannel": "_0xf6d6f7",
        "totalTokenDeposit": "_0x03ba76",
        "updateLCtimeout": "_0x5ed680",
        "totalEthDeposit": "_0x4d78c0",
        "updateVCtimeout": "_0x09f372",
        "virtualChannels": "_0xf3dbcf",
        "_initialAmount": "_0x1dcaa5",
        "virtualChannel": "_0x24cb0b",
        "initialDeposit": "_0xee9f70",
        "partyAddresses": "_0x61b15b",
        "parseInt16Char": "_0xd0bc8a",
        "approveAndCall": "_0xc67e95",
        "tokenbalanceI": "_0xa28c8a",
        "erc20Balances": "_0xab08c0",
        "tokenBalanceA": "_0x143121",
        "tokenbalanceA": "_0x3170fa",
        "tokenBalanceI": "_0xb945f6",
        "hexstrToBytes": "_0xe67bb7",
        "updateLCstate": "_0x615e09",
        "createChannel": "_0x2bb8ed",
        "_decimalUnits": "_0x2a9071",
        "uintToBytes32": "_0x2995a9",
        "recoverSigner": "_0x8c5fd8",
        "uintToString": "_0xaf5802",
        "_tokenSymbol": "_0xfac1fd",
        "_confirmTime": "_0x845b0f",
        "encodePacked": "_0xba3392",
        "_isContained": "_0xd81682",
        "prefixedHash": "_0x94b463",
        "_updateState": "_0x790ebc",
        "transferFrom": "_0xd4b040",
        "updateParams": "_0xf6b299",
        "ethbalanceI": "_0xdd9c8b",
        "ethbalanceA": "_0x66d2bc",
        "ethBalanceA": "_0x1b58c9",
        "_startIndex": "_0xdacec8",
        "ethBalanceI": "_0xa7a483",
        "confirmTime": "_0xccd1b0",
        "joinChannel": "_0xe3fda0",
        "totalSupply": "_0x7e88da",
        "ethBalances": "_0x9d66dc",
        "numChannels": "_0xa0131a",
        "initVCstate": "_0xd57cc7",
        "challenger": "_0x01d008",
        "_extraData": "_0x439485",
        "isSignedBy": "_0xfc7fc7",
        "_tokenName": "_0xfcbb73",
        "getChannel": "_0x852a8e",
        "_initState": "_0x5b86b0",
        "updateBalA": "_0x8ac7cc",
        "_hashedMsg": "_0xa2bd2d",
        "updateBalB": "_0x5bc333",
        "substring": "_0xd39196",
        "remainder": "_0x13b853",
        "ecrecover": "_0x8fcd25",
        "updateBal": "_0x73248b",
        "_endIndex": "_0x5c81f1",
        "keccak256": "_0x46f92f",
        "_balances": "_0xed3f77",
        "updateSeq": "_0x305e0d",
        "proofElem": "_0x872ec0",
        "channelId": "_0xaf2ae6",
        "recipient": "_0xabdf35",
        "numOpenVC": "_0x9fe1f8",
        "_sequence": "_0xbc2cef",
        "balanceOf": "_0x163805",
        "remaining": "_0xcbb745",
        "allowance": "_0x74647e",
        "numOpenVc": "_0x0b7ffa",
        "balances": "_0x0edf87",
        "_spender": "_0x6d5af0",
        "strBytes": "_0x6492f3",
        "balanceA": "_0xfb80ad",
        "decimals": "_0xca2a7a",
        "_balance": "_0xc7230f",
        "balanceB": "_0x3125a1",
        "settleVC": "_0xdb41a1",
        "sequence": "_0xf38ac6",
        "_partyI": "_0xe7ef82",
        "version": "_0x018c6b",
        "_VCroot": "_0xc78abd",
        "allowed": "_0x3494fc",
        "success": "_0x4d1c5a",
        "bresult": "_0xa1b3d3",
        "_partyB": "_0x56a897",
        "deposit": "_0x5f2a5d",
        "isClose": "_0x1c1905",
        "channel": "_0x5779cc",
        "isToken": "_0x5facfb",
        "_hexstr": "_0x7fd4e2",
        "approve": "_0x60e96c",
        "_partyA": "_0x2bd707",
        "partyB": "_0xb95393",
        "cursor": "_0x654891",
        "_token": "_0x6cd989",
        "_proof": "_0xc9d36c",
        "_state": "_0x56dd31",
        "vcRoot": "_0xd4c734",
        "_value": "_0xc11352",
        "prefix": "_0x260f01",
        "_owner": "_0x77a491",
        "symbol": "_0x45e9cc",
        "result": "_0xf01c20",
        "isOpen": "_0x16ff5d",
        "partyI": "_0x4868cf",
        "partyA": "_0xd58a9f",
        "_lcID": "_0x356be4",
        "_from": "_0x64b841",
        "_vcID": "_0x5b5159",
        "_addr": "_0x8b8818",
        "proof": "_0x185d6f",
        "_root": "_0x16404a",
        "_hash": "_0xbf2ade",
        "_sigA": "_0xbc734f",
        "_char": "_0xd65cc4",
        "_bond": "_0x5cea06",
        "token": "_0x06be49",
        "_sigI": "_0x1a2b43",
        "_uint": "_0x89b00b",
        "sigA": "_0x6dd9b1",
        "bstr": "_0x11a698",
        "vcId": "_0xe2b694",
        "bond": "_0xf2dd38",
        "_str": "_0x7f4f5b",
        "name": "_0x043290",
        "_msg": "_0xa413be",
        "lcId": "_0xf9f089",
        "_sig": "_0x1dfbcc",
        "_to": "_0x5ab6ac",
        "len": "_0x59af36",
        "now": "_0xe09844",
        "str": "_0xfa622f",
        "id": "_0x56f453"
      },
      "changes": [
        "Renamed 141 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_212",
      "transformed_id": "ss_l2_hex_sn_ds_212",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier _0x072d96()\n    {\n        require(msg.sender == _0x0152f7);\n        _;\n    }\n\n   modifier _0x37a4b5()\n    {\n        require(_0xaaffa5);\n        _;\n    }\n\n    modifier _0xa11a1d()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  _0xb3fbc6()\n    {\n        require (_0xbbca41[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 _0xb899c3, address _0xea320f);\n    event Win(uint256 _0xb899c3, address _0x4ae2d0);\n    event Lose(uint256 _0xb899c3, address _0xfacc51);\n    event Donate(uint256 _0xb899c3, address _0x4ae2d0, address _0x81ba3b);\n    event DifficultyChanged(uint256 _0xe9ec4a);\n    event BetLimitChanged(uint256 _0x0b3da5);\n\n    address private _0x929f9d;\n    uint256 _0xc6390b;\n    uint difficulty;\n    uint private _0x15c439;\n    address _0x0152f7;\n    mapping(address => uint256) _0x170afa;\n    mapping(address => uint256) _0xbbca41;\n    bool _0xaaffa5;\n    uint256 _0x925b2b;\n\n    constructor(address _0x5fb0d3, uint256 _0xe95054)\n    _0xa11a1d()\n    public\n    {\n        _0xaaffa5 = false;\n        _0x0152f7 = msg.sender;\n        _0x929f9d = _0x5fb0d3;\n        _0x925b2b = 0;\n        _0xc6390b = _0xe95054;\n\n    }\n\n    function OpenToThePublic()\n    _0x072d96()\n    public\n    {\n        _0xaaffa5 = true;\n    }\n\n    function AdjustBetAmounts(uint256 _0xb899c3)\n    _0x072d96()\n    public\n    {\n        _0xc6390b = _0xb899c3;\n\n        emit BetLimitChanged(_0xc6390b);\n    }\n\n    function AdjustDifficulty(uint256 _0xb899c3)\n    _0x072d96()\n    public\n    {\n        difficulty = _0xb899c3;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function _0xc886a7()\n    _0x37a4b5()\n    _0xa11a1d()\n    payable\n    public\n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == _0xc6390b);\n\n        //You cannot wager multiple times\n        require(_0xbbca41[msg.sender] == 0);\n\n        //log the wager and timestamp(block number)\n        _0x170afa[msg.sender] = block.number;\n        _0xbbca41[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function _0xee256e()\n    _0x37a4b5()\n    _0xa11a1d()\n    _0xb3fbc6()\n    public\n    {\n        uint256 _0x0abdbe = _0x170afa[msg.sender];\n        if(_0x0abdbe < block.number)\n        {\n            _0x170afa[msg.sender] = 0;\n            _0xbbca41[msg.sender] = 0;\n\n            uint256 _0x563f3a = uint256(_0xb6a218(abi._0x94fec4(blockhash(_0x0abdbe),  msg.sender)))%difficulty +1;\n\n            if(_0x563f3a == difficulty / 2)\n            {\n                _0x8ffbce(msg.sender);\n            }\n            else\n            {\n                //player loses\n                _0x2b160c(_0xc6390b / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function _0xd0b6f2()\n    _0x37a4b5()\n    public\n    payable\n    {\n        _0xd4d3e1(msg.value);\n    }\n\n    function _0x8ffbce(address _0xdd86a0)\n    internal\n    {\n        uint256 _0xcba042 = address(this).balance / 2;\n\n        _0xdd86a0.transfer(_0xcba042);\n        emit Win(_0xcba042, _0xdd86a0);\n    }\n\n    function _0xd4d3e1(uint256 _0xb899c3)\n    internal\n    {\n        _0x929f9d.call.value(_0xb899c3)(bytes4(_0xb6a218(\"donate()\")));\n        _0x925b2b += _0xb899c3;\n        emit Donate(_0xb899c3, _0x929f9d, msg.sender);\n    }\n\n    function _0x2b160c(uint256 _0xb899c3)\n    internal\n    {\n        _0x929f9d.call.value(_0xb899c3)(bytes4(_0xb6a218(\"donate()\")));\n        _0x925b2b += _0xb899c3;\n        emit Lose(_0xb899c3, msg.sender);\n    }\n\n    function _0xaedf60()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function _0xe9ec4a()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function _0x0b3da5()\n    public\n    view\n    returns (uint256)\n    {\n        return _0xc6390b;\n    }\n\n    function _0x1463cb(address _0xc76ddb)\n    public\n    view\n    returns (bool)\n    {\n        if(_0xbbca41[_0xc76ddb] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function _0x036c5a()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function _0x44583e(address _0x6f616a, address _0xe93195, uint _0xcf7c27)\n    public\n    _0x072d96()\n    returns (bool _0x91fc81)\n    {\n        return ERC20Interface(_0x6f616a).transfer(_0xe93195, _0xcf7c27);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface\n{\n    function transfer(address _0x0519ff, uint256 _0xcf7c27) public returns (bool _0x91fc81);\n}",
      "rename_map": {
        "transferAnyERC20Token": "_0x44583e",
        "currentDifficulty": "_0xe9ec4a",
        "hasPlayerWagered": "_0x1463cb",
        "currentBetLimit": "_0x0b3da5",
        "isOpenToPublic": "_0x37a4b5",
        "onlyRealPeople": "_0xa11a1d",
        "winningNumber": "_0x563f3a",
        "donateToWhale": "_0xd4d3e1",
        "ethToTransfer": "_0xcba042",
        "encodePacked": "_0x94fec4",
        "whaleAddress": "_0x5fb0d3",
        "tokenAddress": "_0x6f616a",
        "openToPublic": "_0xaaffa5",
        "totalDonated": "_0x925b2b",
        "onlyPlayers": "_0xb3fbc6",
        "blockNumber": "_0x0abdbe",
        "timestamps": "_0x170afa",
        "wagerLimit": "_0xe95054",
        "tokenOwner": "_0xe93195",
        "winnersPot": "_0x036c5a",
        "ethBalance": "_0xaedf60",
        "randomSeed": "_0x15c439",
        "depositer": "_0xea320f",
        "loseWager": "_0x2b160c",
        "keccak256": "_0xb6a218",
        "onlyOwner": "_0x072d96",
        "betLimit": "_0xc6390b",
        "success": "_0x91fc81",
        "donator": "_0x81ba3b",
        "wagers": "_0xbbca41",
        "donate": "_0xd0b6f2",
        "winner": "_0xdd86a0",
        "player": "_0xc76ddb",
        "tokens": "_0xcf7c27",
        "payout": "_0x8ffbce",
        "paidTo": "_0x4ae2d0",
        "amount": "_0xb899c3",
        "owner": "_0x0152f7",
        "whale": "_0x929f9d",
        "loser": "_0xfacc51",
        "wager": "_0xc886a7",
        "play": "_0xee256e",
        "to": "_0x0519ff"
      },
      "changes": [
        "Renamed 43 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_213",
      "transformed_id": "ss_l2_hex_sn_ds_213",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.11;\ninterface _0x08c01b { function _0x8daada(address _0xd505d9, uint256 _0xd53caf, address _0x8ca99b, bytes _0xe932b3) public; }\n\n// title Migration Agent interface\ncontract MigrationAgent {\n    function _0x8c6cc4(address _0xd505d9, uint256 _0xd53caf);\n}\n\ncontract ERC20 {\n  uint public _0x268be0;\n  function _0x94c19e(address _0x3b09da) constant returns (uint);\n  function _0x8f285f(address _0xce60c4, address _0x77332b) constant returns (uint);\n\n  function transfer(address _0xcd23c9, uint value) returns (bool _0x5054a8);\n  function _0xca899d(address from, address _0xcd23c9, uint value) returns (bool _0x5054a8);\n  function _0x573acc(address _0x77332b, uint value) returns (bool _0x5054a8);\n  event Transfer(address indexed from, address indexed _0xcd23c9, uint value);\n  event Approval(address indexed _0xce60c4, address indexed _0x77332b, uint value);\n}\n\ncontract SafeMath {\n  function _0xd5af5f(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function _0x8b0d9e(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function _0x09dcb4(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function _0x35092f(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function _0xafedc1(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function _0x7d41bf(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function _0xadc441(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function _0xf2232c(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function assert(bool _0xad486c) internal {\n    if (!_0xad486c) {\n      throw;\n    }\n  }\n}\n\ncontract StandardToken is ERC20, SafeMath {\n\n  /* Token supply got increased and a new owner received these tokens */\n  event Minted(address _0x78b5a3, uint _0xa5d89e);\n\n  /* Actual balances of token holders */\n  mapping(address => uint) _0x3925a1;\n  // what exaclt ether was sent\n  mapping(address => uint) _0x6d171d;\n  /* approve() allowances */\n  mapping (address => mapping (address => uint)) _0x419d48;\n\n  /* Interface declaration */\n  function _0x38fb3f() public constant returns (bool _0x7d42c6) {\n    return true;\n  }\n\n  function transfer(address _0x4ac51d, uint _0xd53caf) returns (bool _0x488e8b) {\n    _0x3925a1[msg.sender] = _0x09dcb4(_0x3925a1[msg.sender], _0xd53caf);\n    _0x3925a1[_0x4ac51d] = _0x35092f(_0x3925a1[_0x4ac51d], _0xd53caf);\n    Transfer(msg.sender, _0x4ac51d, _0xd53caf);\n    return true;\n  }\n\n  function _0xca899d(address _0xd505d9, address _0x4ac51d, uint _0xd53caf) returns (bool _0x488e8b) {\n    uint _0xb133a9 = _0x419d48[_0xd505d9][msg.sender];\n\n    _0x3925a1[_0x4ac51d] = _0x35092f(_0x3925a1[_0x4ac51d], _0xd53caf);\n    _0x3925a1[_0xd505d9] = _0x09dcb4(_0x3925a1[_0xd505d9], _0xd53caf);\n    _0x419d48[_0xd505d9][msg.sender] = _0x09dcb4(_0xb133a9, _0xd53caf);\n    Transfer(_0xd505d9, _0x4ac51d, _0xd53caf);\n    return true;\n  }\n\n  function _0x94c19e(address _0xd7fc35) constant returns (uint balance) {\n    return _0x3925a1[_0xd7fc35];\n  }\n\n  function _0x573acc(address _0x5f96f0, uint _0xd53caf) returns (bool _0x488e8b) {\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    if ((_0xd53caf != 0) && (_0x419d48[msg.sender][_0x5f96f0] != 0)) throw;\n\n    _0x419d48[msg.sender][_0x5f96f0] = _0xd53caf;\n    Approval(msg.sender, _0x5f96f0, _0xd53caf);\n    return true;\n  }\n\n  function _0x8f285f(address _0xd7fc35, address _0x5f96f0) constant returns (uint _0xa0e481) {\n    return _0x419d48[_0xd7fc35][_0x5f96f0];\n  }\n\n}\n\n//  daoPOLSKAtokens\ncontract _0x81810c{\n\n    string public _0xbe2ecf = \"DAO POLSKA TOKEN version 1\";\n    string public _0x0f493e = \"DPL\";\n    uint8 public constant _0xba9c59 = 18;  // 18 decimal places, the same as ETC/ETH/HEE.\n\n    // Receives\n    address public _0xce60c4;\n    address public _0x26f310;\n    // The current total token supply.\n\n    uint256 public _0xc970bb =1.0 ether;\n    uint256 public _0x18b16e      = 10000.0 ether;\n\t//totalSupply\n   uint256 public  _0x268be0      = 0.0 ether;\n\t//chains:\n\taddress public Chain1 = 0x0;\n\taddress public Chain2 = 0x0;\n\taddress public Chain3 = 0x0;\n\taddress public Chain4 = 0x0;\n\n\taddress public _0xe419b1=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\n    uint256 public _0xc92749;\n\n    event Migrate(address indexed _0xd505d9, address indexed _0x4ac51d, uint256 _0xd53caf);\n    event Refund(address indexed _0xd505d9, uint256 _0xd53caf);\n\n\tstruct _0xda7b8c{\n\t\tStandardToken _0x6717d5;\n\t\tuint _0xa5d89e;\n\t\taddress _0x0ee349;\n\t}\n\tmapping(uint => _0xda7b8c) _0xc74c55;\n\tuint _0x6db1ad=0;\n\n  mapping (address => uint256) _0x3925a1;\nmapping (address => uint256) _0x6d171d;\n  mapping (address => mapping (address => uint256)) _0x419d48;\n\n\tevent UpdatedTokenInformation(string _0x531142, string _0x0b30d6);\n\n    event Transfer(address indexed _0xd505d9, address indexed _0x4ac51d, uint256 _0xd53caf);\n\tevent _0x50fdb7(address indexed _0xd505d9,uint256 _0xd53caf);\n  event Approval(address indexed _0xd7fc35, address indexed _0x5f96f0, uint256 _0xd53caf);\n\n      // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n  //tokenCreationCap\n  bool public _0x7d3262 = false;\n  bool public _0xba4546 = false;\n\n  function _0x81810c() {\n_0xce60c4=msg.sender;\n_0x26f310=msg.sender;\n}\n\nfunction  _0x43c6b7(uint256 _0x6beeda) public {\n    \t   if (msg.sender != _0xce60c4) {\n      throw;\n    }\n\t\t    \t   if (_0x7d3262 != false) {\n      throw;\n    }\n\t_0x7d3262 = true;\n\n\t_0x18b16e = _0x6beeda ** uint256(_0xba9c59);\n//balances[owner]=supplylimit;\n  }\nfunction _0xa74759(uint256 _0x6beeda) public {\n    \t   if (msg.sender != _0xce60c4) {\n      throw;\n    }\n\t    \t   if (_0x7d3262 != false) {\n      throw;\n    }\n\n\t_0xba4546 = true;\n\t_0xc970bb = _0x6beeda ** uint256(_0xba9c59);\n\n  }\n    function _0x7f7aa3(address _0x5f96f0, uint256 _0xd53caf, bytes _0xe932b3)\n        public\n        returns (bool _0x488e8b) {\n        _0x08c01b _0x77332b = _0x08c01b(_0x5f96f0);\n        if (_0x573acc(_0x5f96f0, _0xd53caf)) {\n            _0x77332b._0x8daada(msg.sender, _0xd53caf, this, _0xe932b3);\n            return true;\n        }\n    }\n\n    function _0x41e64b(uint256 _0xd53caf) public returns (bool _0x488e8b) {\n        require(_0x3925a1[msg.sender] >= _0xd53caf);   // Check if the sender has enough\n        _0x3925a1[msg.sender] -= _0xd53caf;            // Subtract from the sender\n        _0x268be0 -= _0xd53caf;                      // Updates totalSupply\n        Burn(msg.sender, _0xd53caf);\n        return true;\n    }\n\n    function _0x9cb257(address _0xd505d9, uint256 _0xd53caf) public returns (bool _0x488e8b) {\n        require(_0x3925a1[_0xd505d9] >= _0xd53caf);                // Check if the targeted balance is enough\n        require(_0xd53caf <= _0x419d48[_0xd505d9][msg.sender]);    // Check allowance\n        _0x3925a1[_0xd505d9] -= _0xd53caf;                         // Subtract from the targeted balance\n        _0x419d48[_0xd505d9][msg.sender] -= _0xd53caf;             // Subtract from the sender's allowance\n        _0x268be0 -= _0xd53caf;                              // Update totalSupply\n        Burn(_0xd505d9, _0xd53caf);\n        return true;\n    }\n\n  function transfer(address _0x4ac51d, uint256 _0xd53caf) returns (bool _0x488e8b) {\n    //Default assumes totalSupply can't be over max (2^256 - 1).\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n    //Replace the if with this one instead.\n    if (_0x3925a1[msg.sender] >= _0xd53caf && _0x3925a1[_0x4ac51d] + _0xd53caf > _0x3925a1[_0x4ac51d]) {\n    //if (balances[msg.sender] >= _value && _value > 0) {\n      _0x3925a1[msg.sender] -= _0xd53caf;\n      _0x3925a1[_0x4ac51d] += _0xd53caf;\n      Transfer(msg.sender, _0x4ac51d, _0xd53caf);\n      return true;\n    } else { return false; }\n  }\n\n  function _0xca899d(address _0xd505d9, address _0x4ac51d, uint256 _0xd53caf) returns (bool _0x488e8b) {\n\n    if (_0x3925a1[_0xd505d9] >= _0xd53caf && _0x419d48[_0xd505d9][msg.sender] >= _0xd53caf && _0x3925a1[_0x4ac51d] + _0xd53caf > _0x3925a1[_0x4ac51d]) {\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      _0x3925a1[_0x4ac51d] += _0xd53caf;\n      _0x3925a1[_0xd505d9] -= _0xd53caf;\n      _0x419d48[_0xd505d9][msg.sender] -= _0xd53caf;\n      Transfer(_0xd505d9, _0x4ac51d, _0xd53caf);\n      return true;\n    } else { return false; }\n  }\n\n  function _0x94c19e(address _0xd7fc35) constant returns (uint256 balance) {\n    return _0x3925a1[_0xd7fc35];\n  }\n\n  function _0x573acc(address _0x5f96f0, uint256 _0xd53caf) returns (bool _0x488e8b) {\n    _0x419d48[msg.sender][_0x5f96f0] = _0xd53caf;\n    Approval(msg.sender, _0x5f96f0, _0xd53caf);\n    return true;\n  }\n\n  function _0x8f285f(address _0xd7fc35, address _0x5f96f0) constant returns (uint256 _0xa0e481) {\n    return _0x419d48[_0xd7fc35][_0x5f96f0];\n  }\n\n\t    function () payable  public {\n\t\t if(_0xad3622){\n        _0x50fdb7(msg.sender, msg.value);\n\t\t_0x3925a1[msg.sender]=_0x3925a1[msg.sender]+msg.value;\n\t\t} else throw;\n\n    }\n\n  function _0xb43f5b(string _0x654a76, string _0x91a76b) {\n\n\t   if (msg.sender != _0xce60c4) {\n      throw;\n    }\n\t_0xbe2ecf = _0x654a76;\n    _0x0f493e = _0x91a76b;\n\n    UpdatedTokenInformation(_0xbe2ecf, _0x0f493e);\n  }\n\nfunction _0xb6c193(address _0x60668d, int _0xcf2787) {\n\n\t   if (msg.sender != _0xce60c4) {\n      throw;\n    }\n\tif(_0xcf2787==1){Chain1=_0x60668d;}\n\tif(_0xcf2787==2){Chain2=_0x60668d;}\n\tif(_0xcf2787==3){Chain3=_0x60668d;}\n\tif(_0xcf2787==4){Chain4=_0x60668d;}\n  }\n\n  function DAOPolskaTokenICOregulations() external returns(string _0x029b28) {\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\n}\n// if accidentally other token was donated to Project Dev\n\n\tfunction _0xa1e45d(address StandardTokenAddress, address _0x78b5a3, uint _0xa5d89e){\n\t\tif (msg.sender != _0xce60c4) {\n\t\tthrow;\n\t\t}\n\t\t_0xda7b8c t = _0xc74c55[_0x6db1ad];\n\t\tt._0x6717d5 = StandardToken(StandardTokenAddress);\n\t\tt._0xa5d89e = _0xa5d89e;\n\t\tt._0x0ee349 = _0x78b5a3;\n\t\tt._0x6717d5.transfer(_0x78b5a3, _0xa5d89e);\n\t\t_0x6db1ad++;\n\t}\n\n     // Crowdfunding:\nuint public _0x6a02e8=1000;\nuint public _0xb1297f=1000;\nuint public CreationRate=1761;\n   uint256 public constant _0x7b5ab3 = 36000;\nuint256 public _0x7173ec = 5433616;\nbool public _0xad3622 = true;\nbool public _0xc46a6f = false;\nbool public _0x75caf0= false;\n        function _0xe38f39(address _0x599af6) payable {\n\n        if (!_0xad3622) throw;\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) throw;\n\t\t// check the maximum token creation cap\n        if (msg.value > (_0x18b16e - _0x268be0) / CreationRate)\n          throw;\n\n\t\t//bonus structure\n// in early stage there is about 100% more details in ico regulations on website\n// price and converstion rate in tabled to PLN not ether, and is updated daily\n\n\t var _0x5513f5 = msg.value;\n\n        var _0x4259dc = msg.value * CreationRate;\n        _0x268be0 += _0x4259dc;\n\n        // Assign new tokens to the sender\n        _0x3925a1[_0x599af6] += _0x4259dc;\n        _0x6d171d[_0x599af6] += _0x5513f5;\n        // Log token creation event\n        Transfer(0, _0x599af6, _0x4259dc);\n\n\t\t// Create additional Dao Tokens for the community and developers around 12%\n        uint256 _0xef7e6a = 12;\n        uint256 _0x659c13 = \t_0x4259dc * _0xef7e6a / (100);\n\n        _0x268be0 += _0x659c13;\n\n        _0x3925a1[_0x26f310] += _0x659c13;\n        Transfer(0, _0x26f310, _0x659c13);\n\n\t}\n\tfunction _0x202e6e(uint _0xf122f7){\n\tif(msg.sender == _0xce60c4) {\n\t_0xb1297f=_0xf122f7;\n\tCreationRate=_0x6a02e8+_0xb1297f;\n\t}\n\t}\n\n    function FundsTransfer() external {\n\tif(_0xad3622==true) throw;\n\t\t \tif (!_0xce60c4.send(this.balance)) throw;\n    }\n\n    function PartialFundsTransfer(uint SubX) external {\n\t      if (msg.sender != _0xce60c4) throw;\n        _0xce60c4.send(this.balance - SubX);\n\t}\n\tfunction _0x4385b6() external {\n\t      if (msg.sender != _0xce60c4) throw;\n\t_0xc46a6f=!_0xc46a6f;\n        }\n\n\t\t\tfunction _0xa77136() external {\n\t      if (msg.sender != _0xce60c4) throw;\n\t_0xad3622=!_0xad3622;\n        }\n    function _0xd29118() external {\n\t      if (msg.sender != _0x26f310) throw;\n\t_0x75caf0=!_0x75caf0;\n}\n\n    // notice Finalize crowdfunding clossing funding options\n\nfunction _0xb6c888() external {\n        if (block.number <= _0x7173ec+8*_0x7b5ab3) throw;\n        // Switch to Operational state. This is the only place this can happen.\n        _0xad3622 = false;\n\t\t_0xc46a6f=!_0xc46a6f;\n        // Transfer ETH to theDAO Polska Token network Storage address.\n        if (msg.sender==_0xce60c4)\n\t\t_0xce60c4.send(this.balance);\n    }\n    function _0x7c0e13(uint256 _0xd53caf) external {\n        // Abort if not in Operational Migration state.\n        if (_0x75caf0) throw;\n\n        // Validate input value.\n        if (_0xd53caf == 0) throw;\n        if (_0xd53caf > _0x3925a1[msg.sender]) throw;\n\n        _0x3925a1[msg.sender] -= _0xd53caf;\n        _0x268be0 -= _0xd53caf;\n        _0xc92749 += _0xd53caf;\n        MigrationAgent(_0xe419b1)._0x8c6cc4(msg.sender, _0xd53caf);\n        Migrate(msg.sender, _0xe419b1, _0xd53caf);\n    }\n\nfunction _0xc00250() external {\n        // Abort if not in Funding Failure state.\n        if (_0xad3622) throw;\n        if (!_0xc46a6f) throw;\n\n        var DAOPLTokenValue = _0x3925a1[msg.sender];\n        var ETHValue = _0x6d171d[msg.sender];\n        if (ETHValue == 0) throw;\n        _0x6d171d[msg.sender] = 0;\n        _0x268be0 -= DAOPLTokenValue;\n\n        Refund(msg.sender, ETHValue);\n        msg.sender.transfer(ETHValue);\n}\n\nfunction _0x0abcac() external returns(string _0x029b28) {\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\n}\n\n}\n\n//------------------------------------------------------\n",
      "rename_map": {
        "setotherchainstotalsupply": "_0xa74759",
        "otherchainstotalsupply": "_0xc970bb",
        "createDaoPOLSKAtokens": "_0xe38f39",
        "setBonusCreationRate": "_0x202e6e",
        "setTokenInformation": "_0xb43f5b",
        "otherchainstotalset": "_0xba4546",
        "setChainsAddresses": "_0xb6c193",
        "tokenCreationRate": "_0x6a02e8",
        "preICOregulations": "_0x0abcac",
        "bonusCreationRate": "_0xb1297f",
        "additionalTokens": "_0x659c13",
        "receiveApproval": "_0x8daada",
        "migrationMaster": "_0x26f310",
        "daoPOLSKAtokens": "_0x81810c",
        "fundingEndBlock": "_0x7173ec",
        "percentOfTotal": "_0xef7e6a",
        "migrationAgent": "_0xe419b1",
        "tokenRecipient": "_0x08c01b",
        "supplylimitset": "_0x7d3262",
        "approveAndCall": "_0x7f7aa3",
        "totalMigrated": "_0xc92749",
        "sendTokenAway": "_0xda7b8c",
        "receivedEther": "_0x50fdb7",
        "migratestate": "_0x75caf0",
        "fundingState": "_0xa77136",
        "numTokensRAW": "_0x5513f5",
        "supplyLOCKER": "_0x6beeda",
        "coinContract": "_0x6717d5",
        "transferFrom": "_0xca899d",
        "numTransfers": "_0x6db1ad",
        "sendTokenAw": "_0xa1e45d",
        "balancesRAW": "_0x6d171d",
        "refundstate": "_0xc46a6f",
        "supplylimit": "_0x18b16e",
        "totalSupply": "_0x268be0",
        "migrateFrom": "_0x8c6cc4",
        "turnmigrate": "_0xd29118",
        "chainnumber": "_0xcf2787",
        "_extraData": "_0xe932b3",
        "_allowance": "_0xb133a9",
        "turnrefund": "_0x4385b6",
        "refundTRA": "_0xc00250",
        "numTokens": "_0x4259dc",
        "assertion": "_0xad486c",
        "recipient": "_0x0ee349",
        "setSupply": "_0x43c6b7",
        "transfers": "_0xc74c55",
        "newSymbol": "_0x0b30d6",
        "balanceOf": "_0x94c19e",
        "remaining": "_0xa0e481",
        "allowance": "_0x8f285f",
        "balances": "_0x3925a1",
        "_spender": "_0x5f96f0",
        "decimals": "_0xba9c59",
        "receiver": "_0x78b5a3",
        "burnFrom": "_0x9cb257",
        "finalize": "_0xb6c888",
        "newRate": "_0xf122f7",
        "chainAd": "_0x60668d",
        "newName": "_0x531142",
        "migrate": "_0x7c0e13",
        "spender": "_0x77332b",
        "_symbol": "_0x91a76b",
        "allowed": "_0x419d48",
        "safeMul": "_0xd5af5f",
        "success": "_0x488e8b",
        "safeAdd": "_0x35092f",
        "oneweek": "_0x7b5ab3",
        "funding": "_0xad3622",
        "isToken": "_0x38fb3f",
        "safeDiv": "_0x8b0d9e",
        "safeSub": "_0x09dcb4",
        "approve": "_0x573acc",
        "_token": "_0x8ca99b",
        "_value": "_0xd53caf",
        "amount": "_0xa5d89e",
        "max256": "_0xadc441",
        "_owner": "_0xd7fc35",
        "symbol": "_0x0f493e",
        "holder": "_0x599af6",
        "min256": "_0xf2232c",
        "_name": "_0x654a76",
        "_from": "_0xd505d9",
        "min64": "_0x7d41bf",
        "max64": "_0xafedc1",
        "weAre": "_0x7d42c6",
        "owner": "_0xce60c4",
        "burn": "_0x41e64b",
        "name": "_0xbe2ecf",
        "wow": "_0x029b28",
        "_to": "_0x4ac51d",
        "who": "_0x3b09da",
        "to": "_0xcd23c9",
        "ok": "_0x5054a8"
      },
      "changes": [
        "Renamed 94 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_214",
      "transformed_id": "ss_l2_hex_sn_ds_214",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract ERC20 {\n    function _0x12565b() constant returns (uint _0x967fa0);\n    function _0x405e22( address _0x780122 ) constant returns (uint value);\n    function _0x74e3d0( address _0x8220f4, address _0x78b30a ) constant returns (uint _0x16fff4);\n\n    function transfer( address _0xa2fa22, uint value) returns (bool _0xe53bea);\n    function _0xfabc8e( address from, address _0xa2fa22, uint value) returns (bool _0xe53bea);\n    function _0x6001c8( address _0x78b30a, uint value ) returns (bool _0xe53bea);\n\n    event Transfer( address indexed from, address indexed _0xa2fa22, uint value);\n    event Approval( address indexed _0x8220f4, address indexed _0x78b30a, uint value);\n}\ncontract Ownable {\n  address public _0x8220f4;\n\n  function Ownable() {\n    _0x8220f4 = msg.sender;\n  }\n\n  modifier _0x41354a() {\n    require(msg.sender == _0x8220f4);\n    _;\n  }\n\n  function _0xe2b947(address _0x28b1eb) _0x41354a {\n    if (_0x28b1eb != address(0)) {\n      _0x8220f4 = _0x28b1eb;\n    }\n  }\n\n}\n\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\ncontract ERC721 {\n    // Required methods\n    function _0x12565b() public view returns (uint256 _0xffa95f);\n    function _0x405e22(address _0xa1f990) public view returns (uint256 balance);\n    function _0x6aa502(uint256 _0x2a0fb7) external view returns (address _0x8220f4);\n    function _0x6001c8(address _0x546d79, uint256 _0x2a0fb7) external;\n    function transfer(address _0x546d79, uint256 _0x2a0fb7) external;\n    function _0xfabc8e(address _0xdf6bc8, address _0x546d79, uint256 _0x2a0fb7) external;\n\n    // Events\n    event Transfer(address from, address _0xa2fa22, uint256 _0x943848);\n    event Approval(address _0x8220f4, address _0x111e70, uint256 _0x943848);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function _0xc3fbe0(bytes4 _0x3bf5b5) external view returns (bool);\n}\n\ncontract GeneScienceInterface {\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function _0x63d297() public pure returns (bool);\n\n    /// @dev given genes of kitten 1 & 2, return a genetic combination - may have a random factor\n    /// @param genes1 genes of mom\n    /// @param genes2 genes of sire\n    /// @return the genes that are supposed to be passed down the child\n    function _0xf5394f(uint256[2] _0xd2038f, uint256[2] _0xfb6662,uint256 _0xaa95b9,uint256 _0xa70d7d, uint256 _0xc2202a) public returns (uint256[2]);\n\n    function _0x30469b(uint256[2] _0x9d825e) public view returns(uint256);\n\n    /// @dev get sex from genes 0: female 1: male\n    function _0xa34681(uint256[2] _0x9d825e) public view returns(uint256);\n\n    /// @dev get wizz type from gene\n    function _0x10f542(uint256[2] _0x9d825e) public view returns(uint256);\n\n    function _0xd2430b(uint256[2] _0x2af24c) public returns(uint256[2]);\n}\n\n/// @title A facet of PandaCore that manages special access privileges.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaAccessControl {\n    // This facet controls access control for CryptoPandas. There are four roles managed here:\n    //\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n    //         set to the address that created the smart contract in the PandaCore constructor.\n    //\n    //     - The CFO: The CFO can withdraw funds from PandaCore and its auction contracts.\n    //\n    //     - The COO: The COO can release gen0 pandas to auction, and mint promo cats.\n    //\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\n    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n    // account.\n\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n    event ContractUpgrade(address _0xbef38a);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public _0x4d531c;\n    address public _0x52de96;\n    address public _0xf36c1e;\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public _0x4fadec = false;\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier _0x0057d3() {\n        require(msg.sender == _0x4d531c);\n        _;\n    }\n\n    /// @dev Access modifier for CFO-only functionality\n    modifier _0xf9975c() {\n        require(msg.sender == _0x52de96);\n        _;\n    }\n\n    /// @dev Access modifier for COO-only functionality\n    modifier _0x6c655d() {\n        require(msg.sender == _0xf36c1e);\n        _;\n    }\n\n    modifier _0x57543d() {\n        require(\n            msg.sender == _0xf36c1e ||\n            msg.sender == _0x4d531c ||\n            msg.sender == _0x52de96\n        );\n        _;\n    }\n\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n    /// @param _newCEO The address of the new CEO\n    function _0xacac04(address _0x4a7db6) external _0x0057d3 {\n        require(_0x4a7db6 != address(0));\n\n        _0x4d531c = _0x4a7db6;\n    }\n\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n    /// @param _newCFO The address of the new CFO\n    function _0x02048a(address _0xb64cf6) external _0x0057d3 {\n        require(_0xb64cf6 != address(0));\n\n        _0x52de96 = _0xb64cf6;\n    }\n\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n    /// @param _newCOO The address of the new COO\n    function _0xe09479(address _0x816e1f) external _0x0057d3 {\n        require(_0x816e1f != address(0));\n\n        _0xf36c1e = _0x816e1f;\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\n    modifier _0xd08088() {\n        require(!_0x4fadec);\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the contract IS paused\n    modifier _0xea5b37 {\n        require(_0x4fadec);\n        _;\n    }\n\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\n    function _0xf06dd1() external _0x57543d _0xd08088 {\n        _0x4fadec = true;\n    }\n\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n    ///  one reason we may pause the contract is when CFO or COO accounts are\n    ///  compromised.\n    /// @notice This is public rather than external so it can be called by\n    ///  derived contracts.\n    function _0x29c399() public _0x0057d3 _0xea5b37 {\n        // can't unpause if contract was upgraded\n        _0x4fadec = false;\n    }\n}\n\n/// @title Base contract for CryptoPandas. Holds all common structs, events and base variables.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaBase is PandaAccessControl {\n    /*** EVENTS ***/\n\n    uint256 public constant GEN0_TOTAL_COUNT = 16200;\n    uint256 public _0xc031eb;\n\n    /// @dev The Birth event is fired whenever a new kitten comes into existence. This obviously\n    ///  includes any time a cat is created through the giveBirth method, but it is also called\n    ///  when a new gen0 cat is created.\n    event Birth(address _0x8220f4, uint256 _0xe7bc09, uint256 _0x1cc8d3, uint256 _0xe9c19a, uint256[2] _0x2e8019);\n\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a kitten\n    ///  ownership is assigned, including births.\n    event Transfer(address from, address _0xa2fa22, uint256 _0x943848);\n\n    /*** DATA TYPES ***/\n\n    /// @dev The main Panda struct. Every cat in CryptoPandas is represented by a copy\n    ///  of this structure, so great care was taken to ensure that it fits neatly into\n    ///  exactly two 256-bit words. Note that the order of the members in this structure\n    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n    struct Panda {\n        // The Panda's genetic code is packed into these 256-bits, the format is\n        // sooper-sekret! A cat's genes never change.\n        uint256[2] _0x2e8019;\n\n        // The timestamp from the block when this cat came into existence.\n        uint64 _0x9a305c;\n\n        // The minimum timestamp after which this cat can engage in breeding\n        // activities again. This same timestamp is used for the pregnancy\n        // timer (for matrons) as well as the siring cooldown.\n        uint64 _0xf8b55f;\n\n        // The ID of the parents of this panda, set to 0 for gen0 cats.\n        // Note that using 32-bit unsigned integers limits us to a \"mere\"\n        // 4 billion cats. This number might seem small until you realize\n        // that Ethereum currently has a limit of about 500 million\n        // transactions per year! So, this definitely won't be a problem\n        // for several years (even as Ethereum learns to scale).\n        uint32 _0x1cc8d3;\n        uint32 _0xe9c19a;\n\n        // Set to the ID of the sire cat for matrons that are pregnant,\n        // zero otherwise. A non-zero value here is how we know a cat\n        // is pregnant. Used to retrieve the genetic material for the new\n        // kitten when the birth transpires.\n        uint32 _0x9c00e1;\n\n        // Set to the index in the cooldown array (see below) that represents\n        // the current cooldown duration for this Panda. This starts at zero\n        // for gen0 cats, and is initialized to floor(generation/2) for others.\n        // Incremented by one for each successful breeding action, regardless\n        // of whether this cat is acting as matron or sire.\n        uint16 _0x990f40;\n\n        // The \"generation number\" of this cat. Cats minted by the CK contract\n        // for sale are called \"gen0\" and have a generation number of 0. The\n        // generation number of all other cats is the larger of the two generation\n        // numbers of their parents, plus one.\n        // (i.e. max(matron.generation, sire.generation) + 1)\n        uint16 _0x121419;\n    }\n\n    /*** CONSTANTS ***/\n\n    /// @dev A lookup table indicating the cooldown duration after any successful\n    ///  breeding action, called \"pregnancy time\" for matrons and \"siring cooldown\"\n    ///  for sires. Designed such that the cooldown roughly doubles each time a cat\n    ///  is bred, encouraging owners not to just keep breeding the same cat over\n    ///  and over again. Caps out at one week (a cat can breed an unbounded number\n    ///  of times, and the maximum cooldown is always seven days).\n    uint32[9] public _0x56d799 = [\n        uint32(5 minutes),\n        uint32(30 minutes),\n        uint32(2 hours),\n        uint32(4 hours),\n        uint32(8 hours),\n        uint32(24 hours),\n        uint32(48 hours),\n        uint32(72 hours),\n        uint32(7 days)\n    ];\n\n    // An approximation of currently how many seconds are in between blocks.\n    uint256 public _0x48a966 = 15;\n\n    /*** STORAGE ***/\n\n    /// @dev An array containing the Panda struct for all Pandas in existence. The ID\n    ///  of each cat is actually an index into this array. Note that ID 0 is a negacat,\n    ///  the unPanda, the mythical beast that is the parent of all gen0 cats. A bizarre\n    ///  creature that is both matron and sire... to itself! Has an invalid genetic code.\n    ///  In other words, cat ID 0 is invalid... ;-)\n    Panda[] _0xccbc26;\n\n    /// @dev A mapping from cat IDs to the address that owns them. All cats have\n    ///  some valid owner address, even gen0 cats are created with a non-zero owner.\n    mapping (uint256 => address) public _0x1489f4;\n\n    // @dev A mapping from owner address to count of tokens that address owns.\n    //  Used internally inside balanceOf() to resolve ownership count.\n    mapping (address => uint256) _0x5f4b33;\n\n    /// @dev A mapping from PandaIDs to an address that has been approved to call\n    ///  transferFrom(). Each Panda can only have one approved address for transfer\n    ///  at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public _0x60477d;\n\n    /// @dev A mapping from PandaIDs to an address that has been approved to use\n    ///  this Panda for siring via breedWith(). Each Panda can only have one approved\n    ///  address for siring at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public _0x39db11;\n\n    /// @dev The address of the ClockAuction contract that handles sales of Pandas. This\n    ///  same contract handles both peer-to-peer sales as well as the gen0 sales which are\n    ///  initiated every 15 minutes.\n    SaleClockAuction public _0x09557d;\n\n    /// @dev The address of a custom ClockAuction subclassed contract that handles siring\n    ///  auctions. Needs to be separate from saleAuction because the actions taken on success\n    ///  after a sales and siring auction are quite different.\n    SiringClockAuction public _0x286f88;\n\n    /// @dev The address of the sibling contract that is used to implement the sooper-sekret\n    ///  genetic combination algorithm.\n    GeneScienceInterface public _0xfb86db;\n\n    SaleClockAuctionERC20 public _0x74715e;\n\n    // wizz panda total\n    mapping (uint256 => uint256) public _0x7c3e5b;\n    mapping (uint256 => uint256) public _0xa981b7;\n\n    /// wizz panda control\n    function _0x97f917(uint256 _0x0db4cf) view external returns(uint256) {\n        return _0x7c3e5b[_0x0db4cf];\n    }\n\n    function _0xc4daf7(uint256 _0x0db4cf) view external returns(uint256) {\n        return _0xa981b7[_0x0db4cf];\n    }\n\n    function _0x3c0c81(uint256 _0x0db4cf,uint256 _0x97d39e) external _0x57543d {\n        require (_0x7c3e5b[_0x0db4cf]==0);\n        require (_0x97d39e==uint256(uint32(_0x97d39e)));\n        _0x7c3e5b[_0x0db4cf] = _0x97d39e;\n    }\n\n    function _0x2369a6(uint256 _0x6ddf15) view external returns(uint256) {\n        Panda memory _0x7d97e5 = _0xccbc26[_0x6ddf15];\n        return _0xfb86db._0x10f542(_0x7d97e5._0x2e8019);\n    }\n\n    /// @dev Assigns ownership of a specific Panda to an address.\n    function _0x54f595(address _0xdf6bc8, address _0x546d79, uint256 _0x2a0fb7) internal {\n\n        _0x5f4b33[_0x546d79]++;\n        // transfer ownership\n        _0x1489f4[_0x2a0fb7] = _0x546d79;\n        // When creating new kittens _from is 0x0, but we can't account that address.\n        if (_0xdf6bc8 != address(0)) {\n            _0x5f4b33[_0xdf6bc8]--;\n            // once the kitten is transferred also clear sire allowances\n            delete _0x39db11[_0x2a0fb7];\n            // clear any previously approved ownership exchange\n            delete _0x60477d[_0x2a0fb7];\n        }\n        // Emit the transfer event.\n        Transfer(_0xdf6bc8, _0x546d79, _0x2a0fb7);\n    }\n\n    /// @dev An internal method that creates a new panda and stores it. This\n    ///  method doesn't do any checking and should only be called when the\n    ///  input data is known to be valid. Will generate both a Birth event\n    ///  and a Transfer event.\n    /// @param _matronId The panda ID of the matron of this cat (zero for gen0)\n    /// @param _sireId The panda ID of the sire of this cat (zero for gen0)\n    /// @param _generation The generation number of this cat, must be computed by caller.\n    /// @param _genes The panda's genetic code.\n    /// @param _owner The inital owner of this cat, must be non-zero (except for the unPanda, ID 0)\n    function _0x65ca7b(\n        uint256 _0x159240,\n        uint256 _0xa47ccb,\n        uint256 _0x527278,\n        uint256[2] _0x5b953b,\n        address _0xa1f990\n    )\n        internal\n        returns (uint)\n    {\n        // These requires are not strictly necessary, our calling code should make\n        // sure that these conditions are never broken. However! _createPanda() is already\n        // an expensive call (for storage), and it doesn't hurt to be especially careful\n        // to ensure our data structures are always valid.\n        require(_0x159240 == uint256(uint32(_0x159240)));\n        require(_0xa47ccb == uint256(uint32(_0xa47ccb)));\n        require(_0x527278 == uint256(uint16(_0x527278)));\n\n        // New panda starts with the same cooldown as parent gen/2\n        uint16 _0x990f40 = 0;\n        // when contract creation, geneScience ref is null\n        if (_0xccbc26.length>0){\n            uint16 _0x8764c1 = uint16(_0xfb86db._0x30469b(_0x5b953b));\n            if (_0x8764c1==0) {\n                _0x8764c1 = 1;\n            }\n            _0x990f40 = 1000/_0x8764c1;\n            if (_0x990f40%10 < 5){\n                _0x990f40 = _0x990f40/10;\n            }else{\n                _0x990f40 = _0x990f40/10 + 1;\n            }\n            _0x990f40 = _0x990f40 - 1;\n            if (_0x990f40 > 8) {\n                _0x990f40 = 8;\n            }\n            uint256 _0x0db4cf = _0xfb86db._0x10f542(_0x5b953b);\n            if (_0x0db4cf>0 && _0x7c3e5b[_0x0db4cf]<=_0xa981b7[_0x0db4cf]) {\n                _0x5b953b = _0xfb86db._0xd2430b(_0x5b953b);\n                _0x0db4cf = 0;\n            }\n            // gensis panda cooldownIndex should be 24 hours\n            if (_0x0db4cf == 1){\n                _0x990f40 = 5;\n            }\n\n            // increase wizz counter\n            if (_0x0db4cf>0){\n                _0xa981b7[_0x0db4cf] = _0xa981b7[_0x0db4cf] + 1;\n            }\n            // all gen0&gen1 except gensis\n            if (_0x527278 <= 1 && _0x0db4cf != 1){\n                require(_0xc031eb<GEN0_TOTAL_COUNT);\n                _0xc031eb++;\n            }\n        }\n\n        Panda memory _0xbc844b = Panda({\n            _0x2e8019: _0x5b953b,\n            _0x9a305c: uint64(_0x9e380d),\n            _0xf8b55f: 0,\n            _0x1cc8d3: uint32(_0x159240),\n            _0xe9c19a: uint32(_0xa47ccb),\n            _0x9c00e1: 0,\n            _0x990f40: _0x990f40,\n            _0x121419: uint16(_0x527278)\n        });\n        uint256 _0x4f8623 = _0xccbc26.push(_0xbc844b) - 1;\n\n        // It's probably never going to happen, 4 billion cats is A LOT, but\n        // let's just be 100% sure we never let this happen.\n        require(_0x4f8623 == uint256(uint32(_0x4f8623)));\n\n        // emit the birth event\n        Birth(\n            _0xa1f990,\n            _0x4f8623,\n            uint256(_0xbc844b._0x1cc8d3),\n            uint256(_0xbc844b._0xe9c19a),\n            _0xbc844b._0x2e8019\n        );\n\n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _0x54f595(0, _0xa1f990, _0x4f8623);\n\n        return _0x4f8623;\n    }\n\n    // Any C-level can fix how many seconds per blocks are currently observed.\n    function _0x9948fa(uint256 _0xeb6bf9) external _0x57543d {\n        require(_0xeb6bf9 < _0x56d799[0]);\n        _0x48a966 = _0xeb6bf9;\n    }\n}\n/// @title The external contract that is responsible for generating metadata for the pandas,\n///  it has one function that will return the data as bytes.\ncontract ERC721Metadata {\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\n    function _0x1d6fe3(uint256 _0x2a0fb7, string) public view returns (bytes32[4] _0xd8ee50, uint256 _0x46e9e7) {\n        if (_0x2a0fb7 == 1) {\n            _0xd8ee50[0] = \"Hello World! :D\";\n            _0x46e9e7 = 15;\n        } else if (_0x2a0fb7 == 2) {\n            _0xd8ee50[0] = \"I would definitely choose a medi\";\n            _0xd8ee50[1] = \"um length string.\";\n            _0x46e9e7 = 49;\n        } else if (_0x2a0fb7 == 3) {\n            _0xd8ee50[0] = \"Lorem ipsum dolor sit amet, mi e\";\n            _0xd8ee50[1] = \"st accumsan dapibus augue lorem,\";\n            _0xd8ee50[2] = \" tristique vestibulum id, libero\";\n            _0xd8ee50[3] = \" suscipit varius sapien aliquam.\";\n            _0x46e9e7 = 128;\n        }\n    }\n}\n\n/// @title The facet of the CryptoPandas core contract that manages ownership, ERC-721 (draft) compliant.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev Ref: https://github.com/ethereum/EIPs/issues/721\n///  See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaOwnership is PandaBase, ERC721 {\n\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n    string public constant _0x87b646 = \"PandaEarth\";\n    string public constant _0x5dab3b = \"PE\";\n\n    bytes4 constant InterfaceSignature_ERC165 =\n        bytes4(_0xf96263('_0xc3fbe0(bytes4)'));\n\n    bytes4 constant InterfaceSignature_ERC721 =\n        bytes4(_0xf96263('_0x87b646()')) ^\n        bytes4(_0xf96263('_0x5dab3b()')) ^\n        bytes4(_0xf96263('_0x12565b()')) ^\n        bytes4(_0xf96263('_0x405e22(address)')) ^\n        bytes4(_0xf96263('_0x6aa502(uint256)')) ^\n        bytes4(_0xf96263('_0x6001c8(address,uint256)')) ^\n        bytes4(_0xf96263('transfer(address,uint256)')) ^\n        bytes4(_0xf96263('_0xfabc8e(address,address,uint256)')) ^\n        bytes4(_0xf96263('_0x08d2f4(address)')) ^\n        bytes4(_0xf96263('tokenMetadata(uint256,string)'));\n\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n    ///  ERC-165 (obviously!) and ERC-721.\n    function _0xc3fbe0(bytes4 _0x3bf5b5) external view returns (bool)\n    {\n        // DEBUG ONLY\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n\n        return ((_0x3bf5b5 == InterfaceSignature_ERC165) || (_0x3bf5b5 == InterfaceSignature_ERC721));\n    }\n\n    // Internal utility functions: These functions all assume that their input arguments\n    // are valid. We leave it to public methods to sanitize their inputs and follow\n    // the required logic.\n\n    /// @dev Checks if a given address is the current owner of a particular Panda.\n    /// @param _claimant the address we are validating against.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _0x4b1122(address _0xd71144, uint256 _0x2a0fb7) internal view returns (bool) {\n        return _0x1489f4[_0x2a0fb7] == _0xd71144;\n    }\n\n    /// @dev Checks if a given address currently has transferApproval for a particular Panda.\n    /// @param _claimant the address we are confirming kitten is approved for.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _0x877213(address _0xd71144, uint256 _0x2a0fb7) internal view returns (bool) {\n        return _0x60477d[_0x2a0fb7] == _0xd71144;\n    }\n\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n    ///  _approve() and transferFrom() are used together for putting Pandas on auction, and\n    ///  there is no value in spamming the log with Approval events in that case.\n    function _0xa63ae3(uint256 _0x2a0fb7, address _0xb0e841) internal {\n        _0x60477d[_0x2a0fb7] = _0xb0e841;\n    }\n\n    /// @notice Returns the number of Pandas owned by a specific address.\n    /// @param _owner The owner address to check.\n    /// @dev Required for ERC-721 compliance\n    function _0x405e22(address _0xa1f990) public view returns (uint256 _0x46e9e7) {\n        return _0x5f4b33[_0xa1f990];\n    }\n\n    /// @notice Transfers a Panda to another address. If transferring to a smart\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n    ///  CryptoPandas specifically) or your Panda may be lost forever. Seriously.\n    /// @param _to The address of the recipient, can be a user or contract.\n    /// @param _tokenId The ID of the Panda to transfer.\n    /// @dev Required for ERC-721 compliance.\n    function transfer(\n        address _0x546d79,\n        uint256 _0x2a0fb7\n    )\n        external\n        _0xd08088\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_0x546d79 != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any pandas (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        require(_0x546d79 != address(this));\n        // Disallow transfers to the auction contracts to prevent accidental\n        // misuse. Auction contracts should only take ownership of pandas\n        // through the allow + transferFrom flow.\n        require(_0x546d79 != address(_0x09557d));\n        require(_0x546d79 != address(_0x286f88));\n\n        // You can only send your own cat.\n        require(_0x4b1122(msg.sender, _0x2a0fb7));\n\n        // Reassign ownership, clear pending approvals, emit Transfer event.\n        _0x54f595(msg.sender, _0x546d79, _0x2a0fb7);\n    }\n\n    /// @notice Grant another address the right to transfer a specific Panda via\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\n    ///  clear all approvals.\n    /// @param _tokenId The ID of the Panda that can be transferred if this call succeeds.\n    /// @dev Required for ERC-721 compliance.\n    function _0x6001c8(\n        address _0x546d79,\n        uint256 _0x2a0fb7\n    )\n        external\n        _0xd08088\n    {\n        // Only an owner can grant transfer approval.\n        require(_0x4b1122(msg.sender, _0x2a0fb7));\n\n        // Register the approval (replacing any previous approval).\n        _0xa63ae3(_0x2a0fb7, _0x546d79);\n\n        // Emit approval event.\n        Approval(msg.sender, _0x546d79, _0x2a0fb7);\n    }\n\n    /// @notice Transfer a Panda owned by another address, for which the calling address\n    ///  has previously been granted transfer approval by the owner.\n    /// @param _from The address that owns the Panda to be transfered.\n    /// @param _to The address that should take ownership of the Panda. Can be any address,\n    ///  including the caller.\n    /// @param _tokenId The ID of the Panda to be transferred.\n    /// @dev Required for ERC-721 compliance.\n    function _0xfabc8e(\n        address _0xdf6bc8,\n        address _0x546d79,\n        uint256 _0x2a0fb7\n    )\n        external\n        _0xd08088\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_0x546d79 != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any pandas (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        require(_0x546d79 != address(this));\n        // Check for approval and valid ownership\n        require(_0x877213(msg.sender, _0x2a0fb7));\n        require(_0x4b1122(_0xdf6bc8, _0x2a0fb7));\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _0x54f595(_0xdf6bc8, _0x546d79, _0x2a0fb7);\n    }\n\n    /// @notice Returns the total number of Pandas currently in existence.\n    /// @dev Required for ERC-721 compliance.\n    function _0x12565b() public view returns (uint) {\n        return _0xccbc26.length - 1;\n    }\n\n    /// @notice Returns the address currently assigned ownership of a given Panda.\n    /// @dev Required for ERC-721 compliance.\n    function _0x6aa502(uint256 _0x2a0fb7)\n        external\n        view\n        returns (address _0x8220f4)\n    {\n        _0x8220f4 = _0x1489f4[_0x2a0fb7];\n\n        require(_0x8220f4 != address(0));\n    }\n\n    /// @notice Returns a list of all Panda IDs assigned to an address.\n    /// @param _owner The owner whose Pandas we are interested in.\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Panda array looking for cats belonging to owner),\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function _0x08d2f4(address _0xa1f990) external view returns(uint256[] _0x6e0bbc) {\n        uint256 _0x9bc79c = _0x405e22(_0xa1f990);\n\n        if (_0x9bc79c == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory _0x614e89 = new uint256[](_0x9bc79c);\n            uint256 _0x59751c = _0x12565b();\n            uint256 _0xe929a1 = 0;\n\n            // We count on the fact that all cats have IDs starting at 1 and increasing\n            // sequentially up to the totalCat count.\n            uint256 _0xc26877;\n\n            for (_0xc26877 = 1; _0xc26877 <= _0x59751c; _0xc26877++) {\n                if (_0x1489f4[_0xc26877] == _0xa1f990) {\n                    _0x614e89[_0xe929a1] = _0xc26877;\n                    _0xe929a1++;\n                }\n            }\n\n            return _0x614e89;\n        }\n    }\n\n    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\n    ///  This method is licenced under the Apache License.\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n    function _0x28465f(uint _0xbce0c8, uint _0x8efd19, uint _0xe7132d) private view {\n        // Copy word-length chunks while possible\n        for(; _0xe7132d >= 32; _0xe7132d -= 32) {\n            assembly {\n                mstore(_0xbce0c8, mload(_0x8efd19))\n            }\n            _0xbce0c8 += 32;\n            _0x8efd19 += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 _0x48e956 = 256 ** (32 - _0xe7132d) - 1;\n        assembly {\n            let _0x16aa68 := and(mload(_0x8efd19), not(_0x48e956))\n            let _0xc3f4b5 := and(mload(_0xbce0c8), _0x48e956)\n            mstore(_0xbce0c8, or(_0xc3f4b5, _0x16aa68))\n        }\n    }\n\n    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\n    ///  This method is licenced under the Apache License.\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n    function _0xe7b1f9(bytes32[4] _0xaec75e, uint256 _0x60e71c) private view returns (string) {\n        var _0x719cb5 = new string(_0x60e71c);\n        uint256 _0x4da290;\n        uint256 _0x20c478;\n\n        assembly {\n            _0x4da290 := add(_0x719cb5, 32)\n            _0x20c478 := _0xaec75e\n        }\n\n        _0x28465f(_0x4da290, _0x20c478, _0x60e71c);\n\n        return _0x719cb5;\n    }\n\n}\n\n/// @title A facet of PandaCore that manages Panda siring, gestation, and birth.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaBreeding is PandaOwnership {\n\n    uint256 public constant GENSIS_TOTAL_COUNT = 100;\n\n    /// @dev The Pregnant event is fired when two cats successfully breed and the pregnancy\n    ///  timer begins for the matron.\n    event Pregnant(address _0x8220f4, uint256 _0x1cc8d3, uint256 _0xe9c19a, uint256 _0xf8b55f);\n    /// @dev The Abortion event is fired when two cats breed failed.\n    event Abortion(address _0x8220f4, uint256 _0x1cc8d3, uint256 _0xe9c19a);\n\n    /// @notice The minimum payment required to use breedWithAuto(). This fee goes towards\n    ///  the gas cost paid by whatever calls giveBirth(), and can be dynamically updated by\n    ///  the COO role as the gas price changes.\n    uint256 public _0x331967 = 2 finney;\n\n    // Keeps track of number of pregnant pandas.\n    uint256 public _0xada84f;\n\n    mapping(uint256 => address) _0x9e1bbe;\n\n    /// @dev Update the address of the genetic contract, can only be called by the CEO.\n    /// @param _address An address of a GeneScience contract instance to be used from this point forward.\n    function _0x0dd545(address _0x528740) external _0x0057d3 {\n        GeneScienceInterface _0x4ccd8f = GeneScienceInterface(_0x528740);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0x4ccd8f._0x63d297());\n\n        // Set the new contract address\n        _0xfb86db = _0x4ccd8f;\n    }\n\n    /// @dev Checks that a given kitten is able to breed. Requires that the\n    ///  current cooldown is finished (for sires) and also checks that there is\n    ///  no pending pregnancy.\n    function _0x947dff(Panda _0xa77a49) internal view returns(bool) {\n        // In addition to checking the cooldownEndBlock, we also need to check to see if\n        // the cat has a pending birth; there can be some period of time between the end\n        // of the pregnacy timer and the birth event.\n        return (_0xa77a49._0x9c00e1 == 0) && (_0xa77a49._0xf8b55f <= uint64(block.number));\n    }\n\n    /// @dev Check if a sire has authorized breeding with this matron. True if both sire\n    ///  and matron have the same owner, or if the sire has given siring permission to\n    ///  the matron's owner (via approveSiring()).\n    function _0xb4d690(uint256 _0xa47ccb, uint256 _0x159240) internal view returns(bool) {\n        address _0x6195d4 = _0x1489f4[_0x159240];\n        address _0x10b52b = _0x1489f4[_0xa47ccb];\n\n        // Siring is okay if they have same owner, or if the matron's owner was given\n        // permission to breed with this sire.\n        return (_0x6195d4 == _0x10b52b || _0x39db11[_0xa47ccb] == _0x6195d4);\n    }\n\n    /// @dev Set the cooldownEndTime for the given Panda, based on its current cooldownIndex.\n    ///  Also increments the cooldownIndex (unless it has hit the cap).\n    /// @param _kitten A reference to the Panda in storage which needs its timer started.\n    function _0xb06e32(Panda storage _0xaafd3c) internal {\n        // Compute an estimation of the cooldown time in blocks (based on current cooldownIndex).\n        _0xaafd3c._0xf8b55f = uint64((_0x56d799[_0xaafd3c._0x990f40] / _0x48a966) + block.number);\n\n        // Increment the breeding count, clamping it at 13, which is the length of the\n        // cooldowns array. We could check the array size dynamically, but hard-coding\n        // this as a constant saves gas. Yay, Solidity!\n        if (_0xaafd3c._0x990f40 < 8 && _0xfb86db._0x10f542(_0xaafd3c._0x2e8019) != 1) {\n            _0xaafd3c._0x990f40 += 1;\n        }\n    }\n\n    /// @notice Grants approval to another user to sire with one of your Pandas.\n    /// @param _addr The address that will be able to sire with your Panda. Set to\n    ///  address(0) to clear all siring approvals for this Panda.\n    /// @param _sireId A Panda that you own that _addr will now be able to sire with.\n    function _0xd1072c(address _0xc9c990, uint256 _0xa47ccb)\n    external\n    _0xd08088 {\n        require(_0x4b1122(msg.sender, _0xa47ccb));\n        _0x39db11[_0xa47ccb] = _0xc9c990;\n    }\n\n    /// @dev Updates the minimum payment required for calling giveBirthAuto(). Can only\n    ///  be called by the COO address. (This fee is used to offset the gas cost incurred\n    ///  by the autobirth daemon).\n    function _0x4f156b(uint256 _0x457d97) external _0x6c655d {\n        _0x331967 = _0x457d97;\n    }\n\n    /// @dev Checks to see if a given Panda is pregnant and (if so) if the gestation\n    ///  period has passed.\n    function _0x7b96fa(Panda _0x681327) private view returns(bool) {\n        return (_0x681327._0x9c00e1 != 0) && (_0x681327._0xf8b55f <= uint64(block.number));\n    }\n\n    /// @notice Checks that a given kitten is able to breed (i.e. it is not pregnant or\n    ///  in the middle of a siring cooldown).\n    /// @param _pandaId reference the id of the kitten, any user can inquire about it\n    function _0x666fed(uint256 _0xea2db4)\n    public\n    view\n    returns(bool) {\n        require(_0xea2db4 > 0);\n        Panda storage _0x88a094 = _0xccbc26[_0xea2db4];\n        return _0x947dff(_0x88a094);\n    }\n\n    /// @dev Checks whether a panda is currently pregnant.\n    /// @param _pandaId reference the id of the kitten, any user can inquire about it\n    function _0x7d2fb6(uint256 _0xea2db4)\n    public\n    view\n    returns(bool) {\n        require(_0xea2db4 > 0);\n        // A panda is pregnant if and only if this field is set\n        return _0xccbc26[_0xea2db4]._0x9c00e1 != 0;\n    }\n\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair. DOES NOT\n    ///  check ownership permissions (that is up to the caller).\n    /// @param _matron A reference to the Panda struct of the potential matron.\n    /// @param _matronId The matron's ID.\n    /// @param _sire A reference to the Panda struct of the potential sire.\n    /// @param _sireId The sire's ID\n    function _0x75f075(\n        Panda storage _0x681327,\n        uint256 _0x159240,\n        Panda storage _0x3f35b4,\n        uint256 _0xa47ccb\n    )\n    private\n    view\n    returns(bool) {\n        // A Panda can't breed with itself!\n        if (_0x159240 == _0xa47ccb) {\n            return false;\n        }\n\n        // Pandas can't breed with their parents.\n        if (_0x681327._0x1cc8d3 == _0xa47ccb || _0x681327._0xe9c19a == _0xa47ccb) {\n            return false;\n        }\n        if (_0x3f35b4._0x1cc8d3 == _0x159240 || _0x3f35b4._0xe9c19a == _0x159240) {\n            return false;\n        }\n\n        // We can short circuit the sibling check (below) if either cat is\n        // gen zero (has a matron ID of zero).\n        if (_0x3f35b4._0x1cc8d3 == 0 || _0x681327._0x1cc8d3 == 0) {\n            return true;\n        }\n\n        // Pandas can't breed with full or half siblings.\n        if (_0x3f35b4._0x1cc8d3 == _0x681327._0x1cc8d3 || _0x3f35b4._0x1cc8d3 == _0x681327._0xe9c19a) {\n            return false;\n        }\n        if (_0x3f35b4._0xe9c19a == _0x681327._0x1cc8d3 || _0x3f35b4._0xe9c19a == _0x681327._0xe9c19a) {\n            return false;\n        }\n\n        // male should get breed with female\n        if (_0xfb86db._0xa34681(_0x681327._0x2e8019) + _0xfb86db._0xa34681(_0x3f35b4._0x2e8019) != 1) {\n            return false;\n        }\n\n        // Everything seems cool! Let's get DTF.\n        return true;\n    }\n\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair for\n    ///  breeding via auction (i.e. skips ownership and siring approval checks).\n    function _0x21c919(uint256 _0x159240, uint256 _0xa47ccb)\n    internal\n    view\n    returns(bool) {\n        Panda storage _0xe3dcec = _0xccbc26[_0x159240];\n        Panda storage _0xa9d265 = _0xccbc26[_0xa47ccb];\n        return _0x75f075(_0xe3dcec, _0x159240, _0xa9d265, _0xa47ccb);\n    }\n\n    /// @notice Checks to see if two cats can breed together, including checks for\n    ///  ownership and siring approvals. Does NOT check that both cats are ready for\n    ///  breeding (i.e. breedWith could still fail until the cooldowns are finished).\n    ///  TODO: Shouldn't this check pregnancy and cooldowns?!?\n    /// @param _matronId The ID of the proposed matron.\n    /// @param _sireId The ID of the proposed sire.\n    function _0x6bf1ad(uint256 _0x159240, uint256 _0xa47ccb)\n    external\n    view\n    returns(bool) {\n        require(_0x159240 > 0);\n        require(_0xa47ccb > 0);\n        Panda storage _0xe3dcec = _0xccbc26[_0x159240];\n        Panda storage _0xa9d265 = _0xccbc26[_0xa47ccb];\n        return _0x75f075(_0xe3dcec, _0x159240, _0xa9d265, _0xa47ccb) &&\n            _0xb4d690(_0xa47ccb, _0x159240);\n    }\n\n    function _0x05c032(uint256 _0x159240, uint256 _0xa47ccb) internal returns(uint256, uint256) {\n        if (_0xfb86db._0xa34681(_0xccbc26[_0x159240]._0x2e8019) == 1) {\n            return (_0xa47ccb, _0x159240);\n        } else {\n            return (_0x159240, _0xa47ccb);\n        }\n    }\n\n    /// @dev Internal utility function to initiate breeding, assumes that all breeding\n    ///  requirements have been checked.\n    function _0x248711(uint256 _0x159240, uint256 _0xa47ccb, address _0xa1f990) internal {\n        // make id point real gender\n        (_0x159240, _0xa47ccb) = _0x05c032(_0x159240, _0xa47ccb);\n        // Grab a reference to the Pandas from storage.\n        Panda storage _0xa9d265 = _0xccbc26[_0xa47ccb];\n        Panda storage _0xe3dcec = _0xccbc26[_0x159240];\n\n        // Mark the matron as pregnant, keeping track of who the sire is.\n        _0xe3dcec._0x9c00e1 = uint32(_0xa47ccb);\n\n        // Trigger the cooldown for both parents.\n        _0xb06e32(_0xa9d265);\n        _0xb06e32(_0xe3dcec);\n\n        // Clear siring permission for both parents. This may not be strictly necessary\n        // but it's likely to avoid confusion!\n        delete _0x39db11[_0x159240];\n        delete _0x39db11[_0xa47ccb];\n\n        // Every time a panda gets pregnant, counter is incremented.\n        _0xada84f++;\n\n        _0x9e1bbe[_0x159240] = _0xa1f990;\n\n        // Emit the pregnancy event.\n        Pregnant(_0x1489f4[_0x159240], _0x159240, _0xa47ccb, _0xe3dcec._0xf8b55f);\n    }\n\n    /// @notice Breed a Panda you own (as matron) with a sire that you own, or for which you\n    ///  have previously been given Siring approval. Will either make your cat pregnant, or will\n    ///  fail entirely. Requires a pre-payment of the fee given out to the first caller of giveBirth()\n    /// @param _matronId The ID of the Panda acting as matron (will end up pregnant if successful)\n    /// @param _sireId The ID of the Panda acting as sire (will begin its siring cooldown if successful)\n    function _0x6ca36f(uint256 _0x159240, uint256 _0xa47ccb)\n    external\n    payable\n    _0xd08088 {\n        // Checks for payment.\n        require(msg.value >= _0x331967);\n\n        // Caller must own the matron.\n        require(_0x4b1122(msg.sender, _0x159240));\n\n        // Neither sire nor matron are allowed to be on auction during a normal\n        // breeding operation, but we don't need to check that explicitly.\n        // For matron: The caller of this function can't be the owner of the matron\n        //   because the owner of a Panda on auction is the auction house, and the\n        //   auction house will never call breedWith().\n        // For sire: Similarly, a sire on auction will be owned by the auction house\n        //   and the act of transferring ownership will have cleared any oustanding\n        //   siring approval.\n        // Thus we don't need to spend gas explicitly checking to see if either cat\n        // is on auction.\n\n        // Check that matron and sire are both owned by caller, or that the sire\n        // has given siring permission to caller (i.e. matron's owner).\n        // Will fail for _sireId = 0\n        require(_0xb4d690(_0xa47ccb, _0x159240));\n\n        // Grab a reference to the potential matron\n        Panda storage _0xe3dcec = _0xccbc26[_0x159240];\n\n        // Make sure matron isn't pregnant, or in the middle of a siring cooldown\n        require(_0x947dff(_0xe3dcec));\n\n        // Grab a reference to the potential sire\n        Panda storage _0xa9d265 = _0xccbc26[_0xa47ccb];\n\n        // Make sure sire isn't pregnant, or in the middle of a siring cooldown\n        require(_0x947dff(_0xa9d265));\n\n        // Test that these cats are a valid mating pair.\n        require(_0x75f075(\n            _0xe3dcec,\n            _0x159240,\n            _0xa9d265,\n            _0xa47ccb\n        ));\n\n        // All checks passed, panda gets pregnant!\n        _0x248711(_0x159240, _0xa47ccb, msg.sender);\n    }\n\n    /// @notice Have a pregnant Panda give birth!\n    /// @param _matronId A Panda ready to give birth.\n    /// @return The Panda ID of the new kitten.\n    /// @dev Looks at a given Panda and, if pregnant and if the gestation period has passed,\n    ///  combines the genes of the two parents to create a new kitten. The new Panda is assigned\n    ///  to the current owner of the matron. Upon successful completion, both the matron and the\n\n    ///  are willing to pay the gas!), but the new kitten always goes to the mother's owner.\n    function _0xc70cea(uint256 _0x159240, uint256[2] _0x1fe607, uint256[2] _0x5cb52e)\n    external\n    _0xd08088\n    _0x57543d\n    returns(uint256) {\n        // Grab a reference to the matron in storage.\n        Panda storage _0xe3dcec = _0xccbc26[_0x159240];\n\n        // Check that the matron is a valid cat.\n        require(_0xe3dcec._0x9a305c != 0);\n\n        // Check that the matron is pregnant, and that its time has come!\n        require(_0x7b96fa(_0xe3dcec));\n\n        // Grab a reference to the sire in storage.\n        uint256 _0xe9c19a = _0xe3dcec._0x9c00e1;\n        Panda storage _0xa9d265 = _0xccbc26[_0xe9c19a];\n\n        // Determine the higher generation number of the two parents\n        uint16 _0xe7632f = _0xe3dcec._0x121419;\n        if (_0xa9d265._0x121419 > _0xe3dcec._0x121419) {\n            _0xe7632f = _0xa9d265._0x121419;\n        }\n\n        // Call the sooper-sekret gene mixing operation.\n        //uint256[2] memory childGenes = geneScience.mixGenes(matron.genes, sire.genes,matron.generation,sire.generation, matron.cooldownEndBlock - 1);\n        uint256[2] memory _0x9f2392 = _0x1fe607;\n\n        uint256 _0xc6d621 = 0;\n\n        // birth failed\n        uint256 _0xa832c4 = (_0xfb86db._0x30469b(_0xe3dcec._0x2e8019) + _0xfb86db._0x30469b(_0xa9d265._0x2e8019)) / 2 + _0x5cb52e[0];\n        if (_0xa832c4 >= (_0xe7632f + 1) * _0x5cb52e[1]) {\n            _0xa832c4 = _0xa832c4 - (_0xe7632f + 1) * _0x5cb52e[1];\n        } else {\n            _0xa832c4 = 0;\n        }\n        if (_0xe7632f == 0 && _0xc031eb == GEN0_TOTAL_COUNT) {\n            _0xa832c4 = 0;\n        }\n        if (uint256(_0xf96263(block.blockhash(block.number - 2), _0x9e380d)) % 100 < _0xa832c4) {\n            // Make the new kitten!\n            address _0x8220f4 = _0x9e1bbe[_0x159240];\n            _0xc6d621 = _0x65ca7b(_0x159240, _0xe3dcec._0x9c00e1, _0xe7632f + 1, _0x9f2392, _0x8220f4);\n        } else {\n            Abortion(_0x1489f4[_0x159240], _0x159240, _0xe9c19a);\n        }\n        // Make the new kitten!\n        //address owner = pandaIndexToOwner[_matronId];\n        //address owner = childOwner[_matronId];\n        //uint256 kittenId = _createPanda(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n\n        // Clear the reference to sire from the matron (REQUIRED! Having siringWithId\n        // set is what marks a matron as being pregnant.)\n        delete _0xe3dcec._0x9c00e1;\n\n        // Every time a panda gives birth counter is decremented.\n        _0xada84f--;\n\n        // Send the balance fee to the person who made birth happen.\n        msg.sender.send(_0x331967);\n\n        delete _0x9e1bbe[_0x159240];\n\n        // return the new kitten's ID\n        return _0xc6d621;\n    }\n}\n\n/// @title Auction Core\n/// @dev Contains models, variables, and internal methods for the auction.\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract ClockAuctionBase {\n\n    // Represents an auction on an NFT\n    struct Auction {\n        // Current owner of NFT\n        address _0x90f826;\n        // Price (in wei) at beginning of auction\n        uint128 _0x5807e4;\n        // Price (in wei) at end of auction\n        uint128 _0xd31b85;\n        // Duration (in seconds) of auction\n        uint64 _0xd2874f;\n        // Time when auction started\n        // NOTE: 0 if this auction has been concluded\n        uint64 _0x64601a;\n        // is this auction for gen0 panda\n        uint64 _0xec42d1;\n    }\n\n    // Reference to contract tracking NFT ownership\n    ERC721 public _0x8fe97c;\n\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\n    // Values 0-10,000 map to 0%-100%\n    uint256 public _0xd3261f;\n\n    // Map from token ID to their corresponding auction.\n    mapping (uint256 => Auction) _0xb96fb1;\n\n    event AuctionCreated(uint256 _0x943848, uint256 _0x5807e4, uint256 _0xd31b85, uint256 _0xd2874f);\n    event AuctionSuccessful(uint256 _0x943848, uint256 _0x68fc79, address _0x58f25a);\n    event AuctionCancelled(uint256 _0x943848);\n\n    /// @dev Returns true if the claimant owns the token.\n    /// @param _claimant - Address claiming to own the token.\n    /// @param _tokenId - ID of token whose ownership to verify.\n    function _0x4b1122(address _0xd71144, uint256 _0x2a0fb7) internal view returns (bool) {\n        return (_0x8fe97c._0x6aa502(_0x2a0fb7) == _0xd71144);\n    }\n\n    /// @dev Escrows the NFT, assigning ownership to this contract.\n    /// Throws if the escrow fails.\n    /// @param _owner - Current owner address of token to escrow.\n    /// @param _tokenId - ID of token whose approval to verify.\n    function _0xe5ccba(address _0xa1f990, uint256 _0x2a0fb7) internal {\n        // it will throw if transfer fails\n        _0x8fe97c._0xfabc8e(_0xa1f990, this, _0x2a0fb7);\n    }\n\n    /// @dev Transfers an NFT owned by this contract to another address.\n    /// Returns true if the transfer succeeds.\n    /// @param _receiver - Address to transfer NFT to.\n    /// @param _tokenId - ID of token to transfer.\n    function _0x54f595(address _0xbb38a5, uint256 _0x2a0fb7) internal {\n        // it will throw if transfer fails\n        _0x8fe97c.transfer(_0xbb38a5, _0x2a0fb7);\n    }\n\n    /// @dev Adds an auction to the list of open auctions. Also fires the\n    ///  AuctionCreated event.\n    /// @param _tokenId The ID of the token to be put on auction.\n    /// @param _auction Auction to add.\n    function _0x23df7e(uint256 _0x2a0fb7, Auction _0x1ed53c) internal {\n        // Require that all auctions have a duration of\n        // at least one minute. (Keeps our math from getting hairy!)\n        require(_0x1ed53c._0xd2874f >= 1 minutes);\n\n        _0xb96fb1[_0x2a0fb7] = _0x1ed53c;\n\n        AuctionCreated(\n            uint256(_0x2a0fb7),\n            uint256(_0x1ed53c._0x5807e4),\n            uint256(_0x1ed53c._0xd31b85),\n            uint256(_0x1ed53c._0xd2874f)\n        );\n    }\n\n    /// @dev Cancels an auction unconditionally.\n    function _0xe9165e(uint256 _0x2a0fb7, address _0xa5d202) internal {\n        _0x850d63(_0x2a0fb7);\n        _0x54f595(_0xa5d202, _0x2a0fb7);\n        AuctionCancelled(_0x2a0fb7);\n    }\n\n    /// @dev Computes the price and transfers winnings.\n    /// Does NOT transfer ownership of token.\n    function _0xe84084(uint256 _0x2a0fb7, uint256 _0x5c2f09)\n        internal\n        returns (uint256)\n    {\n        // Get a reference to the auction struct\n        Auction storage _0x48f123 = _0xb96fb1[_0x2a0fb7];\n\n        // Explicitly check that this auction is currently live.\n        // (Because of how Ethereum mappings work, we can't just count\n        // on the lookup above failing. An invalid _tokenId will just\n        // return an auction object that is all zeros.)\n        require(_0x625a36(_0x48f123));\n\n        // Check that the bid is greater than or equal to the current price\n        uint256 _0x6865b3 = _0x2793c4(_0x48f123);\n        require(_0x5c2f09 >= _0x6865b3);\n\n        // Grab a reference to the seller before the auction struct\n        // gets deleted.\n        address _0x90f826 = _0x48f123._0x90f826;\n\n        // The bid is good! Remove the auction before sending the fees\n        _0x850d63(_0x2a0fb7);\n\n        // Transfer proceeds to seller (if there are any!)\n        if (_0x6865b3 > 0) {\n            // Calculate the auctioneer's cut.\n            // (NOTE: _computeCut() is guaranteed to return a\n            // value <= price, so this subtraction can't go negative.)\n            uint256 _0xe6a0ee = _0x9db62b(_0x6865b3);\n            uint256 _0x303dd3 = _0x6865b3 - _0xe6a0ee;\n\n            // NOTE: Doing a transfer() in the middle of a complex\n            // method like this is generally discouraged because of\n            // a contract with an invalid fallback function. We explicitly\n            // before calling transfer(), and the only thing the seller\n\n            // accident, they can call cancelAuction(). )\n            _0x90f826.transfer(_0x303dd3);\n        }\n\n        // Calculate any excess funds included with the bid. If the excess\n        // is anything worth worrying about, transfer it back to bidder.\n        // NOTE: We checked above that the bid amount is greater than or\n\n        uint256 _0xc20f78 = _0x5c2f09 - _0x6865b3;\n\n        // Return the funds. Similar to the previous transfer, this is\n        // removed before any transfers occur.\n        msg.sender.transfer(_0xc20f78);\n\n        // Tell the world!\n        AuctionSuccessful(_0x2a0fb7, _0x6865b3, msg.sender);\n\n        return _0x6865b3;\n    }\n\n    /// @dev Removes an auction from the list of open auctions.\n    /// @param _tokenId - ID of NFT on auction.\n    function _0x850d63(uint256 _0x2a0fb7) internal {\n        delete _0xb96fb1[_0x2a0fb7];\n    }\n\n    /// @dev Returns true if the NFT is on auction.\n    /// @param _auction - Auction to check.\n    function _0x625a36(Auction storage _0x1ed53c) internal view returns (bool) {\n        return (_0x1ed53c._0x64601a > 0);\n    }\n\n    /// @dev Returns current price of an NFT on auction. Broken into two\n    ///  functions (this one, that computes the duration from the auction\n    ///  structure, and the other that does the price computation) so we\n    ///  can easily test that the price computation works correctly.\n    function _0x2793c4(Auction storage _0x1ed53c)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _0x37403d = 0;\n\n        // A bit of insurance against negative values (or wraparound).\n        // Probably not necessary (since Ethereum guarnatees that the\n        // now variable doesn't ever go backwards).\n        if (_0x9e380d > _0x1ed53c._0x64601a) {\n            _0x37403d = _0x9e380d - _0x1ed53c._0x64601a;\n        }\n\n        return _0x08b972(\n            _0x1ed53c._0x5807e4,\n            _0x1ed53c._0xd31b85,\n            _0x1ed53c._0xd2874f,\n            _0x37403d\n        );\n    }\n\n    /// @dev Computes the current price of an auction. Factored out\n    ///  from _currentPrice so we can run extensive unit tests.\n    ///  When testing, make this function public and turn on\n    ///  `Current price computation` test suite.\n    function _0x08b972(\n        uint256 _0xabaf22,\n        uint256 _0x0713a2,\n        uint256 _0x738e66,\n        uint256 _0x98b1fb\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our public functions carefully cap the maximum values for\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\n        //  also known to be non-zero (see the require() statement in\n        //  _addAuction())\n        if (_0x98b1fb >= _0x738e66) {\n            // We've reached the end of the dynamic pricing portion\n            // of the auction, just return the end price.\n            return _0x0713a2;\n        } else {\n            // Starting price can be higher than ending price (and often is!), so\n            // this delta can be negative.\n            int256 _0xe4d803 = int256(_0x0713a2) - int256(_0xabaf22);\n\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\n            // will always fit within 256-bits.\n            int256 _0xe57619 = _0xe4d803 * int256(_0x98b1fb) / int256(_0x738e66);\n\n            // currentPriceChange can be negative, but if so, will have a magnitude\n            // less that _startingPrice. Thus, this result will always end up positive.\n            int256 _0xdcc091 = int256(_0xabaf22) + _0xe57619;\n\n            return uint256(_0xdcc091);\n        }\n    }\n\n    /// @dev Computes owner's cut of a sale.\n    /// @param _price - Sale price of NFT.\n    function _0x9db62b(uint256 _0x88da80) internal view returns (uint256) {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our entry functions carefully cap the maximum values for\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n        //  statement in the ClockAuction constructor). The result of this\n        //  function is always guaranteed to be <= _price.\n        return _0x88da80 * _0xd3261f / 10000;\n    }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public _0x4fadec = false;\n\n  modifier _0xd08088() {\n    require(!_0x4fadec);\n    _;\n  }\n\n  modifier _0xea5b37 {\n    require(_0x4fadec);\n    _;\n  }\n\n  function _0xf06dd1() _0x41354a _0xd08088 returns (bool) {\n    _0x4fadec = true;\n    Pause();\n    return true;\n  }\n\n  function _0x29c399() _0x41354a _0xea5b37 returns (bool) {\n    _0x4fadec = false;\n    Unpause();\n    return true;\n  }\n}\n\n/// @title Clock auction for non-fungible tokens.\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract ClockAuction is Pausable, ClockAuctionBase {\n\n    /// @dev The ERC-165 interface signature for ERC-721.\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n\n    /// @dev Constructor creates a reference to the NFT ownership contract\n    ///  and verifies the owner cut is in the valid range.\n    /// @param _nftAddress - address of a deployed contract implementing\n    ///  the Nonfungible Interface.\n    /// @param _cut - percent cut the owner takes on each auction, must be\n    ///  between 0-10,000.\n    function ClockAuction(address _0x178fd7, uint256 _0x8bc9ec) public {\n        require(_0x8bc9ec <= 10000);\n        _0xd3261f = _0x8bc9ec;\n\n        ERC721 _0x4ccd8f = ERC721(_0x178fd7);\n        require(_0x4ccd8f._0xc3fbe0(InterfaceSignature_ERC721));\n        _0x8fe97c = _0x4ccd8f;\n    }\n\n    /// @dev Remove all Ether from the contract, which is the owner's cuts\n    ///  as well as any Ether sent directly to the contract address.\n    ///  Always transfers to the NFT contract, but can be called either by\n    ///  the owner or the NFT contract.\n    function _0xe9244c() external {\n        address _0xff8058 = address(_0x8fe97c);\n\n        require(\n            msg.sender == _0x8220f4 ||\n            msg.sender == _0xff8058\n        );\n        // We are using this boolean method to make sure that even if one fails it will still work\n        bool _0xa1b3cb = _0xff8058.send(this.balance);\n    }\n\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of time to move between starting\n    ///  price and ending price (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0x717db7(\n        uint256 _0x2a0fb7,\n        uint256 _0xabaf22,\n        uint256 _0x0713a2,\n        uint256 _0x738e66,\n        address _0xa5d202\n    )\n        external\n        _0xd08088\n    {\n\n        // to store them in the auction struct.\n        require(_0xabaf22 == uint256(uint128(_0xabaf22)));\n        require(_0x0713a2 == uint256(uint128(_0x0713a2)));\n        require(_0x738e66 == uint256(uint64(_0x738e66)));\n\n        require(_0x4b1122(msg.sender, _0x2a0fb7));\n        _0xe5ccba(msg.sender, _0x2a0fb7);\n        Auction memory _0x48f123 = Auction(\n            _0xa5d202,\n            uint128(_0xabaf22),\n            uint128(_0x0713a2),\n            uint64(_0x738e66),\n            uint64(_0x9e380d),\n            0\n        );\n        _0x23df7e(_0x2a0fb7, _0x48f123);\n    }\n\n    /// @dev Bids on an open auction, completing the auction and transferring\n    ///  ownership of the NFT if enough Ether is supplied.\n    /// @param _tokenId - ID of token to bid on.\n    function _0xfa3b41(uint256 _0x2a0fb7)\n        external\n        payable\n        _0xd08088\n    {\n        // _bid will throw if the bid or funds transfer fails\n        _0xe84084(_0x2a0fb7, msg.value);\n        _0x54f595(msg.sender, _0x2a0fb7);\n    }\n\n    /// @dev Cancels an auction that hasn't been won yet.\n    ///  Returns the NFT to original owner.\n    /// @notice This is a state-modifying function that can\n    ///  be called while the contract is paused.\n    /// @param _tokenId - ID of token on auction\n    function _0x23d753(uint256 _0x2a0fb7)\n        external\n    {\n        Auction storage _0x48f123 = _0xb96fb1[_0x2a0fb7];\n        require(_0x625a36(_0x48f123));\n        address _0x90f826 = _0x48f123._0x90f826;\n        require(msg.sender == _0x90f826);\n        _0xe9165e(_0x2a0fb7, _0x90f826);\n    }\n\n    /// @dev Cancels an auction when the contract is paused.\n    ///  Only the owner may do this, and NFTs are returned to\n    ///  the seller. This should only be used in emergencies.\n    /// @param _tokenId - ID of the NFT on auction to cancel.\n    function _0xc5fc64(uint256 _0x2a0fb7)\n        _0xea5b37\n        _0x41354a\n        external\n    {\n        Auction storage _0x48f123 = _0xb96fb1[_0x2a0fb7];\n        require(_0x625a36(_0x48f123));\n        _0xe9165e(_0x2a0fb7, _0x48f123._0x90f826);\n    }\n\n    /// @dev Returns auction info for an NFT on auction.\n    /// @param _tokenId - ID of NFT on auction.\n    function _0xa02f1d(uint256 _0x2a0fb7)\n        external\n        view\n        returns\n    (\n        address _0x90f826,\n        uint256 _0x5807e4,\n        uint256 _0xd31b85,\n        uint256 _0xd2874f,\n        uint256 _0x64601a\n    ) {\n        Auction storage _0x48f123 = _0xb96fb1[_0x2a0fb7];\n        require(_0x625a36(_0x48f123));\n        return (\n            _0x48f123._0x90f826,\n            _0x48f123._0x5807e4,\n            _0x48f123._0xd31b85,\n            _0x48f123._0xd2874f,\n            _0x48f123._0x64601a\n        );\n    }\n\n    /// @dev Returns the current price of an auction.\n    /// @param _tokenId - ID of the token price we are checking.\n    function _0x0270f4(uint256 _0x2a0fb7)\n        external\n        view\n        returns (uint256)\n    {\n        Auction storage _0x48f123 = _0xb96fb1[_0x2a0fb7];\n        require(_0x625a36(_0x48f123));\n        return _0x2793c4(_0x48f123);\n    }\n\n}\n\n/// @title Reverse auction modified for siring\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SiringClockAuction is ClockAuction {\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSiringAuctionAddress() call.\n    bool public _0x8042c1 = true;\n\n    // Delegate constructor\n    function SiringClockAuction(address _0x045b6f, uint256 _0x8bc9ec) public\n        ClockAuction(_0x045b6f, _0x8bc9ec) {}\n\n    /// @dev Creates and begins a new auction. Since this function is wrapped,\n    /// require sender to be PandaCore contract.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0x717db7(\n        uint256 _0x2a0fb7,\n        uint256 _0xabaf22,\n        uint256 _0x0713a2,\n        uint256 _0x738e66,\n        address _0xa5d202\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0xabaf22 == uint256(uint128(_0xabaf22)));\n        require(_0x0713a2 == uint256(uint128(_0x0713a2)));\n        require(_0x738e66 == uint256(uint64(_0x738e66)));\n\n        require(msg.sender == address(_0x8fe97c));\n        _0xe5ccba(_0xa5d202, _0x2a0fb7);\n        Auction memory _0x48f123 = Auction(\n            _0xa5d202,\n            uint128(_0xabaf22),\n            uint128(_0x0713a2),\n            uint64(_0x738e66),\n            uint64(_0x9e380d),\n            0\n        );\n        _0x23df7e(_0x2a0fb7, _0x48f123);\n    }\n\n    /// @dev Places a bid for siring. Requires the sender\n    /// is the PandaCore contract because all bid methods\n    /// should be wrapped. Also returns the panda to the\n    /// seller rather than the winner.\n    function _0xfa3b41(uint256 _0x2a0fb7)\n        external\n        payable\n    {\n        require(msg.sender == address(_0x8fe97c));\n        address _0x90f826 = _0xb96fb1[_0x2a0fb7]._0x90f826;\n        // _bid checks that token ID is valid and will throw if bid fails\n        _0xe84084(_0x2a0fb7, msg.value);\n        // We transfer the panda back to the seller, the winner will get\n        // the offspring\n        _0x54f595(_0x90f826, _0x2a0fb7);\n    }\n\n}\n\n/// @title Clock auction modified for sale of pandas\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SaleClockAuction is ClockAuction {\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSaleAuctionAddress() call.\n    bool public _0xf35dbf = true;\n\n    // Tracks last 5 sale price of gen0 panda sales\n    uint256 public _0xfad7df;\n    uint256[5] public _0x8da879;\n    uint256 public constant SurpriseValue = 10 finney;\n\n    uint256[] CommonPanda;\n    uint256[] RarePanda;\n    uint256   CommonPandaIndex;\n    uint256   RarePandaIndex;\n\n    // Delegate constructor\n    function SaleClockAuction(address _0x045b6f, uint256 _0x8bc9ec) public\n        ClockAuction(_0x045b6f, _0x8bc9ec) {\n            CommonPandaIndex = 1;\n            RarePandaIndex   = 1;\n    }\n\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0x717db7(\n        uint256 _0x2a0fb7,\n        uint256 _0xabaf22,\n        uint256 _0x0713a2,\n        uint256 _0x738e66,\n        address _0xa5d202\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0xabaf22 == uint256(uint128(_0xabaf22)));\n        require(_0x0713a2 == uint256(uint128(_0x0713a2)));\n        require(_0x738e66 == uint256(uint64(_0x738e66)));\n\n        require(msg.sender == address(_0x8fe97c));\n        _0xe5ccba(_0xa5d202, _0x2a0fb7);\n        Auction memory _0x48f123 = Auction(\n            _0xa5d202,\n            uint128(_0xabaf22),\n            uint128(_0x0713a2),\n            uint64(_0x738e66),\n            uint64(_0x9e380d),\n            0\n        );\n        _0x23df7e(_0x2a0fb7, _0x48f123);\n    }\n\n    function _0x32f6c5(\n        uint256 _0x2a0fb7,\n        uint256 _0xabaf22,\n        uint256 _0x0713a2,\n        uint256 _0x738e66,\n        address _0xa5d202\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0xabaf22 == uint256(uint128(_0xabaf22)));\n        require(_0x0713a2 == uint256(uint128(_0x0713a2)));\n        require(_0x738e66 == uint256(uint64(_0x738e66)));\n\n        require(msg.sender == address(_0x8fe97c));\n        _0xe5ccba(_0xa5d202, _0x2a0fb7);\n        Auction memory _0x48f123 = Auction(\n            _0xa5d202,\n            uint128(_0xabaf22),\n            uint128(_0x0713a2),\n            uint64(_0x738e66),\n            uint64(_0x9e380d),\n            1\n        );\n        _0x23df7e(_0x2a0fb7, _0x48f123);\n    }\n\n    /// @dev Updates lastSalePrice if seller is the nft contract\n    /// Otherwise, works the same as default bid method.\n    function _0xfa3b41(uint256 _0x2a0fb7)\n        external\n        payable\n    {\n        // _bid verifies token ID size\n        uint64 _0xec42d1 = _0xb96fb1[_0x2a0fb7]._0xec42d1;\n        uint256 _0x6865b3 = _0xe84084(_0x2a0fb7, msg.value);\n        _0x54f595(msg.sender, _0x2a0fb7);\n\n        // If not a gen0 auction, exit\n        if (_0xec42d1 == 1) {\n            // Track gen0 sale prices\n            _0x8da879[_0xfad7df % 5] = _0x6865b3;\n            _0xfad7df++;\n        }\n    }\n\n    function _0xa3b2ee(uint256 _0x2a0fb7,uint256 _0x6c813d)\n        external\n    {\n        require(msg.sender == address(_0x8fe97c));\n        if (_0x6c813d == 0) {\n            CommonPanda.push(_0x2a0fb7);\n        }else {\n            RarePanda.push(_0x2a0fb7);\n        }\n    }\n\n    function _0xd11bc8()\n        external\n        payable\n    {\n        bytes32 _0x2614ec = _0xf96263(block.blockhash(block.number),block.blockhash(block.number-1));\n        uint256 PandaIndex;\n        if (_0x2614ec[25] > 0xC8) {\n            require(uint256(RarePanda.length) >= RarePandaIndex);\n            PandaIndex = RarePandaIndex;\n            RarePandaIndex ++;\n\n        } else{\n            require(uint256(CommonPanda.length) >= CommonPandaIndex);\n            PandaIndex = CommonPandaIndex;\n            CommonPandaIndex ++;\n        }\n        _0x54f595(msg.sender,PandaIndex);\n    }\n\n    function _0xf9d215() external view returns(uint256 _0xee5283,uint256 _0x9a710c) {\n        _0xee5283   = CommonPanda.length + 1 - CommonPandaIndex;\n        _0x9a710c = RarePanda.length + 1 - RarePandaIndex;\n    }\n\n    function _0x6443ca() external view returns (uint256) {\n        uint256 _0xdce758 = 0;\n        for (uint256 i = 0; i < 5; i++) {\n            _0xdce758 += _0x8da879[i];\n        }\n        return _0xdce758 / 5;\n    }\n\n}\n\n/// @title Clock auction modified for sale of pandas\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SaleClockAuctionERC20 is ClockAuction {\n\n    event AuctionERC20Created(uint256 _0x943848, uint256 _0x5807e4, uint256 _0xd31b85, uint256 _0xd2874f, address _0xf2de6f);\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSaleAuctionAddress() call.\n    bool public _0x848770 = true;\n\n    mapping (uint256 => address) public _0xe57b35;\n\n    mapping (address => uint256) public _0xe649b0;\n\n    mapping (address => uint256) public _0x423c03;\n\n    // Delegate constructor\n    function SaleClockAuctionERC20(address _0x045b6f, uint256 _0x8bc9ec) public\n        ClockAuction(_0x045b6f, _0x8bc9ec) {}\n\n    function _0x4e37eb(address _0x7d3779, uint256 _0xe4f6e7) external{\n        require (msg.sender == address(_0x8fe97c));\n\n        require (_0x7d3779 != address(0));\n\n        _0xe649b0[_0x7d3779] = _0xe4f6e7;\n    }\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0x717db7(\n        uint256 _0x2a0fb7,\n        address _0xbc65ac,\n        uint256 _0xabaf22,\n        uint256 _0x0713a2,\n        uint256 _0x738e66,\n        address _0xa5d202\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0xabaf22 == uint256(uint128(_0xabaf22)));\n        require(_0x0713a2 == uint256(uint128(_0x0713a2)));\n        require(_0x738e66 == uint256(uint64(_0x738e66)));\n\n        require(msg.sender == address(_0x8fe97c));\n\n        require (_0xe649b0[_0xbc65ac] > 0);\n\n        _0xe5ccba(_0xa5d202, _0x2a0fb7);\n        Auction memory _0x48f123 = Auction(\n            _0xa5d202,\n            uint128(_0xabaf22),\n            uint128(_0x0713a2),\n            uint64(_0x738e66),\n            uint64(_0x9e380d),\n            0\n        );\n        _0xd16c6a(_0x2a0fb7, _0x48f123, _0xbc65ac);\n        _0xe57b35[_0x2a0fb7] = _0xbc65ac;\n    }\n\n    /// @dev Adds an auction to the list of open auctions. Also fires the\n    ///  AuctionCreated event.\n    /// @param _tokenId The ID of the token to be put on auction.\n    /// @param _auction Auction to add.\n    function _0xd16c6a(uint256 _0x2a0fb7, Auction _0x1ed53c, address _0x7d3779) internal {\n        // Require that all auctions have a duration of\n        // at least one minute. (Keeps our math from getting hairy!)\n        require(_0x1ed53c._0xd2874f >= 1 minutes);\n\n        _0xb96fb1[_0x2a0fb7] = _0x1ed53c;\n\n        AuctionERC20Created(\n            uint256(_0x2a0fb7),\n            uint256(_0x1ed53c._0x5807e4),\n            uint256(_0x1ed53c._0xd31b85),\n            uint256(_0x1ed53c._0xd2874f),\n            _0x7d3779\n        );\n    }\n\n    function _0xfa3b41(uint256 _0x2a0fb7)\n        external\n        payable{\n            // do nothing\n    }\n\n    /// @dev Updates lastSalePrice if seller is the nft contract\n    /// Otherwise, works the same as default bid method.\n    function _0xc0a153(uint256 _0x2a0fb7,uint256 _0x9f9fe9)\n        external\n    {\n        // _bid verifies token ID size\n        address _0x90f826 = _0xb96fb1[_0x2a0fb7]._0x90f826;\n        address _0x7d3779 = _0xe57b35[_0x2a0fb7];\n        require (_0x7d3779 != address(0));\n        uint256 _0x6865b3 = _0xf1c7e2(_0x7d3779,msg.sender,_0x2a0fb7, _0x9f9fe9);\n        _0x54f595(msg.sender, _0x2a0fb7);\n        delete _0xe57b35[_0x2a0fb7];\n    }\n\n    function _0x23d753(uint256 _0x2a0fb7)\n        external\n    {\n        Auction storage _0x48f123 = _0xb96fb1[_0x2a0fb7];\n        require(_0x625a36(_0x48f123));\n        address _0x90f826 = _0x48f123._0x90f826;\n        require(msg.sender == _0x90f826);\n        _0xe9165e(_0x2a0fb7, _0x90f826);\n        delete _0xe57b35[_0x2a0fb7];\n    }\n\n    function _0x800540(address _0xbc65ac, address _0x546d79) external returns(bool _0xa1b3cb)  {\n        require (_0x423c03[_0xbc65ac] > 0);\n        require(msg.sender == address(_0x8fe97c));\n        ERC20(_0xbc65ac).transfer(_0x546d79, _0x423c03[_0xbc65ac]);\n    }\n\n    /// @dev Computes the price and transfers winnings.\n    /// Does NOT transfer ownership of token.\n    function _0xf1c7e2(address _0xbc65ac,address _0x9d7ce8, uint256 _0x2a0fb7, uint256 _0x5c2f09)\n        internal\n        returns (uint256)\n    {\n        // Get a reference to the auction struct\n        Auction storage _0x48f123 = _0xb96fb1[_0x2a0fb7];\n\n        // Explicitly check that this auction is currently live.\n        // (Because of how Ethereum mappings work, we can't just count\n        // on the lookup above failing. An invalid _tokenId will just\n        // return an auction object that is all zeros.)\n        require(_0x625a36(_0x48f123));\n\n        require (_0xbc65ac != address(0) && _0xbc65ac == _0xe57b35[_0x2a0fb7]);\n\n        // Check that the bid is greater than or equal to the current price\n        uint256 _0x6865b3 = _0x2793c4(_0x48f123);\n        require(_0x5c2f09 >= _0x6865b3);\n\n        // Grab a reference to the seller before the auction struct\n        // gets deleted.\n        address _0x90f826 = _0x48f123._0x90f826;\n\n        // The bid is good! Remove the auction before sending the fees\n        _0x850d63(_0x2a0fb7);\n\n        // Transfer proceeds to seller (if there are any!)\n        if (_0x6865b3 > 0) {\n            // Calculate the auctioneer's cut.\n            // (NOTE: _computeCut() is guaranteed to return a\n            // value <= price, so this subtraction can't go negative.)\n            uint256 _0xe6a0ee = _0x9db62b(_0x6865b3);\n            uint256 _0x303dd3 = _0x6865b3 - _0xe6a0ee;\n\n            // Send Erc20 Token to seller should call Erc20 contract\n            // Reference to contract\n            require(ERC20(_0xbc65ac)._0xfabc8e(_0x9d7ce8,_0x90f826,_0x303dd3));\n            if (_0xe6a0ee > 0){\n                require(ERC20(_0xbc65ac)._0xfabc8e(_0x9d7ce8,address(this),_0xe6a0ee));\n                _0x423c03[_0xbc65ac] += _0xe6a0ee;\n            }\n        }\n\n        // Tell the world!\n        AuctionSuccessful(_0x2a0fb7, _0x6865b3, msg.sender);\n\n        return _0x6865b3;\n    }\n}\n\n/// @title Handles creating auctions for sale and siring of pandas.\n///  This wrapper of ReverseAuction exists only so that users can create\n///  auctions with only one transaction.\ncontract PandaAuction is PandaBreeding {\n\n    // @notice The auction contract variables are defined in PandaBase to allow\n    //  us to refer to them in PandaOwnership to prevent accidental transfers.\n    // `saleAuction` refers to the auction for gen0 and p2p sale of pandas.\n    // `siringAuction` refers to the auction for siring rights of pandas.\n\n    /// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function _0x4213e9(address _0x528740) external _0x0057d3 {\n        SaleClockAuction _0x4ccd8f = SaleClockAuction(_0x528740);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0x4ccd8f._0xf35dbf());\n\n        // Set the new contract address\n        _0x09557d = _0x4ccd8f;\n    }\n\n    function _0x976607(address _0x528740) external _0x0057d3 {\n        SaleClockAuctionERC20 _0x4ccd8f = SaleClockAuctionERC20(_0x528740);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0x4ccd8f._0x848770());\n\n        // Set the new contract address\n        _0x74715e = _0x4ccd8f;\n    }\n\n    /// @dev Sets the reference to the siring auction.\n    /// @param _address - Address of siring contract.\n    function _0x44f254(address _0x528740) external _0x0057d3 {\n        SiringClockAuction _0x4ccd8f = SiringClockAuction(_0x528740);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0x4ccd8f._0x8042c1());\n\n        // Set the new contract address\n        _0x286f88 = _0x4ccd8f;\n    }\n\n    /// @dev Put a panda up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function _0xe7f71b(\n        uint256 _0xea2db4,\n        uint256 _0xabaf22,\n        uint256 _0x0713a2,\n        uint256 _0x738e66\n    )\n        external\n        _0xd08088\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_0x4b1122(msg.sender, _0xea2db4));\n        // Ensure the panda is not pregnant to prevent the auction\n        // contract accidentally receiving ownership of the child.\n        // NOTE: the panda IS allowed to be in a cooldown.\n        require(!_0x7d2fb6(_0xea2db4));\n        _0xa63ae3(_0xea2db4, _0x09557d);\n        // Sale auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        _0x09557d._0x717db7(\n            _0xea2db4,\n            _0xabaf22,\n            _0x0713a2,\n            _0x738e66,\n            msg.sender\n        );\n    }\n\n    /// @dev Put a panda up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function _0xcc11d5(\n        uint256 _0xea2db4,\n        address _0x7d3779,\n        uint256 _0xabaf22,\n        uint256 _0x0713a2,\n        uint256 _0x738e66\n    )\n        external\n        _0xd08088\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_0x4b1122(msg.sender, _0xea2db4));\n        // Ensure the panda is not pregnant to prevent the auction\n        // contract accidentally receiving ownership of the child.\n        // NOTE: the panda IS allowed to be in a cooldown.\n        require(!_0x7d2fb6(_0xea2db4));\n        _0xa63ae3(_0xea2db4, _0x74715e);\n        // Sale auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        _0x74715e._0x717db7(\n            _0xea2db4,\n            _0x7d3779,\n            _0xabaf22,\n            _0x0713a2,\n            _0x738e66,\n            msg.sender\n        );\n    }\n\n    function _0x421643(address _0x7d3779, uint256 _0xe4f6e7) external _0x6c655d{\n        _0x74715e._0x4e37eb(_0x7d3779,_0xe4f6e7);\n    }\n\n    /// @dev Put a panda up for auction to be sire.\n    ///  Performs checks to ensure the panda can be sired, then\n    ///  delegates to reverse auction.\n    function _0x99abcc(\n        uint256 _0xea2db4,\n        uint256 _0xabaf22,\n        uint256 _0x0713a2,\n        uint256 _0x738e66\n    )\n        external\n        _0xd08088\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_0x4b1122(msg.sender, _0xea2db4));\n        require(_0x666fed(_0xea2db4));\n        _0xa63ae3(_0xea2db4, _0x286f88);\n        // Siring auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        _0x286f88._0x717db7(\n            _0xea2db4,\n            _0xabaf22,\n            _0x0713a2,\n            _0x738e66,\n            msg.sender\n        );\n    }\n\n    /// @dev Completes a siring auction by bidding.\n    ///  Immediately breeds the winning matron with the sire on auction.\n    /// @param _sireId - ID of the sire on auction.\n    /// @param _matronId - ID of the matron owned by the bidder.\n    function _0x8aa274(\n        uint256 _0xa47ccb,\n        uint256 _0x159240\n    )\n        external\n        payable\n        _0xd08088\n    {\n        // Auction contract checks input sizes\n        require(_0x4b1122(msg.sender, _0x159240));\n        require(_0x666fed(_0x159240));\n        require(_0x21c919(_0x159240, _0xa47ccb));\n\n        // Define the current price of the auction.\n        uint256 _0xdcc091 = _0x286f88._0x0270f4(_0xa47ccb);\n        require(msg.value >= _0xdcc091 + _0x331967);\n\n        // Siring auction will throw if the bid fails.\n        _0x286f88._0xfa3b41.value(msg.value - _0x331967)(_0xa47ccb);\n        _0x248711(uint32(_0x159240), uint32(_0xa47ccb), msg.sender);\n    }\n\n    /// @dev Transfers the balance of the sale auction contract\n    /// to the PandaCore contract. We use two-step withdrawal to\n    /// prevent two transfer calls in the auction bid function.\n    function _0x5e9172() external _0x57543d {\n        _0x09557d._0xe9244c();\n        _0x286f88._0xe9244c();\n    }\n\n    function _0x800540(address _0xbc65ac, address _0x546d79) external _0x57543d {\n        require(_0x74715e != address(0));\n        _0x74715e._0x800540(_0xbc65ac,_0x546d79);\n    }\n}\n\n/// @title all functions related to creating kittens\ncontract PandaMinting is PandaAuction {\n\n    // Limits the number of cats the contract owner can ever create.\n    //uint256 public constant PROMO_CREATION_LIMIT = 5000;\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\n\n    // Constants for gen0 auctions.\n    uint256 public constant GEN0_STARTING_PRICE = 100 finney;\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\n    uint256 public constant OPEN_PACKAGE_PRICE = 10 finney;\n\n    // Counts the number of cats the contract owner has created.\n    //uint256 public promoCreatedCount;\n\n    /// @dev we can create promo kittens, up to a limit. Only callable by COO\n    /// @param _genes the encoded genes of the kitten to be created, any value is accepted\n    /// @param _owner the future owner of the created kittens. Default to contract COO\n    function _0x1524cb(uint256[2] _0x5b953b, uint256 _0x527278, address _0xa1f990) external _0x6c655d {\n        address _0xcfa38d = _0xa1f990;\n        if (_0xcfa38d == address(0)) {\n            _0xcfa38d = _0xf36c1e;\n        }\n\n        _0x65ca7b(0, 0, _0x527278, _0x5b953b, _0xcfa38d);\n    }\n\n    /// @dev create pandaWithGenes\n    /// @param _genes panda genes\n    /// @param _type  0 common 1 rare\n    function _0xa3b2ee(uint256[2] _0x5b953b,uint256 _0x527278,uint256 _0x6c813d)\n        external\n        payable\n        _0x6c655d\n        _0xd08088\n    {\n        require(msg.value >= OPEN_PACKAGE_PRICE);\n        uint256 _0xc6d621 = _0x65ca7b(0, 0, _0x527278, _0x5b953b, _0x09557d);\n        _0x09557d._0xa3b2ee(_0xc6d621,_0x6c813d);\n    }\n\n    //function buyPandaERC20(address _erc20Address, address _buyerAddress, uint256 _pandaID, uint256 _amount)\n    //external\n    //onlyCOO\n    //whenNotPaused {\n    //    saleAuctionERC20.bid(_erc20Address, _buyerAddress, _pandaID, _amount);\n    //}\n\n    /// @dev Creates a new gen0 panda with the given genes and\n    ///  creates an auction for it.\n    //function createGen0Auction(uint256[2] _genes) external onlyCOO {\n    //    require(gen0CreatedCount < GEN0_CREATION_LIMIT);\n    //\n    //    uint256 pandaId = _createPanda(0, 0, 0, _genes, address(this));\n    //    _approve(pandaId, saleAuction);\n    //\n    //    saleAuction.createAuction(\n    //        pandaId,\n    //        _computeNextGen0Price(),\n    //        0,\n    //        GEN0_AUCTION_DURATION,\n    //        address(this)\n    //    );\n    //\n    //    gen0CreatedCount++;\n    //}\n\n    function _0x32f6c5(uint256 _0xea2db4) external _0x6c655d {\n        require(_0x4b1122(msg.sender, _0xea2db4));\n        //require(pandas[_pandaId].generation==1);\n\n        _0xa63ae3(_0xea2db4, _0x09557d);\n\n        _0x09557d._0x32f6c5(\n            _0xea2db4,\n            _0x8599da(),\n            0,\n            GEN0_AUCTION_DURATION,\n            msg.sender\n        );\n    }\n\n    /// @dev Computes the next gen0 auction starting price, given\n    ///  the average of the past 5 prices + 50%.\n    function _0x8599da() internal view returns(uint256) {\n        uint256 _0xec909d = _0x09557d._0x6443ca();\n\n        require(_0xec909d == uint256(uint128(_0xec909d)));\n\n        uint256 _0xb3f6ea = _0xec909d + (_0xec909d / 2);\n\n        // We never auction for less than starting price\n        if (_0xb3f6ea < GEN0_STARTING_PRICE) {\n            _0xb3f6ea = GEN0_STARTING_PRICE;\n        }\n\n        return _0xb3f6ea;\n    }\n}\n\n/// @title CryptoPandas: Collectible, breedable, and oh-so-adorable cats on the Ethereum blockchain.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev The main CryptoPandas contract, keeps track of kittens so they don't wander around and get lost.\ncontract PandaCore is PandaMinting {\n\n    // This is the main CryptoPandas contract. In order to keep our code seperated into logical sections,\n    // we've broken it up in two ways. First, we have several seperately-instantiated sibling contracts\n    // that handle auctions and our super-top-secret genetic combination algorithm. The auctions are\n    // seperate since their logic is somewhat complex and there's always a risk of subtle bugs. By keeping\n    // them in their own contracts, we can upgrade them without disrupting the main contract that tracks\n    // panda ownership. The genetic combination algorithm is kept seperate so we can open-source all of\n    // the rest of our code without making it _too_ easy for folks to figure out how the genetics work.\n    // Don't worry, I'm sure someone will reverse engineer it soon enough!\n    //\n    // Secondly, we break the core contract into multiple files using inheritence, one for each major\n    // facet of functionality of CK. This allows us to keep related code bundled together while still\n    // avoiding a single giant file with everything in it. The breakdown is as follows:\n    //\n    //      - PandaBase: This is where we define the most fundamental code shared throughout the core\n    //             functionality. This includes our main data storage, constants and data types, plus\n    //             internal functions for managing these items.\n    //\n    //      - PandaAccessControl: This contract manages the various addresses and constraints for operations\n    //             that can be executed only by specific roles. Namely CEO, CFO and COO.\n    //\n    //      - PandaOwnership: This provides the methods required for basic non-fungible token\n    //             transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).\n    //\n    //      - PandaBreeding: This file contains the methods necessary to breed cats together, including\n    //             keeping track of siring offers, and relies on an external genetic combination contract.\n    //\n    //      - PandaAuctions: Here we have the public methods for auctioning or bidding on cats or siring\n    //             services. The actual auction functionality is handled in two sibling contracts (one\n    //             for sales and one for siring), while auction creation and bidding is mostly mediated\n    //             through this facet of the core contract.\n    //\n    //      - PandaMinting: This final facet contains the functionality we use for creating new gen0 cats.\n    //             the community is new), and all others can only be created and then immediately put up\n    //             for auction via an algorithmically determined starting price. Regardless of how they\n    //             are created, there is a hard limit of 50k gen0 cats. After that, it's all up to the\n    //             community to breed, breed, breed!\n\n    // Set in case the core contract is broken and an upgrade is required\n    address public _0x54bfc7;\n\n    /// @notice Creates the main CryptoPandas smart contract instance.\n    function PandaCore() public {\n        // Starts paused.\n        _0x4fadec = true;\n\n        // the creator of the contract is the initial CEO\n        _0x4d531c = msg.sender;\n\n        // the creator of the contract is also the initial COO\n        _0xf36c1e = msg.sender;\n\n        // move these code to init(), so we not excceed gas limit\n        //uint256[2] memory _genes = [uint256(-1),uint256(-1)];\n\n        //wizzPandaQuota[1] = 100;\n\n        //_createPanda(0, 0, 0, _genes, address(0));\n    }\n\n    /// init contract\n    function _0xcafe55() external _0x0057d3 _0xea5b37 {\n        // make sure init() only run once\n        require(_0xccbc26.length == 0);\n        // start with the mythical kitten 0 - so we don't have generation-0 parent issues\n        uint256[2] memory _0x5b953b = [uint256(-1),uint256(-1)];\n\n        _0x7c3e5b[1] = 100;\n       _0x65ca7b(0, 0, 0, _0x5b953b, address(0));\n    }\n\n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n\n    ///  emit a message indicating that the new address is set. It's up to clients of this\n    ///  contract to update to the new contract address in that case. (This contract will\n    ///  be paused indefinitely if such an upgrade takes place.)\n    /// @param _v2Address new address\n    function _0xe41800(address _0x492f3f) external _0x0057d3 _0xea5b37 {\n        // See README.md for updgrade plan\n        _0x54bfc7 = _0x492f3f;\n        ContractUpgrade(_0x492f3f);\n    }\n\n    /// @notice No tipping!\n    /// @dev Reject all Ether from being sent here, unless it's from one of the\n    ///  two auction contracts. (Hopefully, we can prevent user accidents.)\n    function() external payable {\n        require(\n            msg.sender == address(_0x09557d) ||\n            msg.sender == address(_0x286f88)\n        );\n    }\n\n    /// @notice Returns all the relevant information about a specific panda.\n    /// @param _id The ID of the panda of interest.\n    function _0x94e412(uint256 _0x6ddf15)\n        external\n        view\n        returns (\n        bool _0xf3aa16,\n        bool _0x951518,\n        uint256 _0x990f40,\n        uint256 _0xed65d1,\n        uint256 _0x9c00e1,\n        uint256 _0x9a305c,\n        uint256 _0x1cc8d3,\n        uint256 _0xe9c19a,\n        uint256 _0x121419,\n        uint256[2] _0x2e8019\n    ) {\n        Panda storage _0x88a094 = _0xccbc26[_0x6ddf15];\n\n        // if this variable is 0 then it's not gestating\n        _0xf3aa16 = (_0x88a094._0x9c00e1 != 0);\n        _0x951518 = (_0x88a094._0xf8b55f <= block.number);\n        _0x990f40 = uint256(_0x88a094._0x990f40);\n        _0xed65d1 = uint256(_0x88a094._0xf8b55f);\n        _0x9c00e1 = uint256(_0x88a094._0x9c00e1);\n        _0x9a305c = uint256(_0x88a094._0x9a305c);\n        _0x1cc8d3 = uint256(_0x88a094._0x1cc8d3);\n        _0xe9c19a = uint256(_0x88a094._0xe9c19a);\n        _0x121419 = uint256(_0x88a094._0x121419);\n        _0x2e8019 = _0x88a094._0x2e8019;\n    }\n\n    /// @dev Override unpause so it requires all external contract addresses\n    ///  to be set before contract can be unpaused. Also, we can't have\n    ///  newContractAddress set either, because then the contract was upgraded.\n    /// @notice This is public rather than external so we can call super.unpause\n    ///  without using an expensive CALL.\n    function _0x29c399() public _0x0057d3 _0xea5b37 {\n        require(_0x09557d != address(0));\n        require(_0x286f88 != address(0));\n        require(_0xfb86db != address(0));\n        require(_0x54bfc7 == address(0));\n\n        // Actually unpause the contract.\n        super._0x29c399();\n    }\n\n    // @dev Allows the CFO to capture the balance available to the contract.\n    function _0xe9244c() external _0xf9975c {\n        uint256 balance = this.balance;\n        // Subtract all the currently pregnant kittens we have, plus 1 of margin.\n        uint256 _0xaa3003 = (_0xada84f + 1) * _0x331967;\n\n        if (balance > _0xaa3003) {\n            _0x52de96.send(balance - _0xaa3003);\n        }\n    }\n}\n",
      "rename_map": {
        "setSaleAuctionERC20Address": "_0x976607",
        "switchSaleAuctionERC20For": "_0x421643",
        "_canBreedWithViaAuction": "_0x21c919",
        "withdrawAuctionBalances": "_0x5e9172",
        "isSaleClockAuctionERC20": "_0x848770",
        "cancelAuctionWhenPaused": "_0xc5fc64",
        "setSiringAuctionAddress": "_0x44f254",
        "createSaleAuctionERC20": "_0xcc11d5",
        "erc20ContractsSwitcher": "_0xe649b0",
        "setSaleAuctionAddress": "_0x4213e9",
        "_computeNextGen0Price": "_0x8599da",
        "_exchangeMatronSireId": "_0x05c032",
        "setGeneScienceAddress": "_0x0dd545",
        "tokenIdToErc20Address": "_0xe57b35",
        "withdrawERC20Balance": "_0x800540",
        "isSiringClockAuction": "_0x8042c1",
        "pandaIndexToApproved": "_0x60477d",
        "averageGen0SalePrice": "_0x6443ca",
        "sireAllowedToAddress": "_0x39db11",
        "_computeCurrentPrice": "_0x08b972",
        "getWizzPandaQuotaOf": "_0x97f917",
        "erc20ContractSwitch": "_0x4e37eb",
        "_isReadyToGiveBirth": "_0x7b96fa",
        "createSiringAuction": "_0x99abcc",
        "ownershipTokenCount": "_0x5f4b33",
        "getWizzPandaCountOf": "_0xc4daf7",
        "setTotalWizzPandaOf": "_0x3c0c81",
        "nonFungibleContract": "_0x8fe97c",
        "_isValidMatingPair": "_0x75f075",
        "currentPriceChange": "_0xe57619",
        "setSecondsPerBlock": "_0x9948fa",
        "newContractAddress": "_0x54bfc7",
        "lastGen0SalePrices": "_0x8da879",
        "isSaleClockAuction": "_0xf35dbf",
        "_isSiringPermitted": "_0xb4d690",
        "bidOnSiringAuction": "_0x8aa274",
        "createSaleAuction": "_0xe7f71b",
        "createGen0Auction": "_0x32f6c5",
        "supportsInterface": "_0xc3fbe0",
        "candidateContract": "_0x4ccd8f",
        "transferOwnership": "_0xe2b947",
        "pandaIndexToOwner": "_0x1489f4",
        "gen0CreatedCount": "_0xc031eb",
        "totalPriceChange": "_0xe4d803",
        "saleAuctionERC20": "_0x74715e",
        "_triggerCooldown": "_0xb06e32",
        "cooldownEndBlock": "_0xf8b55f",
        "_addAuctionERC20": "_0xd16c6a",
        "tokenIdToAuction": "_0xb96fb1",
        "withdrawBalance": "_0xe9244c",
        "createWizzPanda": "_0x1524cb",
        "setAutoBirthFee": "_0x4f156b",
        "getCurrentPrice": "_0x0270f4",
        "secondsPerBlock": "_0x48a966",
        "_isReadyToBreed": "_0x947dff",
        "getPureFromGene": "_0x30469b",
        "_removeAuction": "_0x850d63",
        "isReadyToBreed": "_0x666fed",
        "sellerProceeds": "_0x303dd3",
        "wizzPandaCount": "_0xa981b7",
        "wizzPandaQuota": "_0x7c3e5b",
        "_secondsPassed": "_0x98b1fb",
        "_startingPrice": "_0xabaf22",
        "_cancelAuction": "_0xe9165e",
        "pregnantPandas": "_0xada84f",
        "_currentPrice": "_0x2793c4",
        "_erc20address": "_0x7d3779",
        "tokensOfOwner": "_0x08d2f4",
        "surprisePanda": "_0xd11bc8",
        "cooldownIndex": "_0x990f40",
        "_buyerAddress": "_0x9d7ce8",
        "_erc20Address": "_0xbc65ac",
        "erc20Contract": "_0xf2de6f",
        "isGeneScience": "_0x63d297",
        "approveSiring": "_0xd1072c",
        "cancelAuction": "_0x23d753",
        "clearWizzType": "_0xd2430b",
        "siringAuction": "_0x286f88",
        "breedWithAuto": "_0x6ca36f",
        "auctioneerCut": "_0xe6a0ee",
        "setNewAddress": "_0xe41800",
        "startingPrice": "_0x5807e4",
        "getWizzTypeOf": "_0x2369a6",
        "gen0SaleCount": "_0xfad7df",
        "whenNotPaused": "_0xd08088",
        "_stringLength": "_0x60e71c",
        "secondsPassed": "_0x37403d",
        "createAuction": "_0x717db7",
        "subtractFees": "_0xaa3003",
        "outputString": "_0x719cb5",
        "autoBirthFee": "_0x331967",
        "nextActionAt": "_0xed65d1",
        "_createPanda": "_0x65ca7b",
        "currentPrice": "_0xdcc091",
        "_interfaceID": "_0x3bf5b5",
        "siringWithId": "_0x9c00e1",
        "transferFrom": "_0xfabc8e",
        "canBreedWith": "_0x6bf1ad",
        "_isOnAuction": "_0x625a36",
        "_endingPrice": "_0x0713a2",
        "_approvedFor": "_0x877213",
        "packageCount": "_0xf9d215",
        "_childGenes": "_0x1fe607",
        "newKittenId": "_0x4f8623",
        "isGestating": "_0xf3aa16",
        "geneScience": "_0xfb86db",
        "getMetadata": "_0x1d6fe3",
        "resultIndex": "_0xe929a1",
        "endingPrice": "_0xd31b85",
        "ownerTokens": "_0x6e0bbc",
        "newContract": "_0xbef38a",
        "matronOwner": "_0x6195d4",
        "_nftAddress": "_0x178fd7",
        "saleAuction": "_0x09557d",
        "totalSupply": "_0x12565b",
        "createPanda": "_0xa3b2ee",
        "targetBlock": "_0xc2202a",
        "_addAuction": "_0x23df7e",
        "_generation": "_0x527278",
        "_computeCut": "_0x9db62b",
        "probability": "_0xa832c4",
        "getWizzType": "_0x10f542",
        "childOwner": "_0x9e1bbe",
        "isPregnant": "_0x7d2fb6",
        "totalPrice": "_0x68fc79",
        "nftAddress": "_0xff8058",
        "childGenes": "_0x9f2392",
        "cfoAddress": "_0x52de96",
        "pureDegree": "_0x8764c1",
        "_allowance": "_0x16fff4",
        "_v2Address": "_0x492f3f",
        "tokenCount": "_0x9bc79c",
        "ceoAddress": "_0x4d531c",
        "_bidAmount": "_0x5c2f09",
        "onlyCLevel": "_0x57543d",
        "getAuction": "_0xa02f1d",
        "generation": "_0x121419",
        "cooAddress": "_0xf36c1e",
        "pandaOwner": "_0xcfa38d",
        "_breedWith": "_0x248711",
        "whenPaused": "_0xea5b37",
        "birthTime": "_0x9a305c",
        "bidExcess": "_0xc20f78",
        "_duration": "_0x738e66",
        "totalCats": "_0x59751c",
        "_receiver": "_0xbb38a5",
        "_transfer": "_0x54f595",
        "_rawBytes": "_0xaec75e",
        "keccak256": "_0xf96263",
        "sireOwner": "_0x10b52b",
        "onlyOwner": "_0x41354a",
        "_matronId": "_0x159240",
        "_toString": "_0xe7b1f9",
        "startedAt": "_0x64601a",
        "_claimant": "_0xd71144",
        "outputPtr": "_0x4da290",
        "_bidERC20": "_0xf1c7e2",
        "cooldowns": "_0x56d799",
        "_approved": "_0xb0e841",
        "balanceOf": "_0x405e22",
        "giveBirth": "_0xc70cea",
        "allowance": "_0x74e3d0",
        "parentGen": "_0xe7632f",
        "nextPrice": "_0xb3f6ea",
        "ownerCut": "_0xd3261f",
        "duration": "_0xd2874f",
        "avePrice": "_0xec909d",
        "balances": "_0x423c03",
        "_nftAddr": "_0x045b6f",
        "_approve": "_0xa63ae3",
        "matronId": "_0x1cc8d3",
        "surprise": "_0x9a710c",
        "_address": "_0x528740",
        "_auction": "_0x1ed53c",
        "_factors": "_0x5cb52e",
        "mixGenes": "_0xf5394f",
        "_tokenId": "_0x2a0fb7",
        "kittenId": "_0xc6d621",
        "getPanda": "_0x94e412",
        "bytesPtr": "_0x20c478",
        "newOwner": "_0x28b1eb",
        "bidERC20": "_0xc0a153",
        "destpart": "_0xc3f4b5",
        "_pandaId": "_0xea2db4",
        "approved": "_0x111e70",
        "_sireId": "_0xa47ccb",
        "srcpart": "_0x16aa68",
        "_amount": "_0x9f9fe9",
        "_seller": "_0xa5d202",
        "ownerOf": "_0x6aa502",
        "onlyCEO": "_0x0057d3",
        "spender": "_0x78b30a",
        "_matron": "_0x681327",
        "_memcpy": "_0x28465f",
        "onlyCFO": "_0xf9975c",
        "unpause": "_0x29c399",
        "onlyCOO": "_0x6c655d",
        "auction": "_0x48f123",
        "pandaId": "_0xe7bc09",
        "_newCEO": "_0x4a7db6",
        "_newCOO": "_0x816e1f",
        "_escrow": "_0xe5ccba",
        "approve": "_0x6001c8",
        "_newCFO": "_0xb64cf6",
        "_kitten": "_0xaafd3c",
        "tokenId": "_0x943848",
        "isReady": "_0x951518",
        "common": "_0xee5283",
        "sireId": "_0xe9c19a",
        "genes2": "_0xfb6662",
        "_total": "_0x97d39e",
        "supply": "_0x967fa0",
        "_genes": "_0x5b953b",
        "_price": "_0x88da80",
        "pandas": "_0xccbc26",
        "setCEO": "_0xacac04",
        "_onoff": "_0xe4f6e7",
        "genes1": "_0xd2038f",
        "setCFO": "_0x02048a",
        "_owner": "_0xa1f990",
        "setCOO": "_0xe09479",
        "getSex": "_0xa34681",
        "_panda": "_0xbc844b",
        "paused": "_0x4fadec",
        "buffer": "_0xd8ee50",
        "symbol": "_0x5dab3b",
        "winner": "_0x58f25a",
        "result": "_0x614e89",
        "seller": "_0x90f826",
        "isGen0": "_0xec42d1",
        "matron": "_0xe3dcec",
        "count": "_0x46e9e7",
        "price": "_0x6865b3",
        "_from": "_0xdf6bc8",
        "_addr": "_0xc9c990",
        "_gene": "_0x2af24c",
        "_sire": "_0x3f35b4",
        "total": "_0xffa95f",
        "genes": "_0x2e8019",
        "_owns": "_0x4b1122",
        "_dest": "_0xbce0c8",
        "pause": "_0xf06dd1",
        "_type": "_0x6c813d",
        "owner": "_0x8220f4",
        "bHash": "_0x2614ec",
        "catId": "_0xc26877",
        "mask": "_0x48e956",
        "_bid": "_0xe84084",
        "secs": "_0xeb6bf9",
        "sire": "_0xa9d265",
        "gene": "_0x9d825e",
        "_cut": "_0x8bc9ec",
        "init": "_0xcafe55",
        "_src": "_0x8efd19",
        "name": "_0x87b646",
        "_kit": "_0xa77a49",
        "_len": "_0xe7132d",
        "_id": "_0x6ddf15",
        "res": "_0xa1b3cb",
        "bid": "_0xfa3b41",
        "_to": "_0x546d79",
        "now": "_0x9e380d",
        "kit": "_0x88a094",
        "who": "_0x780122",
        "_tp": "_0x0db4cf",
        "sum": "_0xdce758",
        "val": "_0x457d97",
        "to": "_0xa2fa22",
        "ok": "_0xe53bea",
        "_p": "_0x7d97e5",
        "g1": "_0xaa95b9",
        "g2": "_0xa70d7d"
      },
      "changes": [
        "Renamed 272 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_215",
      "transformed_id": "ss_l2_hex_sn_ds_215",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier _0x841bfb()\n    {\n        require(msg.sender == _0xeec1e2);\n        _;\n    }\n\n   modifier _0xfc6c91()\n    {\n        require(_0xf69d37);\n        _;\n    }\n\n    modifier _0xa55b55()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  _0x39333c()\n    {\n        require (_0x4bd65d[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 _0xac0447, address _0xdd3547);\n    event Win(uint256 _0xac0447, address _0x51fd69);\n    event Lose(uint256 _0xac0447, address _0x581032);\n    event Donate(uint256 _0xac0447, address _0x51fd69, address _0xcb6aea);\n    event DifficultyChanged(uint256 _0x9bbb84);\n    event BetLimitChanged(uint256 _0xe78a74);\n\n    address private _0x88f32e;\n    uint256 _0x0f2368;\n    uint difficulty;\n    uint private _0xa6a11d;\n    address _0xeec1e2;\n    mapping(address => uint256) _0x78bda5;\n    mapping(address => uint256) _0x4bd65d;\n    bool _0xf69d37;\n    uint256 _0x08b48f;\n\n    constructor(address _0x66926f, uint256 _0xf2b72b)\n    _0xa55b55()\n    public\n    {\n        _0xf69d37 = false;\n        _0xeec1e2 = msg.sender;\n        _0x88f32e = _0x66926f;\n        _0x08b48f = 0;\n        _0x0f2368 = _0xf2b72b;\n\n    }\n\n    function OpenToThePublic()\n    _0x841bfb()\n    public\n    {\n        _0xf69d37 = true;\n    }\n\n    function AdjustBetAmounts(uint256 _0xac0447)\n    _0x841bfb()\n    public\n    {\n        _0x0f2368 = _0xac0447;\n\n        emit BetLimitChanged(_0x0f2368);\n    }\n\n    function AdjustDifficulty(uint256 _0xac0447)\n    _0x841bfb()\n    public\n    {\n        difficulty = _0xac0447;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function _0x812fee()\n    _0xfc6c91()\n    _0xa55b55()\n    payable\n    public\n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == _0x0f2368);\n\n        //log the wager and timestamp(block number)\n        _0x78bda5[msg.sender] = block.number;\n        _0x4bd65d[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function _0xeaa8ae()\n    _0xfc6c91()\n    _0xa55b55()\n    _0x39333c()\n    public\n    {\n        uint256 _0x560572 = _0x78bda5[msg.sender];\n        if(_0x560572 < block.number)\n        {\n            _0x78bda5[msg.sender] = 0;\n            _0x4bd65d[msg.sender] = 0;\n\n            uint256 _0x53b403 = uint256(_0xbaa472(abi._0x6e6a7d(blockhash(_0x560572),  msg.sender)))%difficulty +1;\n\n            if(_0x53b403 == difficulty / 2)\n            {\n                _0xca9146(msg.sender);\n            }\n            else\n            {\n                //player loses\n                _0x201017(_0x0f2368 / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function _0x9fd609()\n    _0xfc6c91()\n    public\n    payable\n    {\n        _0xd0eb0f(msg.value);\n    }\n\n    function _0xca9146(address _0xe69c2c)\n    internal\n    {\n        uint256 _0x44d26b = address(this).balance / 2;\n\n        _0xe69c2c.transfer(_0x44d26b);\n        emit Win(_0x44d26b, _0xe69c2c);\n    }\n\n    function _0xd0eb0f(uint256 _0xac0447)\n    internal\n    {\n        _0x88f32e.call.value(_0xac0447)(bytes4(_0xbaa472(\"donate()\")));\n        _0x08b48f += _0xac0447;\n        emit Donate(_0xac0447, _0x88f32e, msg.sender);\n    }\n\n    function _0x201017(uint256 _0xac0447)\n    internal\n    {\n        _0x88f32e.call.value(_0xac0447)(bytes4(_0xbaa472(\"donate()\")));\n        _0x08b48f += _0xac0447;\n        emit Lose(_0xac0447, msg.sender);\n    }\n\n    function _0x48cfc9()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function _0x9bbb84()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function _0xe78a74()\n    public\n    view\n    returns (uint256)\n    {\n        return _0x0f2368;\n    }\n\n    function _0xc2ae77(address _0x2adad6)\n    public\n    view\n    returns (bool)\n    {\n        if(_0x4bd65d[_0x2adad6] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function _0x49e9a7()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function _0x9c7a5c(address _0x8b51a1, address _0xe624df, uint _0xd1a5cb)\n    public\n    _0x841bfb()\n    returns (bool _0x2d6816)\n    {\n        return ERC20Interface(_0x8b51a1).transfer(_0xe624df, _0xd1a5cb);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface\n{\n    function transfer(address _0x520ba6, uint256 _0xd1a5cb) public returns (bool _0x2d6816);\n}",
      "rename_map": {
        "transferAnyERC20Token": "_0x9c7a5c",
        "currentDifficulty": "_0x9bbb84",
        "hasPlayerWagered": "_0xc2ae77",
        "currentBetLimit": "_0xe78a74",
        "isOpenToPublic": "_0xfc6c91",
        "onlyRealPeople": "_0xa55b55",
        "winningNumber": "_0x53b403",
        "donateToWhale": "_0xd0eb0f",
        "ethToTransfer": "_0x44d26b",
        "encodePacked": "_0x6e6a7d",
        "whaleAddress": "_0x66926f",
        "tokenAddress": "_0x8b51a1",
        "openToPublic": "_0xf69d37",
        "totalDonated": "_0x08b48f",
        "onlyPlayers": "_0x39333c",
        "blockNumber": "_0x560572",
        "timestamps": "_0x78bda5",
        "wagerLimit": "_0xf2b72b",
        "tokenOwner": "_0xe624df",
        "winnersPot": "_0x49e9a7",
        "ethBalance": "_0x48cfc9",
        "randomSeed": "_0xa6a11d",
        "depositer": "_0xdd3547",
        "loseWager": "_0x201017",
        "keccak256": "_0xbaa472",
        "onlyOwner": "_0x841bfb",
        "betLimit": "_0x0f2368",
        "success": "_0x2d6816",
        "donator": "_0xcb6aea",
        "wagers": "_0x4bd65d",
        "donate": "_0x9fd609",
        "winner": "_0xe69c2c",
        "player": "_0x2adad6",
        "tokens": "_0xd1a5cb",
        "payout": "_0xca9146",
        "paidTo": "_0x51fd69",
        "amount": "_0xac0447",
        "owner": "_0xeec1e2",
        "whale": "_0x88f32e",
        "loser": "_0x581032",
        "wager": "_0x812fee",
        "play": "_0xeaa8ae",
        "to": "_0x520ba6"
      },
      "changes": [
        "Renamed 43 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_216",
      "transformed_id": "ss_l2_hex_sn_ds_216",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract FiftyFlip {\n    uint constant DONATING_X = 20; // 2% kujira\n\n    // Need to be discussed\n    uint constant JACKPOT_FEE = 10; // 1% jackpot\n    uint constant JACKPOT_MODULO = 1000; // 0.1% jackpotwin\n    uint constant DEV_FEE = 20; // 2% devfee\n    uint constant WIN_X = 1900; // 1.9x\n\n    // There is minimum and maximum bets.\n    uint constant MIN_BET = 0.01 ether;\n    uint constant MAX_BET = 1 ether;\n\n    uint constant BET_EXPIRATION_BLOCKS = 250;\n\n    // owner and PoC contract address\n    address public _0x1681ce;\n    address public _0xcc9735;\n    address public _0x5ca585;\n    address private _0xab5b7c;\n\n    // Accumulated jackpot fund.\n    uint256 public _0xd27f28;\n    uint256 public _0x54a174;\n\n    // Funds that are locked in potentially winning bets.\n    uint256 public _0x6a1002;\n    uint256 public _0x4fe8a6;\n\n    struct Bet {\n        // Wager amount in wei.\n        uint _0x03b6d3;\n        // Block number of placeBet tx.\n        uint256 _0x0d4a20;\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\n        bool _0x14392d;\n        // Address of a player, used to pay out winning bets.\n        address _0x28b097;\n    }\n\n    mapping (uint => Bet) _0x6fc2ea;\n    mapping (address => uint) _0x37c1e2;\n\n    // events\n    event Wager(uint _0x6ea68f, uint _0x32f7c8, uint256 _0x825179, bool _0x14392d, address _0x477b52);\n    event Win(address _0x5b053a, uint _0x03b6d3, uint _0x6ea68f, bool _0x0f62a3, uint _0x1d99cb);\n    event Lose(address _0x6fb66b, uint _0x03b6d3, uint _0x6ea68f, bool _0x0f62a3, uint _0x1d99cb);\n    event Refund(uint _0x6ea68f, uint256 _0x03b6d3, address _0xf55888);\n    event Donate(uint256 _0x03b6d3, address _0xba4c8e);\n    event FailedPayment(address _0x20b9fa, uint _0x03b6d3);\n    event Payment(address _0xa85b96, uint _0x03b6d3);\n    event JackpotPayment(address _0x28b097, uint _0x6ea68f, uint _0x6076d1);\n\n    // constructor\n    constructor (address _0xb8c6b2, address _0x0157bc, address _0x16d197) public {\n        _0x1681ce = msg.sender;\n        _0xcc9735 = _0x0157bc;\n        _0xab5b7c = _0xb8c6b2;\n        _0x5ca585 = _0x16d197;\n        _0xd27f28 = 0;\n        _0x54a174 = 0;\n        _0x6a1002 = 0;\n        _0x4fe8a6 = 0;\n    }\n\n    // modifiers\n    modifier _0x2861b2() {\n        require (msg.sender == _0x1681ce, \"You are not the owner of this contract!\");\n        _;\n    }\n\n    modifier _0x766947() {\n        require (msg.sender == _0xcc9735, \"You are not the bot of this contract!\");\n        _;\n    }\n\n    modifier _0x1ac712() {\n        require (address(this).balance >= _0x6a1002 + _0xd27f28 + _0x54a174, \"This contract doesn't have enough balance, it is stopped till someone donate to this game!\");\n        _;\n    }\n\n    // betMast:\n    // false is front, true is back\n\n    function() public payable { }\n\n    function _0x0bdd14(address _0x0157bc)\n    _0x2861b2()\n    external\n    {\n        _0xcc9735 = _0x0157bc;\n    }\n\n    function _0x05df06(address _0x0f732e)\n    _0x2861b2()\n    external\n    {\n        _0x5ca585 = _0x0f732e;\n    }\n\n    // wager function\n    function _0xf6bec4(bool _0xdd4619, uint _0x6ea68f, uint _0xe39bb0, uint8 v, bytes32 r, bytes32 s)\n    _0x1ac712()\n    external\n    payable {\n        Bet storage _0x4aa599 = _0x6fc2ea[_0x6ea68f];\n        uint _0x03b6d3 = msg.value;\n        address _0x28b097 = msg.sender;\n        require (_0x4aa599._0x28b097 == address(0), \"Ticket is not new one!\");\n        require (_0x03b6d3 >= MIN_BET, \"Your bet is lower than minimum bet amount\");\n        require (_0x03b6d3 <= MAX_BET, \"Your bet is higher than maximum bet amount\");\n        require (_0x55fe50() >= 2 * _0x03b6d3, \"If we accept this, this contract will be in danger!\");\n\n        require (block.number <= _0xe39bb0, \"Ticket has expired.\");\n        bytes32 _0x96717b = _0x0a47c8(abi._0xebf030('\\x19Ethereum Signed Message:\\n37', uint40(_0xe39bb0), _0x6ea68f));\n        require (_0x5ca585 == _0xef3100(_0x96717b, v, r, s), \"web3 vrs signature is not valid.\");\n\n        _0xd27f28 += _0x03b6d3 * JACKPOT_FEE / 1000;\n        _0x54a174 += _0x03b6d3 * DEV_FEE / 1000;\n        _0x6a1002 += _0x03b6d3 * WIN_X / 1000;\n\n        uint _0x0bc80a = _0x03b6d3 * DONATING_X / 1000;\n        _0xab5b7c.call.value(_0x0bc80a)(bytes4(_0x0a47c8(\"donate()\")));\n        _0x4fe8a6 += _0x0bc80a;\n\n        _0x4aa599._0x03b6d3 = _0x03b6d3;\n        _0x4aa599._0x0d4a20 = block.number;\n        _0x4aa599._0x14392d = _0xdd4619;\n        _0x4aa599._0x28b097 = _0x28b097;\n\n        emit Wager(_0x6ea68f, _0x4aa599._0x03b6d3, _0x4aa599._0x0d4a20, _0x4aa599._0x14392d, _0x4aa599._0x28b097);\n    }\n\n    // method to determine winners and losers\n    function _0x1b7abe(uint _0x4b75b7)\n    _0x1ac712()\n    external\n    {\n        uint _0x6ea68f = uint(_0x0a47c8(abi._0xebf030(_0x4b75b7)));\n        Bet storage _0x4aa599 = _0x6fc2ea[_0x6ea68f];\n        require (_0x4aa599._0x28b097 != address(0), \"TicketID is not correct!\");\n        require (_0x4aa599._0x03b6d3 != 0, \"Ticket is already used one!\");\n        uint256 _0x0d4a20 = _0x4aa599._0x0d4a20;\n        if(_0x0d4a20 < block.number && _0x0d4a20 >= block.number - BET_EXPIRATION_BLOCKS)\n        {\n            uint256 _0xfa7dfe = uint256(_0x0a47c8(abi._0xebf030(blockhash(_0x0d4a20),  _0x4b75b7)));\n            bool _0x0f62a3 = (_0xfa7dfe % 2) !=0;\n            uint _0x1d99cb = _0xfa7dfe % JACKPOT_MODULO;\n\n            uint _0x056721 = _0x4aa599._0x03b6d3 * WIN_X / 1000;\n\n            uint _0x110f7b = 0;\n            uint _0x6076d1 = 0;\n\n            if(_0x4aa599._0x14392d == _0x0f62a3) {\n                _0x110f7b = _0x056721;\n            }\n            if(_0x1d99cb == 0) {\n                _0x6076d1 = _0xd27f28;\n                _0xd27f28 = 0;\n            }\n            if (_0x6076d1 > 0) {\n                emit JackpotPayment(_0x4aa599._0x28b097, _0x6ea68f, _0x6076d1);\n            }\n            if(_0x110f7b + _0x6076d1 > 0)\n            {\n                _0xb45ba9(_0x4aa599._0x28b097, _0x110f7b + _0x6076d1, _0x6ea68f, _0x0f62a3, _0x1d99cb);\n            }\n            else\n            {\n                _0x27bcbb(_0x4aa599._0x28b097, _0x4aa599._0x03b6d3, _0x6ea68f, _0x0f62a3, _0x1d99cb);\n            }\n            _0x6a1002 -= _0x056721;\n            _0x4aa599._0x03b6d3 = 0;\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function _0x0c9840()\n    external\n    payable\n    {\n        _0x37c1e2[msg.sender] += msg.value;\n        emit Donate(msg.value, msg.sender);\n    }\n\n    function _0x77a7bd(uint _0x03b6d3)\n    external\n    {\n        require(_0x37c1e2[msg.sender] >= _0x03b6d3, \"You are going to withdraw more than you donated!\");\n\n        if (_0xd303df(msg.sender, _0x03b6d3)){\n            _0x37c1e2[msg.sender] -= _0x03b6d3;\n        }\n    }\n\n    // method to refund\n    function _0xb96cd9(uint _0x6ea68f)\n    _0x1ac712()\n    external {\n        Bet storage _0x4aa599 = _0x6fc2ea[_0x6ea68f];\n\n        require (_0x4aa599._0x03b6d3 != 0, \"this ticket has no balance\");\n        require (block.number > _0x4aa599._0x0d4a20 + BET_EXPIRATION_BLOCKS, \"this ticket is expired.\");\n        _0xfd3639(_0x6ea68f);\n    }\n\n    // Funds withdrawl\n    function _0x9cfd95(address _0xfe39a9, uint _0x37c733)\n    _0x2861b2()\n    _0x1ac712()\n    external {\n        require (_0x54a174 >= _0x37c733, \"You are trying to withdraw more amount than developer fee.\");\n        require (_0x37c733 <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (_0x54a174 <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (_0xd303df(_0xfe39a9, _0x37c733)){\n            _0x54a174 -= _0x37c733;\n        }\n    }\n\n    // Funds withdrawl\n    function _0x6c25e3(uint _0x37c733)\n    _0x766947()\n    _0x1ac712()\n    external {\n        require (_0x54a174 >= _0x37c733, \"You are trying to withdraw more amount than developer fee.\");\n        require (_0x37c733 <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (_0x54a174 <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (_0xd303df(_0xcc9735, _0x37c733)){\n            _0x54a174 -= _0x37c733;\n        }\n    }\n\n    // Get Bet Info from id\n    function _0xc7b25f(uint _0x6ea68f)\n    constant\n    external\n    returns (uint, uint256, bool, address){\n        Bet storage _0x4aa599 = _0x6fc2ea[_0x6ea68f];\n        return (_0x4aa599._0x03b6d3, _0x4aa599._0x0d4a20, _0x4aa599._0x14392d, _0x4aa599._0x28b097);\n    }\n\n    // Get Bet Info from id\n    function _0x6ea0d9()\n    constant\n    external\n    returns (uint){\n        return address(this).balance;\n    }\n\n    // Get Collateral for Bet\n    function _0x55fe50()\n    constant\n    public\n    returns (uint){\n        if (address(this).balance > _0x6a1002 + _0xd27f28 + _0x54a174)\n            return address(this).balance - _0x6a1002 - _0xd27f28 - _0x54a174;\n        return 0;\n    }\n\n    // Contract may be destroyed only when there are no ongoing bets,\n    // either settled or refunded. All funds are transferred to contract owner.\n    function _0xd7d53a() external _0x2861b2() {\n        require (_0x6a1002 == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n        selfdestruct(_0x1681ce);\n    }\n\n    // Payout ETH to winner\n    function _0xb45ba9(address _0x5b053a, uint _0x35b45e, uint _0x6ea68f, bool _0x0f62a3, uint _0x1d99cb)\n    internal\n    {\n        _0x5b053a.transfer(_0x35b45e);\n        emit Win(_0x5b053a, _0x35b45e, _0x6ea68f, _0x0f62a3, _0x1d99cb);\n    }\n\n    // sendRefund to requester\n    function _0xfd3639(uint _0x6ea68f)\n    internal\n    {\n        Bet storage _0x4aa599 = _0x6fc2ea[_0x6ea68f];\n        address _0xf55888 = _0x4aa599._0x28b097;\n        uint256 _0x35b45e = _0x4aa599._0x03b6d3;\n        _0xf55888.transfer(_0x35b45e);\n\n        uint _0x056721 = _0x4aa599._0x03b6d3 * WIN_X / 1000;\n        _0x6a1002 -= _0x056721;\n\n        _0x4aa599._0x03b6d3 = 0;\n        emit Refund(_0x6ea68f, _0x35b45e, _0xf55888);\n    }\n\n    // Helper routine to process the payment.\n    function _0xd303df(address _0x20b9fa, uint _0x03b6d3) private returns (bool){\n        bool _0x6be670 = _0x20b9fa.send(_0x03b6d3);\n        if (_0x6be670) {\n            emit Payment(_0x20b9fa, _0x03b6d3);\n        } else {\n            emit FailedPayment(_0x20b9fa, _0x03b6d3);\n        }\n        return _0x6be670;\n    }\n    // Payout ETH to whale when player loses\n    function _0x27bcbb(address _0x28b097, uint _0x03b6d3, uint _0x6ea68f, bool _0x0f62a3, uint _0x1d99cb)\n    internal\n    {\n        emit Lose(_0x28b097, _0x03b6d3, _0x6ea68f, _0x0f62a3, _0x1d99cb);\n    }\n\n    // bulk clean the storage.\n    function _0xa35d5a(uint[] _0xc4285c) external {\n        uint length = _0xc4285c.length;\n\n        for (uint i = 0; i < length; i++) {\n            _0x635791(_0xc4285c[i]);\n        }\n    }\n\n    // Helper routine to move 'processed' bets into 'clean' state.\n    function _0x635791(uint _0x6ea68f) private {\n        Bet storage _0x4aa599 = _0x6fc2ea[_0x6ea68f];\n\n        // Do not overwrite active bets with zeros; additionally prevent cleanup of bets\n        // for which ticketID signatures may have not expired yet (see whitepaper for details).\n        if (_0x4aa599._0x03b6d3 != 0 || block.number <= _0x4aa599._0x0d4a20 + BET_EXPIRATION_BLOCKS) {\n            return;\n        }\n\n        _0x4aa599._0x0d4a20 = 0;\n        _0x4aa599._0x14392d = false;\n        _0x4aa599._0x28b097 = address(0);\n    }\n\n    // A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n    function _0xf54cca(address _0x418aee, address _0x615db3, uint _0x283a62)\n    public\n    _0x2861b2()\n    returns (bool _0x6be670)\n    {\n        return ERC20Interface(_0x418aee).transfer(_0x615db3, _0x283a62);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface\n{\n    function transfer(address _0x2b12e9, uint256 _0x283a62) public returns (bool _0x6be670);\n}\n",
      "rename_map": {
        "donateForContractHealth": "_0x0c9840",
        "transferAnyERC20Token": "_0xf54cca",
        "getCollateralBalance": "_0x55fe50",
        "checkContractHealth": "_0x1ac712",
        "secretSignerAddress": "_0x16d197",
        "totalAmountToWhale": "_0x4fe8a6",
        "autoPlayBotAddress": "_0x0157bc",
        "getContractBalance": "_0x6ea0d9",
        "clearProcessedBet": "_0x635791",
        "withdrawDonation": "_0x77a7bd",
        "toCleanTicketIDs": "_0xc4285c",
        "withdrawAddress": "_0xfe39a9",
        "setSecretSigner": "_0x05df06",
        "ticketLastBlock": "_0xe39bb0",
        "withdrawBotFee": "_0x6c25e3",
        "betBlockNumber": "_0x825179",
        "withdrawAmount": "_0x37c733",
        "withdrawDevFee": "_0x9cfd95",
        "setBotAddress": "_0x0bdd14",
        "tossWinAmount": "_0x056721",
        "_secretSigner": "_0x0f732e",
        "donate_amount": "_0x0bc80a",
        "signatureHash": "_0x96717b",
        "ethToTransfer": "_0x35b45e",
        "clearStorage": "_0xa35d5a",
        "encodePacked": "_0xebf030",
        "whaleAddress": "_0xb8c6b2",
        "tokenAddress": "_0x418aee",
        "ticketReveal": "_0x4b75b7",
        "secretSigner": "_0x5ca585",
        "donateAmount": "_0x37c1e2",
        "lockedInBets": "_0x6a1002",
        "jackpotSize": "_0xd27f28",
        "autoPlayBot": "_0xcc9735",
        "blockNumber": "_0x0d4a20",
        "jackpotWin": "_0x6076d1",
        "tokenOwner": "_0x615db3",
        "jackpotRes": "_0x1d99cb",
        "devFeeSize": "_0x54a174",
        "sendRefund": "_0xfd3639",
        "noPaidUser": "_0xa85b96",
        "getBetInfo": "_0xc7b25f",
        "sendFunds": "_0xd303df",
        "loseWager": "_0x27bcbb",
        "betPlayer": "_0x477b52",
        "onlyOwner": "_0x2861b2",
        "betAmount": "_0x32f7c8",
        "keccak256": "_0x0a47c8",
        "ecrecover": "_0xef3100",
        "requester": "_0xf55888",
        "ticketID": "_0x6ea68f",
        "paidUser": "_0x20b9fa",
        "onlyBot": "_0x766947",
        "success": "_0x6be670",
        "betMask": "_0x14392d",
        "tossWin": "_0x110f7b",
        "maskRes": "_0x0f62a3",
        "donator": "_0xba4c8e",
        "winner": "_0x5b053a",
        "random": "_0xfa7dfe",
        "refund": "_0xb96cd9",
        "player": "_0x28b097",
        "tokens": "_0x283a62",
        "payout": "_0xb45ba9",
        "amount": "_0x03b6d3",
        "owner": "_0x1681ce",
        "whale": "_0xab5b7c",
        "loser": "_0x6fb66b",
        "wager": "_0xf6bec4",
        "bMask": "_0xdd4619",
        "bets": "_0x6fc2ea",
        "kill": "_0xd7d53a",
        "play": "_0x1b7abe",
        "bet": "_0x4aa599",
        "to": "_0x2b12e9"
      },
      "changes": [
        "Renamed 75 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_232",
      "transformed_id": "ss_l2_hex_sn_ds_232",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\nlibrary SafeMath {\n  function _0x0f0bfd(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n\n  function _0x7766a8(uint256 a, uint256 b) internal constant returns (uint256) {\n    // require(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function _0x2e9fd2(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function _0xf92e20(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint256 public _0x6f97b1;\n  function _0x2decf0(address _0x195ce8) public constant returns (uint256);\n  function transfer(address _0x298621, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed _0x298621, uint256 value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) _0xbd68d8;\n\n  function transfer(address _0x5388b8, uint256 _0xa1977b) public returns (bool) {\n    require(_0x5388b8 != address(0));\n    require(_0xa1977b > 0 && _0xa1977b <= _0xbd68d8[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    _0xbd68d8[msg.sender] = _0xbd68d8[msg.sender]._0x2e9fd2(_0xa1977b);\n    _0xbd68d8[_0x5388b8] = _0xbd68d8[_0x5388b8]._0xf92e20(_0xa1977b);\n    Transfer(msg.sender, _0x5388b8, _0xa1977b);\n    return true;\n  }\n\n  function _0x2decf0(address _0x2956b9) public constant returns (uint256 balance) {\n    return _0xbd68d8[_0x2956b9];\n  }\n}\n\ncontract ERC20 is ERC20Basic {\n  function _0xb0a56f(address _0x97b4d7, address _0x7579f4) public constant returns (uint256);\n  function _0x59f69c(address from, address _0x298621, uint256 value) public returns (bool);\n  function _0x165fa7(address _0x7579f4, uint256 value) public returns (bool);\n  event Approval(address indexed _0x97b4d7, address indexed _0x7579f4, uint256 value);\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal _0x9f5c68;\n\n  function _0x59f69c(address _0xa846d6, address _0x5388b8, uint256 _0xa1977b) public returns (bool) {\n    require(_0x5388b8 != address(0));\n    require(_0xa1977b > 0 && _0xa1977b <= _0xbd68d8[_0xa846d6]);\n    require(_0xa1977b <= _0x9f5c68[_0xa846d6][msg.sender]);\n\n    _0xbd68d8[_0xa846d6] = _0xbd68d8[_0xa846d6]._0x2e9fd2(_0xa1977b);\n    _0xbd68d8[_0x5388b8] = _0xbd68d8[_0x5388b8]._0xf92e20(_0xa1977b);\n    _0x9f5c68[_0xa846d6][msg.sender] = _0x9f5c68[_0xa846d6][msg.sender]._0x2e9fd2(_0xa1977b);\n    Transfer(_0xa846d6, _0x5388b8, _0xa1977b);\n    return true;\n  }\n\n  function _0x165fa7(address _0x32d799, uint256 _0xa1977b) public returns (bool) {\n    _0x9f5c68[msg.sender][_0x32d799] = _0xa1977b;\n    Approval(msg.sender, _0x32d799, _0xa1977b);\n    return true;\n  }\n\n  function _0xb0a56f(address _0x2956b9, address _0x32d799) public constant returns (uint256 _0x7b83fb) {\n    return _0x9f5c68[_0x2956b9][_0x32d799];\n  }\n}\n\ncontract Ownable {\n  address public _0x97b4d7;\n\n  event OwnershipTransferred(address indexed _0x602448, address indexed _0xc63ea1);\n\n  function Ownable() {\n    _0x97b4d7 = msg.sender;\n  }\n\n  modifier _0x17c336() {\n    require(msg.sender == _0x97b4d7);\n    _;\n  }\n\n  function _0x2e044e(address _0xc63ea1) _0x17c336 public {\n    require(_0xc63ea1 != address(0));\n    OwnershipTransferred(_0x97b4d7, _0xc63ea1);\n    _0x97b4d7 = _0xc63ea1;\n  }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public _0xe0cf85 = false;\n\n  modifier _0x86e56b() {\n    require(!_0xe0cf85);\n    _;\n  }\n\n  modifier _0x334e49() {\n    require(_0xe0cf85);\n    _;\n  }\n\n  function _0xea44bf() _0x17c336 _0x86e56b public {\n    _0xe0cf85 = true;\n    Pause();\n  }\n\n  function _0xce9a16() _0x17c336 _0x334e49 public {\n    _0xe0cf85 = false;\n    Unpause();\n  }\n}\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _0x5388b8, uint256 _0xa1977b) public _0x86e56b returns (bool) {\n    return super.transfer(_0x5388b8, _0xa1977b);\n  }\n\n  function _0x59f69c(address _0xa846d6, address _0x5388b8, uint256 _0xa1977b) public _0x86e56b returns (bool) {\n    return super._0x59f69c(_0xa846d6, _0x5388b8, _0xa1977b);\n  }\n\n  function _0x165fa7(address _0x32d799, uint256 _0xa1977b) public _0x86e56b returns (bool) {\n    return super._0x165fa7(_0x32d799, _0xa1977b);\n  }\n\n  function _0xb14be6(address[] _0xf922a7, uint256 _0xa1977b) public _0x86e56b returns (bool) {\n    uint _0x7878c6 = _0xf922a7.length;\n    uint256 _0xa140c8 = uint256(_0x7878c6) * _0xa1977b;\n    require(_0x7878c6 > 0 && _0x7878c6 <= 20);\n    require(_0xa1977b > 0 && _0xbd68d8[msg.sender] >= _0xa140c8);\n\n    _0xbd68d8[msg.sender] = _0xbd68d8[msg.sender]._0x2e9fd2(_0xa140c8);\n    for (uint i = 0; i < _0x7878c6; i++) {\n        _0xbd68d8[_0xf922a7[i]] = _0xbd68d8[_0xf922a7[i]]._0xf92e20(_0xa1977b);\n        Transfer(msg.sender, _0xf922a7[i], _0xa1977b);\n    }\n    return true;\n  }\n}\n\ncontract BecToken is PausableToken {\n    string public _0xc9ab6e = \"BeautyChain\";\n    string public _0xe4742e = \"BEC\";\n    string public _0x4a57f4 = '1.0.0';\n    uint8 public _0xdc59aa = 18;\n\n    function BecToken() {\n      _0x6f97b1 = 7000000000 * (10**(uint256(_0xdc59aa)));\n      _0xbd68d8[msg.sender] = _0x6f97b1;    // Give the creator all initial tokens\n    }\n\n    function () {\n        //if ether is sent to this address, send it back.\n        revert();\n    }\n}\n",
      "rename_map": {
        "transferOwnership": "_0x2e044e",
        "previousOwner": "_0x602448",
        "whenNotPaused": "_0x86e56b",
        "batchTransfer": "_0xb14be6",
        "transferFrom": "_0x59f69c",
        "totalSupply": "_0x6f97b1",
        "_receivers": "_0xf922a7",
        "whenPaused": "_0x334e49",
        "balanceOf": "_0x2decf0",
        "remaining": "_0x7b83fb",
        "allowance": "_0xb0a56f",
        "onlyOwner": "_0x17c336",
        "balances": "_0xbd68d8",
        "_spender": "_0x32d799",
        "decimals": "_0xdc59aa",
        "newOwner": "_0xc63ea1",
        "allowed": "_0x9f5c68",
        "spender": "_0x7579f4",
        "approve": "_0x165fa7",
        "version": "_0x4a57f4",
        "unpause": "_0xce9a16",
        "symbol": "_0xe4742e",
        "_owner": "_0x2956b9",
        "paused": "_0xe0cf85",
        "_value": "_0xa1977b",
        "amount": "_0xa140c8",
        "owner": "_0x97b4d7",
        "_from": "_0xa846d6",
        "pause": "_0xea44bf",
        "name": "_0xc9ab6e",
        "who": "_0x195ce8",
        "div": "_0x7766a8",
        "_to": "_0x5388b8",
        "sub": "_0x2e9fd2",
        "add": "_0xf92e20",
        "mul": "_0x0f0bfd",
        "cnt": "_0x7878c6",
        "to": "_0x298621"
      },
      "changes": [
        "Renamed 38 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_233",
      "transformed_id": "ss_l2_hex_sn_ds_233",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.9_0x01ca4elibrary Deck {\n\t// returns random number from 0 to 51\n\t// let's say 'value' % 4 means suit (0 - Hearts, 1 - Spades, 2 - Diamonds, 3 - Clubs)\n\t//\t\t\t 'value' / 4 means: 0 - King, 1 - Ace, 2 - 10 - pip values, 11 - Jacket, 12 - Queen\n\n\tfunction _0x2e7936(address _0x2c9f49, uint8 _0x2c1efe) internal returns (uint8) {\n\t\tuint b = block.number;\n\t\tuint timestamp = block.timestamp;\n\t\treturn uint8(uint256(_0x1962f9(block.blockhash(b), _0x2c9f49, _0x2c1efe, timestamp)) % 52);\n\t}\n\n\tfunction _0xd6edd0(uint8 _0xdf1470, bool _0xc27a5a) internal constant returns (uint8) {\n\t\tuint8 value = _0xdf1470 / 4;\n\t\tif (value == 0 || value == 11 || value == 12) { // Face cards\n\t\t\treturn 10;\n\t\t}\n\t\tif (value == 1 && _0xc27a5a) { // Ace is worth 11\n\t\t\treturn 11;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction _0x2d5a18(uint8 _0xdf1470) internal constant returns (bool) {\n\t\treturn _0xdf1470 / 4 == 1;\n\t}\n\n\tfunction _0xc3550b(uint8 _0xdf1470) internal constant returns (bool) {\n\t\treturn _0xdf1470 / 4 == 10;\n\t}\n}\n\ncontract BlackJack {\n\tusing Deck for *;\n\n\tuint public _0xfc8490 = 50 finney; // 0.05 eth\n\tuint public _0x35b5c9 = 5 ether;\n\n\tuint8 BLACKJACK = 21;\n\n  enum GameState { Ongoing, Player, Tie, House }\n\n\tstruct Game_0xbfb93baddress _0x2c9f49; // address \u0438\u0433\u0440\u043e\u043a\u0430_0x901858uint _0x9b75b5; // \u0441\u0442\u044b\u0432\u043a\u0430\n\n\t\tuint8[] houseCards; // \u043a\u0430\u0440\u0442\u044b \u0434\u0438\u043b\u043b\u0435\u0440\u0430_0x901858uint8[] _0x1864e0; // \u043a\u0430\u0440\u0442\u044b \u0438\u0433\u0440\u043e\u043a\u0430\n\n\t\tGameState state; // \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435_0x901858uint8 cardsDealt;\n\t}\n\n\tmapping (address => Game) public games;\n\n\tmodifier gameIsGoingOn() {\n\t\tif (_0x99d3f1sender]._0x2c9f49 == 0 || _0x99d3f1sender].state != GameState.Ongoing) {\n\t\t\tthrow; // game doesn't exist or already finished\n\t\t}\n\t\t_;\n\t}\n\n\tevent Deal(\n        bool isUser,\n        uint8 _card\n    );\n\n    event GameStatus(\n    \tuint8 houseScore,\n    \tuint8 houseScoreBig,\n    \tuint8 playerScore,\n    \tuint8 playerScoreBig\n    );\n\n    event Log(\n    \tuint8 value\n    );\n\n\tfunction BlackJack() {\n\n\t}\n\n\tfunction () payable {\n\n\t}\n\n\t// starts a new game\n\tfunction _0x2e7936() public payable_0xbfb93bif (_0x99d3f1sender]._0x2c9f49 != 0 && _0x99d3f1sender].state == GameState.Ongoing) {\n\t\t\tthrow; // game is already going on\n\t\t}\n\n\t\tif_0x0c60c5.value < _0xfc8490 || msg.value > _0x35b5c9) {\n\t\t\tthrow; // incorrect bet\n\t\t}\n\n\t\tuint8[] memory houseCards = new uint8[](1);\n\t\tuint8[] memory _0x1864e0 = new uint8[](2);\n\n\t\t// deal the cards_0x901858_0x1864e0[0] = Deck.deal_0x0db4d6, 0);\n\t\tDeal(true, _0x1864e0[0]);\n\t\thouseCards[0] = Deck.deal_0x0db4d6, 1);\n\t\tDeal(false, houseCards[0]);\n\t\t_0x1864e0[1] = Deck.deal_0x0db4d6, 2);\n\t\tDeal(true, _0x1864e0[1]);\n\n\t\t_0x99d3f1sender] = Game({\n\t\t\t_0x2c9f49: msg.sender,\n\t\t\t_0x9b75b5: msg.value,\n\t\t\thouseCards: houseCards,\n\t\t\t_0x1864e0: _0x1864e0,\n\t\t\tstate: GameState.Ongoing,\n\t\t\tcardsDealt: 3\n\t\t});\n\n\t\tcheckGameResult(_0x99d3f1sender], false);\n\t}\n\n\t// deals one more card to the player\n\tfunction hit() public gameIsGoingOn_0xbfb93buint8 nextCard = _0x99d3f1sender].cardsDealt;\n\t\t_0x99d3f1sender]._0x1864e0._0xfbb527deal_0x0db4d6, nextCard));\n\t\t_0x99d3f1sender].cardsDealt = nextCard + 1;\n\t\tDeal(true, _0x99d3f1sender]._0x1864e0[_0x99d3f1sender]._0x1864e0.length - 1]);\n\t\tcheckGameResult(_0x99d3f1sender], false);\n\t}\n\n\t// finishes the game\n\tfunction stand() public gameIsGoingOn {\n\n\t\tvar (houseScore, houseScoreBig) = calculateScore(_0x99d3f1sender].houseCards);\n\n\t\twhile (houseScoreBig < 17) {\n\t\t\tuint8 nextCard = _0x99d3f1sender].cardsDealt;\n\t\t\tuint8 newCard = Deck.deal_0x0db4d6, nextCard);\n\t\t\t_0x99d3f1sender].houseCards.push(newCard);\n\t\t\t_0x99d3f1sender].cardsDealt = nextCard + 1;\n\t\t\thouseScoreBig += Deck._0xd6edd0(newCard, true);\n\t\t\tDeal(false, newCard);\n\t\t}\n\n\t\tcheckGameResult(_0x99d3f1sender], true);\n\t}\n\n\t// @param finishGame - whether to finish the game or not (in case of Blackjack the game finishes anyway)\n\tfunction checkGameResult(Game _0x80e727, bool finishGame_0x0b80d2_0xbfb93b// calculate house score_0x901858var (houseScore, houseScoreBig) = calculateScore(_0x03873fhouseCards);\n\t\t// calculate player score_0x901858var (playerScore, playerScoreBig) = calculateScore(_0x03873f_0x1864e0);\n\n\t\tGameStatus(houseScore, houseScoreBig, playerScore, playerScoreBig);\n\n\t\tif (houseScoreBig == BLACKJACK || houseScore == BLACKJACK) {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\t\t\t\t// TIE_0xea243cif (!msg.sender._0x8e61b4)) throw; // return bet to the player_0xea243c_0x99d3f1sender].state = GameState.Tie; // finish the game_0xea243creturn;\n\t\t\t} else {\n\t\t\t\t// HOUSE WON_0xea243c_0x99d3f1sender].state = GameState.House; // simply finish the game_0xea243creturn;\n\t\t\t}\n\t\t} else {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\t\t\t\t// PLAYER WON_0xea243cif (_0x03873f_0x1864e0.length == 2 && (Deck._0xc3550b(_0x03873f_0x1864e0[0]) || Deck._0xc3550b(_0x03873f_0x1864e0[1]))) {\n\t\t\t\t\t// Natural blackjack => return x2.5\n\t\t\t\t\tif (!msg.sender.send((_0x03873fbet * 5) / 2)) throw; // send prize to the player\n\t\t\t\t} else {\n\t\t\t\t\t// Usual blackjack => return x2\n\t\t\t\t\tif (!msg.sender._0x8e61b4 * 2)) throw; // send prize to the player\n\t\t\t\t}\n\t\t\t\t_0x99d3f1sender].state = GameState.Player; // finish the game_0xea243creturn;\n\t\t\t} else {\n\n\t\t\t\tif (playerScore > BLACKJACK) {\n\t\t\t\t\t// BUST, HOUSE WON\n\t\t\t\t\tLog(1);\n\t\t\t\t\t_0x99d3f1sender].state = GameState.House; // finish the game\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!finishGame) {\n\t\t\t\t\treturn; // continue the game\n\t\t\t\t}\n\n                // \u043d\u0435\u0434\u043e\u0431\u043e\u0440_0xea243cuint8 playerShortage = 0;\n\t\t\t\tuint8 houseShortage = 0;\n\n\t\t\t\t// player decided to finish the game_0xea243cif (playerScoreBig > BLACKJACK) {\n\t\t\t\t\tif (playerScore > BLACKJACK) {\n\t\t\t\t\t\t// HOUSE WON\n\t\t\t\t\t\t_0x99d3f1sender].state = GameState.House; // simply finish the game\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplayerShortage = BLACKJACK - playerScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tplayerShortage = BLACKJACK - playerScoreBig;\n\t\t\t\t}\n\n\t\t\t\tif (houseScoreBig > BLACKJACK) {\n\t\t\t\t\tif (houseScore > BLACKJACK) {\n\t\t\t\t\t\t// PLAYER WON\n\t\t\t\t\t\tif (!msg.sender._0x8e61b4 * 2)) throw; // send prize to the player\n\t\t\t\t\t\t_0x99d3f1sender].state = GameState.Player;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thouseShortage = BLACKJACK - houseScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thouseShortage = BLACKJACK - houseScoreBig;\n\t\t\t\t}\n\n                // ?????????????????????? \u043f\u043e\u0447\u0435\u043c\u0443 \u0438\u0433\u0440\u0430 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f?_0xea243cif (houseShortage == playerShortage) {\n\t\t\t\t\t// TIE\n\t\t\t\t\tif (!msg.sender._0x8e61b4)) throw; // return bet to the player\n\t\t\t\t\t_0x99d3f1sender].state = GameState.Tie;\n\t\t\t\t} else if (houseShortage > playerShortage) {\n\t\t\t\t\t// PLAYER WON\n\t\t\t\t\tif (!msg.sender._0x8e61b4 * 2)) throw; // send prize to the player\n\t\t\t\t\t_0x99d3f1sender].state = GameState.Player;\n\t\t\t\t} else {\n\t\t\t\t\t_0x99d3f1sender].state = GameState.House;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction calculateScore(uint8[] cards_0x0b80d2 constant returns (uint8, uint8) {\n\t\t_0xa200d00;\n\t\tuint8 scoreBig = 0; // in case of Ace there could be 2 different scores_0x901858bool bigAceUsed = false;\n\t\tfor (uint i = 0; i < cards.length; ++i) {\n\t\t\tuint8 _0xdf1470 = cards[i];\n\t\t\tif (Deck._0x2d5a18(_0xdf1470) && !bigAceUsed) { // doesn't make sense to use the second Ace as 11, because it leads to the losing_0xea243cscoreBig += Deck._0xd6edd0(_0xdf1470, true);\n\t\t\t\tbigAceUsed = true;\n\t\t\t} else {\n\t\t\t\tscoreBig += Deck._0xd6edd0(_0xdf1470, false);\n\t\t\t}\n\t\t\tscore += Deck._0xd6edd0(_0xdf1470, false);\n\t\t}\n\t\treturn (score, scoreBig);\n\t}\n\n\tfunction getPlayerCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif_0xe6179aid > _0x99d3f1sender]._0x1864e0.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn _0x99d3f1sender]._0x1864e0_0xfbaf91function getHouseCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif_0xe6179aid > _0x99d3f1sender].houseCards.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn _0x99d3f1sender].houseCards_0xfbaf91function getPlayerCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn _0x99d3f1sender]._0x1864e0.length;\n\t}\n\n\tfunction getHouseCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn _0x99d3f1sender].houseCards.length;\n\t}\n\n\tfunction getGameState() public constant returns (uint8) {\n\t\tif (_0x99d3f1sender]._0x2c9f49 == 0) {\n\t\t\tthrow; // game doesn't exist\n\t\t}\n\n\t\tGame _0x80e727 = _0x99d3f1sender];\n\n\t\tif (_0x03873fstate == GameState.Player) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (_0x03873fstate == GameState.House) {\n\t\t\treturn 2;\n\t\t}\n\t\tif (_0x03873fstate == GameState.Tie) {\n\t\t\treturn 3;\n\t\t}\n\n\t\treturn 0; // the game is still going on\n\t}\n\n}",
      "rename_map": {
        "urn games[msg.sender": "_0x222da5",
        "rn games[msg.sender": "_0x4b783e",
        "\n\n\t// @param fi": "_0x792cfe",
        "}\n\n\t// deals on": "_0x3bdb61",
        "}\n\n\t// finishes": "_0xad12cf",
        "private {\n\t\t// ": "_0x3dded8",
        "2)) throw; // ": "_0xc81a8f",
        "tus(houseScore": "_0x86c740",
        "> BLACKJACK) {": "_0xa00eb7",
        "uint8 score = ": "_0xa200d0",
        "\n\t\t\t\tif (house": "_0x6d41df",
        "ate player sco": "_0x07fdca",
        "\t\tif (!msg.sen": "_0x9e5bf9",
        " WON\n\t\t\t\tif (g": "_0x46a43e",
        "// return bet ": "_0x2d09e3",
        "\t\t\t// player d": "_0xce2b16",
        "\t\t} else {\n\t\t\t": "_0xc6bf94",
        ";\n\n\t\twhile (ho": "_0x8131b8",
        "int8 value\n   ": "_0xaf12f9",
        " the game\n\t\t\t": "_0x5af74b",
        ";\n\t\t\tDeal(fal": "_0xdb5e31",
        "ame.bet)) thr": "_0x8a2757",
        "\n\n\t\tif (house": "_0xaa9c5c",
        "???????????? ": "_0xeb5936",
        "nder].houseCa": "_0xea0763",
        "f (id < 0 || ": "_0xff32ee",
        "der].houseCar": "_0xee3c44",
        "send(game.bet": "_0x8e61b4",
        ".sender].card": "_0xde8487",
        "rds.length;\n\t": "_0xce6594",
        "der].playerCa": "_0xac41c4",
        "rds);\n\t\t// ca": "_0xfdd213",
        "} else {\n\t\t\t\t": "_0x3c4600",
        "ds.length;\n\t}": "_0x55fa34",
        "mes[msg.sende": "_0x8859e0",
        "ayer == 0 || ": "_0x94c262",
        "             ": "_0x5d7478",
        "reBig) = calc": "_0x53f569",
        "uint8 playerS": "_0x7d439b",
        " (id < 0 || ": "_0xe6179a",
        "layer == 0) ": "_0x9d5bd8",
        "eScoreBig, ": "_0x2c92b5",
        " cards\n\t\tpl": "_0xa29d67",
        "= BLACKJACK": "_0xc6da32",
        "playerCards": "_0x1864e0",
        "games[msg.s": "_0x124416",
        "oreBig == B": "_0x6878ba",
        " constant r": "_0x4aa1a2",
        "[id];\n\t}\n\n\t": "_0xfbaf91",
        "e = BLACKJA": "_0xbd7928",
        "({\n\t\t\tplaye": "_0xcf8914",
        "e(game.play": "_0xa069e7",
        ";\n\n    even": "_0x09f7a5",
        "\tcardsDealt": "_0x473ca1",
        "ngth - 1]);": "_0xdaf0ee",
        "(msg.sender": "_0x0db4d6",
        "e.Ongoing,\n": "_0x6961e8",
        "\u0440\u043e\u043a\u0430\n\n\t\tGam": "_0x952939",
        "k => return": "_0xe76e2b",
        "ard));\n\t\tga": "_0xbdf8b7",
        "\tDeal(true,": "_0x3439fb",
        "ds[1]))) {\n": "_0x925b49",
        "\tgames[msg.": "_0x20cf8c",
        "\n\t\t\tuint8 ": "_0x3acb39",
        "[msg.sende": "_0x0bebc2",
        "\t\t\t}\n\t\t\tsc": "_0x8d685d",
        "t leads to": "_0x511d4b",
        "ame\n\t\t\t\t}\n": "_0x61d226",
        "// \u043a\u0430\u0440\u0442\u044b \u0434": "_0xeff4ea",
        "constant r": "_0x7a06fa",
        "8 houseSco": "_0x45db40",
        "games[msg.": "_0x99d3f1",
        "erCards,\n\t": "_0x01f795",
        "ublic game": "_0x827d10",
        "d];\n\t}\n\n\tf": "_0xc448ac",
        "(msg.sende": "_0x5083ff",
        "core\n\t\tvar": "_0xcf37e7",
        ".sender, n": "_0x8f7d7d",
        "int8 playe": "_0xbac9b0",
        "\tif (!msg.": "_0x53d031",
        "e == BLACK": "_0x6519e5",
        "erScoreBig": "_0xf9891b",
        "cardNumber": "_0x2c1efe",
        "s[msg.send": "_0x031f0b",
        "r].cardsDe": "_0x28c9ff",
        "+= Deck.va": "_0x3281ab",
        "ard = card": "_0x5cfe5a",
        "push(Deck.": "_0xfbb527",
        "= BLACKJAC": "_0x0a9ac2",
        "int8) {\n\t\t": "_0x1a973c",
        "game.house": "_0x7a6806",
        "state: Gam": "_0x2dfcd9",
        "ar (player": "_0x0c61e2",
        "y playerCa": "_0xa49066",
        "\t\treturn ": "_0x67f8de",
        "\t\t\t\t// PL": "_0xaa7716",
        "urn;\n\t\t\t}": "_0xe16ffb",
        ";\n\t\t\t} el": "_0x7cd3f0",
        "der.send(": "_0x24ad88",
        "layerShor": "_0x4437fa",
        "der].stat": "_0xdddbcd",
        "\t\t\treturn": "_0x1793af",
        "\thouseSho": "_0x751e46",
        "urn;\n\t\t\t\t": "_0xc5fcac",
        "send(game": "_0x0440f5",
        ") private": "_0x0b80d2",
        "\t\t\t\t// TI": "_0x9c0e9d",
        "ready goi": "_0x7da491",
        "keccak256": "_0x1962f9",
        "\t\t\t// PLA": "_0x524ae6",
        "'t exist ": "_0x190b5c",
        "{\n\t\t\tretu": "_0xf7215f",
        "useShorta": "_0x93b25c",
        "/ ???????": "_0xdb1fea",
        "t8 cardsD": "_0xc3977a",
        " || playe": "_0x35d71b",
        "turn;\n\t\t\t": "_0x733a09",
        "reBig > B": "_0x95706c",
        "}\n\n\t// st": "_0xf5a0a8",
        "\t\t\t\t// HO": "_0x8f2e79",
        "use;\n\t\t\t\t": "_0x512321",
        "f (player": "_0x140d40",
        "playerCar": "_0x04d859",
        "\tcheckGam": "_0x145169",
        "g(1);\n\t\t\t": "_0x9c7788",
        "ds.lengt": "_0xec532e",
        "ush(newC": "_0x21493c",
        "uint8 ne": "_0xd5a337",
        " false);": "_0x681ab2",
        "on\n\t}\n\n}": "_0xc9489b",
        "igAceUse": "_0x0f5797",
        "isBigAce": "_0xc27a5a",
        "tant ret": "_0x67830f",
        "ames[msg": "_0x270b46",
        "s.length": "_0xac4ab7",
        " // in c": "_0x4e5805",
        ".playerC": "_0x59c1f3",
        "\t\t\tscore": "_0xce286a",
        "\n\tfuncti": "_0x3370e7",
        " nextCar": "_0xe5fabb",
        "\n\n\tfunct": "_0x0fa1d7",
        "; // gam": "_0x51ebc5",
        "valueOf": "_0xd6edd0",
        "yerCard": "_0xa84c24",
        "\t\tgames": "_0x95007b",
        "\n\n\t\tche": "_0x200395",
        "g on\n\t\t": "_0xfed389",
        "nextCar": "_0x246986",
        "rd);\n\t\t": "_0x7b071f",
        "r alrea": "_0xbab6cf",
        "ender],": "_0xa27b5b",
        "turn (s": "_0xbed36e",
        "ck.valu": "_0xb282fb",
        "tage =": "_0x1ad722",
        "t Game": "_0xb92e1f",
        "functi": "_0xd09941",
        "eCards": "_0x46a682",
        "ue, ga": "_0x6689e2",
        "ame.st": "_0xc66028",
        "unctio": "_0x40d8da",
        "ize to": "_0x4cd6fc",
        "useCar": "_0x4e8912",
        "the ga": "_0x8d756a",
        "games[": "_0xfc47d0",
        "0]) ||": "_0xa356fa",
        "ow; //": "_0x09082b",
        "minBet": "_0xfc8490",
        "uint8[": "_0xcde5d7",
        "ge) {\n": "_0x5bc292",
        "whethe": "_0x68c427",
        "eIsGoi": "_0x291948",
        "to the": "_0xb8ad33",
        "sDealt": "_0x28e6d0",
        "g.send": "_0x7a2779",
        "nder],": "_0xf295cf",
        "\t\t} el": "_0x2cc656",
        " game\n": "_0x9e56b6",
        "deal(m": "_0x39395d",
        "f (gam": "_0xe51bb9",
        "sg.sen": "_0xced3fa",
        "n 2;\n\t": "_0x047c8a",
        "\n\t\t\t}\n": "_0xeec972",
        "et: ms": "_0xe6f2b6",
        "else {": "_0xb93703",
        "eResul": "_0xbb3dbb",
        "turns ": "_0x37f3f9",
        "re(uin": "_0x15a5d5",
        "maxBet": "_0x35b5c9",
        "eUsed)": "_0xef3d92",
        "player": "_0x2c9f49",
        "erCard": "_0x9a99d6",
        " incor": "_0xefd843",
        "sGoing": "_0x4fe686",
        "e = Ga": "_0x019441",
        "nction": "_0x2075c7",
        " to th": "_0xe7025d",
        "end pr": "_0x1fa04c",
        " < 17)": "_0xccbc85",
        "coreBi": "_0xab65f2",
        "he gam": "_0xefd91f",
        "te == ": "_0xbd0ff1",
        "inish ": "_0xeabffe",
        "ender]": "_0xdb02d6",
        "te != ": "_0x941b8d",
        "yerCar": "_0xe462fc",
        "\tgames": "_0xa7fb05",
        "the pl": "_0x95ec30",
        "r, nex": "_0xc52c53",
        "meStat": "_0xb7ed98",
        "houseC": "_0xbeb7f4",
        "// fi": "_0x9f205b",
        "\n\t\t\t}": "_0x3fa4e2",
        "ame i": "_0x7d2040",
        "publi": "_0x7b7f6b",
        "uncti": "_0x9aa79e",
        "nder]": "_0x0e1458",
        "alt;\n": "_0x7f283d",
        "y fin": "_0xe063fe",
        "\n\t\t}\n": "_0x23d2db",
        "\t} el": "_0xcf394f",
        "/ fin": "_0x953ace",
        "\t\t\t//": "_0x90e3c5",
        "\t});\n": "_0xd083ae",
        "er].p": "_0x7c3c4f",
        ") {\n\t": "_0x899da2",
        "\t}\n\t\t": "_0xa36c04",
        "isAce": "_0x2d5a18",
        "\tgame": "_0xcbbbcc",
        " more": "_0xd54680",
        "me ga": "_0x84e9df",
        "isTen": "_0xc3550b",
        "finis": "_0x5e2daa",
        "to us": "_0x7c84e3",
        "e.pla": "_0xf141c4",
        "seSco": "_0xc613fa",
        "[] ca": "_0xdb2634",
        "ame d": "_0x8e626e",
        "nder,": "_0x55a9db",
        "t8 ho": "_0x0e8aa8",
        "e.Tie": "_0x286dc2",
        "eturn": "_0xeae31e",
        "y hou": "_0x07e88a",
        "\t\tret": "_0xd2da98",
        "lcula": "_0x6508da",
        "sende": "_0x7f08c7",
        "lic g": "_0x447ab1",
        "(msg.": "_0x3dd78b",
        "!bigA": "_0xcecb92",
        "al bl": "_0x849ef4",
        "ayerS": "_0xd3d6c0",
        "ards:": "_0xe7b5f0",
        "e.Hou": "_0xf973cf",
        "\t\t\tga": "_0x35d108",
        "funct": "_0x08b2d0",
        "onsta": "_0xf4ed57",
        "blic ": "_0xddada3",
        "game.": "_0x03873f",
        "\t\t\t\t\t": "_0xaccb7e",
        "\t\tche": "_0x670f89",
        " (msg": "_0x0c60c5",
        "ll go": "_0x90fb6c",
        "8 sco": "_0x66120c",
        "\n\t\t\t\t": "_0xea243c",
        "ent s": "_0x13019e",
        ".Tie)": "_0x9630b9",
        "[msg.": "_0x66fdbc",
        "e gam": "_0xad078f",
        "/ sim": "_0xb9d257",
        " {\n\t\t": "_0xbfb93b",
        "as 11": "_0x8b78ce",
        "mes[m": "_0x6a68ca",
        "the g": "_0x3b2063",
        ";\n\t\t}": "_0x338369",
        "\n\t\tDe": "_0xd59056",
        "const": "_0xba8350",
        "rd = ": "_0xbb0f85",
        "\n\n\t\t\t": "_0x825f12",
        "yerCa": "_0x6e604a",
        "ishGa": "_0xe48690",
        "shed\n": "_0xb1bf0f",
        "e.Pla": "_0xc1aa08",
        "hrow;": "_0xc5f434",
        "useCa": "_0x93840a",
        "\n\t\t\th": "_0xeb2fa7",
        "e {\n\t": "_0x8d0d05",
        "ender": "_0xcf746c",
        "tate": "_0x300c61",
        "etPl": "_0x4ccfc8",
        "ore,": "_0x69d35c",
        "g.se": "_0x5bf24b",
        "newC": "_0x9d35ae",
        "n(ga": "_0xd9cba4",
        "(gam": "_0x6f010b",
        "yer\n": "_0x00db5c",
        "the ": "_0x4cfcc6",
        "card": "_0xdf1470",
        "() {": "_0xfa9cb7",
        "ckja": "_0x6982ea",
        "ze t": "_0xecf597",
        "play": "_0xc945fa",
        "deal": "_0x2e7936",
        "rn 1": "_0xabc962",
        "er].": "_0xbaa1e8",
        "es[m": "_0x78c2a6",
        " = D": "_0x0df007",
        "eCar": "_0xeb5dc4",
        "\t\t\t\t": "_0xfb0669",
        "stat": "_0x10f4e9",
        "s[1]": "_0xba4ceb",
        "ate ": "_0xbb2918",
        "\n\t\tr": "_0x03a69a",
        " = G": "_0xf6aa09",
        "\tret": "_0xfbe8e0",
        "der]": "_0xf64481",
        "s[0]": "_0xd56e4f",
        " Ace": "_0xc245b4",
        " bec": "_0x45e8b4",
        "eSta": "_0x0f9957",
        " hou": "_0x6b9d5d",
        "= De": "_0xbf0839",
        " sen": "_0xe0fa4e",
        "lue,": "_0x2e4cba",
        "e\n\t\t": "_0x94c6ba",
        "laye": "_0x2c5ef4",
        "alcu": "_0xac5e9e",
        "s st": "_0xc04014",
        "lt =": "_0xaa8c35",
        "game": "_0x80e727",
        "erCa": "_0x7df1b9",
        "rd\n ": "_0x47c4f1",
        "r\n\t\t": "_0xec3b1d",
        "rCar": "_0x7b2189",
        "+= D": "_0x2bd05d",
        "d p": "_0x1c5d49",
        "eBi": "_0x35da83",
        "sta": "_0xcf955c",
        "/ \u0441": "_0xf85939",
        "\t\t\t": "_0xeba296",
        "aye": "_0x884c3a",
        "d =": "_0x8269e5",
        "l(t": "_0xda1a3a",
        ";\n\t": "_0xae756c",
        "kGa": "_0x10f648",
        "\tga": "_0xb74600",
        "eck": "_0x505330",
        "meI": "_0x8e72a8",
        ".pl": "_0x15b17e",
        "hou": "_0x5d9f37",
        "ort": "_0x4449ad",
        "ame": "_0x202c0a",
        "end": "_0x2be1be",
        "e {": "_0x64ca5e",
        "// ": "_0x133f8a",
        "\t\tp": "_0xd9f946",
        "gam": "_0x1d9a01",
        ";\n\n": "_0x01ca4e",
        "kJa": "_0x4f09ec",
        "bet": "_0x9b75b5",
        ".st": "_0x1eb9f7",
        " be": "_0x811725",
        "\tth": "_0x66d0d3",
        "e =": "_0x092581",
        ": h": "_0x9a7952",
        " to": "_0x26583f",
        "meS": "_0x6b4598",
        "sg.": "_0x926556",
        "t r": "_0x085c01",
        "pla": "_0xe446c8",
        "sh ": "_0xf28f47",
        "use": "_0xf2e3fa",
        "f (": "_0xb902ef",
        "e -": "_0x097dcc",
        "\n\t\t": "_0x901858",
        "= G": "_0xd3ce5f",
        "car": "_0xaed6d7",
        "lay": "_0x7b2fcc",
        "tat": "_0x895e2c",
        "me\n": "_0xab1a1a",
        " th": "_0xc261ff",
        "yer": "_0x91b89f",
        "ish": "_0x70c024",
        "ly ": "_0x73333f",
        "eSc": "_0xa60c65",
        " ga": "_0xb58151",
        "es[": "_0x6a48da",
        "tu": "_0x2b081f",
        "me": "_0x16cedf",
        "ur": "_0x728554",
        "ms": "_0xad0d85",
        "sg": "_0x83092f",
        "rn": "_0x8372c0"
      },
      "changes": [
        "Renamed 391 identifiers using hex style"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 2, column 8', 'Syntax error at line 9, column 3', 'Syntax error at line 31, column 1']"
    },
    {
      "original_id": "sn_ds_234",
      "transformed_id": "ss_l2_hex_sn_ds_234",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.13;\n\nlibrary SafeMath {\n  function _0xa14212(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n  function _0xb56b30(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint public _0xff46aa;\n  address public _0x693dcf; //owner\n  address public _0xa0fb6f; //animator\n  function _0x9aa87b(address _0x1e3d9e) constant returns (uint);\n  function transfer(address _0xe86f5e, uint value);\n  event Transfer(address indexed from, address indexed _0xe86f5e, uint value);\n  function _0x7fa2bf(address _0x1e3d9e) internal; // pays remaining dividend\n}\n\ncontract ERC20 is ERC20Basic {\n  function _0xb97e76(address _0x693dcf, address _0x74cdfc) constant returns (uint);\n  function _0xbda2de(address from, address _0xe86f5e, uint value);\n  function _0xffa7ee(address _0x74cdfc, uint value);\n  event Approval(address indexed _0x693dcf, address indexed _0x74cdfc, uint value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n  mapping(address => uint) _0xd411c1;\n\n  modifier _0x1883c4(uint _0xe1408f) {\n     assert(msg.data.length >= _0xe1408f + 4);\n     _;\n  }\n\n  function transfer(address _0x1ac0d7, uint _0xe9d1c3) _0x1883c4(2 * 32) {\n    _0x7fa2bf(msg.sender);\n    _0xd411c1[msg.sender] = _0xd411c1[msg.sender]._0xa14212(_0xe9d1c3);\n    if(_0x1ac0d7 == address(this)) {\n        _0x7fa2bf(_0x693dcf);\n        _0xd411c1[_0x693dcf] = _0xd411c1[_0x693dcf]._0xb56b30(_0xe9d1c3);\n        Transfer(msg.sender, _0x693dcf, _0xe9d1c3);\n    }\n    else {\n        _0x7fa2bf(_0x1ac0d7);\n        _0xd411c1[_0x1ac0d7] = _0xd411c1[_0x1ac0d7]._0xb56b30(_0xe9d1c3);\n        Transfer(msg.sender, _0x1ac0d7, _0xe9d1c3);\n    }\n  }\n\n  function _0x9aa87b(address _0xdf9c3b) constant returns (uint balance) {\n    return _0xd411c1[_0xdf9c3b];\n  }\n}\n\ncontract StandardToken is BasicToken, ERC20 {\n  mapping (address => mapping (address => uint)) _0x8c43bd;\n\n  function _0xbda2de(address _0x5ac2c0, address _0x1ac0d7, uint _0xe9d1c3) _0x1883c4(3 * 32) {\n    var _0x226795 = _0x8c43bd[_0x5ac2c0][msg.sender];\n    _0x7fa2bf(_0x5ac2c0);\n    _0x7fa2bf(_0x1ac0d7);\n    _0xd411c1[_0x1ac0d7] = _0xd411c1[_0x1ac0d7]._0xb56b30(_0xe9d1c3);\n    _0xd411c1[_0x5ac2c0] = _0xd411c1[_0x5ac2c0]._0xa14212(_0xe9d1c3);\n    _0x8c43bd[_0x5ac2c0][msg.sender] = _0x226795._0xa14212(_0xe9d1c3);\n    Transfer(_0x5ac2c0, _0x1ac0d7, _0xe9d1c3);\n  }\n\n  function _0xffa7ee(address _0x0afcad, uint _0xe9d1c3) {\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    assert(!((_0xe9d1c3 != 0) && (_0x8c43bd[msg.sender][_0x0afcad] != 0)));\n    _0x8c43bd[msg.sender][_0x0afcad] = _0xe9d1c3;\n    Approval(msg.sender, _0x0afcad, _0xe9d1c3);\n  }\n\n  function _0xb97e76(address _0xdf9c3b, address _0x0afcad) constant returns (uint _0xdc1e0e) {\n    return _0x8c43bd[_0xdf9c3b][_0x0afcad];\n  }\n}\n\ncontract SmartBillions is StandardToken {\n\n    // metadata\n    string public constant _0xd71237 = \"SmartBillions Token\";\n    string public constant _0x1ddfae = \"PLAY\";\n    uint public constant _0x0d031f = 0;\n\n    // contract state\n    struct Wallet {\n        uint208 balance; // current balance of user\n    \tuint16 _0xe7cb07; // last processed dividend period of user's tokens\n    \tuint32 _0x32f4e2; // next withdrawal possible after this block number\n    }\n    mapping (address => Wallet) _0xbb635b;\n    struct Bet {\n        uint192 value; // bet size\n        uint32 _0x97303b; // selected numbers\n        uint32 _0x874e98; // blocknumber when lottery runs\n    }\n    mapping (address => Bet) _0x271dc6;\n\n    uint public _0x4d043a = 0; // sum of funds in wallets\n\n    // investment parameters\n    uint public _0xbbb819 = 1; // investment start block, 0: closed, 1: preparation\n    uint public _0x85dd00 = 0; // funding from investors\n    uint public _0x5421b2 = 200000 ether; // maximum funding\n    uint public _0xcd0266 = 1;\n    uint[] public _0xd0a9cb; // dividens collected per period, growing array\n\n    // betting parameters\n    uint public _0x94fd53 = 0; // maximum prize won\n    uint public _0xdd4500 = 0; // start time of building hashes database\n    uint public _0x77da97 = 0; // last saved block of hashes\n    uint public _0x8c5d6d = 0; // next available bet block.number\n    uint public _0x0ed3f4 = 0; // used bet volume of next block\n    uint public _0x83dcb4 = 5 ether; // maximum bet size per block\n    uint[] public _0x1a32bb; // space for storing lottery results\n\n    // constants\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\n    uint public constant _0xdf23be = 16384 ; // 30 days of blocks\n    uint public _0x2e82f9 = 0 ; // block of last cold store transfer\n\n    // events\n    event LogBet(address indexed _0x92c938, uint _0xbe71b4, uint _0x0808a1, uint _0x347c7a);\n    event LogLoss(address indexed _0x92c938, uint _0xbe71b4, uint _0x7eb45a);\n    event LogWin(address indexed _0x92c938, uint _0xbe71b4, uint _0x7eb45a, uint _0x98bd70);\n    event LogInvestment(address indexed _0x5ff9d6, address indexed _0x2deeb7, uint _0x99f5a4);\n    event LogRecordWin(address indexed _0x92c938, uint _0x99f5a4);\n    event LogLate(address indexed _0x92c938,uint _0xcb379b,uint _0xc6ce8d);\n    event LogDividend(address indexed _0x5ff9d6, uint _0x99f5a4, uint _0xa97ed5);\n\n    modifier _0xc6da4c() {\n        assert(msg.sender == _0x693dcf);\n        _;\n    }\n\n    modifier _0xc890dd() {\n        assert(msg.sender == _0xa0fb6f);\n        _;\n    }\n\n    // constructor\n    function SmartBillions() {\n        _0x693dcf = msg.sender;\n        _0xa0fb6f = msg.sender;\n        _0xbb635b[_0x693dcf]._0xe7cb07 = uint16(_0xcd0266);\n        _0xd0a9cb.push(0); // not used\n        _0xd0a9cb.push(0); // current dividend\n    }\n\n/* getters */\n\n    function _0x391dd1() constant external returns (uint) {\n        return uint(_0x1a32bb.length);\n    }\n\n    function _0x78bc59(address _0xdf9c3b) constant external returns (uint) {\n        return uint(_0xbb635b[_0xdf9c3b].balance);\n    }\n\n    function _0x9df22f(address _0xdf9c3b) constant external returns (uint) {\n        return uint(_0xbb635b[_0xdf9c3b]._0xe7cb07);\n    }\n\n    function _0xf9b749(address _0xdf9c3b) constant external returns (uint) {\n        return uint(_0xbb635b[_0xdf9c3b]._0x32f4e2);\n    }\n\n    function _0x3d8531(address _0xdf9c3b) constant external returns (uint) {\n        return uint(_0x271dc6[_0xdf9c3b].value);\n    }\n\n    function _0x84d247(address _0xdf9c3b) constant external returns (uint) {\n        return uint(_0x271dc6[_0xdf9c3b]._0x97303b);\n    }\n\n    function _0xa317e3(address _0xdf9c3b) constant external returns (uint) {\n        return uint(_0x271dc6[_0xdf9c3b]._0x874e98);\n    }\n\n    function _0x641600() constant external returns (uint) {\n        if(_0xbbb819 > 0) {\n            return(0);\n        }\n        uint _0xa97ed5 = (block.number - _0xdd4500) / (10 * _0xdf23be);\n        if(_0xa97ed5 > _0xcd0266) {\n            return(0);\n        }\n        return((10 * _0xdf23be) - ((block.number - _0xdd4500) % (10 * _0xdf23be)));\n    }\n\n/* administrative functions */\n\n    function _0x330b72(address _0xe44510) external _0xc6da4c {\n        assert(_0xe44510 != address(0));\n        _0x7fa2bf(msg.sender);\n        _0x7fa2bf(_0xe44510);\n        _0x693dcf = _0xe44510;\n    }\n\n    function _0x311648(address _0xe44510) external _0xc890dd {\n        assert(_0xe44510 != address(0));\n        _0x7fa2bf(msg.sender);\n        _0x7fa2bf(_0xe44510);\n        _0xa0fb6f = _0xe44510;\n    }\n\n    function _0x2abfe2(uint _0x6d83e4) external _0xc6da4c {\n        require(_0xbbb819 == 1 && _0xdd4500 > 0 && block.number < _0x6d83e4);\n        _0xbbb819 = _0x6d83e4;\n    }\n\n    function _0xcba2b7(uint _0xa9179b) external _0xc6da4c {\n        _0x83dcb4 = _0xa9179b;\n    }\n\n    function _0xb3e301() external _0xc6da4c {\n        _0x8c5d6d = block.number + 3;\n        _0x0ed3f4 = 0;\n    }\n\n    function _0xc33622(uint _0x8bb0da) external _0xc6da4c {\n        _0x41c8c6();\n        require(_0x8bb0da > 0 && this.balance >= (_0x85dd00 * 9 / 10) + _0x4d043a + _0x8bb0da);\n        if(_0x85dd00 >= _0x5421b2 / 2){ // additional jackpot protection\n            require((_0x8bb0da <= this.balance / 400) && _0x2e82f9 + 4 * 60 * 24 * 7 <= block.number);\n        }\n        msg.sender.transfer(_0x8bb0da);\n        _0x2e82f9 = block.number;\n    }\n\n    function _0x8f9c92() payable external {\n        _0x41c8c6();\n    }\n\n/* housekeeping functions */\n\n    function _0x41c8c6() public {\n        if(_0xbbb819 > 1 && block.number >= _0xbbb819 + (_0xdf23be * 5)){ // ca. 14 days\n            _0xbbb819 = 0; // start dividend payments\n        }\n        else {\n            if(_0xdd4500 > 0){\n\t\t        uint _0xa97ed5 = (block.number - _0xdd4500) / (10 * _0xdf23be );\n                if(_0xa97ed5 > _0xd0a9cb.length - 2) {\n                    _0xd0a9cb.push(0);\n                }\n                if(_0xa97ed5 > _0xcd0266 && _0xbbb819 == 0 && _0xcd0266 < _0xd0a9cb.length - 1) {\n                    _0xcd0266++;\n                }\n            }\n        }\n    }\n\n/* payments */\n\n    function _0x421bdb() public {\n        if(_0xbb635b[msg.sender].balance > 0 && _0xbb635b[msg.sender]._0x32f4e2 <= block.number){\n            uint balance = _0xbb635b[msg.sender].balance;\n            _0xbb635b[msg.sender].balance = 0;\n            _0x4d043a -= balance;\n            _0xbe49fc(balance);\n        }\n    }\n\n    function _0xbe49fc(uint _0x8bb0da) private {\n        uint _0x777c1d = this.balance / 2;\n        if(_0x777c1d >= _0x8bb0da) {\n            msg.sender.transfer(_0x8bb0da);\n            if(_0x8bb0da > 1 finney) {\n                _0x41c8c6();\n            }\n        }\n        else {\n            uint _0x91df0d = _0x8bb0da - _0x777c1d;\n            _0x4d043a += _0x91df0d;\n            _0xbb635b[msg.sender].balance += uint208(_0x91df0d);\n            _0xbb635b[msg.sender]._0x32f4e2 = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\n            msg.sender.transfer(_0x777c1d);\n        }\n    }\n\n/* investment functions */\n\n    function _0xeed38e() payable external {\n        _0xfb3d16(_0x693dcf);\n    }\n\n    function _0xfb3d16(address _0xa306de) payable public {\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\n        require(_0xbbb819 > 1 && block.number < _0xbbb819 + (_0xdf23be * 5) && _0x85dd00 < _0x5421b2);\n        uint _0x3f320b = msg.value;\n        if(_0x3f320b > _0x5421b2 - _0x85dd00) {\n            _0x3f320b = _0x5421b2 - _0x85dd00;\n            _0x85dd00 = _0x5421b2;\n            _0xbbb819 = 0; // close investment round\n            msg.sender.transfer(msg.value._0xa14212(_0x3f320b)); // send back funds immediately\n        }\n        else{\n            _0x85dd00 += _0x3f320b;\n        }\n        if(_0xa306de == address(0) || _0xa306de == _0x693dcf){\n            _0x4d043a += _0x3f320b / 10;\n            _0xbb635b[_0x693dcf].balance += uint208(_0x3f320b / 10);} // 10% for marketing if no affiliates\n        else{\n            _0x4d043a += (_0x3f320b * 5 / 100) * 2;\n            _0xbb635b[_0x693dcf].balance += uint208(_0x3f320b * 5 / 100); // 5% initial marketing funds\n            _0xbb635b[_0xa306de].balance += uint208(_0x3f320b * 5 / 100);} // 5% for affiliates\n        _0xbb635b[msg.sender]._0xe7cb07 = uint16(_0xcd0266); // assert(dividendPeriod == 1);\n        uint _0x41ec70 = _0x3f320b / 10**15;\n        uint _0x9a84a1 = _0x3f320b * 16 / 10**17  ;\n        uint _0xa255f7 = _0x3f320b * 10 / 10**17  ;\n        _0xd411c1[msg.sender] += _0x41ec70;\n        _0xd411c1[_0x693dcf] += _0x9a84a1 ; // 13% of shares go to developers\n        _0xd411c1[_0xa0fb6f] += _0xa255f7 ; // 8% of shares go to animator\n        _0xff46aa += _0x41ec70 + _0x9a84a1 + _0xa255f7;\n        Transfer(address(0),msg.sender,_0x41ec70); // for etherscan\n        Transfer(address(0),_0x693dcf,_0x9a84a1); // for etherscan\n        Transfer(address(0),_0xa0fb6f,_0xa255f7); // for etherscan\n        LogInvestment(msg.sender,_0xa306de,_0x3f320b);\n    }\n\n    function _0x089517() external {\n        require(_0xbbb819 == 0);\n        _0x7fa2bf(msg.sender);\n        uint _0xc760df = _0xd411c1[msg.sender] * 10**15;\n        Transfer(msg.sender,address(0),_0xd411c1[msg.sender]); // for etherscan\n        delete _0xd411c1[msg.sender]; // totalSupply stays the same, investBalance is reduced\n        _0x85dd00 -= _0xc760df;\n        _0xbb635b[msg.sender].balance += uint208(_0xc760df * 9 / 10);\n        _0x421bdb();\n    }\n\n    function _0xa7db38() external {\n        require(_0xbbb819 == 0);\n        _0x7fa2bf(msg.sender);\n        _0x421bdb();\n    }\n\n    function _0x7fa2bf(address _0xe44510) internal {\n        uint _0xd30607 = _0xbb635b[_0xe44510]._0xe7cb07;\n        if((_0xd411c1[_0xe44510]==0) || (_0xd30607==0)){\n            _0xbb635b[_0xe44510]._0xe7cb07=uint16(_0xcd0266);\n            return;\n        }\n        if(_0xd30607==_0xcd0266) {\n            return;\n        }\n        uint _0xf46cf2 = _0xd411c1[_0xe44510] * 0xffffffff / _0xff46aa;\n        uint balance = 0;\n        for(;_0xd30607<_0xcd0266;_0xd30607++) {\n            balance += _0xf46cf2 * _0xd0a9cb[_0xd30607];\n        }\n        balance = (balance / 0xffffffff);\n        _0x4d043a += balance;\n        _0xbb635b[_0xe44510].balance += uint208(balance);\n        _0xbb635b[_0xe44510]._0xe7cb07 = uint16(_0xd30607);\n        LogDividend(_0xe44510,balance,_0xd30607);\n    }\n\n/* lottery functions */\n\n    function _0x9f515d(Bet _0x3b24fe, uint24 _0xe1dc91) constant private returns (uint) { // house fee 13.85%\n        uint24 _0xbe71b4 = uint24(_0x3b24fe._0x97303b);\n        uint24 _0xe1e55c = _0xbe71b4 ^ _0xe1dc91;\n        uint24 _0x16c91a =\n            ((_0xe1e55c & 0xF) == 0 ? 1 : 0 ) +\n            ((_0xe1e55c & 0xF0) == 0 ? 1 : 0 ) +\n            ((_0xe1e55c & 0xF00) == 0 ? 1 : 0 ) +\n            ((_0xe1e55c & 0xF000) == 0 ? 1 : 0 ) +\n            ((_0xe1e55c & 0xF0000) == 0 ? 1 : 0 ) +\n            ((_0xe1e55c & 0xF00000) == 0 ? 1 : 0 );\n        if(_0x16c91a == 6){\n            return(uint(_0x3b24fe.value) * 7000000);\n        }\n        if(_0x16c91a == 5){\n            return(uint(_0x3b24fe.value) * 20000);\n        }\n        if(_0x16c91a == 4){\n            return(uint(_0x3b24fe.value) * 500);\n        }\n        if(_0x16c91a == 3){\n            return(uint(_0x3b24fe.value) * 25);\n        }\n        if(_0x16c91a == 2){\n            return(uint(_0x3b24fe.value) * 3);\n        }\n        return(0);\n    }\n\n    function _0x580e61(address _0xe44510) constant external returns (uint)  {\n        Bet memory _0x92c938 = _0x271dc6[_0xe44510];\n        if( (_0x92c938.value==0) ||\n            (_0x92c938._0x874e98<=1) ||\n            (block.number<_0x92c938._0x874e98) ||\n            (block.number>=_0x92c938._0x874e98 + (10 * _0xdf23be))){\n            return(0);\n        }\n        if(block.number<_0x92c938._0x874e98+256){\n            return(_0x9f515d(_0x92c938,uint24(block.blockhash(_0x92c938._0x874e98))));\n        }\n        if(_0xdd4500>0){\n            uint32 _0x7eb45a = _0x33220f(_0x92c938._0x874e98);\n            if(_0x7eb45a == 0x1000000) { // load hash failed :-(, return funds\n                return(uint(_0x92c938.value));\n            }\n            else{\n                return(_0x9f515d(_0x92c938,uint24(_0x7eb45a)));\n            }\n\t}\n        return(0);\n    }\n\n    function _0x98c654() public {\n        Bet memory _0x92c938 = _0x271dc6[msg.sender];\n        if(_0x92c938._0x874e98==0){ // create a new player\n            _0x271dc6[msg.sender] = Bet({value: 0, _0x97303b: 0, _0x874e98: 1});\n            return;\n        }\n        if((_0x92c938.value==0) || (_0x92c938._0x874e98==1)){\n            _0x421bdb();\n            return;\n        }\n        require(block.number>_0x92c938._0x874e98); // if there is an active bet, throw()\n        if(_0x92c938._0x874e98 + (10 * _0xdf23be) <= block.number){ // last bet too long ago, lost !\n            LogLate(msg.sender,_0x92c938._0x874e98,block.number);\n            _0x271dc6[msg.sender] = Bet({value: 0, _0x97303b: 0, _0x874e98: 1});\n            return;\n        }\n        uint _0x98bd70 = 0;\n        uint32 _0x7eb45a = 0;\n        if(block.number<_0x92c938._0x874e98+256){\n            _0x7eb45a = uint24(block.blockhash(_0x92c938._0x874e98));\n            _0x98bd70 = _0x9f515d(_0x92c938,uint24(_0x7eb45a));\n        }\n        else {\n            if(_0xdd4500>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\n                _0x7eb45a = _0x33220f(_0x92c938._0x874e98);\n                if(_0x7eb45a == 0x1000000) { // load hash failed :-(, return funds\n                    _0x98bd70 = uint(_0x92c938.value);\n                }\n                else{\n                    _0x98bd70 = _0x9f515d(_0x92c938,uint24(_0x7eb45a));\n                }\n\t    }\n            else{\n                LogLate(msg.sender,_0x92c938._0x874e98,block.number);\n                _0x271dc6[msg.sender] = Bet({value: 0, _0x97303b: 0, _0x874e98: 1});\n                return();\n            }\n        }\n        _0x271dc6[msg.sender] = Bet({value: 0, _0x97303b: 0, _0x874e98: 1});\n        if(_0x98bd70>0) {\n            LogWin(msg.sender,uint(_0x92c938._0x97303b),uint(_0x7eb45a),_0x98bd70);\n            if(_0x98bd70 > _0x94fd53){\n                _0x94fd53 = _0x98bd70;\n                LogRecordWin(msg.sender,_0x98bd70);\n            }\n            _0xbe49fc(_0x98bd70);\n        }\n        else{\n            LogLoss(msg.sender,uint(_0x92c938._0x97303b),uint(_0x7eb45a));\n        }\n    }\n\n    function () payable external {\n        if(msg.value > 0){\n            if(_0xbbb819>1){ // during ICO payment to the contract is treated as investment\n                _0xfb3d16(_0x693dcf);\n            }\n            else{ // if not ICO running payment to contract is treated as play\n                _0x7b5d19();\n            }\n            return;\n        }\n        //check for dividends and other assets\n        if(_0xbbb819 == 0 && _0xd411c1[msg.sender]>0){\n            _0x7fa2bf(msg.sender);}\n        _0x98c654(); // will run payWallet() if nothing else available\n    }\n\n    function _0x7b5d19() payable public returns (uint) {\n        return _0xdb1079(uint(_0xac9bc8(msg.sender,block.number)), address(0));\n    }\n\n    function _0x117038(address _0xa306de) payable public returns (uint) {\n        return _0xdb1079(uint(_0xac9bc8(msg.sender,block.number)), _0xa306de);\n    }\n\n    function _0xdb1079(uint _0xe1dc91, address _0xa306de) payable public returns (uint) {\n        _0x98c654(); // check if player did not win\n        uint24 _0xbe71b4 = uint24(_0xe1dc91);\n        require(msg.value <= 1 ether && msg.value < _0x83dcb4);\n        if(msg.value > 0){\n            if(_0xbbb819==0) { // dividends only after investment finished\n                _0xd0a9cb[_0xcd0266] += msg.value / 20; // 5% dividend\n            }\n            if(_0xa306de != address(0)) {\n                uint _0x535826 = msg.value / 100;\n                _0x4d043a += _0x535826;\n                _0xbb635b[_0xa306de].balance += uint208(_0x535826); // 1% for affiliates\n            }\n            if(_0x8c5d6d < block.number + 3) {\n                _0x8c5d6d = block.number + 3;\n                _0x0ed3f4 = msg.value;\n            }\n            else{\n                if(_0x0ed3f4 > _0x83dcb4) {\n                    _0x8c5d6d++;\n                    _0x0ed3f4 = msg.value;\n                }\n                else{\n                    _0x0ed3f4 += msg.value;\n                }\n            }\n            _0x271dc6[msg.sender] = Bet({value: uint192(msg.value), _0x97303b: uint32(_0xbe71b4), _0x874e98: uint32(_0x8c5d6d)});\n            LogBet(msg.sender,uint(_0xbe71b4),_0x8c5d6d,msg.value);\n        }\n        _0x08984d(); // players help collecing data\n        return(_0x8c5d6d);\n    }\n\n/* database functions */\n\n    function _0x003a89(uint _0xcc1362) public returns (uint) {\n        require(_0xdd4500 == 0 && _0xcc1362 > 0 && _0xcc1362 <= _0xdf23be);\n        uint n = _0x1a32bb.length;\n        if(n + _0xcc1362 > _0xdf23be){\n            _0x1a32bb.length = _0xdf23be;\n        }\n        else{\n            _0x1a32bb.length += _0xcc1362;\n        }\n        for(;n<_0x1a32bb.length;n++){ // make sure to burn gas\n            _0x1a32bb[n] = 1;\n        }\n        if(_0x1a32bb.length>=_0xdf23be) { // assume block.number > 10\n            _0xdd4500 = block.number - ( block.number % 10);\n            _0x77da97 = _0xdd4500;\n        }\n        return(_0x1a32bb.length);\n    }\n\n    function _0x092339() external returns (uint) {\n        return(_0x003a89(128));\n    }\n\n    function _0x7be37f(uint32 _0x575497, uint32 _0xf934c6) constant private returns (uint) {\n        return( ( uint(block.blockhash(_0x575497  )) & 0xFFFFFF )\n            | ( ( uint(block.blockhash(_0x575497+1)) & 0xFFFFFF ) << 24 )\n            | ( ( uint(block.blockhash(_0x575497+2)) & 0xFFFFFF ) << 48 )\n            | ( ( uint(block.blockhash(_0x575497+3)) & 0xFFFFFF ) << 72 )\n            | ( ( uint(block.blockhash(_0x575497+4)) & 0xFFFFFF ) << 96 )\n            | ( ( uint(block.blockhash(_0x575497+5)) & 0xFFFFFF ) << 120 )\n            | ( ( uint(block.blockhash(_0x575497+6)) & 0xFFFFFF ) << 144 )\n            | ( ( uint(block.blockhash(_0x575497+7)) & 0xFFFFFF ) << 168 )\n            | ( ( uint(block.blockhash(_0x575497+8)) & 0xFFFFFF ) << 192 )\n            | ( ( uint(block.blockhash(_0x575497+9)) & 0xFFFFFF ) << 216 )\n            | ( ( uint(_0xf934c6) / _0xdf23be) << 240));\n    }\n\n    function _0x33220f(uint _0xbaf8a4) constant private returns (uint32) {\n        uint _0xd93a4b = (_0xbaf8a4 - _0xdd4500) / 10;\n        uint _0x7eb45a = _0x1a32bb[_0xd93a4b % _0xdf23be];\n        if(_0xd93a4b / _0xdf23be != _0x7eb45a >> 240) {\n            return(0x1000000); // load failed, incorrect data in hashes\n        }\n        uint _0xa5de0f = (_0xbaf8a4 - _0xdd4500) % 10;\n        return(uint32((_0x7eb45a >> (24 * _0xa5de0f)) & 0xFFFFFF));\n    }\n\n    function _0x08984d() public returns (bool) {\n        uint _0xe8caab = _0x77da97;\n        if(_0xe8caab == 0 || block.number <= _0xe8caab + 10) {\n            return(false);\n        }\n        uint _0xdc0695;\n        if(block.number<256) { // useless test for testnet :-(\n            _0xdc0695 = 0;\n        }\n        else{\n            _0xdc0695 = block.number - 256;\n        }\n        if(_0xe8caab < _0xdc0695) {\n            uint _0x4db6bb = _0xdc0695;\n            _0x4db6bb += _0x4db6bb % 10;\n            _0xe8caab = _0x4db6bb;\n        }\n        uint _0xd93a4b = (_0xe8caab - _0xdd4500) / 10;\n        _0x1a32bb[_0xd93a4b % _0xdf23be] = _0x7be37f(uint32(_0xe8caab),uint32(_0xd93a4b));\n        _0x77da97 = _0xe8caab + 10;\n        return(true);\n    }\n\n    function _0x25b436(uint _0x52f91f) external {\n        uint n=0;\n        for(;n<_0x52f91f;n++){\n            if(!_0x08984d()){\n                return;\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "lastDividendPeriod": "_0xe7cb07",
        "currentBlockNumber": "_0xc6ce8d",
        "nextWithdrawBlock": "_0x32f4e2",
        "playerBlockNumber": "_0xcb379b",
        "initialInvestment": "_0xc760df",
        "betBlockNumberOf": "_0xa317e3",
        "investBalanceMax": "_0x5421b2",
        "dividendsBlocks": "_0x641600",
        "onlyPayloadSize": "_0x1883c4",
        "walletBalanceOf": "_0x78bc59",
        "animatorBalance": "_0xa255f7",
        "setInvestStart": "_0x2abfe2",
        "dividendPeriod": "_0xcd0266",
        "walletPeriodOf": "_0x9df22f",
        "changeAnimator": "_0x311648",
        "commitDividend": "_0x7fa2bf",
        "walletBalance": "_0x4d043a",
        "coldStoreLast": "_0x2e82f9",
        "walletBlockOf": "_0xf9b749",
        "investBalance": "_0x85dd00",
        "senderBalance": "_0x41ec70",
        "onlyAnimator": "_0xc890dd",
        "payDividends": "_0xa7db38",
        "investDirect": "_0xeed38e",
        "ownerBalance": "_0x9a84a1",
        "hashesLength": "_0x391dd1",
        "transferFrom": "_0xbda2de",
        "houseKeeping": "_0x41c8c6",
        "addHashes128": "_0x092339",
        "totalSupply": "_0xff46aa",
        "changeOwner": "_0x330b72",
        "keepbalance": "_0x91df0d",
        "blocknumber": "_0x0808a1",
        "investStart": "_0xbbb819",
        "playSystem": "_0xdb1079",
        "calcHashes": "_0x7be37f",
        "_allowance": "_0x226795",
        "hashBetSum": "_0x0ed3f4",
        "playRandom": "_0x117038",
        "hashesSize": "_0xdf23be",
        "hashBetMax": "_0x83dcb4",
        "betValueOf": "_0x3d8531",
        "setBetMax": "_0xcba2b7",
        "onlyOwner": "_0xc6da4c",
        "blockn256": "_0xdc0695",
        "payWallet": "_0x421bdb",
        "coldStore": "_0xc33622",
        "addHashes": "_0x003a89",
        "disinvest": "_0x089517",
        "dividends": "_0xd0a9cb",
        "betHashOf": "_0x84d247",
        "investing": "_0x3f320b",
        "balanceOf": "_0x9aa87b",
        "remaining": "_0xdc1e0e",
        "hashFirst": "_0xdd4500",
        "allowance": "_0xb97e76",
        "putHashes": "_0x25b436",
        "balances": "_0xd411c1",
        "_partner": "_0xa306de",
        "_spender": "_0x0afcad",
        "animator": "_0xa0fb6f",
        "blockNum": "_0x874e98",
        "hashNext": "_0x8c5d6d",
        "decimals": "_0x0d031f",
        "resetBet": "_0xb3e301",
        "betPrize": "_0x9f515d",
        "investor": "_0x5ff9d6",
        "hotStore": "_0x8f9c92",
        "hashLast": "_0x77da97",
        "_amount": "_0x8bb0da",
        "_player": "_0x3b24fe",
        "bethash": "_0xbe71b4",
        "spender": "_0x74cdfc",
        "wallets": "_0xbb635b",
        "allowed": "_0x8c43bd",
        "putHash": "_0x08984d",
        "_maxsum": "_0xa9179b",
        "matches": "_0x16c91a",
        "betsize": "_0x347c7a",
        "approve": "_0xffa7ee",
        "betHash": "_0x97303b",
        "partner": "_0x2deeb7",
        "getHash": "_0x33220f",
        "maxWin": "_0x94fd53",
        "hashes": "_0x1a32bb",
        "_delta": "_0xf934c6",
        "_value": "_0xe9d1c3",
        "amount": "_0x99f5a4",
        "_owner": "_0xdf9c3b",
        "_lastb": "_0x575497",
        "period": "_0xa97ed5",
        "symbol": "_0x1ddfae",
        "_block": "_0xbaf8a4",
        "maxpay": "_0x777c1d",
        "player": "_0x92c938",
        "invest": "_0xfb3d16",
        "share": "_0xf46cf2",
        "_from": "_0x5ac2c0",
        "slotp": "_0xa5de0f",
        "_sadd": "_0xcc1362",
        "_hash": "_0xe1dc91",
        "_when": "_0x6d83e4",
        "prize": "_0x98bd70",
        "betOf": "_0x580e61",
        "owner": "_0x693dcf",
        "lastb": "_0xe8caab",
        "delta": "_0xd93a4b",
        "size": "_0xe1408f",
        "_who": "_0xe44510",
        "bets": "_0x271dc6",
        "sha3": "_0xac9bc8",
        "play": "_0x7b5d19",
        "last": "_0xd30607",
        "_num": "_0x52f91f",
        "name": "_0xd71237",
        "hash": "_0x7eb45a",
        "add": "_0xb56b30",
        "fee": "_0x535826",
        "hit": "_0xe1e55c",
        "sub": "_0xa14212",
        "_to": "_0x1ac0d7",
        "won": "_0x98c654",
        "pay": "_0xbe49fc",
        "who": "_0x1e3d9e",
        "num": "_0x4db6bb",
        "to": "_0xe86f5e"
      },
      "changes": [
        "Renamed 126 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_001",
      "transformed_id": "ss_l2_hex_sn_gs_001",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title GovernanceHYBR (gHYBR)\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\n */\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Lock period for new deposits (configurable between 12-24 hours)\n    uint256 public _0x896d61 = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public _0xafe2e7 = 1200; // 5days\n    uint256 public _0x469e24 = 300; // 1day\n\n    // Withdraw fee configuration (basis points, 10000 = 100%)\n    uint256 public _0xef6dd5 = 100; // 1% default fee\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\n    uint256 public constant BASIS = 10000;\n    address public Team; // Address to receive fees\n    uint256 public _0xc3c335;\n    uint256 public _0xa17052;\n    uint256 public _0x13b475;\n    // User deposit tracking for transfer locks\n    struct UserLock {\n        uint256 _0x9d7941;\n        uint256 _0xed88a6;\n    }\n\n    mapping(address => UserLock[]) public _0x589d57;\n    mapping(address => uint256) public _0xfd6c74;\n\n    // Core contracts\n    address public immutable HYBR;\n    address public immutable _0x876420;\n    address public _0x8cf035;\n    address public _0xdf3040;\n    address public _0xab0b76;\n    uint256 public _0x26eb90; // The veNFT owned by this contract\n\n    // Auto-voting strategy\n    address public _0x6bc69b; // Address that can manage voting strategy\n    uint256 public _0x981cfe; // Last epoch when we voted\n\n    // Reward tracking\n    uint256 public _0x9b15a4;\n    uint256 public _0x8a8ab8;\n\n    // Swap module\n    ISwapper public _0xcc1560;\n\n    // Errors\n    error NOT_AUTHORIZED();\n\n    // Events\n    event Deposit(address indexed _0x8f6438, uint256 _0x0f531d, uint256 _0xf6a9e8);\n    event Withdraw(address indexed _0x8f6438, uint256 _0xc60cef, uint256 _0x0f531d, uint256 _0x808947);\n    event Compound(uint256 _0x59b725, uint256 _0x3dda35);\n    event PenaltyRewardReceived(uint256 _0x9d7941);\n    event TransferLockPeriodUpdated(uint256 _0x96ed26, uint256 _0x0d2096);\n    event SwapperUpdated(address indexed _0xf4dfec, address indexed _0xc7ef1b);\n    event VoterSet(address _0x8cf035);\n    event EmergencyUnlock(address indexed _0x8f6438);\n    event AutoVotingEnabled(bool _0x7fe8f2);\n    event OperatorUpdated(address indexed _0x3f1d81, address indexed _0xc7e162);\n    event DefaultVotingStrategyUpdated(address[] _0x716516, uint256[] _0x874246);\n    event AutoVoteExecuted(uint256 _0x9bc303, address[] _0x716516, uint256[] _0x874246);\n\n    constructor(\n        address _0xf51267,\n        address _0xb3c4f7\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_0xf51267 != address(0), \"Invalid HYBR\");\n        require(_0xb3c4f7 != address(0), \"Invalid VE\");\n\n        HYBR = _0xf51267;\n        _0x876420 = _0xb3c4f7;\n        _0x9b15a4 = block.timestamp;\n        _0x8a8ab8 = block.timestamp;\n        _0x6bc69b = msg.sender; // Initially set deployer as operator\n    }\n\n    function _0x35359b(address _0xc38516) external _0x92cc6e {\n        require(_0xc38516 != address(0), \"Invalid rewards distributor\");\n        _0xdf3040 = _0xc38516;\n    }\n\n    function _0xfbadde(address _0x692940) external _0x92cc6e {\n        require(_0x692940 != address(0), \"Invalid gauge manager\");\n        _0xab0b76 = _0x692940;\n    }\n\n      /**\n     * @notice Modifier to check authorization (owner or operator)\n     */\n    modifier _0xc38ce8() {\n        if (msg.sender != _0x6bc69b) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n    /**\n     * @notice Deposit HYBR and receive gHYBR shares\n     * @param amount Amount of HYBR to deposit\n     * @param recipient Recipient of gHYBR shares\n     */\n    function _0x3f0033(uint256 _0x9d7941, address _0x6c2c37) external _0xe6a668 {\n        require(_0x9d7941 > 0, \"Zero amount\");\n        _0x6c2c37 = _0x6c2c37 == address(0) ? msg.sender : _0x6c2c37;\n\n        // Transfer HYBR from user first\n        IERC20(HYBR)._0xe9b6dc(msg.sender, address(this), _0x9d7941);\n\n        // Initialize veNFT on first deposit\n        if (_0x26eb90 == 0) {\n            _0x4011c6(_0x9d7941);\n        } else {\n            // Add to existing veNFT\n            IERC20(HYBR)._0xa7770b(_0x876420, _0x9d7941);\n            IVotingEscrow(_0x876420)._0x9cbd13(_0x26eb90, _0x9d7941);\n\n            // Extend lock to maximum duration\n            _0xd565bf();\n        }\n\n        // Calculate shares to mint based on current totalAssets\n        uint256 _0xc60cef = _0xafb309(_0x9d7941);\n\n        // Mint gHYBR shares\n        _0x404ec1(_0x6c2c37, _0xc60cef);\n\n        // Add transfer lock for recipient\n        _0xba2be1(_0x6c2c37, _0xc60cef);\n\n        emit Deposit(msg.sender, _0x9d7941, _0xc60cef);\n    }\n\n    /**\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\n     * @param shares Amount of gHYBR shares to burn\n     * @return userTokenId The ID of the new veNFT created for the user\n     */\n    function _0x178f1d(uint256 _0xc60cef) external _0xe6a668 returns (uint256 _0xb12741) {\n        require(_0xc60cef > 0, \"Zero shares\");\n        require(_0x3a6d79(msg.sender) >= _0xc60cef, \"Insufficient balance\");\n        require(_0x26eb90 != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(_0x876420)._0xc25d10(_0x26eb90) == false, \"Cannot withdraw yet\");\n\n        uint256 _0x99616b = HybraTimeLibrary._0x99616b(block.timestamp);\n        uint256 _0x3c729a = HybraTimeLibrary._0x3c729a(block.timestamp);\n\n        require(block.timestamp >= _0x99616b + _0xafe2e7 && block.timestamp < _0x3c729a - _0x469e24, \"Cannot withdraw yet\");\n\n        // Calculate proportional HYBR amount from veNFT\n        uint256 _0x0f531d = _0x5e453b(_0xc60cef);\n        require(_0x0f531d > 0, \"No assets to withdraw\");\n\n        // Calculate fee amount (from the HYBR amount, not shares)\n        uint256 _0x11323e = 0;\n        if (_0xef6dd5 > 0) {\n            _0x11323e = (_0x0f531d * _0xef6dd5) / BASIS;\n        }\n\n        // User receives amount minus fee\n        uint256 _0x89166a = _0x0f531d - _0x11323e;\n        require(_0x89166a > 0, \"Amount too small after fee\");\n\n        // Get actual HYBR locked amount (not voting power)\n        uint256 _0x7e8925 = _0x7acd1f();\n        require(_0x0f531d <= _0x7e8925, \"Insufficient veNFT balance\");\n\n        uint256 _0x384ac4 = _0x7e8925 - _0x89166a - _0x11323e;\n        require(_0x384ac4 >= 0, \"Cannot withdraw entire veNFT\");\n\n        // Burn gHYBR shares (full amount)\n        _0x6dc4c2(msg.sender, _0xc60cef);\n\n        // Use multiSplit to create two NFTs: one for user, one for contract\n        uint256[] memory _0x9994a3 = new uint256[](3);\n        _0x9994a3[0] = _0x384ac4; // Amount staying with gHYBR\n        _0x9994a3[1] = _0x89166a;      // Amount going to user (after fee)\n        _0x9994a3[2] = _0x11323e;      // Amount going to fee recipient\n\n        uint256[] memory _0xeeb293 = IVotingEscrow(_0x876420)._0x546e37(_0x26eb90, _0x9994a3);\n\n        // Update contract's veTokenId to the first new token\n        _0x26eb90 = _0xeeb293[0];\n        _0xb12741 = _0xeeb293[1];\n        uint256 _0xda55b4 = _0xeeb293[2];\n        // Note: userTokenId is transferred to user, they can manage their own lock time\n        IVotingEscrow(_0x876420)._0x23bf9a(address(this), msg.sender, _0xb12741);\n        IVotingEscrow(_0x876420)._0x23bf9a(address(this), Team, _0xda55b4);\n        emit Withdraw(msg.sender, _0xc60cef, _0x89166a, _0x11323e);\n    }\n\n    /**\n     * @notice Internal function to initialize veNFT on first deposit\n     */\n    function _0x4011c6(uint256 _0xb55b53) internal {\n        // Create max lock with the initial deposit amount\n        IERC20(HYBR)._0xa7770b(_0x876420, type(uint256)._0x6e001f);\n        uint256 _0x3b0dc6 = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n        // Create lock with initial amount\n        _0x26eb90 = IVotingEscrow(_0x876420)._0x17e7b3(_0xb55b53, _0x3b0dc6, address(this));\n\n    }\n\n    /**\n     * @notice Calculate shares to mint based on deposit amount\n     */\n    function _0xafb309(uint256 _0x9d7941) public view returns (uint256) {\n        uint256 _0x3e20c3 = _0x4b258c();\n        uint256 _0x4e726c = _0x7acd1f();\n        if (_0x3e20c3 == 0 || _0x4e726c == 0) {\n            return _0x9d7941;\n        }\n        return (_0x9d7941 * _0x3e20c3) / _0x4e726c;\n    }\n\n    /**\n     * @notice Calculate HYBR value of shares\n     */\n    function _0x5e453b(uint256 _0xc60cef) public view returns (uint256) {\n        uint256 _0x3e20c3 = _0x4b258c();\n        if (_0x3e20c3 == 0) {\n            return _0xc60cef;\n        }\n        return (_0xc60cef * _0x7acd1f()) / _0x3e20c3;\n    }\n\n    /**\n     * @notice Get total assets (HYBR) locked in veNFT\n     * @dev Returns actual HYBR amount, not voting power\n     */\n    function _0x7acd1f() public view returns (uint256) {\n        if (_0x26eb90 == 0) {\n            return 0;\n        }\n        // Get actual locked HYBR amount, not voting power\n        IVotingEscrow.LockedBalance memory _0xe35423 = IVotingEscrow(_0x876420)._0xe35423(_0x26eb90);\n        return uint256(int256(_0xe35423._0x9d7941));\n    }\n\n    /**\n     * @notice Add transfer lock for new deposits\n     */\n    function _0xba2be1(address _0x8f6438, uint256 _0x9d7941) internal {\n        uint256 _0xed88a6 = block.timestamp + _0x896d61;\n        _0x589d57[_0x8f6438].push(UserLock({\n            _0x9d7941: _0x9d7941,\n            _0xed88a6: _0xed88a6\n        }));\n        _0xfd6c74[_0x8f6438] += _0x9d7941;\n    }\n\n    /**\n     * @notice Preview available balance (total - currently locked)\n     * @param user The user address to check\n     * @return available The current available balance for transfer\n     */\n    function _0x5bfb61(address _0x8f6438) external view returns (uint256 _0x74a013) {\n        uint256 _0x439c16 = _0x3a6d79(_0x8f6438);\n        uint256 _0x6202a4 = 0;\n\n        UserLock[] storage _0xd429db = _0x589d57[_0x8f6438];\n        for (uint256 i = 0; i < _0xd429db.length; i++) {\n            if (_0xd429db[i]._0xed88a6 > block.timestamp) {\n                _0x6202a4 += _0xd429db[i]._0x9d7941;\n            }\n        }\n\n        return _0x439c16 > _0x6202a4 ? _0x439c16 - _0x6202a4 : 0;\n    }\n    /**\n     * @notice Clean expired locks and update locked balance\n     * @param user The user address to clean locks for\n     * @return freed The amount of tokens freed from expired locks\n     */\n    function _0xda306e(address _0x8f6438) internal returns (uint256 _0x7e85da) {\n        UserLock[] storage _0xd429db = _0x589d57[_0x8f6438];\n        uint256 _0xdce897 = _0xd429db.length;\n        if (_0xdce897 == 0) return 0;\n\n        uint256 _0x03e8ab = 0;\n        unchecked {\n            for (uint256 i = 0; i < _0xdce897; i++) {\n                UserLock memory L = _0xd429db[i];\n                if (L._0xed88a6 <= block.timestamp) {\n                    _0x7e85da += L._0x9d7941;\n                } else {\n                    if (_0x03e8ab != i) _0xd429db[_0x03e8ab] = L;\n                    _0x03e8ab++;\n                }\n            }\n            if (_0x7e85da > 0) {\n                _0xfd6c74[_0x8f6438] -= _0x7e85da;\n            }\n            while (_0xd429db.length > _0x03e8ab) {\n                _0xd429db.pop();\n            }\n        }\n    }\n\n    /**\n     * @notice Override transfer to implement lock mechanism\n     */\n    function _0x5fcdea(\n        address from,\n        address _0xefb685,\n        uint256 _0x9d7941\n    ) internal override {\n        super._0x5fcdea(from, _0xefb685, _0x9d7941);\n\n        if (from != address(0) && _0xefb685 != address(0)) { // Not mint or burn\n            uint256 _0x439c16 = _0x3a6d79(from);\n\n            // Step 1: Check current available balance using cached lockedBalance\n            uint256 _0x377fec = _0x439c16 > _0xfd6c74[from] ? _0x439c16 - _0xfd6c74[from] : 0;\n\n            // Step 2: If current available >= amount, pass directly\n            if (_0x377fec >= _0x9d7941) {\n                return;\n            }\n\n            // Step 3: Not enough, clean expired locks and recalculate\n            _0xda306e(from);\n            uint256 _0xbae5d4 = _0x439c16 > _0xfd6c74[from] ? _0x439c16 - _0xfd6c74[from] : 0;\n\n            // Step 4: Check final available balance\n            require(_0xbae5d4 >= _0x9d7941, \"Tokens locked\");\n        }\n    }\n\n    /**\n     * @notice Claim all rewards from voting and rebase\n     */\n    function _0xdea582() external _0xc38ce8 {\n        require(_0x8cf035 != address(0), \"Voter not set\");\n        require(_0xdf3040 != address(0), \"Distributor not set\");\n\n        // Claim rebase rewards from RewardsDistributor\n        uint256  _0x7c0aba = IRewardsDistributor(_0xdf3040)._0x60639c(_0x26eb90);\n        _0xc3c335 += _0x7c0aba;\n        // Claim bribes from voted pools\n        address[] memory _0x902e8f = IVoter(_0x8cf035)._0xe62bb4(_0x26eb90);\n\n        for (uint256 i = 0; i < _0x902e8f.length; i++) {\n            if (_0x902e8f[i] != address(0)) {\n                address _0x99c6a4 = IGaugeManager(_0xab0b76)._0x433e8c(_0x902e8f[i]);\n\n                if (_0x99c6a4 != address(0)) {\n                    // Prepare arrays for single bribe claim\n                    address[] memory _0x403c24 = new address[](1);\n                    address[][] memory _0x506867 = new address[][](1);\n\n                    // Claim internal bribe (trading fees)\n                    address _0xf2d61e = IGaugeManager(_0xab0b76)._0x8705fb(_0x99c6a4);\n                    if (_0xf2d61e != address(0)) {\n                        uint256 _0x0d7a3a = IBribe(_0xf2d61e)._0xf2327a();\n                        if (_0x0d7a3a > 0) {\n                            address[] memory _0x2b6c81 = new address[](_0x0d7a3a);\n                            for (uint256 j = 0; j < _0x0d7a3a; j++) {\n                                _0x2b6c81[j] = IBribe(_0xf2d61e)._0x2b6c81(j);\n                            }\n                            _0x403c24[0] = _0xf2d61e;\n                            _0x506867[0] = _0x2b6c81;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0xab0b76)._0x4d3830(_0x403c24, _0x506867, _0x26eb90);\n                        }\n                    }\n\n                    // Claim external bribe\n                    address _0x461f97 = IGaugeManager(_0xab0b76)._0xccf906(_0x99c6a4);\n                    if (_0x461f97 != address(0)) {\n                        uint256 _0x0d7a3a = IBribe(_0x461f97)._0xf2327a();\n                        if (_0x0d7a3a > 0) {\n                            address[] memory _0x2b6c81 = new address[](_0x0d7a3a);\n                            for (uint256 j = 0; j < _0x0d7a3a; j++) {\n                                _0x2b6c81[j] = IBribe(_0x461f97)._0x2b6c81(j);\n                            }\n                            _0x403c24[0] = _0x461f97;\n                            _0x506867[0] = _0x2b6c81;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0xab0b76)._0x4d3830(_0x403c24, _0x506867, _0x26eb90);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Execute swap through the configured swapper module\n     * @param _params Swap parameters for the swapper module\n     */\n    function _0x099db4(ISwapper.SwapParams calldata _0xeffda0) external _0xe6a668 _0xc38ce8 {\n        require(address(_0xcc1560) != address(0), \"Swapper not set\");\n\n        // Get token balance before swap\n        uint256 _0x5e4a25 = IERC20(_0xeffda0._0xf43233)._0x3a6d79(address(this));\n        require(_0x5e4a25 >= _0xeffda0._0x790e7e, \"Insufficient token balance\");\n\n        // Approve swapper to spend tokens\n        IERC20(_0xeffda0._0xf43233)._0x6e7eb1(address(_0xcc1560), _0xeffda0._0x790e7e);\n\n        // Execute swap through swapper module\n        uint256 _0xe2774e = _0xcc1560._0x17d4f4(_0xeffda0);\n\n        // Reset approval for safety\n        IERC20(_0xeffda0._0xf43233)._0x6e7eb1(address(_0xcc1560), 0);\n\n        // HYBR is now in this contract, ready for compounding\n        _0x13b475 += _0xe2774e;\n    }\n\n    /**\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\n     */\n    function _0xd10886() external _0xc38ce8 {\n\n        // Get current HYBR balance\n        uint256 _0x1956f9 = IERC20(HYBR)._0x3a6d79(address(this));\n\n        if (_0x1956f9 > 0) {\n            // Lock all HYBR to existing veNFT\n            IERC20(HYBR)._0x6e7eb1(_0x876420, _0x1956f9);\n            IVotingEscrow(_0x876420)._0x9cbd13(_0x26eb90, _0x1956f9);\n\n            // Extend lock to maximum duration\n            _0xd565bf();\n\n            _0x8a8ab8 = block.timestamp;\n\n            emit Compound(_0x1956f9, _0x7acd1f());\n        }\n    }\n\n    /**\n     * @notice Vote for gauges using the veNFT\n     * @param _poolVote Array of pools to vote for\n     * @param _weights Array of weights for each pool\n     */\n    function _0xbcf658(address[] calldata _0x7ea76c, uint256[] calldata _0xd3c00e) external {\n        require(msg.sender == _0xe98e42() || msg.sender == _0x6bc69b, \"Not authorized\");\n        require(_0x8cf035 != address(0), \"Voter not set\");\n\n        IVoter(_0x8cf035)._0xbcf658(_0x26eb90, _0x7ea76c, _0xd3c00e);\n        _0x981cfe = HybraTimeLibrary._0x99616b(block.timestamp);\n\n    }\n\n    /**\n     * @notice Reset votes\n     */\n    function _0x74f8af() external {\n        require(msg.sender == _0xe98e42() || msg.sender == _0x6bc69b, \"Not authorized\");\n        require(_0x8cf035 != address(0), \"Voter not set\");\n\n        IVoter(_0x8cf035)._0x74f8af(_0x26eb90);\n    }\n\n    /**\n     * @notice Receive penalty rewards from rHYBR conversions\n     */\n    function _0xf4a64a(uint256 _0x9d7941) external {\n\n        // Auto-compound penalty rewards to existing veNFT\n        if (_0x9d7941 > 0) {\n            IERC20(HYBR)._0xa7770b(_0x876420, _0x9d7941);\n\n            if(_0x26eb90 == 0){\n                _0x4011c6(_0x9d7941);\n            } else{\n                IVotingEscrow(_0x876420)._0x9cbd13(_0x26eb90, _0x9d7941);\n\n                // Extend lock to maximum duration\n                _0xd565bf();\n            }\n        }\n        _0xa17052 += _0x9d7941;\n        emit PenaltyRewardReceived(_0x9d7941);\n    }\n\n    /**\n     * @notice Set the voter contract\n     */\n    function _0x3ee376(address _0x6371cc) external _0x92cc6e {\n        require(_0x6371cc != address(0), \"Invalid voter\");\n        _0x8cf035 = _0x6371cc;\n        emit VoterSet(_0x6371cc);\n    }\n\n    /**\n     * @notice Update transfer lock period\n     */\n    function _0xfbd70a(uint256 _0x401e9e) external _0x92cc6e {\n        require(_0x401e9e >= MIN_LOCK_PERIOD && _0x401e9e <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 _0x96ed26 = _0x896d61;\n        _0x896d61 = _0x401e9e;\n        emit TransferLockPeriodUpdated(_0x96ed26, _0x401e9e);\n    }\n\n    /**\n     * @notice Set withdraw fee (in basis points)\n     * @param _fee Fee amount (10-30 basis points)\n     */\n    function _0xf7df47(uint256 _0x8f3bb2) external _0x92cc6e {\n        require(_0x8f3bb2 >= MIN_WITHDRAW_FEE && _0x8f3bb2 <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        _0xef6dd5 = _0x8f3bb2;\n    }\n\n    function _0x8795f8(uint256 _0x1d0043) external _0x92cc6e {\n        _0xafe2e7 = _0x1d0043;\n    }\n\n    function _0xe4622a(uint256 _0x1d0043) external _0x92cc6e {\n        _0x469e24 = _0x1d0043;\n    }\n\n    /**\n     * @notice Set the swapper module\n     * @param _swapper Address of the swapper module\n     */\n    function _0x2d51ae(address _0xea20e2) external _0x92cc6e {\n        require(_0xea20e2 != address(0), \"Invalid swapper\");\n        address _0xf4dfec = address(_0xcc1560);\n        _0xcc1560 = ISwapper(_0xea20e2);\n        emit SwapperUpdated(_0xf4dfec, _0xea20e2);\n    }\n\n    /**\n     * @notice Set the team address\n     */\n    function _0x75c5d7(address _0xd1d947) external _0x92cc6e {\n        require(_0xd1d947 != address(0), \"Invalid team\");\n        Team = _0xd1d947;\n    }\n\n    /**\n     * @notice Emergency unlock for a user (owner only)\n     */\n    function _0x0e8156(address _0x8f6438) external _0xc38ce8 {\n        delete _0x589d57[_0x8f6438];\n        _0xfd6c74[_0x8f6438] = 0;\n        emit EmergencyUnlock(_0x8f6438);\n    }\n\n    /**\n     * @notice Get user's locks info\n     */\n    function _0x2cb4d0(address _0x8f6438) external view returns (UserLock[] memory) {\n        return _0x589d57[_0x8f6438];\n    }\n\n    /**\n     * @notice Set operator address\n     */\n    function _0xa34313(address _0x9ac460) external _0x92cc6e {\n        require(_0x9ac460 != address(0), \"Invalid operator\");\n        address _0x3f1d81 = _0x6bc69b;\n        _0x6bc69b = _0x9ac460;\n        emit OperatorUpdated(_0x3f1d81, _0x9ac460);\n    }\n\n    /**\n     * @notice Get veNFT lock end time\n     */\n    function _0x841920() external view returns (uint256) {\n        if (_0x26eb90 == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory _0xe35423 = IVotingEscrow(_0x876420)._0xe35423(_0x26eb90);\n        return uint256(_0xe35423._0x71bf9e);\n    }\n\n    /**\n     * @notice Internal helper to safely extend lock to maximum duration\n     * @dev Calculates exact duration needed to reach max allowed unlock time\n     */\n    function _0xd565bf() internal {\n        if (_0x26eb90 == 0) return;\n\n        IVotingEscrow.LockedBalance memory _0xe35423 = IVotingEscrow(_0x876420)._0xe35423(_0x26eb90);\n        if (_0xe35423._0x3aeeab || _0xe35423._0x71bf9e <= block.timestamp) return;\n\n        uint256 _0x964768 = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n        // Only extend if difference is more than 2 hours\n        if (_0x964768 > _0xe35423._0x71bf9e + 2 hours) {\n            try IVotingEscrow(_0x876420)._0xe8c4b1(_0x26eb90, HybraTimeLibrary.MAX_LOCK_DURATION) {\n                // Extension successful\n            } catch {\n                // Extension failed, continue without error\n                // This can happen if already at max possible time or other constraints\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setHeadNotWithdrawTime": "_0x8795f8",
        "tail_not_withdraw_time": "_0x469e24",
        "head_not_withdraw_time": "_0xafe2e7",
        "setTailNotWithdrawTime": "_0xe4622a",
        "setTransferLockPeriod": "_0xfbd70a",
        "setRewardsDistributor": "_0x35359b",
        "increase_unlock_time": "_0xe8c4b1",
        "receivePenaltyReward": "_0xf4a64a",
        "_beforeTokenTransfer": "_0x5fcdea",
        "_rewardsDistributor": "_0xc38516",
        "rewardsDistributor": "_0xdf3040",
        "transferLockPeriod": "_0x896d61",
        "rewardsListLength": "_0xf2327a",
        "safeTransferFrom": "_0x23bf9a",
        "_extendLockToMax": "_0xd565bf",
        "_addTransferLock": "_0xba2be1",
        "_initializeVeNFT": "_0x4011c6",
        "lastCompoundTime": "_0x8a8ab8",
        "previewAvailable": "_0x5bfb61",
        "currentAvailable": "_0x377fec",
        "create_lock_for": "_0x17e7b3",
        "calculateAssets": "_0x5e453b",
        "external_bribes": "_0xccf906",
        "calculateShares": "_0xafb309",
        "setGaugeManager": "_0xfbadde",
        "internal_bribes": "_0x8705fb",
        "emergencyUnlock": "_0x0e8156",
        "remainingAmount": "_0x384ac4",
        "newTotalLocked": "_0x3dda35",
        "finalAvailable": "_0xbae5d4",
        "sharesReceived": "_0xf6a9e8",
        "setWithdrawFee": "_0xf7df47",
        "lastRebaseTime": "_0x9b15a4",
        "getLockEndTime": "_0x841920",
        "initialAmount": "_0xb55b53",
        "externalBribe": "_0x461f97",
        "_cleanExpired": "_0xda306e",
        "_gaugeManager": "_0x692940",
        "lastVoteEpoch": "_0x981cfe",
        "_votingEscrow": "_0xb3c4f7",
        "currentLocked": "_0x6202a4",
        "internalBribe": "_0xf2d61e",
        "lockedBalance": "_0xfd6c74",
        "maxUnlockTime": "_0x964768",
        "hybrReceived": "_0xe2774e",
        "tokenBalance": "_0x5e4a25",
        "votingEscrow": "_0x876420",
        "_totalAssets": "_0x4e726c",
        "nonReentrant": "_0xe6a668",
        "rebaseAmount": "_0x7c0aba",
        "totalBalance": "_0x439c16",
        "getUserLocks": "_0x2cb4d0",
        "onlyOperator": "_0xc38ce8",
        "_totalSupply": "_0x3e20c3",
        "gaugeManager": "_0xab0b76",
        "transferFrom": "_0xe9b6dc",
        "claimRewards": "_0xdea582",
        "oldOperator": "_0x3f1d81",
        "newTokenIds": "_0xeeb293",
        "hybrBalance": "_0x1956f9",
        "votingYield": "_0x13b475",
        "isPermanent": "_0x3aeeab",
        "withdrawFee": "_0xef6dd5",
        "executeSwap": "_0x099db4",
        "totalAssets": "_0x7acd1f",
        "userTokenId": "_0xb12741",
        "deposit_for": "_0x9cbd13",
        "totalSupply": "_0x4b258c",
        "setOperator": "_0xa34313",
        "claimBribes": "_0x4d3830",
        "newOperator": "_0xc7e162",
        "bribeTokens": "_0x2b6c81",
        "safeApprove": "_0x6e7eb1",
        "unlockTime": "_0xed88a6",
        "epochStart": "_0x99616b",
        "setSwapper": "_0x2d51ae",
        "multiSplit": "_0x546e37",
        "votedPools": "_0x902e8f",
        "feeTokenId": "_0xda55b4",
        "swapToHYBR": "_0x17d4f4",
        "newSwapper": "_0xc7ef1b",
        "hybrAmount": "_0x0f531d",
        "tokenCount": "_0x0d7a3a",
        "oldSwapper": "_0xf4dfec",
        "userAmount": "_0x89166a",
        "_poolVote": "_0x7ea76c",
        "available": "_0x74a013",
        "veTokenId": "_0x26eb90",
        "veBalance": "_0x7e8925",
        "_operator": "_0x9ac460",
        "userLocks": "_0x589d57",
        "oldPeriod": "_0x96ed26",
        "onlyOwner": "_0x92cc6e",
        "recipient": "_0x6c2c37",
        "newPeriod": "_0x0d2096",
        "balanceOf": "_0x3a6d79",
        "epochNext": "_0x3c729a",
        "feeAmount": "_0x11323e",
        "_swapper": "_0xea20e2",
        "setVoter": "_0x3ee376",
        "compound": "_0xd10886",
        "operator": "_0x6bc69b",
        "_weights": "_0xd3c00e",
        "withdraw": "_0x178f1d",
        "amountIn": "_0x790e7e",
        "poolVote": "_0xe62bb4",
        "lockTime": "_0x3b0dc6",
        "_params": "_0xeffda0",
        "tokenIn": "_0xf43233",
        "rewards": "_0x59b725",
        "setTeam": "_0x75c5d7",
        "penalty": "_0xa17052",
        "amounts": "_0x9994a3",
        "deposit": "_0x3f0033",
        "_period": "_0x401e9e",
        "approve": "_0xa7770b",
        "swapper": "_0xcc1560",
        "enabled": "_0x7fe8f2",
        "weights": "_0x874246",
        "rebase": "_0xc3c335",
        "locked": "_0xe35423",
        "amount": "_0x9d7941",
        "_voter": "_0x6371cc",
        "bribes": "_0x403c24",
        "shares": "_0xc60cef",
        "tokens": "_0x506867",
        "gauges": "_0x433e8c",
        "gauge": "_0x99c6a4",
        "write": "_0x03e8ab",
        "claim": "_0x60639c",
        "_burn": "_0x6dc4c2",
        "voter": "_0x8cf035",
        "voted": "_0xc25d10",
        "_time": "_0x1d0043",
        "reset": "_0x74f8af",
        "freed": "_0x7e85da",
        "_team": "_0xd1d947",
        "pools": "_0x716516",
        "_HYBR": "_0xf51267",
        "owner": "_0xe98e42",
        "_mint": "_0x404ec1",
        "epoch": "_0x9bc303",
        "vote": "_0xbcf658",
        "user": "_0x8f6438",
        "_fee": "_0x8f3bb2",
        "arr": "_0xd429db",
        "fee": "_0x808947",
        "end": "_0x71bf9e",
        "len": "_0xdce897",
        "max": "_0x6e001f",
        "to": "_0xefb685"
      },
      "changes": [
        "Renamed 151 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_002",
      "transformed_id": "ss_l2_hex_sn_gs_002",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\n\nimport \"./interfaces/ICLFactory.sol\";\nimport \"./interfaces/fees/IFeeModule.sol\";\n\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/IFactoryRegistry.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@nomad-xyz/src/ExcessivelySafeCall.sol\";\nimport \"./CLPool.sol\";\n\n/// @title Canonical CL factory\n/// @notice Deploys CL pools and manages ownership and control over pool protocol fees\ncontract CLFactory is ICLFactory {\n    using ExcessivelySafeCall for address;\n\n    /// @inheritdoc ICLFactory\n    IGaugeManager public override _0x66fc68;\n    /// @inheritdoc ICLFactory\n    address public immutable override _0xd5ab7d;\n    /// @inheritdoc ICLFactory\n    address public override _0x9fccd8;\n    /// @inheritdoc ICLFactory\n    address public override _0x23fb19;\n    /// @inheritdoc ICLFactory\n    address public override _0x85370d;\n    /// @inheritdoc ICLFactory\n    address public override _0xd02af4;\n    /// @inheritdoc ICLFactory\n    address public override _0xf27de2;\n    /// @inheritdoc ICLFactory\n    uint24 public override _0x05ce2a;\n    /// @inheritdoc ICLFactory\n\n    address public override _0x8ededc;\n    /// @inheritdoc ICLFactory\n    address public override _0xcd29dc;\n    /// @inheritdoc ICLFactory\n    uint24 public override _0x4251d1;\n\n    mapping(int24 => uint24) public override _0xe2e0cc;\n    /// @inheritdoc ICLFactory\n    mapping(address => mapping(address => mapping(int24 => address))) public override _0x4ccfc4;\n    /// @dev Used in VotingEscrow to determine if a contract is a valid pool\n    mapping(address => bool) private _0x18fec2;\n    /// @inheritdoc ICLFactory\n    address[] public override _0x2081c6;\n\n    int24[] private _0xd061ba;\n\n    constructor(address _0x8bccba) {\n        _0x9fccd8 = msg.sender;\n        _0x23fb19 = msg.sender;\n        _0xd02af4 = msg.sender;\n        _0x8ededc = msg.sender;\n        _0xd5ab7d = _0x8bccba;\n        _0x05ce2a = 100_000;\n        _0x4251d1 = 250_000;\n        emit OwnerChanged(address(0), msg.sender);\n        emit SwapFeeManagerChanged(address(0), msg.sender);\n        emit UnstakedFeeManagerChanged(address(0), msg.sender);\n        emit DefaultUnstakedFeeChanged(0, 100_000);\n\n        _0xbea492(1, 100);\n        _0xbea492(50, 500);\n        _0xbea492(100, 500);\n        _0xbea492(200, 3_000);\n        _0xbea492(2_000, 10_000);\n    }\n\n    function _0xb885fe(address _0x16e05a) external {\n        require(msg.sender == _0x9fccd8);\n        _0x66fc68 = IGaugeManager(_0x16e05a);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xaeb813(address _0x6dcf3a, address _0xc0bce5, int24 _0x4b503c, uint160 _0x0fc75a)\n        external\n        override\n        returns (address _0xfd2625)\n    {\n        require(_0x6dcf3a != _0xc0bce5);\n        (address _0xae46c7, address _0xa0a8bb) = _0x6dcf3a < _0xc0bce5 ? (_0x6dcf3a, _0xc0bce5) : (_0xc0bce5, _0x6dcf3a);\n        require(_0xae46c7 != address(0));\n        require(_0xe2e0cc[_0x4b503c] != 0);\n        require(_0x4ccfc4[_0xae46c7][_0xa0a8bb][_0x4b503c] == address(0));\n        _0xfd2625 = Clones._0xe56a9d({\n            _0xd0fd64: _0xd5ab7d,\n            _0xa5becc: _0xc985f1(abi._0xc7d1c6(_0xae46c7, _0xa0a8bb, _0x4b503c))\n        });\n        CLPool(_0xfd2625)._0x3d86c8({\n            _0xc7eddc: address(this),\n            _0x44980e: _0xae46c7,\n            _0xf0e9c6: _0xa0a8bb,\n            _0x09f791: _0x4b503c,\n            _0x16e05a: address(_0x66fc68),\n            _0x4cd60a: _0x0fc75a\n        });\n        _0x2081c6.push(_0xfd2625);\n        _0x18fec2[_0xfd2625] = true;\n        _0x4ccfc4[_0xae46c7][_0xa0a8bb][_0x4b503c] = _0xfd2625;\n        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses\n        _0x4ccfc4[_0xa0a8bb][_0xae46c7][_0x4b503c] = _0xfd2625;\n        emit PoolCreated(_0xae46c7, _0xa0a8bb, _0x4b503c, _0xfd2625);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xf286a1(address _0x17040a) external override {\n        address _0x06d683 = _0x9fccd8;\n        require(msg.sender == _0x06d683);\n        require(_0x17040a != address(0));\n        emit OwnerChanged(_0x06d683, _0x17040a);\n        _0x9fccd8 = _0x17040a;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x8c5bd7(address _0x1bd889) external override {\n        address _0x7b09e3 = _0x23fb19;\n        require(msg.sender == _0x7b09e3);\n        require(_0x1bd889 != address(0));\n        _0x23fb19 = _0x1bd889;\n        emit SwapFeeManagerChanged(_0x7b09e3, _0x1bd889);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xe74356(address _0xb17141) external override {\n        address _0x913af2 = _0xd02af4;\n        require(msg.sender == _0x913af2);\n        require(_0xb17141 != address(0));\n        _0xd02af4 = _0xb17141;\n        emit UnstakedFeeManagerChanged(_0x913af2, _0xb17141);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x1f6126(address _0x2dc5c6) external override {\n        require(msg.sender == _0x23fb19);\n        require(_0x2dc5c6 != address(0));\n        address _0x7a6b9c = _0x85370d;\n        _0x85370d = _0x2dc5c6;\n        emit SwapFeeModuleChanged(_0x7a6b9c, _0x2dc5c6);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xfb15e6(address _0x093d0e) external override {\n        require(msg.sender == _0xd02af4);\n        require(_0x093d0e != address(0));\n        address _0x7a6b9c = _0xf27de2;\n        _0xf27de2 = _0x093d0e;\n        emit UnstakedFeeModuleChanged(_0x7a6b9c, _0x093d0e);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x1f955d(uint24 _0xccb817) external override {\n        require(msg.sender == _0xd02af4);\n        require(_0xccb817 <= 500_000);\n        uint24 _0x42a12b = _0x05ce2a;\n        _0x05ce2a = _0xccb817;\n        emit DefaultUnstakedFeeChanged(_0x42a12b, _0xccb817);\n    }\n\n    function _0xa33716(address _0x737898) external override {\n        require(msg.sender == _0x8ededc);\n        require(_0x737898 != address(0));\n        _0xcd29dc = _0x737898;\n    }\n\n    function _0xf98658(address _0xc7920a) external override {\n        require(msg.sender == _0x8ededc);\n        require(_0xc7920a != address(0));\n        _0x8ededc = _0xc7920a;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xe55d73(address _0xfd2625) external view override returns (uint24) {\n        if (_0x85370d != address(0)) {\n            (bool _0xaef346, bytes memory data) = _0x85370d._0x9e2cf4(\n                200_000, 32, abi._0x239d04(IFeeModule._0xcdbc17.selector, _0xfd2625)\n            );\n            if (_0xaef346) {\n                uint24 _0xd4b4e9 = abi._0x3f0d86(data, (uint24));\n                if (_0xd4b4e9 <= 100_000) {\n                    return _0xd4b4e9;\n                }\n            }\n        }\n        return _0xe2e0cc[CLPool(_0xfd2625)._0x4b503c()];\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x3a3ab8(address _0xfd2625) external view override returns (uint24) {\n\n        if (!_0x66fc68._0xefa626(_0xfd2625)) {\n            return 0;\n        }\n        if (_0xf27de2 != address(0)) {\n            (bool _0xaef346, bytes memory data) = _0xf27de2._0x9e2cf4(\n                200_000, 32, abi._0x239d04(IFeeModule._0xcdbc17.selector, _0xfd2625)\n            );\n            if (_0xaef346) {\n                uint24 _0xd4b4e9 = abi._0x3f0d86(data, (uint24));\n                if (_0xd4b4e9 <= 1_000_000) {\n                    return _0xd4b4e9;\n                }\n            }\n        }\n        return _0x05ce2a;\n    }\n\n    function _0x7033e5(address _0xfd2625) external view override returns (uint24) {\n        // if the gauge is alive, return 0, protocol fee is only for inactive gauges\n        if (_0x66fc68._0xefa626(_0xfd2625)) {\n            return 0;\n        }\n\n        if (_0xcd29dc != address(0)) {\n            (bool _0xaef346, bytes memory data) = _0xcd29dc._0x9e2cf4(\n                200_000, 32, abi._0x239d04(IFeeModule._0xcdbc17.selector, _0xfd2625)\n            );\n            if (_0xaef346) {\n                uint24 _0xd4b4e9 = abi._0x3f0d86(data, (uint24));\n                if (_0xd4b4e9 <= 500_000) {\n                    return _0xd4b4e9;\n                }\n            }\n        }\n        return _0x4251d1;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xbea492(int24 _0x4b503c, uint24 _0xd4b4e9) public override {\n        require(msg.sender == _0x9fccd8);\n        require(_0xd4b4e9 > 0 && _0xd4b4e9 <= 100_000);\n        // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that\n\n        // 16384 ticks represents a >5x price change with ticks of 1 bips\n        require(_0x4b503c > 0 && _0x4b503c < 16384);\n        require(_0xe2e0cc[_0x4b503c] == 0);\n\n        _0xe2e0cc[_0x4b503c] = _0xd4b4e9;\n        _0xd061ba.push(_0x4b503c);\n        emit TickSpacingEnabled(_0x4b503c, _0xd4b4e9);\n    }\n\n    function _0x5de042() external  {\n        require(msg.sender == _0x9fccd8);\n\n        for (uint256 i = 0; i < _0x2081c6.length; i++) {\n            CLPool(_0x2081c6[i])._0x879b1c(msg.sender);\n        }\n    }\n\n    function _0x879b1c(address _0xfd2625) external returns (uint128 _0x4541e4, uint128 _0x9e5078) {\n        require(msg.sender == _0x9fccd8);\n        (_0x4541e4, _0x9e5078) = CLPool(_0xfd2625)._0x879b1c(msg.sender);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x6dadcb() external view override returns (int24[] memory) {\n        return _0xd061ba;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xae0f6d() external view override returns (uint256) {\n        return _0x2081c6.length;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x3d7bab(address _0xfd2625) external view override returns (bool) {\n        return _0x18fec2[_0xfd2625];\n    }\n}",
      "rename_map": {
        "excessivelySafeStaticCall": "_0x9e2cf4",
        "cachedUnstakedFeeManager": "_0x913af2",
        "collectAllProtocolFees": "_0x5de042",
        "setUnstakedFeeManager": "_0xe74356",
        "setProtocolFeeManager": "_0xf98658",
        "setDefaultUnstakedFee": "_0x1f955d",
        "setUnstakedFeeModule": "_0xfb15e6",
        "cachedSwapFeeManager": "_0x7b09e3",
        "setProtocolFeeModule": "_0xa33716",
        "_protocolFeeManager": "_0xc7920a",
        "_unstakedFeeManager": "_0xb17141",
        "collectProtocolFees": "_0x879b1c",
        "isGaugeAliveForPool": "_0xefa626",
        "_defaultUnstakedFee": "_0xccb817",
        "_poolImplementation": "_0x8bccba",
        "unstakedFeeManager": "_0xd02af4",
        "protocolFeeManager": "_0x8ededc",
        "cloneDeterministic": "_0xe56a9d",
        "defaultProtocolFee": "_0x4251d1",
        "_unstakedFeeModule": "_0x093d0e",
        "_protocolFeeModule": "_0x737898",
        "defaultUnstakedFee": "_0x05ce2a",
        "poolImplementation": "_0xd5ab7d",
        "encodeWithSelector": "_0x239d04",
        "protocolFeeModule": "_0xcd29dc",
        "enableTickSpacing": "_0xbea492",
        "setSwapFeeManager": "_0x8c5bd7",
        "unstakedFeeModule": "_0xf27de2",
        "setSwapFeeModule": "_0x1f6126",
        "tickSpacingToFee": "_0xe2e0cc",
        "_swapFeeManager": "_0x1bd889",
        "setGaugeManager": "_0xb885fe",
        "getUnstakedFee": "_0x3a3ab8",
        "_swapFeeModule": "_0x2dc5c6",
        "swapFeeManager": "_0x23fb19",
        "allPoolsLength": "_0xae0f6d",
        "oldUnstakedFee": "_0x42a12b",
        "getProtocolFee": "_0x7033e5",
        "_gaugeManager": "_0x16e05a",
        "_sqrtPriceX96": "_0x4cd60a",
        "_tickSpacings": "_0xd061ba",
        "swapFeeModule": "_0x85370d",
        "oldFeeModule": "_0x7a6b9c",
        "tickSpacings": "_0x6dadcb",
        "_tickSpacing": "_0x09f791",
        "sqrtPriceX96": "_0x0fc75a",
        "gaugeManager": "_0x66fc68",
        "tickSpacing": "_0x4b503c",
        "cachedOwner": "_0x06d683",
        "createPool": "_0xaeb813",
        "getSwapFee": "_0xe55d73",
        "initialize": "_0x3d86c8",
        "keccak256": "_0xc985f1",
        "setOwner": "_0xf286a1",
        "_factory": "_0xc7eddc",
        "allPools": "_0x2081c6",
        "_isPool": "_0x18fec2",
        "amount0": "_0x4541e4",
        "_token1": "_0xf0e9c6",
        "_token0": "_0x44980e",
        "amount1": "_0x9e5078",
        "getPool": "_0x4ccfc4",
        "success": "_0xaef346",
        "token0": "_0xae46c7",
        "tokenA": "_0x6dcf3a",
        "master": "_0xd0fd64",
        "isPool": "_0x3d7bab",
        "tokenB": "_0xc0bce5",
        "_owner": "_0x17040a",
        "decode": "_0x3f0d86",
        "getFee": "_0xcdbc17",
        "token1": "_0xa0a8bb",
        "encode": "_0xc7d1c6",
        "owner": "_0x9fccd8",
        "salt": "_0xa5becc",
        "pool": "_0xfd2625",
        "fee": "_0xd4b4e9"
      },
      "changes": [
        "Renamed 77 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_003",
      "transformed_id": "ss_l2_hex_sn_gs_003",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport './interfaces/IPair.sol';\nimport './interfaces/IBribe.sol';\nimport \"./libraries/Math.sol\";\n\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport './interfaces/IRHYBR.sol';\ninterface IRewarder {\n    function _0x705e90(\n        address _0x677a35,\n        address _0xff61c4,\n        uint256 _0x5610c4\n    ) external;\n}\n\ncontract GaugeV2 is ReentrancyGuard, Ownable {\n\n    using SafeERC20 for IERC20;\n\n    bool public immutable _0x9c48d5;\n    bool public _0x6ca576;\n\n    IERC20 public immutable _0xe554e7;\n    IERC20 public immutable TOKEN;\n    address public immutable _0xf6237b;\n    address public VE;\n    address public DISTRIBUTION;\n    address public _0xf33612;\n    address public _0x0b49ce;\n    address public _0x2524ce;\n\n    uint256 public DURATION;\n    uint256 internal _0x3c01dc;\n    uint256 public _0x8a4b89;\n    uint256 public _0x65fe70;\n    uint256 public _0xca2567;\n\n    mapping(address => uint256) public _0xeedf3e;\n    mapping(address => uint256) public _0x7257dd;\n\n    uint256 internal _0xfbc3db;\n    mapping(address => uint256) internal _0x1f624e;\n    mapping(address => uint256) public _0xf90e6c;\n\n    event RewardAdded(uint256 _0x8aec4b);\n    event Deposit(address indexed _0x677a35, uint256 _0x957ead);\n    event Withdraw(address indexed _0x677a35, uint256 _0x957ead);\n    event Harvest(address indexed _0x677a35, uint256 _0x8aec4b);\n\n    event ClaimFees(address indexed from, uint256 _0xc220c0, uint256 _0x2519a7);\n    event EmergencyActivated(address indexed _0x29b729, uint256 timestamp);\n    event EmergencyDeactivated(address indexed _0x29b729, uint256 timestamp);\n\n    modifier _0x018025(address _0x647df5) {\n        _0xca2567 = _0xff6159();\n        _0x65fe70 = _0x79d2a4();\n        if (_0x647df5 != address(0)) {\n            _0x7257dd[_0x647df5] = _0xb0ccfb(_0x647df5);\n            _0xeedf3e[_0x647df5] = _0xca2567;\n        }\n        _;\n    }\n\n    modifier _0x8bfb96() {\n        require(msg.sender == DISTRIBUTION, \"NA\");\n        _;\n    }\n\n    modifier _0x038ae6() {\n        require(_0x6ca576 == false, \"EMER\");\n        _;\n    }\n\n    constructor(address _0x9cace0,address _0xd23796,address _0x421096,address _0xf32c5f,address _0xfac2fb, address _0x20ce35, address _0x538fd0, bool _0xf87d06) {\n        _0xe554e7 = IERC20(_0x9cace0);     // main reward\n        _0xf6237b = _0xd23796;\n        VE = _0x421096;                               // vested\n        TOKEN = IERC20(_0xf32c5f);                 // underlying (LP)\n        DISTRIBUTION = _0xfac2fb;           // distro address (GaugeManager)\n        DURATION = HybraTimeLibrary.WEEK;\n\n        _0x0b49ce = _0x20ce35;       // lp fees goes here\n        _0x2524ce = _0x538fd0;       // bribe fees goes here\n\n        _0x9c48d5 = _0xf87d06;                 // pair boolean, if false no claim_fees\n\n        _0x6ca576 = false;                      // emergency flag\n\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    ONLY OWNER\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    ///@notice set distribution address (should be GaugeManager)\n    function _0x8050f2(address _0xfac2fb) external _0xc6687b {\n        require(_0xfac2fb != address(0), \"ZA\");\n        require(_0xfac2fb != DISTRIBUTION, \"SAME_ADDR\");\n        DISTRIBUTION = _0xfac2fb;\n    }\n\n    ///@notice set gauge rewarder address\n    function _0x12ee66(address _0xd6ade4) external _0xc6687b {\n        require(_0xd6ade4 != _0xf33612, \"SAME_ADDR\");\n        _0xf33612 = _0xd6ade4;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function _0xe40d17(address _0xa0393c) external _0xc6687b {\n        require(_0xa0393c >= address(0), \"ZA\");\n        _0x0b49ce = _0xa0393c;\n    }\n\n    function _0x3660b8() external _0xc6687b {\n        require(_0x6ca576 == false, \"EMER\");\n        _0x6ca576 = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function _0x0b5f4c() external _0xc6687b {\n\n        require(_0x6ca576 == true,\"EMER\");\n\n        _0x6ca576 = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VIEW FUNCTIONS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    ///@notice total supply held\n    function _0x5ff905() public view returns (uint256) {\n        return _0xfbc3db;\n    }\n\n    ///@notice balance of a user\n    function _0xc54a0b(address _0x647df5) external view returns (uint256) {\n        return _0xbe1d42(_0x647df5);\n    }\n\n    function _0xbe1d42(address _0x647df5) internal view returns (uint256) {\n\n        return _0x1f624e[_0x647df5];\n    }\n\n    ///@notice last time reward\n    function _0x79d2a4() public view returns (uint256) {\n        return Math._0xf443cb(block.timestamp, _0x3c01dc);\n    }\n\n    ///@notice  reward for a sinle token\n    function _0xff6159() public view returns (uint256) {\n        if (_0xfbc3db == 0) {\n            return _0xca2567;\n        } else {\n            return _0xca2567 + (_0x79d2a4() - _0x65fe70) * _0x8a4b89 * 1e18 / _0xfbc3db;\n        }\n    }\n\n    ///@notice see earned rewards for user\n    function _0xb0ccfb(address _0x647df5) public view returns (uint256) {\n        return _0x7257dd[_0x647df5] + _0xbe1d42(_0x647df5) * (_0xff6159() - _0xeedf3e[_0x647df5]) / 1e18;\n    }\n\n    ///@notice get total reward for the duration\n    function _0x5d5c0d() external view returns (uint256) {\n        return _0x8a4b89 * DURATION;\n    }\n\n    function _0xa64f57() external view returns (uint256) {\n        return _0x3c01dc;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    // send whole liquidity as additional param\n\n    ///@notice deposit all TOKEN of msg.sender\n    function _0x1a17be() external {\n        _0x05c4cd(TOKEN._0xc54a0b(msg.sender), msg.sender);\n    }\n\n    ///@notice deposit amount TOKEN\n    function _0x294d1c(uint256 _0x957ead) external {\n        _0x05c4cd(_0x957ead, msg.sender);\n    }\n\n    ///@notice deposit internal\n    function _0x05c4cd(uint256 _0x957ead, address _0x647df5) internal _0x3b813f _0x038ae6 _0x018025(_0x647df5) {\n        require(_0x957ead > 0, \"ZV\");\n\n        _0x1f624e[_0x647df5] = _0x1f624e[_0x647df5] + _0x957ead;\n        _0xfbc3db = _0xfbc3db + _0x957ead;\n        if (address(_0xf33612) != address(0)) {\n            IRewarder(_0xf33612)._0x705e90(_0x647df5, _0x647df5, _0xbe1d42(_0x647df5));\n        }\n\n        TOKEN._0xd30d72(_0x647df5, address(this), _0x957ead);\n\n        emit Deposit(_0x647df5, _0x957ead);\n    }\n\n    ///@notice withdraw all token\n    function _0x88f737() external {\n        _0x59eee2(_0xbe1d42(msg.sender));\n    }\n\n    ///@notice withdraw a certain amount of TOKEN\n    function _0xba5475(uint256 _0x957ead) external {\n        _0x59eee2(_0x957ead);\n    }\n\n    ///@notice withdraw internal\n    function _0x59eee2(uint256 _0x957ead) internal _0x3b813f _0x038ae6 _0x018025(msg.sender) {\n        require(_0x957ead > 0, \"ZV\");\n        require(_0xbe1d42(msg.sender) > 0, \"ZV\");\n        require(block.timestamp >= _0xf90e6c[msg.sender], \"!MATURE\");\n\n        _0xfbc3db = _0xfbc3db - _0x957ead;\n        _0x1f624e[msg.sender] = _0x1f624e[msg.sender] - _0x957ead;\n\n        if (address(_0xf33612) != address(0)) {\n            IRewarder(_0xf33612)._0x705e90(msg.sender, msg.sender,_0xbe1d42(msg.sender));\n        }\n\n        TOKEN._0x14172a(msg.sender, _0x957ead);\n\n        emit Withdraw(msg.sender, _0x957ead);\n    }\n\n    function _0x638caa() external _0x3b813f {\n        require(_0x6ca576, \"EMER\");\n        uint256 _0x715042 = _0xbe1d42(msg.sender);\n        require(_0x715042 > 0, \"ZV\");\n        _0xfbc3db = _0xfbc3db - _0x715042;\n\n        _0x1f624e[msg.sender] = 0;\n\n        TOKEN._0x14172a(msg.sender, _0x715042);\n        emit Withdraw(msg.sender, _0x715042);\n    }\n\n    function _0xd2ddbc(uint256 _0x715042) external _0x3b813f {\n\n        require(_0x6ca576, \"EMER\");\n        _0xfbc3db = _0xfbc3db - _0x715042;\n\n        _0x1f624e[msg.sender] = _0x1f624e[msg.sender] - _0x715042;\n\n        TOKEN._0x14172a(msg.sender, _0x715042);\n        emit Withdraw(msg.sender, _0x715042);\n    }\n\n    ///@notice withdraw all TOKEN and harvest rewardToken\n    function _0x824525(uint8 _0xec2241) external {\n        _0x59eee2(_0xbe1d42(msg.sender));\n        _0x799db6(_0xec2241);\n    }\n\n    ///@notice User harvest function called from distribution (GaugeManager allows harvest on multiple gauges)\n    function _0x799db6(address _0x95bdb6, uint8 _0xec2241) public _0x3b813f _0x8bfb96 _0x018025(_0x95bdb6) {\n        uint256 _0x8aec4b = _0x7257dd[_0x95bdb6];\n        if (_0x8aec4b > 0) {\n            _0x7257dd[_0x95bdb6] = 0;\n            IERC20(_0xe554e7)._0x9fc3e3(_0xf6237b, _0x8aec4b);\n            IRHYBR(_0xf6237b)._0x2ec0e0(_0x8aec4b);\n            IRHYBR(_0xf6237b)._0xaf1135(_0x8aec4b, _0xec2241, _0x95bdb6);\n            emit Harvest(_0x95bdb6, _0x8aec4b);\n        }\n\n        if (_0xf33612 != address(0)) {\n            IRewarder(_0xf33612)._0x705e90(_0x95bdb6, _0x95bdb6, _0xbe1d42(_0x95bdb6));\n        }\n    }\n\n    ///@notice User harvest function\n    function _0x799db6(uint8 _0xec2241) public _0x3b813f _0x018025(msg.sender) {\n        uint256 _0x8aec4b = _0x7257dd[msg.sender];\n        if (_0x8aec4b > 0) {\n            _0x7257dd[msg.sender] = 0;\n            IERC20(_0xe554e7)._0x9fc3e3(_0xf6237b, _0x8aec4b);\n            IRHYBR(_0xf6237b)._0x2ec0e0(_0x8aec4b);\n            IRHYBR(_0xf6237b)._0xaf1135(_0x8aec4b, _0xec2241, msg.sender);\n            emit Harvest(msg.sender, _0x8aec4b);\n        }\n\n        if (_0xf33612 != address(0)) {\n            IRewarder(_0xf33612)._0x705e90(msg.sender, msg.sender, _0xbe1d42(msg.sender));\n        }\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    DISTRIBUTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @dev Receive rewards from distribution\n\n    function _0xd8333d(address _0xdaccff, uint256 _0x8aec4b) external _0x3b813f _0x038ae6 _0x8bfb96 _0x018025(address(0)) {\n        require(_0xdaccff == address(_0xe554e7), \"IA\");\n        _0xe554e7._0xd30d72(DISTRIBUTION, address(this), _0x8aec4b);\n\n        if (block.timestamp >= _0x3c01dc) {\n            _0x8a4b89 = _0x8aec4b / DURATION;\n        } else {\n            uint256 _0xf825c7 = _0x3c01dc - block.timestamp;\n            uint256 _0x35267a = _0xf825c7 * _0x8a4b89;\n            _0x8a4b89 = (_0x8aec4b + _0x35267a) / DURATION;\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n\n        uint256 balance = _0xe554e7._0xc54a0b(address(this));\n        require(_0x8a4b89 <= balance / DURATION, \"REWARD_HIGH\");\n\n        _0x65fe70 = block.timestamp;\n        _0x3c01dc = block.timestamp + DURATION;\n        emit RewardAdded(_0x8aec4b);\n    }\n\n    function _0xd0ff1b() external _0x3b813f returns (uint256 _0xc220c0, uint256 _0x2519a7) {\n        return _0x2cd166();\n    }\n\n     function _0x2cd166() internal returns (uint256 _0xc220c0, uint256 _0x2519a7) {\n        if (!_0x9c48d5) {\n            return (0, 0);\n        }\n        address _0xf32c5f = address(TOKEN);\n        (_0xc220c0, _0x2519a7) = IPair(_0xf32c5f)._0xd0ff1b();\n        if (_0xc220c0 > 0 || _0x2519a7 > 0) {\n\n            uint256 _0x822b25 = _0xc220c0;\n            uint256 _0xcf646e = _0x2519a7;\n\n            (address _0x1381f6, address _0x105283) = IPair(_0xf32c5f)._0xbf4cc2();\n\n            if (_0x822b25  > 0) {\n                IERC20(_0x1381f6)._0x9fc3e3(_0x0b49ce, 0);\n                IERC20(_0x1381f6)._0x9fc3e3(_0x0b49ce, _0x822b25);\n                IBribe(_0x0b49ce)._0xd8333d(_0x1381f6, _0x822b25);\n            }\n            if (_0xcf646e  > 0) {\n                IERC20(_0x105283)._0x9fc3e3(_0x0b49ce, 0);\n                IERC20(_0x105283)._0x9fc3e3(_0x0b49ce, _0xcf646e);\n                IBribe(_0x0b49ce)._0xd8333d(_0x105283, _0xcf646e);\n            }\n            emit ClaimFees(msg.sender, _0xc220c0, _0x2519a7);\n        }\n    }\n\n}",
      "rename_map": {
        "lastTimeRewardApplicable": "_0x79d2a4",
        "emergencyWithdrawAmount": "_0xd2ddbc",
        "depostionEmissionsToken": "_0x2ec0e0",
        "userRewardPerTokenPaid": "_0xeedf3e",
        "withdrawAllAndHarvest": "_0x824525",
        "activateEmergencyMode": "_0x3660b8",
        "rewardPerTokenStored": "_0xca2567",
        "notifyRewardAmount": "_0xd8333d",
        "emergencyWithdraw": "_0x638caa",
        "rewardForDuration": "_0x5d5c0d",
        "stopEmergencyMode": "_0x0b5f4c",
        "safeTransferFrom": "_0xd30d72",
        "setInternalBribe": "_0xe40d17",
        "onlyDistribution": "_0x8bfb96",
        "setGaugeRewarder": "_0x12ee66",
        "_internal_bribe": "_0x20ce35",
        "setDistribution": "_0x8050f2",
        "_external_bribe": "_0x538fd0",
        "_gaugeRewarder": "_0xd6ade4",
        "external_bribe": "_0x2524ce",
        "rewardPerToken": "_0xff6159",
        "internal_bribe": "_0x0b49ce",
        "lastUpdateTime": "_0x65fe70",
        "isNotEmergency": "_0x038ae6",
        "_periodFinish": "_0x3c01dc",
        "gaugeRewarder": "_0xf33612",
        "_distribution": "_0xfac2fb",
        "updateReward": "_0x018025",
        "maturityTime": "_0xf90e6c",
        "nonReentrant": "_0x3b813f",
        "periodFinish": "_0xa64f57",
        "_rewardToken": "_0x9cace0",
        "_totalSupply": "_0xfbc3db",
        "safeTransfer": "_0x14172a",
        "totalSupply": "_0x5ff905",
        "_redeemType": "_0xec2241",
        "withdrawAll": "_0x88f737",
        "userBalance": "_0x5610c4",
        "rewardToken": "_0xe554e7",
        "safeApprove": "_0x9fc3e3",
        "rewardRate": "_0x8a4b89",
        "_isForPair": "_0xf87d06",
        "_balanceOf": "_0xbe1d42",
        "_claimFees": "_0x2cd166",
        "depositAll": "_0x1a17be",
        "getReward": "_0x799db6",
        "redeemFor": "_0xaf1135",
        "emergency": "_0x6ca576",
        "isForPair": "_0x9c48d5",
        "_withdraw": "_0x59eee2",
        "_balances": "_0x1f624e",
        "onlyOwner": "_0xc6687b",
        "recipient": "_0xff61c4",
        "balanceOf": "_0xc54a0b",
        "remaining": "_0xf825c7",
        "claimFees": "_0xd0ff1b",
        "leftover": "_0x35267a",
        "_deposit": "_0x05c4cd",
        "withdraw": "_0xba5475",
        "onReward": "_0x705e90",
        "claimed1": "_0x2519a7",
        "claimed0": "_0xc220c0",
        "_amount": "_0x715042",
        "_token1": "_0x105283",
        "rewards": "_0x7257dd",
        "_token0": "_0x1381f6",
        "account": "_0x647df5",
        "deposit": "_0x294d1c",
        "_token": "_0xf32c5f",
        "_rHYBR": "_0xd23796",
        "amount": "_0x957ead",
        "earned": "_0xb0ccfb",
        "_fees1": "_0xcf646e",
        "_fees0": "_0x822b25",
        "tokens": "_0xbf4cc2",
        "reward": "_0x8aec4b",
        "gauge": "_0x29b729",
        "_user": "_0x95bdb6",
        "rHYBR": "_0xf6237b",
        "token": "_0xdaccff",
        "_int": "_0xa0393c",
        "user": "_0x677a35",
        "min": "_0xf443cb",
        "_ve": "_0x421096"
      },
      "changes": [
        "Renamed 84 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_004",
      "transformed_id": "ss_l2_hex_sn_gs_004",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title GovernanceHYBR (gHYBR)\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\n */\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Lock period for new deposits (configurable between 12-24 hours)\n    uint256 public _0x0c3872 = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public _0xd0755f = 1200; // 5days\n    uint256 public _0xf7ab47 = 300; // 1day\n\n    // Withdraw fee configuration (basis points, 10000 = 100%)\n    uint256 public _0xaa7e20 = 100; // 1% default fee\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\n    uint256 public constant BASIS = 10000;\n    address public Team; // Address to receive fees\n    uint256 public _0x9e65af;\n    uint256 public _0x93f8b2;\n    uint256 public _0x69cb47;\n    // User deposit tracking for transfer locks\n    struct UserLock {\n        uint256 _0x9baf4b;\n        uint256 _0x725b56;\n    }\n\n    mapping(address => UserLock[]) public _0x08a0ca;\n    mapping(address => uint256) public _0x235290;\n\n    // Core contracts\n    address public immutable HYBR;\n    address public immutable _0x3bcb90;\n    address public _0xdd69ab;\n    address public _0x28b7c4;\n    address public _0x725e75;\n    uint256 public _0x8a5ed6; // The veNFT owned by this contract\n\n    // Auto-voting strategy\n    address public _0xdfc883; // Address that can manage voting strategy\n    uint256 public _0x48bb01; // Last epoch when we voted\n\n    // Reward tracking\n    uint256 public _0x8a6372;\n    uint256 public _0x36818e;\n\n    // Swap module\n    ISwapper public _0x2bd0d0;\n\n    // Errors\n    error NOT_AUTHORIZED();\n\n    // Events\n    event Deposit(address indexed _0xcafb62, uint256 _0x7a96b1, uint256 _0x734877);\n    event Withdraw(address indexed _0xcafb62, uint256 _0xef133c, uint256 _0x7a96b1, uint256 _0x46fbd9);\n    event Compound(uint256 _0x8712a1, uint256 _0xbc27d0);\n    event PenaltyRewardReceived(uint256 _0x9baf4b);\n    event TransferLockPeriodUpdated(uint256 _0x0ff4cb, uint256 _0x3d143e);\n    event SwapperUpdated(address indexed _0x2e93bb, address indexed _0xea3d25);\n    event VoterSet(address _0xdd69ab);\n    event EmergencyUnlock(address indexed _0xcafb62);\n    event AutoVotingEnabled(bool _0x095807);\n    event OperatorUpdated(address indexed _0x54b4d3, address indexed _0xe7d571);\n    event DefaultVotingStrategyUpdated(address[] _0x7205b7, uint256[] _0x7cfc76);\n    event AutoVoteExecuted(uint256 _0xd076b1, address[] _0x7205b7, uint256[] _0x7cfc76);\n\n    constructor(\n        address _0xa66795,\n        address _0xf4405a\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_0xa66795 != address(0), \"Invalid HYBR\");\n        require(_0xf4405a != address(0), \"Invalid VE\");\n\n        HYBR = _0xa66795;\n        _0x3bcb90 = _0xf4405a;\n        _0x8a6372 = block.timestamp;\n        _0x36818e = block.timestamp;\n        _0xdfc883 = msg.sender; // Initially set deployer as operator\n    }\n\n    function _0xe1666b(address _0xfa0832) external _0xe5c9cf {\n        require(_0xfa0832 != address(0), \"Invalid rewards distributor\");\n        _0x28b7c4 = _0xfa0832;\n    }\n\n    function _0xfe73ff(address _0x1bc804) external _0xe5c9cf {\n        require(_0x1bc804 != address(0), \"Invalid gauge manager\");\n        _0x725e75 = _0x1bc804;\n    }\n\n      /**\n     * @notice Modifier to check authorization (owner or operator)\n     */\n    modifier _0xcfae1d() {\n        if (msg.sender != _0xdfc883) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n    /**\n     * @notice Deposit HYBR and receive gHYBR shares\n     * @param amount Amount of HYBR to deposit\n     * @param recipient Recipient of gHYBR shares\n     */\n    function _0x96c149(uint256 _0x9baf4b, address _0xa693ca) external _0x211840 {\n        require(_0x9baf4b > 0, \"Zero amount\");\n        _0xa693ca = _0xa693ca == address(0) ? msg.sender : _0xa693ca;\n\n        // Transfer HYBR from user first\n        IERC20(HYBR)._0x9e289b(msg.sender, address(this), _0x9baf4b);\n\n        // Initialize veNFT on first deposit\n        if (_0x8a5ed6 == 0) {\n            _0x24da8e(_0x9baf4b);\n        } else {\n            // Add to existing veNFT\n            IERC20(HYBR)._0x1d1308(_0x3bcb90, _0x9baf4b);\n            IVotingEscrow(_0x3bcb90)._0xad7b2a(_0x8a5ed6, _0x9baf4b);\n\n            // Extend lock to maximum duration\n            _0xe77992();\n        }\n\n        // Calculate shares to mint based on current totalAssets\n        uint256 _0xef133c = _0x914df6(_0x9baf4b);\n\n        // Mint gHYBR shares\n        _0xdbe3c1(_0xa693ca, _0xef133c);\n\n        // Add transfer lock for recipient\n        _0x56f3e0(_0xa693ca, _0xef133c);\n\n        emit Deposit(msg.sender, _0x9baf4b, _0xef133c);\n    }\n\n    /**\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\n     * @param shares Amount of gHYBR shares to burn\n     * @return userTokenId The ID of the new veNFT created for the user\n     */\n    function _0x33be44(uint256 _0xef133c) external _0x211840 returns (uint256 _0x4439eb) {\n        require(_0xef133c > 0, \"Zero shares\");\n        require(_0x106404(msg.sender) >= _0xef133c, \"Insufficient balance\");\n        require(_0x8a5ed6 != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(_0x3bcb90)._0x69367f(_0x8a5ed6) == false, \"Cannot withdraw yet\");\n\n        uint256 _0x84dd04 = HybraTimeLibrary._0x84dd04(block.timestamp);\n        uint256 _0x659a58 = HybraTimeLibrary._0x659a58(block.timestamp);\n\n        require(block.timestamp >= _0x84dd04 + _0xd0755f && block.timestamp < _0x659a58 - _0xf7ab47, \"Cannot withdraw yet\");\n\n        // Calculate proportional HYBR amount from veNFT\n        uint256 _0x7a96b1 = _0xd53367(_0xef133c);\n        require(_0x7a96b1 > 0, \"No assets to withdraw\");\n\n        // Calculate fee amount (from the HYBR amount, not shares)\n        uint256 _0x784a98 = 0;\n        if (_0xaa7e20 > 0) {\n            _0x784a98 = (_0x7a96b1 * _0xaa7e20) / BASIS;\n        }\n\n        // User receives amount minus fee\n        uint256 _0xc14ec1 = _0x7a96b1 - _0x784a98;\n        require(_0xc14ec1 > 0, \"Amount too small after fee\");\n\n        // Get actual HYBR locked amount (not voting power)\n        uint256 _0x0a2bf8 = _0x6e0c50();\n        require(_0x7a96b1 <= _0x0a2bf8, \"Insufficient veNFT balance\");\n\n        uint256 _0x08a33a = _0x0a2bf8 - _0xc14ec1 - _0x784a98;\n        require(_0x08a33a >= 0, \"Cannot withdraw entire veNFT\");\n\n        // Burn gHYBR shares (full amount)\n        _0xc45561(msg.sender, _0xef133c);\n\n        // Use multiSplit to create two NFTs: one for user, one for contract\n        uint256[] memory _0xcd3a64 = new uint256[](3);\n        _0xcd3a64[0] = _0x08a33a; // Amount staying with gHYBR\n        _0xcd3a64[1] = _0xc14ec1;      // Amount going to user (after fee)\n        _0xcd3a64[2] = _0x784a98;      // Amount going to fee recipient\n\n        uint256[] memory _0x9879a7 = IVotingEscrow(_0x3bcb90)._0xb5f39e(_0x8a5ed6, _0xcd3a64);\n\n        // Update contract's veTokenId to the first new token\n        _0x8a5ed6 = _0x9879a7[0];\n        _0x4439eb = _0x9879a7[1];\n        uint256 _0x1430e6 = _0x9879a7[2];\n        // Note: userTokenId is transferred to user, they can manage their own lock time\n        IVotingEscrow(_0x3bcb90)._0x793e87(address(this), msg.sender, _0x4439eb);\n        IVotingEscrow(_0x3bcb90)._0x793e87(address(this), Team, _0x1430e6);\n        emit Withdraw(msg.sender, _0xef133c, _0xc14ec1, _0x784a98);\n    }\n\n    /**\n     * @notice Internal function to initialize veNFT on first deposit\n     */\n    function _0x24da8e(uint256 _0xfcccfd) internal {\n        // Create max lock with the initial deposit amount\n        IERC20(HYBR)._0x1d1308(_0x3bcb90, type(uint256)._0x7b84f1);\n        uint256 _0xd895b3 = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n        // Create lock with initial amount\n        _0x8a5ed6 = IVotingEscrow(_0x3bcb90)._0x5fa35f(_0xfcccfd, _0xd895b3, address(this));\n\n    }\n\n    /**\n     * @notice Calculate shares to mint based on deposit amount\n     */\n    function _0x914df6(uint256 _0x9baf4b) public view returns (uint256) {\n        uint256 _0x7a16d0 = _0xc95bc4();\n        uint256 _0x1e75a7 = _0x6e0c50();\n        if (_0x7a16d0 == 0 || _0x1e75a7 == 0) {\n            return _0x9baf4b;\n        }\n        return (_0x9baf4b * _0x7a16d0) / _0x1e75a7;\n    }\n\n    /**\n     * @notice Calculate HYBR value of shares\n     */\n    function _0xd53367(uint256 _0xef133c) public view returns (uint256) {\n        uint256 _0x7a16d0 = _0xc95bc4();\n        if (_0x7a16d0 == 0) {\n            return _0xef133c;\n        }\n        return (_0xef133c * _0x6e0c50()) / _0x7a16d0;\n    }\n\n    /**\n     * @notice Get total assets (HYBR) locked in veNFT\n     * @dev Returns actual HYBR amount, not voting power\n     */\n    function _0x6e0c50() public view returns (uint256) {\n        if (_0x8a5ed6 == 0) {\n            return 0;\n        }\n        // Get actual locked HYBR amount, not voting power\n        IVotingEscrow.LockedBalance memory _0x115897 = IVotingEscrow(_0x3bcb90)._0x115897(_0x8a5ed6);\n        return uint256(int256(_0x115897._0x9baf4b));\n    }\n\n    /**\n     * @notice Add transfer lock for new deposits\n     */\n    function _0x56f3e0(address _0xcafb62, uint256 _0x9baf4b) internal {\n        uint256 _0x725b56 = block.timestamp + _0x0c3872;\n        _0x08a0ca[_0xcafb62].push(UserLock({\n            _0x9baf4b: _0x9baf4b,\n            _0x725b56: _0x725b56\n        }));\n        _0x235290[_0xcafb62] += _0x9baf4b;\n    }\n\n    /**\n     * @notice Preview available balance (total - currently locked)\n     * @param user The user address to check\n     * @return available The current available balance for transfer\n     */\n    function _0x6b886d(address _0xcafb62) external view returns (uint256 _0x9a852b) {\n        uint256 _0xf15e16 = _0x106404(_0xcafb62);\n        uint256 _0x5d46e4 = 0;\n\n        UserLock[] storage _0x2f0bfd = _0x08a0ca[_0xcafb62];\n        for (uint256 i = 0; i < _0x2f0bfd.length; i++) {\n            if (_0x2f0bfd[i]._0x725b56 > block.timestamp) {\n                _0x5d46e4 += _0x2f0bfd[i]._0x9baf4b;\n            }\n        }\n\n        return _0xf15e16 > _0x5d46e4 ? _0xf15e16 - _0x5d46e4 : 0;\n    }\n    /**\n     * @notice Clean expired locks and update locked balance\n     * @param user The user address to clean locks for\n     * @return freed The amount of tokens freed from expired locks\n     */\n    function _0xadd49f(address _0xcafb62) internal returns (uint256 _0x9d5770) {\n        UserLock[] storage _0x2f0bfd = _0x08a0ca[_0xcafb62];\n        uint256 _0xf52325 = _0x2f0bfd.length;\n        if (_0xf52325 == 0) return 0;\n\n        uint256 _0xb5ceb7 = 0;\n        unchecked {\n            for (uint256 i = 0; i < _0xf52325; i++) {\n                UserLock memory L = _0x2f0bfd[i];\n                if (L._0x725b56 <= block.timestamp) {\n                    _0x9d5770 += L._0x9baf4b;\n                } else {\n                    if (_0xb5ceb7 != i) _0x2f0bfd[_0xb5ceb7] = L;\n                    _0xb5ceb7++;\n                }\n            }\n            if (_0x9d5770 > 0) {\n                _0x235290[_0xcafb62] -= _0x9d5770;\n            }\n            while (_0x2f0bfd.length > _0xb5ceb7) {\n                _0x2f0bfd.pop();\n            }\n        }\n    }\n\n    /**\n     * @notice Override transfer to implement lock mechanism\n     */\n    function _0x3fd035(\n        address from,\n        address _0xe4ff96,\n        uint256 _0x9baf4b\n    ) internal override {\n        super._0x3fd035(from, _0xe4ff96, _0x9baf4b);\n\n        if (from != address(0) && _0xe4ff96 != address(0)) { // Not mint or burn\n            uint256 _0xf15e16 = _0x106404(from);\n\n            // Step 1: Check current available balance using cached lockedBalance\n            uint256 _0xc6bd7f = _0xf15e16 > _0x235290[from] ? _0xf15e16 - _0x235290[from] : 0;\n\n            // Step 2: If current available >= amount, pass directly\n            if (_0xc6bd7f >= _0x9baf4b) {\n                return;\n            }\n\n            // Step 3: Not enough, clean expired locks and recalculate\n            _0xadd49f(from);\n            uint256 _0xb66e08 = _0xf15e16 > _0x235290[from] ? _0xf15e16 - _0x235290[from] : 0;\n\n            // Step 4: Check final available balance\n            require(_0xb66e08 >= _0x9baf4b, \"Tokens locked\");\n        }\n    }\n\n    /**\n     * @notice Claim all rewards from voting and rebase\n     */\n    function _0x20c0f3() external _0xcfae1d {\n        require(_0xdd69ab != address(0), \"Voter not set\");\n        require(_0x28b7c4 != address(0), \"Distributor not set\");\n\n        // Claim rebase rewards from RewardsDistributor\n        uint256  _0x25cae8 = IRewardsDistributor(_0x28b7c4)._0xfb2f52(_0x8a5ed6);\n        _0x9e65af += _0x25cae8;\n        // Claim bribes from voted pools\n        address[] memory _0x553b0e = IVoter(_0xdd69ab)._0xb8bff6(_0x8a5ed6);\n\n        for (uint256 i = 0; i < _0x553b0e.length; i++) {\n            if (_0x553b0e[i] != address(0)) {\n                address _0x36a928 = IGaugeManager(_0x725e75)._0x544f34(_0x553b0e[i]);\n\n                if (_0x36a928 != address(0)) {\n                    // Prepare arrays for single bribe claim\n                    address[] memory _0x295f32 = new address[](1);\n                    address[][] memory _0xf557b4 = new address[][](1);\n\n                    // Claim internal bribe (trading fees)\n                    address _0xd73691 = IGaugeManager(_0x725e75)._0xd71cf4(_0x36a928);\n                    if (_0xd73691 != address(0)) {\n                        uint256 _0x90d7ec = IBribe(_0xd73691)._0xb0081a();\n                        if (_0x90d7ec > 0) {\n                            address[] memory _0x3c5bc9 = new address[](_0x90d7ec);\n                            for (uint256 j = 0; j < _0x90d7ec; j++) {\n                                _0x3c5bc9[j] = IBribe(_0xd73691)._0x3c5bc9(j);\n                            }\n                            _0x295f32[0] = _0xd73691;\n                            _0xf557b4[0] = _0x3c5bc9;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x725e75)._0xb1c42e(_0x295f32, _0xf557b4, _0x8a5ed6);\n                        }\n                    }\n\n                    // Claim external bribe\n                    address _0x8447bc = IGaugeManager(_0x725e75)._0x270259(_0x36a928);\n                    if (_0x8447bc != address(0)) {\n                        uint256 _0x90d7ec = IBribe(_0x8447bc)._0xb0081a();\n                        if (_0x90d7ec > 0) {\n                            address[] memory _0x3c5bc9 = new address[](_0x90d7ec);\n                            for (uint256 j = 0; j < _0x90d7ec; j++) {\n                                _0x3c5bc9[j] = IBribe(_0x8447bc)._0x3c5bc9(j);\n                            }\n                            _0x295f32[0] = _0x8447bc;\n                            _0xf557b4[0] = _0x3c5bc9;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x725e75)._0xb1c42e(_0x295f32, _0xf557b4, _0x8a5ed6);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Execute swap through the configured swapper module\n     * @param _params Swap parameters for the swapper module\n     */\n    function _0x982899(ISwapper.SwapParams calldata _0x6d9efd) external _0x211840 _0xcfae1d {\n        require(address(_0x2bd0d0) != address(0), \"Swapper not set\");\n\n        // Get token balance before swap\n        uint256 _0xe47e4b = IERC20(_0x6d9efd._0x42f895)._0x106404(address(this));\n        require(_0xe47e4b >= _0x6d9efd._0xdad209, \"Insufficient token balance\");\n\n        // Approve swapper to spend tokens\n        IERC20(_0x6d9efd._0x42f895)._0x9fbab6(address(_0x2bd0d0), _0x6d9efd._0xdad209);\n\n        // Execute swap through swapper module\n        uint256 _0xe2a7c2 = _0x2bd0d0._0x870a71(_0x6d9efd);\n\n        // Reset approval for safety\n        IERC20(_0x6d9efd._0x42f895)._0x9fbab6(address(_0x2bd0d0), 0);\n\n        // HYBR is now in this contract, ready for compounding\n        _0x69cb47 += _0xe2a7c2;\n    }\n\n    /**\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\n     */\n    function _0x6f3e4d() external _0xcfae1d {\n\n        // Get current HYBR balance\n        uint256 _0x05a981 = IERC20(HYBR)._0x106404(address(this));\n\n        if (_0x05a981 > 0) {\n            // Lock all HYBR to existing veNFT\n            IERC20(HYBR)._0x9fbab6(_0x3bcb90, _0x05a981);\n            IVotingEscrow(_0x3bcb90)._0xad7b2a(_0x8a5ed6, _0x05a981);\n\n            // Extend lock to maximum duration\n            _0xe77992();\n\n            _0x36818e = block.timestamp;\n\n            emit Compound(_0x05a981, _0x6e0c50());\n        }\n    }\n\n    /**\n     * @notice Vote for gauges using the veNFT\n     * @param _poolVote Array of pools to vote for\n     * @param _weights Array of weights for each pool\n     */\n    function _0xa17d6d(address[] calldata _0x3e3ea2, uint256[] calldata _0xda4806) external {\n        require(msg.sender == _0x10e85a() || msg.sender == _0xdfc883, \"Not authorized\");\n        require(_0xdd69ab != address(0), \"Voter not set\");\n\n        IVoter(_0xdd69ab)._0xa17d6d(_0x8a5ed6, _0x3e3ea2, _0xda4806);\n        _0x48bb01 = HybraTimeLibrary._0x84dd04(block.timestamp);\n\n    }\n\n    /**\n     * @notice Reset votes\n     */\n    function _0x16199a() external {\n        require(msg.sender == _0x10e85a() || msg.sender == _0xdfc883, \"Not authorized\");\n        require(_0xdd69ab != address(0), \"Voter not set\");\n\n        IVoter(_0xdd69ab)._0x16199a(_0x8a5ed6);\n    }\n\n    /**\n     * @notice Receive penalty rewards from rHYBR conversions\n     */\n    function _0x89b5cd(uint256 _0x9baf4b) external {\n\n        // Auto-compound penalty rewards to existing veNFT\n        if (_0x9baf4b > 0) {\n            IERC20(HYBR)._0x1d1308(_0x3bcb90, _0x9baf4b);\n\n            if(_0x8a5ed6 == 0){\n                _0x24da8e(_0x9baf4b);\n            } else{\n                IVotingEscrow(_0x3bcb90)._0xad7b2a(_0x8a5ed6, _0x9baf4b);\n\n                // Extend lock to maximum duration\n                _0xe77992();\n            }\n        }\n        _0x93f8b2 += _0x9baf4b;\n        emit PenaltyRewardReceived(_0x9baf4b);\n    }\n\n    /**\n     * @notice Set the voter contract\n     */\n    function _0x97f6c2(address _0x80ec03) external _0xe5c9cf {\n        require(_0x80ec03 != address(0), \"Invalid voter\");\n        _0xdd69ab = _0x80ec03;\n        emit VoterSet(_0x80ec03);\n    }\n\n    /**\n     * @notice Update transfer lock period\n     */\n    function _0x8c22b6(uint256 _0x6fa78b) external _0xe5c9cf {\n        require(_0x6fa78b >= MIN_LOCK_PERIOD && _0x6fa78b <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 _0x0ff4cb = _0x0c3872;\n        _0x0c3872 = _0x6fa78b;\n        emit TransferLockPeriodUpdated(_0x0ff4cb, _0x6fa78b);\n    }\n\n    /**\n     * @notice Set withdraw fee (in basis points)\n     * @param _fee Fee amount (10-30 basis points)\n     */\n    function _0x020e9c(uint256 _0xe5f8d5) external _0xe5c9cf {\n        require(_0xe5f8d5 >= MIN_WITHDRAW_FEE && _0xe5f8d5 <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        _0xaa7e20 = _0xe5f8d5;\n    }\n\n    function _0x709e52(uint256 _0xe4cd32) external _0xe5c9cf {\n        _0xd0755f = _0xe4cd32;\n    }\n\n    function _0x9a9607(uint256 _0xe4cd32) external _0xe5c9cf {\n        _0xf7ab47 = _0xe4cd32;\n    }\n\n    /**\n     * @notice Set the swapper module\n     * @param _swapper Address of the swapper module\n     */\n    function _0x11cabe(address _0x90f7d9) external _0xe5c9cf {\n        require(_0x90f7d9 != address(0), \"Invalid swapper\");\n        address _0x2e93bb = address(_0x2bd0d0);\n        _0x2bd0d0 = ISwapper(_0x90f7d9);\n        emit SwapperUpdated(_0x2e93bb, _0x90f7d9);\n    }\n\n    /**\n     * @notice Set the team address\n     */\n    function _0x6cbd89(address _0x50f3d0) external _0xe5c9cf {\n        require(_0x50f3d0 != address(0), \"Invalid team\");\n        Team = _0x50f3d0;\n    }\n\n    /**\n     * @notice Emergency unlock for a user (owner only)\n     */\n    function _0x49e6e6(address _0xcafb62) external _0xcfae1d {\n        delete _0x08a0ca[_0xcafb62];\n        _0x235290[_0xcafb62] = 0;\n        emit EmergencyUnlock(_0xcafb62);\n    }\n\n    /**\n     * @notice Get user's locks info\n     */\n    function _0x4265c4(address _0xcafb62) external view returns (UserLock[] memory) {\n        return _0x08a0ca[_0xcafb62];\n    }\n\n    /**\n     * @notice Set operator address\n     */\n    function _0x5e59b9(address _0xba69eb) external _0xe5c9cf {\n        require(_0xba69eb != address(0), \"Invalid operator\");\n        address _0x54b4d3 = _0xdfc883;\n        _0xdfc883 = _0xba69eb;\n        emit OperatorUpdated(_0x54b4d3, _0xba69eb);\n    }\n\n    /**\n     * @notice Get veNFT lock end time\n     */\n    function _0x42384e() external view returns (uint256) {\n        if (_0x8a5ed6 == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory _0x115897 = IVotingEscrow(_0x3bcb90)._0x115897(_0x8a5ed6);\n        return uint256(_0x115897._0x82bb3b);\n    }\n\n    /**\n     * @notice Internal helper to safely extend lock to maximum duration\n     * @dev Calculates exact duration needed to reach max allowed unlock time\n     */\n    function _0xe77992() internal {\n        if (_0x8a5ed6 == 0) return;\n\n        IVotingEscrow.LockedBalance memory _0x115897 = IVotingEscrow(_0x3bcb90)._0x115897(_0x8a5ed6);\n        if (_0x115897._0x7be9f7 || _0x115897._0x82bb3b <= block.timestamp) return;\n\n        uint256 _0x4e3a37 = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n        // Only extend if difference is more than 2 hours\n        if (_0x4e3a37 > _0x115897._0x82bb3b + 2 hours) {\n            try IVotingEscrow(_0x3bcb90)._0x935206(_0x8a5ed6, HybraTimeLibrary.MAX_LOCK_DURATION) {\n                // Extension successful\n            } catch {\n                // Extension failed, continue without error\n                // This can happen if already at max possible time or other constraints\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setHeadNotWithdrawTime": "_0x709e52",
        "tail_not_withdraw_time": "_0xf7ab47",
        "head_not_withdraw_time": "_0xd0755f",
        "setTailNotWithdrawTime": "_0x9a9607",
        "setTransferLockPeriod": "_0x8c22b6",
        "setRewardsDistributor": "_0xe1666b",
        "increase_unlock_time": "_0x935206",
        "receivePenaltyReward": "_0x89b5cd",
        "_beforeTokenTransfer": "_0x3fd035",
        "_rewardsDistributor": "_0xfa0832",
        "rewardsDistributor": "_0x28b7c4",
        "transferLockPeriod": "_0x0c3872",
        "rewardsListLength": "_0xb0081a",
        "safeTransferFrom": "_0x793e87",
        "_extendLockToMax": "_0xe77992",
        "_addTransferLock": "_0x56f3e0",
        "_initializeVeNFT": "_0x24da8e",
        "lastCompoundTime": "_0x36818e",
        "previewAvailable": "_0x6b886d",
        "currentAvailable": "_0xc6bd7f",
        "create_lock_for": "_0x5fa35f",
        "calculateAssets": "_0xd53367",
        "external_bribes": "_0x270259",
        "calculateShares": "_0x914df6",
        "setGaugeManager": "_0xfe73ff",
        "internal_bribes": "_0xd71cf4",
        "emergencyUnlock": "_0x49e6e6",
        "remainingAmount": "_0x08a33a",
        "newTotalLocked": "_0xbc27d0",
        "finalAvailable": "_0xb66e08",
        "sharesReceived": "_0x734877",
        "setWithdrawFee": "_0x020e9c",
        "lastRebaseTime": "_0x8a6372",
        "getLockEndTime": "_0x42384e",
        "initialAmount": "_0xfcccfd",
        "externalBribe": "_0x8447bc",
        "_cleanExpired": "_0xadd49f",
        "_gaugeManager": "_0x1bc804",
        "lastVoteEpoch": "_0x48bb01",
        "_votingEscrow": "_0xf4405a",
        "currentLocked": "_0x5d46e4",
        "internalBribe": "_0xd73691",
        "lockedBalance": "_0x235290",
        "maxUnlockTime": "_0x4e3a37",
        "hybrReceived": "_0xe2a7c2",
        "tokenBalance": "_0xe47e4b",
        "votingEscrow": "_0x3bcb90",
        "_totalAssets": "_0x1e75a7",
        "nonReentrant": "_0x211840",
        "rebaseAmount": "_0x25cae8",
        "totalBalance": "_0xf15e16",
        "getUserLocks": "_0x4265c4",
        "onlyOperator": "_0xcfae1d",
        "_totalSupply": "_0x7a16d0",
        "gaugeManager": "_0x725e75",
        "transferFrom": "_0x9e289b",
        "claimRewards": "_0x20c0f3",
        "oldOperator": "_0x54b4d3",
        "newTokenIds": "_0x9879a7",
        "hybrBalance": "_0x05a981",
        "votingYield": "_0x69cb47",
        "isPermanent": "_0x7be9f7",
        "withdrawFee": "_0xaa7e20",
        "executeSwap": "_0x982899",
        "totalAssets": "_0x6e0c50",
        "userTokenId": "_0x4439eb",
        "deposit_for": "_0xad7b2a",
        "totalSupply": "_0xc95bc4",
        "setOperator": "_0x5e59b9",
        "claimBribes": "_0xb1c42e",
        "newOperator": "_0xe7d571",
        "bribeTokens": "_0x3c5bc9",
        "safeApprove": "_0x9fbab6",
        "unlockTime": "_0x725b56",
        "epochStart": "_0x84dd04",
        "setSwapper": "_0x11cabe",
        "multiSplit": "_0xb5f39e",
        "votedPools": "_0x553b0e",
        "feeTokenId": "_0x1430e6",
        "swapToHYBR": "_0x870a71",
        "newSwapper": "_0xea3d25",
        "hybrAmount": "_0x7a96b1",
        "tokenCount": "_0x90d7ec",
        "oldSwapper": "_0x2e93bb",
        "userAmount": "_0xc14ec1",
        "_poolVote": "_0x3e3ea2",
        "available": "_0x9a852b",
        "veTokenId": "_0x8a5ed6",
        "veBalance": "_0x0a2bf8",
        "_operator": "_0xba69eb",
        "userLocks": "_0x08a0ca",
        "oldPeriod": "_0x0ff4cb",
        "onlyOwner": "_0xe5c9cf",
        "recipient": "_0xa693ca",
        "newPeriod": "_0x3d143e",
        "balanceOf": "_0x106404",
        "epochNext": "_0x659a58",
        "feeAmount": "_0x784a98",
        "_swapper": "_0x90f7d9",
        "setVoter": "_0x97f6c2",
        "compound": "_0x6f3e4d",
        "operator": "_0xdfc883",
        "_weights": "_0xda4806",
        "withdraw": "_0x33be44",
        "amountIn": "_0xdad209",
        "poolVote": "_0xb8bff6",
        "lockTime": "_0xd895b3",
        "_params": "_0x6d9efd",
        "tokenIn": "_0x42f895",
        "rewards": "_0x8712a1",
        "setTeam": "_0x6cbd89",
        "penalty": "_0x93f8b2",
        "amounts": "_0xcd3a64",
        "deposit": "_0x96c149",
        "_period": "_0x6fa78b",
        "approve": "_0x1d1308",
        "swapper": "_0x2bd0d0",
        "enabled": "_0x095807",
        "weights": "_0x7cfc76",
        "rebase": "_0x9e65af",
        "locked": "_0x115897",
        "amount": "_0x9baf4b",
        "_voter": "_0x80ec03",
        "bribes": "_0x295f32",
        "shares": "_0xef133c",
        "tokens": "_0xf557b4",
        "gauges": "_0x544f34",
        "gauge": "_0x36a928",
        "write": "_0xb5ceb7",
        "claim": "_0xfb2f52",
        "_burn": "_0xc45561",
        "voter": "_0xdd69ab",
        "voted": "_0x69367f",
        "_time": "_0xe4cd32",
        "reset": "_0x16199a",
        "freed": "_0x9d5770",
        "_team": "_0x50f3d0",
        "pools": "_0x7205b7",
        "_HYBR": "_0xa66795",
        "owner": "_0x10e85a",
        "_mint": "_0xdbe3c1",
        "epoch": "_0xd076b1",
        "vote": "_0xa17d6d",
        "user": "_0xcafb62",
        "_fee": "_0xe5f8d5",
        "arr": "_0x2f0bfd",
        "fee": "_0x46fbd9",
        "end": "_0x82bb3b",
        "len": "_0xf52325",
        "max": "_0x7b84f1",
        "to": "_0xe4ff96"
      },
      "changes": [
        "Renamed 151 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_005",
      "transformed_id": "ss_l2_hex_sn_gs_005",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPairInfo.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVotingEscrow.sol';\nimport './interfaces/IGaugeManager.sol';\nimport './interfaces/IPermissionsRegistry.sol';\nimport './interfaces/ITokenHandler.sol';\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract VoterV3 is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public _0x902c91;                                         // the ve token that governs these contracts\n    address internal _0x7b4c76;                                      // $the token\n    address public _0xf547e6;                          // registry to check accesses\n    address public _0xf8ca15;\n    uint256 public _0x59ee51;\n    uint public EPOCH_DURATION;\n    uint256 internal constant MIN_VOTING_NUM = 10;\n    IGaugeManager public _0xe197b3;\n\n    mapping(uint256 => mapping(address => uint256)) public _0x06d0f2;  // nft      => pool     => votes\n    mapping(uint256 => address[]) public _0x444da1;                 // nft      => pools\n\n    mapping(address => uint256) public _0x02122e;\n    uint256 public _0x5a17d7;\n    mapping(uint256 => uint256) public _0xcfff42;\n\n    mapping(uint256 => uint256) public _0x25e8f6;                     // nft      => timestamp of last vote (this is shifted to thursday of that epoc)\n    mapping(uint256 => uint256) public _0xef5a70;            // nft      => timestamp of last vote\n\n    event Voted(address indexed _0xec7190, uint256 _0x09baac, uint256 _0x223ea6);\n    event Abstained(uint256 _0x09baac, uint256 _0x223ea6);\n    event SetPermissionRegistry(address indexed _0x89f7d0, address indexed _0x43c4ae);\n\n    constructor() {}\n\n    // function initialize(address __ve, address _pairFactory, address  _gaugeFactory, address _bribes, address _tokenHandler) initializer public {\n    function _0x69bd97(\n        address __ve,\n        address _0xb9cfa1,\n        address _0x3f6951,\n        address _0x79cf62\n    ) public _0xe1e871 {\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _0x902c91 = __ve;\n        _0x7b4c76 = IVotingEscrow(__ve)._0xf7d8f7();\n        _0xe197b3 = IGaugeManager(_0x3f6951);\n        _0xf547e6 = _0x79cf62;\n        _0xf8ca15 = _0xb9cfa1;\n        _0x59ee51 = 30;\n        EPOCH_DURATION = HybraTimeLibrary.WEEK;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    MODIFIERS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    modifier VoterAdmin() {\n        require(IPermissionsRegistry(_0xf547e6)._0x56a865(\"VOTER_ADMIN\",msg.sender), 'VOTER_ADMIN');\n        _;\n    }\n\n    modifier Governance() {\n        require(IPermissionsRegistry(_0xf547e6)._0x56a865(\"GOVERNANCE\",msg.sender), 'GOVERNANCE');\n        _;\n    }\n\n    modifier GenesisManager() {\n        require(IPermissionsRegistry(_0xf547e6)._0x56a865(\"GENESIS_MANAGER\", msg.sender), 'GENESIS_MANAGER');\n        _;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VoterAdmin\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice Set a new PermissionRegistry\n    function _0x24d2f7(address _0x79cf62) external VoterAdmin {\n        require(_0x79cf62.code.length > 0, \"CODELEN\");\n        require(_0x79cf62 != address(0), \"ZA\");\n        emit SetPermissionRegistry(_0xf547e6, _0x79cf62);\n        _0xf547e6 = _0x79cf62;\n    }\n\n    function _0x0f6a2b(uint256 _0x708f47) external VoterAdmin {\n        require (_0x708f47 >= MIN_VOTING_NUM, \"LOW_VOTE\");\n        _0x59ee51 = _0x708f47;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice Reset the votes of a given TokenID\n    function _0x63155d(uint256 _0x54da63) external _0x493e69(_0x54da63) _0xe5f5a2 {\n        require(IVotingEscrow(_0x902c91)._0x09db80(msg.sender, _0x54da63), \"NAO\");\n        _0xa01770(_0x54da63);\n        IVotingEscrow(_0x902c91)._0xd58fe4(_0x54da63);\n    }\n\n    function _0xa01770(uint256 _0x54da63) internal {\n        address[] storage _0xe10e94 = _0x444da1[_0x54da63];\n        uint256 _0xe7f919 = _0xe10e94.length;\n        uint256 _0xa770c5 = 0;\n\n        for (uint256 i = 0; i < _0xe7f919; i ++) {\n            address _0xbbb9cf = _0xe10e94[i];\n            uint256 _0x339809 = _0x06d0f2[_0x54da63][_0xbbb9cf];\n\n            if (_0x339809 != 0) {\n                _0x02122e[_0xbbb9cf] -= _0x339809;\n\n                _0x06d0f2[_0x54da63][_0xbbb9cf] -= _0x339809;\n                address _0x1da55a = _0xe197b3._0x42da21(_0xbbb9cf);\n                address _0x433412 = _0xe197b3._0xaae9a9(_0xbbb9cf);\n                IBribe(_0x1da55a)._0x3aca48(uint256(_0x339809), _0x54da63);\n                IBribe(_0x433412)._0x3aca48(uint256(_0x339809), _0x54da63);\n\n                // decrease totalWeight irrespective of gauge is killed/alive for this current pool\n                _0xa770c5 += _0x339809;\n\n                emit Abstained(_0x54da63, _0x339809);\n            }\n        }\n        _0x5a17d7 -= _0xa770c5;\n        _0xcfff42[_0x54da63] = 0;\n        delete _0x444da1[_0x54da63];\n    }\n\n    /// @notice Recast the saved votes of a given TokenID\n    function _0x95c8d5(uint256 _0x54da63) external _0xe5f5a2 {\n        uint256 _0x1d81a7 = block.timestamp;\n        if (_0x1d81a7 <= HybraTimeLibrary._0xffafd7(_0x1d81a7)){\n            revert(\"DW\");\n        }\n        require(IVotingEscrow(_0x902c91)._0x09db80(msg.sender, _0x54da63) || msg.sender == _0x902c91, \"NAO||VE\");\n        address[] memory _0xe10e94 = _0x444da1[_0x54da63];\n        uint256 _0xe34db9 = _0xe10e94.length;\n        uint256[] memory _0xad2c79 = new uint256[](_0xe34db9);\n\n        for (uint256 i = 0; i < _0xe34db9; i ++) {\n            _0xad2c79[i] = _0x06d0f2[_0x54da63][_0xe10e94[i]];\n        }\n\n        _0x4d0a13(_0x54da63, _0xe10e94, _0xad2c79);\n    }\n\n    /// @notice Vote for pools\n    /// @param  _tokenId    veNFT tokenID used to vote\n    /// @param  _poolVote   array of LPs addresses to vote  (eg.: [sAMM usdc-usdt   , sAMM busd-usdt, vAMM wbnb-the ,...])\n    /// @param  _weights    array of weights for each LPs   (eg.: [10               , 90            , 45             ,...])\n    function _0x0f6b87(uint256 _0x54da63, address[] calldata _0xe10e94, uint256[] calldata _0xad2c79)\n        external _0x493e69(_0x54da63) _0xe5f5a2 {\n        require(IVotingEscrow(_0x902c91)._0x09db80(msg.sender, _0x54da63), \"NAO\");\n        require(_0xe10e94.length == _0xad2c79.length, \"MISMATCH_LEN\");\n        require(_0xe10e94.length <= _0x59ee51, \"EXCEEDS\");\n        uint256 _0x1d81a7 = block.timestamp;\n\n        _0x4d0a13(_0x54da63, _0xe10e94, _0xad2c79);\n        _0x25e8f6[_0x54da63] = HybraTimeLibrary._0xac7e37(block.timestamp) + 1;\n        _0xef5a70[_0x54da63] = block.timestamp;\n    }\n\n    function _0x4d0a13(uint256 _0x54da63, address[] memory _0xe10e94, uint256[] memory _0xad2c79) internal {\n        _0xa01770(_0x54da63);\n        uint256 _0xe34db9 = _0xe10e94.length;\n        uint256 _0xc16f07 = IVotingEscrow(_0x902c91)._0x3495fa(_0x54da63);\n        uint256 _0x6e8dbc = 0;\n        uint256 _0x898df9 = 0;\n\n        for (uint i = 0; i < _0xe34db9; i++) {\n\n            if(_0xe197b3._0x05640b(_0xe10e94[i])) _0x6e8dbc += _0xad2c79[i];\n        }\n\n        for (uint256 i = 0; i < _0xe34db9; i++) {\n            address _0xbbb9cf = _0xe10e94[i];\n\n            if (_0xe197b3._0x05640b(_0xbbb9cf)) {\n                uint256 _0x1028f5 = _0xad2c79[i] * _0xc16f07 / _0x6e8dbc;\n\n                require(_0x06d0f2[_0x54da63][_0xbbb9cf] == 0, \"ZV\");\n                require(_0x1028f5 != 0, \"ZV\");\n\n                _0x444da1[_0x54da63].push(_0xbbb9cf);\n                _0x02122e[_0xbbb9cf] += _0x1028f5;\n\n                _0x06d0f2[_0x54da63][_0xbbb9cf] = _0x1028f5;\n                address _0x1da55a = _0xe197b3._0x42da21(_0xbbb9cf);\n                address _0x433412 = _0xe197b3._0xaae9a9(_0xbbb9cf);\n\n                IBribe(_0x1da55a)._0x7f050a(uint256(_0x1028f5), _0x54da63);\n                IBribe(_0x433412)._0x7f050a(uint256(_0x1028f5), _0x54da63);\n\n                _0x898df9 += _0x1028f5;\n                emit Voted(msg.sender, _0x54da63, _0x1028f5);\n            }\n        }\n        if (_0x898df9 > 0) IVotingEscrow(_0x902c91)._0x8a2204(_0x54da63);\n        _0x5a17d7 += _0x898df9;\n        _0xcfff42[_0x54da63] = _0x898df9;\n    }\n\n    modifier _0x493e69(uint256 _0x54da63) {\n        // ensure new epoch since last vote\n        if (HybraTimeLibrary._0xac7e37(block.timestamp) <= _0x25e8f6[_0x54da63]) revert(\"VOTED\");\n        if (block.timestamp <= HybraTimeLibrary._0xffafd7(block.timestamp)) revert(\"DW\");\n        _;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VIEW FUNCTIONS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice view the total length of the pools\n    function length() external view returns (uint256) {\n        return _0xe197b3._0x5486d4().length;\n    }\n\n    /// @notice view the total length of the voted pools given a tokenId\n    function _0x7dbfc4(uint256 _0x09baac) external view returns(uint256) {\n        return _0x444da1[_0x09baac].length;\n    }\n\n    function _0xca0de8(address _0x3f6951) external VoterAdmin {\n        require(_0x3f6951 != address(0));\n        _0xe197b3 = IGaugeManager(_0x3f6951);\n    }\n\n}",
      "rename_map": {
        "fetchInternalBribeFromPool": "_0x42da21",
        "fetchExternalBribeFromPool": "_0xaae9a9",
        "setPermissionsRegistry": "_0x24d2f7",
        "_permissionRegistry": "_0x79cf62",
        "isGaugeAliveForPool": "_0x05640b",
        "permissionRegistry": "_0xf547e6",
        "lastVotedTimestamp": "_0xef5a70",
        "isApprovedOrOwner": "_0x09db80",
        "_totalVoteWeight": "_0x6e8dbc",
        "setMaxVotingNum": "_0x0f6a2b",
        "setGaugeManager": "_0xca0de8",
        "internal_bribe": "_0x1da55a",
        "epochVoteStart": "_0xffafd7",
        "external_bribe": "_0x433412",
        "poolVoteLength": "_0x7dbfc4",
        "_gaugeManager": "_0x3f6951",
        "_tokenHandler": "_0xb9cfa1",
        "_maxVotingNum": "_0x708f47",
        "nonReentrant": "_0xe5f5a2",
        "tokenHandler": "_0xf8ca15",
        "_totalWeight": "_0xa770c5",
        "maxVotingNum": "_0x59ee51",
        "onlyNewEpoch": "_0x493e69",
        "balanceOfNFT": "_0x3495fa",
        "gaugeManager": "_0xe197b3",
        "_poolVoteCnt": "_0xe7f919",
        "usedWeights": "_0xcfff42",
        "_usedWeight": "_0x898df9",
        "initializer": "_0xe1e871",
        "_poolWeight": "_0x1028f5",
        "totalWeight": "_0x5a17d7",
        "epochStart": "_0xac7e37",
        "initialize": "_0x69bd97",
        "_timestamp": "_0x1d81a7",
        "_poolVote": "_0xe10e94",
        "lastVoted": "_0x25e8f6",
        "_weights": "_0xad2c79",
        "_tokenId": "_0x54da63",
        "_poolCnt": "_0xe34db9",
        "poolVote": "_0x444da1",
        "withdraw": "_0x3aca48",
        "hasRole": "_0x56a865",
        "tokenId": "_0x09baac",
        "abstain": "_0xd58fe4",
        "deposit": "_0x7f050a",
        "_weight": "_0xc16f07",
        "weights": "_0x02122e",
        "voting": "_0x8a2204",
        "_votes": "_0x339809",
        "_reset": "_0xa01770",
        "latest": "_0x43c4ae",
        "weight": "_0x223ea6",
        "reset": "_0x63155d",
        "voter": "_0xec7190",
        "_pool": "_0xbbb9cf",
        "votes": "_0x06d0f2",
        "_vote": "_0x4d0a13",
        "token": "_0xf7d8f7",
        "pools": "_0x5486d4",
        "poke": "_0x95c8d5",
        "base": "_0x7b4c76",
        "vote": "_0x0f6b87",
        "old": "_0x89f7d0",
        "_ve": "_0x902c91"
      },
      "changes": [
        "Renamed 64 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_006",
      "transformed_id": "ss_l2_hex_sn_gs_006",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable _0xda85be;\n    address public immutable _0xb8f9d6;\n    address public VE;\n    address public DISTRIBUTION;\n    address public _0x8e564c;\n    address public _0xe34fd9;\n\n    uint256 public DURATION;\n    uint256 internal _0xad737f;\n    uint256 public _0x20961f;\n    ICLPool public _0x4ca258;\n    address public _0x00b38a;\n    INonfungiblePositionManager public _0xd0ceb2;\n\n    bool public _0xf02270;\n    bool public immutable _0xd91d80;\n    address immutable _0x92859d;\n\n    mapping(uint256 => uint256) public  _0xeb0fea; // epoch => reward rate\n    mapping(address => EnumerableSet.UintSet) internal _0x13c9c7;\n    mapping(uint256 => uint256) public  _0x213f93;\n\n    mapping(uint256 => uint256) public  _0x84a66a;\n\n    mapping(uint256 => uint256) public  _0x9e405f;\n\n    event RewardAdded(uint256 _0xb3c8ac);\n    event Deposit(address indexed _0xe3a508, uint256 _0xa8b354);\n    event Withdraw(address indexed _0xe3a508, uint256 _0xa8b354);\n    event Harvest(address indexed _0xe3a508, uint256 _0xb3c8ac);\n    event ClaimFees(address indexed from, uint256 _0x336f73, uint256 _0x365927);\n    event EmergencyActivated(address indexed _0x9c1aaa, uint256 timestamp);\n    event EmergencyDeactivated(address indexed _0x9c1aaa, uint256 timestamp);\n\n    constructor(address _0x3561f5, address _0x7d2bfa, address _0x11a188, address _0x38cb89, address _0xed0bc8, address _0x43a8c7,\n        address _0x612db4, bool _0x95f927, address _0x384401,  address _0x1c4a43) {\n        _0x92859d = _0x1c4a43;\n        _0xda85be = IERC20(_0x3561f5);     // main reward\n        _0xb8f9d6 = _0x7d2bfa;\n        VE = _0x11a188;                               // vested\n        _0x00b38a = _0x38cb89;\n        _0x4ca258 = ICLPool(_0x38cb89);\n        DISTRIBUTION = _0xed0bc8;           // distro address (GaugeManager)\n        DURATION = HybraTimeLibrary.WEEK;\n\n        _0x8e564c = _0x43a8c7;       // lp fees goes here\n        _0xe34fd9 = _0x612db4;       // bribe fees goes here\n        _0xd91d80 = _0x95f927;\n        _0xd0ceb2 = INonfungiblePositionManager(_0x384401);\n        _0xf02270 = false;\n    }\n\n    modifier _0xa65f5c() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier _0x8bd36a() {\n        require(_0xf02270 == false, \"emergency\");\n        _;\n    }\n\n    function _0xc4030a(uint256 _0x3fd364, int24 _0x70cf82, int24 _0x2a272c) internal {\n        if (_0x9e405f[_0x3fd364] == block.timestamp) return;\n        _0x4ca258._0xeffdd8();\n        _0x9e405f[_0x3fd364] = block.timestamp;\n        _0x84a66a[_0x3fd364] += _0xef90e8(_0x3fd364);\n        _0x213f93[_0x3fd364] = _0x4ca258._0xdb4afa(_0x70cf82, _0x2a272c, 0);\n    }\n\n    function _0x544b53() external _0x66c2e2 {\n        require(_0xf02270 == false, \"emergency\");\n        _0xf02270 = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function _0x3d2cce() external _0x66c2e2 {\n\n        require(_0xf02270 == true,\"emergency\");\n\n        _0xf02270 = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function _0xe44184(uint256 _0x3fd364) external view returns (uint256) {\n        (,,,,,,,uint128 _0x8785a5,,,,) = _0xd0ceb2._0xcf8311(_0x3fd364);\n        return _0x8785a5;\n    }\n\n    function _0x266ea6(address _0x74bbf7, address _0x72e7ee, int24 _0xd26eb3) internal view returns (address) {\n        return ICLFactory(_0xd0ceb2._0x92859d())._0x26bb7b(_0x74bbf7, _0x72e7ee, _0xd26eb3);\n    }\n\n    function _0x30d0da(uint256 _0x3fd364) external view returns (uint256 _0xb3c8ac) {\n        require(_0x13c9c7[msg.sender]._0x4c3ff5(_0x3fd364), \"NA\");\n\n        uint256 _0xb3c8ac = _0xef90e8(_0x3fd364);\n        return (_0xb3c8ac); // bonsReward is 0 for now\n    }\n\n       function _0xef90e8(uint256 _0x3fd364) internal view returns (uint256) {\n        uint256 _0x9e0b4d = _0x4ca258._0x9e0b4d();\n\n        uint256 _0x0192aa = block.timestamp - _0x9e0b4d;\n\n        uint256 _0xc46810 = _0x4ca258._0xc46810();\n        uint256 _0x47bc41 = _0x4ca258._0x47bc41();\n\n        if (_0x0192aa != 0 && _0x47bc41 > 0 && _0x4ca258._0xc67680() > 0) {\n            uint256 _0xb3c8ac = _0x20961f * _0x0192aa;\n            if (_0xb3c8ac > _0x47bc41) _0xb3c8ac = _0x47bc41;\n\n            _0xc46810 += FullMath._0xbba29d(_0xb3c8ac, FixedPoint128.Q128, _0x4ca258._0xc67680());\n        }\n\n        (,,,,, int24 _0x70cf82, int24 _0x2a272c, uint128 _0x8785a5,,,,) = _0xd0ceb2._0xcf8311(_0x3fd364);\n\n        uint256 _0xf8c2cb = _0x213f93[_0x3fd364];\n        uint256 _0x38cc25 = _0x4ca258._0xdb4afa(_0x70cf82, _0x2a272c, _0xc46810);\n\n        uint256 _0xdd5568 =\n            FullMath._0xbba29d(_0x38cc25 - _0xf8c2cb, _0x8785a5, FixedPoint128.Q128);\n        return _0xdd5568;\n    }\n\n    function _0x628f9e(uint256 _0x3fd364) external _0x1cfc59 _0x8bd36a {\n\n         (,,address _0x74bbf7, address _0x72e7ee, int24 _0xd26eb3, int24 _0x70cf82, int24 _0x2a272c, uint128 _0x8785a5,,,,) =\n            _0xd0ceb2._0xcf8311(_0x3fd364);\n\n        require(_0x8785a5 > 0, \"Gauge: zero liquidity\");\n        // Calculate pool address from position parameters\n        address _0xc6b38d = _0x266ea6(_0x74bbf7, _0x72e7ee, _0xd26eb3);\n        // Verify that the position's pool matches this gauge's pool\n        require(_0xc6b38d == _0x00b38a, \"Pool mismatch: Position not for this gauge pool\");\n        // collect fees\n        _0xd0ceb2._0xde353c(INonfungiblePositionManager.CollectParams({\n                _0x3fd364: _0x3fd364,\n                _0x162371: msg.sender,\n                _0x4a0459: type(uint128)._0xce98f5,\n                _0x98e532: type(uint128)._0xce98f5\n            }));\n\n        _0xd0ceb2._0x8b2eb0(msg.sender, address(this), _0x3fd364);\n\n        _0x4ca258._0xa76e45(int128(_0x8785a5), _0x70cf82, _0x2a272c, true);\n\n        uint256 _0x7101ed = _0x4ca258._0xdb4afa(_0x70cf82, _0x2a272c, 0);\n        _0x213f93[_0x3fd364] = _0x7101ed;\n        _0x9e405f[_0x3fd364] = block.timestamp;\n\n        _0x13c9c7[msg.sender]._0xc9bfaf(_0x3fd364);\n\n        emit Deposit(msg.sender, _0x3fd364);\n    }\n\n    function _0x7eb23b(uint256 _0x3fd364, uint8 _0x42b65e) external _0x1cfc59 _0x8bd36a {\n           require(_0x13c9c7[msg.sender]._0x4c3ff5(_0x3fd364), \"NA\");\n\n        // trigger update on staked position so NFT will be in sync with the pool\n        _0xd0ceb2._0xde353c(\n            INonfungiblePositionManager.CollectParams({\n                _0x3fd364: _0x3fd364,\n                _0x162371: msg.sender,\n                _0x4a0459: type(uint128)._0xce98f5,\n                _0x98e532: type(uint128)._0xce98f5\n            })\n        );\n\n        (,,,,, int24 _0x70cf82, int24 _0x2a272c, uint128 _0xfa0c1c,,,,) = _0xd0ceb2._0xcf8311(_0x3fd364);\n        _0x5b3948(_0x70cf82, _0x2a272c, _0x3fd364, msg.sender, _0x42b65e);\n\n        // update virtual liquidity in pool only if token has existing liquidity\n        // i.e. not all removed already via decreaseStakedLiquidity\n        if (_0xfa0c1c != 0) {\n            _0x4ca258._0xa76e45(-int128(_0xfa0c1c), _0x70cf82, _0x2a272c, true);\n        }\n\n        _0x13c9c7[msg.sender]._0x074910(_0x3fd364);\n        _0xd0ceb2._0x8b2eb0(address(this), msg.sender, _0x3fd364);\n\n        emit Withdraw(msg.sender, _0x3fd364);\n    }\n\n    function _0x617714(uint256 _0x3fd364, address _0x10b5ff,uint8 _0x42b65e ) public _0x1cfc59 _0xa65f5c {\n\n        require(_0x13c9c7[_0x10b5ff]._0x4c3ff5(_0x3fd364), \"NA\");\n\n        (,,,,, int24 _0x70cf82, int24 _0x2a272c,,,,,) = _0xd0ceb2._0xcf8311(_0x3fd364);\n        _0x5b3948(_0x70cf82, _0x2a272c, _0x3fd364, _0x10b5ff, _0x42b65e);\n    }\n\n    function _0x5b3948(int24 _0x70cf82, int24 _0x2a272c, uint256 _0x3fd364,address _0x10b5ff, uint8 _0x42b65e) internal {\n        _0xc4030a(_0x3fd364, _0x70cf82, _0x2a272c);\n        uint256 _0xa67e8b = _0x84a66a[_0x3fd364];\n        if(_0xa67e8b > 0){\n            delete _0x84a66a[_0x3fd364];\n            _0xda85be._0x6dc32c(_0xb8f9d6, _0xa67e8b);\n            IRHYBR(_0xb8f9d6)._0x1ac785(_0xa67e8b);\n            IRHYBR(_0xb8f9d6)._0x302e8f(_0xa67e8b, _0x42b65e, _0x10b5ff);\n        }\n        emit Harvest(msg.sender, _0xa67e8b);\n    }\n\n    function _0xde608c(address _0xb70c77, uint256 _0xa67e8b) external _0x1cfc59\n        _0x8bd36a _0xa65f5c returns (uint256 _0xa274d1) {\n        require(_0xb70c77 == address(_0xda85be), \"Invalid reward token\");\n\n        // Update global reward growth before processing new rewards\n        _0x4ca258._0xeffdd8();\n\n        // Calculate time remaining until next epoch begins\n        uint256 _0x56baaa = HybraTimeLibrary._0x4d4659(block.timestamp) - block.timestamp;\n        uint256 _0xeeb4c5 = block.timestamp + _0x56baaa;\n\n        // Include any rolled over rewards from previous period\n        uint256 _0xd9d9b1 = _0xa67e8b + _0x4ca258._0x39eb4e();\n\n        // Check if we are starting a new reward period or continuing existing one\n        if (block.timestamp >= _0xad737f) {\n            // New period: distribute rewards over remaining epoch time\n            _0x20961f = _0xa67e8b / _0x56baaa;\n            _0x4ca258._0x7e494c({\n                _0x20961f: _0x20961f,\n                _0x47bc41: _0xd9d9b1,\n                _0xd79977: _0xeeb4c5\n            });\n        } else {\n            // Existing period: add new rewards to pending distribution\n            uint256 _0x26bd16 = _0x56baaa * _0x20961f;\n            _0x20961f = (_0xa67e8b + _0x26bd16) / _0x56baaa;\n            _0x4ca258._0x7e494c({\n                _0x20961f: _0x20961f,\n                _0x47bc41: _0xd9d9b1 + _0x26bd16,\n                _0xd79977: _0xeeb4c5\n            });\n        }\n\n        // Store reward rate for current epoch tracking\n        _0xeb0fea[HybraTimeLibrary._0x09adbc(block.timestamp)] = _0x20961f;\n\n        // Transfer reward tokens from distributor to gauge\n        _0xda85be._0x8b2eb0(DISTRIBUTION, address(this), _0xa67e8b);\n\n        // Verify contract has sufficient balance to support calculated reward rate\n        uint256 _0x739064 = _0xda85be._0xe44184(address(this));\n        require(_0x20961f <= _0x739064 / _0x56baaa, \"Insufficient balance for reward rate\");\n\n        // Update period finish time and return current rate\n        _0xad737f = _0xeeb4c5;\n        _0xa274d1 = _0x20961f;\n\n        emit RewardAdded(_0xa67e8b);\n    }\n\n    function _0x06c53b() external view returns (uint256 _0x74bbf7, uint256 _0x72e7ee){\n\n        (_0x74bbf7, _0x72e7ee) = _0x4ca258._0x7ab2e5();\n\n    }\n\n    function _0x13bdca() external _0x1cfc59 returns (uint256 _0x336f73, uint256 _0x365927) {\n        return _0xc6987c();\n    }\n\n    function _0xc6987c() internal returns (uint256 _0x336f73, uint256 _0x365927) {\n        if (!_0xd91d80) {\n            return (0, 0);\n        }\n\n        _0x4ca258._0xd74ca0();\n\n        address _0x57c2d1 = _0x4ca258._0x74bbf7();\n        address _0xd813b4 = _0x4ca258._0x72e7ee();\n        // Fetch fee from the whole epoch which just eneded and transfer it to internal Bribe address.\n        _0x336f73 = IERC20(_0x57c2d1)._0xe44184(address(this));\n        _0x365927 = IERC20(_0xd813b4)._0xe44184(address(this));\n\n        if (_0x336f73 > 0 || _0x365927 > 0) {\n\n            uint256 _0xfd2da3 = _0x336f73;\n            uint256 _0xd57b76 = _0x365927;\n\n            if (_0xfd2da3  > 0) {\n                IERC20(_0x57c2d1)._0x6dc32c(_0x8e564c, 0);\n                IERC20(_0x57c2d1)._0x6dc32c(_0x8e564c, _0xfd2da3);\n                IBribe(_0x8e564c)._0xde608c(_0x57c2d1, _0xfd2da3);\n            }\n            if (_0xd57b76  > 0) {\n                IERC20(_0xd813b4)._0x6dc32c(_0x8e564c, 0);\n                IERC20(_0xd813b4)._0x6dc32c(_0x8e564c, _0xd57b76);\n                IBribe(_0x8e564c)._0xde608c(_0xd813b4, _0xd57b76);\n            }\n            emit ClaimFees(msg.sender, _0x336f73, _0x365927);\n        }\n    }\n\n    ///@notice get total reward for the duration\n    function _0xedaf64() external view returns (uint256) {\n        return _0x20961f * DURATION;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function _0x5399ec(address _0x9ff964) external _0x66c2e2 {\n        require(_0x9ff964 >= address(0), \"zero\");\n        _0x8e564c = _0x9ff964;\n    }\n\n    function _0x5fdb7f(address _0xb70c77,address _0x6d52f1,uint256 value) internal {\n        require(_0xb70c77.code.length > 0);\n        (bool _0xfbd54e, bytes memory data) = _0xb70c77.call(abi._0x467cdd(IERC20.transfer.selector, _0x6d52f1, value));\n        require(_0xfbd54e && (data.length == 0 || abi._0xec1d3d(data, (bool))));\n    }\n\n    /**\n     * @dev Handle the receipt of an NFT\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function _0x18d970(\n        address _0x67eb0a,\n        address from,\n        uint256 _0x3fd364,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver._0x18d970.selector;\n    }\n\n}\n\n",
      "rename_map": {
        "rewardPerTokenInsideInitialX128": "_0xf8c2cb",
        "nonfungiblePositionManager": "_0xd0ceb2",
        "updateRewardsGrowthGlobal": "_0xeffdd8",
        "rewardPerTokenInsideX128": "_0x38cc25",
        "depostionEmissionsToken": "_0x1ac785",
        "rewardGrowthGlobalX128": "_0xc46810",
        "activateEmergencyMode": "_0x544b53",
        "getRewardGrowthInside": "_0xdb4afa",
        "notifyRewardAmount": "_0xde608c",
        "rewardGrowthInside": "_0x213f93",
        "encodeWithSelector": "_0x467cdd",
        "epochTimeRemaining": "_0x56baaa",
        "rewardForDuration": "_0xedaf64",
        "stopEmergencyMode": "_0x3d2cce",
        "rewardRateByEpoch": "_0xeb0fea",
        "totalRewardAmount": "_0xd9d9b1",
        "epochEndTimestamp": "_0xeeb4c5",
        "safeTransferFrom": "_0x8b2eb0",
        "setInternalBribe": "_0x5399ec",
        "onlyDistribution": "_0xa65f5c",
        "onERC721Received": "_0x18d970",
        "liquidityToStake": "_0xfa0c1c",
        "_internal_bribe": "_0x43a8c7",
        "_getPoolAddress": "_0x266ea6",
        "stakedLiquidity": "_0xc67680",
        "contractBalance": "_0x739064",
        "_external_bribe": "_0x612db4",
        "_updateRewards": "_0xc4030a",
        "pendingRewards": "_0x26bd16",
        "external_bribe": "_0xe34fd9",
        "internal_bribe": "_0x8e564c",
        "lastUpdateTime": "_0x9e405f",
        "isNotEmergency": "_0x8bd36a",
        "rewardReserve": "_0x47bc41",
        "_periodFinish": "_0xad737f",
        "_safeTransfer": "_0x5fdb7f",
        "_distribution": "_0xed0bc8",
        "gaugeBalances": "_0x06c53b",
        "rewardGrowth": "_0x7101ed",
        "positionPool": "_0xc6b38d",
        "nonReentrant": "_0x1cfc59",
        "rewardAmount": "_0xa67e8b",
        "periodFinish": "_0xd79977",
        "_rewardToken": "_0x3561f5",
        "tickSpacing": "_0xd26eb3",
        "lastUpdated": "_0x9e0b4d",
        "collectFees": "_0xd74ca0",
        "poolAddress": "_0x00b38a",
        "currentRate": "_0xa274d1",
        "rewardToken": "_0xda85be",
        "safeApprove": "_0x6dc32c",
        "epochStart": "_0x09adbc",
        "syncReward": "_0x7e494c",
        "rewardRate": "_0x20961f",
        "amount0Max": "_0x4a0459",
        "_isForPair": "_0x95f927",
        "_getReward": "_0x5b3948",
        "_claimFees": "_0xc6987c",
        "redeemType": "_0x42b65e",
        "amount1Max": "_0x98e532",
        "getReward": "_0x617714",
        "redeemFor": "_0x302e8f",
        "emergency": "_0xf02270",
        "tickUpper": "_0x2a272c",
        "tickLower": "_0x70cf82",
        "isForPair": "_0xd91d80",
        "claimable": "_0xdd5568",
        "timeDelta": "_0x0192aa",
        "onlyOwner": "_0x66c2e2",
        "recipient": "_0x162371",
        "positions": "_0xcf8311",
        "balanceOf": "_0xe44184",
        "gaugeFees": "_0x7ab2e5",
        "claimFees": "_0x13bdca",
        "epochNext": "_0x4d4659",
        "liquidity": "_0x8785a5",
        "rollover": "_0x39eb4e",
        "operator": "_0x67eb0a",
        "_factory": "_0x1c4a43",
        "withdraw": "_0x7eb23b",
        "contains": "_0x4c3ff5",
        "claimed1": "_0x365927",
        "claimed0": "_0x336f73",
        "_stakes": "_0x13c9c7",
        "factory": "_0x92859d",
        "_token1": "_0xd813b4",
        "rewards": "_0x84a66a",
        "_token0": "_0x57c2d1",
        "_earned": "_0xef90e8",
        "getPool": "_0x26bb7b",
        "account": "_0x10b5ff",
        "success": "_0xfbd54e",
        "deposit": "_0x628f9e",
        "tokenId": "_0x3fd364",
        "collect": "_0xde353c",
        "mulDiv": "_0xbba29d",
        "_rHYBR": "_0x7d2bfa",
        "token0": "_0x74bbf7",
        "amount": "_0xa8b354",
        "earned": "_0x30d0da",
        "remove": "_0x074910",
        "decode": "_0xec1d3d",
        "_fees1": "_0xd57b76",
        "token1": "_0x72e7ee",
        "_fees0": "_0xfd2da3",
        "clPool": "_0x4ca258",
        "reward": "_0xb3c8ac",
        "gauge": "_0x9c1aaa",
        "rHYBR": "_0xb8f9d6",
        "_pool": "_0x38cb89",
        "token": "_0xb70c77",
        "stake": "_0xa76e45",
        "nfpm": "_0x384401",
        "_int": "_0x9ff964",
        "user": "_0xe3a508",
        "add": "_0xc9bfaf",
        "max": "_0xce98f5",
        "_ve": "_0x11a188",
        "to": "_0x6d52f1"
      },
      "changes": [
        "Renamed 119 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_007",
      "transformed_id": "ss_l2_hex_sn_gs_007",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable _0x0c6f2f;\n    address public immutable _0xec62a3;\n    address public VE;\n    address public DISTRIBUTION;\n    address public _0x4d46cf;\n    address public _0x85e39c;\n\n    uint256 public DURATION;\n    uint256 internal _0xb0aee8;\n    uint256 public _0xf7d23a;\n    ICLPool public _0x52c5ec;\n    address public _0x387970;\n    INonfungiblePositionManager public _0x32575e;\n\n    bool public _0x26616e;\n    bool public immutable _0x1e4b45;\n    address immutable _0x3a6b03;\n\n    mapping(uint256 => uint256) public  _0xba7465; // epoch => reward rate\n    mapping(address => EnumerableSet.UintSet) internal _0x250c8a;\n    mapping(uint256 => uint256) public  _0xd36935;\n\n    mapping(uint256 => uint256) public  _0x77d6b0;\n\n    mapping(uint256 => uint256) public  _0x7b7e67;\n\n    event RewardAdded(uint256 _0xe30b28);\n    event Deposit(address indexed _0x4ed4b0, uint256 _0xe73e03);\n    event Withdraw(address indexed _0x4ed4b0, uint256 _0xe73e03);\n    event Harvest(address indexed _0x4ed4b0, uint256 _0xe30b28);\n    event ClaimFees(address indexed from, uint256 _0xf841e3, uint256 _0x6666d7);\n    event EmergencyActivated(address indexed _0x46b2ac, uint256 timestamp);\n    event EmergencyDeactivated(address indexed _0x46b2ac, uint256 timestamp);\n\n    constructor(address _0x8d0405, address _0xac27a1, address _0x5ba5a8, address _0x208cbe, address _0x02207b, address _0x7f07ab,\n        address _0xdc464a, bool _0x390066, address _0x0fca62,  address _0xab4815) {\n        _0x3a6b03 = _0xab4815;\n        _0x0c6f2f = IERC20(_0x8d0405);     // main reward\n        _0xec62a3 = _0xac27a1;\n        VE = _0x5ba5a8;                               // vested\n        _0x387970 = _0x208cbe;\n        _0x52c5ec = ICLPool(_0x208cbe);\n        DISTRIBUTION = _0x02207b;           // distro address (GaugeManager)\n        DURATION = HybraTimeLibrary.WEEK;\n\n        _0x4d46cf = _0x7f07ab;       // lp fees goes here\n        _0x85e39c = _0xdc464a;       // bribe fees goes here\n        _0x1e4b45 = _0x390066;\n        _0x32575e = INonfungiblePositionManager(_0x0fca62);\n        _0x26616e = false;\n    }\n\n    modifier _0x203c98() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier _0xe7156e() {\n        require(_0x26616e == false, \"emergency\");\n        _;\n    }\n\n    function _0x04af4f(uint256 _0x4aa1d3, int24 _0x4ca32c, int24 _0xee8b22) internal {\n        if (_0x7b7e67[_0x4aa1d3] == block.timestamp) return;\n        _0x52c5ec._0xa931bc();\n        _0x7b7e67[_0x4aa1d3] = block.timestamp;\n        _0x77d6b0[_0x4aa1d3] += _0x4d9677(_0x4aa1d3);\n        _0xd36935[_0x4aa1d3] = _0x52c5ec._0xd0186c(_0x4ca32c, _0xee8b22, 0);\n    }\n\n    function _0xe2f8d4() external _0x70acec {\n        require(_0x26616e == false, \"emergency\");\n        _0x26616e = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function _0x96996e() external _0x70acec {\n\n        require(_0x26616e == true,\"emergency\");\n\n        _0x26616e = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function _0x835101(uint256 _0x4aa1d3) external view returns (uint256) {\n        (,,,,,,,uint128 _0x46e160,,,,) = _0x32575e._0x234396(_0x4aa1d3);\n        return _0x46e160;\n    }\n\n    function _0xbee468(address _0x52c311, address _0x7369b8, int24 _0x96ab3c) internal view returns (address) {\n        return ICLFactory(_0x32575e._0x3a6b03())._0x1964c8(_0x52c311, _0x7369b8, _0x96ab3c);\n    }\n\n    function _0xcb603e(uint256 _0x4aa1d3) external view returns (uint256 _0xe30b28) {\n        require(_0x250c8a[msg.sender]._0x9c01cc(_0x4aa1d3), \"NA\");\n\n        uint256 _0xe30b28 = _0x4d9677(_0x4aa1d3);\n        return (_0xe30b28); // bonsReward is 0 for now\n    }\n\n       function _0x4d9677(uint256 _0x4aa1d3) internal view returns (uint256) {\n        uint256 _0x9158d1 = _0x52c5ec._0x9158d1();\n\n        uint256 _0x3ebf9f = block.timestamp - _0x9158d1;\n\n        uint256 _0xddd465 = _0x52c5ec._0xddd465();\n        uint256 _0xfa9c48 = _0x52c5ec._0xfa9c48();\n\n        if (_0x3ebf9f != 0 && _0xfa9c48 > 0 && _0x52c5ec._0x619646() > 0) {\n            uint256 _0xe30b28 = _0xf7d23a * _0x3ebf9f;\n            if (_0xe30b28 > _0xfa9c48) _0xe30b28 = _0xfa9c48;\n\n            _0xddd465 += FullMath._0x0d2442(_0xe30b28, FixedPoint128.Q128, _0x52c5ec._0x619646());\n        }\n\n        (,,,,, int24 _0x4ca32c, int24 _0xee8b22, uint128 _0x46e160,,,,) = _0x32575e._0x234396(_0x4aa1d3);\n\n        uint256 _0x302b05 = _0xd36935[_0x4aa1d3];\n        uint256 _0xdda7b4 = _0x52c5ec._0xd0186c(_0x4ca32c, _0xee8b22, _0xddd465);\n\n        uint256 _0x034fd7 =\n            FullMath._0x0d2442(_0xdda7b4 - _0x302b05, _0x46e160, FixedPoint128.Q128);\n        return _0x034fd7;\n    }\n\n    function _0x43dab1(uint256 _0x4aa1d3) external _0x98d996 _0xe7156e {\n\n         (,,address _0x52c311, address _0x7369b8, int24 _0x96ab3c, int24 _0x4ca32c, int24 _0xee8b22, uint128 _0x46e160,,,,) =\n            _0x32575e._0x234396(_0x4aa1d3);\n\n        require(_0x46e160 > 0, \"Gauge: zero liquidity\");\n        // Calculate pool address from position parameters\n        address _0xcf1d7c = _0xbee468(_0x52c311, _0x7369b8, _0x96ab3c);\n        // Verify that the position's pool matches this gauge's pool\n        require(_0xcf1d7c == _0x387970, \"Pool mismatch: Position not for this gauge pool\");\n        // collect fees\n        _0x32575e._0x011315(INonfungiblePositionManager.CollectParams({\n                _0x4aa1d3: _0x4aa1d3,\n                _0x4eabb3: msg.sender,\n                _0x3cd116: type(uint128)._0x409af3,\n                _0xdeb34b: type(uint128)._0x409af3\n            }));\n\n        _0x32575e._0x8e86e9(msg.sender, address(this), _0x4aa1d3);\n\n        _0x52c5ec._0x81c6bd(int128(_0x46e160), _0x4ca32c, _0xee8b22, true);\n\n        uint256 _0xb19540 = _0x52c5ec._0xd0186c(_0x4ca32c, _0xee8b22, 0);\n        _0xd36935[_0x4aa1d3] = _0xb19540;\n        _0x7b7e67[_0x4aa1d3] = block.timestamp;\n\n        _0x250c8a[msg.sender]._0x81c8c7(_0x4aa1d3);\n\n        emit Deposit(msg.sender, _0x4aa1d3);\n    }\n\n    function _0xe89447(uint256 _0x4aa1d3, uint8 _0xdcf75e) external _0x98d996 _0xe7156e {\n           require(_0x250c8a[msg.sender]._0x9c01cc(_0x4aa1d3), \"NA\");\n\n        // trigger update on staked position so NFT will be in sync with the pool\n        _0x32575e._0x011315(\n            INonfungiblePositionManager.CollectParams({\n                _0x4aa1d3: _0x4aa1d3,\n                _0x4eabb3: msg.sender,\n                _0x3cd116: type(uint128)._0x409af3,\n                _0xdeb34b: type(uint128)._0x409af3\n            })\n        );\n\n        (,,,,, int24 _0x4ca32c, int24 _0xee8b22, uint128 _0x047206,,,,) = _0x32575e._0x234396(_0x4aa1d3);\n        _0xb99986(_0x4ca32c, _0xee8b22, _0x4aa1d3, msg.sender, _0xdcf75e);\n\n        // update virtual liquidity in pool only if token has existing liquidity\n        // i.e. not all removed already via decreaseStakedLiquidity\n        if (_0x047206 != 0) {\n            _0x52c5ec._0x81c6bd(-int128(_0x047206), _0x4ca32c, _0xee8b22, true);\n        }\n\n        _0x250c8a[msg.sender]._0xe01a73(_0x4aa1d3);\n        _0x32575e._0x8e86e9(address(this), msg.sender, _0x4aa1d3);\n\n        emit Withdraw(msg.sender, _0x4aa1d3);\n    }\n\n    function _0x416464(uint256 _0x4aa1d3, address _0xcb0266,uint8 _0xdcf75e ) public _0x98d996 _0x203c98 {\n\n        require(_0x250c8a[_0xcb0266]._0x9c01cc(_0x4aa1d3), \"NA\");\n\n        (,,,,, int24 _0x4ca32c, int24 _0xee8b22,,,,,) = _0x32575e._0x234396(_0x4aa1d3);\n        _0xb99986(_0x4ca32c, _0xee8b22, _0x4aa1d3, _0xcb0266, _0xdcf75e);\n    }\n\n    function _0xb99986(int24 _0x4ca32c, int24 _0xee8b22, uint256 _0x4aa1d3,address _0xcb0266, uint8 _0xdcf75e) internal {\n        _0x04af4f(_0x4aa1d3, _0x4ca32c, _0xee8b22);\n        uint256 _0x359420 = _0x77d6b0[_0x4aa1d3];\n        if(_0x359420 > 0){\n            delete _0x77d6b0[_0x4aa1d3];\n            _0x0c6f2f._0xe0eec3(_0xec62a3, _0x359420);\n            IRHYBR(_0xec62a3)._0xe23d28(_0x359420);\n            IRHYBR(_0xec62a3)._0xe42d76(_0x359420, _0xdcf75e, _0xcb0266);\n        }\n        emit Harvest(msg.sender, _0x359420);\n    }\n\n    function _0x404f78(address _0x23cdce, uint256 _0x359420) external _0x98d996\n        _0xe7156e _0x203c98 returns (uint256 _0xfcd942) {\n        require(_0x23cdce == address(_0x0c6f2f), \"Invalid reward token\");\n\n        // Update global reward growth before processing new rewards\n        _0x52c5ec._0xa931bc();\n\n        // Calculate time remaining until next epoch begins\n        uint256 _0x9651e6 = HybraTimeLibrary._0xdae2d3(block.timestamp) - block.timestamp;\n        uint256 _0xf392b8 = block.timestamp + _0x9651e6;\n\n        // Include any rolled over rewards from previous period\n        uint256 _0xbd60aa = _0x359420 + _0x52c5ec._0x6603cb();\n\n        // Check if we are starting a new reward period or continuing existing one\n        if (block.timestamp >= _0xb0aee8) {\n            // New period: distribute rewards over remaining epoch time\n            _0xf7d23a = _0x359420 / _0x9651e6;\n            _0x52c5ec._0xdd528f({\n                _0xf7d23a: _0xf7d23a,\n                _0xfa9c48: _0xbd60aa,\n                _0x2a3f0e: _0xf392b8\n            });\n        } else {\n            // Existing period: add new rewards to pending distribution\n            uint256 _0xebe52b = _0x9651e6 * _0xf7d23a;\n            _0xf7d23a = (_0x359420 + _0xebe52b) / _0x9651e6;\n            _0x52c5ec._0xdd528f({\n                _0xf7d23a: _0xf7d23a,\n                _0xfa9c48: _0xbd60aa + _0xebe52b,\n                _0x2a3f0e: _0xf392b8\n            });\n        }\n\n        // Store reward rate for current epoch tracking\n        _0xba7465[HybraTimeLibrary._0xf0bec0(block.timestamp)] = _0xf7d23a;\n\n        // Transfer reward tokens from distributor to gauge\n        _0x0c6f2f._0x8e86e9(DISTRIBUTION, address(this), _0x359420);\n\n        // Verify contract has sufficient balance to support calculated reward rate\n        uint256 _0xb06ace = _0x0c6f2f._0x835101(address(this));\n        require(_0xf7d23a <= _0xb06ace / _0x9651e6, \"Insufficient balance for reward rate\");\n\n        // Update period finish time and return current rate\n        _0xb0aee8 = _0xf392b8;\n        _0xfcd942 = _0xf7d23a;\n\n        emit RewardAdded(_0x359420);\n    }\n\n    function _0x653eef() external view returns (uint256 _0x52c311, uint256 _0x7369b8){\n\n        (_0x52c311, _0x7369b8) = _0x52c5ec._0x4b9c06();\n\n    }\n\n    function _0x28d570() external _0x98d996 returns (uint256 _0xf841e3, uint256 _0x6666d7) {\n        return _0xf67d71();\n    }\n\n    function _0xf67d71() internal returns (uint256 _0xf841e3, uint256 _0x6666d7) {\n        if (!_0x1e4b45) {\n            return (0, 0);\n        }\n\n        _0x52c5ec._0xce0309();\n\n        address _0xd35c7d = _0x52c5ec._0x52c311();\n        address _0x755ca7 = _0x52c5ec._0x7369b8();\n        // Fetch fee from the whole epoch which just eneded and transfer it to internal Bribe address.\n        _0xf841e3 = IERC20(_0xd35c7d)._0x835101(address(this));\n        _0x6666d7 = IERC20(_0x755ca7)._0x835101(address(this));\n\n        if (_0xf841e3 > 0 || _0x6666d7 > 0) {\n\n            uint256 _0x00e6ca = _0xf841e3;\n            uint256 _0xc62c5a = _0x6666d7;\n\n            if (_0x00e6ca  > 0) {\n                IERC20(_0xd35c7d)._0xe0eec3(_0x4d46cf, 0);\n                IERC20(_0xd35c7d)._0xe0eec3(_0x4d46cf, _0x00e6ca);\n                IBribe(_0x4d46cf)._0x404f78(_0xd35c7d, _0x00e6ca);\n            }\n            if (_0xc62c5a  > 0) {\n                IERC20(_0x755ca7)._0xe0eec3(_0x4d46cf, 0);\n                IERC20(_0x755ca7)._0xe0eec3(_0x4d46cf, _0xc62c5a);\n                IBribe(_0x4d46cf)._0x404f78(_0x755ca7, _0xc62c5a);\n            }\n            emit ClaimFees(msg.sender, _0xf841e3, _0x6666d7);\n        }\n    }\n\n    ///@notice get total reward for the duration\n    function _0x32df17() external view returns (uint256) {\n        return _0xf7d23a * DURATION;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function _0x931bc5(address _0xae7501) external _0x70acec {\n        require(_0xae7501 >= address(0), \"zero\");\n        _0x4d46cf = _0xae7501;\n    }\n\n    function _0x000a77(address _0x23cdce,address _0x506bf5,uint256 value) internal {\n        require(_0x23cdce.code.length > 0);\n        (bool _0x354499, bytes memory data) = _0x23cdce.call(abi._0xbca373(IERC20.transfer.selector, _0x506bf5, value));\n        require(_0x354499 && (data.length == 0 || abi._0x50cfb0(data, (bool))));\n    }\n\n    /**\n     * @dev Handle the receipt of an NFT\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function _0x4c4bc5(\n        address _0x431c2f,\n        address from,\n        uint256 _0x4aa1d3,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver._0x4c4bc5.selector;\n    }\n\n}\n\n",
      "rename_map": {
        "rewardPerTokenInsideInitialX128": "_0x302b05",
        "nonfungiblePositionManager": "_0x32575e",
        "updateRewardsGrowthGlobal": "_0xa931bc",
        "rewardPerTokenInsideX128": "_0xdda7b4",
        "depostionEmissionsToken": "_0xe23d28",
        "rewardGrowthGlobalX128": "_0xddd465",
        "activateEmergencyMode": "_0xe2f8d4",
        "getRewardGrowthInside": "_0xd0186c",
        "notifyRewardAmount": "_0x404f78",
        "rewardGrowthInside": "_0xd36935",
        "encodeWithSelector": "_0xbca373",
        "epochTimeRemaining": "_0x9651e6",
        "rewardForDuration": "_0x32df17",
        "stopEmergencyMode": "_0x96996e",
        "rewardRateByEpoch": "_0xba7465",
        "totalRewardAmount": "_0xbd60aa",
        "epochEndTimestamp": "_0xf392b8",
        "safeTransferFrom": "_0x8e86e9",
        "setInternalBribe": "_0x931bc5",
        "onlyDistribution": "_0x203c98",
        "onERC721Received": "_0x4c4bc5",
        "liquidityToStake": "_0x047206",
        "_internal_bribe": "_0x7f07ab",
        "_getPoolAddress": "_0xbee468",
        "stakedLiquidity": "_0x619646",
        "contractBalance": "_0xb06ace",
        "_external_bribe": "_0xdc464a",
        "_updateRewards": "_0x04af4f",
        "pendingRewards": "_0xebe52b",
        "external_bribe": "_0x85e39c",
        "internal_bribe": "_0x4d46cf",
        "lastUpdateTime": "_0x7b7e67",
        "isNotEmergency": "_0xe7156e",
        "rewardReserve": "_0xfa9c48",
        "_periodFinish": "_0xb0aee8",
        "_safeTransfer": "_0x000a77",
        "_distribution": "_0x02207b",
        "gaugeBalances": "_0x653eef",
        "rewardGrowth": "_0xb19540",
        "positionPool": "_0xcf1d7c",
        "nonReentrant": "_0x98d996",
        "rewardAmount": "_0x359420",
        "periodFinish": "_0x2a3f0e",
        "_rewardToken": "_0x8d0405",
        "tickSpacing": "_0x96ab3c",
        "lastUpdated": "_0x9158d1",
        "collectFees": "_0xce0309",
        "poolAddress": "_0x387970",
        "currentRate": "_0xfcd942",
        "rewardToken": "_0x0c6f2f",
        "safeApprove": "_0xe0eec3",
        "epochStart": "_0xf0bec0",
        "syncReward": "_0xdd528f",
        "rewardRate": "_0xf7d23a",
        "amount0Max": "_0x3cd116",
        "_isForPair": "_0x390066",
        "_getReward": "_0xb99986",
        "_claimFees": "_0xf67d71",
        "redeemType": "_0xdcf75e",
        "amount1Max": "_0xdeb34b",
        "getReward": "_0x416464",
        "redeemFor": "_0xe42d76",
        "emergency": "_0x26616e",
        "tickUpper": "_0xee8b22",
        "tickLower": "_0x4ca32c",
        "isForPair": "_0x1e4b45",
        "claimable": "_0x034fd7",
        "timeDelta": "_0x3ebf9f",
        "onlyOwner": "_0x70acec",
        "recipient": "_0x4eabb3",
        "positions": "_0x234396",
        "balanceOf": "_0x835101",
        "gaugeFees": "_0x4b9c06",
        "claimFees": "_0x28d570",
        "epochNext": "_0xdae2d3",
        "liquidity": "_0x46e160",
        "rollover": "_0x6603cb",
        "operator": "_0x431c2f",
        "_factory": "_0xab4815",
        "withdraw": "_0xe89447",
        "contains": "_0x9c01cc",
        "claimed1": "_0x6666d7",
        "claimed0": "_0xf841e3",
        "_stakes": "_0x250c8a",
        "factory": "_0x3a6b03",
        "_token1": "_0x755ca7",
        "rewards": "_0x77d6b0",
        "_token0": "_0xd35c7d",
        "_earned": "_0x4d9677",
        "getPool": "_0x1964c8",
        "account": "_0xcb0266",
        "success": "_0x354499",
        "deposit": "_0x43dab1",
        "tokenId": "_0x4aa1d3",
        "collect": "_0x011315",
        "mulDiv": "_0x0d2442",
        "_rHYBR": "_0xac27a1",
        "token0": "_0x52c311",
        "amount": "_0xe73e03",
        "earned": "_0xcb603e",
        "remove": "_0xe01a73",
        "decode": "_0x50cfb0",
        "_fees1": "_0xc62c5a",
        "token1": "_0x7369b8",
        "_fees0": "_0x00e6ca",
        "clPool": "_0x52c5ec",
        "reward": "_0xe30b28",
        "gauge": "_0x46b2ac",
        "rHYBR": "_0xec62a3",
        "_pool": "_0x208cbe",
        "token": "_0x23cdce",
        "stake": "_0x81c6bd",
        "nfpm": "_0x0fca62",
        "_int": "_0xae7501",
        "user": "_0x4ed4b0",
        "add": "_0x81c8c7",
        "max": "_0x409af3",
        "_ve": "_0x5ba5a8",
        "to": "_0x506bf5"
      },
      "changes": [
        "Renamed 119 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_008",
      "transformed_id": "ss_l2_hex_sn_gs_008",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title GovernanceHYBR (gHYBR)\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\n */\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Lock period for new deposits (configurable between 12-24 hours)\n    uint256 public _0xa1b2a7 = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public _0x0cb772 = 1200; // 5days\n    uint256 public _0x6b330a = 300; // 1day\n\n    // Withdraw fee configuration (basis points, 10000 = 100%)\n    uint256 public _0xe0872e = 100; // 1% default fee\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\n    uint256 public constant BASIS = 10000;\n    address public Team; // Address to receive fees\n    uint256 public _0x01c101;\n    uint256 public _0x7f9bfd;\n    uint256 public _0xd288fa;\n    // User deposit tracking for transfer locks\n    struct UserLock {\n        uint256 _0xb09ae8;\n        uint256 _0xe96f59;\n    }\n\n    mapping(address => UserLock[]) public _0x34a1b0;\n    mapping(address => uint256) public _0x0da85a;\n\n    // Core contracts\n    address public immutable HYBR;\n    address public immutable _0x9d6bf5;\n    address public _0xf64f5e;\n    address public _0xd8bd2c;\n    address public _0x1d47be;\n    uint256 public _0xe5f467; // The veNFT owned by this contract\n\n    // Auto-voting strategy\n    address public _0xaf5e74; // Address that can manage voting strategy\n    uint256 public _0x597868; // Last epoch when we voted\n\n    // Reward tracking\n    uint256 public _0x778578;\n    uint256 public _0x9831fd;\n\n    // Swap module\n    ISwapper public _0x66fdb4;\n\n    // Errors\n    error NOT_AUTHORIZED();\n\n    // Events\n    event Deposit(address indexed _0x9bee0c, uint256 _0x229163, uint256 _0xc12547);\n    event Withdraw(address indexed _0x9bee0c, uint256 _0x7b39bc, uint256 _0x229163, uint256 _0x1815e2);\n    event Compound(uint256 _0xf91684, uint256 _0x837b13);\n    event PenaltyRewardReceived(uint256 _0xb09ae8);\n    event TransferLockPeriodUpdated(uint256 _0x1a2d32, uint256 _0x6e58d9);\n    event SwapperUpdated(address indexed _0xceb5f7, address indexed _0x40685e);\n    event VoterSet(address _0xf64f5e);\n    event EmergencyUnlock(address indexed _0x9bee0c);\n    event AutoVotingEnabled(bool _0x6467e5);\n    event OperatorUpdated(address indexed _0xd26c79, address indexed _0xf26cec);\n    event DefaultVotingStrategyUpdated(address[] _0xf28bf6, uint256[] _0xad51d8);\n    event AutoVoteExecuted(uint256 _0x387d9a, address[] _0xf28bf6, uint256[] _0xad51d8);\n\n    constructor(\n        address _0xe67883,\n        address _0x9313d7\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_0xe67883 != address(0), \"Invalid HYBR\");\n        require(_0x9313d7 != address(0), \"Invalid VE\");\n\n        HYBR = _0xe67883;\n        _0x9d6bf5 = _0x9313d7;\n        _0x778578 = block.timestamp;\n        _0x9831fd = block.timestamp;\n        _0xaf5e74 = msg.sender; // Initially set deployer as operator\n    }\n\n    function _0x5bee14(address _0x9f279d) external _0x13922f {\n        require(_0x9f279d != address(0), \"Invalid rewards distributor\");\n        _0xd8bd2c = _0x9f279d;\n    }\n\n    function _0xbb451b(address _0x71f1bb) external _0x13922f {\n        require(_0x71f1bb != address(0), \"Invalid gauge manager\");\n        _0x1d47be = _0x71f1bb;\n    }\n\n      /**\n     * @notice Modifier to check authorization (owner or operator)\n     */\n    modifier _0x02cff9() {\n        if (msg.sender != _0xaf5e74) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n    /**\n     * @notice Deposit HYBR and receive gHYBR shares\n     * @param amount Amount of HYBR to deposit\n     * @param recipient Recipient of gHYBR shares\n     */\n    function _0x7071de(uint256 _0xb09ae8, address _0xad58bc) external _0x9479ec {\n        require(_0xb09ae8 > 0, \"Zero amount\");\n        _0xad58bc = _0xad58bc == address(0) ? msg.sender : _0xad58bc;\n\n        // Transfer HYBR from user first\n        IERC20(HYBR)._0x342d48(msg.sender, address(this), _0xb09ae8);\n\n        // Initialize veNFT on first deposit\n        if (_0xe5f467 == 0) {\n            _0xe6fe06(_0xb09ae8);\n        } else {\n            // Add to existing veNFT\n            IERC20(HYBR)._0xe3994f(_0x9d6bf5, _0xb09ae8);\n            IVotingEscrow(_0x9d6bf5)._0x933d44(_0xe5f467, _0xb09ae8);\n\n            // Extend lock to maximum duration\n            _0x51fcde();\n        }\n\n        // Calculate shares to mint based on current totalAssets\n        uint256 _0x7b39bc = _0x988515(_0xb09ae8);\n\n        // Mint gHYBR shares\n        _0x45c8e3(_0xad58bc, _0x7b39bc);\n\n        // Add transfer lock for recipient\n        _0xd26650(_0xad58bc, _0x7b39bc);\n\n        emit Deposit(msg.sender, _0xb09ae8, _0x7b39bc);\n    }\n\n    /**\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\n     * @param shares Amount of gHYBR shares to burn\n     * @return userTokenId The ID of the new veNFT created for the user\n     */\n    function _0x09bf5e(uint256 _0x7b39bc) external _0x9479ec returns (uint256 _0x60576a) {\n        require(_0x7b39bc > 0, \"Zero shares\");\n        require(_0xfee2c4(msg.sender) >= _0x7b39bc, \"Insufficient balance\");\n        require(_0xe5f467 != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(_0x9d6bf5)._0xe0b107(_0xe5f467) == false, \"Cannot withdraw yet\");\n\n        uint256 _0x07412e = HybraTimeLibrary._0x07412e(block.timestamp);\n        uint256 _0x9bf67a = HybraTimeLibrary._0x9bf67a(block.timestamp);\n\n        require(block.timestamp >= _0x07412e + _0x0cb772 && block.timestamp < _0x9bf67a - _0x6b330a, \"Cannot withdraw yet\");\n\n        // Calculate proportional HYBR amount from veNFT\n        uint256 _0x229163 = _0x500461(_0x7b39bc);\n        require(_0x229163 > 0, \"No assets to withdraw\");\n\n        // Calculate fee amount (from the HYBR amount, not shares)\n        uint256 _0xe406a0 = 0;\n        if (_0xe0872e > 0) {\n            _0xe406a0 = (_0x229163 * _0xe0872e) / BASIS;\n        }\n\n        // User receives amount minus fee\n        uint256 _0x330746 = _0x229163 - _0xe406a0;\n        require(_0x330746 > 0, \"Amount too small after fee\");\n\n        // Get actual HYBR locked amount (not voting power)\n        uint256 _0x427672 = _0x3466e5();\n        require(_0x229163 <= _0x427672, \"Insufficient veNFT balance\");\n\n        uint256 _0x79fbe7 = _0x427672 - _0x330746 - _0xe406a0;\n        require(_0x79fbe7 >= 0, \"Cannot withdraw entire veNFT\");\n\n        // Burn gHYBR shares (full amount)\n        _0xe34c1e(msg.sender, _0x7b39bc);\n\n        // Use multiSplit to create two NFTs: one for user, one for contract\n        uint256[] memory _0xd9cd9e = new uint256[](3);\n        _0xd9cd9e[0] = _0x79fbe7; // Amount staying with gHYBR\n        _0xd9cd9e[1] = _0x330746;      // Amount going to user (after fee)\n        _0xd9cd9e[2] = _0xe406a0;      // Amount going to fee recipient\n\n        uint256[] memory _0x01a2e1 = IVotingEscrow(_0x9d6bf5)._0x9ed611(_0xe5f467, _0xd9cd9e);\n\n        // Update contract's veTokenId to the first new token\n        _0xe5f467 = _0x01a2e1[0];\n        _0x60576a = _0x01a2e1[1];\n        uint256 _0x5e0da3 = _0x01a2e1[2];\n        // Note: userTokenId is transferred to user, they can manage their own lock time\n        IVotingEscrow(_0x9d6bf5)._0x2821b9(address(this), msg.sender, _0x60576a);\n        IVotingEscrow(_0x9d6bf5)._0x2821b9(address(this), Team, _0x5e0da3);\n        emit Withdraw(msg.sender, _0x7b39bc, _0x330746, _0xe406a0);\n    }\n\n    /**\n     * @notice Internal function to initialize veNFT on first deposit\n     */\n    function _0xe6fe06(uint256 _0x2c640b) internal {\n        // Create max lock with the initial deposit amount\n        IERC20(HYBR)._0xe3994f(_0x9d6bf5, type(uint256)._0x40826b);\n        uint256 _0x864753 = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n        // Create lock with initial amount\n        _0xe5f467 = IVotingEscrow(_0x9d6bf5)._0x88e66a(_0x2c640b, _0x864753, address(this));\n\n    }\n\n    /**\n     * @notice Calculate shares to mint based on deposit amount\n     */\n    function _0x988515(uint256 _0xb09ae8) public view returns (uint256) {\n        uint256 _0x1a5867 = _0xe4686c();\n        uint256 _0x001a39 = _0x3466e5();\n        if (_0x1a5867 == 0 || _0x001a39 == 0) {\n            return _0xb09ae8;\n        }\n        return (_0xb09ae8 * _0x1a5867) / _0x001a39;\n    }\n\n    /**\n     * @notice Calculate HYBR value of shares\n     */\n    function _0x500461(uint256 _0x7b39bc) public view returns (uint256) {\n        uint256 _0x1a5867 = _0xe4686c();\n        if (_0x1a5867 == 0) {\n            return _0x7b39bc;\n        }\n        return (_0x7b39bc * _0x3466e5()) / _0x1a5867;\n    }\n\n    /**\n     * @notice Get total assets (HYBR) locked in veNFT\n     * @dev Returns actual HYBR amount, not voting power\n     */\n    function _0x3466e5() public view returns (uint256) {\n        if (_0xe5f467 == 0) {\n            return 0;\n        }\n        // Get actual locked HYBR amount, not voting power\n        IVotingEscrow.LockedBalance memory _0xbe56a6 = IVotingEscrow(_0x9d6bf5)._0xbe56a6(_0xe5f467);\n        return uint256(int256(_0xbe56a6._0xb09ae8));\n    }\n\n    /**\n     * @notice Add transfer lock for new deposits\n     */\n    function _0xd26650(address _0x9bee0c, uint256 _0xb09ae8) internal {\n        uint256 _0xe96f59 = block.timestamp + _0xa1b2a7;\n        _0x34a1b0[_0x9bee0c].push(UserLock({\n            _0xb09ae8: _0xb09ae8,\n            _0xe96f59: _0xe96f59\n        }));\n        _0x0da85a[_0x9bee0c] += _0xb09ae8;\n    }\n\n    /**\n     * @notice Preview available balance (total - currently locked)\n     * @param user The user address to check\n     * @return available The current available balance for transfer\n     */\n    function _0xc6c45a(address _0x9bee0c) external view returns (uint256 _0x791e92) {\n        uint256 _0x12b221 = _0xfee2c4(_0x9bee0c);\n        uint256 _0x5a9a43 = 0;\n\n        UserLock[] storage _0x3f4ccb = _0x34a1b0[_0x9bee0c];\n        for (uint256 i = 0; i < _0x3f4ccb.length; i++) {\n            if (_0x3f4ccb[i]._0xe96f59 > block.timestamp) {\n                _0x5a9a43 += _0x3f4ccb[i]._0xb09ae8;\n            }\n        }\n\n        return _0x12b221 > _0x5a9a43 ? _0x12b221 - _0x5a9a43 : 0;\n    }\n    /**\n     * @notice Clean expired locks and update locked balance\n     * @param user The user address to clean locks for\n     * @return freed The amount of tokens freed from expired locks\n     */\n    function _0x03f3f0(address _0x9bee0c) internal returns (uint256 _0x9b0478) {\n        UserLock[] storage _0x3f4ccb = _0x34a1b0[_0x9bee0c];\n        uint256 _0x12f470 = _0x3f4ccb.length;\n        if (_0x12f470 == 0) return 0;\n\n        uint256 _0x7824d5 = 0;\n        unchecked {\n            for (uint256 i = 0; i < _0x12f470; i++) {\n                UserLock memory L = _0x3f4ccb[i];\n                if (L._0xe96f59 <= block.timestamp) {\n                    _0x9b0478 += L._0xb09ae8;\n                } else {\n                    if (_0x7824d5 != i) _0x3f4ccb[_0x7824d5] = L;\n                    _0x7824d5++;\n                }\n            }\n            if (_0x9b0478 > 0) {\n                _0x0da85a[_0x9bee0c] -= _0x9b0478;\n            }\n            while (_0x3f4ccb.length > _0x7824d5) {\n                _0x3f4ccb.pop();\n            }\n        }\n    }\n\n    /**\n     * @notice Override transfer to implement lock mechanism\n     */\n    function _0xddd2b5(\n        address from,\n        address _0xd037c5,\n        uint256 _0xb09ae8\n    ) internal override {\n        super._0xddd2b5(from, _0xd037c5, _0xb09ae8);\n\n        if (from != address(0) && _0xd037c5 != address(0)) { // Not mint or burn\n            uint256 _0x12b221 = _0xfee2c4(from);\n\n            // Step 1: Check current available balance using cached lockedBalance\n            uint256 _0x7e51d1 = _0x12b221 > _0x0da85a[from] ? _0x12b221 - _0x0da85a[from] : 0;\n\n            // Step 2: If current available >= amount, pass directly\n            if (_0x7e51d1 >= _0xb09ae8) {\n                return;\n            }\n\n            // Step 3: Not enough, clean expired locks and recalculate\n            _0x03f3f0(from);\n            uint256 _0x8f8232 = _0x12b221 > _0x0da85a[from] ? _0x12b221 - _0x0da85a[from] : 0;\n\n            // Step 4: Check final available balance\n            require(_0x8f8232 >= _0xb09ae8, \"Tokens locked\");\n        }\n    }\n\n    /**\n     * @notice Claim all rewards from voting and rebase\n     */\n    function _0x366ea7() external _0x02cff9 {\n        require(_0xf64f5e != address(0), \"Voter not set\");\n        require(_0xd8bd2c != address(0), \"Distributor not set\");\n\n        // Claim rebase rewards from RewardsDistributor\n        uint256  _0xd10d31 = IRewardsDistributor(_0xd8bd2c)._0x887094(_0xe5f467);\n        _0x01c101 += _0xd10d31;\n        // Claim bribes from voted pools\n        address[] memory _0xf48b59 = IVoter(_0xf64f5e)._0x778e70(_0xe5f467);\n\n        for (uint256 i = 0; i < _0xf48b59.length; i++) {\n            if (_0xf48b59[i] != address(0)) {\n                address _0x2b95d2 = IGaugeManager(_0x1d47be)._0x31c653(_0xf48b59[i]);\n\n                if (_0x2b95d2 != address(0)) {\n                    // Prepare arrays for single bribe claim\n                    address[] memory _0xe0342b = new address[](1);\n                    address[][] memory _0x011a87 = new address[][](1);\n\n                    // Claim internal bribe (trading fees)\n                    address _0xf70fa7 = IGaugeManager(_0x1d47be)._0xccc9c1(_0x2b95d2);\n                    if (_0xf70fa7 != address(0)) {\n                        uint256 _0x464e8d = IBribe(_0xf70fa7)._0xe05df4();\n                        if (_0x464e8d > 0) {\n                            address[] memory _0x105e5e = new address[](_0x464e8d);\n                            for (uint256 j = 0; j < _0x464e8d; j++) {\n                                _0x105e5e[j] = IBribe(_0xf70fa7)._0x105e5e(j);\n                            }\n                            _0xe0342b[0] = _0xf70fa7;\n                            _0x011a87[0] = _0x105e5e;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x1d47be)._0x8ebe90(_0xe0342b, _0x011a87, _0xe5f467);\n                        }\n                    }\n\n                    // Claim external bribe\n                    address _0x5a62dd = IGaugeManager(_0x1d47be)._0xd3f41a(_0x2b95d2);\n                    if (_0x5a62dd != address(0)) {\n                        uint256 _0x464e8d = IBribe(_0x5a62dd)._0xe05df4();\n                        if (_0x464e8d > 0) {\n                            address[] memory _0x105e5e = new address[](_0x464e8d);\n                            for (uint256 j = 0; j < _0x464e8d; j++) {\n                                _0x105e5e[j] = IBribe(_0x5a62dd)._0x105e5e(j);\n                            }\n                            _0xe0342b[0] = _0x5a62dd;\n                            _0x011a87[0] = _0x105e5e;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x1d47be)._0x8ebe90(_0xe0342b, _0x011a87, _0xe5f467);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Execute swap through the configured swapper module\n     * @param _params Swap parameters for the swapper module\n     */\n    function _0x26c477(ISwapper.SwapParams calldata _0x222402) external _0x9479ec _0x02cff9 {\n        require(address(_0x66fdb4) != address(0), \"Swapper not set\");\n\n        // Get token balance before swap\n        uint256 _0x61fa61 = IERC20(_0x222402._0xbc9d79)._0xfee2c4(address(this));\n        require(_0x61fa61 >= _0x222402._0xef92ff, \"Insufficient token balance\");\n\n        // Approve swapper to spend tokens\n        IERC20(_0x222402._0xbc9d79)._0x01a4b4(address(_0x66fdb4), _0x222402._0xef92ff);\n\n        // Execute swap through swapper module\n        uint256 _0xfbca7b = _0x66fdb4._0x77430b(_0x222402);\n\n        // Reset approval for safety\n        IERC20(_0x222402._0xbc9d79)._0x01a4b4(address(_0x66fdb4), 0);\n\n        // HYBR is now in this contract, ready for compounding\n        _0xd288fa += _0xfbca7b;\n    }\n\n    /**\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\n     */\n    function _0x61b5e7() external _0x02cff9 {\n\n        // Get current HYBR balance\n        uint256 _0xcb1065 = IERC20(HYBR)._0xfee2c4(address(this));\n\n        if (_0xcb1065 > 0) {\n            // Lock all HYBR to existing veNFT\n            IERC20(HYBR)._0x01a4b4(_0x9d6bf5, _0xcb1065);\n            IVotingEscrow(_0x9d6bf5)._0x933d44(_0xe5f467, _0xcb1065);\n\n            // Extend lock to maximum duration\n            _0x51fcde();\n\n            _0x9831fd = block.timestamp;\n\n            emit Compound(_0xcb1065, _0x3466e5());\n        }\n    }\n\n    /**\n     * @notice Vote for gauges using the veNFT\n     * @param _poolVote Array of pools to vote for\n     * @param _weights Array of weights for each pool\n     */\n    function _0x936f29(address[] calldata _0xa97893, uint256[] calldata _0x3ab879) external {\n        require(msg.sender == _0x5ccb60() || msg.sender == _0xaf5e74, \"Not authorized\");\n        require(_0xf64f5e != address(0), \"Voter not set\");\n\n        IVoter(_0xf64f5e)._0x936f29(_0xe5f467, _0xa97893, _0x3ab879);\n        _0x597868 = HybraTimeLibrary._0x07412e(block.timestamp);\n\n    }\n\n    /**\n     * @notice Reset votes\n     */\n    function _0xbd7011() external {\n        require(msg.sender == _0x5ccb60() || msg.sender == _0xaf5e74, \"Not authorized\");\n        require(_0xf64f5e != address(0), \"Voter not set\");\n\n        IVoter(_0xf64f5e)._0xbd7011(_0xe5f467);\n    }\n\n    /**\n     * @notice Receive penalty rewards from rHYBR conversions\n     */\n    function _0x08d0fc(uint256 _0xb09ae8) external {\n\n        // Auto-compound penalty rewards to existing veNFT\n        if (_0xb09ae8 > 0) {\n            IERC20(HYBR)._0xe3994f(_0x9d6bf5, _0xb09ae8);\n\n            if(_0xe5f467 == 0){\n                _0xe6fe06(_0xb09ae8);\n            } else{\n                IVotingEscrow(_0x9d6bf5)._0x933d44(_0xe5f467, _0xb09ae8);\n\n                // Extend lock to maximum duration\n                _0x51fcde();\n            }\n        }\n        _0x7f9bfd += _0xb09ae8;\n        emit PenaltyRewardReceived(_0xb09ae8);\n    }\n\n    /**\n     * @notice Set the voter contract\n     */\n    function _0xf18e1d(address _0x70f942) external _0x13922f {\n        require(_0x70f942 != address(0), \"Invalid voter\");\n        _0xf64f5e = _0x70f942;\n        emit VoterSet(_0x70f942);\n    }\n\n    /**\n     * @notice Update transfer lock period\n     */\n    function _0x602bcd(uint256 _0x0755aa) external _0x13922f {\n        require(_0x0755aa >= MIN_LOCK_PERIOD && _0x0755aa <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 _0x1a2d32 = _0xa1b2a7;\n        _0xa1b2a7 = _0x0755aa;\n        emit TransferLockPeriodUpdated(_0x1a2d32, _0x0755aa);\n    }\n\n    /**\n     * @notice Set withdraw fee (in basis points)\n     * @param _fee Fee amount (10-30 basis points)\n     */\n    function _0x40b620(uint256 _0xeda715) external _0x13922f {\n        require(_0xeda715 >= MIN_WITHDRAW_FEE && _0xeda715 <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        _0xe0872e = _0xeda715;\n    }\n\n    function _0x58bcb9(uint256 _0xc4049e) external _0x13922f {\n        _0x0cb772 = _0xc4049e;\n    }\n\n    function _0x3fd515(uint256 _0xc4049e) external _0x13922f {\n        _0x6b330a = _0xc4049e;\n    }\n\n    /**\n     * @notice Set the swapper module\n     * @param _swapper Address of the swapper module\n     */\n    function _0xfa5fb5(address _0xbcb32f) external _0x13922f {\n        require(_0xbcb32f != address(0), \"Invalid swapper\");\n        address _0xceb5f7 = address(_0x66fdb4);\n        _0x66fdb4 = ISwapper(_0xbcb32f);\n        emit SwapperUpdated(_0xceb5f7, _0xbcb32f);\n    }\n\n    /**\n     * @notice Set the team address\n     */\n    function _0x732fe6(address _0xd29880) external _0x13922f {\n        require(_0xd29880 != address(0), \"Invalid team\");\n        Team = _0xd29880;\n    }\n\n    /**\n     * @notice Emergency unlock for a user (owner only)\n     */\n    function _0x889770(address _0x9bee0c) external _0x02cff9 {\n        delete _0x34a1b0[_0x9bee0c];\n        _0x0da85a[_0x9bee0c] = 0;\n        emit EmergencyUnlock(_0x9bee0c);\n    }\n\n    /**\n     * @notice Get user's locks info\n     */\n    function _0x22ab72(address _0x9bee0c) external view returns (UserLock[] memory) {\n        return _0x34a1b0[_0x9bee0c];\n    }\n\n    /**\n     * @notice Set operator address\n     */\n    function _0x8acfc5(address _0x771e7c) external _0x13922f {\n        require(_0x771e7c != address(0), \"Invalid operator\");\n        address _0xd26c79 = _0xaf5e74;\n        _0xaf5e74 = _0x771e7c;\n        emit OperatorUpdated(_0xd26c79, _0x771e7c);\n    }\n\n    /**\n     * @notice Get veNFT lock end time\n     */\n    function _0xde7b8f() external view returns (uint256) {\n        if (_0xe5f467 == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory _0xbe56a6 = IVotingEscrow(_0x9d6bf5)._0xbe56a6(_0xe5f467);\n        return uint256(_0xbe56a6._0xa8d7d2);\n    }\n\n    /**\n     * @notice Internal helper to safely extend lock to maximum duration\n     * @dev Calculates exact duration needed to reach max allowed unlock time\n     */\n    function _0x51fcde() internal {\n        if (_0xe5f467 == 0) return;\n\n        IVotingEscrow.LockedBalance memory _0xbe56a6 = IVotingEscrow(_0x9d6bf5)._0xbe56a6(_0xe5f467);\n        if (_0xbe56a6._0xe5c908 || _0xbe56a6._0xa8d7d2 <= block.timestamp) return;\n\n        uint256 _0x4f1453 = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n        // Only extend if difference is more than 2 hours\n        if (_0x4f1453 > _0xbe56a6._0xa8d7d2 + 2 hours) {\n            try IVotingEscrow(_0x9d6bf5)._0xfe681c(_0xe5f467, HybraTimeLibrary.MAX_LOCK_DURATION) {\n                // Extension successful\n            } catch {\n                // Extension failed, continue without error\n                // This can happen if already at max possible time or other constraints\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setHeadNotWithdrawTime": "_0x58bcb9",
        "tail_not_withdraw_time": "_0x6b330a",
        "head_not_withdraw_time": "_0x0cb772",
        "setTailNotWithdrawTime": "_0x3fd515",
        "setTransferLockPeriod": "_0x602bcd",
        "setRewardsDistributor": "_0x5bee14",
        "increase_unlock_time": "_0xfe681c",
        "receivePenaltyReward": "_0x08d0fc",
        "_beforeTokenTransfer": "_0xddd2b5",
        "_rewardsDistributor": "_0x9f279d",
        "rewardsDistributor": "_0xd8bd2c",
        "transferLockPeriod": "_0xa1b2a7",
        "rewardsListLength": "_0xe05df4",
        "safeTransferFrom": "_0x2821b9",
        "_extendLockToMax": "_0x51fcde",
        "_addTransferLock": "_0xd26650",
        "_initializeVeNFT": "_0xe6fe06",
        "lastCompoundTime": "_0x9831fd",
        "previewAvailable": "_0xc6c45a",
        "currentAvailable": "_0x7e51d1",
        "create_lock_for": "_0x88e66a",
        "calculateAssets": "_0x500461",
        "external_bribes": "_0xd3f41a",
        "calculateShares": "_0x988515",
        "setGaugeManager": "_0xbb451b",
        "internal_bribes": "_0xccc9c1",
        "emergencyUnlock": "_0x889770",
        "remainingAmount": "_0x79fbe7",
        "newTotalLocked": "_0x837b13",
        "finalAvailable": "_0x8f8232",
        "sharesReceived": "_0xc12547",
        "setWithdrawFee": "_0x40b620",
        "lastRebaseTime": "_0x778578",
        "getLockEndTime": "_0xde7b8f",
        "initialAmount": "_0x2c640b",
        "externalBribe": "_0x5a62dd",
        "_cleanExpired": "_0x03f3f0",
        "_gaugeManager": "_0x71f1bb",
        "lastVoteEpoch": "_0x597868",
        "_votingEscrow": "_0x9313d7",
        "currentLocked": "_0x5a9a43",
        "internalBribe": "_0xf70fa7",
        "lockedBalance": "_0x0da85a",
        "maxUnlockTime": "_0x4f1453",
        "hybrReceived": "_0xfbca7b",
        "tokenBalance": "_0x61fa61",
        "votingEscrow": "_0x9d6bf5",
        "_totalAssets": "_0x001a39",
        "nonReentrant": "_0x9479ec",
        "rebaseAmount": "_0xd10d31",
        "totalBalance": "_0x12b221",
        "getUserLocks": "_0x22ab72",
        "onlyOperator": "_0x02cff9",
        "_totalSupply": "_0x1a5867",
        "gaugeManager": "_0x1d47be",
        "transferFrom": "_0x342d48",
        "claimRewards": "_0x366ea7",
        "oldOperator": "_0xd26c79",
        "newTokenIds": "_0x01a2e1",
        "hybrBalance": "_0xcb1065",
        "votingYield": "_0xd288fa",
        "isPermanent": "_0xe5c908",
        "withdrawFee": "_0xe0872e",
        "executeSwap": "_0x26c477",
        "totalAssets": "_0x3466e5",
        "userTokenId": "_0x60576a",
        "deposit_for": "_0x933d44",
        "totalSupply": "_0xe4686c",
        "setOperator": "_0x8acfc5",
        "claimBribes": "_0x8ebe90",
        "newOperator": "_0xf26cec",
        "bribeTokens": "_0x105e5e",
        "safeApprove": "_0x01a4b4",
        "unlockTime": "_0xe96f59",
        "epochStart": "_0x07412e",
        "setSwapper": "_0xfa5fb5",
        "multiSplit": "_0x9ed611",
        "votedPools": "_0xf48b59",
        "feeTokenId": "_0x5e0da3",
        "swapToHYBR": "_0x77430b",
        "newSwapper": "_0x40685e",
        "hybrAmount": "_0x229163",
        "tokenCount": "_0x464e8d",
        "oldSwapper": "_0xceb5f7",
        "userAmount": "_0x330746",
        "_poolVote": "_0xa97893",
        "available": "_0x791e92",
        "veTokenId": "_0xe5f467",
        "veBalance": "_0x427672",
        "_operator": "_0x771e7c",
        "userLocks": "_0x34a1b0",
        "oldPeriod": "_0x1a2d32",
        "onlyOwner": "_0x13922f",
        "recipient": "_0xad58bc",
        "newPeriod": "_0x6e58d9",
        "balanceOf": "_0xfee2c4",
        "epochNext": "_0x9bf67a",
        "feeAmount": "_0xe406a0",
        "_swapper": "_0xbcb32f",
        "setVoter": "_0xf18e1d",
        "compound": "_0x61b5e7",
        "operator": "_0xaf5e74",
        "_weights": "_0x3ab879",
        "withdraw": "_0x09bf5e",
        "amountIn": "_0xef92ff",
        "poolVote": "_0x778e70",
        "lockTime": "_0x864753",
        "_params": "_0x222402",
        "tokenIn": "_0xbc9d79",
        "rewards": "_0xf91684",
        "setTeam": "_0x732fe6",
        "penalty": "_0x7f9bfd",
        "amounts": "_0xd9cd9e",
        "deposit": "_0x7071de",
        "_period": "_0x0755aa",
        "approve": "_0xe3994f",
        "swapper": "_0x66fdb4",
        "enabled": "_0x6467e5",
        "weights": "_0xad51d8",
        "rebase": "_0x01c101",
        "locked": "_0xbe56a6",
        "amount": "_0xb09ae8",
        "_voter": "_0x70f942",
        "bribes": "_0xe0342b",
        "shares": "_0x7b39bc",
        "tokens": "_0x011a87",
        "gauges": "_0x31c653",
        "gauge": "_0x2b95d2",
        "write": "_0x7824d5",
        "claim": "_0x887094",
        "_burn": "_0xe34c1e",
        "voter": "_0xf64f5e",
        "voted": "_0xe0b107",
        "_time": "_0xc4049e",
        "reset": "_0xbd7011",
        "freed": "_0x9b0478",
        "_team": "_0xd29880",
        "pools": "_0xf28bf6",
        "_HYBR": "_0xe67883",
        "owner": "_0x5ccb60",
        "_mint": "_0x45c8e3",
        "epoch": "_0x387d9a",
        "vote": "_0x936f29",
        "user": "_0x9bee0c",
        "_fee": "_0xeda715",
        "arr": "_0x3f4ccb",
        "fee": "_0x1815e2",
        "end": "_0xa8d7d2",
        "len": "_0x12f470",
        "max": "_0x40826b",
        "to": "_0xd037c5"
      },
      "changes": [
        "Renamed 151 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_009",
      "transformed_id": "ss_l2_hex_sn_gs_009",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IHybra.sol\";\nimport {IHybraVotes} from \"./interfaces/IHybraVotes.sol\";\nimport {IVeArtProxy} from \"./interfaces/IVeArtProxy.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport {VotingDelegationLib} from \"./libraries/VotingDelegationLib.sol\";\nimport {VotingBalanceLogic} from \"./libraries/VotingBalanceLogic.sol\";\n\n/// @title Voting Escrow\n/// @notice veNFT implementation that escrows ERC-20 tokens in the form of an ERC-721 NFT\n/// @notice Votes have a weight depending on time, so that users are committed to the future of (whatever they are voting for)\n/// @author Modified from Solidly (https://github.com/solidlyexchange/solidly/blob/master/contracts/ve.sol)\n/// @author Modified from Curve (https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n/// @author Modified from Nouns DAO (https://github.com/withtally/my-nft-dao-project/blob/main/contracts/ERC721Checkpointable.sol)\n/// @dev Vote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (2 years).\ncontract VotingEscrow is IERC721, IERC721Metadata, IHybraVotes {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed _0x283758,\n        uint _0x323a04,\n        uint value,\n        uint indexed _0x9295e3,\n        DepositType _0x5165e0,\n        uint _0xfcf605\n    );\n\n    event Merge(\n        address indexed _0xa489de,\n        uint256 indexed _0x7ea499,\n        uint256 indexed _0x280b05,\n        uint256 _0x51f6a7,\n        uint256 _0x1ffcde,\n        uint256 _0xbb9b94,\n        uint256 _0x563344,\n        uint256 _0x5c4114\n    );\n    event Split(\n        uint256 indexed _0x7ea499,\n        uint256 indexed _0x366e99,\n        uint256 indexed _0x679a17,\n        address _0xa489de,\n        uint256 _0x65aeec,\n        uint256 _0x0f765f,\n        uint256 _0x563344,\n        uint256 _0x5c4114\n    );\n\n    event MultiSplit(\n        uint256 indexed _0x7ea499,\n        uint256[] _0x365eb7,\n        address _0xa489de,\n        uint256[] _0x6f295c,\n        uint256 _0x563344,\n        uint256 _0x5c4114\n    );\n\n    event MetadataUpdate(uint256 _0x5c718d);\n    event BatchMetadataUpdate(uint256 _0xb4621f, uint256 _0x5b890e);\n\n    event Withdraw(address indexed _0x283758, uint _0x323a04, uint value, uint _0xfcf605);\n    event LockPermanent(address indexed _0xbeb817, uint256 indexed _0x5c718d, uint256 _0xacca5b, uint256 _0x5c4114);\n    event UnlockPermanent(address indexed _0xbeb817, uint256 indexed _0x5c718d, uint256 _0xacca5b, uint256 _0x5c4114);\n    event Supply(uint _0xe084dc, uint _0x09dce4);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable _0x07f5fa;\n    address public _0x875b36;\n    address public _0x133a65;\n    address public _0x90bbe6;\n    // address public burnTokenAddress=0x000000000000000000000000000000000000dEaD;\n\n    uint public PRECISISON = 10000;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal _0x502bcb;\n    mapping(uint => bool) internal _0x5e9e0a;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @dev Current count of token\n    uint internal _0x323a04;\n\n    uint internal WEEK;\n\n    uint internal MAXTIME;\n    int128 internal _0x0408eb;\n    IHybra public _0xcfd878;\n\n    // Instance of the library's storage struct\n    VotingDelegationLib.Data private _0x0efb6c;\n\n    VotingBalanceLogic.Data private _0x01a4b1;\n\n    /// @notice Contract constructor\n    /// @param token_addr `BLACK` token address\n    constructor(address _0x9d6920, address _0x82ddc0) {\n        _0x07f5fa = _0x9d6920;\n        _0x875b36 = msg.sender;\n        _0x133a65 = msg.sender;\n        _0x90bbe6 = _0x82ddc0;\n        WEEK = HybraTimeLibrary.WEEK;\n        MAXTIME = HybraTimeLibrary.MAX_LOCK_DURATION;\n        _0x0408eb = int128(int256(HybraTimeLibrary.MAX_LOCK_DURATION));\n\n        _0x01a4b1._0xa7b12c[0]._0xecd795 = block.number;\n        _0x01a4b1._0xa7b12c[0]._0xfcf605 = block.timestamp;\n\n        _0x502bcb[ERC165_INTERFACE_ID] = true;\n        _0x502bcb[ERC721_INTERFACE_ID] = true;\n        _0x502bcb[ERC721_METADATA_INTERFACE_ID] = true;\n        _0xcfd878 = IHybra(_0x07f5fa);\n\n        // mint-ish\n        emit Transfer(address(0), address(this), _0x323a04);\n        // burn-ish\n        emit Transfer(address(this), address(0), _0x323a04);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    uint8 internal constant _0x554801 = 1;\n    uint8 internal constant _0xc1c854 = 2;\n    uint8 internal _0x43e8e9 = 1;\n    modifier _0x101c7a() {\n        require(_0x43e8e9 == _0x554801);\n        _0x43e8e9 = _0xc1c854;\n        _;\n        _0x43e8e9 = _0x554801;\n    }\n\n    modifier _0xb9abb6(uint256 _0x5c718d) {\n        require(!_0x5e9e0a[_0x5c718d], \"PNFT\");\n        _;\n    }\n\n    modifier _0x888d5f(uint _0x7ea499) {\n        require(_0xa08f42[msg.sender] || _0xa08f42[address(0)], \"!SPLIT\");\n        require(_0x50cfd0[_0x7ea499] == 0 && !_0xb1ddd2[_0x7ea499], \"ATT\");\n        require(_0xe32dab(msg.sender, _0x7ea499), \"NAO\");\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string constant public _0x0c52df = \"veHYBR\";\n    string constant public _0x7b30a5 = \"veHYBR\";\n    string constant public _0xc17187 = \"1.0.0\";\n    uint8 constant public _0xea5320 = 18;\n\n    function _0x11868b(address _0xf12e7c) external {\n        require(msg.sender == _0x133a65);\n        _0x133a65 = _0xf12e7c;\n    }\n\n    function _0xa181a7(address _0x01f486) external {\n        require(msg.sender == _0x133a65);\n        _0x90bbe6 = _0x01f486;\n        emit BatchMetadataUpdate(0, type(uint256)._0x68b771);\n    }\n\n    /// @param _tokenId The token ID to modify\n    /// @param _isPartner Whether this should be a partner veNFT\n    function _0xe7f4dd(uint _0x5c718d, bool _0x81d8d1) external {\n        require(msg.sender == _0x133a65, \"NA\");\n        require(_0xcaa4db[_0x5c718d] != address(0), \"DNE\");\n        _0x5e9e0a[_0x5c718d] = _0x81d8d1;\n    }\n\n    /// @dev Returns current token URI metadata\n    /// @param _tokenId Token ID to fetch URI for.\n    function _0xf3f81b(uint _0x5c718d) external view returns (string memory) {\n        require(_0xcaa4db[_0x5c718d] != address(0), \"DNE\");\n        IVotingEscrow.LockedBalance memory _0x68ad16 = _0xec3fe4[_0x5c718d];\n\n        return IVeArtProxy(_0x90bbe6)._0x1f71cc(_0x5c718d,VotingBalanceLogic._0x7d100c(_0x5c718d, block.timestamp, _0x01a4b1),_0x68ad16._0x1219ef,uint(int256(_0x68ad16._0xacca5b)));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint => address) internal _0xcaa4db;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint) internal _0x5169b4;\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function _0xbd3ac2(uint _0x5c718d) public view returns (address) {\n        return _0xcaa4db[_0x5c718d];\n    }\n\n    function _0x767ebe(address _0x8c1f77) public view returns (uint) {\n\n        return _0x5169b4[_0x8c1f77];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned p to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _0x4ee9c3(address _0xbeb817) internal view returns (uint) {\n        return _0x5169b4[_0xbeb817];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _0xcfd0e1(address _0xbeb817) external view returns (uint) {\n        return _0x4ee9c3(_0xbeb817);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint => address) internal _0xdc1ea6;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal _0x507f95;\n\n    mapping(uint => uint) public _0x6427c5;\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function _0x235f60(uint _0x5c718d) external view returns (address) {\n        return _0xdc1ea6[_0x5c718d];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function _0xf83d44(address _0xbeb817, address _0x9d6144) external view returns (bool) {\n        return (_0x507f95[_0xbeb817])[_0x9d6144];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n    /// @param _approved Address to be approved for the given NFT ID.\n    /// @param _tokenId ID of the token to be approved.\n    function _0xe05975(address _0x89763a, uint _0x5c718d) public {\n        address _0x8c1f77 = _0xcaa4db[_0x5c718d];\n        // Throws if `_tokenId` is not a valid NFT\n        require(_0x8c1f77 != address(0), \"ZA\");\n        // Throws if `_approved` is the current owner\n        require(_0x89763a != _0x8c1f77, \"IA\");\n        // Check requirements\n        bool _0x2710f2 = (_0xcaa4db[_0x5c718d] == msg.sender);\n        bool _0xf90aa8 = (_0x507f95[_0x8c1f77])[msg.sender];\n        require(_0x2710f2 || _0xf90aa8, \"NAO\");\n        // Set the approval\n        _0xdc1ea6[_0x5c718d] = _0x89763a;\n        emit Approval(_0x8c1f77, _0x89763a, _0x5c718d);\n    }\n\n    /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n    /// @notice This works even if sender doesn't own any tokens at the time.\n    /// @param _operator Address to add to the set of authorized operators.\n    /// @param _approved True if the operators is approved, false to revoke approval.\n    function _0x393327(address _0x9d6144, bool _0x89763a) external {\n        // Throws if `_operator` is the `msg.sender`\n        assert(_0x9d6144 != msg.sender);\n        _0x507f95[msg.sender][_0x9d6144] = _0x89763a;\n        emit ApprovalForAll(msg.sender, _0x9d6144, _0x89763a);\n    }\n\n    /* TRANSFER FUNCTIONS */\n    /// @dev Clear an approval of a given address\n    ///      Throws if `_owner` is not the current owner.\n    function _0x66b41c(address _0xbeb817, uint _0x5c718d) internal {\n        // Throws if `_owner` is not the current owner\n        assert(_0xcaa4db[_0x5c718d] == _0xbeb817);\n        if (_0xdc1ea6[_0x5c718d] != address(0)) {\n            // Reset approvals\n            _0xdc1ea6[_0x5c718d] = address(0);\n        }\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\n    function _0xe32dab(address _0xd4d405, uint _0x5c718d) internal view returns (bool) {\n        address _0x8c1f77 = _0xcaa4db[_0x5c718d];\n        bool _0xad189c = _0x8c1f77 == _0xd4d405;\n        bool _0x3f1ab4 = _0xd4d405 == _0xdc1ea6[_0x5c718d];\n        bool _0x1f3441 = (_0x507f95[_0x8c1f77])[_0xd4d405];\n        return _0xad189c || _0x3f1ab4 || _0x1f3441;\n    }\n\n    function _0x00423e(address _0xd4d405, uint _0x5c718d) external view returns (bool) {\n        return _0xe32dab(_0xd4d405, _0x5c718d);\n    }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _0xdb66bf(\n        address _0x7ea499,\n        address _0x280b05,\n        uint _0x5c718d,\n        address _0xa489de\n    ) internal _0xb9abb6(_0x5c718d) {\n        require(_0x50cfd0[_0x5c718d] == 0 && !_0xb1ddd2[_0x5c718d], \"ATT\");\n        // Check requirements\n        require(_0xe32dab(_0xa489de, _0x5c718d), \"NAO\");\n\n        // Clear approval. Throws if `_from` is not the current owner\n        _0x66b41c(_0x7ea499, _0x5c718d);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _0x81edbb(_0x7ea499, _0x5c718d);\n        // auto re-delegate\n        VotingDelegationLib._0xc0d0cb(_0x0efb6c, _0x59a1c3(_0x7ea499), _0x59a1c3(_0x280b05), _0x5c718d, _0xbd3ac2);\n        // Add NFT\n        _0x30714f(_0x280b05, _0x5c718d);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        _0x6427c5[_0x5c718d] = block.number;\n\n        // Log the transfer\n        emit Transfer(_0x7ea499, _0x280b05, _0x5c718d);\n    }\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n    ///        they maybe be permanently lost.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function _0x4d6f20(\n        address _0x7ea499,\n        address _0x280b05,\n        uint _0x5c718d\n    ) external {\n        _0xdb66bf(_0x7ea499, _0x280b05, _0x5c718d, msg.sender);\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function _0xac2537(\n        address _0x7ea499,\n        address _0x280b05,\n        uint _0x5c718d\n    ) external {\n        _0xac2537(_0x7ea499, _0x280b05, _0x5c718d, \"\");\n    }\n\n    function _0x056e45(address _0xadc115) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint _0xe7b240;\n        assembly {\n            _0xe7b240 := extcodesize(_0xadc115)\n        }\n        return _0xe7b240 > 0;\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\n    function _0xac2537(\n        address _0x7ea499,\n        address _0x280b05,\n        uint _0x5c718d,\n        bytes memory _0x7f6141\n    ) public {\n        _0xdb66bf(_0x7ea499, _0x280b05, _0x5c718d, msg.sender);\n\n        if (_0x056e45(_0x280b05)) {\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\n            try IERC721Receiver(_0x280b05)._0xb1b697(msg.sender, _0x7ea499, _0x5c718d, _0x7f6141) returns (bytes4 _0xacbd79) {\n                if (_0xacbd79 != IERC721Receiver(_0x280b05)._0xb1b697.selector) {\n                    revert(\"E721_RJ\");\n                }\n            } catch (bytes memory _0x7fe275) {\n                if (_0x7fe275.length == 0) {\n                    revert('E721_NRCV');\n                } else {\n                    assembly {\n                        revert(add(32, _0x7fe275), mload(_0x7fe275))\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function _0x53c785(bytes4 _0x020529) external view returns (bool) {\n        return _0x502bcb[_0x020529];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint => uint)) internal _0xcf0e8a;\n\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint => uint) internal _0x510e05;\n\n    /// @dev  Get token by index\n    function _0x4ae926(address _0xbeb817, uint _0x835f8e) public view returns (uint) {\n        return _0xcf0e8a[_0xbeb817][_0x835f8e];\n    }\n\n    /// @dev Add a NFT to an index mapping to a given addressndashushun\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _0x28c49d(address _0x280b05, uint _0x5c718d) internal {\n        uint _0x2865e6 = _0x4ee9c3(_0x280b05);\n\n        _0xcf0e8a[_0x280b05][_0x2865e6] = _0x5c718d;\n        _0x510e05[_0x5c718d] = _0x2865e6;\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _0x30714f(address _0x280b05, uint _0x5c718d) internal {\n        // Throws if `_tokenId` is owned by someone\n        assert(_0xcaa4db[_0x5c718d] == address(0));\n        // Change the owner\n        _0xcaa4db[_0x5c718d] = _0x280b05;\n        // Update owner token index tracking\n        _0x28c49d(_0x280b05, _0x5c718d);\n        // Change count tracking\n        _0x5169b4[_0x280b05] += 1;\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _0xf6677c(address _0x280b05, uint _0x5c718d) internal returns (bool) {\n        // Throws if `_to` is zero address\n        assert(_0x280b05 != address(0));\n        // checkpoint for gov\n        VotingDelegationLib._0xc0d0cb(_0x0efb6c, address(0), _0x59a1c3(_0x280b05), _0x5c718d, _0xbd3ac2);\n        // Add NFT. Throws if `_tokenId` is owned by someone\n        _0x30714f(_0x280b05, _0x5c718d);\n        emit Transfer(address(0), _0x280b05, _0x5c718d);\n        return true;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _0x1957dd(address _0x7ea499, uint _0x5c718d) internal {\n        // Delete\n        uint _0x2865e6 = _0x4ee9c3(_0x7ea499) - 1;\n        uint _0xa3c213 = _0x510e05[_0x5c718d];\n\n        if (_0x2865e6 == _0xa3c213) {\n            // update ownerToNFTokenIdList\n            _0xcf0e8a[_0x7ea499][_0x2865e6] = 0;\n            // update tokenToOwnerIndex\n            _0x510e05[_0x5c718d] = 0;\n        } else {\n            uint _0xccfc79 = _0xcf0e8a[_0x7ea499][_0x2865e6];\n\n            // Add\n            // update ownerToNFTokenIdList\n            _0xcf0e8a[_0x7ea499][_0xa3c213] = _0xccfc79;\n            // update tokenToOwnerIndex\n            _0x510e05[_0xccfc79] = _0xa3c213;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            _0xcf0e8a[_0x7ea499][_0x2865e6] = 0;\n            // update tokenToOwnerIndex\n            _0x510e05[_0x5c718d] = 0;\n        }\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _0x81edbb(address _0x7ea499, uint _0x5c718d) internal {\n        // Throws if `_from` is not the current owner\n        assert(_0xcaa4db[_0x5c718d] == _0x7ea499);\n        // Change the owner\n        _0xcaa4db[_0x5c718d] = address(0);\n        // Update owner token index tracking\n        _0x1957dd(_0x7ea499, _0x5c718d);\n        // Change count tracking\n        _0x5169b4[_0x7ea499] -= 1;\n    }\n\n    function _0x340c31(uint _0x5c718d) internal {\n        require(_0xe32dab(msg.sender, _0x5c718d), \"NAO\");\n\n        address _0x8c1f77 = _0xbd3ac2(_0x5c718d);\n\n        // Clear approval\n        delete _0xdc1ea6[_0x5c718d];\n        // Remove token\n        //_removeTokenFrom(msg.sender, _tokenId);\n        _0x81edbb(_0x8c1f77, _0x5c718d);\n        // checkpoint for gov\n        VotingDelegationLib._0xc0d0cb(_0x0efb6c, _0x59a1c3(_0x8c1f77), address(0), _0x5c718d, _0xbd3ac2);\n\n        emit Transfer(_0x8c1f77, address(0), _0x5c718d);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint => IVotingEscrow.LockedBalance) public _0xec3fe4;\n    uint public _0x667fbc;\n    uint public _0x6f3259;\n    mapping(uint => int128) public _0x57b569; // time -> signed slope change\n    uint public _0x09dce4;\n    mapping(address => bool) public _0xa08f42;\n\n    uint internal constant MULTIPLIER = 1 ether;\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function _0x81dfe6(uint _0x5c718d) external view returns (int128) {\n        uint _0x18d6e4 = _0x01a4b1._0xc6020f[_0x5c718d];\n        return _0x01a4b1._0xd49cbc[_0x5c718d][_0x18d6e4]._0x628fb9;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function _0xd49cbc(uint _0x5c718d, uint _0xd6bf6b) external view returns (IVotingEscrow.Point memory) {\n        return _0x01a4b1._0xd49cbc[_0x5c718d][_0xd6bf6b];\n    }\n\n    function _0xa7b12c(uint _0x6f3259) external view returns (IVotingEscrow.Point memory) {\n        return _0x01a4b1._0xa7b12c[_0x6f3259];\n    }\n\n    function _0xc6020f(uint _0x323a04) external view returns (uint) {\n        return _0x01a4b1._0xc6020f[_0x323a04];\n    }\n\n    /// @notice Record global and per-user data to checkpoint\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\n    /// @param old_locked Pevious locked amount / end lock time for the user\n    /// @param new_locked New locked amount / end lock time for the user\n    function _0x2d3736(\n        uint _0x5c718d,\n        IVotingEscrow.LockedBalance memory _0x5f1a4c,\n        IVotingEscrow.LockedBalance memory _0x27e2af\n    ) internal {\n        IVotingEscrow.Point memory _0xb98fc9;\n        IVotingEscrow.Point memory _0x4bd237;\n        int128 _0xa3e01b = 0;\n        int128 _0xedb24f = 0;\n        uint _0x3c9b20 = _0x6f3259;\n\n        if (_0x5c718d != 0) {\n            _0x4bd237._0x2da774 = 0;\n\n            if(_0x27e2af._0x4076e8){\n                _0x4bd237._0x2da774 = uint(int256(_0x27e2af._0xacca5b));\n            }\n\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_0x5f1a4c._0x1219ef > block.timestamp && _0x5f1a4c._0xacca5b > 0) {\n                _0xb98fc9._0x628fb9 = _0x5f1a4c._0xacca5b / _0x0408eb;\n                _0xb98fc9._0x8b8dd4 = _0xb98fc9._0x628fb9 * int128(int256(_0x5f1a4c._0x1219ef - block.timestamp));\n            }\n            if (_0x27e2af._0x1219ef > block.timestamp && _0x27e2af._0xacca5b > 0) {\n                _0x4bd237._0x628fb9 = _0x27e2af._0xacca5b / _0x0408eb;\n                _0x4bd237._0x8b8dd4 = _0x4bd237._0x628fb9 * int128(int256(_0x27e2af._0x1219ef - block.timestamp));\n            }\n\n            // Read values of scheduled changes in the slope\n            // old_locked.end can be in the past and in the future\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            _0xa3e01b = _0x57b569[_0x5f1a4c._0x1219ef];\n            if (_0x27e2af._0x1219ef != 0) {\n                if (_0x27e2af._0x1219ef == _0x5f1a4c._0x1219ef) {\n                    _0xedb24f = _0xa3e01b;\n                } else {\n                    _0xedb24f = _0x57b569[_0x27e2af._0x1219ef];\n                }\n            }\n        }\n\n        IVotingEscrow.Point memory _0xf01da1 = IVotingEscrow.Point({_0x8b8dd4: 0, _0x628fb9: 0, _0xfcf605: block.timestamp, _0xecd795: block.number, _0x2da774: 0});\n        if (_0x3c9b20 > 0) {\n            _0xf01da1 = _0x01a4b1._0xa7b12c[_0x3c9b20];\n        }\n        uint _0xe78c0b = _0xf01da1._0xfcf605;\n        // initial_last_point is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        IVotingEscrow.Point memory _0x498f31 = _0xf01da1;\n        uint _0xce36c8 = 0; // dblock/dt\n        if (block.timestamp > _0xf01da1._0xfcf605) {\n            _0xce36c8 = (MULTIPLIER * (block.number - _0xf01da1._0xecd795)) / (block.timestamp - _0xf01da1._0xfcf605);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        {\n            uint _0xca395b = (_0xe78c0b / WEEK) * WEEK;\n            for (uint i = 0; i < 255; ++i) {\n                // Hopefully it won't happen that this won't get used in 5 years!\n                // If it does, users will be able to withdraw but vote weight will be broken\n                _0xca395b += WEEK;\n                int128 _0xebe73d = 0;\n                if (_0xca395b > block.timestamp) {\n                    _0xca395b = block.timestamp;\n                } else {\n                    _0xebe73d = _0x57b569[_0xca395b];\n                }\n                _0xf01da1._0x8b8dd4 -= _0xf01da1._0x628fb9 * int128(int256(_0xca395b - _0xe78c0b));\n                _0xf01da1._0x628fb9 += _0xebe73d;\n                if (_0xf01da1._0x8b8dd4 < 0) {\n                    // This can happen\n                    _0xf01da1._0x8b8dd4 = 0;\n                }\n                if (_0xf01da1._0x628fb9 < 0) {\n                    // This cannot happen - just in case\n                    _0xf01da1._0x628fb9 = 0;\n                }\n                _0xe78c0b = _0xca395b;\n                _0xf01da1._0xfcf605 = _0xca395b;\n                _0xf01da1._0xecd795 = _0x498f31._0xecd795 + (_0xce36c8 * (_0xca395b - _0x498f31._0xfcf605)) / MULTIPLIER;\n                _0x3c9b20 += 1;\n                if (_0xca395b == block.timestamp) {\n                    _0xf01da1._0xecd795 = block.number;\n                    break;\n                } else {\n                    _0x01a4b1._0xa7b12c[_0x3c9b20] = _0xf01da1;\n                }\n            }\n        }\n\n        _0x6f3259 = _0x3c9b20;\n        // Now point_history is filled until t=now\n\n        if (_0x5c718d != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            _0xf01da1._0x628fb9 += (_0x4bd237._0x628fb9 - _0xb98fc9._0x628fb9);\n            _0xf01da1._0x8b8dd4 += (_0x4bd237._0x8b8dd4 - _0xb98fc9._0x8b8dd4);\n            if (_0xf01da1._0x628fb9 < 0) {\n                _0xf01da1._0x628fb9 = 0;\n            }\n            if (_0xf01da1._0x8b8dd4 < 0) {\n                _0xf01da1._0x8b8dd4 = 0;\n            }\n            _0xf01da1._0x2da774 = _0x667fbc;\n        }\n\n        // Record the changed point into history\n        _0x01a4b1._0xa7b12c[_0x3c9b20] = _0xf01da1;\n\n        if (_0x5c718d != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (_0x5f1a4c._0x1219ef > block.timestamp) {\n                // old_dslope was <something> - u_old.slope, so we cancel that\n                _0xa3e01b += _0xb98fc9._0x628fb9;\n                if (_0x27e2af._0x1219ef == _0x5f1a4c._0x1219ef) {\n                    _0xa3e01b -= _0x4bd237._0x628fb9; // It was a new deposit, not extension\n                }\n                _0x57b569[_0x5f1a4c._0x1219ef] = _0xa3e01b;\n            }\n\n            if (_0x27e2af._0x1219ef > block.timestamp) {\n                if (_0x27e2af._0x1219ef > _0x5f1a4c._0x1219ef) {\n                    _0xedb24f -= _0x4bd237._0x628fb9; // old slope disappeared at this point\n                    _0x57b569[_0x27e2af._0x1219ef] = _0xedb24f;\n                }\n                // else: we recorded it already in old_dslope\n            }\n            // Now handle user history\n            uint _0xa581e8 = _0x01a4b1._0xc6020f[_0x5c718d] + 1;\n\n            _0x01a4b1._0xc6020f[_0x5c718d] = _0xa581e8;\n            _0x4bd237._0xfcf605 = block.timestamp;\n            _0x4bd237._0xecd795 = block.number;\n            _0x01a4b1._0xd49cbc[_0x5c718d][_0xa581e8] = _0x4bd237;\n        }\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    /// @param _tokenId NFT that holds lock\n    /// @param _value Amount to deposit\n    /// @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    /// @param locked_balance Previous locked amount / timestamp\n    /// @param deposit_type The type of deposit\n    function _0x18439d(\n        uint _0x5c718d,\n        uint _0x3a6577,\n        uint _0xea8d23,\n        IVotingEscrow.LockedBalance memory _0xb7b011,\n        DepositType _0x5165e0\n    ) internal {\n        IVotingEscrow.LockedBalance memory _0x68ad16 = _0xb7b011;\n        uint _0x593a7a = _0x09dce4;\n\n        _0x09dce4 = _0x593a7a + _0x3a6577;\n        IVotingEscrow.LockedBalance memory _0x5f1a4c;\n        (_0x5f1a4c._0xacca5b, _0x5f1a4c._0x1219ef, _0x5f1a4c._0x4076e8) = (_0x68ad16._0xacca5b, _0x68ad16._0x1219ef, _0x68ad16._0x4076e8);\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        _0x68ad16._0xacca5b += int128(int256(_0x3a6577));\n\n        if (_0xea8d23 != 0) {\n            _0x68ad16._0x1219ef = _0xea8d23;\n        }\n        _0xec3fe4[_0x5c718d] = _0x68ad16;\n\n        // Possibilities:\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // _locked.end > block.timestamp (always)\n        _0x2d3736(_0x5c718d, _0x5f1a4c, _0x68ad16);\n\n        address from = msg.sender;\n        if (_0x3a6577 != 0) {\n            assert(IERC20(_0x07f5fa)._0x4d6f20(from, address(this), _0x3a6577));\n        }\n\n        emit Deposit(from, _0x5c718d, _0x3a6577, _0x68ad16._0x1219ef, _0x5165e0, block.timestamp);\n        emit Supply(_0x593a7a, _0x593a7a + _0x3a6577);\n    }\n\n    /// @notice Record global data to checkpoint\n    function _0xd76fff() external {\n        _0x2d3736(0, IVotingEscrow.LockedBalance(0, 0, false), IVotingEscrow.LockedBalance(0, 0, false));\n    }\n\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _tokenId lock NFT\n    /// @param _value Amount to add to user's lock\n    function _0x79086f(uint _0x5c718d, uint _0x3a6577) external _0x101c7a {\n        IVotingEscrow.LockedBalance memory _0x68ad16 = _0xec3fe4[_0x5c718d];\n\n        require(_0x3a6577 > 0, \"ZV\"); // dev: need non-zero value\n        require(_0x68ad16._0xacca5b > 0, 'ZL');\n        require(_0x68ad16._0x1219ef > block.timestamp || _0x68ad16._0x4076e8, 'EXP');\n\n        if (_0x68ad16._0x4076e8) _0x667fbc += _0x3a6577;\n\n        _0x18439d(_0x5c718d, _0x3a6577, 0, _0x68ad16, DepositType.DEPOSIT_FOR_TYPE);\n\n        if(_0xb1ddd2[_0x5c718d]) {\n            IVoter(_0x875b36)._0x305b0a(_0x5c718d);\n        }\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _0xeabdbd(uint _0x3a6577, uint _0x0690ab, address _0x280b05) internal returns (uint) {\n        uint _0xea8d23 = (block.timestamp + _0x0690ab) / WEEK * WEEK; // Locktime is rounded down to weeks\n\n        require(_0x3a6577 > 0, \"ZV\"); // dev: need non-zero value\n        require(_0xea8d23 > block.timestamp && (_0xea8d23 <= block.timestamp + MAXTIME), 'IUT');\n\n        ++_0x323a04;\n        uint _0x5c718d = _0x323a04;\n        _0xf6677c(_0x280b05, _0x5c718d);\n\n        IVotingEscrow.LockedBalance memory _0x68ad16 = _0xec3fe4[_0x5c718d];\n\n        _0x18439d(_0x5c718d, _0x3a6577, _0xea8d23, _0x68ad16, DepositType.CREATE_LOCK_TYPE);\n        return _0x5c718d;\n    }\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    function _0x0e6736(uint _0x3a6577, uint _0x0690ab) external _0x101c7a returns (uint) {\n        return _0xeabdbd(_0x3a6577, _0x0690ab, msg.sender);\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _0xac9569(uint _0x3a6577, uint _0x0690ab, address _0x280b05) external _0x101c7a returns (uint) {\n        return _0xeabdbd(_0x3a6577, _0x0690ab, _0x280b05);\n    }\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function _0xa60d84(uint _0x5c718d, uint _0x3a6577) external _0x101c7a {\n        assert(_0xe32dab(msg.sender, _0x5c718d));\n\n        IVotingEscrow.LockedBalance memory _0x68ad16 = _0xec3fe4[_0x5c718d];\n\n        assert(_0x3a6577 > 0); // dev: need non-zero value\n        require(_0x68ad16._0xacca5b > 0, 'ZL');\n        require(_0x68ad16._0x1219ef > block.timestamp || _0x68ad16._0x4076e8, 'EXP');\n\n        if (_0x68ad16._0x4076e8) _0x667fbc += _0x3a6577;\n        _0x18439d(_0x5c718d, _0x3a6577, 0, _0x68ad16, DepositType.INCREASE_LOCK_AMOUNT);\n\n        // poke for the gained voting power\n        if(_0xb1ddd2[_0x5c718d]) {\n            IVoter(_0x875b36)._0x305b0a(_0x5c718d);\n        }\n        emit MetadataUpdate(_0x5c718d);\n    }\n\n    /// @notice Extend the unlock time for `_tokenId`\n    /// @param _lock_duration New number of seconds until tokens unlock\n    function _0xf46fee(uint _0x5c718d, uint _0x0690ab) external _0x101c7a {\n        assert(_0xe32dab(msg.sender, _0x5c718d));\n\n        IVotingEscrow.LockedBalance memory _0x68ad16 = _0xec3fe4[_0x5c718d];\n        require(!_0x68ad16._0x4076e8, \"!NORM\");\n        uint _0xea8d23 = (block.timestamp + _0x0690ab) / WEEK * WEEK; // Locktime is rounded down to weeks\n\n        require(_0x68ad16._0x1219ef > block.timestamp && _0x68ad16._0xacca5b > 0, 'EXP||ZV');\n        require(_0xea8d23 > _0x68ad16._0x1219ef && (_0xea8d23 <= block.timestamp + MAXTIME), 'IUT'); // IUT -> invalid unlock time\n\n        _0x18439d(_0x5c718d, 0, _0xea8d23, _0x68ad16, DepositType.INCREASE_UNLOCK_TIME);\n\n        // poke for the gained voting power\n        if(_0xb1ddd2[_0x5c718d]) {\n            IVoter(_0x875b36)._0x305b0a(_0x5c718d);\n        }\n        emit MetadataUpdate(_0x5c718d);\n    }\n\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function _0xc6362d(uint _0x5c718d) external _0x101c7a {\n        assert(_0xe32dab(msg.sender, _0x5c718d));\n        require(_0x50cfd0[_0x5c718d] == 0 && !_0xb1ddd2[_0x5c718d], \"ATT\");\n\n        IVotingEscrow.LockedBalance memory _0x68ad16 = _0xec3fe4[_0x5c718d];\n        require(!_0x68ad16._0x4076e8, \"!NORM\");\n        require(block.timestamp >= _0x68ad16._0x1219ef, \"!EXP\");\n        uint value = uint(int256(_0x68ad16._0xacca5b));\n\n        _0xec3fe4[_0x5c718d] = IVotingEscrow.LockedBalance(0, 0, false);\n        uint _0x593a7a = _0x09dce4;\n        _0x09dce4 = _0x593a7a - value;\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _0x2d3736(_0x5c718d, _0x68ad16, IVotingEscrow.LockedBalance(0, 0, false));\n\n        assert(IERC20(_0x07f5fa).transfer(msg.sender, value));\n\n        // Burn the NFT\n        _0x340c31(_0x5c718d);\n\n        emit Withdraw(msg.sender, _0x5c718d, value, block.timestamp);\n        emit Supply(_0x593a7a, _0x593a7a - value);\n    }\n\n    function _0x0fe5b7(uint _0x5c718d) external {\n        address sender = msg.sender;\n        require(_0xe32dab(sender, _0x5c718d), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory _0xa823b5 = _0xec3fe4[_0x5c718d];\n        require(!_0xa823b5._0x4076e8, \"!NORM\");\n        require(_0xa823b5._0x1219ef > block.timestamp, \"EXP\");\n        require(_0xa823b5._0xacca5b > 0, \"ZV\");\n\n        uint _0x26990e = uint(int256(_0xa823b5._0xacca5b));\n        _0x667fbc += _0x26990e;\n        _0xa823b5._0x1219ef = 0;\n        _0xa823b5._0x4076e8 = true;\n        _0x2d3736(_0x5c718d, _0xec3fe4[_0x5c718d], _0xa823b5);\n        _0xec3fe4[_0x5c718d] = _0xa823b5;\n        if(_0xb1ddd2[_0x5c718d]) {\n            IVoter(_0x875b36)._0x305b0a(_0x5c718d);\n        }\n        emit LockPermanent(sender, _0x5c718d, _0x26990e, block.timestamp);\n        emit MetadataUpdate(_0x5c718d);\n    }\n\n    function _0xda9eac(uint _0x5c718d) external {\n        address sender = msg.sender;\n        require(_0xe32dab(msg.sender, _0x5c718d), \"NAO\");\n\n        require(_0x50cfd0[_0x5c718d] == 0 && !_0xb1ddd2[_0x5c718d], \"ATT\");\n        IVotingEscrow.LockedBalance memory _0xa823b5 = _0xec3fe4[_0x5c718d];\n        require(_0xa823b5._0x4076e8, \"!NORM\");\n        uint _0x26990e = uint(int256(_0xa823b5._0xacca5b));\n        _0x667fbc -= _0x26990e;\n        _0xa823b5._0x1219ef = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n        _0xa823b5._0x4076e8 = false;\n\n        _0x2d3736(_0x5c718d, _0xec3fe4[_0x5c718d], _0xa823b5);\n        _0xec3fe4[_0x5c718d] = _0xa823b5;\n\n        emit UnlockPermanent(sender, _0x5c718d, _0x26990e, block.timestamp);\n        emit MetadataUpdate(_0x5c718d);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           GAUGE VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    function _0x7d100c(uint _0x5c718d) external view returns (uint) {\n        if (_0x6427c5[_0x5c718d] == block.number) return 0;\n        return VotingBalanceLogic._0x7d100c(_0x5c718d, block.timestamp, _0x01a4b1);\n    }\n\n    function _0x0a3bdf(uint _0x5c718d, uint _0xd4876a) external view returns (uint) {\n        return VotingBalanceLogic._0x7d100c(_0x5c718d, _0xd4876a, _0x01a4b1);\n    }\n\n    function _0x15ba17(uint _0x5c718d, uint _0x60f5d0) external view returns (uint) {\n        return VotingBalanceLogic._0x15ba17(_0x5c718d, _0x60f5d0, _0x01a4b1, _0x6f3259);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _block Block to calculate the total voting power at\n    /// @return Total voting power at `_block`\n    function _0xb7a179(uint _0x60f5d0) external view returns (uint) {\n        return VotingBalanceLogic._0xb7a179(_0x60f5d0, _0x6f3259, _0x01a4b1, _0x57b569);\n    }\n\n    function _0xf98c2f() external view returns (uint) {\n        return _0x36710d(block.timestamp);\n    }\n\n    /// @notice Calculate total voting power\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    /// @return Total voting power\n    function _0x36710d(uint t) public view returns (uint) {\n        return VotingBalanceLogic._0x36710d(t, _0x6f3259, _0x57b569,  _0x01a4b1);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint => uint) public _0x50cfd0;\n    mapping(uint => bool) public _0xb1ddd2;\n\n    function _0x71a491(address _0x32306e) external {\n        require(msg.sender == _0x133a65);\n        _0x875b36 = _0x32306e;\n    }\n\n    function _0x92e3bf(uint _0x5c718d) external {\n        require(msg.sender == _0x875b36);\n        _0xb1ddd2[_0x5c718d] = true;\n    }\n\n    function _0xa6a694(uint _0x5c718d) external {\n        require(msg.sender == _0x875b36, \"NA\");\n        _0xb1ddd2[_0x5c718d] = false;\n    }\n\n    function _0x2a25a2(uint _0x5c718d) external {\n        require(msg.sender == _0x875b36, \"NA\");\n        _0x50cfd0[_0x5c718d] = _0x50cfd0[_0x5c718d] + 1;\n    }\n\n    function _0xd5646e(uint _0x5c718d) external {\n        require(msg.sender == _0x875b36, \"NA\");\n        _0x50cfd0[_0x5c718d] = _0x50cfd0[_0x5c718d] - 1;\n    }\n\n    function _0x12cae5(uint _0x7ea499, uint _0x280b05) external _0x101c7a _0xb9abb6(_0x7ea499) {\n        require(_0x50cfd0[_0x7ea499] == 0 && !_0xb1ddd2[_0x7ea499], \"ATT\");\n        require(_0x7ea499 != _0x280b05, \"SAME\");\n        require(_0xe32dab(msg.sender, _0x7ea499) &&\n        _0xe32dab(msg.sender, _0x280b05), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory _0xbf7e15 = _0xec3fe4[_0x7ea499];\n        IVotingEscrow.LockedBalance memory _0xcd27b2 = _0xec3fe4[_0x280b05];\n        require(_0xcd27b2._0x1219ef > block.timestamp ||  _0xcd27b2._0x4076e8,\"EXP||PERM\");\n        require(_0xbf7e15._0x4076e8 ? _0xcd27b2._0x4076e8 : true, \"!MERGE\");\n\n        uint _0x222c25 = uint(int256(_0xbf7e15._0xacca5b));\n        uint _0x1219ef = _0xbf7e15._0x1219ef >= _0xcd27b2._0x1219ef ? _0xbf7e15._0x1219ef : _0xcd27b2._0x1219ef;\n\n        _0xec3fe4[_0x7ea499] = IVotingEscrow.LockedBalance(0, 0, false);\n        _0x2d3736(_0x7ea499, _0xbf7e15, IVotingEscrow.LockedBalance(0, 0, false));\n        _0x340c31(_0x7ea499);\n\n        IVotingEscrow.LockedBalance memory _0x43d0a8;\n        _0x43d0a8._0x4076e8 = _0xcd27b2._0x4076e8;\n\n        if (_0x43d0a8._0x4076e8){\n            _0x43d0a8._0xacca5b = _0xcd27b2._0xacca5b + _0xbf7e15._0xacca5b;\n            if (!_0xbf7e15._0x4076e8) {  // Only add if source wasn't already permanent\n                _0x667fbc += _0x222c25;\n            }\n        }else{\n            _0x43d0a8._0xacca5b = _0xcd27b2._0xacca5b + _0xbf7e15._0xacca5b;\n            _0x43d0a8._0x1219ef = _0x1219ef;\n        }\n\n        //_checkpointDelegatee(_delegates[_to], value0, true);\n        _0x2d3736(_0x280b05, _0xcd27b2, _0x43d0a8);\n        _0xec3fe4[_0x280b05] = _0x43d0a8;\n\n        if(_0xb1ddd2[_0x280b05]) {\n            IVoter(_0x875b36)._0x305b0a(_0x280b05);\n        }\n        emit Merge(\n            msg.sender,\n            _0x7ea499,\n            _0x280b05,\n            uint(int256(_0xbf7e15._0xacca5b)),\n            uint(int256(_0xcd27b2._0xacca5b)),\n            uint(int256(_0x43d0a8._0xacca5b)),\n            _0x43d0a8._0x1219ef,\n            block.timestamp\n        );\n        emit MetadataUpdate(_0x280b05);\n    }\n\n    // function split(\n    //     uint _from,\n    //     uint _amount\n    // ) external nonreentrant splitAllowed(_from) notPartnerNFT(_from) returns (uint256 _tokenId1, uint256 _tokenId2) {\n    //     address owner = idToOwner[_from];\n\n    //     IVotingEscrow.LockedBalance memory newLocked = locked[_from];\n    //     require(newLocked.end > block.timestamp || newLocked.isPermanent, \"EXP\");\n\n    //     int128 _splitAmount = int128(int256(_amount));\n\n    //     require(_splitAmount != 0, \"ZV\");\n    //     require(newLocked.amount > _splitAmount, \"BIGVAL\");\n\n    //     locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n    //     _checkpoint(_from, newLocked, IVotingEscrow.LockedBalance(0, 0, false));\n    //     _burn(_from);\n\n    //     newLocked.amount -= _splitAmount;\n    //     _tokenId1 = _createSplitNFT(owner, newLocked);\n\n    //     newLocked.amount = _splitAmount;\n    //     _tokenId2 = _createSplitNFT(owner, newLocked);\n\n    //     // emit Split(\n    //     //     _from,\n    //     //     _tokenId1,\n    //     //     _tokenId2,\n    //     //     msg.sender,\n    //     //     uint(int256(locked[_tokenId1].amount)),\n    //     //     uint(int256(_splitAmount)),\n    //     //     newLocked.end,\n    //     //     block.timestamp\n    //     // );\n    // }\n\n    /// @notice Split a veNFT into multiple new veNFTs with specified weight distribution\n    /// @param _from The token ID to split\n    /// @param amounts Array of weights for distributing the locked amount\n    /// @return newTokenIds Array of newly created token IDs\n    function _0x8fc511(\n        uint _0x7ea499,\n        uint[] memory _0xed1556\n    ) external _0x101c7a _0x888d5f(_0x7ea499) _0xb9abb6(_0x7ea499) returns (uint256[] memory _0x223c45) {\n        require(_0xed1556.length >= 2 && _0xed1556.length <= 10, \"MIN2MAX10\");\n\n        address _0x8c1f77 = _0xcaa4db[_0x7ea499];\n\n        IVotingEscrow.LockedBalance memory _0x142735 = _0xec3fe4[_0x7ea499];\n        require(_0x142735._0x1219ef > block.timestamp || _0x142735._0x4076e8, \"EXP\");\n        require(_0x142735._0xacca5b > 0, \"ZV\");\n\n        // Calculate total weight\n        uint _0x0b1b3b = 0;\n        for(uint i = 0; i < _0xed1556.length; i++) {\n            require(_0xed1556[i] > 0, \"ZW\"); // Zero weight not allowed\n            _0x0b1b3b += _0xed1556[i];\n        }\n\n        // Burn the original NFT\n        _0xec3fe4[_0x7ea499] = IVotingEscrow.LockedBalance(0, 0, false);\n        _0x2d3736(_0x7ea499, _0x142735, IVotingEscrow.LockedBalance(0, 0, false));\n        _0x340c31(_0x7ea499);\n\n        // Create new NFTs with proportional amounts\n        _0x223c45 = new uint256[](_0xed1556.length);\n        uint[] memory _0x9b3ae7 = new uint[](_0xed1556.length);\n\n        for(uint i = 0; i < _0xed1556.length; i++) {\n            IVotingEscrow.LockedBalance memory _0x68830b = IVotingEscrow.LockedBalance({\n                _0xacca5b: int128(int256(uint256(int256(_0x142735._0xacca5b)) * _0xed1556[i] / _0x0b1b3b)),\n                _0x1219ef: _0x142735._0x1219ef,\n                _0x4076e8: _0x142735._0x4076e8\n            });\n\n            _0x223c45[i] = _0xad03b6(_0x8c1f77, _0x68830b);\n            _0x9b3ae7[i] = uint256(int256(_0x68830b._0xacca5b));\n        }\n\n        emit MultiSplit(\n            _0x7ea499,\n            _0x223c45,\n            msg.sender,\n            _0x9b3ae7,\n            _0x142735._0x1219ef,\n            block.timestamp\n        );\n    }\n\n    function _0xad03b6(address _0x280b05, IVotingEscrow.LockedBalance memory _0xa823b5) private returns (uint256 _0x5c718d) {\n        _0x5c718d = ++_0x323a04;\n        _0xec3fe4[_0x5c718d] = _0xa823b5;\n        _0x2d3736(_0x5c718d, IVotingEscrow.LockedBalance(0, 0, false), _0xa823b5);\n        _0xf6677c(_0x280b05, _0x5c718d);\n    }\n\n    function _0x57dc34(address _0x53b119, bool _0x07e6be) external {\n        require(msg.sender == _0x133a65);\n        _0xa08f42[_0x53b119] = _0x07e6be;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            DAO VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = _0xcea475(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = _0xcea475(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) private _0x1b186a;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint) public _0xa7263c;\n\n    /**\n     * @notice Overrides the standard `Comp.sol` delegates mapping to return\n     * the delegator's own address if they haven't delegated.\n     * This avoids having to delegate to oneself.\n     */\n    function _0x59a1c3(address _0x8f4d5d) public view returns (address) {\n        address _0xd8ba14 = _0x1b186a[_0x8f4d5d];\n        return _0xd8ba14 == address(0) ? _0x8f4d5d : _0xd8ba14;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function _0xbac301(address _0xadc115) external view returns (uint) {\n        uint32 _0xb3762b = _0x0efb6c._0xebbab0[_0xadc115];\n        if (_0xb3762b == 0) {\n            return 0;\n        }\n        uint[] storage _0x468538 = _0x0efb6c._0x3f8424[_0xadc115][_0xb3762b - 1]._0x919f90;\n        uint _0xc928d9 = 0;\n        for (uint i = 0; i < _0x468538.length; i++) {\n            uint _0xbf6b0a = _0x468538[i];\n            _0xc928d9 = _0xc928d9 + VotingBalanceLogic._0x7d100c(_0xbf6b0a, block.timestamp, _0x01a4b1);\n        }\n        return _0xc928d9;\n    }\n\n    function _0xdb3486(address _0xadc115, uint timestamp)\n        public\n        view\n        returns (uint)\n    {\n        uint32 _0x989765 = VotingDelegationLib._0x31559c(_0x0efb6c, _0xadc115, timestamp);\n        // Sum votes\n        uint[] storage _0x468538 = _0x0efb6c._0x3f8424[_0xadc115][_0x989765]._0x919f90;\n        uint _0xc928d9 = 0;\n        for (uint i = 0; i < _0x468538.length; i++) {\n            uint _0xbf6b0a = _0x468538[i];\n            // Use the provided input timestamp here to get the right decay\n            _0xc928d9 = _0xc928d9 + VotingBalanceLogic._0x7d100c(_0xbf6b0a, timestamp,  _0x01a4b1);\n        }\n\n        return _0xc928d9;\n    }\n\n    function _0x7385b8(uint256 timestamp) external view returns (uint) {\n        return _0x36710d(timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             DAO VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function _0x53df84(address _0x8f4d5d, address _0x71cebe) internal {\n        /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\n        address _0x3b3d71 = _0x59a1c3(_0x8f4d5d);\n\n        _0x1b186a[_0x8f4d5d] = _0x71cebe;\n\n        emit DelegateChanged(_0x8f4d5d, _0x3b3d71, _0x71cebe);\n        VotingDelegationLib.TokenHelpers memory _0x37972f = VotingDelegationLib.TokenHelpers({\n            _0x117274: _0xbd3ac2,\n            _0x767ebe: _0x767ebe,\n            _0x4ae926:_0x4ae926\n        });\n        VotingDelegationLib._0x3399ea(_0x0efb6c, _0x8f4d5d, _0x3b3d71, _0x71cebe, _0x37972f);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function _0x836f06(address _0x71cebe) public {\n        if (_0x71cebe == address(0)) _0x71cebe = msg.sender;\n        return _0x53df84(msg.sender, _0x71cebe);\n    }\n\n    function _0x294603(\n        address _0x71cebe,\n        uint _0x064aa0,\n        uint _0x1919e9,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(_0x71cebe != msg.sender, \"NA\");\n        require(_0x71cebe != address(0), \"ZA\");\n\n        bytes32 _0x9c3ee2 = _0xcea475(\n            abi._0x42813e(\n                DOMAIN_TYPEHASH,\n                _0xcea475(bytes(_0x0c52df)),\n                _0xcea475(bytes(_0xc17187)),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 _0x4feb69 = _0xcea475(\n            abi._0x42813e(DELEGATION_TYPEHASH, _0x71cebe, _0x064aa0, _0x1919e9)\n        );\n        bytes32 _0x47b8c3 = _0xcea475(\n            abi._0x353d22(\"\\x19\\x01\", _0x9c3ee2, _0x4feb69)\n        );\n        address _0xf8ed8c = _0xd22cd9(_0x47b8c3, v, r, s);\n        require(\n            _0xf8ed8c != address(0),\n            \"ZA\"\n        );\n        require(\n            _0x064aa0 == _0xa7263c[_0xf8ed8c]++,\n            \"!NONCE\"\n        );\n        require(\n            block.timestamp <= _0x1919e9,\n            \"EXP\"\n        );\n        return _0x53df84(_0xf8ed8c, _0x71cebe);\n    }\n\n}",
      "rename_map": {
        "_removeTokenFromOwnerList": "_0x1957dd",
        "spenderIsApprovedForAll": "_0x1f3441",
        "senderIsApprovedForAll": "_0xf90aa8",
        "votingBalanceLogicData": "_0x01a4b1",
        "ownerToNFTokenCountFn": "_0x767ebe",
        "permanentLockBalance": "_0x667fbc",
        "increase_unlock_time": "_0xf46fee",
        "_addTokenToOwnerList": "_0x28c49d",
        "ownerToNFTokenIdList": "_0xcf0e8a",
        "get_last_user_slope": "_0x81dfe6",
        "supportedInterfaces": "_0x502bcb",
        "ownerToNFTokenCount": "_0x5169b4",
        "tokenOfOwnerByIndex": "_0x4ae926",
        "getPastTotalSupply": "_0x7385b8",
        "_isApprovedOrOwner": "_0xe32dab",
        "moveTokenDelegates": "_0xc0d0cb",
        "user_point_history": "_0xd49cbc",
        "initial_last_point": "_0x498f31",
        "setApprovalForAll": "_0x393327",
        "isApprovedOrOwner": "_0x00423e",
        "getPastVotesIndex": "_0x31559c",
        "_moveAllDelegates": "_0x3399ea",
        "supportsInterface": "_0x53c785",
        "tokenToOwnerIndex": "_0x510e05",
        "spenderIsApproved": "_0x3f1ab4",
        "isApprovedForAll": "_0xf83d44",
        "safeTransferFrom": "_0xac2537",
        "ownership_change": "_0x6427c5",
        "_removeTokenFrom": "_0x81edbb",
        "ownerToOperators": "_0x507f95",
        "onERC721Received": "_0xb1b697",
        "user_point_epoch": "_0xc6020f",
        "setPartnerVeNFT": "_0xe7f4dd",
        "create_lock_for": "_0xac9569",
        "_createSplitNFT": "_0xad03b6",
        "domainSeparator": "_0x9c3ee2",
        "currentDelegate": "_0x3b3d71",
        "increase_amount": "_0xa60d84",
        "unlockPermanent": "_0xda9eac",
        "last_checkpoint": "_0xe78c0b",
        "totalSupplyAtT": "_0x36710d",
        "balanceOfAtNFT": "_0x15ba17",
        "_clearApproval": "_0x66b41c",
        "numCheckpoints": "_0xebbab0",
        "_entered_state": "_0x43e8e9",
        "originalLocked": "_0x142735",
        "balanceOfNFTAt": "_0x0a3bdf",
        "locked_balance": "_0xb7b011",
        "_lock_duration": "_0x0690ab",
        "spenderIsOwner": "_0xad189c",
        "isPartnerVeNFT": "_0x5e9e0a",
        "_splitAmount1": "_0x65aeec",
        "slope_changes": "_0x57b569",
        "_splitAmount2": "_0x0f765f",
        "lockPermanent": "_0x0fe5b7",
        "current_count": "_0x2865e6",
        "delegateBySig": "_0x294603",
        "notPartnerNFT": "_0xb9abb6",
        "supply_before": "_0x593a7a",
        "senderIsOwner": "_0x2710f2",
        "idToApprovals": "_0xdc1ea6",
        "current_index": "_0xa3c213",
        "_transferFrom": "_0xdb66bf",
        "point_history": "_0xa7b12c",
        "actualAmounts": "_0x9b3ae7",
        "totalSupplyAt": "_0xb7a179",
        "_not_entered": "_0x554801",
        "_deposit_for": "_0x18439d",
        "nonreentrant": "_0x101c7a",
        "nCheckpoints": "_0xb3762b",
        "_interfaceID": "_0x020529",
        "tokenHelpers": "_0x37972f",
        "encodePacked": "_0x353d22",
        "balanceOfNFT": "_0x7d100c",
        "transferFrom": "_0x4d6f20",
        "_fromTokenId": "_0xb4621f",
        "_create_lock": "_0xeabdbd",
        "splitAllowed": "_0x888d5f",
        "deposit_type": "_0x5165e0",
        "_amountFinal": "_0xbb9b94",
        "getPastVotes": "_0xdb3486",
        "_newTokenIds": "_0x365eb7",
        "toggleSplit": "_0x57dc34",
        "newTokenIds": "_0x223c45",
        "_checkpoint": "_0x2d3736",
        "attachments": "_0x50cfd0",
        "block_slope": "_0xce36c8",
        "_addTokenTo": "_0x30714f",
        "isPermanent": "_0x4076e8",
        "_checkIndex": "_0x989765",
        "_tokenIndex": "_0x835f8e",
        "_amountFrom": "_0x51f6a7",
        "deposit_for": "_0x79086f",
        "setArtProxy": "_0xa181a7",
        "totalSupply": "_0xf98c2f",
        "lastTokenId": "_0xccfc79",
        "_isContract": "_0x056e45",
        "getApproved": "_0x235f60",
        "newLockedTo": "_0x43d0a8",
        "checkpoints": "_0x3f8424",
        "unlock_time": "_0xea8d23",
        "totalWeight": "_0x0b1b3b",
        "create_lock": "_0x0e6736",
        "user_epoch": "_0xa581e8",
        "prevSupply": "_0xe084dc",
        "checkpoint": "_0xd76fff",
        "multiSplit": "_0x8fc511",
        "last_point": "_0xf01da1",
        "_newLocked": "_0xa823b5",
        "old_dslope": "_0xa3e01b",
        "new_locked": "_0x27e2af",
        "structHash": "_0x4feb69",
        "new_dslope": "_0xedb24f",
        "_toTokenId": "_0x5b890e",
        "token_addr": "_0x9d6920",
        "_delegates": "_0x1b186a",
        "_isPartner": "_0x81d8d1",
        "old_locked": "_0x5f1a4c",
        "delegator": "_0x8f4d5d",
        "_tokenId2": "_0x679a17",
        "ecrecover": "_0xd22cd9",
        "ownerOfFn": "_0x117274",
        "delegatee": "_0x71cebe",
        "_operator": "_0x9d6144",
        "_delegate": "_0x53df84",
        "signatory": "_0xf8ed8c",
        "keccak256": "_0xcea475",
        "_amountTo": "_0x1ffcde",
        "newLocked": "_0x68830b",
        "_tokenId1": "_0x366e99",
        "art_proxy": "_0x82ddc0",
        "_locktime": "_0x563344",
        "_tokenURI": "_0x1f71cc",
        "_approved": "_0x89763a",
        "balanceOf": "_0xcfd0e1",
        "_tokenIds": "_0x468538",
        "idToOwner": "_0xcaa4db",
        "delegates": "_0x59a1c3",
        "permanent": "_0x2da774",
        "iMAXTIME": "_0x0408eb",
        "setVoter": "_0x71a491",
        "_spender": "_0xd4d405",
        "_locked0": "_0xbf7e15",
        "provider": "_0x283758",
        "delegate": "_0x836f06",
        "_tokenId": "_0x5c718d",
        "decimals": "_0xea5320",
        "canSplit": "_0xa08f42",
        "_account": "_0x53b119",
        "_amounts": "_0x6f295c",
        "_locked1": "_0xcd27b2",
        "withdraw": "_0xc6362d",
        "_balance": "_0x4ee9c3",
        "response": "_0xacbd79",
        "getVotes": "_0xbac301",
        "locktime": "_0x9295e3",
        "tokenIds": "_0x919f90",
        "_entered": "_0xc1c854",
        "artProxy": "_0x90bbe6",
        "tokenURI": "_0xf3f81b",
        "_sender": "_0xa489de",
        "_amount": "_0x26990e",
        "ownerOf": "_0xbd3ac2",
        "version": "_0xc17187",
        "current": "_0xd8ba14",
        "abstain": "_0xa6a694",
        "setTeam": "_0x11868b",
        "account": "_0xadc115",
        "_locked": "_0x68ad16",
        "amounts": "_0xed1556",
        "d_slope": "_0xebe73d",
        "approve": "_0xe05975",
        "tokenId": "_0x323a04",
        "digest": "_0x47b8c3",
        "value0": "_0x222c25",
        "expiry": "_0x1919e9",
        "voting": "_0x92e3bf",
        "_proxy": "_0x01f486",
        "cpData": "_0x0efb6c",
        "supply": "_0x09dce4",
        "locked": "_0xec3fe4",
        "reason": "_0x7fe275",
        "_value": "_0x3a6577",
        "amount": "_0xacca5b",
        "detach": "_0xd5646e",
        "_owner": "_0xbeb817",
        "_voter": "_0x32306e",
        "_epoch": "_0x3c9b20",
        "attach": "_0x2a25a2",
        "symbol": "_0x7b30a5",
        "_block": "_0x60f5d0",
        "uepoch": "_0x18d6e4",
        "encode": "_0x42813e",
        "nonces": "_0xa7263c",
        "_from": "_0x7ea499",
        "_burn": "_0x340c31",
        "slope": "_0x628fb9",
        "merge": "_0x12cae5",
        "voter": "_0x875b36",
        "voted": "_0xb1ddd2",
        "u_new": "_0x4bd237",
        "_hybr": "_0xcfd878",
        "u_old": "_0xb98fc9",
        "_team": "_0xf12e7c",
        "token": "_0x07f5fa",
        "nonce": "_0x064aa0",
        "owner": "_0x8c1f77",
        "_bool": "_0x07e6be",
        "_data": "_0x7f6141",
        "_mint": "_0xf6677c",
        "epoch": "_0x6f3259",
        "votes": "_0xc928d9",
        "size": "_0xe7b240",
        "team": "_0x133a65",
        "bias": "_0x8b8dd4",
        "_idx": "_0xd6bf6b",
        "name": "_0x0c52df",
        "poke": "_0x305b0a",
        "_ts": "_0x5c4114",
        "end": "_0x1219ef",
        "t_i": "_0xca395b",
        "_to": "_0x280b05",
        "tId": "_0xbf6b0a",
        "blk": "_0xecd795",
        "max": "_0x68b771",
        "ts": "_0xfcf605",
        "_t": "_0xd4876a"
      },
      "changes": [
        "Renamed 227 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_011",
      "transformed_id": "ss_l2_hex_sn_gs_011",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n/// @title MinVotingPowerCondition\n/// @author Aragon X - 2024\n/// @notice Checks if an account's voting power or token balance meets the threshold defined on the given plugin.\n/// @custom:security-contact sirt@aragon.org\ncontract MinVotingPowerCondition is PermissionCondition {\n    /// @notice The address of the `ILockToGovernBase` plugin used to fetch the settings from.\n    ILockToGovernBase public immutable _0x945ecc;\n\n    /// @notice The address of the LockManager used by the plugin.\n    ILockManager public immutable _0xcd8a90;\n\n    /// @notice The `IERC20` token interface used to check token balance.\n    IERC20 public immutable _0x6663cd;\n\n    /// @notice Initializes the contract with the `ILockToGovernBase` plugin address and caches the associated token.\n    /// @param _plugin The address of the `ILockToGovernBase` plugin.\n    constructor(ILockToGovernBase _0x03f068) {\n        _0x945ecc = _0x03f068;\n        _0x6663cd = _0x945ecc._0x6663cd();\n        _0xcd8a90 = _0x945ecc._0xcd8a90();\n    }\n\n    /// @inheritdoc IPermissionCondition\n    /// @dev The function checks both the voting power and token balance to ensure `_who` meets the minimum voting\n    ///      threshold defined in the `TokenVoting` plugin. Returns `false` if the minimum requirement is unmet.\n    function _0x5b4ab2(address _0xfc384b, address _0xfd407c, bytes32 _0x2a0406, bytes calldata _0xd82f5d)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (_0xfc384b, _0xd82f5d, _0x2a0406);\n\n        uint256 _0xaf381d = _0x6663cd._0xf57b3b(_0xfd407c) + _0xcd8a90._0x25c6ff(_0xfd407c);\n        uint256 _0x8be1c8 = _0x945ecc._0xb57308();\n\n        return _0xaf381d >= _0x8be1c8;\n    }\n}\n",
      "rename_map": {
        "_minProposerVotingPower": "_0x8be1c8",
        "minProposerVotingPower": "_0xb57308",
        "getLockedBalance": "_0x25c6ff",
        "_currentBalance": "_0xaf381d",
        "_permissionId": "_0x2a0406",
        "lockManager": "_0xcd8a90",
        "balanceOf": "_0xf57b3b",
        "isGranted": "_0x5b4ab2",
        "_plugin": "_0x03f068",
        "_where": "_0xfc384b",
        "plugin": "_0x945ecc",
        "token": "_0x6663cd",
        "_data": "_0xd82f5d",
        "_who": "_0xfd407c"
      },
      "changes": [
        "Renamed 14 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_012",
      "transformed_id": "ss_l2_hex_sn_gs_012",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this._0x4572d6.selector ^ this._0xf4c679.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = _0x1c6da2(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = _0x1c6da2(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 _0xe6e4e7, address _0xdfe4c0);\n\n    error VoteRemovalForbidden(uint256 _0xe6e4e7, address _0xdfe4c0);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function _0xe40c68(\n        IDAO _0x8a7ae6,\n        ILockManager _0x6ea991,\n        VotingSettings calldata _0x653765,\n        IPlugin.TargetConfig calldata _0x007f54,\n        bytes calldata _0xb81322\n    ) external _0x286642 _0xbaa4a0(1) {\n        __MajorityVotingBase_init(_0x8a7ae6, _0x653765, _0x007f54, _0xb81322);\n        __LockToGovernBase_init(_0x6ea991);\n\n        emit MembershipContractAnnounced({_0xa3816e: address(_0x6ea991._0xeadbdc())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function _0x23d1e3(bytes4 _0x90cda5)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _0x90cda5 == LOCK_TO_VOTE_INTERFACE_ID || _0x90cda5 == type(ILockToVote)._0x2f7123\n            || super._0x23d1e3(_0x90cda5);\n    }\n\n    /// @inheritdoc IProposal\n    function _0xd46563() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function _0xf4c679(\n        bytes calldata _0xb07420,\n        Action[] memory _0x0ff068,\n        uint64 _0x1cc74f,\n        uint64 _0xe059f5,\n        bytes memory _0x3777b9\n    ) external _0xf31187(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 _0xe6e4e7) {\n        uint256 _0xc412d9;\n\n        if (_0x3777b9.length != 0) {\n            (_0xc412d9) = abi._0x73fb1c(_0x3777b9, (uint256));\n        }\n\n        if (_0x5bc10c() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_0x1cc74f, _0xe059f5) = _0x2367c7(_0x1cc74f, _0xe059f5);\n\n        _0xe6e4e7 = _0x80596b(_0x1c6da2(abi._0xe1bc85(_0x0ff068, _0xb07420)));\n\n        if (_0x78e9c3(_0xe6e4e7)) {\n            revert ProposalAlreadyExists(_0xe6e4e7);\n        }\n\n        // Store proposal related information\n        Proposal storage _0x0d31a8 = _0x8a1b85[_0xe6e4e7];\n\n        _0x0d31a8._0x0ad853._0x2903cc = _0x2903cc();\n        _0x0d31a8._0x0ad853._0x8d7e70 = _0x8d7e70();\n        _0x0d31a8._0x0ad853._0x8b93d1 = _0x1cc74f;\n        _0x0d31a8._0x0ad853._0x5dfdde = _0xe059f5;\n        _0x0d31a8._0x0ad853._0x360cba = _0x360cba();\n        _0x0d31a8._0x0ad853._0x4c2fab = _0x4c2fab();\n\n        _0x0d31a8._0x7deb67 = _0x6d1314();\n\n        // Reduce costs\n        if (_0xc412d9 != 0) {\n            _0x0d31a8._0x03177a = _0xc412d9;\n        }\n\n        for (uint256 i; i < _0x0ff068.length;) {\n            _0x0d31a8._0xb21759.push(_0x0ff068[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(_0xe6e4e7, _0x89330c(), _0x1cc74f, _0xe059f5, _0xb07420, _0x0ff068, _0xc412d9);\n\n        _0xa7b7df._0x94f940(_0xe6e4e7);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function _0x28da9d(uint256 _0x4a66ee, address _0x681b59, VoteOption _0xf9aecb) public view returns (bool) {\n        if (!_0x78e9c3(_0x4a66ee)) {\n            revert NonexistentProposal(_0x4a66ee);\n        }\n\n        Proposal storage _0x0d31a8 = _0x8a1b85[_0x4a66ee];\n        return _0xf5f9ab(_0x0d31a8, _0x681b59, _0xf9aecb, _0xa7b7df._0x2f3219(_0x681b59));\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x142613(uint256 _0x4a66ee, address _0x681b59, VoteOption _0xf9aecb, uint256 _0x60ae69)\n        public\n        override\n        _0xf31187(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage _0x0d31a8 = _0x8a1b85[_0x4a66ee];\n\n        if (!_0xf5f9ab(_0x0d31a8, _0x681b59, _0xf9aecb, _0x60ae69)) {\n            revert VoteCastForbidden(_0x4a66ee, _0x681b59);\n        }\n\n        // Same vote\n        if (_0xf9aecb == _0x0d31a8._0x5fda16[_0x681b59]._0x43f43c) {\n            // Same value, nothing to do\n            if (_0x60ae69 == _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 _0x3694e7 = _0x60ae69 - _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a;\n            _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a = _0x60ae69;\n\n            if (_0x0d31a8._0x5fda16[_0x681b59]._0x43f43c == VoteOption.Yes) {\n                _0x0d31a8._0x9396c5._0x7701fe += _0x3694e7;\n            } else if (_0x0d31a8._0x5fda16[_0x681b59]._0x43f43c == VoteOption.No) {\n                _0x0d31a8._0x9396c5._0x021f67 += _0x3694e7;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                _0x0d31a8._0x9396c5._0x64e39c += _0x3694e7;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (_0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a > 0) {\n                // Undo that vote\n                if (_0x0d31a8._0x5fda16[_0x681b59]._0x43f43c == VoteOption.Yes) {\n                    _0x0d31a8._0x9396c5._0x7701fe -= _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a;\n                } else if (_0x0d31a8._0x5fda16[_0x681b59]._0x43f43c == VoteOption.No) {\n                    _0x0d31a8._0x9396c5._0x021f67 -= _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    _0x0d31a8._0x9396c5._0x64e39c -= _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a;\n                }\n            }\n\n            // Register the new vote\n            if (_0xf9aecb == VoteOption.Yes) {\n                _0x0d31a8._0x9396c5._0x7701fe += _0x60ae69;\n            } else if (_0xf9aecb == VoteOption.No) {\n                _0x0d31a8._0x9396c5._0x021f67 += _0x60ae69;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                _0x0d31a8._0x9396c5._0x64e39c += _0x60ae69;\n            }\n            _0x0d31a8._0x5fda16[_0x681b59]._0x43f43c = _0xf9aecb;\n            _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a = _0x60ae69;\n        }\n\n        emit VoteCast(_0x4a66ee, _0x681b59, _0xf9aecb, _0x60ae69);\n\n        if (_0x0d31a8._0x0ad853._0x2903cc == VotingMode.EarlyExecution) {\n            _0x892542(_0x4a66ee, _0x89330c());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x2aff0b(uint256 _0x4a66ee, address _0x681b59) external _0xf31187(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage _0x0d31a8 = _0x8a1b85[_0x4a66ee];\n        if (!_0x1a7f19(_0x0d31a8)) {\n            revert VoteRemovalForbidden(_0x4a66ee, _0x681b59);\n        } else if (_0x0d31a8._0x0ad853._0x2903cc != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_0x4a66ee, _0x681b59);\n        } else if (_0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (_0x0d31a8._0x5fda16[_0x681b59]._0x43f43c == VoteOption.Yes) {\n            _0x0d31a8._0x9396c5._0x7701fe -= _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a;\n        } else if (_0x0d31a8._0x5fda16[_0x681b59]._0x43f43c == VoteOption.No) {\n            _0x0d31a8._0x9396c5._0x021f67 -= _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (_0x0d31a8._0x5fda16[_0x681b59]._0x43f43c == VoteOption.Abstain) {\n            _0x0d31a8._0x9396c5._0x64e39c -= _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a;\n        }\n        _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a = 0;\n\n        emit VoteCleared(_0x4a66ee, _0x681b59);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x457039(uint256 _0x4a66ee) external view returns (bool) {\n        Proposal storage _0x0d31a8 = _0x8a1b85[_0x4a66ee];\n        return _0x1a7f19(_0x0d31a8);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0x4572d6() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase._0x4572d6();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0x5bc10c() public view override returns (uint256) {\n        return IERC20(_0xa7b7df._0xeadbdc())._0x6abf0a();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x45cd2e(uint256 _0x4a66ee, address _0x681b59) public view returns (uint256) {\n        return _0x8a1b85[_0x4a66ee]._0x5fda16[_0x681b59]._0xd2bc1a;\n    }\n\n    // Internal helpers\n\n    function _0xf5f9ab(Proposal storage _0x0d31a8, address _0x681b59, VoteOption _0xf9aecb, uint256 _0x60ae69)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _0x59e173 = _0x0d31a8._0x5fda16[_0x681b59]._0xd2bc1a;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_0x1a7f19(_0x0d31a8)) {\n            return false;\n        } else if (_0xf9aecb == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (_0x0d31a8._0x0ad853._0x2903cc != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_0x60ae69 <= _0x59e173) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                _0x0d31a8._0x5fda16[_0x681b59]._0x43f43c != VoteOption.None\n                    && _0xf9aecb != _0x0d31a8._0x5fda16[_0x681b59]._0x43f43c\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_0x60ae69 == 0 || _0x60ae69 < _0x59e173) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_0x60ae69 == _0x59e173 && _0xf9aecb == _0x0d31a8._0x5fda16[_0x681b59]._0x43f43c) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _0x892542(uint256 _0x4a66ee, address _0x18ae40) internal {\n        if (!_0xa5ed82(_0x4a66ee)) {\n            return;\n        } else if (!_0x864cf0()._0x27ef4f(address(this), _0x18ae40, EXECUTE_PROPOSAL_PERMISSION_ID, _0xf6d297())) {\n            return;\n        }\n\n        _0x5fa4ed(_0x4a66ee);\n    }\n\n    function _0x5fa4ed(uint256 _0x4a66ee) internal override {\n        super._0x5fa4ed(_0x4a66ee);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        _0xa7b7df._0x706898(_0x4a66ee);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "rename_map": {
        "onlyCallAtInitialization": "_0x286642",
        "customProposalParamsABI": "_0xd46563",
        "minProposerVotingPower": "_0x4572d6",
        "_attemptEarlyExecution": "_0x892542",
        "_validateProposalDates": "_0x2367c7",
        "minParticipationRatio": "_0x360cba",
        "supportThresholdRatio": "_0x8d7e70",
        "_currentVotingPower": "_0x59e173",
        "currentTokenSupply": "_0x5bc10c",
        "_createProposalId": "_0x80596b",
        "supportsInterface": "_0x23d1e3",
        "minApprovalRatio": "_0x4c2fab",
        "_allowFailureMap": "_0xc412d9",
        "getLockedBalance": "_0x2f3219",
        "definingContract": "_0xa3816e",
        "_proposalExists": "_0x78e9c3",
        "_isProposalOpen": "_0x1a7f19",
        "_pluginMetadata": "_0xb81322",
        "usedVotingPower": "_0x45cd2e",
        "proposalCreated": "_0x94f940",
        "allowFailureMap": "_0x03177a",
        "_votingSettings": "_0x653765",
        "getTargetConfig": "_0x6d1314",
        "_newVotingPower": "_0x60ae69",
        "isProposalOpen": "_0x457039",
        "createProposal": "_0xf4c679",
        "hasPermission": "_0x27ef4f",
        "proposalEnded": "_0x706898",
        "reinitializer": "_0xbaa4a0",
        "_targetConfig": "_0x007f54",
        "_lockManager": "_0x6ea991",
        "_interfaceId": "_0x90cda5",
        "targetConfig": "_0x7deb67",
        "_proposalId": "_0x4a66ee",
        "_voteOption": "_0xf9aecb",
        "_canExecute": "_0xa5ed82",
        "totalSupply": "_0x6abf0a",
        "votingPower": "_0xd2bc1a",
        "_voteCaller": "_0x18ae40",
        "interfaceId": "_0x2f7123",
        "lockManager": "_0xa7b7df",
        "votingMode": "_0x2903cc",
        "proposalId": "_0xe6e4e7",
        "parameters": "_0x0ad853",
        "voteOption": "_0x43f43c",
        "_msgSender": "_0x89330c",
        "_startDate": "_0x1cc74f",
        "initialize": "_0xe40c68",
        "_metadata": "_0xb07420",
        "proposals": "_0x8a1b85",
        "clearVote": "_0x2aff0b",
        "keccak256": "_0x1c6da2",
        "startDate": "_0x8b93d1",
        "proposal_": "_0x0d31a8",
        "_endDate": "_0xe059f5",
        "_canVote": "_0xf5f9ab",
        "_msgData": "_0xf6d297",
        "_execute": "_0x5fa4ed",
        "_actions": "_0x0ff068",
        "actions": "_0xb21759",
        "abstain": "_0x64e39c",
        "canVote": "_0x28da9d",
        "endDate": "_0x5dfdde",
        "_voter": "_0x681b59",
        "decode": "_0x73fb1c",
        "encode": "_0xe1bc85",
        "tally": "_0x9396c5",
        "voter": "_0xdfe4c0",
        "token": "_0xeadbdc",
        "_data": "_0x3777b9",
        "votes": "_0x5fda16",
        "auth": "_0xf31187",
        "diff": "_0x3694e7",
        "vote": "_0x142613",
        "_dao": "_0x8a7ae6",
        "yes": "_0x7701fe",
        "dao": "_0x864cf0",
        "no": "_0x021f67"
      },
      "changes": [
        "Renamed 78 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_013",
      "transformed_id": "ss_l2_hex_sn_gs_013",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title LockManagerERC20\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n    /// @notice The address of the token contract used to determine the voting power\n    IERC20 private immutable _0xa2e22f;\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    /// @param _token The address of the token contract that users can lock\n    constructor(LockManagerSettings memory _0xf29286, IERC20 _0x2fc466) LockManagerBase(_0xf29286) {\n        _0xa2e22f = _0x2fc466;\n    }\n\n    /// @inheritdoc ILockManager\n    /// @dev Not having `token` as a public variable because the return types would differ (address vs IERC20)\n    function _0xcfbbaf() public view virtual returns (address _0x2fc466) {\n        return address(_0xa2e22f);\n    }\n\n    // Overrides\n\n    /// @inheritdoc LockManagerBase\n    function _0xa29da1() internal view virtual override returns (uint256) {\n        return _0xa2e22f._0x845829(msg.sender, address(this));\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0x16d666(uint256 _0xcbc854) internal virtual override {\n        _0xa2e22f._0xc37b77(msg.sender, address(this), _0xcbc854);\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0xbb5dcf(address _0x0b54c9, uint256 _0xcbc854) internal virtual override {\n        _0xa2e22f.transfer(_0x0b54c9, _0xcbc854);\n    }\n}\n",
      "rename_map": {
        "_incomingTokenBalance": "_0xa29da1",
        "_doUnlockTransfer": "_0xbb5dcf",
        "_doLockTransfer": "_0x16d666",
        "transferFrom": "_0xc37b77",
        "erc20Token": "_0xa2e22f",
        "_recipient": "_0x0b54c9",
        "allowance": "_0x845829",
        "_settings": "_0xf29286",
        "_amount": "_0xcbc854",
        "_token": "_0x2fc466",
        "token": "_0xcfbbaf"
      },
      "changes": [
        "Renamed 11 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_014",
      "transformed_id": "ss_l2_hex_sn_gs_014",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title LockManagerERC20\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n    /// @notice The address of the token contract used to determine the voting power\n    IERC20 private immutable _0xf3bd18;\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    /// @param _token The address of the token contract that users can lock\n    constructor(LockManagerSettings memory _0xf9de9d, IERC20 _0xead07e) LockManagerBase(_0xf9de9d) {\n        _0xf3bd18 = _0xead07e;\n    }\n\n    /// @inheritdoc ILockManager\n    /// @dev Not having `token` as a public variable because the return types would differ (address vs IERC20)\n    function _0x423587() public view virtual returns (address _0xead07e) {\n        return address(_0xf3bd18);\n    }\n\n    // Overrides\n\n    /// @inheritdoc LockManagerBase\n    function _0xbe104a() internal view virtual override returns (uint256) {\n        return _0xf3bd18._0x54c7a2(msg.sender, address(this));\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0x450b0d(uint256 _0xcceb1c) internal virtual override {\n        _0xf3bd18._0x92ee86(msg.sender, address(this), _0xcceb1c);\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0x1c7a7a(address _0x98bcf5, uint256 _0xcceb1c) internal virtual override {\n        _0xf3bd18.transfer(_0x98bcf5, _0xcceb1c);\n    }\n}\n",
      "rename_map": {
        "_incomingTokenBalance": "_0xbe104a",
        "_doUnlockTransfer": "_0x1c7a7a",
        "_doLockTransfer": "_0x450b0d",
        "transferFrom": "_0x92ee86",
        "erc20Token": "_0xf3bd18",
        "_recipient": "_0x98bcf5",
        "allowance": "_0x54c7a2",
        "_settings": "_0xf9de9d",
        "_amount": "_0xcceb1c",
        "_token": "_0xead07e",
        "token": "_0x423587"
      },
      "changes": [
        "Renamed 11 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_015",
      "transformed_id": "ss_l2_hex_sn_gs_015",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title LockManagerBase\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @notice The current LockManager settings\n    LockManagerSettings public _0x53933c;\n\n    /// @notice The address of the lock to vote plugin to use\n    ILockToGovernBase public _0x9f7191;\n\n    /// @notice Keeps track of the amount of tokens locked by address\n    mapping(address => uint256) private _0x9681a2;\n\n    /// @notice Keeps track of the known active proposal ID's\n    /// @dev NOTE: Executed proposals will be actively reported, but defeated proposals will need to be garbage collected over time.\n    EnumerableSet.UintSet internal _0x77dc23;\n\n    /// @notice Emitted when a token holder locks funds into the manager contract\n    event BalanceLocked(address _0x361f3e, uint256 _0x9f1737);\n\n    /// @notice Emitted when a token holder unlocks funds from the manager contract\n    event BalanceUnlocked(address _0x361f3e, uint256 _0x9f1737);\n\n    /// @notice Emitted when the plugin reports a proposal as ended\n    /// @param proposalId The ID the proposal where votes can no longer be submitted or cleared\n    event ProposalEnded(uint256 _0x9f816e);\n\n    /// @notice Thrown when the address calling proposalEnded() is not the plugin's\n    error InvalidPluginAddress();\n\n    /// @notice Raised when the caller holds no tokens or didn't lock any tokens\n    error NoBalance();\n\n    /// @notice Raised when attempting to unlock while active votes are cast in strict mode\n    error LocksStillActive();\n\n    /// @notice Thrown when trying to set an invalid contract as the plugin\n    error InvalidPlugin();\n\n    /// @notice Thrown when trying to set an invalid PluginMode value, or when trying to use an operation not supported by the current pluginMode\n    error InvalidPluginMode();\n\n    /// @notice Thrown when trying to define the address of the plugin after it already was\n    error SetPluginAddressForbidden();\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    constructor(LockManagerSettings memory _0x002c0d) {\n        _0x53933c._0x2ff868 = _0x002c0d._0x2ff868;\n    }\n\n    /// @notice Returns the known proposalID at the given index\n    function _0x428ce4(uint256 _0x507845) public view virtual returns (uint256) {\n        return _0x77dc23._0x7eac04(_0x507845);\n    }\n\n    /// @notice Returns the number of known proposalID's\n    function _0xae9152() public view virtual returns (uint256) {\n        return _0x77dc23.length();\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xbbe149() public virtual {\n        _0x528b3a(_0x81df3c());\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xbbe149(uint256 _0xff23f6) public virtual {\n        _0x528b3a(_0xff23f6);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x22d14e(uint256 _0x9c107f, IMajorityVoting.VoteOption _0xcdaade) public virtual {\n        if (_0x53933c._0x2ff868 != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _0x528b3a(_0x81df3c());\n        _0x8a9ab2(_0x9c107f, _0xcdaade);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x22d14e(uint256 _0x9c107f, IMajorityVoting.VoteOption _0xcdaade, uint256 _0xff23f6) public virtual {\n        if (_0x53933c._0x2ff868 != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _0x528b3a(_0xff23f6);\n        _0x8a9ab2(_0x9c107f, _0xcdaade);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x9e4519(uint256 _0x9c107f, IMajorityVoting.VoteOption _0xcdaade) public virtual {\n        if (_0x53933c._0x2ff868 != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _0x8a9ab2(_0x9c107f, _0xcdaade);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x1d41f1(address _0x97bbcd) public view virtual returns (uint256) {\n        return _0x9681a2[_0x97bbcd];\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x0f5bd7(uint256 _0x9c107f, address _0xa42324, IMajorityVoting.VoteOption _0xcdaade)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(_0x9f7191))._0x0f5bd7(_0x9c107f, _0xa42324, _0xcdaade);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xedefdc() public virtual {\n        uint256 _0x1f092c = _0x1d41f1(msg.sender);\n        if (_0x1f092c == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev The plugin may decide to revert if its voting mode doesn't allow for it\n        _0x1cbf60();\n\n        // All votes clear\n\n        _0x9681a2[msg.sender] = 0;\n\n        // Withdraw\n        _0x972076(msg.sender, _0x1f092c);\n        emit BalanceUnlocked(msg.sender, _0x1f092c);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x5ea150(uint256 _0x9c107f) public virtual {\n        if (msg.sender != address(_0x9f7191)) {\n            revert InvalidPluginAddress();\n        }\n\n        // @dev Not checking for duplicate proposalId's\n        // @dev Both plugins already enforce unicity\n\n        _0x77dc23._0xb9e7f1(_0x9c107f);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x02efd1(uint256 _0x9c107f) public virtual {\n        if (msg.sender != address(_0x9f7191)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(_0x9c107f);\n        _0x77dc23._0x8207f9(_0x9c107f);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x644fcd(ILockToGovernBase _0x6f0f7a) public virtual {\n        if (address(_0x9f7191) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(_0x6f0f7a))._0x53442a(type(ILockToGovernBase)._0x45ff44)) {\n            revert InvalidPlugin();\n        }\n        // Is it the right type of plugin?\n        else if (\n            _0x53933c._0x2ff868 == PluginMode.Voting\n                && !IERC165(address(_0x6f0f7a))._0x53442a(type(ILockToVote)._0x45ff44)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        _0x9f7191 = _0x6f0f7a;\n    }\n\n    // Internal\n\n    /// @notice Returns the amount of tokens that LockManager receives or can transfer from msg.sender\n    function _0x81df3c() internal view virtual returns (uint256);\n\n    /// @notice Takes the user's tokens and registers the received amount.\n    function _0x528b3a(uint256 _0xff23f6) internal virtual {\n        if (_0xff23f6 == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev Reverts if not enough balance is approved\n        _0x76e4bb(_0xff23f6);\n\n        _0x9681a2[msg.sender] += _0xff23f6;\n        emit BalanceLocked(msg.sender, _0xff23f6);\n    }\n\n    /// @notice Triggers the transfer needed in order to complete the token locking flow.\n    ///     Reverts if the requested amount cannot be locked.\n    function _0x76e4bb(uint256 _0xff23f6) internal virtual;\n\n    /// @notice Transfers the requested amount of tokens to the recipient\n    /// @param _recipient The address that will receive the locked tokens back\n    /// @param _amount The amount of tokens that the recipient will get\n    function _0x972076(address _0x5f4d90, uint256 _0xff23f6) internal virtual;\n\n    function _0x8a9ab2(uint256 _0x9c107f, IMajorityVoting.VoteOption _0xcdaade) internal virtual {\n        uint256 _0x3baab6 = _0x1d41f1(msg.sender);\n\n        /// @dev The voting power value is checked within plugin.vote()\n\n        ILockToVote(address(_0x9f7191))._0x9e4519(_0x9c107f, msg.sender, _0xcdaade, _0x3baab6);\n    }\n\n    function _0x1cbf60() internal virtual {\n        uint256 _0x1d3a4d = _0x77dc23.length();\n        for (uint256 _0xf9c22b; _0xf9c22b < _0x1d3a4d;) {\n            uint256 _0x9c107f = _0x77dc23._0x7eac04(_0xf9c22b);\n            if (!_0x9f7191._0x4c8c86(_0x9c107f)) {\n                _0x77dc23._0x8207f9(_0x9c107f);\n                _0x1d3a4d = _0x77dc23.length();\n\n                // Were we at the last element?\n                if (_0xf9c22b == _0x1d3a4d) {\n                    return;\n                }\n\n                // Recheck the same index (now, another proposalId)\n                continue;\n            }\n\n            if (_0x9f7191._0x27c5ca(_0x9c107f, msg.sender) > 0) {\n                ILockToVote(address(_0x9f7191))._0x5e246a(_0x9c107f, msg.sender);\n            }\n\n            unchecked {\n                _0xf9c22b++;\n            }\n        }\n    }\n}\n",
      "rename_map": {
        "_withdrawActiveVotingPower": "_0x1cbf60",
        "knownProposalIdsLength": "_0xae9152",
        "_incomingTokenBalance": "_0x81df3c",
        "_currentVotingPower": "_0x3baab6",
        "_refundableBalance": "_0x1f092c",
        "_doUnlockTransfer": "_0x972076",
        "supportsInterface": "_0x53442a",
        "_newPluginAddress": "_0x6f0f7a",
        "knownProposalIdAt": "_0x428ce4",
        "setPluginAddress": "_0x644fcd",
        "knownProposalIds": "_0x77dc23",
        "getLockedBalance": "_0x1d41f1",
        "usedVotingPower": "_0x27c5ca",
        "proposalCreated": "_0x5ea150",
        "_doLockTransfer": "_0x76e4bb",
        "lockedBalances": "_0x9681a2",
        "_proposalCount": "_0x1d3a4d",
        "isProposalOpen": "_0x4c8c86",
        "proposalEnded": "_0x02efd1",
        "_proposalId": "_0x9c107f",
        "lockAndVote": "_0x22d14e",
        "interfaceId": "_0x45ff44",
        "_voteOption": "_0xcdaade",
        "pluginMode": "_0x2ff868",
        "proposalId": "_0x9f816e",
        "_recipient": "_0x5f4d90",
        "clearVote": "_0x5e246a",
        "_settings": "_0x002c0d",
        "_account": "_0x97bbcd",
        "settings": "_0x53933c",
        "canVote": "_0x0f5bd7",
        "_amount": "_0xff23f6",
        "plugin": "_0x9f7191",
        "_voter": "_0xa42324",
        "remove": "_0x8207f9",
        "unlock": "_0xedefdc",
        "amount": "_0x9f1737",
        "_index": "_0x507845",
        "voter": "_0x361f3e",
        "_lock": "_0x528b3a",
        "_vote": "_0x8a9ab2",
        "lock": "_0xbbe149",
        "vote": "_0x9e4519",
        "add": "_0xb9e7f1",
        "at": "_0x7eac04",
        "_i": "_0xf9c22b"
      },
      "changes": [
        "Renamed 46 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_016",
      "transformed_id": "ss_l2_hex_sn_gs_016",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this._0x7766cb.selector ^ this._0x3a8093.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = _0x3e6437(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = _0x3e6437(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 _0x386491, address _0x14985d);\n\n    error VoteRemovalForbidden(uint256 _0x386491, address _0x14985d);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function _0x215c46(\n        IDAO _0x279827,\n        ILockManager _0x26285c,\n        VotingSettings calldata _0x6594c9,\n        IPlugin.TargetConfig calldata _0x085ab0,\n        bytes calldata _0x8da0b2\n    ) external _0x98a46d _0xbf6f90(1) {\n        __MajorityVotingBase_init(_0x279827, _0x6594c9, _0x085ab0, _0x8da0b2);\n        __LockToGovernBase_init(_0x26285c);\n\n        emit MembershipContractAnnounced({_0x447213: address(_0x26285c._0x9ad714())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function _0x7eabb6(bytes4 _0x745f55)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _0x745f55 == LOCK_TO_VOTE_INTERFACE_ID || _0x745f55 == type(ILockToVote)._0x808e3e\n            || super._0x7eabb6(_0x745f55);\n    }\n\n    /// @inheritdoc IProposal\n    function _0xd44974() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function _0x3a8093(\n        bytes calldata _0xd90be6,\n        Action[] memory _0x631cf0,\n        uint64 _0x573b1c,\n        uint64 _0x33fdc0,\n        bytes memory _0x8e1ebf\n    ) external _0x0fb871(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 _0x386491) {\n        uint256 _0x9985ef;\n\n        if (_0x8e1ebf.length != 0) {\n            (_0x9985ef) = abi._0x8af0fb(_0x8e1ebf, (uint256));\n        }\n\n        if (_0x7653b8() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_0x573b1c, _0x33fdc0) = _0x284c2c(_0x573b1c, _0x33fdc0);\n\n        _0x386491 = _0x30844a(_0x3e6437(abi._0xbd8730(_0x631cf0, _0xd90be6)));\n\n        if (_0x43b84b(_0x386491)) {\n            revert ProposalAlreadyExists(_0x386491);\n        }\n\n        // Store proposal related information\n        Proposal storage _0x7bffec = _0x0d21fb[_0x386491];\n\n        _0x7bffec._0xbe1a59._0x9dd648 = _0x9dd648();\n        _0x7bffec._0xbe1a59._0x21e483 = _0x21e483();\n        _0x7bffec._0xbe1a59._0xfc8d1d = _0x573b1c;\n        _0x7bffec._0xbe1a59._0xf7d0a9 = _0x33fdc0;\n        _0x7bffec._0xbe1a59._0x9fdf26 = _0x9fdf26();\n        _0x7bffec._0xbe1a59._0x932b7f = _0x932b7f();\n\n        _0x7bffec._0xcbf1f1 = _0xb86f8b();\n\n        // Reduce costs\n        if (_0x9985ef != 0) {\n            _0x7bffec._0xf2c673 = _0x9985ef;\n        }\n\n        for (uint256 i; i < _0x631cf0.length;) {\n            _0x7bffec._0x501b3d.push(_0x631cf0[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(_0x386491, _0xcf9696(), _0x573b1c, _0x33fdc0, _0xd90be6, _0x631cf0, _0x9985ef);\n\n        _0x5ffa1f._0x838b58(_0x386491);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function _0xdd56b9(uint256 _0xc89dc5, address _0xee5392, VoteOption _0x3ca184) public view returns (bool) {\n        if (!_0x43b84b(_0xc89dc5)) {\n            revert NonexistentProposal(_0xc89dc5);\n        }\n\n        Proposal storage _0x7bffec = _0x0d21fb[_0xc89dc5];\n        return _0x817a0f(_0x7bffec, _0xee5392, _0x3ca184, _0x5ffa1f._0x4cbe2c(_0xee5392));\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x1b039d(uint256 _0xc89dc5, address _0xee5392, VoteOption _0x3ca184, uint256 _0x611160)\n        public\n        override\n        _0x0fb871(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage _0x7bffec = _0x0d21fb[_0xc89dc5];\n\n        if (!_0x817a0f(_0x7bffec, _0xee5392, _0x3ca184, _0x611160)) {\n            revert VoteCastForbidden(_0xc89dc5, _0xee5392);\n        }\n\n        // Same vote\n        if (_0x3ca184 == _0x7bffec._0xe9bc78[_0xee5392]._0xab36c1) {\n            // Same value, nothing to do\n            if (_0x611160 == _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 _0x76ce0a = _0x611160 - _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f;\n            _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f = _0x611160;\n\n            if (_0x7bffec._0xe9bc78[_0xee5392]._0xab36c1 == VoteOption.Yes) {\n                _0x7bffec._0x5ceca0._0xc12d85 += _0x76ce0a;\n            } else if (_0x7bffec._0xe9bc78[_0xee5392]._0xab36c1 == VoteOption.No) {\n                _0x7bffec._0x5ceca0._0xdd5112 += _0x76ce0a;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                _0x7bffec._0x5ceca0._0x76e66c += _0x76ce0a;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (_0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f > 0) {\n                // Undo that vote\n                if (_0x7bffec._0xe9bc78[_0xee5392]._0xab36c1 == VoteOption.Yes) {\n                    _0x7bffec._0x5ceca0._0xc12d85 -= _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f;\n                } else if (_0x7bffec._0xe9bc78[_0xee5392]._0xab36c1 == VoteOption.No) {\n                    _0x7bffec._0x5ceca0._0xdd5112 -= _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    _0x7bffec._0x5ceca0._0x76e66c -= _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f;\n                }\n            }\n\n            // Register the new vote\n            if (_0x3ca184 == VoteOption.Yes) {\n                _0x7bffec._0x5ceca0._0xc12d85 += _0x611160;\n            } else if (_0x3ca184 == VoteOption.No) {\n                _0x7bffec._0x5ceca0._0xdd5112 += _0x611160;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                _0x7bffec._0x5ceca0._0x76e66c += _0x611160;\n            }\n            _0x7bffec._0xe9bc78[_0xee5392]._0xab36c1 = _0x3ca184;\n            _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f = _0x611160;\n        }\n\n        emit VoteCast(_0xc89dc5, _0xee5392, _0x3ca184, _0x611160);\n\n        if (_0x7bffec._0xbe1a59._0x9dd648 == VotingMode.EarlyExecution) {\n            _0xf2b13d(_0xc89dc5, _0xcf9696());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x36a2cf(uint256 _0xc89dc5, address _0xee5392) external _0x0fb871(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage _0x7bffec = _0x0d21fb[_0xc89dc5];\n        if (!_0x431f41(_0x7bffec)) {\n            revert VoteRemovalForbidden(_0xc89dc5, _0xee5392);\n        } else if (_0x7bffec._0xbe1a59._0x9dd648 != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_0xc89dc5, _0xee5392);\n        } else if (_0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (_0x7bffec._0xe9bc78[_0xee5392]._0xab36c1 == VoteOption.Yes) {\n            _0x7bffec._0x5ceca0._0xc12d85 -= _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f;\n        } else if (_0x7bffec._0xe9bc78[_0xee5392]._0xab36c1 == VoteOption.No) {\n            _0x7bffec._0x5ceca0._0xdd5112 -= _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (_0x7bffec._0xe9bc78[_0xee5392]._0xab36c1 == VoteOption.Abstain) {\n            _0x7bffec._0x5ceca0._0x76e66c -= _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f;\n        }\n        _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f = 0;\n\n        emit VoteCleared(_0xc89dc5, _0xee5392);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0xbeb454(uint256 _0xc89dc5) external view returns (bool) {\n        Proposal storage _0x7bffec = _0x0d21fb[_0xc89dc5];\n        return _0x431f41(_0x7bffec);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0x7766cb() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase._0x7766cb();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0x7653b8() public view override returns (uint256) {\n        return IERC20(_0x5ffa1f._0x9ad714())._0xc19f0e();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0xa699b9(uint256 _0xc89dc5, address _0xee5392) public view returns (uint256) {\n        return _0x0d21fb[_0xc89dc5]._0xe9bc78[_0xee5392]._0x1b7d2f;\n    }\n\n    // Internal helpers\n\n    function _0x817a0f(Proposal storage _0x7bffec, address _0xee5392, VoteOption _0x3ca184, uint256 _0x611160)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _0x3f7ccf = _0x7bffec._0xe9bc78[_0xee5392]._0x1b7d2f;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_0x431f41(_0x7bffec)) {\n            return false;\n        } else if (_0x3ca184 == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (_0x7bffec._0xbe1a59._0x9dd648 != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_0x611160 <= _0x3f7ccf) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                _0x7bffec._0xe9bc78[_0xee5392]._0xab36c1 != VoteOption.None\n                    && _0x3ca184 != _0x7bffec._0xe9bc78[_0xee5392]._0xab36c1\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_0x611160 == 0 || _0x611160 < _0x3f7ccf) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_0x611160 == _0x3f7ccf && _0x3ca184 == _0x7bffec._0xe9bc78[_0xee5392]._0xab36c1) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _0xf2b13d(uint256 _0xc89dc5, address _0x05012b) internal {\n        if (!_0x198ab9(_0xc89dc5)) {\n            return;\n        } else if (!_0x16bfe6()._0x5ac755(address(this), _0x05012b, EXECUTE_PROPOSAL_PERMISSION_ID, _0x4b5622())) {\n            return;\n        }\n\n        _0x9784a2(_0xc89dc5);\n    }\n\n    function _0x9784a2(uint256 _0xc89dc5) internal override {\n        super._0x9784a2(_0xc89dc5);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        _0x5ffa1f._0xec0beb(_0xc89dc5);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "rename_map": {
        "onlyCallAtInitialization": "_0x98a46d",
        "customProposalParamsABI": "_0xd44974",
        "minProposerVotingPower": "_0x7766cb",
        "_attemptEarlyExecution": "_0xf2b13d",
        "_validateProposalDates": "_0x284c2c",
        "minParticipationRatio": "_0x9fdf26",
        "supportThresholdRatio": "_0x21e483",
        "_currentVotingPower": "_0x3f7ccf",
        "currentTokenSupply": "_0x7653b8",
        "_createProposalId": "_0x30844a",
        "supportsInterface": "_0x7eabb6",
        "minApprovalRatio": "_0x932b7f",
        "_allowFailureMap": "_0x9985ef",
        "getLockedBalance": "_0x4cbe2c",
        "definingContract": "_0x447213",
        "_proposalExists": "_0x43b84b",
        "_isProposalOpen": "_0x431f41",
        "_pluginMetadata": "_0x8da0b2",
        "usedVotingPower": "_0xa699b9",
        "proposalCreated": "_0x838b58",
        "allowFailureMap": "_0xf2c673",
        "_votingSettings": "_0x6594c9",
        "getTargetConfig": "_0xb86f8b",
        "_newVotingPower": "_0x611160",
        "isProposalOpen": "_0xbeb454",
        "createProposal": "_0x3a8093",
        "hasPermission": "_0x5ac755",
        "proposalEnded": "_0xec0beb",
        "reinitializer": "_0xbf6f90",
        "_targetConfig": "_0x085ab0",
        "_lockManager": "_0x26285c",
        "_interfaceId": "_0x745f55",
        "targetConfig": "_0xcbf1f1",
        "_proposalId": "_0xc89dc5",
        "_voteOption": "_0x3ca184",
        "_canExecute": "_0x198ab9",
        "totalSupply": "_0xc19f0e",
        "votingPower": "_0x1b7d2f",
        "_voteCaller": "_0x05012b",
        "interfaceId": "_0x808e3e",
        "lockManager": "_0x5ffa1f",
        "votingMode": "_0x9dd648",
        "proposalId": "_0x386491",
        "parameters": "_0xbe1a59",
        "voteOption": "_0xab36c1",
        "_msgSender": "_0xcf9696",
        "_startDate": "_0x573b1c",
        "initialize": "_0x215c46",
        "_metadata": "_0xd90be6",
        "proposals": "_0x0d21fb",
        "clearVote": "_0x36a2cf",
        "keccak256": "_0x3e6437",
        "startDate": "_0xfc8d1d",
        "proposal_": "_0x7bffec",
        "_endDate": "_0x33fdc0",
        "_canVote": "_0x817a0f",
        "_msgData": "_0x4b5622",
        "_execute": "_0x9784a2",
        "_actions": "_0x631cf0",
        "actions": "_0x501b3d",
        "abstain": "_0x76e66c",
        "canVote": "_0xdd56b9",
        "endDate": "_0xf7d0a9",
        "_voter": "_0xee5392",
        "decode": "_0x8af0fb",
        "encode": "_0xbd8730",
        "tally": "_0x5ceca0",
        "voter": "_0x14985d",
        "token": "_0x9ad714",
        "_data": "_0x8e1ebf",
        "votes": "_0xe9bc78",
        "auth": "_0x0fb871",
        "diff": "_0x76ce0a",
        "vote": "_0x1b039d",
        "_dao": "_0x279827",
        "yes": "_0xc12d85",
        "dao": "_0x16bfe6",
        "no": "_0xdd5112"
      },
      "changes": [
        "Renamed 78 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_017",
      "transformed_id": "ss_l2_hex_sn_gs_017",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n/// @title MinVotingPowerCondition\n/// @author Aragon X - 2024\n/// @notice Checks if an account's voting power or token balance meets the threshold defined on the given plugin.\n/// @custom:security-contact sirt@aragon.org\ncontract MinVotingPowerCondition is PermissionCondition {\n    /// @notice The address of the `ILockToGovernBase` plugin used to fetch the settings from.\n    ILockToGovernBase public immutable _0x303e2c;\n\n    /// @notice The address of the LockManager used by the plugin.\n    ILockManager public immutable _0x9cc099;\n\n    /// @notice The `IERC20` token interface used to check token balance.\n    IERC20 public immutable _0xc3610e;\n\n    /// @notice Initializes the contract with the `ILockToGovernBase` plugin address and caches the associated token.\n    /// @param _plugin The address of the `ILockToGovernBase` plugin.\n    constructor(ILockToGovernBase _0xe1453c) {\n        _0x303e2c = _0xe1453c;\n        _0xc3610e = _0x303e2c._0xc3610e();\n        _0x9cc099 = _0x303e2c._0x9cc099();\n    }\n\n    /// @inheritdoc IPermissionCondition\n    /// @dev The function checks both the voting power and token balance to ensure `_who` meets the minimum voting\n    ///      threshold defined in the `TokenVoting` plugin. Returns `false` if the minimum requirement is unmet.\n    function _0x36c945(address _0xe8a1e8, address _0x52fa4d, bytes32 _0x3cb0e1, bytes calldata _0xa70ded)\n        public\n        view\n        override\n        returns (bool)\n    {\n        (_0xe8a1e8, _0xa70ded, _0x3cb0e1);\n\n        uint256 _0x9b87f7 = _0xc3610e._0xa3a64d(_0x52fa4d) + _0x9cc099._0x510d4b(_0x52fa4d);\n        uint256 _0x5517c8 = _0x303e2c._0x204f88();\n\n        return _0x9b87f7 >= _0x5517c8;\n    }\n}\n",
      "rename_map": {
        "_minProposerVotingPower": "_0x5517c8",
        "minProposerVotingPower": "_0x204f88",
        "getLockedBalance": "_0x510d4b",
        "_currentBalance": "_0x9b87f7",
        "_permissionId": "_0x3cb0e1",
        "lockManager": "_0x9cc099",
        "balanceOf": "_0xa3a64d",
        "isGranted": "_0x36c945",
        "_plugin": "_0xe1453c",
        "_where": "_0xe8a1e8",
        "plugin": "_0x303e2c",
        "token": "_0xc3610e",
        "_data": "_0xa70ded",
        "_who": "_0x52fa4d"
      },
      "changes": [
        "Renamed 14 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_018",
      "transformed_id": "ss_l2_hex_sn_gs_018",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this._0xf53b7d.selector ^ this._0xa182e7.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = _0x808527(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = _0x808527(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 _0xae0541, address _0xa989d8);\n\n    error VoteRemovalForbidden(uint256 _0xae0541, address _0xa989d8);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function _0x389472(\n        IDAO _0x02f672,\n        ILockManager _0x8aa5be,\n        VotingSettings calldata _0xc81683,\n        IPlugin.TargetConfig calldata _0x06a88e,\n        bytes calldata _0x4eb957\n    ) external _0x133844 _0x4fb40a(1) {\n        __MajorityVotingBase_init(_0x02f672, _0xc81683, _0x06a88e, _0x4eb957);\n        __LockToGovernBase_init(_0x8aa5be);\n\n        emit MembershipContractAnnounced({_0x7506ec: address(_0x8aa5be._0x2b5b74())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function _0xf5f41c(bytes4 _0x696b62)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        return _0x696b62 == LOCK_TO_VOTE_INTERFACE_ID || _0x696b62 == type(ILockToVote)._0x105700\n            || super._0xf5f41c(_0x696b62);\n    }\n\n    /// @inheritdoc IProposal\n    function _0x5d77bb() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function _0xa182e7(\n        bytes calldata _0x42a3b7,\n        Action[] memory _0x709132,\n        uint64 _0x944d4e,\n        uint64 _0x982c10,\n        bytes memory _0xd799cd\n    ) external _0xf9724f(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 _0xae0541) {\n        uint256 _0x941dc0;\n\n        if (_0xd799cd.length != 0) {\n            (_0x941dc0) = abi._0x19620f(_0xd799cd, (uint256));\n        }\n\n        if (_0xf3e2c8() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_0x944d4e, _0x982c10) = _0x485c14(_0x944d4e, _0x982c10);\n\n        _0xae0541 = _0x4d1341(_0x808527(abi._0xab7f57(_0x709132, _0x42a3b7)));\n\n        if (_0xc6c27a(_0xae0541)) {\n            revert ProposalAlreadyExists(_0xae0541);\n        }\n\n        // Store proposal related information\n        Proposal storage _0x29b1ef = _0x643b9b[_0xae0541];\n\n        _0x29b1ef._0x7e8ecd._0x447455 = _0x447455();\n        _0x29b1ef._0x7e8ecd._0x8f7706 = _0x8f7706();\n        _0x29b1ef._0x7e8ecd._0x9c3159 = _0x944d4e;\n        _0x29b1ef._0x7e8ecd._0x9f261b = _0x982c10;\n        _0x29b1ef._0x7e8ecd._0xefc84e = _0xefc84e();\n        _0x29b1ef._0x7e8ecd._0xd4144d = _0xd4144d();\n\n        _0x29b1ef._0xcb3bce = _0xf71583();\n\n        // Reduce costs\n        if (_0x941dc0 != 0) {\n            _0x29b1ef._0x003322 = _0x941dc0;\n        }\n\n        for (uint256 i; i < _0x709132.length;) {\n            _0x29b1ef._0x977990.push(_0x709132[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(_0xae0541, _0x765729(), _0x944d4e, _0x982c10, _0x42a3b7, _0x709132, _0x941dc0);\n\n        _0x06c74b._0xf6f649(_0xae0541);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function _0x8294fe(uint256 _0x0c1ca7, address _0xf80f6c, VoteOption _0x4cd36d) public view returns (bool) {\n        if (!_0xc6c27a(_0x0c1ca7)) {\n            revert NonexistentProposal(_0x0c1ca7);\n        }\n\n        Proposal storage _0x29b1ef = _0x643b9b[_0x0c1ca7];\n        return _0x6a53b0(_0x29b1ef, _0xf80f6c, _0x4cd36d, _0x06c74b._0x42ebcb(_0xf80f6c));\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x1e5bd5(uint256 _0x0c1ca7, address _0xf80f6c, VoteOption _0x4cd36d, uint256 _0x0ad4d2)\n        public\n        override\n        _0xf9724f(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage _0x29b1ef = _0x643b9b[_0x0c1ca7];\n\n        if (!_0x6a53b0(_0x29b1ef, _0xf80f6c, _0x4cd36d, _0x0ad4d2)) {\n            revert VoteCastForbidden(_0x0c1ca7, _0xf80f6c);\n        }\n\n        // Same vote\n        if (_0x4cd36d == _0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9) {\n            // Same value, nothing to do\n            if (_0x0ad4d2 == _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 _0x0da714 = _0x0ad4d2 - _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618;\n            _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618 = _0x0ad4d2;\n\n            if (_0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9 == VoteOption.Yes) {\n                _0x29b1ef._0xfd8b8a._0xcdc42d += _0x0da714;\n            } else if (_0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9 == VoteOption.No) {\n                _0x29b1ef._0xfd8b8a._0xc724ff += _0x0da714;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                _0x29b1ef._0xfd8b8a._0xcfedc8 += _0x0da714;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (_0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618 > 0) {\n                // Undo that vote\n                if (_0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9 == VoteOption.Yes) {\n                    _0x29b1ef._0xfd8b8a._0xcdc42d -= _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618;\n                } else if (_0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9 == VoteOption.No) {\n                    _0x29b1ef._0xfd8b8a._0xc724ff -= _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    _0x29b1ef._0xfd8b8a._0xcfedc8 -= _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618;\n                }\n            }\n\n            // Register the new vote\n            if (_0x4cd36d == VoteOption.Yes) {\n                _0x29b1ef._0xfd8b8a._0xcdc42d += _0x0ad4d2;\n            } else if (_0x4cd36d == VoteOption.No) {\n                _0x29b1ef._0xfd8b8a._0xc724ff += _0x0ad4d2;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                _0x29b1ef._0xfd8b8a._0xcfedc8 += _0x0ad4d2;\n            }\n            _0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9 = _0x4cd36d;\n            _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618 = _0x0ad4d2;\n        }\n\n        emit VoteCast(_0x0c1ca7, _0xf80f6c, _0x4cd36d, _0x0ad4d2);\n\n        if (_0x29b1ef._0x7e8ecd._0x447455 == VotingMode.EarlyExecution) {\n            _0x7e6f8a(_0x0c1ca7, _0x765729());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0xab38dc(uint256 _0x0c1ca7, address _0xf80f6c) external _0xf9724f(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage _0x29b1ef = _0x643b9b[_0x0c1ca7];\n        if (!_0x88143c(_0x29b1ef)) {\n            revert VoteRemovalForbidden(_0x0c1ca7, _0xf80f6c);\n        } else if (_0x29b1ef._0x7e8ecd._0x447455 != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_0x0c1ca7, _0xf80f6c);\n        } else if (_0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618 == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (_0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9 == VoteOption.Yes) {\n            _0x29b1ef._0xfd8b8a._0xcdc42d -= _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618;\n        } else if (_0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9 == VoteOption.No) {\n            _0x29b1ef._0xfd8b8a._0xc724ff -= _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (_0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9 == VoteOption.Abstain) {\n            _0x29b1ef._0xfd8b8a._0xcfedc8 -= _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618;\n        }\n        _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618 = 0;\n\n        emit VoteCleared(_0x0c1ca7, _0xf80f6c);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x7138fc(uint256 _0x0c1ca7) external view returns (bool) {\n        Proposal storage _0x29b1ef = _0x643b9b[_0x0c1ca7];\n        return _0x88143c(_0x29b1ef);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0xf53b7d() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase._0xf53b7d();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0xf3e2c8() public view override returns (uint256) {\n        return IERC20(_0x06c74b._0x2b5b74())._0xda9d43();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0xc34458(uint256 _0x0c1ca7, address _0xf80f6c) public view returns (uint256) {\n        return _0x643b9b[_0x0c1ca7]._0x0dbd1f[_0xf80f6c]._0xcb8618;\n    }\n\n    // Internal helpers\n\n    function _0x6a53b0(Proposal storage _0x29b1ef, address _0xf80f6c, VoteOption _0x4cd36d, uint256 _0x0ad4d2)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _0x4c3874 = _0x29b1ef._0x0dbd1f[_0xf80f6c]._0xcb8618;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_0x88143c(_0x29b1ef)) {\n            return false;\n        } else if (_0x4cd36d == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (_0x29b1ef._0x7e8ecd._0x447455 != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_0x0ad4d2 <= _0x4c3874) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                _0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9 != VoteOption.None\n                    && _0x4cd36d != _0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_0x0ad4d2 == 0 || _0x0ad4d2 < _0x4c3874) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_0x0ad4d2 == _0x4c3874 && _0x4cd36d == _0x29b1ef._0x0dbd1f[_0xf80f6c]._0x630de9) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _0x7e6f8a(uint256 _0x0c1ca7, address _0xc90b7c) internal {\n        if (!_0x63e496(_0x0c1ca7)) {\n            return;\n        } else if (!_0x59ac35()._0x489e9a(address(this), _0xc90b7c, EXECUTE_PROPOSAL_PERMISSION_ID, _0x36be4c())) {\n            return;\n        }\n\n        _0x01c833(_0x0c1ca7);\n    }\n\n    function _0x01c833(uint256 _0x0c1ca7) internal override {\n        super._0x01c833(_0x0c1ca7);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        _0x06c74b._0x7b659c(_0x0c1ca7);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "rename_map": {
        "onlyCallAtInitialization": "_0x133844",
        "customProposalParamsABI": "_0x5d77bb",
        "minProposerVotingPower": "_0xf53b7d",
        "_attemptEarlyExecution": "_0x7e6f8a",
        "_validateProposalDates": "_0x485c14",
        "minParticipationRatio": "_0xefc84e",
        "supportThresholdRatio": "_0x8f7706",
        "_currentVotingPower": "_0x4c3874",
        "currentTokenSupply": "_0xf3e2c8",
        "_createProposalId": "_0x4d1341",
        "supportsInterface": "_0xf5f41c",
        "minApprovalRatio": "_0xd4144d",
        "_allowFailureMap": "_0x941dc0",
        "getLockedBalance": "_0x42ebcb",
        "definingContract": "_0x7506ec",
        "_proposalExists": "_0xc6c27a",
        "_isProposalOpen": "_0x88143c",
        "_pluginMetadata": "_0x4eb957",
        "usedVotingPower": "_0xc34458",
        "proposalCreated": "_0xf6f649",
        "allowFailureMap": "_0x003322",
        "_votingSettings": "_0xc81683",
        "getTargetConfig": "_0xf71583",
        "_newVotingPower": "_0x0ad4d2",
        "isProposalOpen": "_0x7138fc",
        "createProposal": "_0xa182e7",
        "hasPermission": "_0x489e9a",
        "proposalEnded": "_0x7b659c",
        "reinitializer": "_0x4fb40a",
        "_targetConfig": "_0x06a88e",
        "_lockManager": "_0x8aa5be",
        "_interfaceId": "_0x696b62",
        "targetConfig": "_0xcb3bce",
        "_proposalId": "_0x0c1ca7",
        "_voteOption": "_0x4cd36d",
        "_canExecute": "_0x63e496",
        "totalSupply": "_0xda9d43",
        "votingPower": "_0xcb8618",
        "_voteCaller": "_0xc90b7c",
        "interfaceId": "_0x105700",
        "lockManager": "_0x06c74b",
        "votingMode": "_0x447455",
        "proposalId": "_0xae0541",
        "parameters": "_0x7e8ecd",
        "voteOption": "_0x630de9",
        "_msgSender": "_0x765729",
        "_startDate": "_0x944d4e",
        "initialize": "_0x389472",
        "_metadata": "_0x42a3b7",
        "proposals": "_0x643b9b",
        "clearVote": "_0xab38dc",
        "keccak256": "_0x808527",
        "startDate": "_0x9c3159",
        "proposal_": "_0x29b1ef",
        "_endDate": "_0x982c10",
        "_canVote": "_0x6a53b0",
        "_msgData": "_0x36be4c",
        "_execute": "_0x01c833",
        "_actions": "_0x709132",
        "actions": "_0x977990",
        "abstain": "_0xcfedc8",
        "canVote": "_0x8294fe",
        "endDate": "_0x9f261b",
        "_voter": "_0xf80f6c",
        "decode": "_0x19620f",
        "encode": "_0xab7f57",
        "tally": "_0xfd8b8a",
        "voter": "_0xa989d8",
        "token": "_0x2b5b74",
        "_data": "_0xd799cd",
        "votes": "_0x0dbd1f",
        "auth": "_0xf9724f",
        "diff": "_0x0da714",
        "vote": "_0x1e5bd5",
        "_dao": "_0x02f672",
        "yes": "_0xcdc42d",
        "dao": "_0x59ac35",
        "no": "_0xc724ff"
      },
      "changes": [
        "Renamed 78 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_019",
      "transformed_id": "ss_l2_hex_sn_gs_019",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {ReentrancyGuardTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\n/// @title Midas Redemption Vault Gateway\n/// @notice Gateway contract that manages redemptions from Midas vault on behalf of users\n/// @dev Stores pending redemption requests and handles partial withdrawals\ncontract MidasRedemptionVaultGateway is ReentrancyGuardTrait, IMidasRedemptionVaultGateway {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant override _0xee7f79 = \"GATEWAY::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override _0x59a929 = 3_10;\n\n    address public immutable _0xfa56ab;\n    address public immutable _0xab8a0f;\n\n    mapping(address => PendingRedemption) public _0xa2876a;\n\n    /// @notice Constructor\n    /// @param _midasRedemptionVault Address of the Midas Redemption Vault\n    constructor(address _0x650329) {\n        _0xfa56ab = _0x650329;\n        _0xab8a0f = IMidasRedemptionVault(_0x650329)._0xab8a0f();\n    }\n\n    /// @notice Performs instant redemption of mToken for output token\n    /// @param tokenOut Output token to receive\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @param minReceiveAmount Minimum amount of output token to receive\n    /// @dev Transfers mToken from sender, redeems, and transfers output token back\n    function _0x3b5ded(address _0x00eca9, uint256 _0x504b59, uint256 _0x3d87a8) external _0x62beba {\n        IERC20(_0xab8a0f)._0x0a69bc(msg.sender, address(this), _0x504b59);\n\n        uint256 _0xc9deeb = IERC20(_0x00eca9)._0x644b78(address(this));\n\n        IERC20(_0xab8a0f)._0xc165a0(_0xfa56ab, _0x504b59);\n        IMidasRedemptionVault(_0xfa56ab)._0x3b5ded(_0x00eca9, _0x504b59, _0x3d87a8);\n\n        uint256 _0xb1b97b = IERC20(_0x00eca9)._0x644b78(address(this)) - _0xc9deeb;\n\n        IERC20(_0x00eca9)._0x6f4d79(msg.sender, _0xb1b97b);\n    }\n\n    /// @notice Requests a redemption of mToken for output token\n    /// @param tokenOut Output token to receive\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @dev Stores the request ID and timestamp for tracking\n    function _0xa1e2f6(address _0x00eca9, uint256 _0x504b59) external _0x62beba {\n        if (_0xa2876a[msg.sender]._0xbbcc58) {\n            revert(\"MidasRedemptionVaultGateway: user has a pending redemption\");\n        }\n\n        uint256 _0x19844a = IMidasRedemptionVault(_0xfa56ab)._0xdd7801();\n\n        IERC20(_0xab8a0f)._0x0a69bc(msg.sender, address(this), _0x504b59);\n\n        IERC20(_0xab8a0f)._0xc165a0(_0xfa56ab, _0x504b59);\n        IMidasRedemptionVault(_0xfa56ab)._0xfa4bcd(_0x00eca9, _0x504b59);\n\n        _0xa2876a[msg.sender] =\n            PendingRedemption({_0xbbcc58: true, _0x19844a: _0x19844a, timestamp: block.timestamp, _0xf9b140: 0});\n    }\n\n    /// @notice Withdraws tokens from a fulfilled redemption request\n    /// @param amount Amount of output token to withdraw\n    /// @dev Supports partial withdrawals by tracking remainder\n    function _0x591259(uint256 _0xb1b97b) external _0x62beba {\n        PendingRedemption memory _0x240634 = _0xa2876a[msg.sender];\n\n        if (!_0x240634._0xbbcc58) {\n            revert(\"MidasRedemptionVaultGateway: user does not have a pending redemption\");\n        }\n\n        (\n            address sender,\n            address _0x00eca9,\n            uint8 _0xdf984b,\n            uint256 _0x504b59,\n            uint256 _0xabf260,\n            uint256 _0x2b4aae\n        ) = IMidasRedemptionVault(_0xfa56ab)._0x3a46f9(_0x240634._0x19844a);\n\n        if (sender != address(this)) {\n            revert(\"MidasRedemptionVaultGateway: invalid request\");\n        }\n\n        if (_0xdf984b != 1) {\n            revert(\"MidasRedemptionVaultGateway: redemption not fulfilled\");\n        }\n\n        uint256 _0x4d3930;\n\n        if (_0x240634._0xf9b140 > 0) {\n            _0x4d3930 = _0x240634._0xf9b140;\n        } else {\n            _0x4d3930 = _0x6ecefc(_0x504b59, _0xabf260, _0x2b4aae, _0x00eca9);\n        }\n\n        if (_0xb1b97b > _0x4d3930) {\n            revert(\"MidasRedemptionVaultGateway: amount exceeds available\");\n        }\n\n        if (_0xb1b97b == _0x4d3930) {\n            delete _0xa2876a[msg.sender];\n        } else {\n            _0xa2876a[msg.sender]._0xf9b140 = _0x4d3930 - _0xb1b97b;\n        }\n\n        IERC20(_0x00eca9)._0x6f4d79(msg.sender, _0xb1b97b);\n    }\n\n    /// @notice Returns the expected amount of output token for a user's pending redemption\n    /// @param user User address to check\n    /// @param tokenOut Output token to check\n    /// @return Expected amount of output token, considering any partial withdrawals\n    function _0x56d317(address _0x4e1e64, address _0x00eca9) external view returns (uint256) {\n        PendingRedemption memory _0x240634 = _0xa2876a[_0x4e1e64];\n\n        if (!_0x240634._0xbbcc58) {\n            return 0;\n        }\n\n        (address sender, address _0xac058d,, uint256 _0x504b59, uint256 _0xabf260, uint256 _0x2b4aae) =\n            IMidasRedemptionVault(_0xfa56ab)._0x3a46f9(_0x240634._0x19844a);\n\n        if (sender != address(this) || _0xac058d != _0x00eca9) {\n            return 0;\n        }\n\n        if (_0x240634._0xf9b140 > 0) {\n            return _0x240634._0xf9b140;\n        } else {\n            return _0x6ecefc(_0x504b59, _0xabf260, _0x2b4aae, _0x00eca9);\n        }\n    }\n\n    /// @dev Calculates the output token amount from mToken amount and rates\n    /// @param amountMTokenIn Amount of mToken\n    /// @param mTokenRate Rate of mToken\n    /// @param tokenOutRate Rate of output token\n    /// @param tokenOut Address of output token\n    /// @return Amount of output token in its native decimals\n    function _0x6ecefc(\n        uint256 _0x504b59,\n        uint256 _0xabf260,\n        uint256 _0x2b4aae,\n        address _0x00eca9\n    ) internal view returns (uint256) {\n        uint256 _0xb3f77b = (_0x504b59 * _0xabf260) / _0x2b4aae;\n\n        uint256 _0xa14345 = 10 ** IERC20Metadata(_0x00eca9)._0xf6a85b();\n\n        return _0xb3f77b * _0xa14345 / 1e18;\n    }\n}",
      "rename_map": {
        "_calculateTokenOutAmount": "_0x6ecefc",
        "_midasRedemptionVault": "_0x650329",
        "pendingTokenOutAmount": "_0x56d317",
        "midasRedemptionVault": "_0xfa56ab",
        "pendingRedemptions": "_0xa2876a",
        "safeTransferFrom": "_0x0a69bc",
        "minReceiveAmount": "_0x3d87a8",
        "currentRequestId": "_0xdd7801",
        "availableAmount": "_0x4d3930",
        "requestTokenOut": "_0xac058d",
        "amountMTokenIn": "_0x504b59",
        "redeemRequests": "_0x3a46f9",
        "redeemRequest": "_0xfa4bcd",
        "balanceBefore": "_0xc9deeb",
        "redeemInstant": "_0x3b5ded",
        "requestRedeem": "_0xa1e2f6",
        "nonReentrant": "_0x62beba",
        "tokenOutRate": "_0x2b4aae",
        "safeTransfer": "_0x6f4d79",
        "forceApprove": "_0xc165a0",
        "contractType": "_0xee7f79",
        "amount1e18": "_0xb3f77b",
        "mTokenRate": "_0xabf260",
        "balanceOf": "_0x644b78",
        "remainder": "_0xf9b140",
        "tokenUnit": "_0xa14345",
        "requestId": "_0x19844a",
        "decimals": "_0xf6a85b",
        "withdraw": "_0x591259",
        "isActive": "_0xbbcc58",
        "tokenOut": "_0x00eca9",
        "pending": "_0x240634",
        "version": "_0x59a929",
        "status": "_0xdf984b",
        "amount": "_0xb1b97b",
        "mToken": "_0xab8a0f",
        "user": "_0x4e1e64"
      },
      "changes": [
        "Renamed 37 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_020",
      "transformed_id": "ss_l2_hex_sn_gs_020",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\nimport {NotImplementedException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultAdapter} from \"../../interfaces/midas/IMidasRedemptionVaultAdapter.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\nimport {WAD, RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\n\n/// @title Midas Redemption Vault adapter\n/// @notice Implements logic for interacting with the Midas Redemption Vault through a gateway\ncontract MidasRedemptionVaultAdapter is AbstractAdapter, IMidasRedemptionVaultAdapter {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 public constant override _0x10b7df = \"ADAPTER::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override _0x207233 = 3_10;\n\n    /// @notice mToken\n    address public immutable override _0x80cf09;\n\n    /// @notice Gateway address\n    address public immutable override _0x4eddd8;\n\n    /// @notice Mapping from phantom token to its tracked output token\n    mapping(address => address) public _0xdc9c27;\n\n    /// @notice Mapping from output token to its tracked phantom token\n    mapping(address => address) public _0xfc1631;\n\n    /// @dev Set of allowed output tokens for redemptions\n    EnumerableSet.AddressSet internal _0x755cc6;\n\n    /// @notice Constructor\n    /// @param _creditManager Credit manager address\n    /// @param _gateway Midas Redemption Vault gateway address\n    constructor(address _0x398bbb, address _0x951dcb) AbstractAdapter(_0x398bbb, _0x951dcb) {\n        _0x4eddd8 = _0x951dcb;\n        _0x80cf09 = IMidasRedemptionVaultGateway(_0x951dcb)._0x80cf09();\n\n        _0x131226(_0x80cf09);\n    }\n\n    /// @notice Instantly redeems mToken for output token\n    /// @param tokenOut Output token address\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @param minReceiveAmount Minimum amount of output token to receive\n    function _0xcdb5e6(address _0x1a3bf6, uint256 _0x0f616c, uint256 _0xb12d8a)\n        external\n        override\n        _0xb52eef\n        returns (bool)\n    {\n        if (!_0xac26bf(_0x1a3bf6)) revert TokenNotAllowedException();\n\n        _0x37bbeb(_0x1a3bf6, _0x0f616c, _0xb12d8a);\n\n        return false;\n    }\n\n    /// @notice Instantly redeems the entire balance of mToken for output token, except the specified amount\n    /// @param tokenOut Output token address\n    /// @param leftoverAmount Amount of mToken to keep in the account\n    /// @param rateMinRAY Minimum exchange rate from input token to mToken (in RAY format)\n    function _0x727bac(address _0x1a3bf6, uint256 _0x4471fe, uint256 _0x345259)\n        external\n        override\n        _0xb52eef\n        returns (bool)\n    {\n        if (!_0xac26bf(_0x1a3bf6)) revert TokenNotAllowedException();\n\n        address _0x5f616c = _0xf4d127();\n\n        uint256 balance = IERC20(_0x80cf09)._0x28d8be(_0x5f616c);\n        if (balance > _0x4471fe) {\n            unchecked {\n                uint256 _0xbd05c4 = balance - _0x4471fe;\n                uint256 _0xb12d8a = (_0xbd05c4 * _0x345259) / RAY;\n                _0x37bbeb(_0x1a3bf6, _0xbd05c4, _0xb12d8a);\n            }\n        }\n        return false;\n    }\n\n    /// @dev Internal implementation of redeemInstant\n    function _0x37bbeb(address _0x1a3bf6, uint256 _0x0f616c, uint256 _0xb12d8a) internal {\n        _0x9e2d94(\n            _0x80cf09,\n            abi._0x269ac8(\n                IMidasRedemptionVaultGateway._0xcdb5e6,\n                (_0x1a3bf6, _0x0f616c, _0x266bb2(_0xb12d8a, _0x1a3bf6))\n            )\n        );\n    }\n\n    /// @notice Requests a redemption of mToken for output token\n    /// @param tokenOut Output token address\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @dev Returns `true` to allow safe pricing for the withdrawal phantom token\n    function _0xc878f4(address _0x1a3bf6, uint256 _0x0f616c)\n        external\n        override\n        _0xb52eef\n        returns (bool)\n    {\n        if (!_0xac26bf(_0x1a3bf6) || _0xfc1631[_0x1a3bf6] == address(0)) {\n            revert TokenNotAllowedException();\n        }\n\n        _0x9e2d94(\n            _0x80cf09, abi._0x269ac8(IMidasRedemptionVaultGateway._0xc1e8a2, (_0x1a3bf6, _0x0f616c))\n        );\n        return true;\n    }\n\n    /// @notice Withdraws redeemed tokens from the gateway\n    /// @param amount Amount to withdraw\n    function _0x541ff2(uint256 _0xbd05c4) external override _0xb52eef returns (bool) {\n        _0xfc7f32(_0xbd05c4);\n        return false;\n    }\n\n    /// @dev Internal implementation of withdraw\n    function _0xfc7f32(uint256 _0xbd05c4) internal {\n        _0xe0cf8c(abi._0x269ac8(IMidasRedemptionVaultGateway._0x541ff2, (_0xbd05c4)));\n    }\n\n    /// @notice Withdraws phantom token balance\n    /// @param token Phantom token address\n    /// @param amount Amount to withdraw\n    function _0xc7d903(address _0xed4ad6, uint256 _0xbd05c4) external override _0xb52eef returns (bool) {\n        if (_0xdc9c27[_0xed4ad6] == address(0)) revert IncorrectStakedPhantomTokenException();\n        _0xfc7f32(_0xbd05c4);\n        return false;\n    }\n\n    /// @notice Deposits phantom token (not implemented for redemption vaults)\n    /// @return Never returns (always reverts)\n    /// @dev Redemption vaults only support withdrawals, not deposits\n    function _0x58dd83(address, uint256) external pure override returns (bool) {\n        revert NotImplementedException();\n    }\n\n    /// @dev Converts the token amount to 18 decimals, which is accepted by Midas\n    function _0x266bb2(uint256 _0xbd05c4, address _0xed4ad6) internal view returns (uint256) {\n        uint256 _0xa70272 = 10 ** IERC20Metadata(_0xed4ad6)._0xb24dbe();\n        return _0xbd05c4 * WAD / _0xa70272;\n    }\n\n    /// @notice Returns whether a token is allowed as output for redemptions\n    /// @param token Token address to check\n    /// @return True if token is allowed\n    function _0xac26bf(address _0xed4ad6) public view override returns (bool) {\n        return _0x755cc6._0xf0533e(_0xed4ad6);\n    }\n\n    /// @notice Returns all allowed output tokens\n    /// @return Array of allowed token addresses\n    function _0x814062() public view override returns (address[] memory) {\n        return _0x755cc6._0xa40c0e();\n    }\n\n    /// @notice Sets the allowed status for a batch of output tokens\n    /// @param configs Array of MidasAllowedTokenStatus structs\n    /// @dev Can only be called by the configurator\n    function _0xabce2e(MidasAllowedTokenStatus[] calldata _0xe4e3fc)\n        external\n        override\n        _0x9c86a1\n    {\n        uint256 _0x94f0e1 = _0xe4e3fc.length;\n\n        for (uint256 i; i < _0x94f0e1; ++i) {\n            MidasAllowedTokenStatus memory _0xc5c0ef = _0xe4e3fc[i];\n\n            if (_0xc5c0ef._0x16b502) {\n                _0x131226(_0xc5c0ef._0xed4ad6);\n                _0x755cc6._0x1aef01(_0xc5c0ef._0xed4ad6);\n\n                if (_0xc5c0ef._0x0832a4 != address(0)) {\n                    _0x131226(_0xc5c0ef._0x0832a4);\n                    _0xdc9c27[_0xc5c0ef._0x0832a4] = _0xc5c0ef._0xed4ad6;\n                    _0xfc1631[_0xc5c0ef._0xed4ad6] = _0xc5c0ef._0x0832a4;\n                }\n            } else {\n                _0x755cc6._0xf8944b(_0xc5c0ef._0xed4ad6);\n\n                address _0x0832a4 = _0xfc1631[_0xc5c0ef._0xed4ad6];\n\n                if (_0x0832a4 != address(0)) {\n                    delete _0xfc1631[_0xc5c0ef._0xed4ad6];\n                    delete _0xdc9c27[_0x0832a4];\n                }\n            }\n\n            emit SetTokenAllowedStatus(_0xc5c0ef._0xed4ad6, _0xc5c0ef._0x0832a4, _0xc5c0ef._0x16b502);\n        }\n    }\n\n    /// @notice Serialized adapter parameters\n    /// @return serializedData Encoded adapter configuration\n    function _0x769acb() external view returns (bytes memory _0xb481ca) {\n        _0xb481ca = abi._0xa530f1(_0x74563a, _0x80a57d, _0x4eddd8, _0x80cf09, _0x814062());\n    }\n}",
      "rename_map": {
        "setTokenAllowedStatusBatch": "_0xabce2e",
        "phantomTokenToOutputToken": "_0xdc9c27",
        "outputTokenToPhantomToken": "_0xfc1631",
        "_executeSwapSafeApprove": "_0x9e2d94",
        "withdrawPhantomToken": "_0xc7d903",
        "depositPhantomToken": "_0x58dd83",
        "redeemInstantDiff": "_0x727bac",
        "_getMaskOrRevert": "_0x131226",
        "minReceiveAmount": "_0xb12d8a",
        "configuratorOnly": "_0x9c86a1",
        "creditFacadeOnly": "_0xb52eef",
        "amountMTokenIn": "_0x0f616c",
        "isTokenAllowed": "_0xac26bf",
        "_allowedTokens": "_0x755cc6",
        "leftoverAmount": "_0x4471fe",
        "_redeemInstant": "_0x37bbeb",
        "serializedData": "_0xb481ca",
        "_creditAccount": "_0xf4d127",
        "targetContract": "_0x80a57d",
        "_creditManager": "_0x398bbb",
        "redeemRequest": "_0xc878f4",
        "creditManager": "_0x74563a",
        "_convertToE18": "_0x266bb2",
        "redeemInstant": "_0xcdb5e6",
        "requestRedeem": "_0xc1e8a2",
        "creditAccount": "_0x5f616c",
        "allowedTokens": "_0x814062",
        "contractType": "_0x10b7df",
        "phantomToken": "_0x0832a4",
        "encodeCall": "_0x269ac8",
        "rateMinRAY": "_0x345259",
        "balanceOf": "_0x28d8be",
        "_withdraw": "_0xfc7f32",
        "tokenUnit": "_0xa70272",
        "serialize": "_0x769acb",
        "_execute": "_0xe0cf8c",
        "_gateway": "_0x951dcb",
        "decimals": "_0xb24dbe",
        "contains": "_0xf0533e",
        "withdraw": "_0x541ff2",
        "tokenOut": "_0x1a3bf6",
        "allowed": "_0x16b502",
        "gateway": "_0x4eddd8",
        "configs": "_0xe4e3fc",
        "version": "_0x207233",
        "remove": "_0xf8944b",
        "values": "_0xa40c0e",
        "config": "_0xc5c0ef",
        "encode": "_0xa530f1",
        "amount": "_0xbd05c4",
        "mToken": "_0x80cf09",
        "token": "_0xed4ad6",
        "len": "_0x94f0e1",
        "add": "_0x1aef01"
      },
      "changes": [
        "Renamed 54 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_021",
      "transformed_id": "ss_l2_hex_sn_gs_021",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, _0xa4e47f} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n/// @title UniswapV4KEMHook\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n  /// @notice Thrown when the caller is not PoolManager\n  error NotPoolManager();\n\n  /// @notice The address of the PoolManager contract\n  IPoolManager public immutable _0x691fdd;\n\n  constructor(\n    IPoolManager _0xe42236,\n    address _0xc7bdcb,\n    address[] memory _0x9daa21,\n    address _0x375f13,\n    address _0xa990c6\n  ) BaseKEMHook(_0xc7bdcb, _0x9daa21, _0x375f13, _0xa990c6) {\n    _0x691fdd = _0xe42236;\n    Hooks._0x2ac932(IHooks(address(this)), _0x0ed9e4());\n  }\n\n  /// @notice Only allow calls from the PoolManager contract\n  modifier _0x38eaae() {\n    if (msg.sender != address(_0x691fdd)) revert NotPoolManager();\n    _;\n  }\n\n  /// @inheritdoc IKEMHook\n  function _0x3113da(address[] calldata _0x2b79d6, uint256[] calldata _0x06fb7f) public {\n    require(_0xf1dcb6[msg.sender], NonClaimableAccount(msg.sender));\n    require(_0x2b79d6.length == _0x06fb7f.length, MismatchedArrayLengths());\n\n    _0x691fdd._0xb2b7a7(abi._0x003305(_0x2b79d6, _0x06fb7f));\n  }\n\n  function _0x85e928(bytes calldata data) public _0x38eaae returns (bytes memory) {\n    (address[] memory _0x2b79d6, uint256[] memory _0x06fb7f) = abi._0x171028(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < _0x2b79d6.length; i++) {\n      uint256 _0x5ec077 = uint256(uint160(_0x2b79d6[i]));\n      if (_0x06fb7f[i] == 0) {\n        _0x06fb7f[i] = _0x691fdd._0x540a54(address(this), _0x5ec077);\n      }\n      if (_0x06fb7f[i] > 0) {\n        _0x691fdd._0x1c7319(address(this), _0x5ec077, _0x06fb7f[i]);\n        _0x691fdd._0x2b637b(Currency._0xa40d2f(_0x2b79d6[i]), _0x9747ef, _0x06fb7f[i]);\n      }\n    }\n\n    emit ClaimEgTokens(_0x9747ef, _0x2b79d6, _0x06fb7f);\n  }\n\n  function _0x0ed9e4() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      _0x3a74c8: false,\n      _0x6e73c7: false,\n      _0xf226a8: false,\n      _0x6339c8: false,\n      _0x47526e: false,\n      _0xba470f: false,\n      _0x73c8e9: true,\n      _0x5c4ec1: true,\n      _0x02c839: false,\n      _0x0dd3cc: false,\n      _0x23b00f: false,\n      _0x973746: true,\n      _0xc8fb1f: false,\n      _0x7d162e: false\n    });\n  }\n\n  function _0x73c8e9(\n    address sender,\n    PoolKey calldata _0xaabff5,\n    IPoolManager.SwapParams calldata _0x4f56a1,\n    bytes calldata _0x163071\n  ) external _0x38eaae returns (bytes4, BeforeSwapDelta, uint24) {\n    require(_0x4f56a1._0x9754ab < 0, ExactOutputDisabled());\n\n    (\n      int256 _0x28310e,\n      int256 _0x114684,\n      int256 _0x81f0ef,\n      uint256 _0x4cad1e,\n      uint256 _0x191a63,\n      bytes memory _0xfc4b19\n    ) = HookDataDecoder._0x1c7857(_0x163071);\n\n    require(block.timestamp <= _0x191a63, ExpiredSignature(_0x191a63, block.timestamp));\n    require(\n      -_0x4f56a1._0x9754ab <= _0x28310e,\n      ExceededMaxAmountIn(_0x28310e, -_0x4f56a1._0x9754ab)\n    );\n\n    _0x3e0161(_0x4cad1e);\n\n    bytes32 _0xf6291f = _0xa1e2ee(\n      abi._0x003305(\n        sender,\n        _0xaabff5,\n        _0x4f56a1._0xfcd8a5,\n        _0x28310e,\n        _0x114684,\n        _0x81f0ef,\n        _0x4cad1e,\n        _0x191a63\n      )\n    );\n    require(\n      SignatureChecker._0x467ee0(_0x932e1f, _0xf6291f, _0xfc4b19), InvalidSignature()\n    );\n\n    return (this._0x73c8e9.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function _0x5c4ec1(\n    address,\n    PoolKey calldata _0xaabff5,\n    IPoolManager.SwapParams calldata _0x4f56a1,\n    BalanceDelta _0x0f7a29,\n    bytes calldata _0x163071\n  ) external _0x38eaae returns (bytes4, int128) {\n    (int256 _0x114684, int256 _0x81f0ef) =\n      HookDataDecoder._0x50496a(_0x163071);\n\n    int128 _0x7c7c48;\n    int128 _0xed4f26;\n    Currency _0xfac989;\n    unchecked {\n      if (_0x4f56a1._0xfcd8a5) {\n        _0x7c7c48 = -_0x0f7a29._0x11e689();\n        _0xed4f26 = _0x0f7a29._0x6e4b04();\n        _0xfac989 = _0xaabff5._0xf09ae0;\n      } else {\n        _0x7c7c48 = -_0x0f7a29._0x6e4b04();\n        _0xed4f26 = _0x0f7a29._0x11e689();\n        _0xfac989 = _0xaabff5._0xfb0c08;\n      }\n    }\n\n    int256 _0x64f662 = _0x7c7c48 * _0x114684 / _0x81f0ef;\n\n    unchecked {\n      int256 _0x32cbbf = _0x64f662 < _0xed4f26 ? _0xed4f26 - _0x64f662 : int256(0);\n      if (_0x32cbbf > 0) {\n        _0x691fdd._0x4a5d7c(\n          address(this), uint256(uint160(Currency._0xa9532b(_0xfac989))), uint256(_0x32cbbf)\n        );\n\n        emit AbsorbEgToken(PoolId._0xa9532b(_0xaabff5._0x26a070()), Currency._0xa9532b(_0xfac989), _0x32cbbf);\n      }\n\n      return (this._0x5c4ec1.selector, int128(_0x32cbbf));\n    }\n  }\n}",
      "rename_map": {
        "afterRemoveLiquidityReturnDelta": "_0x7d162e",
        "afterAddLiquidityReturnDelta": "_0xc8fb1f",
        "initialClaimableAccounts": "_0x9daa21",
        "validateHookPermissions": "_0x2ac932",
        "beforeSwapReturnDelta": "_0x23b00f",
        "beforeRemoveLiquidity": "_0x47526e",
        "afterRemoveLiquidity": "_0xba470f",
        "afterSwapReturnDelta": "_0x973746",
        "isValidSignatureNow": "_0x467ee0",
        "beforeAddLiquidity": "_0xf226a8",
        "_useUnorderedNonce": "_0x3e0161",
        "decodeExchangeRate": "_0x50496a",
        "initialEgRecipient": "_0xa990c6",
        "getHookPermissions": "_0x0ed9e4",
        "initialQuoteSigner": "_0x375f13",
        "exchangeRateDenom": "_0x81f0ef",
        "afterAddLiquidity": "_0x6339c8",
        "decodeAllHookData": "_0x1c7857",
        "beforeInitialize": "_0x3a74c8",
        "onlyPoolManager": "_0x38eaae",
        "amountSpecified": "_0x9754ab",
        "afterInitialize": "_0x6e73c7",
        "maxExchangeRate": "_0x114684",
        "unlockCallback": "_0x85e928",
        "toBalanceDelta": "_0xa4e47f",
        "claimEgTokens": "_0x3113da",
        "maxAmountOut": "_0x64f662",
        "beforeDonate": "_0x02c839",
        "_poolManager": "_0xe42236",
        "initialOwner": "_0xc7bdcb",
        "afterDonate": "_0x0dd3cc",
        "maxAmountIn": "_0x28310e",
        "egRecipient": "_0x9747ef",
        "poolManager": "_0x691fdd",
        "quoteSigner": "_0x932e1f",
        "currencyOut": "_0xfac989",
        "beforeSwap": "_0x73c8e9",
        "zeroForOne": "_0xfcd8a5",
        "expiryTime": "_0x191a63",
        "balanceOf": "_0x540a54",
        "amountOut": "_0xed4f26",
        "claimable": "_0xf1dcb6",
        "signature": "_0xfc4b19",
        "keccak256": "_0xa1e2ee",
        "currency0": "_0xfb0c08",
        "afterSwap": "_0x5c4ec1",
        "currency1": "_0xf09ae0",
        "amountIn": "_0x7c7c48",
        "hookData": "_0x163071",
        "egAmount": "_0x32cbbf",
        "amount1": "_0x6e4b04",
        "amounts": "_0x06fb7f",
        "amount0": "_0x11e689",
        "unlock": "_0xb2b7a7",
        "unwrap": "_0xa9532b",
        "decode": "_0x171028",
        "params": "_0x4f56a1",
        "digest": "_0xf6291f",
        "tokens": "_0x2b79d6",
        "encode": "_0x003305",
        "delta": "_0x0f7a29",
        "nonce": "_0x4cad1e",
        "take": "_0x2b637b",
        "wrap": "_0xa40d2f",
        "burn": "_0x1c7319",
        "toId": "_0x26a070",
        "mint": "_0x4a5d7c",
        "key": "_0xaabff5",
        "id": "_0x5ec077"
      },
      "changes": [
        "Renamed 69 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_022",
      "transformed_id": "ss_l2_hex_sn_gs_022",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, _0x0e1337} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n/// @title UniswapV4KEMHook\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n  /// @notice Thrown when the caller is not PoolManager\n  error NotPoolManager();\n\n  /// @notice The address of the PoolManager contract\n  IPoolManager public immutable _0xabe670;\n\n  constructor(\n    IPoolManager _0x634a97,\n    address _0xa7cd95,\n    address[] memory _0xabbadb,\n    address _0x01e6f8,\n    address _0x034bbf\n  ) BaseKEMHook(_0xa7cd95, _0xabbadb, _0x01e6f8, _0x034bbf) {\n    _0xabe670 = _0x634a97;\n    Hooks._0x41ea10(IHooks(address(this)), _0x277c83());\n  }\n\n  /// @notice Only allow calls from the PoolManager contract\n  modifier _0xa729f9() {\n    if (msg.sender != address(_0xabe670)) revert NotPoolManager();\n    _;\n  }\n\n  /// @inheritdoc IKEMHook\n  function _0x61c671(address[] calldata _0x679601, uint256[] calldata _0x01b1b8) public {\n    require(_0xfcb723[msg.sender], NonClaimableAccount(msg.sender));\n    require(_0x679601.length == _0x01b1b8.length, MismatchedArrayLengths());\n\n    _0xabe670._0xe61dd4(abi._0x50622a(_0x679601, _0x01b1b8));\n  }\n\n  function _0xf4da36(bytes calldata data) public _0xa729f9 returns (bytes memory) {\n    (address[] memory _0x679601, uint256[] memory _0x01b1b8) = abi._0x5da861(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < _0x679601.length; i++) {\n      uint256 _0x0bdd49 = uint256(uint160(_0x679601[i]));\n      if (_0x01b1b8[i] == 0) {\n        _0x01b1b8[i] = _0xabe670._0x5cb76f(address(this), _0x0bdd49);\n      }\n      if (_0x01b1b8[i] > 0) {\n        _0xabe670._0x69b6b4(address(this), _0x0bdd49, _0x01b1b8[i]);\n        _0xabe670._0x7b7591(Currency._0xde5628(_0x679601[i]), _0x2c9166, _0x01b1b8[i]);\n      }\n    }\n\n    emit ClaimEgTokens(_0x2c9166, _0x679601, _0x01b1b8);\n  }\n\n  function _0x277c83() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      _0xeec954: false,\n      _0x93344e: false,\n      _0xb08d91: false,\n      _0xf582c2: false,\n      _0xc44b54: false,\n      _0x21095e: false,\n      _0x8f2088: true,\n      _0x562e89: true,\n      _0xff023b: false,\n      _0x622d74: false,\n      _0x55de3c: false,\n      _0xf19cdc: true,\n      _0xa0c49f: false,\n      _0x43a42c: false\n    });\n  }\n\n  function _0x8f2088(\n    address sender,\n    PoolKey calldata _0x1d2a8e,\n    IPoolManager.SwapParams calldata _0x31bb60,\n    bytes calldata _0x3da71a\n  ) external _0xa729f9 returns (bytes4, BeforeSwapDelta, uint24) {\n    require(_0x31bb60._0x9bb2f6 < 0, ExactOutputDisabled());\n\n    (\n      int256 _0x15f909,\n      int256 _0xf94514,\n      int256 _0x5341b8,\n      uint256 _0x159b0b,\n      uint256 _0x1dbb02,\n      bytes memory _0xc6129d\n    ) = HookDataDecoder._0xf3fe46(_0x3da71a);\n\n    require(block.timestamp <= _0x1dbb02, ExpiredSignature(_0x1dbb02, block.timestamp));\n    require(\n      -_0x31bb60._0x9bb2f6 <= _0x15f909,\n      ExceededMaxAmountIn(_0x15f909, -_0x31bb60._0x9bb2f6)\n    );\n\n    _0x09b8eb(_0x159b0b);\n\n    bytes32 _0xb7bd89 = _0x5d1d0f(\n      abi._0x50622a(\n        sender,\n        _0x1d2a8e,\n        _0x31bb60._0x0f6b67,\n        _0x15f909,\n        _0xf94514,\n        _0x5341b8,\n        _0x159b0b,\n        _0x1dbb02\n      )\n    );\n    require(\n      SignatureChecker._0x85a862(_0x000ccc, _0xb7bd89, _0xc6129d), InvalidSignature()\n    );\n\n    return (this._0x8f2088.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function _0x562e89(\n    address,\n    PoolKey calldata _0x1d2a8e,\n    IPoolManager.SwapParams calldata _0x31bb60,\n    BalanceDelta _0xbf79c4,\n    bytes calldata _0x3da71a\n  ) external _0xa729f9 returns (bytes4, int128) {\n    (int256 _0xf94514, int256 _0x5341b8) =\n      HookDataDecoder._0xe270d0(_0x3da71a);\n\n    int128 _0x67551f;\n    int128 _0x04bc50;\n    Currency _0x4bed02;\n    unchecked {\n      if (_0x31bb60._0x0f6b67) {\n        _0x67551f = -_0xbf79c4._0x8d88bd();\n        _0x04bc50 = _0xbf79c4._0xf39a38();\n        _0x4bed02 = _0x1d2a8e._0x9421da;\n      } else {\n        _0x67551f = -_0xbf79c4._0xf39a38();\n        _0x04bc50 = _0xbf79c4._0x8d88bd();\n        _0x4bed02 = _0x1d2a8e._0xc8da81;\n      }\n    }\n\n    int256 _0xa11fa1 = _0x67551f * _0xf94514 / _0x5341b8;\n\n    unchecked {\n      int256 _0x6fb155 = _0xa11fa1 < _0x04bc50 ? _0x04bc50 - _0xa11fa1 : int256(0);\n      if (_0x6fb155 > 0) {\n        _0xabe670._0xca6c00(\n          address(this), uint256(uint160(Currency._0xc9b3c7(_0x4bed02))), uint256(_0x6fb155)\n        );\n\n        emit AbsorbEgToken(PoolId._0xc9b3c7(_0x1d2a8e._0x294261()), Currency._0xc9b3c7(_0x4bed02), _0x6fb155);\n      }\n\n      return (this._0x562e89.selector, int128(_0x6fb155));\n    }\n  }\n}",
      "rename_map": {
        "afterRemoveLiquidityReturnDelta": "_0x43a42c",
        "afterAddLiquidityReturnDelta": "_0xa0c49f",
        "initialClaimableAccounts": "_0xabbadb",
        "validateHookPermissions": "_0x41ea10",
        "beforeSwapReturnDelta": "_0x55de3c",
        "beforeRemoveLiquidity": "_0xc44b54",
        "afterRemoveLiquidity": "_0x21095e",
        "afterSwapReturnDelta": "_0xf19cdc",
        "isValidSignatureNow": "_0x85a862",
        "beforeAddLiquidity": "_0xb08d91",
        "_useUnorderedNonce": "_0x09b8eb",
        "decodeExchangeRate": "_0xe270d0",
        "initialEgRecipient": "_0x034bbf",
        "getHookPermissions": "_0x277c83",
        "initialQuoteSigner": "_0x01e6f8",
        "exchangeRateDenom": "_0x5341b8",
        "afterAddLiquidity": "_0xf582c2",
        "decodeAllHookData": "_0xf3fe46",
        "beforeInitialize": "_0xeec954",
        "onlyPoolManager": "_0xa729f9",
        "amountSpecified": "_0x9bb2f6",
        "afterInitialize": "_0x93344e",
        "maxExchangeRate": "_0xf94514",
        "unlockCallback": "_0xf4da36",
        "toBalanceDelta": "_0x0e1337",
        "claimEgTokens": "_0x61c671",
        "maxAmountOut": "_0xa11fa1",
        "beforeDonate": "_0xff023b",
        "_poolManager": "_0x634a97",
        "initialOwner": "_0xa7cd95",
        "afterDonate": "_0x622d74",
        "maxAmountIn": "_0x15f909",
        "egRecipient": "_0x2c9166",
        "poolManager": "_0xabe670",
        "quoteSigner": "_0x000ccc",
        "currencyOut": "_0x4bed02",
        "beforeSwap": "_0x8f2088",
        "zeroForOne": "_0x0f6b67",
        "expiryTime": "_0x1dbb02",
        "balanceOf": "_0x5cb76f",
        "amountOut": "_0x04bc50",
        "claimable": "_0xfcb723",
        "signature": "_0xc6129d",
        "keccak256": "_0x5d1d0f",
        "currency0": "_0xc8da81",
        "afterSwap": "_0x562e89",
        "currency1": "_0x9421da",
        "amountIn": "_0x67551f",
        "hookData": "_0x3da71a",
        "egAmount": "_0x6fb155",
        "amount1": "_0xf39a38",
        "amounts": "_0x01b1b8",
        "amount0": "_0x8d88bd",
        "unlock": "_0xe61dd4",
        "unwrap": "_0xc9b3c7",
        "decode": "_0x5da861",
        "params": "_0x31bb60",
        "digest": "_0xb7bd89",
        "tokens": "_0x679601",
        "encode": "_0x50622a",
        "delta": "_0xbf79c4",
        "nonce": "_0x159b0b",
        "take": "_0x7b7591",
        "wrap": "_0xde5628",
        "burn": "_0x69b6b4",
        "toId": "_0x294261",
        "mint": "_0xca6c00",
        "key": "_0x1d2a8e",
        "id": "_0x0bdd49"
      },
      "changes": [
        "Renamed 69 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_023",
      "transformed_id": "ss_l2_hex_sn_gs_023",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed _0x125a90, uint256 _0x01788f);\n    event ETHReturnedToStaking(uint256 _0x01788f);\n    event ETHAllocatedToManager(uint256 indexed _0x125a90, uint256 _0x01788f);\n    event ETHReceivedFromStaking(uint256 _0x01788f);\n    event FeesCollected(uint256 _0x01788f);\n    event InterestClaimed(\n        uint256 indexed _0x125a90,\n        uint256 _0xe3caa0\n    );\n    event InterestToppedUp(\n        uint256 _0x01788f\n    );\n}\n\n/**\n * @title LiquidityBuffer\n * @notice Manages liquidity allocation to various position managers for DeFi protocols\n */\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n    // ========================================= CONSTANTS =========================================\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = _0x84bd24(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = _0x84bd24(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = _0x84bd24(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = _0x84bd24(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant _0xabe5f4 = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /// @notice The staking contract to which the liquidity buffer accepts funds from and returns funds to.\n    IStakingReturnsWrite public _0x530446;\n\n    /// @notice The pauser contract.\n    /// @dev Keeps the pause state across the protocol.\n    IPauserRead public _0x161e56;\n\n    /// @notice Total number of position managers\n    uint256 public _0x17372c;\n\n    /// @notice Mapping from manager ID to position manager configuration\n    mapping(uint256 => PositionManagerConfig) public _0xd88f6e;\n\n    /// @notice Mapping from manager ID to accounting information\n    mapping(uint256 => PositionAccountant) public _0xa32ae8;\n\n    /// @notice Total funds received from staking contract\n    uint256 public _0xae2ece;\n\n    /// @notice Total funds returned to staking contract\n    uint256 public _0xbbb561;\n\n    /// @notice Total allocated balance across all position managers\n    uint256 public _0xc3d4b7;\n\n    /// @notice Total interest claimed from position managers\n    uint256 public _0x7c5faa;\n\n    /// @notice Total interest topped up to staking contract\n    uint256 public _0xed511b;\n\n    /// @notice Total allocation capacity across all managers\n    uint256 public _0xa11c92;\n\n    /// @notice Cumulative drawdown amount\n    uint256 public _0x48cb83;\n\n    /// @notice Default manager ID for deposit and allocation operations\n    uint256 public _0xb62c1c;\n\n    /// @notice The address receiving protocol fees.\n    address payable public _0x407052;\n\n    /// @notice The protocol fees in basis points (1/10000).\n    uint16 public _0x6b2b8e;\n\n    uint256 public _0x467ed7;\n\n    /// @notice Tracks pending interest available for top-up operations\n    uint256 public _0xc731b9;\n\n    /// @notice Tracks pending principal available for operations\n    uint256 public _0x45575e;\n\n    /// @notice Controls whether to execute allocation logic in depositETH method\n    bool public _0x753b9f;\n    /// @notice Mapping from manager address to boolean indicating if it is registered\n    mapping(address => bool) public _0x7c8185;\n\n    struct Init {\n        address _0xbc00b3;\n        address _0x155f29;\n        address _0x32b6f6;\n        address _0x801a10;\n        address _0x298cfd;\n        address payable _0x407052;\n        IStakingReturnsWrite _0x0cdb09;\n        IPauserRead _0x161e56;\n    }\n\n    // ========================================= ERRORS =========================================\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n    // ========================================= INITIALIZATION =========================================\n\n    constructor() {\n        _0xb06df2();\n    }\n\n    function _0x129766(Init memory _0xd6e174) external _0x65be36 {\n\n        __AccessControlEnumerable_init();\n\n        _0x2f5def(DEFAULT_ADMIN_ROLE, _0xd6e174._0xbc00b3);\n        _0x2f5def(LIQUIDITY_MANAGER_ROLE, _0xd6e174._0x155f29);\n        _0x2f5def(POSITION_MANAGER_ROLE, _0xd6e174._0x32b6f6);\n        _0x2f5def(INTEREST_TOPUP_ROLE, _0xd6e174._0x801a10);\n        _0x2f5def(DRAWDOWN_MANAGER_ROLE, _0xd6e174._0x298cfd);\n\n        _0x530446 = _0xd6e174._0x0cdb09;\n        _0x161e56 = _0xd6e174._0x161e56;\n        _0x407052 = _0xd6e174._0x407052;\n        _0x753b9f = true;\n\n        _0x2f5def(LIQUIDITY_MANAGER_ROLE, address(_0x530446));\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    function _0xf1baf0(uint256 _0x125a90) public view returns (uint256) {\n        PositionManagerConfig memory _0xa218ae = _0xd88f6e[_0x125a90];\n        // Get current underlying balance from position manager\n        IPositionManager _0x7d3d1c = IPositionManager(_0xa218ae._0x47f4e1);\n        uint256 _0x044b98 = _0x7d3d1c._0x592080();\n\n        // Calculate interest as: current balance - allocated balance\n        PositionAccountant memory _0x72a46d = _0xa32ae8[_0x125a90];\n\n        if (_0x044b98 > _0x72a46d._0x9bc38b) {\n            return _0x044b98 - _0x72a46d._0x9bc38b;\n        }\n\n        return 0;\n    }\n\n    function _0x3e90c5() public view returns (uint256) {\n        return _0xa11c92 - _0xc3d4b7;\n    }\n\n    function _0xf0f2da() public view returns (uint256) {\n        return _0xae2ece - _0xbbb561;\n    }\n\n    function _0xb834f4() public view returns (uint256) {\n        uint256 _0x45c1f5 = address(this).balance;\n\n        // Loop through all position manager configs and get their balances\n        // Note: This function makes external calls in a loop which can be gas-expensive\n        // Consider caching balances or using a different approach for production\n        for (uint256 i = 0; i < _0x17372c; i++) {\n            PositionManagerConfig storage _0xa218ae = _0xd88f6e[i];\n            if (_0xa218ae._0x67c8f7) {\n                IPositionManager _0x7d3d1c = IPositionManager(_0xa218ae._0x47f4e1);\n                uint256 _0x4f8c3e = _0x7d3d1c._0x592080();\n                _0x45c1f5 += _0x4f8c3e;\n            }\n        }\n\n        return _0x45c1f5;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n\n    function _0xcc8630(\n        address _0x47f4e1,\n        uint256 _0x3126b6\n    ) external _0x7b751d(POSITION_MANAGER_ROLE) returns (uint256 _0x125a90) {\n        if (_0x7c8185[_0x47f4e1]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        _0x125a90 = _0x17372c;\n        _0x17372c++;\n\n        _0xd88f6e[_0x125a90] = PositionManagerConfig({\n            _0x47f4e1: _0x47f4e1,\n            _0x3126b6: _0x3126b6,\n            _0x67c8f7: true\n        });\n        _0xa32ae8[_0x125a90] = PositionAccountant({\n            _0x9bc38b: 0,\n            _0x2f9abd: 0\n        });\n        _0x7c8185[_0x47f4e1] = true;\n\n        _0xa11c92 += _0x3126b6;\n        emit ProtocolConfigChanged(\n            this._0xcc8630.selector,\n            \"addPositionManager(address,uint256)\",\n            abi._0xa1d743(_0x47f4e1, _0x3126b6)\n        );\n    }\n\n    function _0x1ed670(\n        uint256 _0x125a90,\n        uint256 _0xed6297,\n        bool _0x67c8f7\n    ) external _0x7b751d(POSITION_MANAGER_ROLE) {\n        if (_0x125a90 >= _0x17372c) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0xa218ae = _0xd88f6e[_0x125a90];\n\n        if (_0xed6297 < _0xa32ae8[_0x125a90]._0x9bc38b) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        // Update total allocation capacity\n        _0xa11c92 = _0xa11c92 - _0xa218ae._0x3126b6 + _0xed6297;\n\n        _0xa218ae._0x3126b6 = _0xed6297;\n        _0xa218ae._0x67c8f7 = _0x67c8f7;\n\n        emit ProtocolConfigChanged(\n            this._0x1ed670.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi._0xa1d743(_0x125a90, _0xed6297, _0x67c8f7)\n        );\n    }\n\n    function _0x65c333(uint256 _0x125a90) external _0x7b751d(POSITION_MANAGER_ROLE) {\n        if (_0x125a90 >= _0x17372c) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0xa218ae = _0xd88f6e[_0x125a90];\n        _0xa218ae._0x67c8f7 = !_0xa218ae._0x67c8f7;\n\n        emit ProtocolConfigChanged(\n            this._0x65c333.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi._0xa1d743(_0x125a90)\n        );\n    }\n\n    function _0x8a289d(uint256 _0x572cf1) external _0x7b751d(DRAWDOWN_MANAGER_ROLE) {\n        _0x48cb83 = _0x572cf1;\n\n        emit ProtocolConfigChanged(\n            this._0x8a289d.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi._0xa1d743(_0x572cf1)\n        );\n    }\n\n    function _0x8c375e(uint256 _0x5cb7d2) external _0x7b751d(POSITION_MANAGER_ROLE) {\n        if (_0x5cb7d2 >= _0x17372c) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!_0xd88f6e[_0x5cb7d2]._0x67c8f7) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        _0xb62c1c = _0x5cb7d2;\n\n        emit ProtocolConfigChanged(\n            this._0x8c375e.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi._0xa1d743(_0x5cb7d2)\n        );\n    }\n\n    /// @notice Sets the fees basis points.\n    /// @param newBasisPoints The new fees basis points.\n    function _0x374063(uint16 _0x7f7408) external _0x7b751d(POSITION_MANAGER_ROLE) {\n        if (_0x7f7408 > _0xabe5f4) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        _0x6b2b8e = _0x7f7408;\n        emit ProtocolConfigChanged(\n            this._0x374063.selector, \"setFeeBasisPoints(uint16)\", abi._0xa1d743(_0x7f7408)\n        );\n    }\n\n     /// @notice Sets the fees receiver wallet for the protocol.\n    /// @param newReceiver The new fees receiver wallet.\n    function _0xb13da6(address payable _0xdc9a76)\n        external\n        _0x7b751d(POSITION_MANAGER_ROLE)\n        _0xc8a9c9(_0xdc9a76)\n    {\n        _0x407052 = _0xdc9a76;\n        emit ProtocolConfigChanged(this._0xb13da6.selector, \"setFeesReceiver(address)\", abi._0xa1d743(_0xdc9a76));\n    }\n\n    /// @notice Sets whether to execute allocation logic in depositETH method.\n    /// @param executeAllocation Whether to execute allocation logic.\n    function _0xd2b6bf(bool _0xb9c8aa) external _0x7b751d(POSITION_MANAGER_ROLE) {\n        _0x753b9f = _0xb9c8aa;\n        emit ProtocolConfigChanged(this._0xd2b6bf.selector, \"setShouldExecuteAllocation(bool)\", abi._0xa1d743(_0xb9c8aa));\n    }\n\n    // ========================================= LIQUIDITY MANAGEMENT =========================================\n\n    function _0x5803a3() external payable _0x7b751d(LIQUIDITY_MANAGER_ROLE) {\n        if (_0x161e56._0x7c4d5e()) revert LiquidityBuffer__Paused();\n        _0x3e05bd(msg.value);\n        if (_0x753b9f) {\n            _0x99b43d(_0xb62c1c, msg.value);\n        }\n    }\n\n    function _0x5bdea8(uint256 _0x125a90, uint256 _0x01788f) external _0x7b751d(LIQUIDITY_MANAGER_ROLE) {\n        _0x08bd4e(_0x125a90, _0x01788f);\n        _0x32b726(_0x01788f);\n    }\n\n    function _0x839718(uint256 _0x125a90, uint256 _0x01788f) external _0x7b751d(LIQUIDITY_MANAGER_ROLE) {\n        _0x99b43d(_0x125a90, _0x01788f);\n    }\n\n    function _0x88ec6e(uint256 _0x125a90, uint256 _0x01788f) external _0x7b751d(LIQUIDITY_MANAGER_ROLE) {\n        _0x08bd4e(_0x125a90, _0x01788f);\n    }\n\n    function _0x538fb0(uint256 _0x01788f) external _0x7b751d(LIQUIDITY_MANAGER_ROLE) {\n        _0x32b726(_0x01788f);\n    }\n\n    function _0x9d0efe() external payable _0x948289 {\n        // This function receives ETH from position managers\n        // The ETH is already in the contract balance, no additional processing needed\n    }\n\n    // ========================================= INTEREST MANAGEMENT =========================================\n\n    function _0x304d7f(uint256 _0x125a90, uint256 _0xba5b5d) external _0x7b751d(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0x01788f = _0xa87473(_0x125a90);\n        if (_0x01788f < _0xba5b5d) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return _0x01788f;\n    }\n\n    function _0x18a0d0(uint256 _0x01788f) external _0x7b751d(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < _0x01788f) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0xce66d3(_0x01788f);\n        return _0x01788f;\n    }\n\n    function _0x3b8b73(uint256 _0x125a90, uint256 _0xba5b5d) external _0x7b751d(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0x01788f = _0xa87473(_0x125a90);\n        if (_0x01788f < _0xba5b5d) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0xce66d3(_0x01788f);\n\n        return _0x01788f;\n    }\n\n    // ========================================= INTERNAL FUNCTIONS =========================================\n\n    function _0xce66d3(uint256 _0x01788f) internal {\n        if (_0x161e56._0x7c4d5e()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x01788f > _0xc731b9) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        _0xc731b9 -= _0x01788f;\n        uint256 _0xe52afa = Math._0x003c07(_0x6b2b8e, _0x01788f, _0xabe5f4);\n        uint256 _0x4d44c6 = _0x01788f - _0xe52afa;\n        _0x530446._0x41d886{value: _0x4d44c6}();\n        _0xed511b += _0x4d44c6;\n        emit InterestToppedUp(_0x4d44c6);\n\n        if (_0xe52afa > 0) {\n            Address._0x1b7cda(_0x407052, _0xe52afa);\n            _0x467ed7 += _0xe52afa;\n            emit FeesCollected(_0xe52afa);\n        }\n    }\n\n    function _0xa87473(uint256 _0x125a90) internal returns (uint256) {\n        if (_0x161e56._0x7c4d5e()) {\n            revert LiquidityBuffer__Paused();\n        }\n        // Get interest amount\n        uint256 _0xe3caa0 = _0xf1baf0(_0x125a90);\n\n        if (_0xe3caa0 > 0) {\n            PositionManagerConfig memory _0xa218ae = _0xd88f6e[_0x125a90];\n\n            // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n            _0xa32ae8[_0x125a90]._0x2f9abd += _0xe3caa0;\n            _0x7c5faa += _0xe3caa0;\n            _0xc731b9 += _0xe3caa0;\n            emit InterestClaimed(_0x125a90, _0xe3caa0);\n\n            // Withdraw interest from position manager AFTER state updates\n            IPositionManager _0x7d3d1c = IPositionManager(_0xa218ae._0x47f4e1);\n            _0x7d3d1c._0xbb760e(_0xe3caa0);\n        } else {\n            emit InterestClaimed(_0x125a90, _0xe3caa0);\n        }\n\n        return _0xe3caa0;\n    }\n\n    function _0x08bd4e(uint256 _0x125a90, uint256 _0x01788f) internal {\n        if (_0x161e56._0x7c4d5e()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x125a90 >= _0x17372c) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory _0xa218ae = _0xd88f6e[_0x125a90];\n        if (!_0xa218ae._0x67c8f7) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage _0x72a46d = _0xa32ae8[_0x125a90];\n\n        // Check sufficient allocation\n        if (_0x01788f > _0x72a46d._0x9bc38b) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x72a46d._0x9bc38b -= _0x01788f;\n        _0xc3d4b7 -= _0x01788f;\n        _0x45575e += _0x01788f;\n        emit ETHWithdrawnFromManager(_0x125a90, _0x01788f);\n\n        // Call position manager to withdraw AFTER state updates\n        IPositionManager _0x7d3d1c = IPositionManager(_0xa218ae._0x47f4e1);\n        _0x7d3d1c._0xbb760e(_0x01788f);\n    }\n\n    function _0x32b726(uint256 _0x01788f) internal {\n        if (_0x161e56._0x7c4d5e()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        // Validate staking contract is set and not zero address\n        if (address(_0x530446) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (_0x01788f > _0x45575e) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0xbbb561 += _0x01788f;\n        _0x45575e -= _0x01788f;\n        emit ETHReturnedToStaking(_0x01788f);\n\n        // Send ETH to trusted staking contract AFTER state updates\n        // Note: stakingContract is a trusted contract set during initialization\n        _0x530446._0x770714{value: _0x01788f}();\n    }\n\n    function _0x99b43d(uint256 _0x125a90, uint256 _0x01788f) internal {\n        if (_0x161e56._0x7c4d5e()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x01788f > _0x45575e) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (_0x125a90 >= _0x17372c) revert LiquidityBuffer__ManagerNotFound();\n        // check available balance\n        if (address(this).balance < _0x01788f) revert LiquidityBuffer__InsufficientBalance();\n\n        // check position manager is active\n        PositionManagerConfig memory _0xa218ae = _0xd88f6e[_0x125a90];\n        if (!_0xa218ae._0x67c8f7) revert LiquidityBuffer__ManagerInactive();\n        // check allocation cap\n        PositionAccountant storage _0x72a46d = _0xa32ae8[_0x125a90];\n        if (_0x72a46d._0x9bc38b + _0x01788f > _0xa218ae._0x3126b6) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x72a46d._0x9bc38b += _0x01788f;\n        _0xc3d4b7 += _0x01788f;\n        _0x45575e -= _0x01788f;\n        emit ETHAllocatedToManager(_0x125a90, _0x01788f);\n\n        // deposit to position manager AFTER state updates\n        IPositionManager _0x7d3d1c = IPositionManager(_0xa218ae._0x47f4e1);\n        _0x7d3d1c._0x7f121f{value: _0x01788f}(0);\n    }\n\n    function _0x3e05bd(uint256 _0x01788f) internal {\n        _0xae2ece += _0x01788f;\n        _0x45575e += _0x01788f;\n        emit ETHReceivedFromStaking(_0x01788f);\n    }\n\n    /// @notice Ensures that the given address is not the zero address.\n    /// @param addr The address to check.\n    modifier _0xc8a9c9(address _0x254f3d) {\n        if (_0x254f3d == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n    /// @dev Validates that the caller is the staking contract.\n    modifier _0x5733cb() {\n        if (msg.sender != address(_0x530446)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier _0x948289() {\n        bool _0xfb674c = false;\n\n        // Loop through all position manager configs to check if sender is a valid manager\n        for (uint256 i = 0; i < _0x17372c; i++) {\n            PositionManagerConfig memory _0xa218ae = _0xd88f6e[i];\n\n            if (msg.sender == _0xa218ae._0x47f4e1 && _0xa218ae._0x67c8f7) {\n                _0xfb674c = true;\n                break;\n            }\n        }\n\n        if (!_0xfb674c) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "_topUpInterestToStakingAndCollectFees": "_0xce66d3",
        "receiveReturnsFromLiquidityBuffer": "_0x770714",
        "receiveETHFromPositionManager": "_0x9d0efe",
        "onlyPositionManagerContract": "_0x948289",
        "togglePositionManagerStatus": "_0x65c333",
        "setShouldExecuteAllocation": "_0xd2b6bf",
        "interestClaimedFromManager": "_0x2f9abd",
        "_claimInterestFromManager": "_0xa87473",
        "_BASIS_POINTS_DENOMINATOR": "_0xabe5f4",
        "claimInterestFromManager": "_0x304d7f",
        "_withdrawETHFromManager": "_0x08bd4e",
        "isLiquidityBufferPaused": "_0x7c4d5e",
        "shouldExecuteAllocation": "_0x753b9f",
        "totalAllocationCapacity": "_0xa11c92",
        "positionManagerConfigs": "_0xd88f6e",
        "_receiveETHFromStaking": "_0x3e05bd",
        "withdrawETHFromManager": "_0x88ec6e",
        "topUpInterestToStaking": "_0x18a0d0",
        "totalAllocatedBalance": "_0xc3d4b7",
        "_allocateETHToManager": "_0x99b43d",
        "totalInterestToppedUp": "_0xed511b",
        "updatePositionManager": "_0x1ed670",
        "claimInterestAndTopUp": "_0x3b8b73",
        "setCumulativeDrawdown": "_0x8a289d",
        "positionManagerCount": "_0x17372c",
        "_disableInitializers": "_0xb06df2",
        "totalInterestClaimed": "_0x7c5faa",
        "allocateETHToManager": "_0x839718",
        "getControlledBalance": "_0xb834f4",
        "getUnderlyingBalance": "_0x592080",
        "getAvailableCapacity": "_0x3e90c5",
        "positionAccountants": "_0xa32ae8",
        "getAvailableBalance": "_0xf0f2da",
        "isRegisteredManager": "_0x7c8185",
        "setDefaultManagerId": "_0x8c375e",
        "_returnETHToStaking": "_0x32b726",
        "onlyStakingContract": "_0x5733cb",
        "newDefaultManagerId": "_0x5cb7d2",
        "totalFundsReceived": "_0xae2ece",
        "returnETHToStaking": "_0x538fb0",
        "totalFeesCollected": "_0x467ed7",
        "cumulativeDrawdown": "_0x48cb83",
        "totalFundsReturned": "_0xbbb561",
        "addPositionManager": "_0xcc8630",
        "withdrawAndReturn": "_0x5bdea8",
        "getInterestAmount": "_0xf1baf0",
        "setFeeBasisPoints": "_0x374063",
        "executeAllocation": "_0xb9c8aa",
        "newAllocationCap": "_0xed6297",
        "liquidityManager": "_0x155f29",
        "defaultManagerId": "_0xb62c1c",
        "pendingPrincipal": "_0x45575e",
        "allocatedBalance": "_0x9bc38b",
        "positionManager": "_0x32b6f6",
        "drawdownManager": "_0x298cfd",
        "setFeesReceiver": "_0xb13da6",
        "stakingContract": "_0x530446",
        "feesBasisPoints": "_0x6b2b8e",
        "pendingInterest": "_0xc731b9",
        "notZeroAddress": "_0xc8a9c9",
        "interestAmount": "_0xe3caa0",
        "drawdownAmount": "_0x572cf1",
        "managerBalance": "_0x4f8c3e",
        "isValidManager": "_0xfb674c",
        "managerAddress": "_0x47f4e1",
        "newBasisPoints": "_0x7f7408",
        "currentBalance": "_0x044b98",
        "interestTopUp": "_0x801a10",
        "allocationCap": "_0x3126b6",
        "totalBalance": "_0x45c1f5",
        "feesReceiver": "_0x407052",
        "topUpAmount": "_0x4d44c6",
        "initializer": "_0x65be36",
        "newReceiver": "_0xdc9a76",
        "_grantRole": "_0x2f5def",
        "accounting": "_0x72a46d",
        "depositETH": "_0x5803a3",
        "initialize": "_0x129766",
        "minAmount": "_0xba5b5d",
        "sendValue": "_0x1b7cda",
        "keccak256": "_0x84bd24",
        "managerId": "_0x125a90",
        "onlyRole": "_0x7b751d",
        "withdraw": "_0xbb760e",
        "isActive": "_0x67c8f7",
        "manager": "_0x7d3d1c",
        "deposit": "_0x7f121f",
        "staking": "_0x0cdb09",
        "mulDiv": "_0x003c07",
        "config": "_0xa218ae",
        "amount": "_0x01788f",
        "pauser": "_0x161e56",
        "encode": "_0xa1d743",
        "topUp": "_0x41d886",
        "admin": "_0xbc00b3",
        "fees": "_0xe52afa",
        "addr": "_0x254f3d",
        "init": "_0xd6e174"
      },
      "changes": [
        "Renamed 98 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_024",
      "transformed_id": "ss_l2_hex_sn_gs_024",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed _0xa1d9f6, uint256 _0x7642ae);\n    event ETHReturnedToStaking(uint256 _0x7642ae);\n    event ETHAllocatedToManager(uint256 indexed _0xa1d9f6, uint256 _0x7642ae);\n    event ETHReceivedFromStaking(uint256 _0x7642ae);\n    event FeesCollected(uint256 _0x7642ae);\n    event InterestClaimed(\n        uint256 indexed _0xa1d9f6,\n        uint256 _0x9933ae\n    );\n    event InterestToppedUp(\n        uint256 _0x7642ae\n    );\n}\n\n/**\n * @title LiquidityBuffer\n * @notice Manages liquidity allocation to various position managers for DeFi protocols\n */\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n    // ========================================= CONSTANTS =========================================\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = _0x8ef8b2(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = _0x8ef8b2(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = _0x8ef8b2(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = _0x8ef8b2(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant _0xfd58ec = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /// @notice The staking contract to which the liquidity buffer accepts funds from and returns funds to.\n    IStakingReturnsWrite public _0x4d8e5a;\n\n    /// @notice The pauser contract.\n    /// @dev Keeps the pause state across the protocol.\n    IPauserRead public _0x3996e2;\n\n    /// @notice Total number of position managers\n    uint256 public _0x04243c;\n\n    /// @notice Mapping from manager ID to position manager configuration\n    mapping(uint256 => PositionManagerConfig) public _0xb921a2;\n\n    /// @notice Mapping from manager ID to accounting information\n    mapping(uint256 => PositionAccountant) public _0x516574;\n\n    /// @notice Total funds received from staking contract\n    uint256 public _0xe2b8c7;\n\n    /// @notice Total funds returned to staking contract\n    uint256 public _0x35c7a7;\n\n    /// @notice Total allocated balance across all position managers\n    uint256 public _0xa6ea61;\n\n    /// @notice Total interest claimed from position managers\n    uint256 public _0xbf8105;\n\n    /// @notice Total interest topped up to staking contract\n    uint256 public _0xc95aa9;\n\n    /// @notice Total allocation capacity across all managers\n    uint256 public _0xfbab03;\n\n    /// @notice Cumulative drawdown amount\n    uint256 public _0x697e52;\n\n    /// @notice Default manager ID for deposit and allocation operations\n    uint256 public _0x9afe27;\n\n    /// @notice The address receiving protocol fees.\n    address payable public _0x0a4c39;\n\n    /// @notice The protocol fees in basis points (1/10000).\n    uint16 public _0xb7718b;\n\n    uint256 public _0xbd39c8;\n\n    /// @notice Tracks pending interest available for top-up operations\n    uint256 public _0x87747f;\n\n    /// @notice Tracks pending principal available for operations\n    uint256 public _0x86f130;\n\n    /// @notice Controls whether to execute allocation logic in depositETH method\n    bool public _0x1b3282;\n    /// @notice Mapping from manager address to boolean indicating if it is registered\n    mapping(address => bool) public _0x461b62;\n\n    struct Init {\n        address _0x532ec9;\n        address _0x1ff12d;\n        address _0x9d7122;\n        address _0x648072;\n        address _0x21e209;\n        address payable _0x0a4c39;\n        IStakingReturnsWrite _0xc16f40;\n        IPauserRead _0x3996e2;\n    }\n\n    // ========================================= ERRORS =========================================\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n    // ========================================= INITIALIZATION =========================================\n\n    constructor() {\n        _0x02c43f();\n    }\n\n    function _0xccb00c(Init memory _0x281fc4) external _0xdda540 {\n\n        __AccessControlEnumerable_init();\n\n        _0x9541e0(DEFAULT_ADMIN_ROLE, _0x281fc4._0x532ec9);\n        _0x9541e0(LIQUIDITY_MANAGER_ROLE, _0x281fc4._0x1ff12d);\n        _0x9541e0(POSITION_MANAGER_ROLE, _0x281fc4._0x9d7122);\n        _0x9541e0(INTEREST_TOPUP_ROLE, _0x281fc4._0x648072);\n        _0x9541e0(DRAWDOWN_MANAGER_ROLE, _0x281fc4._0x21e209);\n\n        _0x4d8e5a = _0x281fc4._0xc16f40;\n        _0x3996e2 = _0x281fc4._0x3996e2;\n        _0x0a4c39 = _0x281fc4._0x0a4c39;\n        _0x1b3282 = true;\n\n        _0x9541e0(LIQUIDITY_MANAGER_ROLE, address(_0x4d8e5a));\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    function _0xd96209(uint256 _0xa1d9f6) public view returns (uint256) {\n        PositionManagerConfig memory _0x254748 = _0xb921a2[_0xa1d9f6];\n        // Get current underlying balance from position manager\n        IPositionManager _0x5afd4a = IPositionManager(_0x254748._0x165bea);\n        uint256 _0x308158 = _0x5afd4a._0xfee02a();\n\n        // Calculate interest as: current balance - allocated balance\n        PositionAccountant memory _0xd9be2d = _0x516574[_0xa1d9f6];\n\n        if (_0x308158 > _0xd9be2d._0xad3e20) {\n            return _0x308158 - _0xd9be2d._0xad3e20;\n        }\n\n        return 0;\n    }\n\n    function _0x429ab0() public view returns (uint256) {\n        return _0xfbab03 - _0xa6ea61;\n    }\n\n    function _0x9e1352() public view returns (uint256) {\n        return _0xe2b8c7 - _0x35c7a7;\n    }\n\n    function _0x695264() public view returns (uint256) {\n        uint256 _0x3b849d = address(this).balance;\n\n        // Loop through all position manager configs and get their balances\n        // Note: This function makes external calls in a loop which can be gas-expensive\n        // Consider caching balances or using a different approach for production\n        for (uint256 i = 0; i < _0x04243c; i++) {\n            PositionManagerConfig storage _0x254748 = _0xb921a2[i];\n            if (_0x254748._0xe166a1) {\n                IPositionManager _0x5afd4a = IPositionManager(_0x254748._0x165bea);\n                uint256 _0xe7490a = _0x5afd4a._0xfee02a();\n                _0x3b849d += _0xe7490a;\n            }\n        }\n\n        return _0x3b849d;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n\n    function _0xa35db6(\n        address _0x165bea,\n        uint256 _0x3ceec9\n    ) external _0x332c69(POSITION_MANAGER_ROLE) returns (uint256 _0xa1d9f6) {\n        if (_0x461b62[_0x165bea]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        _0xa1d9f6 = _0x04243c;\n        _0x04243c++;\n\n        _0xb921a2[_0xa1d9f6] = PositionManagerConfig({\n            _0x165bea: _0x165bea,\n            _0x3ceec9: _0x3ceec9,\n            _0xe166a1: true\n        });\n        _0x516574[_0xa1d9f6] = PositionAccountant({\n            _0xad3e20: 0,\n            _0x977834: 0\n        });\n        _0x461b62[_0x165bea] = true;\n\n        _0xfbab03 += _0x3ceec9;\n        emit ProtocolConfigChanged(\n            this._0xa35db6.selector,\n            \"addPositionManager(address,uint256)\",\n            abi._0xbc7e2a(_0x165bea, _0x3ceec9)\n        );\n    }\n\n    function _0x52910f(\n        uint256 _0xa1d9f6,\n        uint256 _0x530970,\n        bool _0xe166a1\n    ) external _0x332c69(POSITION_MANAGER_ROLE) {\n        if (_0xa1d9f6 >= _0x04243c) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0x254748 = _0xb921a2[_0xa1d9f6];\n\n        if (_0x530970 < _0x516574[_0xa1d9f6]._0xad3e20) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        // Update total allocation capacity\n        _0xfbab03 = _0xfbab03 - _0x254748._0x3ceec9 + _0x530970;\n\n        _0x254748._0x3ceec9 = _0x530970;\n        _0x254748._0xe166a1 = _0xe166a1;\n\n        emit ProtocolConfigChanged(\n            this._0x52910f.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi._0xbc7e2a(_0xa1d9f6, _0x530970, _0xe166a1)\n        );\n    }\n\n    function _0xb3e4b4(uint256 _0xa1d9f6) external _0x332c69(POSITION_MANAGER_ROLE) {\n        if (_0xa1d9f6 >= _0x04243c) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0x254748 = _0xb921a2[_0xa1d9f6];\n        _0x254748._0xe166a1 = !_0x254748._0xe166a1;\n\n        emit ProtocolConfigChanged(\n            this._0xb3e4b4.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi._0xbc7e2a(_0xa1d9f6)\n        );\n    }\n\n    function _0xe5c12a(uint256 _0xefc623) external _0x332c69(DRAWDOWN_MANAGER_ROLE) {\n        _0x697e52 = _0xefc623;\n\n        emit ProtocolConfigChanged(\n            this._0xe5c12a.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi._0xbc7e2a(_0xefc623)\n        );\n    }\n\n    function _0x70970c(uint256 _0x1f24b2) external _0x332c69(POSITION_MANAGER_ROLE) {\n        if (_0x1f24b2 >= _0x04243c) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!_0xb921a2[_0x1f24b2]._0xe166a1) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        _0x9afe27 = _0x1f24b2;\n\n        emit ProtocolConfigChanged(\n            this._0x70970c.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi._0xbc7e2a(_0x1f24b2)\n        );\n    }\n\n    /// @notice Sets the fees basis points.\n    /// @param newBasisPoints The new fees basis points.\n    function _0x17c208(uint16 _0xdca10b) external _0x332c69(POSITION_MANAGER_ROLE) {\n        if (_0xdca10b > _0xfd58ec) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        _0xb7718b = _0xdca10b;\n        emit ProtocolConfigChanged(\n            this._0x17c208.selector, \"setFeeBasisPoints(uint16)\", abi._0xbc7e2a(_0xdca10b)\n        );\n    }\n\n     /// @notice Sets the fees receiver wallet for the protocol.\n    /// @param newReceiver The new fees receiver wallet.\n    function _0xb6abb8(address payable _0xa52eb9)\n        external\n        _0x332c69(POSITION_MANAGER_ROLE)\n        _0x9efee8(_0xa52eb9)\n    {\n        _0x0a4c39 = _0xa52eb9;\n        emit ProtocolConfigChanged(this._0xb6abb8.selector, \"setFeesReceiver(address)\", abi._0xbc7e2a(_0xa52eb9));\n    }\n\n    /// @notice Sets whether to execute allocation logic in depositETH method.\n    /// @param executeAllocation Whether to execute allocation logic.\n    function _0xfdfc5c(bool _0xe7ba37) external _0x332c69(POSITION_MANAGER_ROLE) {\n        _0x1b3282 = _0xe7ba37;\n        emit ProtocolConfigChanged(this._0xfdfc5c.selector, \"setShouldExecuteAllocation(bool)\", abi._0xbc7e2a(_0xe7ba37));\n    }\n\n    // ========================================= LIQUIDITY MANAGEMENT =========================================\n\n    function _0x9dc560() external payable _0x332c69(LIQUIDITY_MANAGER_ROLE) {\n        if (_0x3996e2._0xcbc9bb()) revert LiquidityBuffer__Paused();\n        _0x9ac58d(msg.value);\n        if (_0x1b3282) {\n            _0x0482ee(_0x9afe27, msg.value);\n        }\n    }\n\n    function _0x62d802(uint256 _0xa1d9f6, uint256 _0x7642ae) external _0x332c69(LIQUIDITY_MANAGER_ROLE) {\n        _0x26ece1(_0xa1d9f6, _0x7642ae);\n        _0xc23a68(_0x7642ae);\n    }\n\n    function _0x2870c8(uint256 _0xa1d9f6, uint256 _0x7642ae) external _0x332c69(LIQUIDITY_MANAGER_ROLE) {\n        _0x0482ee(_0xa1d9f6, _0x7642ae);\n    }\n\n    function _0xff009e(uint256 _0xa1d9f6, uint256 _0x7642ae) external _0x332c69(LIQUIDITY_MANAGER_ROLE) {\n        _0x26ece1(_0xa1d9f6, _0x7642ae);\n    }\n\n    function _0x9cffa7(uint256 _0x7642ae) external _0x332c69(LIQUIDITY_MANAGER_ROLE) {\n        _0xc23a68(_0x7642ae);\n    }\n\n    function _0x280195() external payable _0x2861d2 {\n        // This function receives ETH from position managers\n        // The ETH is already in the contract balance, no additional processing needed\n    }\n\n    // ========================================= INTEREST MANAGEMENT =========================================\n\n    function _0xdfc23b(uint256 _0xa1d9f6, uint256 _0x1b9643) external _0x332c69(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0x7642ae = _0xaa0bfd(_0xa1d9f6);\n        if (_0x7642ae < _0x1b9643) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return _0x7642ae;\n    }\n\n    function _0x50da36(uint256 _0x7642ae) external _0x332c69(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < _0x7642ae) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0x2aeba8(_0x7642ae);\n        return _0x7642ae;\n    }\n\n    function _0x6787d4(uint256 _0xa1d9f6, uint256 _0x1b9643) external _0x332c69(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0x7642ae = _0xaa0bfd(_0xa1d9f6);\n        if (_0x7642ae < _0x1b9643) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0x2aeba8(_0x7642ae);\n\n        return _0x7642ae;\n    }\n\n    // ========================================= INTERNAL FUNCTIONS =========================================\n\n    function _0x2aeba8(uint256 _0x7642ae) internal {\n        if (_0x3996e2._0xcbc9bb()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x7642ae > _0x87747f) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        _0x87747f -= _0x7642ae;\n        uint256 _0x50bea9 = Math._0x1ab0cd(_0xb7718b, _0x7642ae, _0xfd58ec);\n        uint256 _0x913715 = _0x7642ae - _0x50bea9;\n        _0x4d8e5a._0x3dfc24{value: _0x913715}();\n        _0xc95aa9 += _0x913715;\n        emit InterestToppedUp(_0x913715);\n\n        if (_0x50bea9 > 0) {\n            Address._0xf49b97(_0x0a4c39, _0x50bea9);\n            _0xbd39c8 += _0x50bea9;\n            emit FeesCollected(_0x50bea9);\n        }\n    }\n\n    function _0xaa0bfd(uint256 _0xa1d9f6) internal returns (uint256) {\n        if (_0x3996e2._0xcbc9bb()) {\n            revert LiquidityBuffer__Paused();\n        }\n        // Get interest amount\n        uint256 _0x9933ae = _0xd96209(_0xa1d9f6);\n\n        if (_0x9933ae > 0) {\n            PositionManagerConfig memory _0x254748 = _0xb921a2[_0xa1d9f6];\n\n            // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n            _0x516574[_0xa1d9f6]._0x977834 += _0x9933ae;\n            _0xbf8105 += _0x9933ae;\n            _0x87747f += _0x9933ae;\n            emit InterestClaimed(_0xa1d9f6, _0x9933ae);\n\n            // Withdraw interest from position manager AFTER state updates\n            IPositionManager _0x5afd4a = IPositionManager(_0x254748._0x165bea);\n            _0x5afd4a._0xc7f3a5(_0x9933ae);\n        } else {\n            emit InterestClaimed(_0xa1d9f6, _0x9933ae);\n        }\n\n        return _0x9933ae;\n    }\n\n    function _0x26ece1(uint256 _0xa1d9f6, uint256 _0x7642ae) internal {\n        if (_0x3996e2._0xcbc9bb()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0xa1d9f6 >= _0x04243c) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory _0x254748 = _0xb921a2[_0xa1d9f6];\n        if (!_0x254748._0xe166a1) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage _0xd9be2d = _0x516574[_0xa1d9f6];\n\n        // Check sufficient allocation\n        if (_0x7642ae > _0xd9be2d._0xad3e20) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0xd9be2d._0xad3e20 -= _0x7642ae;\n        _0xa6ea61 -= _0x7642ae;\n        _0x86f130 += _0x7642ae;\n        emit ETHWithdrawnFromManager(_0xa1d9f6, _0x7642ae);\n\n        // Call position manager to withdraw AFTER state updates\n        IPositionManager _0x5afd4a = IPositionManager(_0x254748._0x165bea);\n        _0x5afd4a._0xc7f3a5(_0x7642ae);\n    }\n\n    function _0xc23a68(uint256 _0x7642ae) internal {\n        if (_0x3996e2._0xcbc9bb()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        // Validate staking contract is set and not zero address\n        if (address(_0x4d8e5a) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (_0x7642ae > _0x86f130) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x35c7a7 += _0x7642ae;\n        _0x86f130 -= _0x7642ae;\n        emit ETHReturnedToStaking(_0x7642ae);\n\n        // Send ETH to trusted staking contract AFTER state updates\n        // Note: stakingContract is a trusted contract set during initialization\n        _0x4d8e5a._0x0a19f3{value: _0x7642ae}();\n    }\n\n    function _0x0482ee(uint256 _0xa1d9f6, uint256 _0x7642ae) internal {\n        if (_0x3996e2._0xcbc9bb()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x7642ae > _0x86f130) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (_0xa1d9f6 >= _0x04243c) revert LiquidityBuffer__ManagerNotFound();\n        // check available balance\n        if (address(this).balance < _0x7642ae) revert LiquidityBuffer__InsufficientBalance();\n\n        // check position manager is active\n        PositionManagerConfig memory _0x254748 = _0xb921a2[_0xa1d9f6];\n        if (!_0x254748._0xe166a1) revert LiquidityBuffer__ManagerInactive();\n        // check allocation cap\n        PositionAccountant storage _0xd9be2d = _0x516574[_0xa1d9f6];\n        if (_0xd9be2d._0xad3e20 + _0x7642ae > _0x254748._0x3ceec9) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0xd9be2d._0xad3e20 += _0x7642ae;\n        _0xa6ea61 += _0x7642ae;\n        _0x86f130 -= _0x7642ae;\n        emit ETHAllocatedToManager(_0xa1d9f6, _0x7642ae);\n\n        // deposit to position manager AFTER state updates\n        IPositionManager _0x5afd4a = IPositionManager(_0x254748._0x165bea);\n        _0x5afd4a._0x55e3c2{value: _0x7642ae}(0);\n    }\n\n    function _0x9ac58d(uint256 _0x7642ae) internal {\n        _0xe2b8c7 += _0x7642ae;\n        _0x86f130 += _0x7642ae;\n        emit ETHReceivedFromStaking(_0x7642ae);\n    }\n\n    /// @notice Ensures that the given address is not the zero address.\n    /// @param addr The address to check.\n    modifier _0x9efee8(address _0xdcca83) {\n        if (_0xdcca83 == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n    /// @dev Validates that the caller is the staking contract.\n    modifier _0xff4ee2() {\n        if (msg.sender != address(_0x4d8e5a)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier _0x2861d2() {\n        bool _0x0aab08 = false;\n\n        // Loop through all position manager configs to check if sender is a valid manager\n        for (uint256 i = 0; i < _0x04243c; i++) {\n            PositionManagerConfig memory _0x254748 = _0xb921a2[i];\n\n            if (msg.sender == _0x254748._0x165bea && _0x254748._0xe166a1) {\n                _0x0aab08 = true;\n                break;\n            }\n        }\n\n        if (!_0x0aab08) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "_topUpInterestToStakingAndCollectFees": "_0x2aeba8",
        "receiveReturnsFromLiquidityBuffer": "_0x0a19f3",
        "receiveETHFromPositionManager": "_0x280195",
        "onlyPositionManagerContract": "_0x2861d2",
        "togglePositionManagerStatus": "_0xb3e4b4",
        "setShouldExecuteAllocation": "_0xfdfc5c",
        "interestClaimedFromManager": "_0x977834",
        "_claimInterestFromManager": "_0xaa0bfd",
        "_BASIS_POINTS_DENOMINATOR": "_0xfd58ec",
        "claimInterestFromManager": "_0xdfc23b",
        "_withdrawETHFromManager": "_0x26ece1",
        "isLiquidityBufferPaused": "_0xcbc9bb",
        "shouldExecuteAllocation": "_0x1b3282",
        "totalAllocationCapacity": "_0xfbab03",
        "positionManagerConfigs": "_0xb921a2",
        "_receiveETHFromStaking": "_0x9ac58d",
        "withdrawETHFromManager": "_0xff009e",
        "topUpInterestToStaking": "_0x50da36",
        "totalAllocatedBalance": "_0xa6ea61",
        "_allocateETHToManager": "_0x0482ee",
        "totalInterestToppedUp": "_0xc95aa9",
        "updatePositionManager": "_0x52910f",
        "claimInterestAndTopUp": "_0x6787d4",
        "setCumulativeDrawdown": "_0xe5c12a",
        "positionManagerCount": "_0x04243c",
        "_disableInitializers": "_0x02c43f",
        "totalInterestClaimed": "_0xbf8105",
        "allocateETHToManager": "_0x2870c8",
        "getControlledBalance": "_0x695264",
        "getUnderlyingBalance": "_0xfee02a",
        "getAvailableCapacity": "_0x429ab0",
        "positionAccountants": "_0x516574",
        "getAvailableBalance": "_0x9e1352",
        "isRegisteredManager": "_0x461b62",
        "setDefaultManagerId": "_0x70970c",
        "_returnETHToStaking": "_0xc23a68",
        "onlyStakingContract": "_0xff4ee2",
        "newDefaultManagerId": "_0x1f24b2",
        "totalFundsReceived": "_0xe2b8c7",
        "returnETHToStaking": "_0x9cffa7",
        "totalFeesCollected": "_0xbd39c8",
        "cumulativeDrawdown": "_0x697e52",
        "totalFundsReturned": "_0x35c7a7",
        "addPositionManager": "_0xa35db6",
        "withdrawAndReturn": "_0x62d802",
        "getInterestAmount": "_0xd96209",
        "setFeeBasisPoints": "_0x17c208",
        "executeAllocation": "_0xe7ba37",
        "newAllocationCap": "_0x530970",
        "liquidityManager": "_0x1ff12d",
        "defaultManagerId": "_0x9afe27",
        "pendingPrincipal": "_0x86f130",
        "allocatedBalance": "_0xad3e20",
        "positionManager": "_0x9d7122",
        "drawdownManager": "_0x21e209",
        "setFeesReceiver": "_0xb6abb8",
        "stakingContract": "_0x4d8e5a",
        "feesBasisPoints": "_0xb7718b",
        "pendingInterest": "_0x87747f",
        "notZeroAddress": "_0x9efee8",
        "interestAmount": "_0x9933ae",
        "drawdownAmount": "_0xefc623",
        "managerBalance": "_0xe7490a",
        "isValidManager": "_0x0aab08",
        "managerAddress": "_0x165bea",
        "newBasisPoints": "_0xdca10b",
        "currentBalance": "_0x308158",
        "interestTopUp": "_0x648072",
        "allocationCap": "_0x3ceec9",
        "totalBalance": "_0x3b849d",
        "feesReceiver": "_0x0a4c39",
        "topUpAmount": "_0x913715",
        "initializer": "_0xdda540",
        "newReceiver": "_0xa52eb9",
        "_grantRole": "_0x9541e0",
        "accounting": "_0xd9be2d",
        "depositETH": "_0x9dc560",
        "initialize": "_0xccb00c",
        "minAmount": "_0x1b9643",
        "sendValue": "_0xf49b97",
        "keccak256": "_0x8ef8b2",
        "managerId": "_0xa1d9f6",
        "onlyRole": "_0x332c69",
        "withdraw": "_0xc7f3a5",
        "isActive": "_0xe166a1",
        "manager": "_0x5afd4a",
        "deposit": "_0x55e3c2",
        "staking": "_0xc16f40",
        "mulDiv": "_0x1ab0cd",
        "config": "_0x254748",
        "amount": "_0x7642ae",
        "pauser": "_0x3996e2",
        "encode": "_0xbc7e2a",
        "topUp": "_0x3dfc24",
        "admin": "_0x532ec9",
        "fees": "_0x50bea9",
        "addr": "_0xdcca83",
        "init": "_0x281fc4"
      },
      "changes": [
        "Renamed 98 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_025",
      "transformed_id": "ss_l2_hex_sn_gs_025",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed _0xfda57a, uint256 _0x99177a, uint256 _0xad66e4);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed _0xb4c52c, address indexed _0xfda57a, uint256 _0x99177a, uint256 _0x40a542);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed _0xb4c52c, address indexed _0xfda57a);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed _0xb4c52c, uint256 indexed _0xeb62b1, bytes _0x0dcc5d, uint256 _0x56a255);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 _0x33859a);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 _0x33859a);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 _0x33859a);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 _0x33859a);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 _0x33859a);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 _0x48905d, uint256 _0xc27608);\n    error UnstakeBelowMinimumETHAmount(uint256 _0x99177a, uint256 _0xc27608);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = _0x78d684(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = _0x78d684(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = _0x78d684(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = _0x78d684(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = _0x78d684(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = _0x78d684(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 _0xeb62b1;\n        uint256 _0x008961;\n        bytes _0x0dcc5d;\n        bytes _0x361db2;\n        bytes _0xc4d237;\n        bytes32 _0xd64848;\n    }\n\n    mapping(bytes _0x0dcc5d => bool _0x335315) public _0x645170;\n    uint256 public _0x3587a4;\n    uint256 public _0x1b3a50;\n    uint256 public _0xb6edc7;\n    uint256 public _0x500f1e;\n    uint256 public _0xb01a4d;\n    uint256 public _0xa04e49;\n    uint16 public _0x44309d;\n    uint16 internal constant _0x539f8a = 10_000;\n    uint16 internal constant _0x2b17ee = _0x539f8a / 10;\n    uint256 public _0x670e5f;\n    uint256 public _0xfc5921;\n    IDepositContract public _0x67a874;\n    IMETH public _0x4e1a76;\n    IOracleReadRecord public _0x80b1ac;\n    IPauserRead public _0x66761a;\n    IUnstakeRequestsManager public _0xa59f3b;\n    address public _0xe74ae5;\n    address public _0x71a7f4;\n    bool public _0x7ab509;\n    uint256 public _0x47af74;\n    uint256 public _0xa43cb0;\n    ILiquidityBuffer public _0x0bebee;\n\n    struct Init {\n        address _0x1f5117;\n        address _0x9c2bff;\n        address _0x21b2c8;\n        address _0x62f45d;\n        address _0x71a7f4;\n        address _0xe74ae5;\n        IMETH _0x4e1a76;\n        IDepositContract _0x67a874;\n        IOracleReadRecord _0x80b1ac;\n        IPauserRead _0x66761a;\n        IUnstakeRequestsManager _0xa59f3b;\n    }\n\n    constructor() {\n        _0x44e29b();\n    }\n\n    function _0x2a8b57(Init memory _0x88adbd) external _0x32643e {\n        __AccessControlEnumerable_init();\n\n        _0x104ec5(DEFAULT_ADMIN_ROLE, _0x88adbd._0x1f5117);\n        _0x104ec5(STAKING_MANAGER_ROLE, _0x88adbd._0x9c2bff);\n        _0x104ec5(ALLOCATOR_SERVICE_ROLE, _0x88adbd._0x21b2c8);\n        _0x104ec5(INITIATOR_SERVICE_ROLE, _0x88adbd._0x62f45d);\n\n        _0x94c038(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _0x94c038(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        _0x4e1a76 = _0x88adbd._0x4e1a76;\n        _0x67a874 = _0x88adbd._0x67a874;\n        _0x80b1ac = _0x88adbd._0x80b1ac;\n        _0x66761a = _0x88adbd._0x66761a;\n        _0x71a7f4 = _0x88adbd._0x71a7f4;\n        _0xa59f3b = _0x88adbd._0xa59f3b;\n        _0xe74ae5 = _0x88adbd._0xe74ae5;\n\n        _0xb01a4d = 0.1 ether;\n        _0xa04e49 = 0.01 ether;\n        _0x670e5f = 32 ether;\n        _0xfc5921 = 32 ether;\n        _0x7ab509 = true;\n        _0x47af74 = block.number;\n        _0xa43cb0 = 1024 ether;\n    }\n\n    function _0xf887ea(ILiquidityBuffer _0x24db19) public _0x0e4149(2) {\n        _0x0bebee = _0x24db19;\n    }\n\n    function _0xab2e97(uint256 _0x280101) external payable {\n        if (_0x66761a._0x912c28()) {\n            revert Paused();\n        }\n\n        if (_0x7ab509) {\n            _0x5c6a3f(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < _0xb01a4d) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 _0x20e057 = _0xbfe1c8(msg.value);\n        if (_0x20e057 + _0x4e1a76._0x09d497() > _0xa43cb0) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (_0x20e057 < _0x280101) {\n            revert StakeBelowMinimumMETHAmount(_0x20e057, _0x280101);\n        }\n\n        _0xb6edc7 += msg.value;\n\n        emit Staked(msg.sender, msg.value, _0x20e057);\n        _0x4e1a76._0xb5fbb7(msg.sender, _0x20e057);\n    }\n\n    function _0x393d53(uint128 _0x48905d, uint128 _0x7c3308) external returns (uint256) {\n        return _0xb67bd4(_0x48905d, _0x7c3308);\n    }\n\n    function _0x85ec2e(\n        uint128 _0x48905d,\n        uint128 _0x7c3308,\n        uint256 _0xbc6949,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable._0xf41cd0(_0x4e1a76, msg.sender, address(this), _0x48905d, _0xbc6949, v, r, s);\n        return _0xb67bd4(_0x48905d, _0x7c3308);\n    }\n\n    function _0xb67bd4(uint128 _0x48905d, uint128 _0x7c3308) internal returns (uint256) {\n        if (_0x66761a._0x207f1d()) {\n            revert Paused();\n        }\n\n        if (_0x48905d < _0xa04e49) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 _0x99177a = uint128(_0xd4df03(_0x48905d));\n        if (_0x99177a < _0x7c3308) {\n            revert UnstakeBelowMinimumETHAmount(_0x99177a, _0x7c3308);\n        }\n\n        uint256 _0x8b3c00 =\n            _0xa59f3b._0x0060c4({_0xae958e: msg.sender, _0x40a542: _0x48905d, _0x83e568: _0x99177a});\n        emit UnstakeRequested({_0xb4c52c: _0x8b3c00, _0xfda57a: msg.sender, _0x99177a: _0x99177a, _0x40a542: _0x48905d});\n\n        SafeERC20Upgradeable._0xf2cf9a(_0x4e1a76, msg.sender, address(_0xa59f3b), _0x48905d);\n\n        return _0x8b3c00;\n    }\n\n    function _0xbfe1c8(uint256 _0x99177a) public view returns (uint256) {\n        if (_0x4e1a76._0x09d497() == 0) {\n            return _0x99177a;\n        }\n        uint256 _0x0b981c = Math._0x2a6836(\n            _0x15b8ff(), _0x539f8a + _0x44309d, _0x539f8a\n        );\n        return Math._0x2a6836(_0x99177a, _0x4e1a76._0x09d497(), _0x0b981c);\n    }\n\n    function _0xd4df03(uint256 _0xad66e4) public view returns (uint256) {\n        if (_0x4e1a76._0x09d497() == 0) {\n            return _0xad66e4;\n        }\n        return Math._0x2a6836(_0xad66e4, _0x15b8ff(), _0x4e1a76._0x09d497());\n    }\n\n    function _0x15b8ff() public view returns (uint256) {\n        OracleRecord memory _0xf5fff7 = _0x80b1ac._0x075067();\n        uint256 _0xd87495 = 0;\n        _0xd87495 += _0xb6edc7;\n        _0xd87495 += _0x500f1e;\n        _0xd87495 += _0x3587a4 - _0xf5fff7._0xf6cb87;\n        _0xd87495 += _0xf5fff7._0x66f749;\n        _0xd87495 += _0x0bebee._0x288a2b();\n        _0xd87495 -= _0x0bebee._0x7342e8();\n        _0xd87495 += _0xa59f3b.balance();\n        return _0xd87495;\n    }\n\n    function _0x3a9bdd() external payable _0x507d3c {\n        emit ReturnsReceived(msg.value);\n        _0xb6edc7 += msg.value;\n    }\n\n    function _0xc67f40() external payable _0x83daf2 {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        _0xb6edc7 += msg.value;\n    }\n\n    modifier _0x507d3c() {\n        if (msg.sender != _0x71a7f4) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier _0x83daf2() {\n        if (msg.sender != address(_0x0bebee)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier _0x5480b5() {\n        if (msg.sender != address(_0xa59f3b)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier _0x149d27(address _0x8ba9db) {\n        if (_0x8ba9db == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "_0xc67f40",
        "cumulativeProcessedDepositAmount": "_0xf6cb87",
        "isUnstakeRequestsAndClaimsPaused": "_0x207f1d",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "_0x2b17ee",
        "currentTotalValidatorBalance": "_0x66f749",
        "onlyUnstakeRequestsManager": "_0x5480b5",
        "totalDepositedInValidators": "_0x3587a4",
        "initializationBlockNumber": "_0x47af74",
        "_BASIS_POINTS_DENOMINATOR": "_0x539f8a",
        "unstakeRequestWithPermit": "_0x85ec2e",
        "adjustedTotalControlled": "_0x0b981c",
        "allocatedETHForDeposits": "_0x500f1e",
        "exchangeAdjustmentRate": "_0x44309d",
        "unstakeRequestsManager": "_0xa59f3b",
        "numInitiatedValidators": "_0x1b3a50",
        "onlyReturnsAggregator": "_0x507d3c",
        "withdrawalCredentials": "_0x361db2",
        "_disableInitializers": "_0x44e29b",
        "minimumDepositAmount": "_0x670e5f",
        "maximumDepositAmount": "_0xfc5921",
        "getAvailableBalance": "_0x288a2b",
        "onlyLiquidityBuffer": "_0x83daf2",
        "minimumUnstakeBound": "_0xa04e49",
        "cumulativeDrawdown": "_0x7342e8",
        "isStakingAllowlist": "_0x7ab509",
        "minimumStakeBound": "_0xb01a4d",
        "maximumMETHSupply": "_0xa43cb0",
        "returnsAggregator": "_0x71a7f4",
        "safeTransferFrom": "_0xf2cf9a",
        "withdrawalWallet": "_0xe74ae5",
        "allocatorService": "_0x21b2c8",
        "initiatorService": "_0x62f45d",
        "expectedMinimum": "_0xc27608",
        "amountDeposited": "_0x56a255",
        "depositDataRoot": "_0xd64848",
        "depositContract": "_0x67a874",
        "_unstakeRequest": "_0xb67bd4",
        "liquidityBuffer": "_0x0bebee",
        "totalControlled": "_0x15b8ff",
        "isStakingPaused": "_0x912c28",
        "notZeroAddress": "_0x149d27",
        "unstakeRequest": "_0x393d53",
        "receiveReturns": "_0x3a9bdd",
        "usedValidators": "_0x645170",
        "unallocatedETH": "_0xb6edc7",
        "mETHMintAmount": "_0x20e057",
        "minMETHAmount": "_0x280101",
        "_setRoleAdmin": "_0x94c038",
        "depositAmount": "_0x008961",
        "reinitializer": "_0x0e4149",
        "initializeV2": "_0xf887ea",
        "minETHAmount": "_0x7c3308",
        "latestRecord": "_0x075067",
        "ethRequested": "_0x83e568",
        "initializer": "_0x32643e",
        "totalSupply": "_0x09d497",
        "mETHLocked": "_0x40a542",
        "_grantRole": "_0x104ec5",
        "_checkRole": "_0x5c6a3f",
        "operatorID": "_0xeb62b1",
        "safePermit": "_0xf41cd0",
        "mETHAmount": "_0xad66e4",
        "methAmount": "_0x48905d",
        "initialize": "_0x2a8b57",
        "ethAmount": "_0x99177a",
        "requestID": "_0x8b3c00",
        "requester": "_0xae958e",
        "mETHToETH": "_0xd4df03",
        "keccak256": "_0x78d684",
        "ethToMETH": "_0xbfe1c8",
        "signature": "_0xc4d237",
        "deadline": "_0xbc6949",
        "manager": "_0x9c2bff",
        "mulDiv": "_0x2a6836",
        "amount": "_0x33859a",
        "staker": "_0xfda57a",
        "create": "_0x0060c4",
        "oracle": "_0x80b1ac",
        "exists": "_0x335315",
        "pauser": "_0x66761a",
        "record": "_0xf5fff7",
        "pubkey": "_0x0dcc5d",
        "total": "_0xd87495",
        "admin": "_0x1f5117",
        "stake": "_0xab2e97",
        "addr": "_0x8ba9db",
        "mETH": "_0x4e1a76",
        "mint": "_0xb5fbb7",
        "init": "_0x88adbd",
        "id": "_0xb4c52c",
        "lb": "_0x24db19"
      },
      "changes": [
        "Renamed 91 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_026",
      "transformed_id": "ss_l2_hex_sn_gs_026",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IPool} from \"aave-v3/interfaces/IPool.sol\";\nimport {DataTypes} from \"aave-v3/protocol/libraries/types/DataTypes.sol\";\nimport {IPositionManager} from './interfaces/IPositionManager.sol';\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {ILiquidityBuffer} from \"../liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/**\n * @title PositionManager\n * @dev Position manager with role-based access control\n * inspired by WrappedTokenGatewayV3 0xd01607c3c5ecaba394d8be377a08590149325722\n */\ncontract PositionManager is Initializable, AccessControlEnumerableUpgradeable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n    // Role definitions\n    bytes32 public constant EXECUTOR_ROLE = _0xdc288e(\"EXECUTOR_ROLE\");\n    bytes32 public constant MANAGER_ROLE = _0xdc288e(\"MANAGER_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = _0xdc288e(\"EMERGENCY_ROLE\");\n\n    // State variables\n    IPool public _0x5ace4c;\n    IWETH public _0x3aaae6;\n    ILiquidityBuffer public _0xba5ed6;\n\n    /// @notice Configuration for contract initialization.\n    struct Init {\n        address _0x8bc99c;\n        address _0xb84975;\n        ILiquidityBuffer _0xba5ed6;\n        IWETH _0x3aaae6;\n        IPool _0x5ace4c;\n    }\n\n    // Events\n    event Deposit(address indexed _0x7b11f5, uint _0xee747e, uint _0x45e65c);\n    event Withdraw(address indexed _0x7b11f5, uint _0xee747e);\n    event Borrow(address indexed _0x7b11f5, uint _0xee747e, uint _0x8b0149);\n    event Repay(address indexed _0x7b11f5, uint _0xee747e, uint _0x8b0149);\n    event SetUserEMode(address indexed _0x7b11f5, uint8 _0x61deac);\n\n    constructor() {\n        _0x3fe7e5();\n    }\n\n    function _0x75d91d(Init memory _0x071d6c) external _0xb9d2cc {\n        __AccessControlEnumerable_init();\n\n        _0x3aaae6 = _0x071d6c._0x3aaae6;\n        _0x5ace4c = _0x071d6c._0x5ace4c;\n        _0xba5ed6 = _0x071d6c._0xba5ed6;\n\n        // Set up roles\n        _0xb780ce(DEFAULT_ADMIN_ROLE, _0x071d6c._0x8bc99c);\n        _0xb780ce(MANAGER_ROLE, _0x071d6c._0xb84975);\n        _0xb780ce(EXECUTOR_ROLE, address(_0x071d6c._0xba5ed6));\n\n        // Approve pool to spend WETH\n        _0x3aaae6._0x10f0b1(address(_0x5ace4c), type(uint256)._0x0b5615);\n    }\n\n    // IPositionManager Implementation\n\n    function _0x8e8e0f(uint16 _0x3baecd) external payable override _0xa9e00a(EXECUTOR_ROLE) {\n        if (msg.value > 0) {\n            // Wrap ETH to WETH\n            _0x3aaae6._0x8e8e0f{value: msg.value}();\n\n            // Deposit WETH into pool\n            _0x5ace4c._0x8e8e0f(address(_0x3aaae6), msg.value, address(this), _0x3baecd);\n\n            emit Deposit(msg.sender, msg.value, msg.value);\n        }\n    }\n\n    function _0xa0b4ff(uint256 _0xee747e) external override _0xa9e00a(EXECUTOR_ROLE) {\n        require(_0xee747e > 0, 'Invalid _0xee747e');\n\n        // Get aWETH token\n        IERC20 _0x4f48a7 = IERC20(_0x5ace4c._0x3c389c(address(_0x3aaae6)));\n        uint256 _0xb1b6c5 = _0x4f48a7._0xdc8b3e(address(this));\n\n        uint256 _0x34c04c = _0xee747e;\n        if (_0xee747e == type(uint256)._0x0b5615) {\n            _0x34c04c = _0xb1b6c5;\n        }\n\n        require(_0x34c04c <= _0xb1b6c5, 'Insufficient balance');\n\n        // Withdraw from pool\n        _0x5ace4c._0xa0b4ff(address(_0x3aaae6), _0x34c04c, address(this));\n\n        // Unwrap WETH to ETH\n        _0x3aaae6._0xa0b4ff(_0x34c04c);\n\n        // Transfer ETH to LiquidityBuffer via receiveETHFromPositionManager\n        _0xba5ed6._0xf57c97{value: _0x34c04c}();\n\n        emit Withdraw(msg.sender, _0x34c04c);\n    }\n\n    function _0x89cc10() external view returns (uint256) {\n        IERC20 _0x4f48a7 = IERC20(_0x5ace4c._0x3c389c(address(_0x3aaae6)));\n        return _0x4f48a7._0xdc8b3e(address(this));\n    }\n\n    function _0xbd27a7(uint8 _0x61deac) external override _0xa9e00a(MANAGER_ROLE) {\n        // Set user E-mode category\n        _0x5ace4c._0xbd27a7(_0x61deac);\n\n        emit SetUserEMode(msg.sender, _0x61deac);\n    }\n    function _0x8e0a81(address _0x585f8c, address _0x854122, uint256 _0x09fe71) external override _0xa9e00a(MANAGER_ROLE) {\n        IERC20(_0x585f8c)._0x414a2a(_0x854122, _0x09fe71);\n    }\n\n    function _0x6b24dc(address _0x585f8c, address _0x854122) external override _0xa9e00a(MANAGER_ROLE) {\n        IERC20(_0x585f8c)._0x414a2a(_0x854122, 0);\n    }\n\n    // Additional helper functions\n\n    function _0xecadf2() external view returns (uint256) {\n        address _0xaa8323 = _0x5ace4c._0x4151f8(address(_0x3aaae6));\n        return IERC20(_0xaa8323)._0xdc8b3e(address(this));\n    }\n\n    function _0xb4eb7d() external view returns (uint256) {\n        IERC20 _0x4f48a7 = IERC20(_0x5ace4c._0x3c389c(address(_0x3aaae6)));\n        return _0x4f48a7._0xdc8b3e(address(this));\n    }\n\n    function _0x46115b() external view returns (uint256) {\n        return _0x5ace4c._0x46115b(address(this));\n    }\n\n    function _0x32cf89(address _0x100116, bool _0xc2e5c3) external _0xa9e00a(MANAGER_ROLE) {\n        _0x5ace4c._0x32cf89(_0x100116, _0xc2e5c3);\n    }\n\n    function _0x2ae213(address _0x754cf0) external _0xa9e00a(MANAGER_ROLE) {\n        _0x89d290(EXECUTOR_ROLE, address(_0xba5ed6));\n        _0xb780ce(EXECUTOR_ROLE, _0x754cf0);\n        _0xba5ed6 = ILiquidityBuffer(_0x754cf0);\n    }\n\n    /**\n    * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n    * direct transfers to the contract address.\n    * @param token token to transfer\n    * @param to recipient of the transfer\n    * @param amount amount to send\n    */\n    function _0x467184(address _0x585f8c, address _0xb9b305, uint256 _0xee747e) external _0xa9e00a(EMERGENCY_ROLE) {\n        IERC20(_0x585f8c)._0x8c0c4e(_0xb9b305, _0xee747e);\n    }\n\n    /**\n    * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\n    * due to selfdestructs or ether transfers to the pre-computed contract address before deployment.\n    * @param to recipient of the transfer\n    * @param amount amount to send\n    */\n    function _0x23a9a2(address _0xb9b305, uint256 _0xee747e) external _0xa9e00a(EMERGENCY_ROLE) {\n        _0x8c5af8(_0xb9b305, _0xee747e);\n    }\n\n    /**\n     * @dev transfer ETH to an address, revert if it fails.\n     * @param to recipient of the transfer\n     * @param value the amount to send\n     */\n    function _0x8c5af8(address _0xb9b305, uint256 value) internal {\n        (bool _0x4162ab, ) = _0xb9b305.call{value: value}(new bytes(0));\n        require(_0x4162ab, 'ETH_TRANSFER_FAILED');\n    }\n\n    /**\n    * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n    */\n    receive() external payable {\n        require(msg.sender == address(_0x3aaae6), 'Receive not allowed');\n    }\n\n    /**\n    * @dev Revert fallback calls\n    */\n    fallback() external payable {\n        revert('Fallback not allowed');\n    }\n}",
      "rename_map": {
        "receiveETHFromPositionManager": "_0xf57c97",
        "setUserUseReserveAsCollateral": "_0x32cf89",
        "getReserveVariableDebtToken": "_0x4151f8",
        "emergencyEtherTransfer": "_0x23a9a2",
        "emergencyTokenTransfer": "_0x467184",
        "_disableInitializers": "_0x3fe7e5",
        "getUnderlyingBalance": "_0x89cc10",
        "getCollateralBalance": "_0xb4eb7d",
        "setLiquidityBuffer": "_0x2ae213",
        "amountToWithdraw": "_0x34c04c",
        "getReserveAToken": "_0x3c389c",
        "_liquidityBuffer": "_0x754cf0",
        "_safeTransferETH": "_0x8c5af8",
        "getBorrowBalance": "_0xecadf2",
        "liquidityBuffer": "_0xba5ed6",
        "useAsCollateral": "_0xc2e5c3",
        "getUserEMode": "_0x46115b",
        "safeTransfer": "_0x8c0c4e",
        "setUserEMode": "_0xbd27a7",
        "referralCode": "_0x3baecd",
        "approveToken": "_0x8e0a81",
        "aTokenAmount": "_0x45e65c",
        "userBalance": "_0xb1b6c5",
        "initializer": "_0xb9d2cc",
        "safeApprove": "_0x414a2a",
        "revokeToken": "_0x6b24dc",
        "_revokeRole": "_0x89d290",
        "_grantRole": "_0xb780ce",
        "initialize": "_0x75d91d",
        "categoryId": "_0x61deac",
        "balanceOf": "_0xdc8b3e",
        "debtToken": "_0xaa8323",
        "keccak256": "_0xdc288e",
        "onlyRole": "_0xa9e00a",
        "withdraw": "_0xa0b4ff",
        "rateMode": "_0x8b0149",
        "success": "_0x4162ab",
        "approve": "_0x10f0b1",
        "deposit": "_0x8e8e0f",
        "manager": "_0xb84975",
        "caller": "_0x7b11f5",
        "amount": "_0xee747e",
        "admin": "_0x8bc99c",
        "asset": "_0x100116",
        "aWETH": "_0x4f48a7",
        "token": "_0x585f8c",
        "init": "_0x071d6c",
        "weth": "_0x3aaae6",
        "addr": "_0x854122",
        "pool": "_0x5ace4c",
        "wad": "_0x09fe71",
        "max": "_0x0b5615",
        "to": "_0xb9b305"
      },
      "changes": [
        "Renamed 53 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_027",
      "transformed_id": "ss_l2_hex_sn_gs_027",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed _0xb34323, uint256 _0x3f9d54, uint256 _0xe7ed00);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed _0xce7b0c, address indexed _0xb34323, uint256 _0x3f9d54, uint256 _0xcb2a2a);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed _0xce7b0c, address indexed _0xb34323);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed _0xce7b0c, uint256 indexed _0xc31be8, bytes _0x28e2b0, uint256 _0x2359f6);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 _0xb687a1);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 _0xb687a1);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 _0xb687a1);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 _0xb687a1);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 _0xb687a1);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 _0xedce5e, uint256 _0xe3c0e2);\n    error UnstakeBelowMinimumETHAmount(uint256 _0x3f9d54, uint256 _0xe3c0e2);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = _0x0525ea(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = _0x0525ea(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = _0x0525ea(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = _0x0525ea(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = _0x0525ea(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = _0x0525ea(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 _0xc31be8;\n        uint256 _0x7df69f;\n        bytes _0x28e2b0;\n        bytes _0x21b8e8;\n        bytes _0x530436;\n        bytes32 _0x11cbcb;\n    }\n\n    mapping(bytes _0x28e2b0 => bool _0x2ac226) public _0x4959e4;\n    uint256 public _0x7e797b;\n    uint256 public _0x1f3129;\n    uint256 public _0xfca343;\n    uint256 public _0x77454d;\n    uint256 public _0x5094ed;\n    uint256 public _0x054b05;\n    uint16 public _0xd1b01f;\n    uint16 internal constant _0xad3294 = 10_000;\n    uint16 internal constant _0x25fc27 = _0xad3294 / 10;\n    uint256 public _0x5cad8e;\n    uint256 public _0x4ab7b0;\n    IDepositContract public _0x064941;\n    IMETH public _0x307d8a;\n    IOracleReadRecord public _0xc01a34;\n    IPauserRead public _0x68eda1;\n    IUnstakeRequestsManager public _0x9451b9;\n    address public _0xe83969;\n    address public _0x6b80eb;\n    bool public _0x462014;\n    uint256 public _0x11f274;\n    uint256 public _0x55ffb7;\n    ILiquidityBuffer public _0xf6ec6b;\n\n    struct Init {\n        address _0x96fc16;\n        address _0x2bad16;\n        address _0x4ebbac;\n        address _0x4c8e53;\n        address _0x6b80eb;\n        address _0xe83969;\n        IMETH _0x307d8a;\n        IDepositContract _0x064941;\n        IOracleReadRecord _0xc01a34;\n        IPauserRead _0x68eda1;\n        IUnstakeRequestsManager _0x9451b9;\n    }\n\n    constructor() {\n        _0x03b88d();\n    }\n\n    function _0xa9e5e7(Init memory _0x665ff9) external _0x73a9fd {\n        __AccessControlEnumerable_init();\n\n        _0xb23122(DEFAULT_ADMIN_ROLE, _0x665ff9._0x96fc16);\n        _0xb23122(STAKING_MANAGER_ROLE, _0x665ff9._0x2bad16);\n        _0xb23122(ALLOCATOR_SERVICE_ROLE, _0x665ff9._0x4ebbac);\n        _0xb23122(INITIATOR_SERVICE_ROLE, _0x665ff9._0x4c8e53);\n\n        _0x03165b(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _0x03165b(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        _0x307d8a = _0x665ff9._0x307d8a;\n        _0x064941 = _0x665ff9._0x064941;\n        _0xc01a34 = _0x665ff9._0xc01a34;\n        _0x68eda1 = _0x665ff9._0x68eda1;\n        _0x6b80eb = _0x665ff9._0x6b80eb;\n        _0x9451b9 = _0x665ff9._0x9451b9;\n        _0xe83969 = _0x665ff9._0xe83969;\n\n        _0x5094ed = 0.1 ether;\n        _0x054b05 = 0.01 ether;\n        _0x5cad8e = 32 ether;\n        _0x4ab7b0 = 32 ether;\n        _0x462014 = true;\n        _0x11f274 = block.number;\n        _0x55ffb7 = 1024 ether;\n    }\n\n    function _0x415a8a(ILiquidityBuffer _0x0abcc5) public _0x308c73(2) {\n        _0xf6ec6b = _0x0abcc5;\n    }\n\n    function _0x1f1d93(uint256 _0x6eb0aa) external payable {\n        if (_0x68eda1._0x5edcec()) {\n            revert Paused();\n        }\n\n        if (_0x462014) {\n            _0xc2a0fd(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < _0x5094ed) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 _0x7f91eb = _0x58d7dd(msg.value);\n        if (_0x7f91eb + _0x307d8a._0xff89fb() > _0x55ffb7) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (_0x7f91eb < _0x6eb0aa) {\n            revert StakeBelowMinimumMETHAmount(_0x7f91eb, _0x6eb0aa);\n        }\n\n        _0xfca343 += msg.value;\n\n        emit Staked(msg.sender, msg.value, _0x7f91eb);\n        _0x307d8a._0x89b3ff(msg.sender, _0x7f91eb);\n    }\n\n    function _0x137479(uint128 _0xedce5e, uint128 _0x546011) external returns (uint256) {\n        return _0xe61a23(_0xedce5e, _0x546011);\n    }\n\n    function _0xc8be2f(\n        uint128 _0xedce5e,\n        uint128 _0x546011,\n        uint256 _0xcaea3e,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable._0x65c6f8(_0x307d8a, msg.sender, address(this), _0xedce5e, _0xcaea3e, v, r, s);\n        return _0xe61a23(_0xedce5e, _0x546011);\n    }\n\n    function _0xe61a23(uint128 _0xedce5e, uint128 _0x546011) internal returns (uint256) {\n        if (_0x68eda1._0x226767()) {\n            revert Paused();\n        }\n\n        if (_0xedce5e < _0x054b05) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 _0x3f9d54 = uint128(_0x1d5b3c(_0xedce5e));\n        if (_0x3f9d54 < _0x546011) {\n            revert UnstakeBelowMinimumETHAmount(_0x3f9d54, _0x546011);\n        }\n\n        uint256 _0x555f5f =\n            _0x9451b9._0x1ea531({_0xe152a1: msg.sender, _0xcb2a2a: _0xedce5e, _0x2c8217: _0x3f9d54});\n        emit UnstakeRequested({_0xce7b0c: _0x555f5f, _0xb34323: msg.sender, _0x3f9d54: _0x3f9d54, _0xcb2a2a: _0xedce5e});\n\n        SafeERC20Upgradeable._0x7f14ac(_0x307d8a, msg.sender, address(_0x9451b9), _0xedce5e);\n\n        return _0x555f5f;\n    }\n\n    function _0x58d7dd(uint256 _0x3f9d54) public view returns (uint256) {\n        if (_0x307d8a._0xff89fb() == 0) {\n            return _0x3f9d54;\n        }\n        uint256 _0xd8a597 = Math._0xba1804(\n            _0xb696e3(), _0xad3294 + _0xd1b01f, _0xad3294\n        );\n        return Math._0xba1804(_0x3f9d54, _0x307d8a._0xff89fb(), _0xd8a597);\n    }\n\n    function _0x1d5b3c(uint256 _0xe7ed00) public view returns (uint256) {\n        if (_0x307d8a._0xff89fb() == 0) {\n            return _0xe7ed00;\n        }\n        return Math._0xba1804(_0xe7ed00, _0xb696e3(), _0x307d8a._0xff89fb());\n    }\n\n    function _0xb696e3() public view returns (uint256) {\n        OracleRecord memory _0x942a1a = _0xc01a34._0x9f88b7();\n        uint256 _0xda088e = 0;\n        _0xda088e += _0xfca343;\n        _0xda088e += _0x77454d;\n        _0xda088e += _0x7e797b - _0x942a1a._0x322069;\n        _0xda088e += _0x942a1a._0xba3a97;\n        _0xda088e += _0xf6ec6b._0x952361();\n        _0xda088e -= _0xf6ec6b._0x4587d5();\n        _0xda088e += _0x9451b9.balance();\n        return _0xda088e;\n    }\n\n    function _0x11f931() external payable _0x081299 {\n        emit ReturnsReceived(msg.value);\n        _0xfca343 += msg.value;\n    }\n\n    function _0x7cb5f0() external payable _0x542716 {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        _0xfca343 += msg.value;\n    }\n\n    modifier _0x081299() {\n        if (msg.sender != _0x6b80eb) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier _0x542716() {\n        if (msg.sender != address(_0xf6ec6b)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier _0x185ca2() {\n        if (msg.sender != address(_0x9451b9)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier _0xef109a(address _0x8e58a2) {\n        if (_0x8e58a2 == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "_0x7cb5f0",
        "cumulativeProcessedDepositAmount": "_0x322069",
        "isUnstakeRequestsAndClaimsPaused": "_0x226767",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "_0x25fc27",
        "currentTotalValidatorBalance": "_0xba3a97",
        "onlyUnstakeRequestsManager": "_0x185ca2",
        "totalDepositedInValidators": "_0x7e797b",
        "initializationBlockNumber": "_0x11f274",
        "_BASIS_POINTS_DENOMINATOR": "_0xad3294",
        "unstakeRequestWithPermit": "_0xc8be2f",
        "adjustedTotalControlled": "_0xd8a597",
        "allocatedETHForDeposits": "_0x77454d",
        "exchangeAdjustmentRate": "_0xd1b01f",
        "unstakeRequestsManager": "_0x9451b9",
        "numInitiatedValidators": "_0x1f3129",
        "onlyReturnsAggregator": "_0x081299",
        "withdrawalCredentials": "_0x21b8e8",
        "_disableInitializers": "_0x03b88d",
        "minimumDepositAmount": "_0x5cad8e",
        "maximumDepositAmount": "_0x4ab7b0",
        "getAvailableBalance": "_0x952361",
        "onlyLiquidityBuffer": "_0x542716",
        "minimumUnstakeBound": "_0x054b05",
        "cumulativeDrawdown": "_0x4587d5",
        "isStakingAllowlist": "_0x462014",
        "minimumStakeBound": "_0x5094ed",
        "maximumMETHSupply": "_0x55ffb7",
        "returnsAggregator": "_0x6b80eb",
        "safeTransferFrom": "_0x7f14ac",
        "withdrawalWallet": "_0xe83969",
        "allocatorService": "_0x4ebbac",
        "initiatorService": "_0x4c8e53",
        "expectedMinimum": "_0xe3c0e2",
        "amountDeposited": "_0x2359f6",
        "depositDataRoot": "_0x11cbcb",
        "depositContract": "_0x064941",
        "_unstakeRequest": "_0xe61a23",
        "liquidityBuffer": "_0xf6ec6b",
        "totalControlled": "_0xb696e3",
        "isStakingPaused": "_0x5edcec",
        "notZeroAddress": "_0xef109a",
        "unstakeRequest": "_0x137479",
        "receiveReturns": "_0x11f931",
        "usedValidators": "_0x4959e4",
        "unallocatedETH": "_0xfca343",
        "mETHMintAmount": "_0x7f91eb",
        "minMETHAmount": "_0x6eb0aa",
        "_setRoleAdmin": "_0x03165b",
        "depositAmount": "_0x7df69f",
        "reinitializer": "_0x308c73",
        "initializeV2": "_0x415a8a",
        "minETHAmount": "_0x546011",
        "latestRecord": "_0x9f88b7",
        "ethRequested": "_0x2c8217",
        "initializer": "_0x73a9fd",
        "totalSupply": "_0xff89fb",
        "mETHLocked": "_0xcb2a2a",
        "_grantRole": "_0xb23122",
        "_checkRole": "_0xc2a0fd",
        "operatorID": "_0xc31be8",
        "safePermit": "_0x65c6f8",
        "mETHAmount": "_0xe7ed00",
        "methAmount": "_0xedce5e",
        "initialize": "_0xa9e5e7",
        "ethAmount": "_0x3f9d54",
        "requestID": "_0x555f5f",
        "requester": "_0xe152a1",
        "mETHToETH": "_0x1d5b3c",
        "keccak256": "_0x0525ea",
        "ethToMETH": "_0x58d7dd",
        "signature": "_0x530436",
        "deadline": "_0xcaea3e",
        "manager": "_0x2bad16",
        "mulDiv": "_0xba1804",
        "amount": "_0xb687a1",
        "staker": "_0xb34323",
        "create": "_0x1ea531",
        "oracle": "_0xc01a34",
        "exists": "_0x2ac226",
        "pauser": "_0x68eda1",
        "record": "_0x942a1a",
        "pubkey": "_0x28e2b0",
        "total": "_0xda088e",
        "admin": "_0x96fc16",
        "stake": "_0x1f1d93",
        "addr": "_0x8e58a2",
        "mETH": "_0x307d8a",
        "mint": "_0x89b3ff",
        "init": "_0x665ff9",
        "id": "_0xce7b0c",
        "lb": "_0x0abcc5"
      },
      "changes": [
        "Renamed 91 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_028",
      "transformed_id": "ss_l2_hex_sn_gs_028",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed _0x839a24, uint256 _0xe9899d, uint256 _0x008b3e);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed _0xe62b08, address indexed _0x839a24, uint256 _0xe9899d, uint256 _0xa7799e);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed _0xe62b08, address indexed _0x839a24);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed _0xe62b08, uint256 indexed _0x0d486d, bytes _0x848600, uint256 _0xd127b0);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 _0x049fc9);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 _0x049fc9);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 _0x049fc9);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 _0x049fc9);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 _0x049fc9);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 _0x0e5bbd, uint256 _0x9ae417);\n    error UnstakeBelowMinimumETHAmount(uint256 _0xe9899d, uint256 _0x9ae417);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = _0xb6e251(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = _0xb6e251(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = _0xb6e251(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = _0xb6e251(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = _0xb6e251(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = _0xb6e251(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 _0x0d486d;\n        uint256 _0xc6d17a;\n        bytes _0x848600;\n        bytes _0x35e718;\n        bytes _0x7473fe;\n        bytes32 _0xc3f66e;\n    }\n\n    mapping(bytes _0x848600 => bool _0xd0563e) public _0xea92c9;\n    uint256 public _0x757e81;\n    uint256 public _0x4ef952;\n    uint256 public _0x81bfef;\n    uint256 public _0xeeff52;\n    uint256 public _0xa05967;\n    uint256 public _0xdde84c;\n    uint16 public _0x40b219;\n    uint16 internal constant _0x59a9ff = 10_000;\n    uint16 internal constant _0xd1b9e3 = _0x59a9ff / 10;\n    uint256 public _0x4619a0;\n    uint256 public _0x8b8f24;\n    IDepositContract public _0x01ebdc;\n    IMETH public _0xda536d;\n    IOracleReadRecord public _0xee46e5;\n    IPauserRead public _0xb58ab2;\n    IUnstakeRequestsManager public _0x8c61b3;\n    address public _0x341b0d;\n    address public _0x71c2df;\n    bool public _0xf8acfe;\n    uint256 public _0xb70f7d;\n    uint256 public _0x3d4207;\n    ILiquidityBuffer public _0x810284;\n\n    struct Init {\n        address _0x64b136;\n        address _0x6955e4;\n        address _0x259ceb;\n        address _0x6803c4;\n        address _0x71c2df;\n        address _0x341b0d;\n        IMETH _0xda536d;\n        IDepositContract _0x01ebdc;\n        IOracleReadRecord _0xee46e5;\n        IPauserRead _0xb58ab2;\n        IUnstakeRequestsManager _0x8c61b3;\n    }\n\n    constructor() {\n        _0x02afad();\n    }\n\n    function _0xd3045a(Init memory _0x6c6330) external _0x22d274 {\n        __AccessControlEnumerable_init();\n\n        _0xad12da(DEFAULT_ADMIN_ROLE, _0x6c6330._0x64b136);\n        _0xad12da(STAKING_MANAGER_ROLE, _0x6c6330._0x6955e4);\n        _0xad12da(ALLOCATOR_SERVICE_ROLE, _0x6c6330._0x259ceb);\n        _0xad12da(INITIATOR_SERVICE_ROLE, _0x6c6330._0x6803c4);\n\n        _0xd0dbf1(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _0xd0dbf1(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        _0xda536d = _0x6c6330._0xda536d;\n        _0x01ebdc = _0x6c6330._0x01ebdc;\n        _0xee46e5 = _0x6c6330._0xee46e5;\n        _0xb58ab2 = _0x6c6330._0xb58ab2;\n        _0x71c2df = _0x6c6330._0x71c2df;\n        _0x8c61b3 = _0x6c6330._0x8c61b3;\n        _0x341b0d = _0x6c6330._0x341b0d;\n\n        _0xa05967 = 0.1 ether;\n        _0xdde84c = 0.01 ether;\n        _0x4619a0 = 32 ether;\n        _0x8b8f24 = 32 ether;\n        _0xf8acfe = true;\n        _0xb70f7d = block.number;\n        _0x3d4207 = 1024 ether;\n    }\n\n    function _0x5996df(ILiquidityBuffer _0x8723ea) public _0xcea592(2) {\n        _0x810284 = _0x8723ea;\n    }\n\n    function _0x79a344(uint256 _0x499b0a) external payable {\n        if (_0xb58ab2._0x677f02()) {\n            revert Paused();\n        }\n\n        if (_0xf8acfe) {\n            _0x46a399(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < _0xa05967) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 _0x1504fc = _0x927416(msg.value);\n        if (_0x1504fc + _0xda536d._0x8ea752() > _0x3d4207) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (_0x1504fc < _0x499b0a) {\n            revert StakeBelowMinimumMETHAmount(_0x1504fc, _0x499b0a);\n        }\n\n        _0x81bfef += msg.value;\n\n        emit Staked(msg.sender, msg.value, _0x1504fc);\n        _0xda536d._0x1b46a0(msg.sender, _0x1504fc);\n    }\n\n    function _0x5d35de(uint128 _0x0e5bbd, uint128 _0x1de5e4) external returns (uint256) {\n        return _0x6dd254(_0x0e5bbd, _0x1de5e4);\n    }\n\n    function _0x8cad97(\n        uint128 _0x0e5bbd,\n        uint128 _0x1de5e4,\n        uint256 _0xb709e8,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable._0xcdcae8(_0xda536d, msg.sender, address(this), _0x0e5bbd, _0xb709e8, v, r, s);\n        return _0x6dd254(_0x0e5bbd, _0x1de5e4);\n    }\n\n    function _0x6dd254(uint128 _0x0e5bbd, uint128 _0x1de5e4) internal returns (uint256) {\n        if (_0xb58ab2._0xc01798()) {\n            revert Paused();\n        }\n\n        if (_0x0e5bbd < _0xdde84c) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 _0xe9899d = uint128(_0x3d97ad(_0x0e5bbd));\n        if (_0xe9899d < _0x1de5e4) {\n            revert UnstakeBelowMinimumETHAmount(_0xe9899d, _0x1de5e4);\n        }\n\n        uint256 _0xe44e0f =\n            _0x8c61b3._0x5f486f({_0x23c72f: msg.sender, _0xa7799e: _0x0e5bbd, _0x98bad2: _0xe9899d});\n        emit UnstakeRequested({_0xe62b08: _0xe44e0f, _0x839a24: msg.sender, _0xe9899d: _0xe9899d, _0xa7799e: _0x0e5bbd});\n\n        SafeERC20Upgradeable._0xabfcdc(_0xda536d, msg.sender, address(_0x8c61b3), _0x0e5bbd);\n\n        return _0xe44e0f;\n    }\n\n    function _0x927416(uint256 _0xe9899d) public view returns (uint256) {\n        if (_0xda536d._0x8ea752() == 0) {\n            return _0xe9899d;\n        }\n        uint256 _0xfac2d0 = Math._0xee1eb6(\n            _0x990eb7(), _0x59a9ff + _0x40b219, _0x59a9ff\n        );\n        return Math._0xee1eb6(_0xe9899d, _0xda536d._0x8ea752(), _0xfac2d0);\n    }\n\n    function _0x3d97ad(uint256 _0x008b3e) public view returns (uint256) {\n        if (_0xda536d._0x8ea752() == 0) {\n            return _0x008b3e;\n        }\n        return Math._0xee1eb6(_0x008b3e, _0x990eb7(), _0xda536d._0x8ea752());\n    }\n\n    function _0x990eb7() public view returns (uint256) {\n        OracleRecord memory _0x81d68b = _0xee46e5._0x04f469();\n        uint256 _0xd14b20 = 0;\n        _0xd14b20 += _0x81bfef;\n        _0xd14b20 += _0xeeff52;\n        _0xd14b20 += _0x757e81 - _0x81d68b._0x95713a;\n        _0xd14b20 += _0x81d68b._0x2f06d9;\n        _0xd14b20 += _0x810284._0x5676ae();\n        _0xd14b20 -= _0x810284._0x78be08();\n        _0xd14b20 += _0x8c61b3.balance();\n        return _0xd14b20;\n    }\n\n    function _0x8be70a() external payable _0xfcde53 {\n        emit ReturnsReceived(msg.value);\n        _0x81bfef += msg.value;\n    }\n\n    function _0xad615a() external payable _0x52defb {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        _0x81bfef += msg.value;\n    }\n\n    modifier _0xfcde53() {\n        if (msg.sender != _0x71c2df) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier _0x52defb() {\n        if (msg.sender != address(_0x810284)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier _0xe59d04() {\n        if (msg.sender != address(_0x8c61b3)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier _0x477df2(address _0x3e2456) {\n        if (_0x3e2456 == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "_0xad615a",
        "cumulativeProcessedDepositAmount": "_0x95713a",
        "isUnstakeRequestsAndClaimsPaused": "_0xc01798",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "_0xd1b9e3",
        "currentTotalValidatorBalance": "_0x2f06d9",
        "onlyUnstakeRequestsManager": "_0xe59d04",
        "totalDepositedInValidators": "_0x757e81",
        "initializationBlockNumber": "_0xb70f7d",
        "_BASIS_POINTS_DENOMINATOR": "_0x59a9ff",
        "unstakeRequestWithPermit": "_0x8cad97",
        "adjustedTotalControlled": "_0xfac2d0",
        "allocatedETHForDeposits": "_0xeeff52",
        "exchangeAdjustmentRate": "_0x40b219",
        "unstakeRequestsManager": "_0x8c61b3",
        "numInitiatedValidators": "_0x4ef952",
        "onlyReturnsAggregator": "_0xfcde53",
        "withdrawalCredentials": "_0x35e718",
        "_disableInitializers": "_0x02afad",
        "minimumDepositAmount": "_0x4619a0",
        "maximumDepositAmount": "_0x8b8f24",
        "getAvailableBalance": "_0x5676ae",
        "onlyLiquidityBuffer": "_0x52defb",
        "minimumUnstakeBound": "_0xdde84c",
        "cumulativeDrawdown": "_0x78be08",
        "isStakingAllowlist": "_0xf8acfe",
        "minimumStakeBound": "_0xa05967",
        "maximumMETHSupply": "_0x3d4207",
        "returnsAggregator": "_0x71c2df",
        "safeTransferFrom": "_0xabfcdc",
        "withdrawalWallet": "_0x341b0d",
        "allocatorService": "_0x259ceb",
        "initiatorService": "_0x6803c4",
        "expectedMinimum": "_0x9ae417",
        "amountDeposited": "_0xd127b0",
        "depositDataRoot": "_0xc3f66e",
        "depositContract": "_0x01ebdc",
        "_unstakeRequest": "_0x6dd254",
        "liquidityBuffer": "_0x810284",
        "totalControlled": "_0x990eb7",
        "isStakingPaused": "_0x677f02",
        "notZeroAddress": "_0x477df2",
        "unstakeRequest": "_0x5d35de",
        "receiveReturns": "_0x8be70a",
        "usedValidators": "_0xea92c9",
        "unallocatedETH": "_0x81bfef",
        "mETHMintAmount": "_0x1504fc",
        "minMETHAmount": "_0x499b0a",
        "_setRoleAdmin": "_0xd0dbf1",
        "depositAmount": "_0xc6d17a",
        "reinitializer": "_0xcea592",
        "initializeV2": "_0x5996df",
        "minETHAmount": "_0x1de5e4",
        "latestRecord": "_0x04f469",
        "ethRequested": "_0x98bad2",
        "initializer": "_0x22d274",
        "totalSupply": "_0x8ea752",
        "mETHLocked": "_0xa7799e",
        "_grantRole": "_0xad12da",
        "_checkRole": "_0x46a399",
        "operatorID": "_0x0d486d",
        "safePermit": "_0xcdcae8",
        "mETHAmount": "_0x008b3e",
        "methAmount": "_0x0e5bbd",
        "initialize": "_0xd3045a",
        "ethAmount": "_0xe9899d",
        "requestID": "_0xe44e0f",
        "requester": "_0x23c72f",
        "mETHToETH": "_0x3d97ad",
        "keccak256": "_0xb6e251",
        "ethToMETH": "_0x927416",
        "signature": "_0x7473fe",
        "deadline": "_0xb709e8",
        "manager": "_0x6955e4",
        "mulDiv": "_0xee1eb6",
        "amount": "_0x049fc9",
        "staker": "_0x839a24",
        "create": "_0x5f486f",
        "oracle": "_0xee46e5",
        "exists": "_0xd0563e",
        "pauser": "_0xb58ab2",
        "record": "_0x81d68b",
        "pubkey": "_0x848600",
        "total": "_0xd14b20",
        "admin": "_0x64b136",
        "stake": "_0x79a344",
        "addr": "_0x3e2456",
        "mETH": "_0xda536d",
        "mint": "_0x1b46a0",
        "init": "_0x6c6330",
        "id": "_0xe62b08",
        "lb": "_0x8723ea"
      },
      "changes": [
        "Renamed 91 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_029",
      "transformed_id": "ss_l2_hex_sn_gs_029",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { Payload } from \"../Payload.sol\";\n\nimport { ICheckpointer, Snapshot } from \"../interfaces/ICheckpointer.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\nimport { ISapient, ISapientCompact } from \"../interfaces/ISapient.sol\";\n\nusing LibBytes for bytes;\nusing Payload for Payload.Decoded;\n\n/// @title BaseSig\n/// @author Agustin Aguilar, Michael Standen, William Hua, Shun Kakinoki\n/// @notice Library for recovering signatures from the base-auth payload\nlibrary BaseSig {\n\n  uint256 internal constant FLAG_SIGNATURE_HASH = 0;\n  uint256 internal constant FLAG_ADDRESS = 1;\n  uint256 internal constant FLAG_SIGNATURE_ERC1271 = 2;\n  uint256 internal constant FLAG_NODE = 3;\n  uint256 internal constant FLAG_BRANCH = 4;\n  uint256 internal constant FLAG_SUBDIGEST = 5;\n  uint256 internal constant FLAG_NESTED = 6;\n  uint256 internal constant FLAG_SIGNATURE_ETH_SIGN = 7;\n  uint256 internal constant FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST = 8;\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT = 9;\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT_COMPACT = 10;\n\n  /// @notice Error thrown when the weight is too low for a chained signature\n  error LowWeightChainedSignature(bytes _0x84ef49, uint256 _0xcfc988, uint256 _0x1a6d5d);\n  /// @notice Error thrown when the ERC1271 signature is invalid\n  error InvalidERC1271Signature(bytes32 _0x142400, address _0xc6baa0, bytes _0x84ef49);\n  /// @notice Error thrown when the checkpoint order is wrong\n  error WrongChainedCheckpointOrder(uint256 _0xe381f6, uint256 _0xf069ee);\n  /// @notice Error thrown when the snapshot is unused\n  error UnusedSnapshot(Snapshot _0x375c95);\n  /// @notice Error thrown when the signature flag is invalid\n  error InvalidSignatureFlag(uint256 _0x076740);\n\n  function _0x65b714(address _0xccfa91, uint256 _0x1a6d5d) internal pure returns (bytes32) {\n    return _0x8c2ba0(abi._0x3ae912(\"Sequence signer:\\n\", _0xccfa91, _0x1a6d5d));\n  }\n\n  function _0xa3ba61(bytes32 _0x1d59ac, uint256 _0xcfc988, uint256 _0x1a6d5d) internal pure returns (bytes32) {\n    return _0x8c2ba0(abi._0x3ae912(\"Sequence nested config:\\n\", _0x1d59ac, _0xcfc988, _0x1a6d5d));\n  }\n\n  function _0xa6c070(address _0xccfa91, uint256 _0x1a6d5d, bytes32 _0x4bb176) internal pure returns (bytes32) {\n    return _0x8c2ba0(abi._0x3ae912(\"Sequence sapient config:\\n\", _0xccfa91, _0x1a6d5d, _0x4bb176));\n  }\n\n  function _0x29b611(\n    bytes32 _0xe85298\n  ) internal pure returns (bytes32) {\n    return _0x8c2ba0(abi._0x3ae912(\"Sequence static digest:\\n\", _0xe85298));\n  }\n\n  function _0x4ce428(\n    bytes32 _0x5418bf\n  ) internal pure returns (bytes32) {\n    return _0x8c2ba0(abi._0x3ae912(\"Sequence any address subdigest:\\n\", _0x5418bf));\n  }\n\n  function _0x611dd8(\n    Payload.Decoded memory _0x9f9bac,\n    bytes calldata _0x84ef49,\n    bool _0xa34e79,\n    address _0xee1794\n  ) internal view returns (uint256 _0xf24369, uint256 _0xef013e, bytes32 _0xdd0192, uint256 _0x88a863, bytes32 _0x732a7d) {\n    // First byte is the signature flag\n    (uint256 _0x006900, uint256 _0xedd6a2) = _0x84ef49._0x0984ae();\n\n    // The possible flags are:\n    // - 0000 00XX (bits [1..0]): signature type (00 = normal, 01/11 = chained, 10 = no chain id)\n    // - 000X XX00 (bits [4..2]): checkpoint size (00 = 0 bytes, 001 = 1 byte, 010 = 2 bytes...)\n    // - 00X0 0000 (bit [5]): threshold size (0 = 1 byte, 1 = 2 bytes)\n    // - 0X00 0000 (bit [6]): set if imageHash checkpointer is used\n    // - X000 0000 (bit [7]): reserved by base-auth\n\n    Snapshot memory _0x36561f;\n\n    // Recover the imageHash checkpointer if any\n    // but checkpointer passed as argument takes precedence\n    // since it can be defined by the chained signatures\n    if (_0x006900 & 0x40 == 0x40 && _0xee1794 == address(0)) {\n      // Override the checkpointer\n      // not ideal, but we don't have much room in the stack\n      (_0xee1794, _0xedd6a2) = _0x84ef49._0xe6477a(_0xedd6a2);\n\n      if (!_0xa34e79) {\n        // Next 3 bytes determine the checkpointer data size\n        uint256 _0xc0ea59;\n        (_0xc0ea59, _0xedd6a2) = _0x84ef49._0xc9595f(_0xedd6a2);\n\n        // Read the checkpointer data\n        bytes memory _0xb417ff = _0x84ef49[_0xedd6a2:_0xedd6a2 + _0xc0ea59];\n\n        // Call the middleware\n        _0x36561f = ICheckpointer(_0xee1794)._0xa84097(address(this), _0xb417ff);\n\n        _0xedd6a2 += _0xc0ea59;\n      }\n    }\n\n    // If signature type is 01 or 11 we do a chained signature\n    if (_0x006900 & 0x01 == 0x01) {\n      return _0x1375d4(_0x9f9bac, _0xee1794, _0x36561f, _0x84ef49[_0xedd6a2:]);\n    }\n\n    // If the signature type is 10 we do a no chain id signature\n    _0x9f9bac._0xc08552 = _0x006900 & 0x02 == 0x02;\n\n    {\n      // Recover the checkpoint using the size defined by the flag\n      uint256 _0x61a3eb = (_0x006900 & 0x1c) >> 2;\n      (_0x88a863, _0xedd6a2) = _0x84ef49._0x7533fa(_0xedd6a2, _0x61a3eb);\n    }\n\n    // Recover the threshold, using the flag for the size\n    {\n      uint256 _0x7f030a = ((_0x006900 & 0x20) >> 5) + 1;\n      (_0xf24369, _0xedd6a2) = _0x84ef49._0x7533fa(_0xedd6a2, _0x7f030a);\n    }\n\n    // Recover the tree\n    _0x732a7d = _0x9f9bac._0xbdf7fb();\n    (_0xef013e, _0xdd0192) = _0xbfb955(_0x9f9bac, _0x732a7d, _0x84ef49[_0xedd6a2:]);\n\n    _0xdd0192 = LibOptim._0x95ff97(_0xdd0192, bytes32(_0xf24369));\n    _0xdd0192 = LibOptim._0x95ff97(_0xdd0192, bytes32(_0x88a863));\n    _0xdd0192 = LibOptim._0x95ff97(_0xdd0192, bytes32(uint256(uint160(_0xee1794))));\n\n    // If the snapshot is used, either the imageHash must match\n    // or the checkpoint must be greater than the snapshot checkpoint\n    if (_0x36561f._0xdd0192 != bytes32(0) && _0x36561f._0xdd0192 != _0xdd0192 && _0x88a863 <= _0x36561f._0x88a863) {\n      revert UnusedSnapshot(_0x36561f);\n    }\n  }\n\n  function _0x1375d4(\n    Payload.Decoded memory _0x9f9bac,\n    address _0xee1794,\n    Snapshot memory _0x375c95,\n    bytes calldata _0x84ef49\n  ) internal view returns (uint256 _0xf24369, uint256 _0xef013e, bytes32 _0xdd0192, uint256 _0x88a863, bytes32 _0x732a7d) {\n    Payload.Decoded memory _0xd372b0;\n    _0xd372b0._0x651351 = Payload.KIND_CONFIG_UPDATE;\n\n    uint256 _0xedd6a2;\n    uint256 _0x371ae0 = type(uint256)._0x874378;\n\n    while (_0xedd6a2 < _0x84ef49.length) {\n      uint256 _0x0987bc;\n\n      {\n        uint256 _0xf25588;\n        (_0xf25588, _0xedd6a2) = _0x84ef49._0xc9595f(_0xedd6a2);\n        _0x0987bc = _0xf25588 + _0xedd6a2;\n      }\n\n      address _0xa8c563 = _0x0987bc == _0x84ef49.length ? _0xee1794 : address(0);\n\n      if (_0x371ae0 == type(uint256)._0x874378) {\n        (_0xf24369, _0xef013e, _0xdd0192, _0x88a863, _0x732a7d) =\n          _0x611dd8(_0x9f9bac, _0x84ef49[_0xedd6a2:_0x0987bc], true, _0xa8c563);\n      } else {\n        (_0xf24369, _0xef013e, _0xdd0192, _0x88a863,) =\n          _0x611dd8(_0xd372b0, _0x84ef49[_0xedd6a2:_0x0987bc], true, _0xa8c563);\n      }\n\n      if (_0xef013e < _0xf24369) {\n        revert LowWeightChainedSignature(_0x84ef49[_0xedd6a2:_0x0987bc], _0xf24369, _0xef013e);\n      }\n      _0xedd6a2 = _0x0987bc;\n\n      if (_0x375c95._0xdd0192 == _0xdd0192) {\n        _0x375c95._0xdd0192 = bytes32(0);\n      }\n\n      if (_0x88a863 >= _0x371ae0) {\n        revert WrongChainedCheckpointOrder(_0x88a863, _0x371ae0);\n      }\n\n      _0xd372b0._0xdd0192 = _0xdd0192;\n      _0x371ae0 = _0x88a863;\n    }\n\n    if (_0x375c95._0xdd0192 != bytes32(0) && _0x88a863 <= _0x375c95._0x88a863) {\n      revert UnusedSnapshot(_0x375c95);\n    }\n  }\n\n  function _0xbfb955(\n    Payload.Decoded memory _0x9f9bac,\n    bytes32 _0x142400,\n    bytes calldata _0x84ef49\n  ) internal view returns (uint256 _0xef013e, bytes32 _0x5ea63e) {\n    unchecked {\n      uint256 _0xedd6a2;\n\n      // Iterate until the image is completed\n      while (_0xedd6a2 < _0x84ef49.length) {\n        // The first byte is half flag (the top nibble)\n        // and the second set of 4 bits can freely be used by the part\n\n        // Read next item type\n        uint256 _0x63aa49;\n        (_0x63aa49, _0xedd6a2) = _0x84ef49._0xb69c4b(_0xedd6a2);\n\n        // The top 4 bits are the flag\n        uint256 _0x1b6384 = (_0x63aa49 & 0xf0) >> 4;\n\n        // Signature hash (0x00)\n        if (_0x1b6384 == FLAG_SIGNATURE_HASH) {\n          // Free bits layout:\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, ..., 1111 = 15)\n          // We read 64 bytes for an ERC-2098 compact signature (r, yParityAndS).\n          // The top bit of yParityAndS is yParity, the remaining 255 bits are s.\n\n          uint8 _0x14e6ef = uint8(_0x63aa49 & 0x0f);\n          if (_0x14e6ef == 0) {\n            (_0x14e6ef, _0xedd6a2) = _0x84ef49._0xb69c4b(_0xedd6a2);\n          }\n\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0xedd6a2) = _0x84ef49._0x95ec7c(_0xedd6a2);\n\n          address _0x14abe8 = _0xe28f7d(_0x142400, v, r, s);\n\n          _0xef013e += _0x14e6ef;\n          bytes32 _0xc7fc16 = _0x65b714(_0x14abe8, _0x14e6ef);\n          _0x5ea63e = _0x5ea63e != bytes32(0) ? LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16) : _0xc7fc16;\n          continue;\n        }\n\n        // Address (0x01) (without signature)\n        if (_0x1b6384 == FLAG_ADDRESS) {\n          // Free bits layout:\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, 0010 = 2, ...)\n\n          // Read weight\n          uint8 _0x14e6ef = uint8(_0x63aa49 & 0x0f);\n          if (_0x14e6ef == 0) {\n            (_0x14e6ef, _0xedd6a2) = _0x84ef49._0xb69c4b(_0xedd6a2);\n          }\n\n          // Read address\n          address _0x14abe8;\n          (_0x14abe8, _0xedd6a2) = _0x84ef49._0xe6477a(_0xedd6a2);\n\n          // Compute the merkle root WITHOUT adding the weight\n          bytes32 _0xc7fc16 = _0x65b714(_0x14abe8, _0x14e6ef);\n          _0x5ea63e = _0x5ea63e != bytes32(0) ? LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16) : _0xc7fc16;\n          continue;\n        }\n\n        // Signature ERC1271 (0x02)\n        if (_0x1b6384 == FLAG_SIGNATURE_ERC1271) {\n          // Free bits layout:\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Read weight\n          uint8 _0x14e6ef = uint8(_0x63aa49 & 0x03);\n          if (_0x14e6ef == 0) {\n            (_0x14e6ef, _0xedd6a2) = _0x84ef49._0xb69c4b(_0xedd6a2);\n          }\n\n          // Read signer\n          address _0x14abe8;\n          (_0x14abe8, _0xedd6a2) = _0x84ef49._0xe6477a(_0xedd6a2);\n\n          // Read signature size\n          uint256 _0x6c1b2b = uint8(_0x63aa49 & 0x0c) >> 2;\n          uint256 _0x19421a;\n          (_0x19421a, _0xedd6a2) = _0x84ef49._0x7533fa(_0xedd6a2, _0x6c1b2b);\n\n          // Read dynamic size signature\n          uint256 _0x0987bc = _0xedd6a2 + _0x19421a;\n\n          // Call the ERC1271 contract to check if the signature is valid\n          if (IERC1271(_0x14abe8)._0x513d1e(_0x142400, _0x84ef49[_0xedd6a2:_0x0987bc]) != IERC1271_MAGIC_VALUE_HASH) {\n            revert InvalidERC1271Signature(_0x142400, _0x14abe8, _0x84ef49[_0xedd6a2:_0x0987bc]);\n          }\n          _0xedd6a2 = _0x0987bc;\n          // Add the weight and compute the merkle root\n          _0xef013e += _0x14e6ef;\n          bytes32 _0xc7fc16 = _0x65b714(_0x14abe8, _0x14e6ef);\n          _0x5ea63e = _0x5ea63e != bytes32(0) ? LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16) : _0xc7fc16;\n          continue;\n        }\n\n        // Node (0x03)\n        if (_0x1b6384 == FLAG_NODE) {\n          // Free bits left unused\n\n          // Read node hash\n          bytes32 _0xc7fc16;\n          (_0xc7fc16, _0xedd6a2) = _0x84ef49._0x0ca9fd(_0xedd6a2);\n          _0x5ea63e = _0x5ea63e != bytes32(0) ? LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16) : _0xc7fc16;\n          continue;\n        }\n\n        // Branch (0x04)\n        if (_0x1b6384 == FLAG_BRANCH) {\n          // Free bits layout:\n          // - XXXX : Size size (0000 = 0 byte, 0001 = 1 byte, 0010 = 2 bytes, ...)\n\n          // Read size\n          uint256 _0x6c1b2b = uint8(_0x63aa49 & 0x0f);\n          uint256 _0x19421a;\n          (_0x19421a, _0xedd6a2) = _0x84ef49._0x7533fa(_0xedd6a2, _0x6c1b2b);\n\n          // Enter a branch of the signature merkle tree\n          uint256 _0x0987bc = _0xedd6a2 + _0x19421a;\n\n          (uint256 _0x9b1334, bytes32 _0xc7fc16) = _0xbfb955(_0x9f9bac, _0x142400, _0x84ef49[_0xedd6a2:_0x0987bc]);\n          _0xedd6a2 = _0x0987bc;\n\n          _0xef013e += _0x9b1334;\n          _0x5ea63e = LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16);\n          continue;\n        }\n\n        // Nested (0x06)\n        if (_0x1b6384 == FLAG_NESTED) {\n          // Unused free bits:\n          // - XX00 : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n          // - 00XX : Threshold (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Enter a branch of the signature merkle tree\n          // but with an internal threshold and an external fixed weight\n          uint256 _0xa3dc0e = uint8(_0x63aa49 & 0x0c) >> 2;\n          if (_0xa3dc0e == 0) {\n            (_0xa3dc0e, _0xedd6a2) = _0x84ef49._0xb69c4b(_0xedd6a2);\n          }\n\n          uint256 _0x0daa69 = uint8(_0x63aa49 & 0x03);\n          if (_0x0daa69 == 0) {\n            (_0x0daa69, _0xedd6a2) = _0x84ef49._0x48d6cf(_0xedd6a2);\n          }\n\n          uint256 _0x19421a;\n          (_0x19421a, _0xedd6a2) = _0x84ef49._0xc9595f(_0xedd6a2);\n          uint256 _0x0987bc = _0xedd6a2 + _0x19421a;\n\n          (uint256 _0x82c98c, bytes32 _0xd9bb57) = _0xbfb955(_0x9f9bac, _0x142400, _0x84ef49[_0xedd6a2:_0x0987bc]);\n          _0xedd6a2 = _0x0987bc;\n\n          if (_0x82c98c >= _0x0daa69) {\n            _0xef013e += _0xa3dc0e;\n          }\n\n          bytes32 _0xc7fc16 = _0xa3ba61(_0xd9bb57, _0x0daa69, _0xa3dc0e);\n          _0x5ea63e = _0x5ea63e != bytes32(0) ? LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16) : _0xc7fc16;\n          continue;\n        }\n\n        // Subdigest (0x05)\n        if (_0x1b6384 == FLAG_SUBDIGEST) {\n          // Free bits left unused\n\n          // A hardcoded always accepted digest\n          // it pushes the weight to the maximum\n          bytes32 _0x5599c2;\n          (_0x5599c2, _0xedd6a2) = _0x84ef49._0x0ca9fd(_0xedd6a2);\n          if (_0x5599c2 == _0x142400) {\n            _0xef013e = type(uint256)._0x874378;\n          }\n\n          bytes32 _0xc7fc16 = _0x29b611(_0x5599c2);\n          _0x5ea63e = _0x5ea63e != bytes32(0) ? LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16) : _0xc7fc16;\n          continue;\n        }\n\n        // Signature ETH Sign (0x07)\n        if (_0x1b6384 == FLAG_SIGNATURE_ETH_SIGN) {\n          // Free bits layout:\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, ..., 1111 = 15)\n          // We read 64 bytes for an ERC-2098 compact signature (r, yParityAndS).\n          // The top bit of yParityAndS is yParity, the remaining 255 bits are s.\n\n          uint8 _0x14e6ef = uint8(_0x63aa49 & 0x0f);\n          if (_0x14e6ef == 0) {\n            (_0x14e6ef, _0xedd6a2) = _0x84ef49._0xb69c4b(_0xedd6a2);\n          }\n\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0xedd6a2) = _0x84ef49._0x95ec7c(_0xedd6a2);\n\n          address _0x14abe8 = _0xe28f7d(_0x8c2ba0(abi._0x3ae912(\"\\x19Ethereum Signed Message:\\n32\", _0x142400)), v, r, s);\n\n          _0xef013e += _0x14e6ef;\n          bytes32 _0xc7fc16 = _0x65b714(_0x14abe8, _0x14e6ef);\n          _0x5ea63e = _0x5ea63e != bytes32(0) ? LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16) : _0xc7fc16;\n          continue;\n        }\n\n        // Signature Any address subdigest (0x08)\n        // similar to subdigest, but allows for counter-factual payloads\n        if (_0x1b6384 == FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST) {\n          // Free bits left unused\n\n          // A hardcoded always accepted digest\n          // it pushes the weight to the maximum\n          bytes32 _0x5599c2;\n          (_0x5599c2, _0xedd6a2) = _0x84ef49._0x0ca9fd(_0xedd6a2);\n          bytes32 _0xe5baa6 = _0x9f9bac._0xc524a5(address(0));\n          if (_0x5599c2 == _0xe5baa6) {\n            _0xef013e = type(uint256)._0x874378;\n          }\n\n          bytes32 _0xc7fc16 = _0x4ce428(_0x5599c2);\n          _0x5ea63e = _0x5ea63e != bytes32(0) ? LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16) : _0xc7fc16;\n          continue;\n        }\n\n        // Signature Sapient (0x09)\n        if (_0x1b6384 == FLAG_SIGNATURE_SAPIENT) {\n          // Free bits layout:\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Read signer and weight\n          uint8 _0x14e6ef = uint8(_0x63aa49 & 0x03);\n          if (_0x14e6ef == 0) {\n            (_0x14e6ef, _0xedd6a2) = _0x84ef49._0xb69c4b(_0xedd6a2);\n          }\n\n          address _0x14abe8;\n          (_0x14abe8, _0xedd6a2) = _0x84ef49._0xe6477a(_0xedd6a2);\n\n          // Read signature size\n          uint256 _0x19421a;\n          {\n            uint256 _0x6c1b2b = uint8(_0x63aa49 & 0x0c) >> 2;\n            (_0x19421a, _0xedd6a2) = _0x84ef49._0x7533fa(_0xedd6a2, _0x6c1b2b);\n          }\n\n          // Read dynamic size signature\n          uint256 _0x0987bc = _0xedd6a2 + _0x19421a;\n\n          // Call the ERC1271 contract to check if the signature is valid\n          bytes32 _0x3c9037 = ISapient(_0x14abe8)._0x7a655b(_0x9f9bac, _0x84ef49[_0xedd6a2:_0x0987bc]);\n          _0xedd6a2 = _0x0987bc;\n\n          // Add the weight and compute the merkle root\n          _0xef013e += _0x14e6ef;\n          bytes32 _0xc7fc16 = _0xa6c070(_0x14abe8, _0x14e6ef, _0x3c9037);\n          _0x5ea63e = _0x5ea63e != bytes32(0) ? LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16) : _0xc7fc16;\n          continue;\n        }\n\n        // Signature Sapient Compact (0x0A)\n        if (_0x1b6384 == FLAG_SIGNATURE_SAPIENT_COMPACT) {\n          // Free bits layout:\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Read signer and weight\n          uint8 _0x14e6ef = uint8(_0x63aa49 & 0x03);\n          if (_0x14e6ef == 0) {\n            (_0x14e6ef, _0xedd6a2) = _0x84ef49._0xb69c4b(_0xedd6a2);\n          }\n\n          address _0x14abe8;\n          (_0x14abe8, _0xedd6a2) = _0x84ef49._0xe6477a(_0xedd6a2);\n\n          // Read signature size\n          uint256 _0x6c1b2b = uint8(_0x63aa49 & 0x0c) >> 2;\n          uint256 _0x19421a;\n          (_0x19421a, _0xedd6a2) = _0x84ef49._0x7533fa(_0xedd6a2, _0x6c1b2b);\n\n          // Read dynamic size signature\n          uint256 _0x0987bc = _0xedd6a2 + _0x19421a;\n\n          // Call the Sapient contract to check if the signature is valid\n          bytes32 _0x3c9037 =\n            ISapientCompact(_0x14abe8)._0x6be473(_0x142400, _0x84ef49[_0xedd6a2:_0x0987bc]);\n          _0xedd6a2 = _0x0987bc;\n          // Add the weight and compute the merkle root\n          _0xef013e += _0x14e6ef;\n          bytes32 _0xc7fc16 = _0xa6c070(_0x14abe8, _0x14e6ef, _0x3c9037);\n          _0x5ea63e = _0x5ea63e != bytes32(0) ? LibOptim._0x95ff97(_0x5ea63e, _0xc7fc16) : _0xc7fc16;\n          continue;\n        }\n\n        revert InvalidSignatureFlag(_0x1b6384);\n      }\n    }\n  }\n\n}",
      "rename_map": {
        "recoverSapientSignatureCompact": "_0x6be473",
        "_leafForAnyAddressSubdigest": "_0x4ce428",
        "_leafForHardcodedSubdigest": "_0x29b611",
        "_leafForAddressAndWeight": "_0x65b714",
        "recoverSapientSignature": "_0x7a655b",
        "_anyAddressSubdigest": "_0x5418bf",
        "checkpointerDataSize": "_0xc0ea59",
        "_ignoreCheckpointer": "_0xa34e79",
        "internalThreshold": "_0x0daa69",
        "isValidSignature": "_0x513d1e",
        "anyAddressOpHash": "_0xe5baa6",
        "checkpointerData": "_0xb417ff",
        "sapientImageHash": "_0x3c9037",
        "_nextCheckpoint": "_0xe381f6",
        "_leafForSapient": "_0xa6c070",
        "internalWeight": "_0x82c98c",
        "recoverChained": "_0x1375d4",
        "_leafForNested": "_0xa3ba61",
        "readFirstUint8": "_0x0984ae",
        "externalWeight": "_0xa3dc0e",
        "checkpointSize": "_0x61a3eb",
        "readRSVCompact": "_0x95ec7c",
        "prevCheckpoint": "_0x371ae0",
        "linkedPayload": "_0xd372b0",
        "thresholdSize": "_0x7f030a",
        "recoverBranch": "_0xbfb955",
        "signatureFlag": "_0x006900",
        "_checkpointer": "_0xee1794",
        "checkpointer": "_0xa8c563",
        "encodePacked": "_0x3ae912",
        "internalRoot": "_0xd9bb57",
        "readBytes32": "_0x0ca9fd",
        "readAddress": "_0xe6477a",
        "_checkpoint": "_0xf069ee",
        "snapshotFor": "_0xa84097",
        "readUint24": "_0xc9595f",
        "checkpoint": "_0x88a863",
        "addrWeight": "_0x14e6ef",
        "_threshold": "_0xcfc988",
        "readUint16": "_0x48d6cf",
        "_signature": "_0x84ef49",
        "fkeccak256": "_0x95ff97",
        "_subdigest": "_0xe85298",
        "_imageHash": "_0x4bb176",
        "imageHash": "_0xdd0192",
        "_snapshot": "_0x375c95",
        "threshold": "_0xf24369",
        "ecrecover": "_0xe28f7d",
        "keccak256": "_0x8c2ba0",
        "firstByte": "_0x63aa49",
        "hardcoded": "_0x5599c2",
        "readUintX": "_0x7533fa",
        "noChainId": "_0xc08552",
        "readUint8": "_0xb69c4b",
        "_payload": "_0x9f9bac",
        "snapshot": "_0x36561f",
        "sizeSize": "_0x6c1b2b",
        "_opHash": "_0x142400",
        "recover": "_0x611dd8",
        "sigSize": "_0xf25588",
        "_signer": "_0xc6baa0",
        "_weight": "_0x1a6d5d",
        "hashFor": "_0xc524a5",
        "nrindex": "_0x0987bc",
        "nweight": "_0x9b1334",
        "opHash": "_0x732a7d",
        "rindex": "_0xedd6a2",
        "weight": "_0xef013e",
        "_flag": "_0x076740",
        "_node": "_0x1d59ac",
        "_addr": "_0xccfa91",
        "size": "_0x19421a",
        "flag": "_0x1b6384",
        "root": "_0x5ea63e",
        "addr": "_0x14abe8",
        "kind": "_0x651351",
        "node": "_0xc7fc16",
        "hash": "_0xbdf7fb",
        "max": "_0x874378"
      },
      "changes": [
        "Renamed 79 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_030",
      "transformed_id": "ss_l2_hex_sn_gs_030",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibOptim } from \"../utils/LibOptim.sol\";\nimport { Nonce } from \"./Nonce.sol\";\nimport { Payload } from \"./Payload.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { BaseAuth } from \"./auth/BaseAuth.sol\";\nimport { IDelegatedExtension } from \"./interfaces/IDelegatedExtension.sol\";\n\n/// @title Calls\n/// @author Agustin Aguilar, Michael Standen, William Hua\n/// @notice Contract for executing calls\nabstract contract Calls is ReentrancyGuard, BaseAuth, Nonce {\n\n  /// @notice Emitted when a call succeeds\n  event CallSucceeded(bytes32 _0x7c95de, uint256 _0xb298d3);\n  /// @notice Emitted when a call fails\n  event CallFailed(bytes32 _0x7c95de, uint256 _0xb298d3, bytes _0x841799);\n  /// @notice Emitted when a call is aborted\n  event CallAborted(bytes32 _0x7c95de, uint256 _0xb298d3, bytes _0x841799);\n  /// @notice Emitted when a call is skipped\n  event CallSkipped(bytes32 _0x7c95de, uint256 _0xb298d3);\n\n  /// @notice Error thrown when a call reverts\n  error Reverted(Payload.Decoded _0xef678a, uint256 _0xb298d3, bytes _0x841799);\n  /// @notice Error thrown when a signature is invalid\n  error InvalidSignature(Payload.Decoded _0xef678a, bytes _0xb7b88c);\n  /// @notice Error thrown when there is not enough gas\n  error NotEnoughGas(Payload.Decoded _0xef678a, uint256 _0xb298d3, uint256 _0x744132);\n\n  /// @notice Execute a call\n  /// @param _payload The payload\n  /// @param _signature The signature\n  function _0x0e486d(bytes calldata _0xef678a, bytes calldata _0xb7b88c) external payable virtual _0x35f972 {\n    uint256 _0x413f7f = _0x11af04();\n    Payload.Decoded memory _0x8b3117 = Payload._0x71ecf7(_0xef678a);\n\n    _0xf55e2f(_0x8b3117._0xa78445, _0x8b3117._0xd3b4c0);\n    (bool _0x4a39e4, bytes32 _0x19eeff) = _0x092634(_0x8b3117, _0xb7b88c);\n\n    if (!_0x4a39e4) {\n      revert InvalidSignature(_0x8b3117, _0xb7b88c);\n    }\n\n    _0x1f9586(_0x413f7f, _0x19eeff, _0x8b3117);\n  }\n\n  /// @notice Execute a call\n  /// @dev Callable only by the contract itself\n  /// @param _payload The payload\n  function _0x714501(\n    bytes calldata _0xef678a\n  ) external payable virtual _0x0c5a89 {\n    uint256 _0x413f7f = _0x11af04();\n    Payload.Decoded memory _0x8b3117 = Payload._0x71ecf7(_0xef678a);\n    bytes32 _0x19eeff = Payload._0x22c6ef(_0x8b3117);\n    _0x1f9586(_0x413f7f, _0x19eeff, _0x8b3117);\n  }\n\n  function _0x1f9586(uint256 _0xdcb774, bytes32 _0x7c95de, Payload.Decoded memory _0x9ef095) private {\n    bool _0x90bfa1 = false;\n\n    uint256 _0x4ddbc8 = _0x9ef095._0x60f4e6.length;\n    for (uint256 i = 0; i < _0x4ddbc8; i++) {\n      Payload.Call memory call = _0x9ef095._0x60f4e6[i];\n\n      // Skip onlyFallback calls if no error occurred\n      if (call._0xa39553 && !_0x90bfa1) {\n        emit CallSkipped(_0x7c95de, i);\n        continue;\n      }\n\n      // Reset the error flag\n      // onlyFallback calls only apply when the immediately preceding transaction fails\n      _0x90bfa1 = false;\n\n      uint256 gasLimit = call.gasLimit;\n      if (gasLimit != 0 && _0x11af04() < gasLimit) {\n        revert NotEnoughGas(_0x9ef095, i, _0x11af04());\n      }\n\n      bool _0x9a0e82;\n      if (call.delegateCall) {\n        (_0x9a0e82) = LibOptim.delegatecall(\n          call._0xa928c9,\n          gasLimit == 0 ? _0x11af04() : gasLimit,\n          abi._0xc64b75(\n            IDelegatedExtension._0x092eb5.selector,\n            _0x7c95de,\n            _0xdcb774,\n            i,\n            _0x4ddbc8,\n            _0x9ef095._0xa78445,\n            call.data\n          )\n        );\n      } else {\n        (_0x9a0e82) = LibOptim.call(call._0xa928c9, call.value, gasLimit == 0 ? _0x11af04() : gasLimit, call.data);\n      }\n\n      if (!_0x9a0e82) {\n        if (call.behaviorOnError == Payload.BEHAVIOR_IGNORE_ERROR) {\n          _0x90bfa1 = true;\n          emit CallFailed(_0x7c95de, i, LibOptim._0x509534());\n          continue;\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_REVERT_ON_ERROR) {\n          revert Reverted(_0x9ef095, i, LibOptim._0x509534());\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_ABORT_ON_ERROR) {\n          emit CallAborted(_0x7c95de, i, LibOptim._0x509534());\n          break;\n        }\n      }\n\n      emit CallSucceeded(_0x7c95de, i);\n    }\n  }\n\n}",
      "rename_map": {
        "handleSequenceDelegateCall": "_0x092eb5",
        "signatureValidation": "_0x092634",
        "encodeWithSelector": "_0xc64b75",
        "fromPackedCalls": "_0x71ecf7",
        "_consumeNonce": "_0xf55e2f",
        "nonReentrant": "_0x35f972",
        "onlyFallback": "_0xa39553",
        "_startingGas": "_0xdcb774",
        "startingGas": "_0x413f7f",
        "_returnData": "_0x841799",
        "selfExecute": "_0x714501",
        "_signature": "_0xb7b88c",
        "returnData": "_0x509534",
        "errorFlag": "_0x90bfa1",
        "_gasLeft": "_0x744132",
        "_payload": "_0xef678a",
        "_execute": "_0x1f9586",
        "onlySelf": "_0x0c5a89",
        "_decoded": "_0x9ef095",
        "numCalls": "_0x4ddbc8",
        "decoded": "_0x8b3117",
        "isValid": "_0x4a39e4",
        "_opHash": "_0x7c95de",
        "success": "_0x9a0e82",
        "gasleft": "_0x11af04",
        "execute": "_0x0e486d",
        "opHash": "_0x19eeff",
        "_index": "_0xb298d3",
        "calls": "_0x60f4e6",
        "space": "_0xa78445",
        "nonce": "_0xd3b4c0",
        "hash": "_0x22c6ef",
        "to": "_0xa928c9"
      },
      "changes": [
        "Renamed 33 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_031",
      "transformed_id": "ss_l2_hex_sn_gs_031",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from \"../../modules/Payload.sol\";\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { SessionErrors } from \"./SessionErrors.sol\";\nimport { SessionPermissions } from \"./explicit/IExplicitSessionManager.sol\";\nimport { LibPermission, Permission } from \"./explicit/Permission.sol\";\nimport { Attestation, LibAttestation } from \"./implicit/Attestation.sol\";\n\nusing LibBytes for bytes;\nusing LibAttestation for Attestation;\n\n/// @title SessionSig\n/// @author Michael Standen, Agustin Aguilar\n/// @notice Library for session signatures\nlibrary SessionSig {\n\n  uint256 internal constant FLAG_PERMISSIONS = 0;\n  uint256 internal constant FLAG_NODE = 1;\n  uint256 internal constant FLAG_BRANCH = 2;\n  uint256 internal constant FLAG_BLACKLIST = 3;\n  uint256 internal constant FLAG_IDENTITY_SIGNER = 4;\n\n  uint256 internal constant MIN_ENCODED_PERMISSION_SIZE = 94;\n\n  /// @notice Call signature for a specific session\n  /// @param isImplicit If the call is implicit\n  /// @param sessionSigner Address of the session signer\n  /// @param sessionPermission Session permission for explicit calls\n  /// @param attestation Attestation for implicit calls\n  struct CallSignature {\n    bool _0xe9718e;\n    address _0xdf20aa;\n    uint8 _0xbb10af;\n    Attestation _0xb1efa3;\n  }\n\n  /// @notice Decoded signature for a specific session\n  /// @param imageHash Derived configuration image hash\n  /// @param identitySigner Identity signer address\n  /// @param implicitBlacklist Implicit blacklist addresses\n  /// @param sessionPermissions Session permissions for each explicit signer\n  /// @param callSignatures Call signatures for each call in the payload\n  struct DecodedSignature {\n    bytes32 _0x358049;\n    address _0xf7c0aa;\n    address[] _0x2aca70;\n    SessionPermissions[] _0xfb5d3a;\n    CallSignature[] _0x07d268;\n  }\n\n  /// @notice Recovers the decoded signature from the encodedSignature bytes.\n  /// @dev The encoded layout is conceptually separated into three parts:\n  ///  1) Session Configuration\n  ///  2) A reusable list of Attestations + their identity signatures (if any implicit calls exist)\n  ///  3) Call Signatures (one per call in the payload)\n  ///\n  /// High-level layout:\n  ///  - session_configuration: [uint24 size, <Session Configuration encoded>]\n  ///  - attestation_list: [uint8 attestationCount, (Attestation + identitySig) * attestationCount]\n  ///    (new section to allow reusing the same Attestation across multiple calls)\n  ///  - call_signatures: [<CallSignature encoded>] - Size is payload.calls.length\n  ///    - call_signature: [uint8 call_flags, <session_signature>]\n  ///      - call_flags: [bool is_implicit (MSB), 7 bits encoded]\n  ///      - if call_flags.is_implicit.MSB == 1:\n  ///         - attestation_index: [uint8 index into the attestation list (7 bits of the call_flags)]\n  ///         - session_signature: [r, s, v (compact)]\n  ///      - if call_flags.is_implicit.MSB == 0:\n  ///         - session_permission: [uint8 (7 bits of the call_flags)]\n  ///         - session_signature: [r, s, v (compact)]\n  function _0x530e11(\n    Payload.Decoded calldata _0x162372,\n    bytes calldata _0x468958\n  ) internal view returns (DecodedSignature memory sig) {\n    uint256 _0xd2b6ba = 0;\n    bool _0xdbb70e;\n\n    // ----- Session Configuration -----\n    {\n      // First read the length of the session configuration bytes (uint24)\n      uint256 _0x036f5d;\n      (_0x036f5d, _0xd2b6ba) = _0x468958._0x4aca2e(_0xd2b6ba);\n\n      // Recover the session configuration\n      (sig, _0xdbb70e) = _0x276e2b(_0x468958[_0xd2b6ba:_0xd2b6ba + _0x036f5d]);\n      _0xd2b6ba += _0x036f5d;\n\n      // Identity signer must be set\n      if (sig._0xf7c0aa == address(0)) {\n        revert SessionErrors.InvalidIdentitySigner();\n      }\n    }\n\n    // ----- Attestations for implicit calls -----\n    Attestation[] memory _0x81d593;\n    {\n      uint8 _0xce7857;\n      (_0xce7857, _0xd2b6ba) = _0x468958._0x98871d(_0xd2b6ba);\n      _0x81d593 = new Attestation[](_0xce7857);\n      // Parse each attestation and its identity signature, store in memory\n      for (uint256 i = 0; i < _0xce7857; i++) {\n        Attestation memory _0xf412fd;\n        (_0xf412fd, _0xd2b6ba) = LibAttestation._0x345082(_0x468958, _0xd2b6ba);\n\n        // Read the identity signature that approves this attestation\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0xd2b6ba) = _0x468958._0x87d3a9(_0xd2b6ba);\n\n          // Recover the identity signer from the attestation identity signature\n          bytes32 _0xd1483f = _0xf412fd._0x1721ae();\n          address _0xdb561d = _0x6745c0(_0xd1483f, v, r, s);\n          if (_0xdb561d != sig._0xf7c0aa) {\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n        }\n\n        _0x81d593[i] = _0xf412fd;\n      }\n\n      // If we have any implicit calls, we must have a blacklist in the configuration\n      if (_0xce7857 > 0 && !_0xdbb70e) {\n        revert SessionErrors.InvalidBlacklist();\n      }\n    }\n\n    // ----- Call Signatures -----\n    {\n      uint256 _0x219454 = _0x162372._0x79f12d.length;\n      sig._0x07d268 = new CallSignature[](_0x219454);\n\n      for (uint256 i = 0; i < _0x219454; i++) {\n        CallSignature memory _0x5b3c1e;\n\n        // Determine signature type\n        {\n          uint8 _0x930e19;\n          (_0x930e19, _0xd2b6ba) = _0x468958._0x98871d(_0xd2b6ba);\n          _0x5b3c1e._0xe9718e = (_0x930e19 & 0x80) != 0;\n\n          if (_0x5b3c1e._0xe9718e) {\n            // Read attestation index from the call_flags\n            uint8 _0x77129c = uint8(_0x930e19 & 0x7f);\n\n            // Check if the attestation index is out of range\n            if (_0x77129c >= _0x81d593.length) {\n              revert SessionErrors.InvalidAttestation();\n            }\n\n            // Set the attestation\n            _0x5b3c1e._0xb1efa3 = _0x81d593[_0x77129c];\n          } else {\n            // Session permission index is the entire byte, top bit is 0 => no conflict\n            _0x5b3c1e._0xbb10af = _0x930e19;\n          }\n        }\n\n        // Read session signature and recover the signer\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0xd2b6ba) = _0x468958._0x87d3a9(_0xd2b6ba);\n\n          bytes32 _0xb5b66e = _0x6cd6f3(_0x162372, i);\n          _0x5b3c1e._0xdf20aa = _0x6745c0(_0xb5b66e, v, r, s);\n          if (_0x5b3c1e._0xdf20aa == address(0)) {\n            revert SessionErrors.InvalidSessionSigner(address(0));\n          }\n        }\n\n        sig._0x07d268[i] = _0x5b3c1e;\n      }\n    }\n\n    return sig;\n  }\n\n  /// @notice Recovers the session configuration from the encoded data.\n  function _0x276e2b(\n    bytes calldata _0x642c18\n  ) internal pure returns (DecodedSignature memory sig, bool _0x9aab11) {\n    uint256 _0xd2b6ba;\n    uint256 _0x20de72;\n\n    // Guess maximum permissions size by bytes length\n    {\n      uint256 _0xa8ba30 = _0x642c18.length / MIN_ENCODED_PERMISSION_SIZE;\n      sig._0xfb5d3a = new SessionPermissions[](_0xa8ba30);\n    }\n\n    while (_0xd2b6ba < _0x642c18.length) {\n      // First byte is the flag (top 4 bits) and additional data (bottom 4 bits)\n      uint256 _0x838072;\n      (_0x838072, _0xd2b6ba) = _0x642c18._0x98871d(_0xd2b6ba);\n      // The top 4 bits are the flag\n      uint256 _0x930e19 = (_0x838072 & 0xf0) >> 4;\n\n      // Permissions configuration (0x00)\n      if (_0x930e19 == FLAG_PERMISSIONS) {\n        SessionPermissions memory _0xcf0437;\n        uint256 _0x62a22f = _0xd2b6ba;\n\n        // Read signer\n        (_0xcf0437._0x63cba6, _0xd2b6ba) = _0x642c18._0x57c9a6(_0xd2b6ba);\n\n        // Read chainId\n        (_0xcf0437.chainId, _0xd2b6ba) = _0x642c18._0xe639f9(_0xd2b6ba);\n\n        // Read value limit\n        (_0xcf0437._0xd73033, _0xd2b6ba) = _0x642c18._0xe639f9(_0xd2b6ba);\n\n        // Read deadline\n        (_0xcf0437._0x10b854, _0xd2b6ba) = _0x642c18._0x35c7fc(_0xd2b6ba);\n\n        // Read permissions array\n        (_0xcf0437._0x2942fa, _0xd2b6ba) = _0xe99510(_0x642c18, _0xd2b6ba);\n\n        // Update root\n        {\n          bytes32 _0x2c4551 = _0xcaaf92(_0x642c18[_0x62a22f:_0xd2b6ba]);\n          sig._0x358049 =\n            sig._0x358049 != bytes32(0) ? LibOptim._0x5e172b(sig._0x358049, _0x2c4551) : _0x2c4551;\n        }\n\n        // Push node permissions to the permissions array\n        sig._0xfb5d3a[_0x20de72++] = _0xcf0437;\n        continue;\n      }\n\n      // Node (0x01)\n      if (_0x930e19 == FLAG_NODE) {\n        // Read pre-hashed node\n        bytes32 _0x038c15;\n        (_0x038c15, _0xd2b6ba) = _0x642c18._0x8cf806(_0xd2b6ba);\n\n        // Update root\n        sig._0x358049 = sig._0x358049 != bytes32(0) ? LibOptim._0x5e172b(sig._0x358049, _0x038c15) : _0x038c15;\n\n        continue;\n      }\n\n      // Branch (0x02)\n      if (_0x930e19 == FLAG_BRANCH) {\n        // Read branch size\n        uint256 _0xcaffd7;\n        {\n          uint256 _0xe5baf4 = uint8(_0x838072 & 0x0f);\n          (_0xcaffd7, _0xd2b6ba) = _0x642c18._0xeae744(_0xd2b6ba, _0xe5baf4);\n        }\n        // Process branch\n        uint256 _0x0390eb = _0xd2b6ba + _0xcaffd7;\n        (DecodedSignature memory _0x147a0d, bool _0x621e56) = _0x276e2b(_0x642c18[_0xd2b6ba:_0x0390eb]);\n        _0xd2b6ba = _0x0390eb;\n\n        // Store the branch blacklist\n        if (_0x621e56) {\n          if (_0x9aab11) {\n            // Blacklist already set\n            revert SessionErrors.InvalidBlacklist();\n          }\n          _0x9aab11 = true;\n          sig._0x2aca70 = _0x147a0d._0x2aca70;\n        }\n\n        // Store the branch identity signer\n        if (_0x147a0d._0xf7c0aa != address(0)) {\n          if (sig._0xf7c0aa != address(0)) {\n            // Identity signer already set\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n          sig._0xf7c0aa = _0x147a0d._0xf7c0aa;\n        }\n\n        // Push all branch permissions to the permissions array\n        for (uint256 i = 0; i < _0x147a0d._0xfb5d3a.length; i++) {\n          sig._0xfb5d3a[_0x20de72++] = _0x147a0d._0xfb5d3a[i];\n        }\n\n        // Update root\n        sig._0x358049 =\n          sig._0x358049 != bytes32(0) ? LibOptim._0x5e172b(sig._0x358049, _0x147a0d._0x358049) : _0x147a0d._0x358049;\n\n        continue;\n      }\n\n      // Blacklist (0x03)\n      if (_0x930e19 == FLAG_BLACKLIST) {\n        if (_0x9aab11) {\n          // Blacklist already set\n          revert SessionErrors.InvalidBlacklist();\n        }\n        _0x9aab11 = true;\n\n        // Read the blacklist count from the first byte's lower 4 bits\n        uint256 _0xe85ac5 = uint256(_0x838072 & 0x0f);\n        if (_0xe85ac5 == 0x0f) {\n          // If it's max nibble, read the next 2 bytes for the actual size\n          (_0xe85ac5, _0xd2b6ba) = _0x642c18._0xa22c1a(_0xd2b6ba);\n        }\n        uint256 _0x62a22f = _0xd2b6ba;\n\n        // Read the blacklist addresses\n        sig._0x2aca70 = new address[](_0xe85ac5);\n        address _0xf3abbc;\n        for (uint256 i = 0; i < _0xe85ac5; i++) {\n          (sig._0x2aca70[i], _0xd2b6ba) = _0x642c18._0x57c9a6(_0xd2b6ba);\n          if (sig._0x2aca70[i] < _0xf3abbc) {\n            revert SessionErrors.InvalidBlacklistUnsorted();\n          }\n          _0xf3abbc = sig._0x2aca70[i];\n        }\n\n        // Update the root\n        bytes32 _0x264e96 = _0xe305bb(_0x642c18[_0x62a22f:_0xd2b6ba]);\n        sig._0x358049 = sig._0x358049 != bytes32(0) ? LibOptim._0x5e172b(sig._0x358049, _0x264e96) : _0x264e96;\n\n        continue;\n      }\n\n      // Identity signer (0x04)\n      if (_0x930e19 == FLAG_IDENTITY_SIGNER) {\n        if (sig._0xf7c0aa != address(0)) {\n          // Identity signer already set\n          revert SessionErrors.InvalidIdentitySigner();\n        }\n        (sig._0xf7c0aa, _0xd2b6ba) = _0x642c18._0x57c9a6(_0xd2b6ba);\n\n        // Update the root\n        bytes32 _0x19ff48 = _0x096c2d(sig._0xf7c0aa);\n        sig._0x358049 =\n          sig._0x358049 != bytes32(0) ? LibOptim._0x5e172b(sig._0x358049, _0x19ff48) : _0x19ff48;\n\n        continue;\n      }\n\n      revert SessionErrors.InvalidNodeType(_0x930e19);\n    }\n\n    {\n      // Update the permissions array length to the actual count\n      SessionPermissions[] memory _0x2942fa = sig._0xfb5d3a;\n      assembly {\n        mstore(_0x2942fa, _0x20de72)\n      }\n    }\n\n    return (sig, _0x9aab11);\n  }\n\n  /// @notice Decodes an array of Permission objects from the encoded data.\n  function _0xe99510(\n    bytes calldata _0x642c18,\n    uint256 _0xd2b6ba\n  ) internal pure returns (Permission[] memory _0x2942fa, uint256 _0xa2c091) {\n    uint256 length;\n    (length, _0xd2b6ba) = _0x642c18._0x98871d(_0xd2b6ba);\n    _0x2942fa = new Permission[](length);\n    for (uint256 i = 0; i < length; i++) {\n      (_0x2942fa[i], _0xd2b6ba) = LibPermission._0x4cb0a7(_0x642c18, _0xd2b6ba);\n    }\n    return (_0x2942fa, _0xd2b6ba);\n  }\n\n  /// @notice Hashes the encoded session permissions into a leaf node.\n  function _0xcaaf92(\n    bytes calldata _0xde0ca8\n  ) internal pure returns (bytes32) {\n    return _0x851f94(abi._0x8483e8(uint8(FLAG_PERMISSIONS), _0xde0ca8));\n  }\n\n  /// @notice Hashes the encoded blacklist into a leaf node.\n  function _0xe305bb(\n    bytes calldata _0x78bef4\n  ) internal pure returns (bytes32) {\n    return _0x851f94(abi._0x8483e8(uint8(FLAG_BLACKLIST), _0x78bef4));\n  }\n\n  /// @notice Hashes the identity signer into a leaf node.\n  function _0x096c2d(\n    address _0xf7c0aa\n  ) internal pure returns (bytes32) {\n    return _0x851f94(abi._0x8483e8(uint8(FLAG_IDENTITY_SIGNER), _0xf7c0aa));\n  }\n\n  /// @notice Hashes a call with replay protection.\n  /// @dev The replay protection is based on the chainId, space, nonce and index in the payload.\n  /// @param payload The payload to hash\n  /// @param callIdx The index of the call to hash\n  /// @return callHash The hash of the call with replay protection\n  function _0x6cd6f3(\n    Payload.Decoded calldata _0x162372,\n    uint256 _0xa6eaf1\n  ) public view returns (bytes32 _0xb5b66e) {\n    return _0x851f94(\n      abi._0x8483e8(\n        _0x162372._0xfe1660 ? 0 : block.chainid,\n        _0x162372._0x17913d,\n        _0x162372._0xddc693,\n        _0xa6eaf1,\n        Payload._0x05a619(_0x162372._0x79f12d[_0xa6eaf1])\n      )\n    );\n  }\n\n}\n",
      "rename_map": {
        "hashCallWithReplayProtection": "_0x6cd6f3",
        "_leafHashForIdentitySigner": "_0x096c2d",
        "recoveredIdentitySigner": "_0xdb561d",
        "_leafHashForPermissions": "_0xcaaf92",
        "_leafHashForBlacklist": "_0xe305bb",
        "recoverConfiguration": "_0x276e2b",
        "hasBlacklistInConfig": "_0xdbb70e",
        "identitySignerHash": "_0x19ff48",
        "_decodePermissions": "_0xe99510",
        "branchHasBlacklist": "_0x621e56",
        "maxPermissionsSize": "_0xa8ba30",
        "sessionPermissions": "_0xfb5d3a",
        "encodedPermissions": "_0xde0ca8",
        "sessionPermission": "_0xbb10af",
        "implicitBlacklist": "_0x2aca70",
        "attestationCount": "_0xce7857",
        "attestationIndex": "_0x77129c",
        "recoverSignature": "_0x530e11",
        "encodedBlacklist": "_0x78bef4",
        "encodedSignature": "_0x468958",
        "permissionsCount": "_0x20de72",
        "nodePermissions": "_0xcf0437",
        "attestationList": "_0x81d593",
        "previousAddress": "_0xf3abbc",
        "attestationHash": "_0xd1483f",
        "identitySigner": "_0xf7c0aa",
        "callSignatures": "_0x07d268",
        "permissionHash": "_0x2c4551",
        "blacklistCount": "_0xe85ac5",
        "readPermission": "_0x4cb0a7",
        "readRSVCompact": "_0x87d3a9",
        "blacklistHash": "_0x264e96",
        "sessionSigner": "_0xdf20aa",
        "callSignature": "_0x5b3c1e",
        "hasBlacklist": "_0x9aab11",
        "encodePacked": "_0x8483e8",
        "pointerStart": "_0x62a22f",
        "readBytes32": "_0x8cf806",
        "readAddress": "_0x57c9a6",
        "permissions": "_0x2942fa",
        "attestation": "_0xb1efa3",
        "readUint256": "_0xe639f9",
        "readUint24": "_0x4aca2e",
        "readUint64": "_0x35c7fc",
        "fromPacked": "_0x345082",
        "readUint16": "_0xa22c1a",
        "valueLimit": "_0xd73033",
        "newPointer": "_0xa2c091",
        "fkeccak256": "_0x5e172b",
        "isImplicit": "_0xe9718e",
        "callsCount": "_0x219454",
        "imageHash": "_0x358049",
        "ecrecover": "_0x6745c0",
        "keccak256": "_0x851f94",
        "firstByte": "_0x838072",
        "readUintX": "_0xeae744",
        "noChainId": "_0xfe1660",
        "readUint8": "_0x98871d",
        "branchSig": "_0x147a0d",
        "dataSize": "_0x036f5d",
        "deadline": "_0x10b854",
        "sizeSize": "_0xe5baf4",
        "callHash": "_0xb5b66e",
        "hashCall": "_0x05a619",
        "pointer": "_0xd2b6ba",
        "encoded": "_0x642c18",
        "callIdx": "_0xa6eaf1",
        "nrindex": "_0x0390eb",
        "payload": "_0x162372",
        "toHash": "_0x1721ae",
        "signer": "_0x63cba6",
        "space": "_0x17913d",
        "nonce": "_0xddc693",
        "calls": "_0x79f12d",
        "size": "_0xcaffd7",
        "flag": "_0x930e19",
        "node": "_0x038c15",
        "att": "_0xf412fd"
      },
      "changes": [
        "Renamed 78 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_032",
      "transformed_id": "ss_l2_hex_sn_gs_032",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport { Calls } from \"./Calls.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { IAccount, PackedUserOperation } from \"./interfaces/IAccount.sol\";\nimport { IERC1271_MAGIC_VALUE_HASH } from \"./interfaces/IERC1271.sol\";\nimport { IEntryPoint } from \"./interfaces/IEntryPoint.sol\";\n\n/// @title ERC4337v07\n/// @author Agustin Aguilar, Michael Standen\n/// @notice ERC4337 v7 support\nabstract contract ERC4337v07 is ReentrancyGuard, IAccount, Calls {\n\n  uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n  address public immutable _0xcd4438;\n\n  error InvalidEntryPoint(address _0xd3d8d4);\n  error ERC4337Disabled();\n\n  constructor(\n    address _0xd3d8d4\n  ) {\n    _0xcd4438 = _0xd3d8d4;\n  }\n\n  /// @inheritdoc IAccount\n  function _0x36d1ab(\n    PackedUserOperation calldata _0xf5513b,\n    bytes32 _0x433ca7,\n    uint256 _0x056199\n  ) external returns (uint256 _0xfce6f3) {\n    if (_0xcd4438 == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != _0xcd4438) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n    // userOp.nonce is validated by the entrypoint\n\n    if (_0x056199 != 0) {\n      IEntryPoint(_0xcd4438)._0xf3b5d6{ value: _0x056199 }(address(this));\n    }\n\n    if (this._0x473298(_0x433ca7, _0xf5513b._0xe6692a) != IERC1271_MAGIC_VALUE_HASH) {\n      return SIG_VALIDATION_FAILED;\n    }\n\n    return 0;\n  }\n\n  /// @notice Execute a user operation\n  /// @param _payload The packed payload\n  /// @dev This is the execute function for the EntryPoint to call.\n  function _0x7fca11(\n    bytes calldata _0xb8f93f\n  ) external _0x351f60 {\n    if (_0xcd4438 == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != _0xcd4438) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n    this._0x6829be(_0xb8f93f);\n  }\n\n}",
      "rename_map": {
        "missingAccountFunds": "_0x056199",
        "isValidSignature": "_0x473298",
        "validateUserOp": "_0x36d1ab",
        "validationData": "_0xfce6f3",
        "executeUserOp": "_0x7fca11",
        "nonReentrant": "_0x351f60",
        "selfExecute": "_0x6829be",
        "_entrypoint": "_0xd3d8d4",
        "userOpHash": "_0x433ca7",
        "entrypoint": "_0xcd4438",
        "depositTo": "_0xf3b5d6",
        "signature": "_0xe6692a",
        "_payload": "_0xb8f93f",
        "userOp": "_0xf5513b"
      },
      "changes": [
        "Renamed 14 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_033",
      "transformed_id": "ss_l2_hex_sn_gs_033",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from \"../Payload.sol\";\n\nimport { Storage } from \"../Storage.sol\";\nimport { IAuth } from \"../interfaces/IAuth.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\n\nimport { IPartialAuth } from \"../interfaces/IPartialAuth.sol\";\nimport { ISapient } from \"../interfaces/ISapient.sol\";\nimport { BaseSig } from \"./BaseSig.sol\";\n\nimport { SelfAuth } from \"./SelfAuth.sol\";\n\nusing Payload for Payload.Decoded;\n\n/// @title BaseAuth\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Base contract for the auth module\nabstract contract BaseAuth is IAuth, IPartialAuth, ISapient, IERC1271, SelfAuth {\n\n  /// @dev keccak256(\"org.sequence.module.auth.static\")\n  bytes32 private constant STATIC_SIGNATURE_KEY =\n    bytes32(0xc852adf5e97c2fc3b38f405671e91b7af1697ef0287577f227ef10494c2a8e86);\n\n  /// @notice Error thrown when the sapient signature is invalid\n  error InvalidSapientSignature(Payload.Decoded _0x576441, bytes _0x9a02f7);\n  /// @notice Error thrown when the signature weight is invalid\n  error InvalidSignatureWeight(uint256 _0x420c62, uint256 _0x3c38c1);\n  /// @notice Error thrown when the static signature has expired\n  error InvalidStaticSignatureExpired(bytes32 _0x2308f9, uint256 _0x351ff5);\n  /// @notice Error thrown when the static signature has the wrong caller\n  error InvalidStaticSignatureWrongCaller(bytes32 _0x2308f9, address _0x261cf5, address _0x205fd5);\n\n  /// @notice Event emitted when a static signature is set\n  event StaticSignatureSet(bytes32 _0xdf5d4c, address _0xc277bc, uint96 _0xbbe3b8);\n\n  function _0xf6bf7d(\n    bytes32 _0xdf5d4c\n  ) internal view returns (address, uint256) {\n    uint256 _0x8b16ba = uint256(Storage._0xf71163(STATIC_SIGNATURE_KEY, _0xdf5d4c));\n    return (address(uint160(_0x8b16ba >> 96)), uint256(uint96(_0x8b16ba)));\n  }\n\n  function _0xabe522(bytes32 _0xdf5d4c, address _0xc277bc, uint256 _0xbbe3b8) internal {\n    Storage._0x990956(\n      STATIC_SIGNATURE_KEY, _0xdf5d4c, bytes32(uint256(uint160(_0xc277bc)) << 96 | (_0xbbe3b8 & 0xffffffffffffffffffffffff))\n    );\n  }\n\n  /// @notice Get the static signature for a specific hash\n  /// @param _hash The hash to get the static signature for\n  /// @return address The address associated with the static signature\n  /// @return timestamp The timestamp of the static signature\n  function _0x12aa71(\n    bytes32 _0xdf5d4c\n  ) external view returns (address, uint256) {\n    return _0xf6bf7d(_0xdf5d4c);\n  }\n\n  /// @notice Set the static signature for a specific hash\n  /// @param _hash The hash to set the static signature for\n  /// @param _address The address to associate with the static signature\n  /// @param _timestamp The timestamp of the static signature\n  /// @dev Only callable by the wallet itself\n  function _0x85246a(bytes32 _0xdf5d4c, address _0xc277bc, uint96 _0xbbe3b8) external _0xf2b841 {\n    _0xabe522(_0xdf5d4c, _0xc277bc, _0xbbe3b8);\n    emit StaticSignatureSet(_0xdf5d4c, _0xc277bc, _0xbbe3b8);\n  }\n\n  /// @notice Update the image hash\n  /// @param _imageHash The new image hash\n  /// @dev Only callable by the wallet itself\n  function _0xf8bf38(\n    bytes32 _0x3f2962\n  ) external virtual _0xf2b841 {\n    _0x6014f3(_0x3f2962);\n  }\n\n  function _0xe493a7(\n    Payload.Decoded memory _0x576441,\n    bytes calldata _0x9a02f7\n  ) internal view virtual returns (bool _0x0cb9a6, bytes32 _0xedbd41) {\n    // Read first bit to determine if static signature is used\n    bytes1 _0xe44e31 = _0x9a02f7[0];\n\n    if (_0xe44e31 & 0x80 == 0x80) {\n      _0xedbd41 = _0x576441._0xa12aca();\n\n      (address _0xdfb04d, uint256 timestamp) = _0xf6bf7d(_0xedbd41);\n      if (timestamp <= block.timestamp) {\n        revert InvalidStaticSignatureExpired(_0xedbd41, timestamp);\n      }\n\n      if (_0xdfb04d != address(0) && _0xdfb04d != msg.sender) {\n        revert InvalidStaticSignatureWrongCaller(_0xedbd41, msg.sender, _0xdfb04d);\n      }\n\n      return (true, _0xedbd41);\n    }\n\n    // Static signature is not used, recover and validate imageHash\n\n    uint256 _0x0b885c;\n    uint256 _0x019f9c;\n    bytes32 _0x57a545;\n\n    (_0x0b885c, _0x019f9c, _0x57a545,, _0xedbd41) = BaseSig._0x4be4fe(_0x576441, _0x9a02f7, false, address(0));\n\n    // Validate the weight\n    if (_0x019f9c < _0x0b885c) {\n      revert InvalidSignatureWeight(_0x0b885c, _0x019f9c);\n    }\n\n    _0x0cb9a6 = _0x2984a1(_0x57a545);\n  }\n\n  /// @inheritdoc ISapient\n  function _0xe8172a(\n    Payload.Decoded memory _0x576441,\n    bytes calldata _0x9a02f7\n  ) external view returns (bytes32) {\n    // Copy parent wallets + add caller at the end\n    address[] memory _0xe932d3 = new address[](_0x576441._0xe932d3.length + 1);\n\n    for (uint256 i = 0; i < _0x576441._0xe932d3.length; i++) {\n      _0xe932d3[i] = _0x576441._0xe932d3[i];\n    }\n\n    _0xe932d3[_0x576441._0xe932d3.length] = msg.sender;\n    _0x576441._0xe932d3 = _0xe932d3;\n\n    (bool _0x0cb9a6,) = _0xe493a7(_0x576441, _0x9a02f7);\n    if (!_0x0cb9a6) {\n      revert InvalidSapientSignature(_0x576441, _0x9a02f7);\n    }\n\n    return bytes32(uint256(1));\n  }\n\n  /// @inheritdoc IERC1271\n  function _0xd632ca(bytes32 _0xdf5d4c, bytes calldata _0x9a02f7) external view returns (bytes4) {\n    Payload.Decoded memory _0x34b6cc = Payload._0x163c61(_0xdf5d4c);\n\n    (bool _0x0cb9a6,) = _0xe493a7(_0x34b6cc, _0x9a02f7);\n    if (!_0x0cb9a6) {\n      return bytes4(0);\n    }\n\n    return IERC1271_MAGIC_VALUE_HASH;\n  }\n\n  /// @inheritdoc IPartialAuth\n  function _0x87a36b(\n    Payload.Decoded memory _0x576441,\n    bytes calldata _0x9a02f7\n  )\n    external\n    view\n    returns (\n      uint256 _0x0b885c,\n      uint256 _0x019f9c,\n      bool _0x495c89,\n      bytes32 _0x57a545,\n      uint256 _0x0f3ceb,\n      bytes32 _0xedbd41\n    )\n  {\n    (_0x0b885c, _0x019f9c, _0x57a545, _0x0f3ceb, _0xedbd41) = BaseSig._0x4be4fe(_0x576441, _0x9a02f7, false, address(0));\n    _0x495c89 = _0x2984a1(_0x57a545);\n  }\n\n}",
      "rename_map": {
        "recoverSapientSignature": "_0xe8172a",
        "recoverPartialSignature": "_0x87a36b",
        "_setStaticSignature": "_0xabe522",
        "_getStaticSignature": "_0xf6bf7d",
        "signatureValidation": "_0xe493a7",
        "setStaticSignature": "_0x85246a",
        "getStaticSignature": "_0x12aa71",
        "isValidSignature": "_0xd632ca",
        "_updateImageHash": "_0x6014f3",
        "updateImageHash": "_0xf8bf38",
        "_expectedCaller": "_0x205fd5",
        "writeBytes32Map": "_0x990956",
        "readBytes32Map": "_0xf71163",
        "signatureFlag": "_0xe44e31",
        "_isValidImage": "_0x2984a1",
        "parentWallets": "_0xe932d3",
        "isValidImage": "_0x495c89",
        "_threshold": "_0x420c62",
        "checkpoint": "_0x0f3ceb",
        "_imageHash": "_0x3f2962",
        "fromDigest": "_0x163c61",
        "_signature": "_0x9a02f7",
        "_timestamp": "_0xbbe3b8",
        "imageHash": "_0x57a545",
        "threshold": "_0x0b885c",
        "_payload": "_0x576441",
        "_expires": "_0x351ff5",
        "onlySelf": "_0xf2b841",
        "_address": "_0xc277bc",
        "payload": "_0x34b6cc",
        "isValid": "_0x0cb9a6",
        "_opHash": "_0x2308f9",
        "recover": "_0x4be4fe",
        "_weight": "_0x3c38c1",
        "_caller": "_0x261cf5",
        "opHash": "_0xedbd41",
        "weight": "_0x019f9c",
        "_hash": "_0xdf5d4c",
        "addr": "_0xdfb04d",
        "hash": "_0xa12aca",
        "word": "_0x8b16ba"
      },
      "changes": [
        "Renamed 41 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_034",
      "transformed_id": "ss_l2_hex_sn_gs_034",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport \"./Wallet.sol\";\n\n/// @title Factory\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Factory for deploying wallets\ncontract Factory {\n\n  /// @notice Error thrown when the deployment fails\n  error DeployFailed(address _0xfea8f7, bytes32 _0x89c81f);\n\n  /// @notice Deploy a new wallet instance\n  /// @param _mainModule Address of the main module to be used by the wallet\n  /// @param _salt Salt used to generate the wallet, which is the imageHash of the wallet's configuration.\n  /// @dev It is recommended to not have more than 200 signers as opcode repricing could make transactions impossible to execute as all the signers must be passed for each transaction.\n  function _0xfed844(address _0xfea8f7, bytes32 _0x89c81f) public payable returns (address _0xd8134d) {\n    bytes memory code = abi._0x61d24e(Wallet._0x5916df, uint256(uint160(_0xfea8f7)));\n    assembly {\n      _0xd8134d := create2(callvalue(), add(code, 32), mload(code), _0x89c81f)\n    }\n    if (_0xd8134d == address(0)) {\n      revert DeployFailed(_0xfea8f7, _0x89c81f);\n    }\n  }\n\n}",
      "rename_map": {
        "creationCode": "_0x5916df",
        "encodePacked": "_0x61d24e",
        "_mainModule": "_0xfea8f7",
        "_contract": "_0xd8134d",
        "deploy": "_0xfed844",
        "_salt": "_0x89c81f"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_035",
      "transformed_id": "ss_l2_hex_sn_gs_035",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19 <0.9.0;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IV2Pool} from \"../../external/IV2Pool.sol\";\nimport {IV2Router} from \"../../external/IV2Router.sol\";\nimport {IV2LockerFactory} from \"../../interfaces/extensions/v2/IV2LockerFactory.sol\";\nimport {IV2Locker} from \"../../interfaces/extensions/v2/IV2Locker.sol\";\nimport {ILocker} from \"../../interfaces/ILocker.sol\";\nimport {Locker} from \"../../Locker.sol\";\n\n/// @title V2Locker\n/// @author velodrome.finance\n/// @notice Manages locking liquidity, staking, and claiming rewards for V2 pools.\ncontract V2Locker is Locker, IV2Locker {\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc IV2Locker\n    address public immutable _0xcd2abc;\n\n    uint256 internal _0x2a4256;\n\n    constructor(\n        bool _0x1da32b,\n        address _0x8078b2,\n        address _0xc2547a,\n        address _0x5db15b,\n        uint256 _0x0ac698,\n        uint32 _0xe1a132,\n        address _0xcd8055,\n        uint16 _0x9c6a35,\n        uint16 _0x996877\n    ) Locker(_0x1da32b, _0x8078b2, _0xc2547a, _0xe1a132, _0xcd8055, _0x9c6a35, _0x996877) {\n        _0xcd2abc = _0x5db15b;\n        _0x2a4256 = _0x0ac698;\n        (_0x413649, _0x902baf) = IV2Pool(_0x907ee5)._0x3ed049();\n    }\n\n    /// @inheritdoc Locker\n    function _0xac1b42(address _0xbacc01) external override(Locker, ILocker) _0xb9826f _0x8a690a returns (uint256) {\n        if (msg.sender != _0xbddedd) revert NotFactory();\n\n        delete _0x8fc5e5;\n        delete _0x4aeb62;\n\n        IERC20(_0x907ee5)._0x830903({_0x563d3a: _0xbacc01, value: _0x2a4256});\n\n        /// @dev Refund locked balances\n        uint256 _0x87336f = IERC20(_0x413649)._0x63c6fd({_0x37636f: address(this)});\n        if (_0x87336f > 0) IERC20(_0x413649)._0x830903({_0x563d3a: _0xbacc01, value: _0x87336f});\n        _0x87336f = IERC20(_0x902baf)._0x63c6fd({_0x37636f: address(this)});\n        if (_0x87336f > 0) IERC20(_0x902baf)._0x830903({_0x563d3a: _0xbacc01, value: _0x87336f});\n\n        emit Unlocked({_0x7786ea: _0xbacc01});\n        return _0x2a4256;\n    }\n\n    /// @inheritdoc Locker\n    function _0xbed625() external override(Locker, ILocker) _0x8a690a _0xe04a79 _0xb9826f _0xab2074 {\n        if (_0x8fc5e5) revert AlreadyStaked();\n        _0x8fc5e5 = true;\n\n        _0xbd0bc7({_0xbacc01: _0x255db8()});\n\n        IERC20(_0x907ee5)._0xdfdb8e({_0x600331: address(_0x02f7df), value: _0x2a4256});\n        _0x02f7df._0x67ebcf({_0x490af9: _0x2a4256});\n        emit Staked();\n    }\n\n    /// @inheritdoc Locker\n    function _0x2b82ed(uint256 _0xdb617a, uint256 _0x25c229, uint256 _0xcbc981, uint256 _0x405e6d)\n        external\n        override(ILocker, Locker)\n        _0x8a690a\n        _0xe04a79\n        _0xb9826f\n        returns (uint256)\n    {\n        if (_0xdb617a == 0 && _0x25c229 == 0) revert ZeroAmount();\n\n        uint256 _0x004003 = _0xaffd3e({_0x69a91b: _0x413649, _0x8375d6: _0xdb617a});\n        uint256 _0x560c56 = _0xaffd3e({_0x69a91b: _0x902baf, _0x8375d6: _0x25c229});\n\n        IERC20(_0x413649)._0x3d1475({_0x600331: _0xcd2abc, value: _0xdb617a});\n        IERC20(_0x902baf)._0x3d1475({_0x600331: _0xcd2abc, value: _0x25c229});\n\n        (uint256 _0x7249f8, uint256 _0x60e6d4, uint256 _0x809e78) = IV2Router(_0xcd2abc)._0xe7da00({\n            _0xb1e815: _0x413649,\n            _0xcb6089: _0x902baf,\n            _0x6bde1b: IV2Pool(_0x907ee5)._0x6bde1b(),\n            _0xe4dad8: _0xdb617a,\n            _0xadd846: _0x25c229,\n            _0x3548cc: _0xcbc981,\n            _0xd8b93a: _0x405e6d,\n            _0x563d3a: address(this),\n            _0xf99c92: block.timestamp\n        });\n\n        IERC20(_0x413649)._0x3d1475({_0x600331: _0xcd2abc, value: 0});\n        IERC20(_0x902baf)._0x3d1475({_0x600331: _0xcd2abc, value: 0});\n\n        address _0x7786ea = _0x255db8();\n        _0x982670({_0x69a91b: _0x413649, _0xbacc01: _0x7786ea, _0x136733: _0x004003});\n        _0x982670({_0x69a91b: _0x902baf, _0xbacc01: _0x7786ea, _0x136733: _0x560c56});\n\n        if (_0x8fc5e5) {\n            IERC20(_0x907ee5)._0xdfdb8e({_0x600331: address(_0x02f7df), value: _0x809e78});\n            _0x02f7df._0x67ebcf({_0x490af9: _0x809e78});\n        }\n\n        _0x2a4256 += _0x809e78;\n\n        emit LiquidityIncreased({_0x74ae4c: _0x7249f8, _0x1c55c8: _0x60e6d4, _0x809e78: _0x809e78});\n        return _0x809e78;\n    }\n\n    function _0xb32439() internal override returns (uint256 _0x1ef99b, uint256 _0x28359b) {\n        (_0x1ef99b, _0x28359b) = IV2Pool(_0x907ee5)._0xf019af();\n\n        uint256 _0x58430b = _0xd7d04d({_0x057c10: _0x1ef99b, _0x69a91b: _0x413649});\n        uint256 _0x985d81 = _0xd7d04d({_0x057c10: _0x28359b, _0x69a91b: _0x902baf});\n        _0x1ef99b -= _0x58430b;\n        _0x28359b -= _0x985d81;\n\n        if (_0x58430b > 0 || _0x985d81 > 0) {\n            emit FeesClaimed({_0x7786ea: _0x4bd414, _0x1ef99b: _0x58430b, _0x28359b: _0x985d81});\n        }\n    }\n\n    function _0xc2ca54() internal override returns (uint256 _0x8e7a4a) {\n        uint256 _0xdf63b4 = IERC20(_0xb67e95)._0x63c6fd({_0x37636f: address(this)});\n        _0x02f7df._0x9c8a93({_0x37636f: address(this)});\n        uint256 _0x92bf9d = IERC20(_0xb67e95)._0x63c6fd({_0x37636f: address(this)});\n\n        _0x8e7a4a = _0x92bf9d - _0xdf63b4;\n        uint256 _0x4dcb58 = _0xd7d04d({_0x057c10: _0x8e7a4a, _0x69a91b: _0xb67e95});\n        _0x8e7a4a -= _0x4dcb58;\n\n        if (_0x4dcb58 > 0) {\n            emit RewardsClaimed({_0x7786ea: _0x4bd414, _0x8e7a4a: _0x4dcb58});\n        }\n    }\n\n    function _0x490af9() public view override(ILocker, Locker) returns (uint256) {\n        return _0x2a4256;\n    }\n}",
      "rename_map": {
        "safeIncreaseAllowance": "_0xdfdb8e",
        "_beneficiaryShare": "_0x9c6a35",
        "increaseLiquidity": "_0x2b82ed",
        "amount0Deposited": "_0x7249f8",
        "amount1Deposited": "_0x60e6d4",
        "_bribeableShare": "_0x996877",
        "_refundLeftover": "_0x982670",
        "_collectRewards": "_0xc2ca54",
        "amountADesired": "_0xe4dad8",
        "amountBDesired": "_0xadd846",
        "rewardsBefore": "_0xdf63b4",
        "rewardsAfter": "_0x92bf9d",
        "_beneficiary": "_0xcd8055",
        "_collectFees": "_0xb32439",
        "_deductShare": "_0xd7d04d",
        "nonReentrant": "_0x8a690a",
        "addLiquidity": "_0xe7da00",
        "_lockedUntil": "_0xe1a132",
        "safeTransfer": "_0x830903",
        "forceApprove": "_0x3d1475",
        "_amount0Min": "_0xcbc981",
        "_amount1Min": "_0x405e6d",
        "_fundLocker": "_0xaffd3e",
        "beneficiary": "_0x4bd414",
        "ensureGauge": "_0xab2074",
        "lockedUntil": "_0x4aeb62",
        "rewardToken": "_0xb67e95",
        "onlyLocked": "_0xb9826f",
        "_claimFees": "_0xbd0bc7",
        "_maxAmount": "_0x136733",
        "amountBMin": "_0xd8b93a",
        "_recipient": "_0xbacc01",
        "amountAMin": "_0x3548cc",
        "getReward": "_0x9c8a93",
        "_totalBal": "_0x8375d6",
        "onlyOwner": "_0xe04a79",
        "recipient": "_0x7786ea",
        "supplied0": "_0x004003",
        "supplied1": "_0x560c56",
        "balanceOf": "_0x63c6fd",
        "claimFees": "_0xf019af",
        "liquidity": "_0x809e78",
        "leftover": "_0x87336f",
        "_amount1": "_0x25c229",
        "deadline": "_0xf99c92",
        "_amount0": "_0xdb617a",
        "claimed1": "_0x28359b",
        "claimed0": "_0x1ef99b",
        "factory": "_0xbddedd",
        "claimed": "_0x8e7a4a",
        "_amount": "_0x057c10",
        "amount0": "_0x74ae4c",
        "_router": "_0x5db15b",
        "spender": "_0x600331",
        "amount1": "_0x1c55c8",
        "account": "_0x37636f",
        "deposit": "_0x67ebcf",
        "share0": "_0x58430b",
        "_token": "_0x69a91b",
        "token0": "_0x413649",
        "unlock": "_0xac1b42",
        "tokenA": "_0xb1e815",
        "router": "_0xcd2abc",
        "stable": "_0x6bde1b",
        "staked": "_0x8fc5e5",
        "tokenB": "_0xcb6089",
        "_owner": "_0x8078b2",
        "share1": "_0x985d81",
        "token1": "_0x902baf",
        "tokens": "_0x3ed049",
        "share": "_0x4dcb58",
        "gauge": "_0x02f7df",
        "_root": "_0x1da32b",
        "_pool": "_0xc2547a",
        "owner": "_0x255db8",
        "stake": "_0xbed625",
        "_lp_": "_0x0ac698",
        "pool": "_0x907ee5",
        "_lp": "_0x2a4256",
        "to": "_0x563d3a",
        "lp": "_0x490af9"
      },
      "changes": [
        "Renamed 81 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_001",
      "transformed_id": "ss_l2_hex_sn_tc_001",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bridge Replica Contract\n * @notice Processes cross-chain messages from source chain to destination chain\n * @dev Validates and executes messages based on merkle proofs\n */\ncontract BridgeReplica {\n    // Message status enum\n    enum MessageStatus {\n        None,\n        Pending,\n        Processed\n    }\n\n    // Mapping of message hash to status\n    mapping(bytes32 => MessageStatus) public _0x15e33a;\n\n    // The confirmed root for messages\n    bytes32 public _0x605b73;\n\n    // Bridge router that handles the actual token transfers\n    address public _0x29a6ee;\n\n    // Nonce tracking\n    mapping(uint32 => uint32) public _0x0621af;\n\n    event MessageProcessed(bytes32 indexed _0x42ca82, bool _0x16c0be);\n\n    constructor(address _0x9f0a78) {\n        _0x29a6ee = _0x9f0a78;\n    }\n\n    /**\n     * @notice Process a cross-chain message\n     * @param _message The formatted message to process\n     * @return success Whether the message was successfully processed\n     */\n    function _0xf6e413(bytes memory _0x853af1) external returns (bool _0x16c0be) {\n        bytes32 _0x42ca82 = _0xd8e17b(_0x853af1);\n\n        // Check if message has already been processed\n        require(\n            _0x15e33a[_0x42ca82] != MessageStatus.Processed,\n            \"Already processed\"\n        );\n\n        // Validate message root\n        bytes32 _0xf54850 = _0x1c931b(_0x853af1);\n        require(_0xf54850 == _0x605b73, \"Invalid root\");\n\n        // Mark as processed\n        _0x15e33a[_0x42ca82] = MessageStatus.Processed;\n\n        // Forward to bridge router for token transfer\n        (bool _0xb71855, ) = _0x29a6ee.call(_0x853af1);\n\n        emit MessageProcessed(_0x42ca82, _0xb71855);\n        return _0xb71855;\n    }\n\n    /**\n     * @notice Derive the message root\n     * @dev Verifies message against merkle proof\n     */\n    function _0x1c931b(\n        bytes memory _0x853af1\n    ) internal pure returns (bytes32) {\n        // Simplified merkle proof verification\n        if (_0x853af1.length > 32 && uint256(bytes32(_0x853af1)) == 0) {\n            return bytes32(0);\n        }\n\n        return _0xd8e17b(_0x853af1);\n    }\n\n    /**\n     * @notice Set the accepted root (admin function)\n     */\n    function _0x36a6e5(bytes32 _0x3595a1) external {\n        _0x605b73 = _0x3595a1;\n    }\n}\n",
      "rename_map": {
        "setAcceptedRoot": "_0x36a6e5",
        "routerSuccess": "_0xb71855",
        "_bridgeRouter": "_0x9f0a78",
        "_messageRoot": "_0x1c931b",
        "bridgeRouter": "_0x29a6ee",
        "acceptedRoot": "_0x605b73",
        "messageHash": "_0x42ca82",
        "keccak256": "_0xd8e17b",
        "messages": "_0x15e33a",
        "_newRoot": "_0x3595a1",
        "_message": "_0x853af1",
        "process": "_0xf6e413",
        "success": "_0x16c0be",
        "nonces": "_0x0621af",
        "root": "_0xf54850"
      },
      "changes": [
        "Renamed 15 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_002",
      "transformed_id": "ss_l2_hex_sn_tc_002",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Governance System\n * @notice Manages protocol governance proposals and voting\n * @dev Allows token holders to propose and vote on protocol changes\n */\n\ninterface IDiamondCut {\n    struct FacetCut {\n        address _0x402c90;\n        uint8 _0xb1ea70;\n        bytes4[] _0xd20202;\n    }\n}\n\ncontract GovernanceSystem {\n    // Voting power based on deposits\n    mapping(address => uint256) public _0xb8df12;\n    mapping(address => uint256) public _0x8f7071;\n\n    // Proposal structure\n    struct Proposal {\n        address _0x04683e;\n        address _0x43de3f;\n        bytes data;\n        uint256 _0x49b2be;\n        uint256 _0xdfac64;\n        bool _0x26dcab;\n    }\n\n    mapping(uint256 => Proposal) public _0x2783ba;\n    mapping(uint256 => mapping(address => bool)) public _0xed1bec;\n    uint256 public _0x520f1d;\n\n    uint256 public _0x8dc537;\n\n    // Constants\n    uint256 constant EMERGENCY_THRESHOLD = 66;\n\n    event ProposalCreated(\n        uint256 indexed _0x67164f,\n        address _0x04683e,\n        address _0x43de3f\n    );\n    event Voted(uint256 indexed _0x67164f, address _0xf45aef, uint256 _0xc2bc21);\n    event ProposalExecuted(uint256 indexed _0x67164f);\n\n    /**\n     * @notice Deposit tokens to gain voting power\n     * @param amount Amount to deposit\n     */\n    function _0x557d7b(uint256 _0xe3c31d) external {\n        _0xb8df12[msg.sender] += _0xe3c31d;\n        _0x8f7071[msg.sender] += _0xe3c31d;\n        _0x8dc537 += _0xe3c31d;\n    }\n\n    /**\n     * @notice Create a governance proposal\n     * @param _target The contract to call\n     * @param _calldata The calldata to execute\n     */\n    function _0x8dc8bf(\n        IDiamondCut.FacetCut[] calldata,\n        address _0x68b290,\n        bytes calldata _0x1ec6e4,\n        uint8\n    ) external returns (uint256) {\n        _0x520f1d++;\n\n        Proposal storage _0xe456cd = _0x2783ba[_0x520f1d];\n        _0xe456cd._0x04683e = msg.sender;\n        _0xe456cd._0x43de3f = _0x68b290;\n        _0xe456cd.data = _0x1ec6e4;\n        _0xe456cd._0xdfac64 = block.timestamp;\n        _0xe456cd._0x26dcab = false;\n\n        // Auto-vote with proposer's voting power\n        _0xe456cd._0x49b2be = _0x8f7071[msg.sender];\n        _0xed1bec[_0x520f1d][msg.sender] = true;\n\n        emit ProposalCreated(_0x520f1d, msg.sender, _0x68b290);\n        return _0x520f1d;\n    }\n\n    /**\n     * @notice Vote on a proposal\n     * @param proposalId The ID of the proposal\n     */\n    function _0x879528(uint256 _0x67164f) external {\n        require(!_0xed1bec[_0x67164f][msg.sender], \"Already voted\");\n        require(!_0x2783ba[_0x67164f]._0x26dcab, \"Already executed\");\n\n        _0x2783ba[_0x67164f]._0x49b2be += _0x8f7071[msg.sender];\n        _0xed1bec[_0x67164f][msg.sender] = true;\n\n        emit Voted(_0x67164f, msg.sender, _0x8f7071[msg.sender]);\n    }\n\n    /**\n     * @notice Emergency commit - execute proposal immediately\n     * @param proposalId The ID of the proposal to execute\n     */\n    function _0xd2ecb4(uint256 _0x67164f) external {\n        Proposal storage _0xe456cd = _0x2783ba[_0x67164f];\n        require(!_0xe456cd._0x26dcab, \"Already executed\");\n\n        uint256 _0x7c10cb = (_0xe456cd._0x49b2be * 100) / _0x8dc537;\n        require(_0x7c10cb >= EMERGENCY_THRESHOLD, \"Insufficient votes\");\n\n        _0xe456cd._0x26dcab = true;\n\n        // Execute the proposal\n        (bool _0xd81f54, ) = _0xe456cd._0x43de3f.call(_0xe456cd.data);\n        require(_0xd81f54, \"Execution failed\");\n\n        emit ProposalExecuted(_0x67164f);\n    }\n}\n",
      "rename_map": {
        "functionSelectors": "_0xd20202",
        "depositedBalance": "_0xb8df12",
        "totalVotingPower": "_0x8dc537",
        "emergencyCommit": "_0xd2ecb4",
        "votePercentage": "_0x7c10cb",
        "proposalCount": "_0x520f1d",
        "facetAddress": "_0x402c90",
        "votingPower": "_0x8f7071",
        "proposalId": "_0x67164f",
        "_calldata": "_0x1ec6e4",
        "startTime": "_0xdfac64",
        "proposals": "_0x2783ba",
        "hasVoted": "_0xed1bec",
        "executed": "_0x26dcab",
        "proposer": "_0x04683e",
        "forVotes": "_0x49b2be",
        "propose": "_0x8dc8bf",
        "success": "_0xd81f54",
        "_target": "_0x68b290",
        "deposit": "_0x557d7b",
        "action": "_0xb1ea70",
        "target": "_0x43de3f",
        "amount": "_0xe3c31d",
        "voter": "_0xf45aef",
        "votes": "_0xc2bc21",
        "prop": "_0xe456cd",
        "vote": "_0x879528"
      },
      "changes": [
        "Renamed 27 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_003",
      "transformed_id": "ss_l2_hex_sn_tc_003",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Multi-Signature Wallet Library\n * @notice Shared library contract for multi-sig wallet functionality\n * @dev Used by wallet proxies via delegatecall\n */\ncontract WalletLibrary {\n    // Owner mapping\n    mapping(address => bool) public _0x107a10;\n    address[] public _0x4be8c1;\n    uint256 public _0x7d97e7;\n\n    // Initialization state\n    bool public _0xb3c34d;\n\n    event OwnerAdded(address indexed _0x5c7d25);\n    event WalletDestroyed(address indexed _0x91a66a);\n\n    /**\n     * @notice Initialize the wallet with owners\n     * @param _owners Array of owner addresses\n     * @param _required Number of required signatures\n     * @param _daylimit Daily withdrawal limit\n     */\n    function _0x1e9fc8(\n        address[] memory _0xbbcd8d,\n        uint256 _0x49c14a,\n        uint256 _0xcb304f\n    ) public {\n        // Clear existing owners\n        for (uint i = 0; i < _0x4be8c1.length; i++) {\n            _0x107a10[_0x4be8c1[i]] = false;\n        }\n        delete _0x4be8c1;\n\n        // Set new owners\n        for (uint i = 0; i < _0xbbcd8d.length; i++) {\n            address _0x5c7d25 = _0xbbcd8d[i];\n            require(_0x5c7d25 != address(0), \"Invalid owner\");\n            require(!_0x107a10[_0x5c7d25], \"Duplicate owner\");\n\n            _0x107a10[_0x5c7d25] = true;\n            _0x4be8c1.push(_0x5c7d25);\n            emit OwnerAdded(_0x5c7d25);\n        }\n\n        _0x7d97e7 = _0x49c14a;\n        _0xb3c34d = true;\n    }\n\n    /**\n     * @notice Check if an address is an owner\n     * @param _addr Address to check\n     * @return bool Whether the address is an owner\n     */\n    function _0x635a3a(address _0x240ad7) public view returns (bool) {\n        return _0x107a10[_0x240ad7];\n    }\n\n    /**\n     * @notice Destroy the contract\n     * @param _to Address to send remaining funds to\n     */\n    function _0x802a0e(address payable _0xcff084) external {\n        require(_0x107a10[msg.sender], \"Not an owner\");\n\n        emit WalletDestroyed(msg.sender);\n\n        selfdestruct(_0xcff084);\n    }\n\n    /**\n     * @notice Execute a transaction\n     * @param to Target address\n     * @param value Amount of ETH to send\n     * @param data Transaction data\n     */\n    function _0x0facc8(address _0xc768df, uint256 value, bytes memory data) external {\n        require(_0x107a10[msg.sender], \"Not an owner\");\n\n        (bool _0xbfb43c, ) = _0xc768df.call{value: value}(data);\n        require(_0xbfb43c, \"Execution failed\");\n    }\n}\n\n/**\n * @title Wallet Proxy\n * @notice Proxy contract that delegates to WalletLibrary\n */\ncontract WalletProxy {\n    address public _0xc6c4a3;\n\n    constructor(address _0x8950f1) {\n        _0xc6c4a3 = _0x8950f1;\n    }\n\n    fallback() external payable {\n        address _0x944e54 = _0xc6c4a3;\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let _0x0c1b2a := delegatecall(gas(), _0x944e54, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n\n            switch _0x0c1b2a\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "isOwnerAddress": "_0x635a3a",
        "libraryAddress": "_0xc6c4a3",
        "initialized": "_0xb3c34d",
        "initWallet": "_0x1e9fc8",
        "destroyer": "_0x91a66a",
        "_required": "_0x49c14a",
        "_daylimit": "_0xcb304f",
        "required": "_0x7d97e7",
        "_library": "_0x8950f1",
        "_owners": "_0xbbcd8d",
        "success": "_0xbfb43c",
        "isOwner": "_0x107a10",
        "execute": "_0x0facc8",
        "result": "_0x0c1b2a",
        "owners": "_0x4be8c1",
        "owner": "_0x5c7d25",
        "_addr": "_0x240ad7",
        "kill": "_0x802a0e",
        "_to": "_0xcff084",
        "lib": "_0x944e54",
        "to": "_0xc768df"
      },
      "changes": [
        "Renamed 21 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_004",
      "transformed_id": "ss_l2_hex_sn_tc_004",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Yield Aggregator Vault\n * @notice Vault contract that deploys funds to external yield strategies\n * @dev Users deposit tokens and receive vault shares representing their position\n */\n\ninterface ICurvePool {\n    function _0x47ad6d(\n        int128 i,\n        int128 j,\n        uint256 _0x615949,\n        uint256 _0x295dd3\n    ) external returns (uint256);\n\n    function _0xf72700(\n        int128 i,\n        int128 j,\n        uint256 _0x615949\n    ) external view returns (uint256);\n}\n\ncontract YieldVault {\n    address public _0x27aaf7;\n    ICurvePool public _0x5ef325;\n\n    uint256 public _0x7d39a6;\n    mapping(address => uint256) public _0xd78fe6;\n\n    // Assets deployed to external protocols\n    uint256 public _0xa979a7;\n\n    event Deposit(address indexed _0x9330dd, uint256 _0x0908aa, uint256 _0xf3763c);\n    event Withdrawal(address indexed _0x9330dd, uint256 _0xf3763c, uint256 _0x0908aa);\n\n    constructor(address _0xd8ec24, address _0x8df8e3) {\n        _0x27aaf7 = _0xd8ec24;\n        _0x5ef325 = ICurvePool(_0x8df8e3);\n    }\n\n    /**\n     * @notice Deposit tokens and receive vault shares\n     * @param amount Amount of underlying tokens to deposit\n     * @return shares Amount of vault shares minted\n     */\n    function _0xdaf54b(uint256 _0x0908aa) external returns (uint256 _0xf3763c) {\n        require(_0x0908aa > 0, \"Zero amount\");\n\n        // Calculate shares based on current price\n        if (_0x7d39a6 == 0) {\n            _0xf3763c = _0x0908aa;\n        } else {\n            uint256 _0x9f9cb3 = _0xe2b9c8();\n            _0xf3763c = (_0x0908aa * _0x7d39a6) / _0x9f9cb3;\n        }\n\n        _0xd78fe6[msg.sender] += _0xf3763c;\n        _0x7d39a6 += _0xf3763c;\n\n        // Deploy funds to strategy\n        _0xea3aad(_0x0908aa);\n\n        emit Deposit(msg.sender, _0x0908aa, _0xf3763c);\n        return _0xf3763c;\n    }\n\n    /**\n     * @notice Withdraw underlying tokens by burning shares\n     * @param shares Amount of vault shares to burn\n     * @return amount Amount of underlying tokens received\n     */\n    function _0x9f9e52(uint256 _0xf3763c) external returns (uint256 _0x0908aa) {\n        require(_0xf3763c > 0, \"Zero shares\");\n        require(_0xd78fe6[msg.sender] >= _0xf3763c, \"Insufficient balance\");\n\n        // Calculate amount based on current price\n        uint256 _0x9f9cb3 = _0xe2b9c8();\n        _0x0908aa = (_0xf3763c * _0x9f9cb3) / _0x7d39a6;\n\n        _0xd78fe6[msg.sender] -= _0xf3763c;\n        _0x7d39a6 -= _0xf3763c;\n\n        // Withdraw from strategy\n        _0x57cc9e(_0x0908aa);\n\n        emit Withdrawal(msg.sender, _0xf3763c, _0x0908aa);\n        return _0x0908aa;\n    }\n\n    /**\n     * @notice Get total assets under management\n     * @return Total value of vault assets\n     */\n    function _0xe2b9c8() public view returns (uint256) {\n        uint256 _0x907b05 = 0;\n        uint256 _0x47b97a = _0xa979a7;\n\n        return _0x907b05 + _0x47b97a;\n    }\n\n    /**\n     * @notice Get price per share\n     * @return Price per vault share\n     */\n    function _0x961685() public view returns (uint256) {\n        if (_0x7d39a6 == 0) return 1e18;\n        return (_0xe2b9c8() * 1e18) / _0x7d39a6;\n    }\n\n    /**\n     * @notice Internal function to invest in Curve\n     */\n    function _0xea3aad(uint256 _0x0908aa) internal {\n        _0xa979a7 += _0x0908aa;\n    }\n\n    /**\n     * @notice Internal function to withdraw from Curve\n     */\n    function _0x57cc9e(uint256 _0x0908aa) internal {\n        require(_0xa979a7 >= _0x0908aa, \"Insufficient invested\");\n        _0xa979a7 -= _0x0908aa;\n    }\n}\n",
      "rename_map": {
        "getPricePerFullShare": "_0x961685",
        "exchange_underlying": "_0x47ad6d",
        "_withdrawFromCurve": "_0x57cc9e",
        "get_dy_underlying": "_0xf72700",
        "investedBalance": "_0xa979a7",
        "underlyingToken": "_0x27aaf7",
        "_investInCurve": "_0xea3aad",
        "getTotalAssets": "_0xe2b9c8",
        "curveBalance": "_0x47b97a",
        "vaultBalance": "_0x907b05",
        "totalAssets": "_0x9f9cb3",
        "totalSupply": "_0x7d39a6",
        "_curvePool": "_0x8df8e3",
        "curvePool": "_0x5ef325",
        "balanceOf": "_0xd78fe6",
        "withdraw": "_0x9f9e52",
        "deposit": "_0xdaf54b",
        "min_dy": "_0x295dd3",
        "shares": "_0xf3763c",
        "_token": "_0xd8ec24",
        "amount": "_0x0908aa",
        "user": "_0x9330dd",
        "dx": "_0x615949"
      },
      "changes": [
        "Renamed 23 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_005",
      "transformed_id": "ss_l2_hex_sn_tc_005",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Automated Market Maker Pool\n * @notice Liquidity pool for token swaps with concentrated liquidity\n * @dev Allows users to add liquidity and perform token swaps\n */\ncontract AMMPool {\n    // Token balances in the pool\n    mapping(uint256 => uint256) public _0x640a72; // 0 = token0, 1 = token1\n\n    // LP token\n    mapping(address => uint256) public _0xd0f9fd;\n    uint256 public _0xc63594;\n\n    uint256 private _0xd9639c;\n    uint256 private constant _0xe6fb61 = 1;\n    uint256 private constant _0x42a8fc = 2;\n\n    event LiquidityAdded(\n        address indexed _0x92412f,\n        uint256[2] _0x23274a,\n        uint256 _0x6241fa\n    );\n    event LiquidityRemoved(\n        address indexed _0x92412f,\n        uint256 _0x90b76c,\n        uint256[2] _0x23274a\n    );\n\n    constructor() {\n        _0xd9639c = _0xe6fb61;\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param amounts Array of token amounts to deposit\n     * @param min_mint_amount Minimum LP tokens to mint\n     * @return Amount of LP tokens minted\n     */\n    function _0xcfbb9b(\n        uint256[2] memory _0x23274a,\n        uint256 _0xd131d8\n    ) external payable returns (uint256) {\n        require(_0x23274a[0] == msg.value, \"ETH amount mismatch\");\n\n        // Calculate LP tokens to mint\n        uint256 _0x8ba917;\n        if (_0xc63594 == 0) {\n            _0x8ba917 = _0x23274a[0] + _0x23274a[1];\n        } else {\n            uint256 _0x28ce53 = _0x640a72[0] + _0x640a72[1];\n            _0x8ba917 = ((_0x23274a[0] + _0x23274a[1]) * _0xc63594) / _0x28ce53;\n        }\n\n        require(_0x8ba917 >= _0xd131d8, \"Slippage\");\n\n        // Update balances\n        _0x640a72[0] += _0x23274a[0];\n        _0x640a72[1] += _0x23274a[1];\n\n        // Mint LP tokens\n        _0xd0f9fd[msg.sender] += _0x8ba917;\n        _0xc63594 += _0x8ba917;\n\n        // Handle ETH operations\n        if (_0x23274a[0] > 0) {\n            _0xba0675(_0x23274a[0]);\n        }\n\n        emit LiquidityAdded(msg.sender, _0x23274a, _0x8ba917);\n        return _0x8ba917;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool\n     * @param lpAmount Amount of LP tokens to burn\n     * @param min_amounts Minimum amounts to receive\n     */\n    function _0xc94733(\n        uint256 _0x32d4f6,\n        uint256[2] memory _0x91b01c\n    ) external {\n        require(_0xd0f9fd[msg.sender] >= _0x32d4f6, \"Insufficient LP\");\n\n        // Calculate amounts to return\n        uint256 _0xc81ea7 = (_0x32d4f6 * _0x640a72[0]) / _0xc63594;\n        uint256 _0x1d29ac = (_0x32d4f6 * _0x640a72[1]) / _0xc63594;\n\n        require(\n            _0xc81ea7 >= _0x91b01c[0] && _0x1d29ac >= _0x91b01c[1],\n            \"Slippage\"\n        );\n\n        // Burn LP tokens\n        _0xd0f9fd[msg.sender] -= _0x32d4f6;\n        _0xc63594 -= _0x32d4f6;\n\n        // Update balances\n        _0x640a72[0] -= _0xc81ea7;\n        _0x640a72[1] -= _0x1d29ac;\n\n        // Transfer tokens\n        if (_0xc81ea7 > 0) {\n            payable(msg.sender).transfer(_0xc81ea7);\n        }\n\n        uint256[2] memory _0x23274a = [_0xc81ea7, _0x1d29ac];\n        emit LiquidityRemoved(msg.sender, _0x32d4f6, _0x23274a);\n    }\n\n    /**\n     * @notice Internal function for ETH operations\n     */\n    function _0xba0675(uint256 _0x3a8566) internal {\n        (bool _0x691d5d, ) = msg.sender.call{value: 0}(\"\");\n        require(_0x691d5d, \"Transfer failed\");\n    }\n\n    /**\n     * @notice Exchange tokens\n     * @param i Index of input token\n     * @param j Index of output token\n     * @param dx Input amount\n     * @param min_dy Minimum output amount\n     * @return Output amount\n     */\n    function _0x6e2208(\n        int128 i,\n        int128 j,\n        uint256 _0x428aa4,\n        uint256 _0x6c724d\n    ) external payable returns (uint256) {\n        uint256 _0x797364 = uint256(int256(i));\n        uint256 _0xb1546e = uint256(int256(j));\n\n        require(_0x797364 < 2 && _0xb1546e < 2 && _0x797364 != _0xb1546e, \"Invalid indices\");\n\n        // Calculate output amount\n        uint256 _0xd1c27f = (_0x428aa4 * _0x640a72[_0xb1546e]) / (_0x640a72[_0x797364] + _0x428aa4);\n        require(_0xd1c27f >= _0x6c724d, \"Slippage\");\n\n        if (_0x797364 == 0) {\n            require(msg.value == _0x428aa4, \"ETH mismatch\");\n            _0x640a72[0] += _0x428aa4;\n        }\n\n        _0x640a72[_0x797364] += _0x428aa4;\n        _0x640a72[_0xb1546e] -= _0xd1c27f;\n\n        if (_0xb1546e == 0) {\n            payable(msg.sender).transfer(_0xd1c27f);\n        }\n\n        return _0xd1c27f;\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "_handleETHTransfer": "_0xba0675",
        "remove_liquidity": "_0xc94733",
        "min_mint_amount": "_0xd131d8",
        "add_liquidity": "_0xcfbb9b",
        "totalLPSupply": "_0xc63594",
        "_NOT_ENTERED": "_0xe6fb61",
        "min_amounts": "_0x91b01c",
        "totalValue": "_0x28ce53",
        "lpBalances": "_0xd0f9fd",
        "lpAmount": "_0x32d4f6",
        "exchange": "_0x6e2208",
        "_ENTERED": "_0x42a8fc",
        "balances": "_0x640a72",
        "lpBurned": "_0x90b76c",
        "lpMinted": "_0x6241fa",
        "provider": "_0x92412f",
        "lpToMint": "_0x8ba917",
        "amount1": "_0x1d29ac",
        "_status": "_0xd9639c",
        "success": "_0x691d5d",
        "amounts": "_0x23274a",
        "amount0": "_0xc81ea7",
        "min_dy": "_0x6c724d",
        "amount": "_0x3a8566",
        "dy": "_0xd1c27f",
        "dx": "_0x428aa4",
        "ui": "_0x797364",
        "uj": "_0xb1546e"
      },
      "changes": [
        "Renamed 28 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_006",
      "transformed_id": "ss_l2_hex_sn_tc_006",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Cross-Chain Bridge\n * @notice Processes withdrawals from sidechain to mainnet using multi-sig validation\n * @dev Validators sign withdrawal requests to authorize token transfers\n */\ncontract CrossChainBridge {\n    // Validator addresses\n    address[] public _0x71930a;\n    mapping(address => bool) public _0x079c69;\n\n    uint256 public _0x1d0552 = 5;\n    uint256 public _0x191609;\n\n    // Track processed withdrawals to prevent replay\n    mapping(uint256 => bool) public _0x7b78ae;\n\n    // Supported tokens\n    mapping(address => bool) public _0xa830de;\n\n    event WithdrawalProcessed(\n        uint256 indexed _0x0bfa08,\n        address indexed _0x0029ff,\n        address indexed _0x914bb5,\n        uint256 _0x014f3d\n    );\n\n    constructor(address[] memory _0xc65042) {\n        require(\n            _0xc65042.length >= _0x1d0552,\n            \"Not enough validators\"\n        );\n\n        for (uint256 i = 0; i < _0xc65042.length; i++) {\n            address _0x4bbe28 = _0xc65042[i];\n            require(_0x4bbe28 != address(0), \"Invalid validator\");\n            require(!_0x079c69[_0x4bbe28], \"Duplicate validator\");\n\n            _0x71930a.push(_0x4bbe28);\n            _0x079c69[_0x4bbe28] = true;\n        }\n\n        _0x191609 = _0xc65042.length;\n    }\n\n    /**\n     * @notice Process a withdrawal request\n     * @param _withdrawalId Unique ID for this withdrawal\n     * @param _user Address to receive tokens\n     * @param _token Token contract address\n     * @param _amount Amount to withdraw\n     * @param _signatures Concatenated validator signatures\n     */\n    function _0xe0852a(\n        uint256 _0x9b47a7,\n        address _0xbf24b5,\n        address _0x029180,\n        uint256 _0xb8b7f2,\n        bytes memory _0x460457\n    ) external {\n        // Check if already processed\n        require(!_0x7b78ae[_0x9b47a7], \"Already processed\");\n\n        // Check if token is supported\n        require(_0xa830de[_0x029180], \"Token not supported\");\n\n        // Verify signatures\n        require(\n            _0x90f296(\n                _0x9b47a7,\n                _0xbf24b5,\n                _0x029180,\n                _0xb8b7f2,\n                _0x460457\n            ),\n            \"Invalid signatures\"\n        );\n\n        // Mark as processed\n        _0x7b78ae[_0x9b47a7] = true;\n\n        // Transfer tokens\n        emit WithdrawalProcessed(_0x9b47a7, _0xbf24b5, _0x029180, _0xb8b7f2);\n    }\n\n    /**\n     * @notice Verify validator signatures\n     */\n    function _0x90f296(\n        uint256 _0x9b47a7,\n        address _0xbf24b5,\n        address _0x029180,\n        uint256 _0xb8b7f2,\n        bytes memory _0x460457\n    ) internal view returns (bool) {\n        require(_0x460457.length % 65 == 0, \"Invalid signature length\");\n\n        uint256 _0xe72d86 = _0x460457.length / 65;\n        require(_0xe72d86 >= _0x1d0552, \"Not enough signatures\");\n\n        // Reconstruct the message hash\n        bytes32 _0x8bdd40 = _0x2f11f8(\n            abi._0x875d47(_0x9b47a7, _0xbf24b5, _0x029180, _0xb8b7f2)\n        );\n        bytes32 _0xa0669b = _0x2f11f8(\n            abi._0x875d47(\"\\x19Ethereum Signed Message:\\n32\", _0x8bdd40)\n        );\n\n        address[] memory _0x231485 = new address[](_0xe72d86);\n\n        // Extract and verify each signature\n        for (uint256 i = 0; i < _0xe72d86; i++) {\n            bytes memory _0x0b7e49 = _0xdf1dbb(_0x460457, i);\n            address _0x349fa2 = _0xc42409(_0xa0669b, _0x0b7e49);\n\n            // Check if signer is a validator\n            require(_0x079c69[_0x349fa2], \"Invalid signer\");\n\n            // Check for duplicate signers\n            for (uint256 j = 0; j < i; j++) {\n                require(_0x231485[j] != _0x349fa2, \"Duplicate signer\");\n            }\n\n            _0x231485[i] = _0x349fa2;\n        }\n\n        // All checks passed\n        return true;\n    }\n\n    /**\n     * @notice Extract a single signature from concatenated signatures\n     */\n    function _0xdf1dbb(\n        bytes memory _0x460457,\n        uint256 _0x2a2bcd\n    ) internal pure returns (bytes memory) {\n        bytes memory _0x0b7e49 = new bytes(65);\n        uint256 _0x56c282 = _0x2a2bcd * 65;\n\n        for (uint256 i = 0; i < 65; i++) {\n            _0x0b7e49[i] = _0x460457[_0x56c282 + i];\n        }\n\n        return _0x0b7e49;\n    }\n\n    /**\n     * @notice Recover signer from signature\n     */\n    function _0xc42409(\n        bytes32 _0x5b23bf,\n        bytes memory _0x7c135c\n    ) internal pure returns (address) {\n        require(_0x7c135c.length == 65, \"Invalid signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(_0x7c135c, 32))\n            s := mload(add(_0x7c135c, 64))\n            v := byte(0, mload(add(_0x7c135c, 96)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28, \"Invalid signature v value\");\n\n        return _0x3c820d(_0x5b23bf, v, r, s);\n    }\n\n    /**\n     * @notice Add supported token (admin function)\n     */\n    function _0xf3f5b1(address _0x029180) external {\n        _0xa830de[_0x029180] = true;\n    }\n}\n",
      "rename_map": {
        "ethSignedMessageHash": "_0xa0669b",
        "processedWithdrawals": "_0x7b78ae",
        "requiredSignatures": "_0x1d0552",
        "addSupportedToken": "_0xf3f5b1",
        "_extractSignature": "_0xdf1dbb",
        "_verifySignatures": "_0x90f296",
        "withdrawERC20For": "_0xe0852a",
        "supportedTokens": "_0xa830de",
        "validatorCount": "_0x191609",
        "_recoverSigner": "_0xc42409",
        "signatureCount": "_0xe72d86",
        "_withdrawalId": "_0x9b47a7",
        "encodePacked": "_0x875d47",
        "withdrawalId": "_0x0bfa08",
        "_signatures": "_0x460457",
        "_validators": "_0xc65042",
        "messageHash": "_0x8bdd40",
        "isValidator": "_0x079c69",
        "validators": "_0x71930a",
        "_signature": "_0x7c135c",
        "signature": "_0x0b7e49",
        "validator": "_0x4bbe28",
        "keccak256": "_0x2f11f8",
        "ecrecover": "_0x3c820d",
        "signers": "_0x231485",
        "_amount": "_0xb8b7f2",
        "signer": "_0x349fa2",
        "offset": "_0x56c282",
        "_token": "_0x029180",
        "amount": "_0x014f3d",
        "_index": "_0x2a2bcd",
        "_hash": "_0x5b23bf",
        "_user": "_0xbf24b5",
        "token": "_0x914bb5",
        "user": "_0x0029ff"
      },
      "changes": [
        "Renamed 35 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_007",
      "transformed_id": "ss_l2_hex_sn_tc_007",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Cross-Chain Manager\n * @notice Manages cross-chain message execution between different blockchains\n * @dev Validates headers and executes transactions from source chains\n */\n\ninterface ICrossChainData {\n    function _0x4c7aaa(address _0x92a8bd) external;\n\n    function _0x97c46c(\n        bytes calldata _0x4c42c5\n    ) external returns (bool);\n\n    function _0x6c79b3() external view returns (bytes memory);\n}\n\ncontract CrossChainData {\n    address public _0x62c66f;\n    bytes public _0xa77876;\n\n    event OwnershipTransferred(\n        address indexed _0x419e73,\n        address indexed _0x92a8bd\n    );\n    event PublicKeysUpdated(bytes _0x2519f1);\n\n    constructor() {\n        _0x62c66f = msg.sender;\n    }\n\n    modifier _0xde0c2d() {\n        require(msg.sender == _0x62c66f, \"Not owner\");\n        _;\n    }\n\n    /**\n     * @notice Update validator public keys\n     */\n    function _0x97c46c(\n        bytes calldata _0x4c42c5\n    ) external _0xde0c2d returns (bool) {\n        _0xa77876 = _0x4c42c5;\n        emit PublicKeysUpdated(_0x4c42c5);\n        return true;\n    }\n\n    /**\n     * @notice Transfer ownership\n     */\n    function _0x4c7aaa(address _0x92a8bd) external _0xde0c2d {\n        require(_0x92a8bd != address(0), \"Invalid address\");\n        emit OwnershipTransferred(_0x62c66f, _0x92a8bd);\n        _0x62c66f = _0x92a8bd;\n    }\n\n    function _0x6c79b3() external view returns (bytes memory) {\n        return _0xa77876;\n    }\n}\n\ncontract CrossChainManager {\n    address public _0x95aefc;\n\n    event CrossChainEvent(\n        address indexed _0x9b1c6f,\n        bytes _0xf00693,\n        bytes _0x1b7594\n    );\n\n    constructor(address _0x481147) {\n        _0x95aefc = _0x481147;\n    }\n\n    /**\n     * @notice Verify and execute cross-chain transaction\n     * @param proof Merkle proof of transaction inclusion\n     * @param rawHeader Block header from source chain\n     * @param headerProof Proof of header validity\n     * @param curRawHeader Current header\n     * @param headerSig Validator signatures\n     */\n    function _0x1170c9(\n        bytes memory _0xa72759,\n        bytes memory _0xc78bb1,\n        bytes memory _0x099c71,\n        bytes memory _0x3bd36b,\n        bytes memory _0x3a8e62\n    ) external returns (bool) {\n        // Step 1: Verify the block header is valid\n        require(_0xbd9b5a(_0xc78bb1, _0x3a8e62), \"Invalid header\");\n\n        // Step 2: Verify the transaction was included in that block\n        require(_0x9d72c6(_0xa72759, _0xc78bb1), \"Invalid proof\");\n\n        // Step 3: Decode the transaction data\n        (\n            address _0xf00693,\n            bytes memory _0x1b7594,\n            bytes memory _0x341a62\n        ) = _0xa491ea(_0xa72759);\n\n        // Execute the transaction\n        (bool _0x9e7721, ) = _0xf00693.call(abi._0xa33739(_0x1b7594, _0x341a62));\n        require(_0x9e7721, \"Execution failed\");\n\n        return true;\n    }\n\n    /**\n     * @notice Verify block header signatures\n     */\n    function _0xbd9b5a(\n        bytes memory _0xc78bb1,\n        bytes memory _0x3a8e62\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Verify Merkle proof\n     */\n    function _0x9d72c6(\n        bytes memory _0xa72759,\n        bytes memory _0xc78bb1\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Decode transaction data\n     */\n    function _0xa491ea(\n        bytes memory _0xa72759\n    )\n        internal\n        view\n        returns (address _0xf00693, bytes memory _0x1b7594, bytes memory _0x341a62)\n    {\n        _0xf00693 = _0x95aefc;\n        _0x1b7594 = abi._0x249dd0(\n            \"putCurEpochConPubKeyBytes(bytes)\",\n            \"\"\n        );\n        _0x341a62 = \"\";\n    }\n}\n",
      "rename_map": {
        "putCurEpochConPubKeyBytes": "_0x97c46c",
        "getCurEpochConPubKeyBytes": "_0x6c79b3",
        "verifyHeaderAndExecuteTx": "_0x1170c9",
        "currentEpochPublicKeys": "_0xa77876",
        "encodeWithSignature": "_0x249dd0",
        "transferOwnership": "_0x4c7aaa",
        "curEpochPkBytes": "_0x4c42c5",
        "_verifyHeader": "_0xbd9b5a",
        "previousOwner": "_0x419e73",
        "_dataContract": "_0x481147",
        "fromContract": "_0x9b1c6f",
        "encodePacked": "_0xa33739",
        "dataContract": "_0x95aefc",
        "curRawHeader": "_0x3bd36b",
        "_verifyProof": "_0x9d72c6",
        "headerProof": "_0x099c71",
        "toContract": "_0xf00693",
        "headerSig": "_0x3a8e62",
        "_decodeTx": "_0xa491ea",
        "rawHeader": "_0xc78bb1",
        "onlyOwner": "_0xde0c2d",
        "newOwner": "_0x92a8bd",
        "success": "_0x9e7721",
        "newKeys": "_0x2519f1",
        "method": "_0x1b7594",
        "owner": "_0x62c66f",
        "proof": "_0xa72759",
        "args": "_0x341a62"
      },
      "changes": [
        "Renamed 28 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_008",
      "transformed_id": "ss_l2_hex_sn_tc_008",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Lending Protocol\n * @notice Decentralized lending and borrowing platform\n * @dev Users can deposit collateral and borrow against it\n */\n\ninterface IOracle {\n    function _0xd74c84(address _0xb2fecd) external view returns (uint256);\n}\n\ninterface ICToken {\n    function _0xe34ab4(uint256 _0x3596fa) external;\n\n    function _0xb5e9c5(uint256 _0x4790dc) external;\n\n    function _0x9e43ad(uint256 _0x5e4761) external;\n\n    function _0xa1c7d2() external view returns (address);\n}\n\ncontract LendingProtocol {\n    // Oracle for getting asset prices\n    IOracle public _0x5e72f1;\n\n    // Collateral factors\n    mapping(address => uint256) public _0xd8ff41;\n\n    // User deposits (cToken balances)\n    mapping(address => mapping(address => uint256)) public _0x0d9c2d;\n\n    // User borrows\n    mapping(address => mapping(address => uint256)) public _0x950fd9;\n\n    // Supported markets\n    mapping(address => bool) public _0xac7e27;\n\n    event Deposit(address indexed _0xced3df, address indexed _0xb2fecd, uint256 _0x1dbf43);\n    event Borrow(address indexed _0xced3df, address indexed _0xb2fecd, uint256 _0x1dbf43);\n\n    constructor(address _0x674ef7) {\n        _0x5e72f1 = IOracle(_0x674ef7);\n    }\n\n    /**\n     * @notice Mint cTokens by depositing underlying assets\n     * @param cToken The cToken to mint\n     * @param amount Amount of underlying to deposit\n     */\n    function _0xe34ab4(address _0xb2fecd, uint256 _0x1dbf43) external {\n        require(_0xac7e27[_0xb2fecd], \"Market not supported\");\n\n        // Mint cTokens to user\n        _0x0d9c2d[msg.sender][_0xb2fecd] += _0x1dbf43;\n\n        emit Deposit(msg.sender, _0xb2fecd, _0x1dbf43);\n    }\n\n    /**\n     * @notice Borrow assets against collateral\n     * @param cToken The cToken to borrow\n     * @param amount Amount to borrow\n     */\n    function _0xb5e9c5(address _0xb2fecd, uint256 _0x1dbf43) external {\n        require(_0xac7e27[_0xb2fecd], \"Market not supported\");\n\n        // Calculate user's borrowing power\n        uint256 _0x35ae43 = _0xef3338(msg.sender);\n\n        // Calculate current total borrows value\n        uint256 _0x94133e = _0xfabd1c(msg.sender);\n\n        // Get value of new borrow\n        uint256 _0xad4112 = (_0x5e72f1._0xd74c84(_0xb2fecd) * _0x1dbf43) /\n            1e18;\n\n        // Check if user has enough collateral\n        require(\n            _0x94133e + _0xad4112 <= _0x35ae43,\n            \"Insufficient collateral\"\n        );\n\n        // Update borrow balance\n        _0x950fd9[msg.sender][_0xb2fecd] += _0x1dbf43;\n\n        emit Borrow(msg.sender, _0xb2fecd, _0x1dbf43);\n    }\n\n    /**\n     * @notice Calculate user's total borrowing power\n     * @param user The user address\n     * @return Total borrowing power in USD\n     */\n    function _0xef3338(address _0xced3df) public view returns (uint256) {\n        uint256 _0x55827d = 0;\n\n        address[] memory _0xaf780f = new address[](2);\n\n        for (uint256 i = 0; i < _0xaf780f.length; i++) {\n            address _0xb2fecd = _0xaf780f[i];\n            uint256 balance = _0x0d9c2d[_0xced3df][_0xb2fecd];\n\n            if (balance > 0) {\n                // Get price from oracle\n                uint256 _0xac212f = _0x5e72f1._0xd74c84(_0xb2fecd);\n\n                // Calculate value\n                uint256 value = (balance * _0xac212f) / 1e18;\n\n                // Apply collateral factor\n                uint256 _0x6e66b5 = (value * _0xd8ff41[_0xb2fecd]) / 1e18;\n\n                _0x55827d += _0x6e66b5;\n            }\n        }\n\n        return _0x55827d;\n    }\n\n    /**\n     * @notice Calculate user's total borrow value\n     * @param user The user address\n     * @return Total borrow value in USD\n     */\n    function _0xfabd1c(address _0xced3df) public view returns (uint256) {\n        uint256 _0x323dcd = 0;\n\n        address[] memory _0xaf780f = new address[](2);\n\n        for (uint256 i = 0; i < _0xaf780f.length; i++) {\n            address _0xb2fecd = _0xaf780f[i];\n            uint256 _0x1f75bb = _0x950fd9[_0xced3df][_0xb2fecd];\n\n            if (_0x1f75bb > 0) {\n                uint256 _0xac212f = _0x5e72f1._0xd74c84(_0xb2fecd);\n                uint256 value = (_0x1f75bb * _0xac212f) / 1e18;\n                _0x323dcd += value;\n            }\n        }\n\n        return _0x323dcd;\n    }\n\n    /**\n     * @notice Add a supported market\n     * @param cToken The cToken to add\n     * @param collateralFactor The collateral factor\n     */\n    function _0xe99843(address _0xb2fecd, uint256 _0x99e7be) external {\n        _0xac7e27[_0xb2fecd] = true;\n        _0xd8ff41[_0xb2fecd] = _0x99e7be;\n    }\n}\n",
      "rename_map": {
        "calculateTotalBorrows": "_0xfabd1c",
        "calculateBorrowPower": "_0xef3338",
        "getUnderlyingPrice": "_0xd74c84",
        "collateralFactors": "_0xd8ff41",
        "supportedMarkets": "_0xac7e27",
        "collateralFactor": "_0x99e7be",
        "currentBorrows": "_0x94133e",
        "totalBorrows": "_0x323dcd",
        "userDeposits": "_0x0d9c2d",
        "redeemTokens": "_0x5e4761",
        "borrowAmount": "_0x4790dc",
        "userBorrows": "_0x950fd9",
        "borrowValue": "_0xad4112",
        "borrowPower": "_0x35ae43",
        "totalPower": "_0x55827d",
        "mintAmount": "_0x3596fa",
        "underlying": "_0xa1c7d2",
        "addMarket": "_0xe99843",
        "borrowed": "_0x1f75bb",
        "_oracle": "_0x674ef7",
        "markets": "_0xaf780f",
        "cToken": "_0xb2fecd",
        "redeem": "_0x9e43ad",
        "oracle": "_0x5e72f1",
        "borrow": "_0xb5e9c5",
        "amount": "_0x1dbf43",
        "power": "_0x6e66b5",
        "price": "_0xac212f",
        "mint": "_0xe34ab4",
        "user": "_0xced3df"
      },
      "changes": [
        "Renamed 30 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_009",
      "transformed_id": "ss_l2_hex_sn_tc_009",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Concentrated Liquidity AMM Pool\n * @notice Automated market maker with concentrated liquidity positions\n * @dev Allows liquidity providers to concentrate capital at specific price ranges\n */\ncontract ConcentratedLiquidityPool {\n    // Token addresses\n    address public _0x27a664;\n    address public _0xa8102b;\n\n    // Current state\n    uint160 public _0x68d086;\n    int24 public _0x8b279f;\n    uint128 public _0xf0eca3;\n\n    // Liquidity at each tick\n    mapping(int24 => int128) public _0x76c2d3;\n\n    // Position tracking\n    struct Position {\n        uint128 _0xf0eca3;\n        int24 _0x52865d;\n        int24 _0x4b5c49;\n    }\n\n    mapping(bytes32 => Position) public _0x7e69fa;\n\n    event Swap(\n        address indexed sender,\n        uint256 _0xa03df3,\n        uint256 _0x2474b9,\n        uint256 _0x32c510,\n        uint256 _0x5705b2\n    );\n\n    event LiquidityAdded(\n        address indexed _0x18246a,\n        int24 _0x52865d,\n        int24 _0x4b5c49,\n        uint128 _0xf0eca3\n    );\n\n    /**\n     * @notice Add liquidity to a price range\n     * @param tickLower Lower tick of range\n     * @param tickUpper Upper tick of range\n     * @param liquidityDelta Amount of liquidity to add\n     */\n    function _0x22d025(\n        int24 _0x52865d,\n        int24 _0x4b5c49,\n        uint128 _0xad9bf3\n    ) external returns (uint256 _0xb3704d, uint256 _0x086425) {\n        require(_0x52865d < _0x4b5c49, \"Invalid ticks\");\n        require(_0xad9bf3 > 0, \"Zero liquidity\");\n\n        // Create position ID\n        bytes32 _0x0c8c5c = _0x60dcdb(\n            abi._0x2d521d(msg.sender, _0x52865d, _0x4b5c49)\n        );\n\n        // Update position\n        Position storage _0x58dfe2 = _0x7e69fa[_0x0c8c5c];\n        _0x58dfe2._0xf0eca3 += _0xad9bf3;\n        _0x58dfe2._0x52865d = _0x52865d;\n        _0x58dfe2._0x4b5c49 = _0x4b5c49;\n\n        // Update tick liquidity\n        _0x76c2d3[_0x52865d] += int128(_0xad9bf3);\n        _0x76c2d3[_0x4b5c49] -= int128(_0xad9bf3);\n\n        // If current price is in range, update active liquidity\n        if (_0x8b279f >= _0x52865d && _0x8b279f < _0x4b5c49) {\n            _0xf0eca3 += _0xad9bf3;\n        }\n\n        // Calculate required amounts\n        (_0xb3704d, _0x086425) = _0xea51ab(\n            _0x68d086,\n            _0x52865d,\n            _0x4b5c49,\n            int128(_0xad9bf3)\n        );\n\n        emit LiquidityAdded(msg.sender, _0x52865d, _0x4b5c49, _0xad9bf3);\n    }\n\n    /**\n     * @notice Execute a swap\n     * @param zeroForOne Direction of swap\n     * @param amountSpecified Amount to swap\n     * @param sqrtPriceLimitX96 Price limit for the swap\n     */\n    function _0x6fb62d(\n        bool _0x1920f7,\n        int256 _0x934dc9,\n        uint160 _0x77dc4f\n    ) external returns (int256 _0xb3704d, int256 _0x086425) {\n        require(_0x934dc9 != 0, \"Zero amount\");\n\n        // Swap state\n        uint160 _0x9976d9 = _0x68d086;\n        uint128 _0x750f41 = _0xf0eca3;\n        int24 _0x350e8d = _0x8b279f;\n\n        // Simulate swap steps\n        while (_0x934dc9 != 0) {\n            // Calculate how much can be swapped in current tick\n            (\n                uint256 _0x214261,\n                uint256 _0x664e41,\n                uint160 _0xbdd765\n            ) = _0x0a817d(\n                    _0x9976d9,\n                    _0x77dc4f,\n                    _0x750f41,\n                    _0x934dc9\n                );\n\n            // Update price\n            _0x9976d9 = _0xbdd765;\n\n            // Check if we crossed a tick\n            int24 _0x339811 = _0xd336a0(_0x9976d9);\n            if (_0x339811 != _0x350e8d) {\n                // Tick crossing involves liquidity updates\n                int128 _0x8bf548 = _0x76c2d3[_0x339811];\n\n                if (_0x1920f7) {\n                    _0x8bf548 = -_0x8bf548;\n                }\n\n                _0x750f41 = _0x25346f(\n                    _0x750f41,\n                    _0x8bf548\n                );\n\n                _0x350e8d = _0x339811;\n            }\n\n            // Update remaining amount\n            if (_0x934dc9 > 0) {\n                _0x934dc9 -= int256(_0x214261);\n            } else {\n                _0x934dc9 += int256(_0x664e41);\n            }\n        }\n\n        // Update state\n        _0x68d086 = _0x9976d9;\n        _0xf0eca3 = _0x750f41;\n        _0x8b279f = _0x350e8d;\n\n        return (_0xb3704d, _0x086425);\n    }\n\n    /**\n     * @notice Add signed liquidity value\n     */\n    function _0x25346f(\n        uint128 x,\n        int128 y\n    ) internal pure returns (uint128 z) {\n        if (y < 0) {\n            z = x - uint128(-y);\n        } else {\n            z = x + uint128(y);\n        }\n    }\n\n    /**\n     * @notice Calculate amounts for liquidity\n     */\n    function _0xea51ab(\n        uint160 _0x06f4f1,\n        int24 _0x52865d,\n        int24 _0x4b5c49,\n        int128 _0xad9bf3\n    ) internal pure returns (uint256 _0xb3704d, uint256 _0x086425) {\n        _0xb3704d = uint256(uint128(_0xad9bf3)) / 2;\n        _0x086425 = uint256(uint128(_0xad9bf3)) / 2;\n    }\n\n    /**\n     * @notice Compute single swap step\n     */\n    function _0x0a817d(\n        uint160 _0xc0109a,\n        uint160 _0x3a9687,\n        uint128 _0x0e680a,\n        int256 _0x81aebe\n    )\n        internal\n        pure\n        returns (uint256 _0x214261, uint256 _0x664e41, uint160 _0x9711ff)\n    {\n        _0x214261 =\n            uint256(_0x81aebe > 0 ? _0x81aebe : -_0x81aebe) /\n            2;\n        _0x664e41 = _0x214261;\n        _0x9711ff = _0xc0109a;\n    }\n\n    /**\n     * @notice Get tick at sqrt ratio\n     */\n    function _0xd336a0(\n        uint160 _0x68d086\n    ) internal pure returns (int24 _0xa96e21) {\n        return int24(int256(uint256(_0x68d086 >> 96)));\n    }\n}\n",
      "rename_map": {
        "sqrtPriceCurrentX96": "_0xc0109a",
        "_getTickAtSqrtRatio": "_0xd336a0",
        "liquidityNetAtTick": "_0x8bf548",
        "sqrtPriceX96Target": "_0xbdd765",
        "sqrtPriceTargetX96": "_0x3a9687",
        "sqrtPriceLimitX96": "_0x77dc4f",
        "_calculateAmounts": "_0xea51ab",
        "sqrtPriceX96Next": "_0x9976d9",
        "liquidityCurrent": "_0x0e680a",
        "_computeSwapStep": "_0x0a817d",
        "sqrtPriceNextX96": "_0x9711ff",
        "amountSpecified": "_0x934dc9",
        "amountRemaining": "_0x81aebe",
        "liquidityDelta": "_0xad9bf3",
        "liquidityNext": "_0x750f41",
        "_addLiquidity": "_0x25346f",
        "addLiquidity": "_0x22d025",
        "encodePacked": "_0x2d521d",
        "liquidityNet": "_0x76c2d3",
        "sqrtPriceX96": "_0x68d086",
        "currentTick": "_0x8b279f",
        "positionKey": "_0x0c8c5c",
        "tickCrossed": "_0x339811",
        "amount1Out": "_0x5705b2",
        "amount0Out": "_0x32c510",
        "zeroForOne": "_0x1920f7",
        "tickLower": "_0x52865d",
        "amountOut": "_0x664e41",
        "sqrtPrice": "_0x06f4f1",
        "positions": "_0x7e69fa",
        "amount0In": "_0xa03df3",
        "keccak256": "_0x60dcdb",
        "liquidity": "_0xf0eca3",
        "tickUpper": "_0x4b5c49",
        "amount1In": "_0x2474b9",
        "amountIn": "_0x214261",
        "position": "_0x58dfe2",
        "provider": "_0x18246a",
        "tickNext": "_0x350e8d",
        "amount1": "_0x086425",
        "amount0": "_0xb3704d",
        "token0": "_0x27a664",
        "token1": "_0xa8102b",
        "swap": "_0x6fb62d",
        "tick": "_0xa96e21"
      },
      "changes": [
        "Renamed 45 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_010",
      "transformed_id": "ss_l2_hex_sn_tc_010",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\n/**\n * @title Credit System Contract\n * @notice Manages deposits and withdrawals\n */\ncontract CreditSystem {\n    mapping(address => uint256) public _0xa2f731;\n    uint256 public balance;\n\n    function _0xc5e1eb() public payable {\n        _0xa2f731[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n\n    function _0xab6bb5() public {\n        uint256 _0x343fe5 = _0xa2f731[msg.sender];\n        if (_0x343fe5 > 0) {\n            balance -= _0x343fe5;\n            bool _0xd16516 = msg.sender.call.value(_0x343fe5)();\n            require(_0xd16516);\n            _0xa2f731[msg.sender] = 0;\n        }\n    }\n\n    function _0x6c78b9(address _0xacc323) public view returns (uint256) {\n        return _0xa2f731[_0xacc323];\n    }\n}\n",
      "rename_map": {
        "withdrawAll": "_0xab6bb5",
        "callResult": "_0xd16516",
        "getCredit": "_0x6c78b9",
        "deposit": "_0xc5e1eb",
        "oCredit": "_0x343fe5",
        "credit": "_0xa2f731",
        "user": "_0xacc323"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_011",
      "transformed_id": "ss_l2_hex_sn_tc_011",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Lending Pool Contract\n * @notice Manages token supplies and withdrawals\n */\n\ninterface IERC777 {\n    function transfer(address _0x3a359a, uint256 _0x3b573c) external returns (bool);\n\n    function _0x37f56b(address _0x548786) external view returns (uint256);\n}\n\ninterface IERC1820Registry {\n    function _0xbec2f6(\n        address _0x548786,\n        bytes32 _0xc9af49,\n        address _0x263577\n    ) external;\n}\n\ncontract LendingPool {\n    mapping(address => mapping(address => uint256)) public _0x0ca902;\n    mapping(address => uint256) public _0xe0d149;\n\n    function _0xc26840(address _0xce1c75, uint256 _0x3b573c) external returns (uint256) {\n        IERC777 _0x75c112 = IERC777(_0xce1c75);\n\n        require(_0x75c112.transfer(address(this), _0x3b573c), \"Transfer failed\");\n\n        _0x0ca902[msg.sender][_0xce1c75] += _0x3b573c;\n        _0xe0d149[_0xce1c75] += _0x3b573c;\n\n        return _0x3b573c;\n    }\n\n    function _0x8bd704(\n        address _0xce1c75,\n        uint256 _0x561aea\n    ) external returns (uint256) {\n        uint256 _0x7345f4 = _0x0ca902[msg.sender][_0xce1c75];\n        require(_0x7345f4 > 0, \"No balance\");\n\n        uint256 _0x337e94 = _0x561aea;\n        if (_0x561aea == type(uint256)._0xf280a0) {\n            _0x337e94 = _0x7345f4;\n        }\n        require(_0x337e94 <= _0x7345f4, \"Insufficient balance\");\n\n        IERC777(_0xce1c75).transfer(msg.sender, _0x337e94);\n\n        _0x0ca902[msg.sender][_0xce1c75] -= _0x337e94;\n        _0xe0d149[_0xce1c75] -= _0x337e94;\n\n        return _0x337e94;\n    }\n\n    function _0x96fa58(\n        address _0xc1cce7,\n        address _0xce1c75\n    ) external view returns (uint256) {\n        return _0x0ca902[_0xc1cce7][_0xce1c75];\n    }\n}\n",
      "rename_map": {
        "setInterfaceImplementer": "_0xbec2f6",
        "requestedAmount": "_0x561aea",
        "withdrawAmount": "_0x337e94",
        "interfaceHash": "_0xc9af49",
        "totalSupplied": "_0xe0d149",
        "getSupplied": "_0x96fa58",
        "implementer": "_0x263577",
        "userBalance": "_0x7345f4",
        "balanceOf": "_0x37f56b",
        "withdraw": "_0x8bd704",
        "supplied": "_0x0ca902",
        "account": "_0x548786",
        "supply": "_0xc26840",
        "amount": "_0x3b573c",
        "asset": "_0xce1c75",
        "token": "_0x75c112",
        "user": "_0xc1cce7",
        "max": "_0xf280a0",
        "to": "_0x3a359a"
      },
      "changes": [
        "Renamed 19 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_012",
      "transformed_id": "ss_l2_hex_sn_tc_012",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Lending Protocol\n * @notice Manages collateral deposits and borrowing\n */\n\ninterface IComptroller {\n    function _0x8a78d0(\n        address[] memory _0x36b82d\n    ) external returns (uint256[] memory);\n\n    function _0xeb1f15(address _0xd9bf44) external returns (uint256);\n\n    function _0x9acd82(\n        address _0xb8a1a9\n    ) external view returns (uint256, uint256, uint256);\n}\n\ncontract LendingProtocol {\n    IComptroller public _0x76e8f5;\n\n    mapping(address => uint256) public _0x5692e8;\n    mapping(address => uint256) public _0x56e4d8;\n    mapping(address => bool) public _0xe04bea;\n\n    uint256 public _0x90bd85;\n    uint256 public _0x28f713;\n    uint256 public constant COLLATERAL_FACTOR = 150;\n\n    constructor(address _0x180a34) {\n        _0x76e8f5 = IComptroller(_0x180a34);\n    }\n\n    function _0xad6622() external payable {\n        _0x5692e8[msg.sender] += msg.value;\n        _0x90bd85 += msg.value;\n        _0xe04bea[msg.sender] = true;\n    }\n\n    function _0x185bf4(\n        address _0xb8a1a9,\n        uint256 _0x484841\n    ) public view returns (bool) {\n        uint256 _0x057920 = _0x56e4d8[_0xb8a1a9] + _0x484841;\n        if (_0x057920 == 0) return true;\n\n        if (!_0xe04bea[_0xb8a1a9]) return false;\n\n        uint256 _0x041d26 = _0x5692e8[_0xb8a1a9];\n        return _0x041d26 >= (_0x057920 * COLLATERAL_FACTOR) / 100;\n    }\n\n    function _0x68ca45(uint256 _0x68ead9) external {\n        require(_0x68ead9 > 0, \"Invalid amount\");\n        require(address(this).balance >= _0x68ead9, \"Insufficient funds\");\n\n        require(_0x185bf4(msg.sender, _0x68ead9), \"Insufficient collateral\");\n\n        _0x56e4d8[msg.sender] += _0x68ead9;\n        _0x28f713 += _0x68ead9;\n\n        (bool _0x0c2e8d, ) = payable(msg.sender).call{value: _0x68ead9}(\"\");\n        require(_0x0c2e8d, \"Transfer failed\");\n\n        require(_0x185bf4(msg.sender, 0), \"Health check failed\");\n    }\n\n    function _0xeb1f15() external {\n        require(_0x56e4d8[msg.sender] == 0, \"Outstanding debt\");\n        _0xe04bea[msg.sender] = false;\n    }\n\n    function _0x81fce0(uint256 _0x68ead9) external {\n        require(_0x5692e8[msg.sender] >= _0x68ead9, \"Insufficient deposits\");\n        require(!_0xe04bea[msg.sender], \"Exit market first\");\n\n        _0x5692e8[msg.sender] -= _0x68ead9;\n        _0x90bd85 -= _0x68ead9;\n\n        payable(msg.sender).transfer(_0x68ead9);\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "depositAndEnterMarket": "_0xad6622",
        "getAccountLiquidity": "_0x9acd82",
        "additionalBorrow": "_0x484841",
        "collateralValue": "_0x041d26",
        "totalBorrowed": "_0x28f713",
        "totalDeposits": "_0x90bd85",
        "_comptroller": "_0x180a34",
        "enterMarkets": "_0x8a78d0",
        "comptroller": "_0x76e8f5",
        "exitMarket": "_0xeb1f15",
        "isHealthy": "_0x185bf4",
        "totalDebt": "_0x057920",
        "deposits": "_0x5692e8",
        "inMarket": "_0xe04bea",
        "withdraw": "_0x81fce0",
        "borrowed": "_0x56e4d8",
        "cTokens": "_0x36b82d",
        "account": "_0xb8a1a9",
        "success": "_0x0c2e8d",
        "cToken": "_0xd9bf44",
        "borrow": "_0x68ca45",
        "amount": "_0x68ead9"
      },
      "changes": [
        "Renamed 22 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_013",
      "transformed_id": "ss_l2_hex_sn_tc_013",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Reward Minter Contract\n * @notice Manages LP token deposits and reward minting\n */\n\ninterface IERC20 {\n    function transfer(address _0x63358d, uint256 _0x2a22b0) external returns (bool);\n\n    function _0x04c62c(\n        address from,\n        address _0x63358d,\n        uint256 _0x2a22b0\n    ) external returns (bool);\n\n    function _0xd1b0ca(address _0xe8b8a5) external view returns (uint256);\n}\n\ninterface IPancakeRouter {\n    function _0x050070(\n        uint _0xb73dcd,\n        uint _0xd924cb,\n        address[] calldata _0x47705b,\n        address _0x63358d,\n        uint _0x4293c7\n    ) external returns (uint[] memory _0xda21a6);\n}\n\ncontract RewardMinter {\n    IERC20 public _0x59e6f2;\n    IERC20 public _0x2aef9b;\n\n    mapping(address => uint256) public _0xff74c4;\n    mapping(address => uint256) public _0x1f4192;\n\n    uint256 public constant REWARD_RATE = 100;\n\n    constructor(address _0x4b0e7a, address _0xc09514) {\n        _0x59e6f2 = IERC20(_0x4b0e7a);\n        _0x2aef9b = IERC20(_0xc09514);\n    }\n\n    function _0xff302f(uint256 _0x2a22b0) external {\n        _0x59e6f2._0x04c62c(msg.sender, address(this), _0x2a22b0);\n        _0xff74c4[msg.sender] += _0x2a22b0;\n    }\n\n    function _0x785886(\n        address _0x15d265,\n        uint256 _0xc21c21,\n        uint256 _0x4a3621,\n        address _0x63358d,\n        uint256\n    ) external {\n        require(_0x15d265 == address(_0x59e6f2), \"Invalid token\");\n\n        uint256 _0x8c468b = _0x4a3621 + _0xc21c21;\n        _0x59e6f2._0x04c62c(msg.sender, address(this), _0x8c468b);\n\n        uint256 _0xd2ada0 = _0x0f84bb(\n            _0x59e6f2._0xd1b0ca(address(this))\n        );\n\n        _0x1f4192[_0x63358d] += _0xd2ada0;\n    }\n\n    function _0x0f84bb(uint256 _0xecfbf6) internal pure returns (uint256) {\n        return _0xecfbf6 * REWARD_RATE;\n    }\n\n    function _0xa21c62() external {\n        uint256 _0x1b555c = _0x1f4192[msg.sender];\n        require(_0x1b555c > 0, \"No rewards\");\n\n        _0x1f4192[msg.sender] = 0;\n        _0x2aef9b.transfer(msg.sender, _0x1b555c);\n    }\n\n    function _0xf02052(uint256 _0x2a22b0) external {\n        require(_0xff74c4[msg.sender] >= _0x2a22b0, \"Insufficient balance\");\n        _0xff74c4[msg.sender] -= _0x2a22b0;\n        _0x59e6f2.transfer(msg.sender, _0x2a22b0);\n    }\n}\n",
      "rename_map": {
        "swapExactTokensForTokens": "_0x050070",
        "hunnyRewardAmount": "_0xd2ada0",
        "_performanceFee": "_0x4a3621",
        "_withdrawalFee": "_0xc21c21",
        "tokenToReward": "_0x0f84bb",
        "earnedRewards": "_0x1f4192",
        "transferFrom": "_0x04c62c",
        "_rewardToken": "_0xc09514",
        "depositedLP": "_0xff74c4",
        "rewardToken": "_0x2aef9b",
        "balanceOf": "_0xd1b0ca",
        "getReward": "_0xa21c62",
        "amountOut": "_0xd924cb",
        "lpAmount": "_0xecfbf6",
        "deadline": "_0x4293c7",
        "amountIn": "_0xb73dcd",
        "_lpToken": "_0x4b0e7a",
        "withdraw": "_0xf02052",
        "mintFor": "_0x785886",
        "account": "_0xe8b8a5",
        "amounts": "_0xda21a6",
        "deposit": "_0xff302f",
        "lpToken": "_0x59e6f2",
        "feeSum": "_0x8c468b",
        "amount": "_0x2a22b0",
        "reward": "_0x1b555c",
        "flip": "_0x15d265",
        "path": "_0x47705b",
        "to": "_0x63358d"
      },
      "changes": [
        "Renamed 29 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_014",
      "transformed_id": "ss_l2_hex_sn_tc_014",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Vault Strategy Contract\n * @notice Manages deposits and automated yield strategies\n */\n\ninterface ICurve3Pool {\n    function _0x37e09d(\n        uint256[3] memory _0xc82929,\n        uint256 _0x19cb60\n    ) external;\n\n    function _0x99ccf7(\n        uint256[3] memory _0xc82929,\n        uint256 _0x8ca107\n    ) external;\n\n    function _0x9f5fb3() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function transfer(address _0xaf8f10, uint256 _0x2c4619) external returns (bool);\n\n    function _0x23d958(\n        address from,\n        address _0xaf8f10,\n        uint256 _0x2c4619\n    ) external returns (bool);\n\n    function _0xecc4a9(address _0x352b09) external view returns (uint256);\n\n    function _0x2562da(address _0x197248, uint256 _0x2c4619) external returns (bool);\n}\n\ncontract YieldVault {\n    IERC20 public _0xaeab52;\n    IERC20 public _0xf4eb14;\n    ICurve3Pool public _0xbe436a;\n\n    mapping(address => uint256) public _0x1fb273;\n    uint256 public _0x3e4f68;\n    uint256 public _0x42432c;\n\n    uint256 public constant MIN_EARN_THRESHOLD = 1000 ether;\n\n    constructor(address _0xd0cf73, address _0x6ecbbb, address _0xb5d0e3) {\n        _0xaeab52 = IERC20(_0xd0cf73);\n        _0xf4eb14 = IERC20(_0x6ecbbb);\n        _0xbe436a = ICurve3Pool(_0xb5d0e3);\n    }\n\n    function _0xd40a0e(uint256 _0x2c4619) external {\n        _0xaeab52._0x23d958(msg.sender, address(this), _0x2c4619);\n\n        uint256 _0xd0e658;\n        if (_0x3e4f68 == 0) {\n            _0xd0e658 = _0x2c4619;\n        } else {\n            _0xd0e658 = (_0x2c4619 * _0x3e4f68) / _0x42432c;\n        }\n\n        _0x1fb273[msg.sender] += _0xd0e658;\n        _0x3e4f68 += _0xd0e658;\n        _0x42432c += _0x2c4619;\n    }\n\n    function _0x0a7b1b() external {\n        uint256 _0x1b1c0e = _0xaeab52._0xecc4a9(address(this));\n        require(\n            _0x1b1c0e >= MIN_EARN_THRESHOLD,\n            \"Insufficient balance to earn\"\n        );\n\n        uint256 _0xfcf95d = _0xbe436a._0x9f5fb3();\n\n        _0xaeab52._0x2562da(address(_0xbe436a), _0x1b1c0e);\n        uint256[3] memory _0xc82929 = [_0x1b1c0e, 0, 0];\n        _0xbe436a._0x37e09d(_0xc82929, 0);\n    }\n\n    function _0x87582e() external {\n        uint256 _0x7f8e58 = _0x1fb273[msg.sender];\n        require(_0x7f8e58 > 0, \"No shares\");\n\n        uint256 _0xbd7927 = (_0x7f8e58 * _0x42432c) / _0x3e4f68;\n\n        _0x1fb273[msg.sender] = 0;\n        _0x3e4f68 -= _0x7f8e58;\n        _0x42432c -= _0xbd7927;\n\n        _0xaeab52.transfer(msg.sender, _0xbd7927);\n    }\n\n    function balance() public view returns (uint256) {\n        return\n            _0xaeab52._0xecc4a9(address(this)) +\n            (_0xf4eb14._0xecc4a9(address(this)) * _0xbe436a._0x9f5fb3()) /\n            1e18;\n    }\n}\n",
      "rename_map": {
        "remove_liquidity_imbalance": "_0x99ccf7",
        "get_virtual_price": "_0x9f5fb3",
        "min_mint_amount": "_0x19cb60",
        "max_burn_amount": "_0x8ca107",
        "withdrawAmount": "_0xbd7927",
        "add_liquidity": "_0x37e09d",
        "totalDeposits": "_0x42432c",
        "transferFrom": "_0x23d958",
        "vaultBalance": "_0x1b1c0e",
        "virtualPrice": "_0xfcf95d",
        "withdrawAll": "_0x87582e",
        "_curve3Pool": "_0xb5d0e3",
        "shareAmount": "_0xd0e658",
        "totalShares": "_0x3e4f68",
        "curve3Pool": "_0xbe436a",
        "userShares": "_0x7f8e58",
        "balanceOf": "_0xecc4a9",
        "account": "_0x352b09",
        "spender": "_0x197248",
        "approve": "_0x2562da",
        "amounts": "_0xc82929",
        "deposit": "_0xd40a0e",
        "shares": "_0x1fb273",
        "amount": "_0x2c4619",
        "_crv3": "_0x6ecbbb",
        "crv3": "_0xf4eb14",
        "_dai": "_0xd0cf73",
        "earn": "_0x0a7b1b",
        "dai": "_0xaeab52",
        "to": "_0xaf8f10"
      },
      "changes": [
        "Renamed 30 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_015",
      "transformed_id": "ss_l2_hex_sn_tc_015",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Compound Market Token\n * @notice Represents claims on supplied assets\n */\n\ninterface IERC20 {\n    function transfer(address _0x616f6e, uint256 _0x0fb48f) external returns (bool);\n\n    function _0x4c2045(address _0xafa535) external view returns (uint256);\n}\n\ncontract CompoundMarket {\n    address public _0xd5272e;\n    address public _0x6866ee;\n\n    mapping(address => uint256) public _0x9bfdc2;\n    uint256 public _0x113090;\n\n    address public constant OLD_TUSD =\n        0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;\n    address public constant NEW_TUSD =\n        0x0000000000085d4780B73119b644AE5ecd22b376;\n\n    constructor() {\n        _0x6866ee = msg.sender;\n        _0xd5272e = OLD_TUSD;\n    }\n\n    function _0x6cc41f(uint256 _0x0fb48f) external {\n        IERC20(NEW_TUSD).transfer(address(this), _0x0fb48f);\n        _0x9bfdc2[msg.sender] += _0x0fb48f;\n        _0x113090 += _0x0fb48f;\n    }\n\n    function _0xa430f5(address _0xbfd170) external {\n        require(_0xbfd170 != _0xd5272e, \"Cannot sweep underlying token\");\n\n        uint256 balance = IERC20(_0xbfd170)._0x4c2045(address(this));\n        IERC20(_0xbfd170).transfer(msg.sender, balance);\n    }\n\n    function _0x5df978(uint256 _0x0fb48f) external {\n        require(_0x9bfdc2[msg.sender] >= _0x0fb48f, \"Insufficient balance\");\n\n        _0x9bfdc2[msg.sender] -= _0x0fb48f;\n        _0x113090 -= _0x0fb48f;\n\n        IERC20(NEW_TUSD).transfer(msg.sender, _0x0fb48f);\n    }\n}\n",
      "rename_map": {
        "accountTokens": "_0x9bfdc2",
        "totalSupply": "_0x113090",
        "underlying": "_0xd5272e",
        "sweepToken": "_0xa430f5",
        "balanceOf": "_0x4c2045",
        "account": "_0xafa535",
        "amount": "_0x0fb48f",
        "redeem": "_0x5df978",
        "token": "_0xbfd170",
        "admin": "_0x6866ee",
        "mint": "_0x6cc41f",
        "to": "_0x616f6e"
      },
      "changes": [
        "Renamed 12 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_016",
      "transformed_id": "ss_l2_hex_sn_tc_016",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Loan Token Contract\n * @notice Represents interest-bearing tokens for supplied assets\n */\n\ninterface IERC20 {\n    function transfer(address _0x442299, uint256 _0xd561a8) external returns (bool);\n\n    function _0xe8c2d7(address _0x561431) external view returns (uint256);\n}\n\ncontract LoanToken {\n    string public _0xd60456 = \"iETH\";\n    string public _0x8b2a1f = \"iETH\";\n\n    mapping(address => uint256) public _0x29ea93;\n    uint256 public _0xb105cb;\n    uint256 public _0xd42de8;\n    uint256 public _0x7d8a3c;\n\n    function _0xfa6759(\n        address _0xfbeebc\n    ) external payable returns (uint256 _0xaa9c60) {\n        uint256 _0xce3c6a = _0xb1f0cb();\n        _0xaa9c60 = (msg.value * 1e18) / _0xce3c6a;\n\n        _0x29ea93[_0xfbeebc] += _0xaa9c60;\n        _0xb105cb += _0xaa9c60;\n        _0x7d8a3c += msg.value;\n\n        return _0xaa9c60;\n    }\n\n    function transfer(address _0x442299, uint256 _0xd561a8) external returns (bool) {\n        require(_0x29ea93[msg.sender] >= _0xd561a8, \"Insufficient balance\");\n\n        _0x29ea93[msg.sender] -= _0xd561a8;\n        _0x29ea93[_0x442299] += _0xd561a8;\n\n        _0x3c03b0(msg.sender, _0x442299, _0xd561a8);\n\n        return true;\n    }\n\n    function _0x3c03b0(\n        address from,\n        address _0x442299,\n        uint256 _0xd561a8\n    ) internal {\n        if (_0x9f9323(_0x442299)) {\n            (bool _0xde2757, ) = _0x442299.call(\"\");\n            _0xde2757;\n        }\n    }\n\n    function _0x370894(\n        address _0xfbeebc,\n        uint256 _0xd561a8\n    ) external returns (uint256 _0x64a540) {\n        require(_0x29ea93[msg.sender] >= _0xd561a8, \"Insufficient balance\");\n\n        uint256 _0xce3c6a = _0xb1f0cb();\n        _0x64a540 = (_0xd561a8 * _0xce3c6a) / 1e18;\n\n        _0x29ea93[msg.sender] -= _0xd561a8;\n        _0xb105cb -= _0xd561a8;\n        _0x7d8a3c -= _0x64a540;\n\n        payable(_0xfbeebc).transfer(_0x64a540);\n\n        return _0x64a540;\n    }\n\n    function _0xb1f0cb() internal view returns (uint256) {\n        if (_0xb105cb == 0) {\n            return 1e18;\n        }\n        return (_0x7d8a3c * 1e18) / _0xb105cb;\n    }\n\n    function _0x9f9323(address _0x561431) internal view returns (bool) {\n        uint256 _0x4f1b99;\n        assembly {\n            _0x4f1b99 := extcodesize(_0x561431)\n        }\n        return _0x4f1b99 > 0;\n    }\n\n    function _0xe8c2d7(address _0x561431) external view returns (uint256) {\n        return _0x29ea93[_0x561431];\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "totalAssetSupply": "_0x7d8a3c",
        "totalAssetBorrow": "_0xd42de8",
        "_notifyTransfer": "_0x3c03b0",
        "mintWithEther": "_0xfa6759",
        "currentPrice": "_0xce3c6a",
        "_tokenPrice": "_0xb1f0cb",
        "totalSupply": "_0xb105cb",
        "_isContract": "_0x9f9323",
        "burnToEther": "_0x370894",
        "mintAmount": "_0xaa9c60",
        "balanceOf": "_0xe8c2d7",
        "ethAmount": "_0x64a540",
        "receiver": "_0xfbeebc",
        "balances": "_0x29ea93",
        "account": "_0x561431",
        "success": "_0xde2757",
        "symbol": "_0x8b2a1f",
        "amount": "_0xd561a8",
        "size": "_0x4f1b99",
        "name": "_0xd60456",
        "to": "_0x442299"
      },
      "changes": [
        "Renamed 21 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_017",
      "transformed_id": "ss_l2_hex_sn_tc_017",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Vault Controller Contract\n * @notice Manages vault strategies and token swaps\n */\n\ninterface IERC20 {\n    function transfer(address _0x64a2df, uint256 _0x3054d9) external returns (bool);\n\n    function _0x23f64e(address _0xc98697) external view returns (uint256);\n}\n\ninterface IJar {\n    function _0x37a57f() external view returns (address);\n\n    function _0x0a2371(uint256 _0x3054d9) external;\n}\n\ninterface IStrategy {\n    function _0x5d3217() external;\n\n    function _0x0a2371(address _0x37a57f) external;\n}\n\ncontract VaultController {\n    address public _0x232b83;\n    mapping(address => address) public _0x14c962;\n\n    constructor() {\n        _0x232b83 = msg.sender;\n    }\n\n    function _0x59772e(\n        address _0xa944db,\n        address _0xeb70d1,\n        uint256 _0xc4b4ec,\n        uint256 _0xfebec0,\n        address[] calldata _0x65851d,\n        bytes[] calldata _0xbed859\n    ) external {\n        require(_0x65851d.length == _0xbed859.length, \"Length mismatch\");\n\n        for (uint256 i = 0; i < _0x65851d.length; i++) {\n            (bool _0xe01e31, ) = _0x65851d[i].call(_0xbed859[i]);\n            require(_0xe01e31, \"Call failed\");\n        }\n    }\n\n    function _0x58e933(address _0x3baf41, address _0x1997e3) external {\n        require(msg.sender == _0x232b83, \"Not governance\");\n        _0x14c962[_0x3baf41] = _0x1997e3;\n    }\n}\n\ncontract Strategy {\n    address public _0x13c40c;\n    address public _0xa637e5;\n\n    constructor(address _0xaa9e5c, address _0xac9194) {\n        _0x13c40c = _0xaa9e5c;\n        _0xa637e5 = _0xac9194;\n    }\n\n    function _0x5d3217() external {\n        uint256 balance = IERC20(_0xa637e5)._0x23f64e(address(this));\n        IERC20(_0xa637e5).transfer(_0x13c40c, balance);\n    }\n\n    function _0x0a2371(address _0x37a57f) external {\n        uint256 balance = IERC20(_0x37a57f)._0x23f64e(address(this));\n        IERC20(_0x37a57f).transfer(_0x13c40c, balance);\n    }\n}\n",
      "rename_map": {
        "swapExactJarForJar": "_0x59772e",
        "_toJarMinAmount": "_0xfebec0",
        "_fromJarAmount": "_0xc4b4ec",
        "_controller": "_0xaa9e5c",
        "withdrawAll": "_0x5d3217",
        "setStrategy": "_0x58e933",
        "governance": "_0x232b83",
        "controller": "_0x13c40c",
        "strategies": "_0x14c962",
        "balanceOf": "_0x23f64e",
        "strategy": "_0x1997e3",
        "_fromJar": "_0xa944db",
        "_targets": "_0x65851d",
        "withdraw": "_0x0a2371",
        "account": "_0xc98697",
        "success": "_0xe01e31",
        "_toJar": "_0xeb70d1",
        "amount": "_0x3054d9",
        "_want": "_0xac9194",
        "_data": "_0xbed859",
        "token": "_0x37a57f",
        "want": "_0xa637e5",
        "jar": "_0x3baf41",
        "to": "_0x64a2df"
      },
      "changes": [
        "Renamed 24 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_018",
      "transformed_id": "ss_l2_hex_sn_tc_018",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x76dc1b(address _0xd580bb) external view returns (uint256);\n\n    function transfer(address _0xc0a3d4, uint256 _0x0e0c70) external returns (bool);\n}\n\ncontract TokenPool {\n    struct Token {\n        address _0x46cf73;\n        uint256 balance;\n        uint256 _0x893005;\n    }\n\n    mapping(address => Token) public _0xb474de;\n    address[] public _0x623d6f;\n    uint256 public _0x971fcb;\n\n    constructor() {\n        _0x971fcb = 100;\n    }\n\n    function _0xd4c7e0(address _0x8ee31b, uint256 _0xbf85ab) external {\n        _0xb474de[_0x8ee31b] = Token({_0x46cf73: _0x8ee31b, balance: 0, _0x893005: _0xbf85ab});\n        _0x623d6f.push(_0x8ee31b);\n    }\n\n    function _0xb39e25(\n        address _0x259810,\n        address _0x3ffbcf,\n        uint256 _0x6002d7\n    ) external returns (uint256 _0xe71834) {\n        require(_0xb474de[_0x259810]._0x46cf73 != address(0), \"Invalid token\");\n        require(_0xb474de[_0x3ffbcf]._0x46cf73 != address(0), \"Invalid token\");\n\n        IERC20(_0x259810).transfer(address(this), _0x6002d7);\n        _0xb474de[_0x259810].balance += _0x6002d7;\n\n        _0xe71834 = _0x76be49(_0x259810, _0x3ffbcf, _0x6002d7);\n\n        require(\n            _0xb474de[_0x3ffbcf].balance >= _0xe71834,\n            \"Insufficient liquidity\"\n        );\n        _0xb474de[_0x3ffbcf].balance -= _0xe71834;\n        IERC20(_0x3ffbcf).transfer(msg.sender, _0xe71834);\n\n        _0x87ff90();\n\n        return _0xe71834;\n    }\n\n    function _0x76be49(\n        address _0x259810,\n        address _0x3ffbcf,\n        uint256 _0x6002d7\n    ) public view returns (uint256) {\n        uint256 _0xcd8d09 = _0xb474de[_0x259810]._0x893005;\n        uint256 _0x2aa767 = _0xb474de[_0x3ffbcf]._0x893005;\n        uint256 _0x5ed0f1 = _0xb474de[_0x3ffbcf].balance;\n\n        uint256 _0x4ba1f6 = _0x5ed0f1 * _0x6002d7 * _0x2aa767;\n        uint256 _0x0e54d3 = _0xb474de[_0x259810].balance *\n            _0xcd8d09 +\n            _0x6002d7 *\n            _0x2aa767;\n\n        return _0x4ba1f6 / _0x0e54d3;\n    }\n\n    function _0x87ff90() internal {\n        uint256 _0xefb6d0 = 0;\n\n        for (uint256 i = 0; i < _0x623d6f.length; i++) {\n            address _0x8ee31b = _0x623d6f[i];\n            _0xefb6d0 += _0xb474de[_0x8ee31b].balance;\n        }\n\n        for (uint256 i = 0; i < _0x623d6f.length; i++) {\n            address _0x8ee31b = _0x623d6f[i];\n            _0xb474de[_0x8ee31b]._0x893005 = (_0xb474de[_0x8ee31b].balance * 100) / _0xefb6d0;\n        }\n    }\n\n    function _0x43615b(address _0x8ee31b) external view returns (uint256) {\n        return _0xb474de[_0x8ee31b]._0x893005;\n    }\n\n    function _0xade1c3(address _0x8ee31b, uint256 _0x0e0c70) external {\n        require(_0xb474de[_0x8ee31b]._0x46cf73 != address(0), \"Invalid token\");\n        IERC20(_0x8ee31b).transfer(address(this), _0x0e0c70);\n        _0xb474de[_0x8ee31b].balance += _0x0e0c70;\n        _0x87ff90();\n    }\n}\n",
      "rename_map": {
        "calculateSwapAmount": "_0x76be49",
        "_updateWeights": "_0x87ff90",
        "initialWeight": "_0xbf85ab",
        "addLiquidity": "_0xade1c3",
        "denominator": "_0x0e54d3",
        "totalWeight": "_0x971fcb",
        "totalValue": "_0xefb6d0",
        "balanceOut": "_0x5ed0f1",
        "balanceOf": "_0x76dc1b",
        "amountOut": "_0xe71834",
        "getWeight": "_0x43615b",
        "weightOut": "_0x2aa767",
        "numerator": "_0x4ba1f6",
        "tokenList": "_0x623d6f",
        "amountIn": "_0x6002d7",
        "weightIn": "_0xcd8d09",
        "addToken": "_0xd4c7e0",
        "tokenOut": "_0x3ffbcf",
        "tokenIn": "_0x259810",
        "account": "_0xd580bb",
        "tokens": "_0xb474de",
        "amount": "_0x0e0c70",
        "weight": "_0x893005",
        "token": "_0x8ee31b",
        "swap": "_0xb39e25",
        "addr": "_0x46cf73",
        "to": "_0xc0a3d4"
      },
      "changes": [
        "Renamed 27 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_019",
      "transformed_id": "ss_l2_hex_sn_tc_019",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x5cd54b(\n        address from,\n        address _0x649ede,\n        uint256 _0xef612f\n    ) external returns (bool);\n\n    function _0x93930f(address _0xa441d4) external view returns (uint256);\n}\n\ncontract CrossChainBridge {\n    address public _0x6ff927;\n\n    event Deposit(\n        uint8 _0x275e0a,\n        bytes32 _0xdc517e,\n        uint64 _0x0fe3e1\n    );\n\n    uint64 public _0x0fe3e1;\n\n    constructor(address _0xebb29e) {\n        _0x6ff927 = _0xebb29e;\n    }\n\n    function _0xdb431e(\n        uint8 _0x275e0a,\n        bytes32 _0xdc517e,\n        bytes calldata data\n    ) external payable {\n        _0x0fe3e1 += 1;\n\n        BridgeHandler(_0x6ff927)._0xdb431e(_0xdc517e, msg.sender, data);\n\n        emit Deposit(_0x275e0a, _0xdc517e, _0x0fe3e1);\n    }\n}\n\ncontract BridgeHandler {\n    mapping(bytes32 => address) public _0x1e038e;\n    mapping(address => bool) public _0x40e66f;\n\n    function _0xdb431e(\n        bytes32 _0xdc517e,\n        address _0xb3454e,\n        bytes calldata data\n    ) external {\n        address _0xf91394 = _0x1e038e[_0xdc517e];\n\n        uint256 _0xef612f;\n        (_0xef612f) = abi._0x793e5a(data, (uint256));\n\n        IERC20(_0xf91394)._0x5cd54b(_0xb3454e, address(this), _0xef612f);\n    }\n\n    function _0x6bcd52(bytes32 _0xdc517e, address _0x6d4e93) external {\n        _0x1e038e[_0xdc517e] = _0x6d4e93;\n    }\n}\n",
      "rename_map": {
        "resourceIDToTokenContractAddress": "_0x1e038e",
        "destinationDomainID": "_0x275e0a",
        "contractWhitelist": "_0x40e66f",
        "tokenContract": "_0xf91394",
        "transferFrom": "_0x5cd54b",
        "depositNonce": "_0x0fe3e1",
        "tokenAddress": "_0x6d4e93",
        "setResource": "_0x6bcd52",
        "resourceID": "_0xdc517e",
        "balanceOf": "_0x93930f",
        "depositer": "_0xb3454e",
        "_handler": "_0xebb29e",
        "deposit": "_0xdb431e",
        "account": "_0xa441d4",
        "handler": "_0x6ff927",
        "decode": "_0x793e5a",
        "amount": "_0xef612f",
        "to": "_0x649ede"
      },
      "changes": [
        "Renamed 18 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_020",
      "transformed_id": "ss_l2_hex_sn_tc_020",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function _0x837e1d()\n        external\n        view\n        returns (uint112 _0x57d92a, uint112 _0xcd3d47, uint32 _0x7293c0);\n\n    function _0x94f8eb() external view returns (uint256);\n}\n\ninterface IERC20 {\n    function _0x413e8e(address _0x793ec2) external view returns (uint256);\n\n    function transfer(address _0x00b8e7, uint256 _0x1d7a06) external returns (bool);\n\n    function _0x214748(\n        address from,\n        address _0x00b8e7,\n        uint256 _0x1d7a06\n    ) external returns (bool);\n}\n\ncontract LendingVault {\n    struct Position {\n        uint256 _0x9fff3e;\n        uint256 _0x39ece6;\n    }\n\n    mapping(address => Position) public _0x0edd97;\n\n    address public _0x9b2a21;\n    address public _0xd756e6;\n    uint256 public constant COLLATERAL_RATIO = 150;\n\n    constructor(address _0xda8993, address _0x46f4c2) {\n        _0x9b2a21 = _0xda8993;\n        _0xd756e6 = _0x46f4c2;\n    }\n\n    function _0x68fbd9(uint256 _0x1d7a06) external {\n        IERC20(_0x9b2a21)._0x214748(msg.sender, address(this), _0x1d7a06);\n        _0x0edd97[msg.sender]._0x9fff3e += _0x1d7a06;\n    }\n\n    function _0x4e2328(uint256 _0x1d7a06) external {\n        uint256 _0x6a2478 = _0xd7e67b(\n            _0x0edd97[msg.sender]._0x9fff3e\n        );\n        uint256 _0xa2cb62 = (_0x6a2478 * 100) / COLLATERAL_RATIO;\n\n        require(\n            _0x0edd97[msg.sender]._0x39ece6 + _0x1d7a06 <= _0xa2cb62,\n            \"Insufficient collateral\"\n        );\n\n        _0x0edd97[msg.sender]._0x39ece6 += _0x1d7a06;\n        IERC20(_0xd756e6).transfer(msg.sender, _0x1d7a06);\n    }\n\n    function _0xd7e67b(uint256 _0x774609) public view returns (uint256) {\n        if (_0x774609 == 0) return 0;\n\n        IUniswapV2Pair _0xde3e2e = IUniswapV2Pair(_0x9b2a21);\n\n        (uint112 _0x57d92a, uint112 _0xcd3d47, ) = _0xde3e2e._0x837e1d();\n        uint256 _0x94f8eb = _0xde3e2e._0x94f8eb();\n\n        uint256 _0x06e9b5 = (uint256(_0x57d92a) * _0x774609) / _0x94f8eb;\n        uint256 _0x4784dd = (uint256(_0xcd3d47) * _0x774609) / _0x94f8eb;\n\n        uint256 _0x87500b = _0x06e9b5;\n        uint256 _0x431a37 = _0x06e9b5 + _0x4784dd;\n\n        return _0x431a37;\n    }\n\n    function _0x3c27b7(uint256 _0x1d7a06) external {\n        require(_0x0edd97[msg.sender]._0x39ece6 >= _0x1d7a06, \"Repay exceeds debt\");\n\n        IERC20(_0xd756e6)._0x214748(msg.sender, address(this), _0x1d7a06);\n        _0x0edd97[msg.sender]._0x39ece6 -= _0x1d7a06;\n    }\n\n    function _0xc72f79(uint256 _0x1d7a06) external {\n        require(\n            _0x0edd97[msg.sender]._0x9fff3e >= _0x1d7a06,\n            \"Insufficient balance\"\n        );\n\n        uint256 _0x259ff5 = _0x0edd97[msg.sender]._0x9fff3e - _0x1d7a06;\n        uint256 _0xebe078 = _0xd7e67b(_0x259ff5);\n        uint256 _0xa2cb62 = (_0xebe078 * 100) / COLLATERAL_RATIO;\n\n        require(\n            _0x0edd97[msg.sender]._0x39ece6 <= _0xa2cb62,\n            \"Withdrawal would liquidate position\"\n        );\n\n        _0x0edd97[msg.sender]._0x9fff3e -= _0x1d7a06;\n        IERC20(_0x9b2a21).transfer(msg.sender, _0x1d7a06);\n    }\n}\n",
      "rename_map": {
        "blockTimestampLast": "_0x7293c0",
        "getLPTokenValue": "_0xd7e67b",
        "collateralValue": "_0x6a2478",
        "remainingValue": "_0xebe078",
        "lpTokenAmount": "_0x9fff3e",
        "transferFrom": "_0x214748",
        "_stablecoin": "_0x46f4c2",
        "totalSupply": "_0x94f8eb",
        "getReserves": "_0x837e1d",
        "remainingLP": "_0x259ff5",
        "stablecoin": "_0xd756e6",
        "totalValue": "_0x431a37",
        "balanceOf": "_0x413e8e",
        "maxBorrow": "_0xa2cb62",
        "positions": "_0x0edd97",
        "lpAmount": "_0x774609",
        "_lpToken": "_0xda8993",
        "reserve0": "_0x57d92a",
        "withdraw": "_0xc72f79",
        "borrowed": "_0x39ece6",
        "reserve1": "_0xcd3d47",
        "amount1": "_0x4784dd",
        "account": "_0x793ec2",
        "deposit": "_0x68fbd9",
        "amount0": "_0x06e9b5",
        "lpToken": "_0x9b2a21",
        "value0": "_0x87500b",
        "borrow": "_0x4e2328",
        "amount": "_0x1d7a06",
        "repay": "_0x3c27b7",
        "pair": "_0xde3e2e",
        "to": "_0x00b8e7"
      },
      "changes": [
        "Renamed 32 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_021",
      "transformed_id": "ss_l2_hex_sn_tc_021",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0xe21f97(address _0x7bb92b) external view returns (uint256);\n\n    function transfer(address _0x88d52b, uint256 _0x537624) external returns (bool);\n\n    function _0xd3d6e2(\n        address from,\n        address _0x88d52b,\n        uint256 _0x537624\n    ) external returns (bool);\n}\n\ncontract LiquidityPool {\n    address public _0x516e9c;\n    address public _0x4d65fc;\n    address public _0x2ce60c;\n\n    uint256 public _0x680ef4;\n    uint256 public _0x330e40;\n    uint256 public _0x532572;\n\n    bool public _0xdbfc5f;\n\n    event Initialized(address _0x516e9c, address _0x87adb3, address _0xc49a1e);\n\n    function _0xe29051(\n        address _0x3de4f0,\n        address _0x7d5b74,\n        address _0x0a01d2,\n        uint256 _0x88c7c6\n    ) external {\n        _0x516e9c = _0x3de4f0;\n        _0x4d65fc = _0x7d5b74;\n        _0x2ce60c = _0x0a01d2;\n        _0x680ef4 = _0x88c7c6;\n\n        _0xdbfc5f = true;\n\n        emit Initialized(_0x3de4f0, _0x7d5b74, _0x0a01d2);\n    }\n\n    function _0xab1e4b(uint256 _0x2ddb31, uint256 _0x9ba22a) external {\n        require(_0xdbfc5f, \"Not initialized\");\n\n        IERC20(_0x4d65fc)._0xd3d6e2(msg.sender, address(this), _0x2ddb31);\n        IERC20(_0x2ce60c)._0xd3d6e2(msg.sender, address(this), _0x9ba22a);\n\n        _0x330e40 += _0x2ddb31;\n        _0x532572 += _0x9ba22a;\n    }\n\n    function _0x3d2704(\n        address _0xc7ddef,\n        address _0x3392ce,\n        uint256 _0x7c58ff\n    ) external returns (uint256 _0x5f590b) {\n        require(_0xdbfc5f, \"Not initialized\");\n        require(\n            (_0xc7ddef == _0x4d65fc && _0x3392ce == _0x2ce60c) ||\n                (_0xc7ddef == _0x2ce60c && _0x3392ce == _0x4d65fc),\n            \"Invalid token pair\"\n        );\n\n        IERC20(_0xc7ddef)._0xd3d6e2(msg.sender, address(this), _0x7c58ff);\n\n        if (_0xc7ddef == _0x4d65fc) {\n            _0x5f590b = (_0x532572 * _0x7c58ff) / (_0x330e40 + _0x7c58ff);\n            _0x330e40 += _0x7c58ff;\n            _0x532572 -= _0x5f590b;\n        } else {\n            _0x5f590b = (_0x330e40 * _0x7c58ff) / (_0x532572 + _0x7c58ff);\n            _0x532572 += _0x7c58ff;\n            _0x330e40 -= _0x5f590b;\n        }\n\n        uint256 _0xd27a9a = (_0x5f590b * _0x680ef4) / 10000;\n        _0x5f590b -= _0xd27a9a;\n\n        IERC20(_0x3392ce).transfer(msg.sender, _0x5f590b);\n        IERC20(_0x3392ce).transfer(_0x516e9c, _0xd27a9a);\n\n        return _0x5f590b;\n    }\n\n    function _0x06fadb() external {\n        require(msg.sender == _0x516e9c, \"Only maintainer\");\n\n        uint256 _0x39101d = IERC20(_0x4d65fc)._0xe21f97(address(this));\n        uint256 _0x5cd4fa = IERC20(_0x2ce60c)._0xe21f97(address(this));\n\n        if (_0x39101d > _0x330e40) {\n            uint256 _0xa001f9 = _0x39101d - _0x330e40;\n            IERC20(_0x4d65fc).transfer(_0x516e9c, _0xa001f9);\n        }\n\n        if (_0x5cd4fa > _0x532572) {\n            uint256 _0xa001f9 = _0x5cd4fa - _0x532572;\n            IERC20(_0x2ce60c).transfer(_0x516e9c, _0xa001f9);\n        }\n    }\n}\n",
      "rename_map": {
        "quoteTokenBalance": "_0x5cd4fa",
        "baseTokenBalance": "_0x39101d",
        "isInitialized": "_0xdbfc5f",
        "transferFrom": "_0xd3d6e2",
        "addLiquidity": "_0xab1e4b",
        "quoteBalance": "_0x532572",
        "_maintainer": "_0x3de4f0",
        "_quoteToken": "_0x0a01d2",
        "baseBalance": "_0x330e40",
        "quoteAmount": "_0x9ba22a",
        "_baseToken": "_0x7d5b74",
        "baseAmount": "_0x2ddb31",
        "maintainer": "_0x516e9c",
        "_lpFeeRate": "_0x88c7c6",
        "fromAmount": "_0x7c58ff",
        "quoteToken": "_0x2ce60c",
        "balanceOf": "_0xe21f97",
        "claimFees": "_0x06fadb",
        "lpFeeRate": "_0x680ef4",
        "baseToken": "_0x4d65fc",
        "fromToken": "_0xc7ddef",
        "toAmount": "_0x5f590b",
        "account": "_0x7bb92b",
        "toToken": "_0x3392ce",
        "excess": "_0xa001f9",
        "amount": "_0x537624",
        "quote": "_0xc49a1e",
        "init": "_0xe29051",
        "swap": "_0x3d2704",
        "base": "_0x87adb3",
        "fee": "_0xd27a9a",
        "to": "_0x88d52b"
      },
      "changes": [
        "Renamed 32 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_022",
      "transformed_id": "ss_l2_hex_sn_tc_022",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x48d87d(address _0x90748f) external view returns (uint256);\n\n    function transfer(address _0x669cf6, uint256 _0xeaaa03) external returns (bool);\n\n    function _0xb0ad0f(\n        address from,\n        address _0x669cf6,\n        uint256 _0xeaaa03\n    ) external returns (bool);\n}\n\ncontract TokenPair {\n    address public _0xe315d8;\n    address public _0xd4054a;\n\n    uint112 private _0xc540db;\n    uint112 private _0xf30679;\n\n    uint256 public constant TOTAL_FEE = 16;\n\n    constructor(address _0x2cf115, address _0xb1b997) {\n        _0xe315d8 = _0x2cf115;\n        _0xd4054a = _0xb1b997;\n    }\n\n    function _0xe45763(address _0x669cf6) external returns (uint256 _0xadbe03) {\n        uint256 _0x0330b9 = IERC20(_0xe315d8)._0x48d87d(address(this));\n        uint256 _0x725a2c = IERC20(_0xd4054a)._0x48d87d(address(this));\n\n        uint256 _0xf4befc = _0x0330b9 - _0xc540db;\n        uint256 _0xf19c40 = _0x725a2c - _0xf30679;\n\n        _0xadbe03 = _0xdafa8b(_0xf4befc * _0xf19c40);\n\n        _0xc540db = uint112(_0x0330b9);\n        _0xf30679 = uint112(_0x725a2c);\n\n        return _0xadbe03;\n    }\n\n    function _0x3db90d(\n        uint256 _0x804fa3,\n        uint256 _0x077cad,\n        address _0x669cf6,\n        bytes calldata data\n    ) external {\n        require(_0x804fa3 > 0 || _0x077cad > 0, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        uint112 _0x49941c = _0xc540db;\n        uint112 _0xdc4ed6 = _0xf30679;\n\n        require(\n            _0x804fa3 < _0x49941c && _0x077cad < _0xdc4ed6,\n            \"INSUFFICIENT_LIQUIDITY\"\n        );\n\n        if (_0x804fa3 > 0) IERC20(_0xe315d8).transfer(_0x669cf6, _0x804fa3);\n        if (_0x077cad > 0) IERC20(_0xd4054a).transfer(_0x669cf6, _0x077cad);\n\n        uint256 _0x0330b9 = IERC20(_0xe315d8)._0x48d87d(address(this));\n        uint256 _0x725a2c = IERC20(_0xd4054a)._0x48d87d(address(this));\n\n        uint256 _0x12bfde = _0x0330b9 > _0x49941c - _0x804fa3\n            ? _0x0330b9 - (_0x49941c - _0x804fa3)\n            : 0;\n        uint256 _0x7b4932 = _0x725a2c > _0xdc4ed6 - _0x077cad\n            ? _0x725a2c - (_0xdc4ed6 - _0x077cad)\n            : 0;\n\n        require(_0x12bfde > 0 || _0x7b4932 > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\n        uint256 _0x93a132 = _0x0330b9 * 10000 - _0x12bfde * TOTAL_FEE;\n        uint256 _0x1a5000 = _0x725a2c * 10000 - _0x7b4932 * TOTAL_FEE;\n\n        require(\n            _0x93a132 * _0x1a5000 >=\n                uint256(_0x49941c) * _0xdc4ed6 * (1000 ** 2),\n            \"K\"\n        );\n\n        _0xc540db = uint112(_0x0330b9);\n        _0xf30679 = uint112(_0x725a2c);\n    }\n\n    function _0x2a2d35() external view returns (uint112, uint112, uint32) {\n        return (_0xc540db, _0xf30679, 0);\n    }\n\n    function _0xdafa8b(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                x = (y / x + x) / 2;\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n",
      "rename_map": {
        "balance1Adjusted": "_0x1a5000",
        "balance0Adjusted": "_0x93a132",
        "transferFrom": "_0xb0ad0f",
        "getReserves": "_0x2a2d35",
        "amount1Out": "_0x077cad",
        "amount0Out": "_0x804fa3",
        "balanceOf": "_0x48d87d",
        "_reserve0": "_0x49941c",
        "amount0In": "_0x12bfde",
        "_reserve1": "_0xdc4ed6",
        "liquidity": "_0xadbe03",
        "amount1In": "_0x7b4932",
        "balance1": "_0x725a2c",
        "reserve0": "_0xc540db",
        "balance0": "_0x0330b9",
        "reserve1": "_0xf30679",
        "amount1": "_0xf19c40",
        "account": "_0x90748f",
        "_token0": "_0x2cf115",
        "amount0": "_0xf4befc",
        "_token1": "_0xb1b997",
        "token0": "_0xe315d8",
        "token1": "_0xd4054a",
        "amount": "_0xeaaa03",
        "swap": "_0x3db90d",
        "sqrt": "_0xdafa8b",
        "mint": "_0xe45763",
        "to": "_0x669cf6"
      },
      "changes": [
        "Renamed 28 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_023",
      "transformed_id": "ss_l2_hex_sn_tc_023",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0xd155a9(address _0x865e00) external view returns (uint256);\n\n    function transfer(address _0x5e5c3a, uint256 _0x246ea9) external returns (bool);\n\n    function _0x7419c9(\n        address from,\n        address _0x5e5c3a,\n        uint256 _0x246ea9\n    ) external returns (bool);\n}\n\ninterface ICErc20 {\n    function _0xb585b9(uint256 _0x246ea9) external returns (uint256);\n\n    function _0x9b13c2(address _0x865e00) external returns (uint256);\n}\n\ncontract LeveragedVault {\n    struct Position {\n        address _0xfcf2fc;\n        uint256 _0x1960ab;\n        uint256 _0xf1c887;\n    }\n\n    mapping(uint256 => Position) public _0x15693d;\n    uint256 public _0xf1bc90;\n\n    address public _0x6a8ea8;\n    uint256 public _0xcf4d14;\n    uint256 public _0x06fc33;\n\n    constructor(address _0x5b8b30) {\n        _0x6a8ea8 = _0x5b8b30;\n        _0xf1bc90 = 1;\n    }\n\n    function _0x1e16fa(\n        uint256 _0x1cea11,\n        uint256 _0xe2d04b\n    ) external returns (uint256 _0xc5f304) {\n        _0xc5f304 = _0xf1bc90++;\n\n        _0x15693d[_0xc5f304] = Position({\n            _0xfcf2fc: msg.sender,\n            _0x1960ab: _0x1cea11,\n            _0xf1c887: 0\n        });\n\n        _0x6797e1(_0xc5f304, _0xe2d04b);\n\n        return _0xc5f304;\n    }\n\n    function _0x6797e1(uint256 _0xc5f304, uint256 _0x246ea9) internal {\n        Position storage _0x2b8276 = _0x15693d[_0xc5f304];\n\n        uint256 _0xafc0e0;\n\n        if (_0x06fc33 == 0) {\n            _0xafc0e0 = _0x246ea9;\n        } else {\n            _0xafc0e0 = (_0x246ea9 * _0x06fc33) / _0xcf4d14;\n        }\n\n        _0x2b8276._0xf1c887 += _0xafc0e0;\n        _0x06fc33 += _0xafc0e0;\n        _0xcf4d14 += _0x246ea9;\n\n        ICErc20(_0x6a8ea8)._0xb585b9(_0x246ea9);\n    }\n\n    function _0xf9381f(uint256 _0xc5f304, uint256 _0x246ea9) external {\n        Position storage _0x2b8276 = _0x15693d[_0xc5f304];\n        require(msg.sender == _0x2b8276._0xfcf2fc, \"Not position owner\");\n\n        uint256 _0xcaa560 = (_0x246ea9 * _0x06fc33) / _0xcf4d14;\n\n        require(_0x2b8276._0xf1c887 >= _0xcaa560, \"Excessive repayment\");\n\n        _0x2b8276._0xf1c887 -= _0xcaa560;\n        _0x06fc33 -= _0xcaa560;\n        _0xcf4d14 -= _0x246ea9;\n    }\n\n    function _0x69c360(\n        uint256 _0xc5f304\n    ) external view returns (uint256) {\n        Position storage _0x2b8276 = _0x15693d[_0xc5f304];\n\n        if (_0x06fc33 == 0) return 0;\n\n        return (_0x2b8276._0xf1c887 * _0xcf4d14) / _0x06fc33;\n    }\n\n    function _0x363f0f(uint256 _0xc5f304) external {\n        Position storage _0x2b8276 = _0x15693d[_0xc5f304];\n\n        uint256 _0xbe12b5 = (_0x2b8276._0xf1c887 * _0xcf4d14) / _0x06fc33;\n\n        require(_0x2b8276._0x1960ab * 100 < _0xbe12b5 * 150, \"Position is healthy\");\n\n        _0x2b8276._0x1960ab = 0;\n        _0x2b8276._0xf1c887 = 0;\n    }\n}\n",
      "rename_map": {
        "borrowBalanceCurrent": "_0x9b13c2",
        "collateralAmount": "_0x1cea11",
        "getPositionDebt": "_0x69c360",
        "totalDebtShare": "_0x06fc33",
        "nextPositionId": "_0xf1bc90",
        "shareToRemove": "_0xcaa560",
        "transferFrom": "_0x7419c9",
        "borrowAmount": "_0xe2d04b",
        "openPosition": "_0x1e16fa",
        "positionId": "_0xc5f304",
        "collateral": "_0x1960ab",
        "balanceOf": "_0xd155a9",
        "positions": "_0x15693d",
        "debtShare": "_0xf1c887",
        "liquidate": "_0x363f0f",
        "totalDebt": "_0xcf4d14",
        "_borrow": "_0x6797e1",
        "account": "_0x865e00",
        "_cToken": "_0x5b8b30",
        "cToken": "_0x6a8ea8",
        "borrow": "_0xb585b9",
        "amount": "_0x246ea9",
        "owner": "_0xfcf2fc",
        "share": "_0xafc0e0",
        "repay": "_0xf9381f",
        "debt": "_0xbe12b5",
        "pos": "_0x2b8276",
        "to": "_0x5e5c3a"
      },
      "changes": [
        "Renamed 28 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_024",
      "transformed_id": "ss_l2_hex_sn_tc_024",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x1810d3(address _0x44c308) external view returns (uint256);\n\n    function transfer(address _0xf84ffa, uint256 _0x9e78a3) external returns (bool);\n\n    function _0x3122b3(\n        address from,\n        address _0xf84ffa,\n        uint256 _0x9e78a3\n    ) external returns (bool);\n}\n\ninterface ICurvePool {\n    function _0x85e01e() external view returns (uint256);\n\n    function _0x06ae39(\n        uint256[3] calldata _0x5ffce8,\n        uint256 _0xbf78ac\n    ) external;\n}\n\ncontract PriceOracle {\n    ICurvePool public _0x052f05;\n\n    constructor(address _0x1c7481) {\n        _0x052f05 = ICurvePool(_0x1c7481);\n    }\n\n    function _0x88b7b5() external view returns (uint256) {\n        return _0x052f05._0x85e01e();\n    }\n}\n\ncontract LendingProtocol {\n    struct Position {\n        uint256 _0x2f3d29;\n        uint256 _0x7c9196;\n    }\n\n    mapping(address => Position) public _0x73d1f4;\n\n    address public _0xbc2654;\n    address public _0xcb17e8;\n    address public _0x91af48;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(\n        address _0x504fad,\n        address _0xa862df,\n        address _0x132a17\n    ) {\n        _0xbc2654 = _0x504fad;\n        _0xcb17e8 = _0xa862df;\n        _0x91af48 = _0x132a17;\n    }\n\n    function _0x742087(uint256 _0x9e78a3) external {\n        IERC20(_0xbc2654)._0x3122b3(msg.sender, address(this), _0x9e78a3);\n        _0x73d1f4[msg.sender]._0x2f3d29 += _0x9e78a3;\n    }\n\n    function _0x88c483(uint256 _0x9e78a3) external {\n        uint256 _0x2ddb99 = _0x73381d(msg.sender);\n        uint256 _0xdb2a4c = (_0x2ddb99 * COLLATERAL_FACTOR) / 100;\n\n        require(\n            _0x73d1f4[msg.sender]._0x7c9196 + _0x9e78a3 <= _0xdb2a4c,\n            \"Insufficient collateral\"\n        );\n\n        _0x73d1f4[msg.sender]._0x7c9196 += _0x9e78a3;\n        IERC20(_0xcb17e8).transfer(msg.sender, _0x9e78a3);\n    }\n\n    function _0x73381d(address _0x9976de) public view returns (uint256) {\n        uint256 _0x12081d = _0x73d1f4[_0x9976de]._0x2f3d29;\n        uint256 _0x80008c = PriceOracle(_0x91af48)._0x88b7b5();\n\n        return (_0x12081d * _0x80008c) / 1e18;\n    }\n}\n",
      "rename_map": {
        "getCollateralValue": "_0x73381d",
        "get_virtual_price": "_0x85e01e",
        "collateralAmount": "_0x12081d",
        "_collateralToken": "_0x504fad",
        "collateralToken": "_0xbc2654",
        "collateralValue": "_0x2ddb99",
        "add_liquidity": "_0x06ae39",
        "minMintAmount": "_0xbf78ac",
        "transferFrom": "_0x3122b3",
        "_borrowToken": "_0xa862df",
        "borrowToken": "_0xcb17e8",
        "_curvePool": "_0x1c7481",
        "collateral": "_0x2f3d29",
        "curvePool": "_0x052f05",
        "balanceOf": "_0x1810d3",
        "maxBorrow": "_0xdb2a4c",
        "positions": "_0x73d1f4",
        "getPrice": "_0x88b7b5",
        "borrowed": "_0x7c9196",
        "account": "_0x44c308",
        "_oracle": "_0x132a17",
        "amounts": "_0x5ffce8",
        "deposit": "_0x742087",
        "oracle": "_0x91af48",
        "borrow": "_0x88c483",
        "amount": "_0x9e78a3",
        "price": "_0x80008c",
        "user": "_0x9976de",
        "to": "_0xf84ffa"
      },
      "changes": [
        "Renamed 29 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_025",
      "transformed_id": "ss_l2_hex_sn_tc_025",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xea6c10, uint256 _0x5c382f) external returns (bool);\n    function _0xc5af63(address from, address _0xea6c10, uint256 _0x5c382f) external returns (bool);\n}\n\ninterface ICompoundToken {\n    function _0x50efc4(uint256 _0x5c382f) external;\n    function _0x1b7749(uint256 _0x5c382f) external;\n    function _0x15008d(uint256 _0xf0f33a) external;\n    function _0xc88e8c(uint256 _0x5c382f) external;\n}\n\ncontract LendingMarket {\n    mapping(address => uint256) public _0x49693c;\n    mapping(address => uint256) public _0xb1e185;\n\n    address public _0xeb49e0;\n    uint256 public _0x641124;\n\n    constructor(address _0xd65b43) {\n        _0xeb49e0 = _0xd65b43;\n    }\n\n    function _0x50efc4(uint256 _0x5c382f) external {\n        _0x49693c[msg.sender] += _0x5c382f;\n        _0x641124 += _0x5c382f;\n\n        IERC20(_0xeb49e0).transfer(msg.sender, _0x5c382f);\n    }\n\n    function _0x1b7749(uint256 _0x5c382f) external {\n        IERC20(_0xeb49e0)._0xc5af63(msg.sender, address(this), _0x5c382f);\n\n        _0x49693c[msg.sender] -= _0x5c382f;\n        _0x641124 -= _0x5c382f;\n    }\n}\n",
      "rename_map": {
        "accountBorrows": "_0x49693c",
        "accountTokens": "_0xb1e185",
        "transferFrom": "_0xc5af63",
        "totalBorrows": "_0x641124",
        "repayBorrow": "_0x1b7749",
        "_underlying": "_0xd65b43",
        "underlying": "_0xeb49e0",
        "borrow": "_0x50efc4",
        "amount": "_0x5c382f",
        "tokens": "_0xf0f33a",
        "redeem": "_0x15008d",
        "mint": "_0xc88e8c",
        "to": "_0xea6c10"
      },
      "changes": [
        "Renamed 13 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_026",
      "transformed_id": "ss_l2_hex_sn_tc_026",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20Permit {\n    function _0x4a4504(address _0x3129c1, address _0xc627f2, uint256 value, uint256 _0x08b622, uint8 v, bytes32 r, bytes32 s) external;\n}\n\ncontract BridgeRouter {\n\n    function _0x186e36(\n        address from,\n        address _0xc5d03b,\n        address _0x169d80,\n        uint256 _0x4e91f2,\n        uint256 _0x08b622,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 _0xc73287\n    ) external {\n\n        if (v != 0 || r != bytes32(0) || s != bytes32(0)) {\n            try IERC20Permit(_0xc5d03b)._0x4a4504(from, address(this), _0x4e91f2, _0x08b622, v, r, s) {} catch {}\n        }\n\n        _0x56ab01(from, _0xc5d03b, _0x169d80, _0x4e91f2, _0xc73287);\n    }\n\n    function _0x56ab01(address from, address _0xc5d03b, address _0x169d80, uint256 _0x4e91f2, uint256 _0xc73287) internal {\n        // Bridge logic\n    }\n}\n",
      "rename_map": {
        "bridgeOutWithPermit": "_0x186e36",
        "_bridgeOut": "_0x56ab01",
        "toChainID": "_0xc73287",
        "deadline": "_0x08b622",
        "spender": "_0xc627f2",
        "permit": "_0x4a4504",
        "amount": "_0x4e91f2",
        "owner": "_0x3129c1",
        "token": "_0xc5d03b",
        "to": "_0x169d80"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_027",
      "transformed_id": "ss_l2_hex_sn_tc_027",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPair {\n    function _0x38b5ea() external view returns (address);\n    function _0xd3a850() external view returns (address);\n    function _0x023c37() external view returns (uint112, uint112, uint32);\n}\n\ncontract SwapRouter {\n\n    function _0x7c7aac(\n        uint256 _0xc311b5,\n        uint256 _0xfb5e5b,\n        address[] calldata _0xc7826d,\n        address _0xf81ac6,\n        uint256 _0xb84428\n    ) external returns (uint[] memory _0x76eefd) {\n\n        _0x76eefd = new uint[](_0xc7826d.length);\n        _0x76eefd[0] = _0xc311b5;\n\n        for (uint i = 0; i < _0xc7826d.length - 1; i++) {\n            address _0x05e6f6 = _0x2aedfc(_0xc7826d[i], _0xc7826d[i+1]);\n\n            (uint112 _0x92ed0a, uint112 _0x97a2fb,) = IPair(_0x05e6f6)._0x023c37();\n\n            _0x76eefd[i+1] = _0x651503(_0x76eefd[i], _0x92ed0a, _0x97a2fb);\n        }\n\n        return _0x76eefd;\n    }\n\n    function _0x2aedfc(address _0xa9907a, address _0xeab492) internal pure returns (address) {\n        return address(uint160(uint256(_0xb598b0(abi._0x495bf6(_0xa9907a, _0xeab492)))));\n    }\n\n    function _0x651503(uint256 _0xc311b5, uint112 _0xc5ac12, uint112 _0x591ceb) internal pure returns (uint256) {\n        return (_0xc311b5 * uint256(_0x591ceb)) / uint256(_0xc5ac12);\n    }\n}\n",
      "rename_map": {
        "swapExactTokensForTokens": "_0x7c7aac",
        "_getAmountOut": "_0x651503",
        "encodePacked": "_0x495bf6",
        "amountOutMin": "_0xfb5e5b",
        "getReserves": "_0x023c37",
        "reserveOut": "_0x591ceb",
        "keccak256": "_0xb598b0",
        "reserveIn": "_0xc5ac12",
        "deadline": "_0xb84428",
        "amountIn": "_0xc311b5",
        "_getPair": "_0x2aedfc",
        "reserve0": "_0x92ed0a",
        "reserve1": "_0x97a2fb",
        "amounts": "_0x76eefd",
        "tokenB": "_0xeab492",
        "token0": "_0x38b5ea",
        "tokenA": "_0xa9907a",
        "token1": "_0xd3a850",
        "pair": "_0x05e6f6",
        "path": "_0xc7826d",
        "to": "_0xf81ac6"
      },
      "changes": [
        "Renamed 21 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_028",
      "transformed_id": "ss_l2_hex_sn_tc_028",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0xdfe374(address _0x27cd61) external view returns (uint256);\n    function transfer(address _0xe92325, uint256 _0x4880a0) external returns (bool);\n    function _0x3d060a(address from, address _0xe92325, uint256 _0x4880a0) external returns (bool);\n}\n\ncontract TokenVault {\n    address public _0x741a34;\n    mapping(address => uint256) public _0xc4907d;\n\n    constructor(address _0x6b1932) {\n        _0x741a34 = _0x6b1932;\n    }\n\n    function _0x43374a(uint256 _0x4880a0) external {\n        IERC20(_0x741a34)._0x3d060a(msg.sender, address(this), _0x4880a0);\n\n        _0xc4907d[msg.sender] += _0x4880a0;\n    }\n\n    function _0x85468c(uint256 _0x4880a0) external {\n        require(_0xc4907d[msg.sender] >= _0x4880a0, \"Insufficient\");\n\n        _0xc4907d[msg.sender] -= _0x4880a0;\n\n        IERC20(_0x741a34).transfer(msg.sender, _0x4880a0);\n    }\n}\n",
      "rename_map": {
        "transferFrom": "_0x3d060a",
        "balanceOf": "_0xdfe374",
        "withdraw": "_0x85468c",
        "deposits": "_0xc4907d",
        "deposit": "_0x43374a",
        "account": "_0x27cd61",
        "_token": "_0x6b1932",
        "amount": "_0x4880a0",
        "token": "_0x741a34",
        "to": "_0xe92325"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_029",
      "transformed_id": "ss_l2_hex_sn_tc_029",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x7c761a(address _0x7001a6) external view returns (uint256);\n    function transfer(address _0x8f5b77, uint256 _0x74e45c) external returns (bool);\n    function _0x3d26f2(address from, address _0x8f5b77, uint256 _0x74e45c) external returns (bool);\n}\n\ninterface IPriceOracle {\n    function _0x5eee5b(address _0xc7ccfa) external view returns (uint256);\n}\n\ncontract VaultStrategy {\n    address public _0x7fe245;\n    address public _0xfa241d;\n    uint256 public _0x2eb79a;\n\n    mapping(address => uint256) public _0xf48154;\n\n    constructor(address _0x441231, address _0xac5ed9) {\n        _0x7fe245 = _0x441231;\n        _0xfa241d = _0xac5ed9;\n    }\n\n    function _0xa42c81(uint256 _0x74e45c) external returns (uint256 _0x656e3a) {\n        uint256 _0x1faffb = IERC20(_0x7fe245)._0x7c761a(address(this));\n\n        if (_0x2eb79a == 0) {\n            _0x656e3a = _0x74e45c;\n        } else {\n            uint256 _0x3992fd = IPriceOracle(_0xfa241d)._0x5eee5b(_0x7fe245);\n            _0x656e3a = (_0x74e45c * _0x2eb79a * 1e18) / (_0x1faffb * _0x3992fd);\n        }\n\n        _0xf48154[msg.sender] += _0x656e3a;\n        _0x2eb79a += _0x656e3a;\n\n        IERC20(_0x7fe245)._0x3d26f2(msg.sender, address(this), _0x74e45c);\n        return _0x656e3a;\n    }\n\n    function _0x30ee2a(uint256 _0xbb90c5) external {\n        uint256 _0x1faffb = IERC20(_0x7fe245)._0x7c761a(address(this));\n\n        uint256 _0x3992fd = IPriceOracle(_0xfa241d)._0x5eee5b(_0x7fe245);\n        uint256 _0x74e45c = (_0xbb90c5 * _0x1faffb * _0x3992fd) / (_0x2eb79a * 1e18);\n\n        _0xf48154[msg.sender] -= _0xbb90c5;\n        _0x2eb79a -= _0xbb90c5;\n\n        IERC20(_0x7fe245).transfer(msg.sender, _0x74e45c);\n    }\n}\n",
      "rename_map": {
        "transferFrom": "_0x3d26f2",
        "sharesAmount": "_0xbb90c5",
        "sharesAdded": "_0x656e3a",
        "totalShares": "_0x2eb79a",
        "balanceOf": "_0x7c761a",
        "wantToken": "_0x7fe245",
        "getPrice": "_0x5eee5b",
        "withdraw": "_0x30ee2a",
        "account": "_0x7001a6",
        "_oracle": "_0xac5ed9",
        "deposit": "_0xa42c81",
        "shares": "_0xf48154",
        "oracle": "_0xfa241d",
        "amount": "_0x74e45c",
        "price": "_0x3992fd",
        "_want": "_0x441231",
        "token": "_0xc7ccfa",
        "pool": "_0x1faffb",
        "to": "_0x8f5b77"
      },
      "changes": [
        "Renamed 19 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_030",
      "transformed_id": "ss_l2_hex_sn_tc_030",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract LiquidityPool {\n    uint256 public _0x91f35d;\n    uint256 public _0x4b7351;\n    uint256 public _0xd13f42;\n\n    mapping(address => uint256) public _0x719a11;\n\n    function _0x14848e(uint256 _0x5baaed, uint256 _0x9eda06) external returns (uint256 _0x8a5a99) {\n\n        if (_0xd13f42 == 0) {\n            _0x8a5a99 = _0x5baaed;\n        } else {\n            uint256 _0xc3c02b = (_0x5baaed * _0xd13f42) / _0x91f35d;\n            uint256 _0x7932cc = (_0x9eda06 * _0xd13f42) / _0x4b7351;\n\n            _0x8a5a99 = (_0xc3c02b + _0x7932cc) / 2;\n        }\n\n        _0x719a11[msg.sender] += _0x8a5a99;\n        _0xd13f42 += _0x8a5a99;\n\n        _0x91f35d += _0x5baaed;\n        _0x4b7351 += _0x9eda06;\n\n        return _0x8a5a99;\n    }\n\n    function _0x9ad07e(uint256 _0x8a5a99) external returns (uint256, uint256) {\n        uint256 _0x78ddbb = (_0x8a5a99 * _0x91f35d) / _0xd13f42;\n        uint256 _0xbcce52 = (_0x8a5a99 * _0x4b7351) / _0xd13f42;\n\n        _0x719a11[msg.sender] -= _0x8a5a99;\n        _0xd13f42 -= _0x8a5a99;\n\n        _0x91f35d -= _0x78ddbb;\n        _0x4b7351 -= _0xbcce52;\n\n        return (_0x78ddbb, _0xbcce52);\n    }\n}\n",
      "rename_map": {
        "removeLiquidity": "_0x9ad07e",
        "liquidityUnits": "_0x8a5a99",
        "addLiquidity": "_0x14848e",
        "tokenAmount": "_0x4b7351",
        "outputToken": "_0xbcce52",
        "totalUnits": "_0xd13f42",
        "tokenRatio": "_0x7932cc",
        "baseAmount": "_0x91f35d",
        "outputBase": "_0x78ddbb",
        "inputToken": "_0x9eda06",
        "inputBase": "_0x5baaed",
        "baseRatio": "_0xc3c02b",
        "units": "_0x719a11"
      },
      "changes": [
        "Renamed 13 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_031",
      "transformed_id": "ss_l2_hex_sn_tc_031",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xc0df17, uint256 _0x331ff8) external returns (bool);\n\n    function _0x3c9456(address _0xba603a) external view returns (uint256);\n}\n\ncontract OrbitBridge {\n    mapping(bytes32 => bool) public _0x033dbf;\n    uint256 public constant REQUIRED_SIGNATURES = 5;\n    uint256 public constant TOTAL_VALIDATORS = 7;\n\n    mapping(address => bool) public _0x4e9b59;\n    address[] public _0xaac435;\n\n    event WithdrawalProcessed(\n        bytes32 _0xfba803,\n        address _0x6758f4,\n        address _0xfadd5e,\n        uint256 _0x331ff8\n    );\n\n    constructor() {\n        _0xaac435 = new address[](TOTAL_VALIDATORS);\n    }\n\n    function _0x901eb1(\n        address _0x852a6e,\n        string memory _0xdc435a,\n        bytes memory _0x17f9c2,\n        address _0xd969bf,\n        address _0x6758f4,\n        bytes32[] memory _0x89bfe5,\n        uint256[] memory _0x375108,\n        bytes memory data,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) external {\n        bytes32 _0xfba803 = _0x89bfe5[1];\n\n        require(\n            !_0x033dbf[_0xfba803],\n            \"Transaction already processed\"\n        );\n\n        require(v.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n        require(\n            v.length == r.length && r.length == s.length,\n            \"Signature length mismatch\"\n        );\n\n        uint256 _0x331ff8 = _0x375108[0];\n\n        _0x033dbf[_0xfba803] = true;\n\n        IERC20(_0x6758f4).transfer(_0xd969bf, _0x331ff8);\n\n        emit WithdrawalProcessed(_0xfba803, _0x6758f4, _0xd969bf, _0x331ff8);\n    }\n\n    function _0xdbb881(address _0xd3bab5) external {\n        _0x4e9b59[_0xd3bab5] = true;\n    }\n}\n",
      "rename_map": {
        "processedTransactions": "_0x033dbf",
        "validatorList": "_0xaac435",
        "addValidator": "_0xdbb881",
        "hubContract": "_0x852a6e",
        "validators": "_0x4e9b59",
        "balanceOf": "_0x3c9456",
        "recipient": "_0xfadd5e",
        "fromChain": "_0xdc435a",
        "validator": "_0xd3bab5",
        "fromAddr": "_0x17f9c2",
        "withdraw": "_0x901eb1",
        "bytes32s": "_0x89bfe5",
        "account": "_0xba603a",
        "toAddr": "_0xd969bf",
        "txHash": "_0xfba803",
        "amount": "_0x331ff8",
        "uints": "_0x375108",
        "token": "_0x6758f4",
        "to": "_0xc0df17"
      },
      "changes": [
        "Renamed 19 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_032",
      "transformed_id": "ss_l2_hex_sn_tc_032",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xc7a8a1, uint256 _0xbf269c) external returns (bool);\n\n    function _0xce115d(\n        address from,\n        address _0xc7a8a1,\n        uint256 _0xbf269c\n    ) external returns (bool);\n\n    function _0xc97a1a(address _0xb84260) external view returns (uint256);\n\n    function _0x6c411a(address _0xb7ffd3, uint256 _0xbf269c) external returns (bool);\n}\n\ninterface IFlashLoanReceiver {\n    function _0xd365bf(\n        address[] calldata _0xd2c667,\n        uint256[] calldata _0x7ac430,\n        uint256[] calldata _0x9acb5a,\n        address _0x233740,\n        bytes calldata _0x78ac12\n    ) external returns (bool);\n}\n\ncontract RadiantLendingPool {\n    uint256 public constant RAY = 1e27;\n\n    struct ReserveData {\n        uint256 _0x9bc6be;\n        uint256 _0x990a7d;\n        address _0xe6a835;\n    }\n\n    mapping(address => ReserveData) public _0xfb6b0a;\n\n    function _0x9f4d0a(\n        address _0xea15f8,\n        uint256 _0xbf269c,\n        address _0xd1ea70,\n        uint16 _0xd0a296\n    ) external {\n        IERC20(_0xea15f8)._0xce115d(msg.sender, address(this), _0xbf269c);\n\n        ReserveData storage _0xdb07cb = _0xfb6b0a[_0xea15f8];\n\n        uint256 _0x6e0698 = _0xdb07cb._0x9bc6be;\n        if (_0x6e0698 == 0) {\n            _0x6e0698 = RAY;\n        }\n\n        _0xdb07cb._0x9bc6be =\n            _0x6e0698 +\n            (_0xbf269c * RAY) /\n            (_0xdb07cb._0x990a7d + 1);\n        _0xdb07cb._0x990a7d += _0xbf269c;\n\n        uint256 _0xf3ce11 = _0x29effb(_0xbf269c, _0xdb07cb._0x9bc6be);\n        _0x2fc1ff(_0xdb07cb._0xe6a835, _0xd1ea70, _0xf3ce11);\n    }\n\n    function _0x215ca3(\n        address _0xea15f8,\n        uint256 _0xbf269c,\n        address _0xc7a8a1\n    ) external returns (uint256) {\n        ReserveData storage _0xdb07cb = _0xfb6b0a[_0xea15f8];\n\n        uint256 _0x400410 = _0x29effb(_0xbf269c, _0xdb07cb._0x9bc6be);\n\n        _0xaa01cd(_0xdb07cb._0xe6a835, msg.sender, _0x400410);\n\n        _0xdb07cb._0x990a7d -= _0xbf269c;\n        IERC20(_0xea15f8).transfer(_0xc7a8a1, _0xbf269c);\n\n        return _0xbf269c;\n    }\n\n    function _0x38a193(\n        address _0xea15f8,\n        uint256 _0xbf269c,\n        uint256 _0xb59f18,\n        uint16 _0xd0a296,\n        address _0xd1ea70\n    ) external {\n        IERC20(_0xea15f8).transfer(_0xd1ea70, _0xbf269c);\n    }\n\n    function _0xa42baa(\n        address _0x021f1d,\n        address[] calldata _0xd2c667,\n        uint256[] calldata _0x7ac430,\n        uint256[] calldata _0xf58ed1,\n        address _0xd1ea70,\n        bytes calldata _0x78ac12,\n        uint16 _0xd0a296\n    ) external {\n        for (uint256 i = 0; i < _0xd2c667.length; i++) {\n            IERC20(_0xd2c667[i]).transfer(_0x021f1d, _0x7ac430[i]);\n        }\n\n        require(\n            IFlashLoanReceiver(_0x021f1d)._0xd365bf(\n                _0xd2c667,\n                _0x7ac430,\n                new uint256[](_0xd2c667.length),\n                msg.sender,\n                _0x78ac12\n            ),\n            \"Flashloan callback failed\"\n        );\n\n        for (uint256 i = 0; i < _0xd2c667.length; i++) {\n            IERC20(_0xd2c667[i])._0xce115d(\n                _0x021f1d,\n                address(this),\n                _0x7ac430[i]\n            );\n        }\n    }\n\n    function _0x29effb(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 _0x20d27a = b / 2;\n        require(b != 0, \"Division by zero\");\n        return (a * RAY + _0x20d27a) / b;\n    }\n\n    function _0x2fc1ff(address _0x16a7e6, address _0xc7a8a1, uint256 _0xbf269c) internal {}\n\n    function _0xaa01cd(\n        address _0x16a7e6,\n        address from,\n        uint256 _0xbf269c\n    ) internal {}\n}\n",
      "rename_map": {
        "currentLiquidityIndex": "_0x6e0698",
        "executeOperation": "_0xd365bf",
        "interestRateMode": "_0xb59f18",
        "receiverAddress": "_0x021f1d",
        "totalLiquidity": "_0x990a7d",
        "liquidityIndex": "_0x9bc6be",
        "rTokenAddress": "_0xe6a835",
        "rTokensToBurn": "_0x400410",
        "transferFrom": "_0xce115d",
        "referralCode": "_0xd0a296",
        "rTokenAmount": "_0xf3ce11",
        "_burnRToken": "_0xaa01cd",
        "_mintRToken": "_0x2fc1ff",
        "onBehalfOf": "_0xd1ea70",
        "balanceOf": "_0xc97a1a",
        "initiator": "_0x233740",
        "flashLoan": "_0xa42baa",
        "premiums": "_0x9acb5a",
        "withdraw": "_0x215ca3",
        "reserves": "_0xfb6b0a",
        "reserve": "_0xdb07cb",
        "account": "_0xb84260",
        "spender": "_0xb7ffd3",
        "approve": "_0x6c411a",
        "amounts": "_0x7ac430",
        "deposit": "_0x9f4d0a",
        "rayDiv": "_0x29effb",
        "params": "_0x78ac12",
        "assets": "_0xd2c667",
        "rToken": "_0x16a7e6",
        "borrow": "_0x38a193",
        "amount": "_0xbf269c",
        "halfB": "_0x20d27a",
        "asset": "_0xea15f8",
        "modes": "_0xf58ed1",
        "to": "_0xc7a8a1"
      },
      "changes": [
        "Renamed 36 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_033",
      "transformed_id": "ss_l2_hex_sn_tc_033",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x2db1f4, uint256 _0x5b9809) external returns (bool);\n\n    function _0x82cb75(\n        address from,\n        address _0x2db1f4,\n        uint256 _0x5b9809\n    ) external returns (bool);\n\n    function _0xfb9598(address _0x66256d) external view returns (uint256);\n\n    function _0x3cbcee(address _0xe0afa6, uint256 _0x5b9809) external returns (bool);\n}\n\ncontract SocketGateway {\n    mapping(uint32 => address) public _0x176d2e;\n    mapping(address => bool) public _0x7d4157;\n\n    event RouteExecuted(uint32 _0xb37c5c, address _0x254829, bytes _0x2ed6df);\n\n    function _0x458a6b(\n        uint32 _0xb37c5c,\n        bytes calldata _0xaa4052\n    ) external payable returns (bytes memory) {\n        address _0xe40732 = _0x176d2e[_0xb37c5c];\n        require(_0xe40732 != address(0), \"Invalid route\");\n        require(_0x7d4157[_0xe40732], \"Route not approved\");\n\n        (bool _0x8bb5fc, bytes memory _0x2ed6df) = _0xe40732.call(_0xaa4052);\n        require(_0x8bb5fc, \"Route execution failed\");\n\n        emit RouteExecuted(_0xb37c5c, msg.sender, _0x2ed6df);\n        return _0x2ed6df;\n    }\n\n    function _0x9c3128(uint32 _0xb37c5c, address _0xe40732) external {\n        _0x176d2e[_0xb37c5c] = _0xe40732;\n        _0x7d4157[_0xe40732] = true;\n    }\n}\n\ncontract BasicRoute {\n    function _0x189d26(\n        address _0x893ed1,\n        address _0xe529c1,\n        uint256 _0x5b9809,\n        address _0x8c32a4,\n        bytes32 _0x9037c0,\n        bytes calldata _0xdcb71e\n    ) external payable returns (uint256) {\n        if (_0xdcb71e.length > 0) {\n            (bool _0x8bb5fc, ) = _0x893ed1.call(_0xdcb71e);\n            require(_0x8bb5fc, \"Swap failed\");\n        }\n\n        return _0x5b9809;\n    }\n}\n",
      "rename_map": {
        "receiverAddress": "_0x8c32a4",
        "approvedRoutes": "_0x7d4157",
        "swapExtraData": "_0xdcb71e",
        "performAction": "_0x189d26",
        "transferFrom": "_0x82cb75",
        "routeAddress": "_0xe40732",
        "executeRoute": "_0x458a6b",
        "balanceOf": "_0xfb9598",
        "routeData": "_0xaa4052",
        "fromToken": "_0x893ed1",
        "metadata": "_0x9037c0",
        "addRoute": "_0x9c3128",
        "account": "_0x66256d",
        "success": "_0x8bb5fc",
        "routeId": "_0xb37c5c",
        "spender": "_0xe0afa6",
        "approve": "_0x3cbcee",
        "toToken": "_0xe529c1",
        "result": "_0x2ed6df",
        "routes": "_0x176d2e",
        "amount": "_0x5b9809",
        "user": "_0x254829",
        "to": "_0x2db1f4"
      },
      "changes": [
        "Renamed 23 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_034",
      "transformed_id": "ss_l2_hex_sn_tc_034",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xe0537f, uint256 _0x03b7c5) external returns (bool);\n\n    function _0x4c280f(\n        address from,\n        address _0xe0537f,\n        uint256 _0x03b7c5\n    ) external returns (bool);\n\n    function _0xd22899(address _0x79a975) external view returns (uint256);\n\n    function _0x2aba6d(address _0x96618c, uint256 _0x03b7c5) external returns (bool);\n}\n\ninterface IUniswapV3Pool {\n    function _0x40cbfb(\n        address _0xfe5069,\n        bool _0x3e27f8,\n        int256 _0x91b50d,\n        uint160 _0xf047ab,\n        bytes calldata data\n    ) external returns (int256 _0x9e0349, int256 _0x11e27a);\n\n    function _0xff6621(\n        address _0xfe5069,\n        uint256 _0x9e0349,\n        uint256 _0x11e27a,\n        bytes calldata data\n    ) external;\n}\n\ncontract GammaHypervisor {\n    IERC20 public _0xc59a27;\n    IERC20 public _0x473913;\n    IUniswapV3Pool public _0x7fd94a;\n\n    uint256 public _0x83b8de;\n    mapping(address => uint256) public _0xd22899;\n\n    struct Position {\n        uint128 _0x091403;\n        int24 _0xf0e021;\n        int24 _0x2f75da;\n    }\n\n    Position public _0xda7de8;\n    Position public _0x997681;\n\n    function _0xf19c24(\n        uint256 _0x737c12,\n        uint256 _0x4b5ed1,\n        address _0xe0537f\n    ) external returns (uint256 _0xdaa9f4) {\n        uint256 _0xa96902 = _0xc59a27._0xd22899(address(this));\n        uint256 _0x8ffa3e = _0x473913._0xd22899(address(this));\n\n        _0xc59a27._0x4c280f(msg.sender, address(this), _0x737c12);\n        _0x473913._0x4c280f(msg.sender, address(this), _0x4b5ed1);\n\n        if (_0x83b8de == 0) {\n            _0xdaa9f4 = _0x737c12 + _0x4b5ed1;\n        } else {\n            uint256 _0x50e50a = _0xa96902 + _0x737c12;\n            uint256 _0x30a40b = _0x8ffa3e + _0x4b5ed1;\n\n            _0xdaa9f4 = (_0x83b8de * (_0x737c12 + _0x4b5ed1)) / (_0xa96902 + _0x8ffa3e);\n        }\n\n        _0xd22899[_0xe0537f] += _0xdaa9f4;\n        _0x83b8de += _0xdaa9f4;\n\n        _0xdd3ea8(_0x737c12, _0x4b5ed1);\n    }\n\n    function _0x08ee87(\n        uint256 _0xdaa9f4,\n        address _0xe0537f\n    ) external returns (uint256 _0x9e0349, uint256 _0x11e27a) {\n        require(_0xd22899[msg.sender] >= _0xdaa9f4, \"Insufficient balance\");\n\n        uint256 _0xa96902 = _0xc59a27._0xd22899(address(this));\n        uint256 _0x8ffa3e = _0x473913._0xd22899(address(this));\n\n        _0x9e0349 = (_0xdaa9f4 * _0xa96902) / _0x83b8de;\n        _0x11e27a = (_0xdaa9f4 * _0x8ffa3e) / _0x83b8de;\n\n        _0xd22899[msg.sender] -= _0xdaa9f4;\n        _0x83b8de -= _0xdaa9f4;\n\n        _0xc59a27.transfer(_0xe0537f, _0x9e0349);\n        _0x473913.transfer(_0xe0537f, _0x11e27a);\n    }\n\n    function _0x881ea9() external {\n        _0x61563b(_0xda7de8._0x091403);\n\n        _0xdd3ea8(\n            _0xc59a27._0xd22899(address(this)),\n            _0x473913._0xd22899(address(this))\n        );\n    }\n\n    function _0xdd3ea8(uint256 _0x9e0349, uint256 _0x11e27a) internal {}\n\n    function _0x61563b(uint128 _0x091403) internal {}\n}\n",
      "rename_map": {
        "sqrtPriceLimitX96": "_0xf047ab",
        "_removeLiquidity": "_0x61563b",
        "amountSpecified": "_0x91b50d",
        "amount1Current": "_0x30a40b",
        "amount0Current": "_0x50e50a",
        "limitPosition": "_0x997681",
        "_addLiquidity": "_0xdd3ea8",
        "transferFrom": "_0x4c280f",
        "basePosition": "_0xda7de8",
        "totalSupply": "_0x83b8de",
        "zeroForOne": "_0x3e27f8",
        "tickLower": "_0xf0e021",
        "balanceOf": "_0xd22899",
        "recipient": "_0xfe5069",
        "rebalance": "_0x881ea9",
        "liquidity": "_0x091403",
        "tickUpper": "_0x2f75da",
        "deposit1": "_0x4b5ed1",
        "withdraw": "_0x08ee87",
        "deposit0": "_0x737c12",
        "amount1": "_0x11e27a",
        "account": "_0x79a975",
        "spender": "_0x96618c",
        "approve": "_0x2aba6d",
        "deposit": "_0xf19c24",
        "amount0": "_0x9e0349",
        "shares": "_0xdaa9f4",
        "token0": "_0xc59a27",
        "total0": "_0xa96902",
        "token1": "_0x473913",
        "amount": "_0x03b7c5",
        "total1": "_0x8ffa3e",
        "flash": "_0xff6621",
        "swap": "_0x40cbfb",
        "pool": "_0x7fd94a",
        "to": "_0xe0537f"
      },
      "changes": [
        "Renamed 36 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_035",
      "transformed_id": "ss_l2_hex_sn_tc_035",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x755ffe, uint256 _0x1ca703) external returns (bool);\n\n    function _0x654e38(\n        address from,\n        address _0x755ffe,\n        uint256 _0x1ca703\n    ) external returns (bool);\n\n    function _0xeea563(address _0x919100) external view returns (uint256);\n\n    function _0x8054e9(address _0x007798, uint256 _0x1ca703) external returns (bool);\n}\n\ninterface IERC721 {\n    function _0x654e38(address from, address _0x755ffe, uint256 _0x34b0f8) external;\n\n    function _0xd677d5(uint256 _0x34b0f8) external view returns (address);\n}\n\ncontract WiseLending {\n    struct PoolData {\n        uint256 _0xbb8322;\n        uint256 _0xce0c25;\n        uint256 _0x071425;\n        uint256 _0xcdaf8d;\n    }\n\n    mapping(address => PoolData) public _0x9a7970;\n    mapping(uint256 => mapping(address => uint256)) public _0xa2263e;\n    mapping(uint256 => mapping(address => uint256)) public _0xec9fa5;\n\n    IERC721 public _0xb9a0b8;\n    uint256 public _0x056b61;\n\n    function _0xef0c5b() external returns (uint256) {\n        uint256 _0x95505e = ++_0x056b61;\n        return _0x95505e;\n    }\n\n    function _0x4da177(\n        uint256 _0xefc8c2,\n        address _0x6ad1ad,\n        uint256 _0xe5da2c\n    ) external returns (uint256 _0xdba823) {\n        IERC20(_0x6ad1ad)._0x654e38(msg.sender, address(this), _0xe5da2c);\n\n        PoolData storage _0xe23939 = _0x9a7970[_0x6ad1ad];\n\n        if (_0xe23939._0xce0c25 == 0) {\n            _0xdba823 = _0xe5da2c;\n            _0xe23939._0xce0c25 = _0xe5da2c;\n        } else {\n            _0xdba823 =\n                (_0xe5da2c * _0xe23939._0xce0c25) /\n                _0xe23939._0xbb8322;\n            _0xe23939._0xce0c25 += _0xdba823;\n        }\n\n        _0xe23939._0xbb8322 += _0xe5da2c;\n        _0xa2263e[_0xefc8c2][_0x6ad1ad] += _0xdba823;\n\n        return _0xdba823;\n    }\n\n    function _0xf8e985(\n        uint256 _0xefc8c2,\n        address _0x6ad1ad,\n        uint256 _0x8784c4\n    ) external returns (uint256 _0x2c9808) {\n        require(\n            _0xa2263e[_0xefc8c2][_0x6ad1ad] >= _0x8784c4,\n            \"Insufficient shares\"\n        );\n\n        PoolData storage _0xe23939 = _0x9a7970[_0x6ad1ad];\n\n        _0x2c9808 =\n            (_0x8784c4 * _0xe23939._0xbb8322) /\n            _0xe23939._0xce0c25;\n\n        _0xa2263e[_0xefc8c2][_0x6ad1ad] -= _0x8784c4;\n        _0xe23939._0xce0c25 -= _0x8784c4;\n        _0xe23939._0xbb8322 -= _0x2c9808;\n\n        IERC20(_0x6ad1ad).transfer(msg.sender, _0x2c9808);\n\n        return _0x2c9808;\n    }\n\n    function _0x4378cc(\n        uint256 _0xefc8c2,\n        address _0x6ad1ad,\n        uint256 _0x559183\n    ) external returns (uint256 _0x1fb9de) {\n        PoolData storage _0xe23939 = _0x9a7970[_0x6ad1ad];\n\n        _0x1fb9de =\n            (_0x559183 * _0xe23939._0xce0c25) /\n            _0xe23939._0xbb8322;\n\n        require(\n            _0xa2263e[_0xefc8c2][_0x6ad1ad] >= _0x1fb9de,\n            \"Insufficient shares\"\n        );\n\n        _0xa2263e[_0xefc8c2][_0x6ad1ad] -= _0x1fb9de;\n        _0xe23939._0xce0c25 -= _0x1fb9de;\n        _0xe23939._0xbb8322 -= _0x559183;\n\n        IERC20(_0x6ad1ad).transfer(msg.sender, _0x559183);\n\n        return _0x1fb9de;\n    }\n\n    function _0x9f1127(\n        uint256 _0xefc8c2,\n        address _0x6ad1ad\n    ) external view returns (uint256) {\n        return _0xa2263e[_0xefc8c2][_0x6ad1ad];\n    }\n\n    function _0x7ede52(address _0x6ad1ad) external view returns (uint256) {\n        return _0x9a7970[_0x6ad1ad]._0xbb8322;\n    }\n}\n",
      "rename_map": {
        "getPositionLendingShares": "_0x9f1127",
        "withdrawExactShares": "_0xf8e985",
        "withdrawExactAmount": "_0x4378cc",
        "totalDepositShares": "_0xce0c25",
        "depositExactAmount": "_0x4da177",
        "userLendingShares": "_0xa2263e",
        "totalBorrowShares": "_0x071425",
        "userBorrowShares": "_0xec9fa5",
        "collateralFactor": "_0xcdaf8d",
        "pseudoTotalPool": "_0xbb8322",
        "lendingPoolData": "_0x9a7970",
        "_withdrawAmount": "_0x559183",
        "withdrawAmount": "_0x2c9808",
        "transferFrom": "_0x654e38",
        "positionNFTs": "_0xb9a0b8",
        "mintPosition": "_0xef0c5b",
        "getTotalPool": "_0x7ede52",
        "nftIdCounter": "_0x056b61",
        "shareBurned": "_0x1fb9de",
        "shareAmount": "_0xdba823",
        "_poolToken": "_0x6ad1ad",
        "balanceOf": "_0xeea563",
        "account": "_0x919100",
        "spender": "_0x007798",
        "approve": "_0x8054e9",
        "_amount": "_0xe5da2c",
        "tokenId": "_0x34b0f8",
        "ownerOf": "_0xd677d5",
        "_shares": "_0x8784c4",
        "_nftId": "_0xefc8c2",
        "amount": "_0x1ca703",
        "nftId": "_0x95505e",
        "pool": "_0xe23939",
        "to": "_0x755ffe"
      },
      "changes": [
        "Renamed 34 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_036",
      "transformed_id": "ss_l2_hex_sn_tc_036",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x26843f, uint256 _0xcddc7f) external returns (bool);\n\n    function _0xe83e6d(\n        address from,\n        address _0x26843f,\n        uint256 _0xcddc7f\n    ) external returns (bool);\n\n    function _0x7340f7(address _0x083535) external view returns (uint256);\n\n    function _0x59c8d3(address _0x317a81, uint256 _0xcddc7f) external returns (bool);\n}\n\ninterface IBorrowerOperations {\n    function _0x8341d2(address _0x10ecf2, bool _0x7d086e) external;\n\n    function _0xecf919(\n        address _0x95b2ff,\n        address _0x083535,\n        uint256 _0x55d667,\n        uint256 _0x962aae,\n        uint256 _0xeaa9fa,\n        address _0xe7d533,\n        address _0xc0ca59\n    ) external;\n\n    function _0xb7331d(address _0x95b2ff, address _0x083535) external;\n}\n\ninterface ITroveManager {\n    function _0x083182(\n        address _0x32c60d\n    ) external view returns (uint256 _0xdf865f, uint256 _0x480977);\n\n    function _0xe5972b(address _0x32c60d) external;\n}\n\ncontract MigrateTroveZap {\n    IBorrowerOperations public _0xcb05c3;\n    address public _0xf4a13c;\n    address public _0xc29f68;\n\n    constructor(address _0x30d9a9, address _0xb38df6, address _0xd7119f) {\n        _0xcb05c3 = _0x30d9a9;\n        _0xf4a13c = _0xb38df6;\n        _0xc29f68 = _0xd7119f;\n    }\n\n    function _0x62acea(\n        address _0x95b2ff,\n        address _0x083535,\n        uint256 _0xcee0ac,\n        uint256 _0x572301,\n        uint256 _0x66d12a,\n        address _0xf8264b,\n        address _0x0a0da2\n    ) external {\n        IERC20(_0xf4a13c)._0xe83e6d(\n            msg.sender,\n            address(this),\n            _0x572301\n        );\n\n        IERC20(_0xf4a13c)._0x59c8d3(address(_0xcb05c3), _0x572301);\n\n        _0xcb05c3._0xecf919(\n            _0x95b2ff,\n            _0x083535,\n            _0xcee0ac,\n            _0x572301,\n            _0x66d12a,\n            _0xf8264b,\n            _0x0a0da2\n        );\n\n        IERC20(_0xc29f68).transfer(msg.sender, _0x66d12a);\n    }\n\n    function _0x746921(address _0x95b2ff, address _0x083535) external {\n        _0xcb05c3._0xb7331d(_0x95b2ff, _0x083535);\n    }\n}\n\ncontract BorrowerOperations {\n    mapping(address => mapping(address => bool)) public _0x1e7b20;\n    ITroveManager public _0x95b2ff;\n\n    function _0x8341d2(address _0x10ecf2, bool _0x7d086e) external {\n        _0x1e7b20[msg.sender][_0x10ecf2] = _0x7d086e;\n    }\n\n    function _0xecf919(\n        address _0x1bb5e5,\n        address _0x083535,\n        uint256 _0x55d667,\n        uint256 _0x962aae,\n        uint256 _0xeaa9fa,\n        address _0xe7d533,\n        address _0xc0ca59\n    ) external {\n        require(\n            msg.sender == _0x083535 || _0x1e7b20[_0x083535][msg.sender],\n            \"Not authorized\"\n        );\n    }\n\n    function _0xb7331d(address _0x1bb5e5, address _0x083535) external {\n        require(\n            msg.sender == _0x083535 || _0x1e7b20[_0x083535][msg.sender],\n            \"Not authorized\"\n        );\n    }\n}\n",
      "rename_map": {
        "openTroveAndMigrate": "_0x62acea",
        "_borrowerOperations": "_0x30d9a9",
        "setDelegateApproval": "_0x8341d2",
        "getTroveCollAndDebt": "_0x083182",
        "borrowerOperations": "_0xcb05c3",
        "_maxFeePercentage": "_0x55d667",
        "_collateralAmount": "_0x962aae",
        "maxFeePercentage": "_0xcee0ac",
        "collateralAmount": "_0x572301",
        "closeTroveFor": "_0x746921",
        "_troveManager": "_0x1bb5e5",
        "transferFrom": "_0xe83e6d",
        "troveManager": "_0x95b2ff",
        "_isApproved": "_0x7d086e",
        "_debtAmount": "_0xeaa9fa",
        "debtAmount": "_0x66d12a",
        "_upperHint": "_0xe7d533",
        "closeTrove": "_0xb7331d",
        "_lowerHint": "_0xc0ca59",
        "balanceOf": "_0x7340f7",
        "_borrower": "_0x32c60d",
        "_delegate": "_0x10ecf2",
        "liquidate": "_0xe5972b",
        "lowerHint": "_0x0a0da2",
        "delegates": "_0x1e7b20",
        "openTrove": "_0xecf919",
        "upperHint": "_0xf8264b",
        "account": "_0x083535",
        "spender": "_0x317a81",
        "approve": "_0x59c8d3",
        "_wstETH": "_0xb38df6",
        "_mkUSD": "_0xd7119f",
        "wstETH": "_0xf4a13c",
        "amount": "_0xcddc7f",
        "mkUSD": "_0xc29f68",
        "debt": "_0x480977",
        "coll": "_0xdf865f",
        "to": "_0x26843f"
      },
      "changes": [
        "Renamed 38 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_037",
      "transformed_id": "ss_l2_hex_sn_tc_037",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xf5b9e7, uint256 _0x25b670) external returns (bool);\n\n    function _0xcea1d8(\n        address from,\n        address _0xf5b9e7,\n        uint256 _0x25b670\n    ) external returns (bool);\n\n    function _0x2cd988(address _0x661532) external view returns (uint256);\n\n    function _0x0912b0(address _0x3e087b, uint256 _0x25b670) external returns (bool);\n}\n\ninterface IAaveOracle {\n    function _0x57b274(address _0x2360fc) external view returns (uint256);\n\n    function _0x5a1097(\n        address[] calldata _0x0cde15,\n        address[] calldata _0xa214e1\n    ) external;\n}\n\ninterface ICurvePool {\n    function _0xb8c81e(\n        int128 i,\n        int128 j,\n        uint256 _0x4b1db3,\n        uint256 _0x925386\n    ) external returns (uint256);\n\n    function _0x775e62(\n        int128 i,\n        int128 j,\n        uint256 _0x4b1db3\n    ) external view returns (uint256);\n\n    function _0x20992a(uint256 i) external view returns (uint256);\n}\n\ninterface ILendingPool {\n    function _0x8843e6(\n        address _0x2360fc,\n        uint256 _0x25b670,\n        address _0xe12e14,\n        uint16 _0x6abf89\n    ) external;\n\n    function _0x2ce3be(\n        address _0x2360fc,\n        uint256 _0x25b670,\n        uint256 _0xe59404,\n        uint16 _0x6abf89,\n        address _0xe12e14\n    ) external;\n\n    function _0xdff017(\n        address _0x2360fc,\n        uint256 _0x25b670,\n        address _0xf5b9e7\n    ) external returns (uint256);\n}\n\ncontract UwuLendingPool is ILendingPool {\n    IAaveOracle public _0xc54ce3;\n    mapping(address => uint256) public _0x3eaa28;\n    mapping(address => uint256) public _0x1df5b8;\n    uint256 public constant LTV = 8500;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    function _0x8843e6(\n        address _0x2360fc,\n        uint256 _0x25b670,\n        address _0xe12e14,\n        uint16 _0x6abf89\n    ) external override {\n        IERC20(_0x2360fc)._0xcea1d8(msg.sender, address(this), _0x25b670);\n        _0x3eaa28[_0xe12e14] += _0x25b670;\n    }\n\n    function _0x2ce3be(\n        address _0x2360fc,\n        uint256 _0x25b670,\n        uint256 _0xe59404,\n        uint16 _0x6abf89,\n        address _0xe12e14\n    ) external override {\n        uint256 _0x2cd2bd = _0xc54ce3._0x57b274(msg.sender);\n        uint256 _0x30771a = _0xc54ce3._0x57b274(_0x2360fc);\n\n        uint256 _0x2cbe78 = (_0x3eaa28[msg.sender] * _0x2cd2bd) /\n            1e18;\n        uint256 _0xfb2313 = (_0x2cbe78 * LTV) / BASIS_POINTS;\n\n        uint256 _0xd76316 = (_0x25b670 * _0x30771a) / 1e18;\n\n        require(_0xd76316 <= _0xfb2313, \"Insufficient collateral\");\n\n        _0x1df5b8[msg.sender] += _0x25b670;\n        IERC20(_0x2360fc).transfer(_0xe12e14, _0x25b670);\n    }\n\n    function _0xdff017(\n        address _0x2360fc,\n        uint256 _0x25b670,\n        address _0xf5b9e7\n    ) external override returns (uint256) {\n        require(_0x3eaa28[msg.sender] >= _0x25b670, \"Insufficient balance\");\n        _0x3eaa28[msg.sender] -= _0x25b670;\n        IERC20(_0x2360fc).transfer(_0xf5b9e7, _0x25b670);\n        return _0x25b670;\n    }\n}\n\ncontract CurveOracle {\n    ICurvePool public _0x513f51;\n\n    constructor(address _0x123ed9) {\n        _0x513f51 = _0x123ed9;\n    }\n\n    function _0x57b274(address _0x2360fc) external view returns (uint256) {\n        uint256 _0xb73a90 = _0x513f51._0x20992a(0);\n        uint256 _0xbae2cc = _0x513f51._0x20992a(1);\n\n        uint256 _0x8154e8 = (_0xbae2cc * 1e18) / _0xb73a90;\n\n        return _0x8154e8;\n    }\n}\n",
      "rename_map": {
        "interestRateMode": "_0xe59404",
        "setAssetSources": "_0x5a1097",
        "collateralValue": "_0x2cbe78",
        "collateralPrice": "_0x2cd2bd",
        "getAssetPrice": "_0x57b274",
        "transferFrom": "_0xcea1d8",
        "referralCode": "_0x6abf89",
        "borrowPrice": "_0x30771a",
        "borrowValue": "_0xd76316",
        "onBehalfOf": "_0xe12e14",
        "curvePool": "_0x513f51",
        "balanceOf": "_0x2cd988",
        "maxBorrow": "_0xfb2313",
        "exchange": "_0xb8c81e",
        "balances": "_0x20992a",
        "deposits": "_0x3eaa28",
        "balance1": "_0xbae2cc",
        "balance0": "_0xb73a90",
        "withdraw": "_0xdff017",
        "sources": "_0xa214e1",
        "account": "_0x661532",
        "borrows": "_0x1df5b8",
        "spender": "_0x3e087b",
        "approve": "_0x0912b0",
        "deposit": "_0x8843e6",
        "min_dy": "_0x925386",
        "get_dy": "_0x775e62",
        "assets": "_0x0cde15",
        "oracle": "_0xc54ce3",
        "borrow": "_0x2ce3be",
        "amount": "_0x25b670",
        "price": "_0x8154e8",
        "_pool": "_0x123ed9",
        "asset": "_0x2360fc",
        "dx": "_0x4b1db3",
        "to": "_0xf5b9e7"
      },
      "changes": [
        "Renamed 36 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_038",
      "transformed_id": "ss_l2_hex_sn_tc_038",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x4ae5f1, uint256 _0xfe4855) external returns (bool);\n\n    function _0xfd9a2e(\n        address from,\n        address _0x4ae5f1,\n        uint256 _0xfe4855\n    ) external returns (bool);\n\n    function _0x9f0eef(address _0x4082c8) external view returns (uint256);\n\n    function _0xa17bdf(address _0x5f273e, uint256 _0xfe4855) external returns (bool);\n}\n\ninterface IPriceOracle {\n    function _0xe78efd(address _0x93070b) external view returns (uint256);\n}\n\ncontract BlueberryLending {\n    struct Market {\n        bool _0x10fcbf;\n        uint256 _0xb2dd20;\n        mapping(address => uint256) _0xef50b3;\n        mapping(address => uint256) _0x7e6408;\n    }\n\n    mapping(address => Market) public _0x471c45;\n    IPriceOracle public _0xc29940;\n\n    uint256 public constant COLLATERAL_FACTOR = 75;\n    uint256 public constant BASIS_POINTS = 100;\n\n    function _0xff0c17(\n        address[] calldata _0xa56717\n    ) external returns (uint256[] memory) {\n        uint256[] memory _0x1acf14 = new uint256[](_0xa56717.length);\n        for (uint256 i = 0; i < _0xa56717.length; i++) {\n            _0x471c45[_0xa56717[i]]._0x10fcbf = true;\n            _0x1acf14[i] = 0;\n        }\n        return _0x1acf14;\n    }\n\n    function _0xbcd73c(address _0x93070b, uint256 _0xfe4855) external returns (uint256) {\n        IERC20(_0x93070b)._0xfd9a2e(msg.sender, address(this), _0xfe4855);\n\n        uint256 _0x27964a = _0xc29940._0xe78efd(_0x93070b);\n\n        _0x471c45[_0x93070b]._0xef50b3[msg.sender] += _0xfe4855;\n        return 0;\n    }\n\n    function _0x9fae3e(\n        address _0xe4d25c,\n        uint256 _0x278cac\n    ) external returns (uint256) {\n        uint256 _0xb95599 = 0;\n\n        uint256 _0xc9b8ed = _0xc29940._0xe78efd(_0xe4d25c);\n        uint256 _0x5b9091 = (_0x278cac * _0xc9b8ed) / 1e18;\n\n        uint256 _0xa9f26e = (_0xb95599 * COLLATERAL_FACTOR) /\n            BASIS_POINTS;\n\n        require(_0x5b9091 <= _0xa9f26e, \"Insufficient collateral\");\n\n        _0x471c45[_0xe4d25c]._0x7e6408[msg.sender] += _0x278cac;\n        IERC20(_0xe4d25c).transfer(msg.sender, _0x278cac);\n\n        return 0;\n    }\n\n    function _0xf533b2(\n        address _0x29dbe3,\n        address _0x3dc47a,\n        uint256 _0xa3153e,\n        address _0x262810\n    ) external {}\n}\n\ncontract ManipulableOracle is IPriceOracle {\n    mapping(address => uint256) public _0x99174a;\n\n    function _0xe78efd(address _0x93070b) external view override returns (uint256) {\n        return _0x99174a[_0x93070b];\n    }\n\n    function _0xd8b756(address _0x93070b, uint256 _0x27964a) external {\n        _0x99174a[_0x93070b] = _0x27964a;\n    }\n}\n",
      "rename_map": {
        "totalCollateralValue": "_0xb95599",
        "accountCollateral": "_0xef50b3",
        "collateralFactor": "_0xb2dd20",
        "collateralToken": "_0x262810",
        "accountBorrows": "_0x7e6408",
        "maxBorrowValue": "_0xa9f26e",
        "transferFrom": "_0xfd9a2e",
        "borrowAmount": "_0x278cac",
        "enterMarkets": "_0xff0c17",
        "borrowPrice": "_0xc9b8ed",
        "borrowValue": "_0x5b9091",
        "borrowToken": "_0xe4d25c",
        "repayAmount": "_0xa3153e",
        "repayToken": "_0x3dc47a",
        "balanceOf": "_0x9f0eef",
        "liquidate": "_0xf533b2",
        "isListed": "_0x10fcbf",
        "setPrice": "_0xd8b756",
        "getPrice": "_0xe78efd",
        "borrower": "_0x29dbe3",
        "account": "_0x4082c8",
        "results": "_0x1acf14",
        "vTokens": "_0xa56717",
        "spender": "_0x5f273e",
        "approve": "_0xa17bdf",
        "markets": "_0x471c45",
        "oracle": "_0xc29940",
        "borrow": "_0x9fae3e",
        "prices": "_0x99174a",
        "amount": "_0xfe4855",
        "price": "_0x27964a",
        "token": "_0x93070b",
        "mint": "_0xbcd73c",
        "to": "_0x4ae5f1"
      },
      "changes": [
        "Renamed 34 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_039",
      "transformed_id": "ss_l2_hex_sn_tc_039",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x42300a, uint256 _0x58bde6) external returns (bool);\n\n    function _0xfc57c0(\n        address from,\n        address _0x42300a,\n        uint256 _0x58bde6\n    ) external returns (bool);\n\n    function _0xea7d75(address _0xe3e06f) external view returns (uint256);\n\n    function _0x2c50f4(address _0x7b612b, uint256 _0x58bde6) external returns (bool);\n}\n\ninterface IWETH {\n    function _0x8bca28() external payable;\n\n    function _0x501c8b(uint256 _0x58bde6) external;\n\n    function _0xea7d75(address _0xe3e06f) external view returns (uint256);\n}\n\ncontract CowSolver {\n    IWETH public immutable WETH;\n    address public immutable _0xaed6d9;\n\n    constructor(address _0xef9371, address _0x0b5fd2) {\n        WETH = IWETH(_0xef9371);\n        _0xaed6d9 = _0x0b5fd2;\n    }\n\n    function _0x6d301c(\n        int256 _0x35bf01,\n        int256 _0x7522bd,\n        bytes calldata data\n    ) external payable {\n        (\n            uint256 _0xb1e115,\n            address _0x7fae2f,\n            address _0xf470aa,\n            address _0xa9aa37\n        ) = abi._0xffccd2(data, (uint256, address, address, address));\n\n        uint256 _0x6a8b1b;\n        if (_0x35bf01 > 0) {\n            _0x6a8b1b = uint256(_0x35bf01);\n        } else {\n            _0x6a8b1b = uint256(_0x7522bd);\n        }\n\n        if (_0xf470aa == address(WETH)) {\n            WETH._0x501c8b(_0x6a8b1b);\n            payable(_0xa9aa37).transfer(_0x6a8b1b);\n        } else {\n            IERC20(_0xf470aa).transfer(_0xa9aa37, _0x6a8b1b);\n        }\n    }\n\n    function _0xca1956(bytes calldata _0x13e910) external {\n        require(msg.sender == _0xaed6d9, \"Only settlement\");\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "uniswapV3SwapCallback": "_0x6d301c",
        "executeSettlement": "_0xca1956",
        "settlementData": "_0x13e910",
        "transferFrom": "_0xfc57c0",
        "amount1Delta": "_0x7522bd",
        "amount0Delta": "_0x35bf01",
        "amountToPay": "_0x6a8b1b",
        "_settlement": "_0x0b5fd2",
        "settlement": "_0xaed6d9",
        "balanceOf": "_0xea7d75",
        "recipient": "_0xa9aa37",
        "withdraw": "_0x501c8b",
        "tokenIn": "_0xf470aa",
        "account": "_0xe3e06f",
        "spender": "_0x7b612b",
        "approve": "_0x2c50f4",
        "deposit": "_0x8bca28",
        "solver": "_0x7fae2f",
        "decode": "_0xffccd2",
        "amount": "_0x58bde6",
        "price": "_0xb1e115",
        "_weth": "_0xef9371",
        "to": "_0x42300a"
      },
      "changes": [
        "Renamed 23 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_040",
      "transformed_id": "ss_l2_hex_sn_tc_040",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x7af535, uint256 _0x1c9651) external returns (bool);\n\n    function _0x157783(\n        address from,\n        address _0x7af535,\n        uint256 _0x1c9651\n    ) external returns (bool);\n\n    function _0x9cdbff(address _0xde4c19) external view returns (uint256);\n\n    function _0xcf992b(address _0x524178, uint256 _0x1c9651) external returns (bool);\n}\n\ninterface IUniswapV3Router {\n    struct ExactInputSingleParams {\n        address _0xc157d6;\n        address _0xb2a36e;\n        uint24 _0xd68578;\n        address _0x228e35;\n        uint256 _0x881810;\n        uint256 _0x524875;\n        uint256 _0xf388f9;\n        uint160 _0xe4708e;\n    }\n\n    function _0x86f74f(\n        ExactInputSingleParams calldata _0x8ac67d\n    ) external payable returns (uint256 _0x2dd3db);\n}\n\ncontract BedrockVault {\n    IERC20 public immutable _0xacc169;\n    IERC20 public immutable WBTC;\n    IUniswapV3Router public immutable _0x3f55ed;\n\n    uint256 public _0x5c4359;\n    uint256 public _0xb4d091;\n\n    constructor(address _0x146e17, address _0xa81be9, address _0xe506e0) {\n        _0xacc169 = IERC20(_0x146e17);\n        WBTC = IERC20(_0xa81be9);\n        _0x3f55ed = IUniswapV3Router(_0xe506e0);\n    }\n\n    function _0xca7a5e() external payable {\n        require(msg.value > 0, \"No ETH sent\");\n\n        uint256 _0x81e077 = msg.value;\n\n        _0x5c4359 += msg.value;\n        _0xb4d091 += _0x81e077;\n\n        _0xacc169.transfer(msg.sender, _0x81e077);\n    }\n\n    function _0x24aa3f(uint256 _0x1c9651) external {\n        require(_0x1c9651 > 0, \"No amount specified\");\n        require(_0xacc169._0x9cdbff(msg.sender) >= _0x1c9651, \"Insufficient balance\");\n\n        _0xacc169._0x157783(msg.sender, address(this), _0x1c9651);\n\n        uint256 _0x0e8259 = _0x1c9651;\n        require(address(this).balance >= _0x0e8259, \"Insufficient ETH\");\n\n        payable(msg.sender).transfer(_0x0e8259);\n    }\n\n    function _0x6b2834() external pure returns (uint256) {\n        return 1e18;\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "totalETHDeposited": "_0x5c4359",
        "sqrtPriceLimitX96": "_0xe4708e",
        "totalUniBTCMinted": "_0xb4d091",
        "exactInputSingle": "_0x86f74f",
        "amountOutMinimum": "_0xf388f9",
        "getExchangeRate": "_0x6b2834",
        "transferFrom": "_0x157783",
        "uniBTCAmount": "_0x81e077",
        "balanceOf": "_0x9cdbff",
        "recipient": "_0x228e35",
        "amountOut": "_0x2dd3db",
        "ethAmount": "_0x0e8259",
        "deadline": "_0x881810",
        "amountIn": "_0x524875",
        "tokenOut": "_0xb2a36e",
        "_uniBTC": "_0x146e17",
        "tokenIn": "_0xc157d6",
        "account": "_0xde4c19",
        "spender": "_0x524178",
        "approve": "_0xcf992b",
        "_router": "_0xe506e0",
        "uniBTC": "_0xacc169",
        "params": "_0x8ac67d",
        "redeem": "_0x24aa3f",
        "router": "_0x3f55ed",
        "amount": "_0x1c9651",
        "_wbtc": "_0xa81be9",
        "mint": "_0xca7a5e",
        "fee": "_0xd68578",
        "to": "_0x7af535"
      },
      "changes": [
        "Renamed 30 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_041",
      "transformed_id": "ss_l2_hex_sn_tc_041",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xaa12f5, uint256 _0xe8a2da) external returns (bool);\n\n    function _0x5dfe07(\n        address from,\n        address _0xaa12f5,\n        uint256 _0xe8a2da\n    ) external returns (bool);\n\n    function _0x000c03(address _0x6673a1) external view returns (uint256);\n\n    function _0x68afd9(address _0x378611, uint256 _0xe8a2da) external returns (bool);\n}\n\ncontract ShezmuCollateralToken is IERC20 {\n    string public _0x12207b = \"Shezmu Collateral Token\";\n    string public _0x47a8ac = \"SCT\";\n    uint8 public _0x4f58dd = 18;\n\n    mapping(address => uint256) public _0x000c03;\n    mapping(address => mapping(address => uint256)) public _0xcb2bee;\n    uint256 public _0xaffb48;\n\n    function _0x5546ae(address _0xaa12f5, uint256 _0xe8a2da) external {\n        _0x000c03[_0xaa12f5] += _0xe8a2da;\n        _0xaffb48 += _0xe8a2da;\n    }\n\n    function transfer(\n        address _0xaa12f5,\n        uint256 _0xe8a2da\n    ) external override returns (bool) {\n        require(_0x000c03[msg.sender] >= _0xe8a2da, \"Insufficient balance\");\n        _0x000c03[msg.sender] -= _0xe8a2da;\n        _0x000c03[_0xaa12f5] += _0xe8a2da;\n        return true;\n    }\n\n    function _0x5dfe07(\n        address from,\n        address _0xaa12f5,\n        uint256 _0xe8a2da\n    ) external override returns (bool) {\n        require(_0x000c03[from] >= _0xe8a2da, \"Insufficient balance\");\n        require(\n            _0xcb2bee[from][msg.sender] >= _0xe8a2da,\n            \"Insufficient allowance\"\n        );\n        _0x000c03[from] -= _0xe8a2da;\n        _0x000c03[_0xaa12f5] += _0xe8a2da;\n        _0xcb2bee[from][msg.sender] -= _0xe8a2da;\n        return true;\n    }\n\n    function _0x68afd9(\n        address _0x378611,\n        uint256 _0xe8a2da\n    ) external override returns (bool) {\n        _0xcb2bee[msg.sender][_0x378611] = _0xe8a2da;\n        return true;\n    }\n}\n\ncontract ShezmuVault {\n    IERC20 public _0x6e0d93;\n    IERC20 public _0x6d1bc5;\n\n    mapping(address => uint256) public _0x6d6249;\n    mapping(address => uint256) public _0xcad63b;\n\n    uint256 public constant COLLATERAL_RATIO = 150;\n    uint256 public constant BASIS_POINTS = 100;\n\n    constructor(address _0x49e184, address _0x4927d2) {\n        _0x6e0d93 = IERC20(_0x49e184);\n        _0x6d1bc5 = IERC20(_0x4927d2);\n    }\n\n    function _0x93c9e7(uint256 _0xe8a2da) external {\n        _0x6e0d93._0x5dfe07(msg.sender, address(this), _0xe8a2da);\n        _0x6d6249[msg.sender] += _0xe8a2da;\n    }\n\n    function _0x48fcc3(uint256 _0xe8a2da) external {\n        uint256 _0x09eac0 = (_0x6d6249[msg.sender] * BASIS_POINTS) /\n            COLLATERAL_RATIO;\n\n        require(\n            _0xcad63b[msg.sender] + _0xe8a2da <= _0x09eac0,\n            \"Insufficient collateral\"\n        );\n\n        _0xcad63b[msg.sender] += _0xe8a2da;\n\n        _0x6d1bc5.transfer(msg.sender, _0xe8a2da);\n    }\n\n    function _0x4f15e7(uint256 _0xe8a2da) external {\n        require(_0xcad63b[msg.sender] >= _0xe8a2da, \"Excessive repayment\");\n        _0x6d1bc5._0x5dfe07(msg.sender, address(this), _0xe8a2da);\n        _0xcad63b[msg.sender] -= _0xe8a2da;\n    }\n\n    function _0x8a5000(uint256 _0xe8a2da) external {\n        require(\n            _0x6d6249[msg.sender] >= _0xe8a2da,\n            \"Insufficient collateral\"\n        );\n        uint256 _0x9a20c4 = _0x6d6249[msg.sender] - _0xe8a2da;\n        uint256 _0x7c571d = (_0x9a20c4 * BASIS_POINTS) /\n            COLLATERAL_RATIO;\n        require(\n            _0xcad63b[msg.sender] <= _0x7c571d,\n            \"Would be undercollateralized\"\n        );\n\n        _0x6d6249[msg.sender] -= _0xe8a2da;\n        _0x6e0d93.transfer(msg.sender, _0xe8a2da);\n    }\n}\n",
      "rename_map": {
        "remainingCollateral": "_0x9a20c4",
        "withdrawCollateral": "_0x8a5000",
        "collateralBalance": "_0x6d6249",
        "_collateralToken": "_0x49e184",
        "collateralToken": "_0x6e0d93",
        "addCollateral": "_0x93c9e7",
        "transferFrom": "_0x5dfe07",
        "totalSupply": "_0xaffb48",
        "debtBalance": "_0xcad63b",
        "balanceOf": "_0x000c03",
        "maxBorrow": "_0x09eac0",
        "allowance": "_0xcb2bee",
        "_shezUSD": "_0x4927d2",
        "decimals": "_0x4f58dd",
        "account": "_0x6673a1",
        "shezUSD": "_0x6d1bc5",
        "spender": "_0x378611",
        "approve": "_0x68afd9",
        "maxDebt": "_0x7c571d",
        "symbol": "_0x47a8ac",
        "borrow": "_0x48fcc3",
        "amount": "_0xe8a2da",
        "repay": "_0x4f15e7",
        "mint": "_0x5546ae",
        "name": "_0x12207b",
        "to": "_0xaa12f5"
      },
      "changes": [
        "Renamed 26 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_042",
      "transformed_id": "ss_l2_hex_sn_tc_042",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xfca7c4, uint256 _0x9c9734) external returns (bool);\n\n    function _0x5af8dd(\n        address from,\n        address _0xfca7c4,\n        uint256 _0x9c9734\n    ) external returns (bool);\n\n    function _0x952140(address _0xdf5107) external view returns (uint256);\n\n    function _0x4581b4(address _0x197458, uint256 _0x9c9734) external returns (bool);\n}\n\nenum TokenLockup {\n    Unlocked,\n    Locked,\n    Vesting\n}\n\nstruct Campaign {\n    address _0x933669;\n    address _0xe0f331;\n    uint256 _0x9c9734;\n    uint256 _0xe0bd67;\n    TokenLockup _0x47a119;\n    bytes32 _0xb19482;\n}\n\nstruct ClaimLockup {\n    address _0x722525;\n    uint256 _0x4a8404;\n    uint256 _0xaf519c;\n    uint256 _0x9da50e;\n    uint256 _0xd81907;\n}\n\nstruct Donation {\n    address _0x722525;\n    uint256 _0x9c9734;\n    uint256 _0x2dc857;\n    uint256 _0x4a8404;\n    uint256 _0xaf519c;\n    uint256 _0x9da50e;\n}\n\ncontract HedgeyClaimCampaigns {\n    mapping(bytes16 => Campaign) public _0x1c4ee6;\n\n    function _0x44ba4e(\n        bytes16 _0x720431,\n        Campaign memory _0x8492be,\n        ClaimLockup memory _0xe016ba,\n        Donation memory _0xc21a9e\n    ) external {\n        require(_0x1c4ee6[_0x720431]._0x933669 == address(0), \"Campaign exists\");\n\n        _0x1c4ee6[_0x720431] = _0x8492be;\n\n        if (_0xc21a9e._0x9c9734 > 0 && _0xc21a9e._0x722525 != address(0)) {\n            (bool _0x488f81, ) = _0xc21a9e._0x722525.call(\n                abi._0x285db0(\n                    \"createTokenLock(address,uint256,uint256,uint256,uint256,uint256)\",\n                    _0x8492be._0xe0f331,\n                    _0xc21a9e._0x9c9734,\n                    _0xc21a9e._0x4a8404,\n                    _0xc21a9e._0xaf519c,\n                    _0xc21a9e._0x2dc857,\n                    _0xc21a9e._0x9da50e\n                )\n            );\n\n            require(_0x488f81, \"Token lock failed\");\n        }\n    }\n\n    function _0x75f343(bytes16 _0x6fa7a3) external {\n        require(_0x1c4ee6[_0x6fa7a3]._0x933669 == msg.sender, \"Not manager\");\n        delete _0x1c4ee6[_0x6fa7a3];\n    }\n}\n",
      "rename_map": {
        "createLockedCampaign": "_0x44ba4e",
        "encodeWithSignature": "_0x285db0",
        "cancelCampaign": "_0x75f343",
        "transferFrom": "_0x5af8dd",
        "claimLockup": "_0xe016ba",
        "tokenLockup": "_0x47a119",
        "tokenLocker": "_0x722525",
        "campaignId": "_0x6fa7a3",
        "balanceOf": "_0x952140",
        "campaigns": "_0x1c4ee6",
        "donation": "_0xc21a9e",
        "campaign": "_0x8492be",
        "account": "_0xdf5107",
        "success": "_0x488f81",
        "spender": "_0x197458",
        "approve": "_0x4581b4",
        "periods": "_0xd81907",
        "manager": "_0x933669",
        "period": "_0x9da50e",
        "amount": "_0x9c9734",
        "start": "_0x4a8404",
        "cliff": "_0xaf519c",
        "token": "_0xe0f331",
        "root": "_0xb19482",
        "rate": "_0x2dc857",
        "end": "_0xe0bd67",
        "id": "_0x720431",
        "to": "_0xfca7c4"
      },
      "changes": [
        "Renamed 28 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_043",
      "transformed_id": "ss_l2_hex_sn_tc_043",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x5bad3c, uint256 _0x2a07ca) external returns (bool);\n\n    function _0xee979b(\n        address from,\n        address _0x5bad3c,\n        uint256 _0x2a07ca\n    ) external returns (bool);\n\n    function _0x456048(address _0x83747e) external view returns (uint256);\n\n    function _0x691135(address _0x6dd9f8, uint256 _0x2a07ca) external returns (bool);\n}\n\ncontract SenecaChamber {\n    uint8 public constant OPERATION_CALL = 30;\n    uint8 public constant OPERATION_DELEGATECALL = 31;\n\n    mapping(address => bool) public _0x8a7915;\n\n    function _0xbeefde(\n        uint8[] memory _0xb70aaf,\n        uint256[] memory _0x99e1bd,\n        bytes[] memory _0x42eb62\n    ) external payable returns (uint256 _0x7c72a0, uint256 _0x4b5267) {\n        require(\n            _0xb70aaf.length == _0x99e1bd.length && _0x99e1bd.length == _0x42eb62.length,\n            \"Length mismatch\"\n        );\n\n        for (uint256 i = 0; i < _0xb70aaf.length; i++) {\n            if (_0xb70aaf[i] == OPERATION_CALL) {\n                (address _0xc40ab5, bytes memory callData, , , ) = abi._0xf1fc29(\n                    _0x42eb62[i],\n                    (address, bytes, uint256, uint256, uint256)\n                );\n\n                (bool _0x07bafb, ) = _0xc40ab5.call{value: _0x99e1bd[i]}(callData);\n                require(_0x07bafb, \"Call failed\");\n            }\n        }\n\n        return (0, 0);\n    }\n}\n",
      "rename_map": {
        "performOperations": "_0xbeefde",
        "transferFrom": "_0xee979b",
        "vaultOwners": "_0x8a7915",
        "balanceOf": "_0x456048",
        "actions": "_0xb70aaf",
        "spender": "_0x6dd9f8",
        "approve": "_0x691135",
        "success": "_0x07bafb",
        "account": "_0x83747e",
        "value2": "_0x4b5267",
        "decode": "_0xf1fc29",
        "value1": "_0x7c72a0",
        "values": "_0x99e1bd",
        "amount": "_0x2a07ca",
        "target": "_0xc40ab5",
        "datas": "_0x42eb62",
        "to": "_0x5bad3c"
      },
      "changes": [
        "Renamed 17 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_044",
      "transformed_id": "ss_l2_hex_sn_tc_044",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x4a1e47, uint256 _0xa0f209) external returns (bool);\n\n    function _0x08bb61(\n        address from,\n        address _0x4a1e47,\n        uint256 _0xa0f209\n    ) external returns (bool);\n\n    function _0xaf792e(address _0xa927fe) external view returns (uint256);\n\n    function _0x325fa7(address _0x33b8b8, uint256 _0xa0f209) external returns (bool);\n}\n\ninterface ISmartLoan {\n    function _0x39128c(\n        bytes32 _0xaa562d,\n        bytes32 _0x9aeebb,\n        uint256 _0x7d7c10,\n        uint256 _0x969742,\n        bytes4 selector,\n        bytes memory data\n    ) external;\n\n    function _0x476b9f(address _0x472297, uint256[] calldata _0xd1ff00) external;\n}\n\ncontract SmartLoansFactory {\n    address public _0xd91eef;\n\n    constructor() {\n        _0xd91eef = msg.sender;\n    }\n\n    function _0x01bbc6() external returns (address) {\n        SmartLoan _0x815e99 = new SmartLoan();\n        return address(_0x815e99);\n    }\n\n    function _0xc1c563(\n        address _0x70f742,\n        address _0x10389e\n    ) external {\n        require(msg.sender == _0xd91eef, \"Not admin\");\n    }\n}\n\ncontract SmartLoan is ISmartLoan {\n    mapping(bytes32 => uint256) public _0x368d07;\n    mapping(bytes32 => uint256) public _0xd078cd;\n\n    function _0x39128c(\n        bytes32 _0xaa562d,\n        bytes32 _0x9aeebb,\n        uint256 _0x7d7c10,\n        uint256 _0x969742,\n        bytes4 selector,\n        bytes memory data\n    ) external override {}\n\n    function _0x476b9f(\n        address _0x472297,\n        uint256[] calldata _0xd1ff00\n    ) external override {\n        (bool _0x68f9f6, ) = _0x472297.call(\n            abi._0x76ac70(\"claimRewards(address)\", msg.sender)\n        );\n    }\n}\n",
      "rename_map": {
        "encodeWithSignature": "_0x76ac70",
        "newImplementation": "_0x10389e",
        "swapDebtParaSwap": "_0x39128c",
        "_borrowAmount": "_0x969742",
        "transferFrom": "_0x08bb61",
        "_repayAmount": "_0x7d7c10",
        "upgradePool": "_0xc1c563",
        "claimReward": "_0x476b9f",
        "_fromAsset": "_0xaa562d",
        "createLoan": "_0x01bbc6",
        "balanceOf": "_0xaf792e",
        "poolProxy": "_0x70f742",
        "_toAsset": "_0x9aeebb",
        "deposits": "_0x368d07",
        "account": "_0xa927fe",
        "success": "_0x68f9f6",
        "spender": "_0x33b8b8",
        "approve": "_0x325fa7",
        "amount": "_0xa0f209",
        "admin": "_0xd91eef",
        "debts": "_0xd078cd",
        "pair": "_0x472297",
        "loan": "_0x815e99",
        "ids": "_0xd1ff00",
        "to": "_0x4a1e47"
      },
      "changes": [
        "Renamed 25 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_045",
      "transformed_id": "ss_l2_hex_sn_tc_045",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x320253, uint256 _0xd616b9) external returns (bool);\n\n    function _0xcb60b4(\n        address from,\n        address _0x320253,\n        uint256 _0xd616b9\n    ) external returns (bool);\n\n    function _0x844494(address _0x35f7ae) external view returns (uint256);\n\n    function _0xa649f8(address _0x99e28d, uint256 _0xd616b9) external returns (bool);\n}\n\ninterface IPendleMarket {\n    function _0xd29d52() external view returns (address[] memory);\n\n    function _0xb318a9() external returns (uint256[] memory);\n\n    function _0x921dbe(address _0x975f21) external returns (uint256[] memory);\n}\n\ncontract PenpieStaking {\n    mapping(address => mapping(address => uint256)) public _0x463e17;\n    mapping(address => uint256) public _0x0f3b68;\n\n    function _0x99ff16(address _0xaba0c9, uint256 _0xd616b9) external {\n        IERC20(_0xaba0c9)._0xcb60b4(msg.sender, address(this), _0xd616b9);\n        _0x463e17[_0xaba0c9][msg.sender] += _0xd616b9;\n        _0x0f3b68[_0xaba0c9] += _0xd616b9;\n    }\n\n    function _0x921dbe(address _0xaba0c9, address _0x975f21) external {\n        uint256[] memory _0xe82a76 = IPendleMarket(_0xaba0c9)._0x921dbe(_0x975f21);\n\n        for (uint256 i = 0; i < _0xe82a76.length; i++) {}\n    }\n\n    function _0xefe0f0(address _0xaba0c9, uint256 _0xd616b9) external {\n        require(\n            _0x463e17[_0xaba0c9][msg.sender] >= _0xd616b9,\n            \"Insufficient balance\"\n        );\n\n        _0x463e17[_0xaba0c9][msg.sender] -= _0xd616b9;\n        _0x0f3b68[_0xaba0c9] -= _0xd616b9;\n\n        IERC20(_0xaba0c9).transfer(msg.sender, _0xd616b9);\n    }\n}\n\ncontract PendleMarketRegister {\n    mapping(address => bool) public _0x3d3043;\n\n    function _0x731890(address _0xaba0c9) external {\n        _0x3d3043[_0xaba0c9] = true;\n    }\n}\n",
      "rename_map": {
        "rewardIndexesCurrent": "_0xb318a9",
        "registeredMarkets": "_0x3d3043",
        "getRewardTokens": "_0xd29d52",
        "registerMarket": "_0x731890",
        "transferFrom": "_0xcb60b4",
        "userBalances": "_0x463e17",
        "claimRewards": "_0x921dbe",
        "totalStaked": "_0x0f3b68",
        "balanceOf": "_0x844494",
        "withdraw": "_0xefe0f0",
        "account": "_0x35f7ae",
        "rewards": "_0xe82a76",
        "spender": "_0x99e28d",
        "approve": "_0xa649f8",
        "deposit": "_0x99ff16",
        "market": "_0xaba0c9",
        "amount": "_0xd616b9",
        "user": "_0x975f21",
        "to": "_0x320253"
      },
      "changes": [
        "Renamed 19 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_046",
      "transformed_id": "ss_l2_hex_sn_tc_046",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x8aac0d, uint256 _0x8892d0) external returns (bool);\n\n    function _0x8b2fa9(address _0xbf0c1d) external view returns (uint256);\n}\n\ncontract FloatHotWalletV2 {\n    address public _0x9f4d06;\n\n    mapping(address => bool) public _0xd0cd62;\n\n    event Withdrawal(address _0xcf5e8b, address _0x8aac0d, uint256 _0x8892d0);\n\n    constructor() {\n        _0x9f4d06 = msg.sender;\n    }\n\n    modifier _0x4cce1b() {\n        require(msg.sender == _0x9f4d06, \"Not owner\");\n        _;\n    }\n\n    function _0x1be36a(\n        address _0xcf5e8b,\n        address _0x8aac0d,\n        uint256 _0x8892d0\n    ) external _0x4cce1b {\n        if (_0xcf5e8b == address(0)) {\n            payable(_0x8aac0d).transfer(_0x8892d0);\n        } else {\n            IERC20(_0xcf5e8b).transfer(_0x8aac0d, _0x8892d0);\n        }\n\n        emit Withdrawal(_0xcf5e8b, _0x8aac0d, _0x8892d0);\n    }\n\n    function _0x98c177(address _0xcf5e8b) external _0x4cce1b {\n        uint256 balance;\n        if (_0xcf5e8b == address(0)) {\n            balance = address(this).balance;\n            payable(_0x9f4d06).transfer(balance);\n        } else {\n            balance = IERC20(_0xcf5e8b)._0x8b2fa9(address(this));\n            IERC20(_0xcf5e8b).transfer(_0x9f4d06, balance);\n        }\n\n        emit Withdrawal(_0xcf5e8b, _0x9f4d06, balance);\n    }\n\n    function _0xbdcde4(address _0x783ce9) external _0x4cce1b {\n        _0x9f4d06 = _0x783ce9;\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "authorizedOperators": "_0xd0cd62",
        "transferOwnership": "_0xbdcde4",
        "emergencyWithdraw": "_0x98c177",
        "balanceOf": "_0x8b2fa9",
        "onlyOwner": "_0x4cce1b",
        "withdraw": "_0x1be36a",
        "newOwner": "_0x783ce9",
        "account": "_0xbf0c1d",
        "amount": "_0x8892d0",
        "owner": "_0x9f4d06",
        "token": "_0xcf5e8b",
        "to": "_0x8aac0d"
      },
      "changes": [
        "Renamed 12 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_047",
      "transformed_id": "ss_l2_hex_sn_tc_047",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x2c9b43, uint256 _0x311831) external returns (bool);\n\n    function _0x7b33db(address _0xc25eda) external view returns (uint256);\n}\n\ncontract PlayDappToken {\n    string public _0x184528 = \"PlayDapp Token\";\n    string public _0x58fb98 = \"PLA\";\n    uint8 public _0xd86ab5 = 18;\n\n    uint256 public _0xa6eb3c;\n\n    address public _0x774da9;\n\n    mapping(address => uint256) public _0x7b33db;\n    mapping(address => mapping(address => uint256)) public _0xd812dc;\n\n    event Transfer(address indexed from, address indexed _0x2c9b43, uint256 value);\n    event Approval(\n        address indexed _0xbf6be4,\n        address indexed _0x71acea,\n        uint256 value\n    );\n    event Minted(address indexed _0x2c9b43, uint256 _0x311831);\n\n    constructor() {\n        _0x774da9 = msg.sender;\n        _0x632e3f(msg.sender, 700_000_000 * 10 ** 18);\n    }\n\n    modifier _0x0c61ed() {\n        require(msg.sender == _0x774da9, \"Not minter\");\n        _;\n    }\n\n    function _0x5899c9(address _0x2c9b43, uint256 _0x311831) external _0x0c61ed {\n        _0x632e3f(_0x2c9b43, _0x311831);\n        emit Minted(_0x2c9b43, _0x311831);\n    }\n\n    function _0x632e3f(address _0x2c9b43, uint256 _0x311831) internal {\n        require(_0x2c9b43 != address(0), \"Mint to zero address\");\n\n        _0xa6eb3c += _0x311831;\n        _0x7b33db[_0x2c9b43] += _0x311831;\n\n        emit Transfer(address(0), _0x2c9b43, _0x311831);\n    }\n\n    function _0x9f8380(address _0x610ddd) external _0x0c61ed {\n        _0x774da9 = _0x610ddd;\n    }\n\n    function transfer(address _0x2c9b43, uint256 _0x311831) external returns (bool) {\n        require(_0x7b33db[msg.sender] >= _0x311831, \"Insufficient balance\");\n        _0x7b33db[msg.sender] -= _0x311831;\n        _0x7b33db[_0x2c9b43] += _0x311831;\n        emit Transfer(msg.sender, _0x2c9b43, _0x311831);\n        return true;\n    }\n\n    function _0x6a29b4(address _0x71acea, uint256 _0x311831) external returns (bool) {\n        _0xd812dc[msg.sender][_0x71acea] = _0x311831;\n        emit Approval(msg.sender, _0x71acea, _0x311831);\n        return true;\n    }\n\n    function _0x5432e7(\n        address from,\n        address _0x2c9b43,\n        uint256 _0x311831\n    ) external returns (bool) {\n        require(_0x7b33db[from] >= _0x311831, \"Insufficient balance\");\n        require(\n            _0xd812dc[from][msg.sender] >= _0x311831,\n            \"Insufficient allowance\"\n        );\n\n        _0x7b33db[from] -= _0x311831;\n        _0x7b33db[_0x2c9b43] += _0x311831;\n        _0xd812dc[from][msg.sender] -= _0x311831;\n\n        emit Transfer(from, _0x2c9b43, _0x311831);\n        return true;\n    }\n}\n",
      "rename_map": {
        "transferFrom": "_0x5432e7",
        "totalSupply": "_0xa6eb3c",
        "onlyMinter": "_0x0c61ed",
        "balanceOf": "_0x7b33db",
        "setMinter": "_0x9f8380",
        "allowance": "_0xd812dc",
        "newMinter": "_0x610ddd",
        "decimals": "_0xd86ab5",
        "account": "_0xc25eda",
        "spender": "_0x71acea",
        "approve": "_0x6a29b4",
        "symbol": "_0x58fb98",
        "minter": "_0x774da9",
        "amount": "_0x311831",
        "owner": "_0xbf6be4",
        "_mint": "_0x632e3f",
        "mint": "_0x5899c9",
        "name": "_0x184528",
        "to": "_0x2c9b43"
      },
      "changes": [
        "Renamed 19 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_048",
      "transformed_id": "ss_l2_hex_sn_tc_048",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x15c388, uint256 _0xc7f860) external returns (bool);\n\n    function _0xa33437(\n        address from,\n        address _0x15c388,\n        uint256 _0xc7f860\n    ) external returns (bool);\n\n    function _0xbb0be6(address _0xe32e55) external view returns (uint256);\n}\n\ncontract SonneMarket {\n    IERC20 public _0x9dd6dc;\n\n    string public _0x3c0ab8 = \"Sonne WETH\";\n    string public _0x17a604 = \"soWETH\";\n    uint8 public _0x6b6014 = 8;\n\n    uint256 public _0x3121ea;\n    mapping(address => uint256) public _0xbb0be6;\n\n    uint256 public _0x5376fd;\n    uint256 public _0xd4fbe2;\n\n    event Mint(address _0x803a2c, uint256 _0x036596, uint256 _0x80dff9);\n    event Redeem(address _0xa561f2, uint256 _0x4a485e, uint256 _0x2ac028);\n\n    constructor(address _0x9c511f) {\n        _0x9dd6dc = IERC20(_0x9c511f);\n    }\n\n    function _0x0390cf() public view returns (uint256) {\n        if (_0x3121ea == 0) {\n            return 1e18;\n        }\n\n        uint256 _0xe33776 = _0x9dd6dc._0xbb0be6(address(this));\n\n        uint256 _0xc64596 = _0xe33776 + _0x5376fd - _0xd4fbe2;\n\n        return (_0xc64596 * 1e18) / _0x3121ea;\n    }\n\n    function _0x0b2d9f(uint256 _0x036596) external returns (uint256) {\n        require(_0x036596 > 0, \"Zero mint\");\n\n        uint256 _0x516a5b = _0x0390cf();\n\n        uint256 _0x80dff9 = (_0x036596 * 1e18) / _0x516a5b;\n\n        _0x3121ea += _0x80dff9;\n        _0xbb0be6[msg.sender] += _0x80dff9;\n\n        _0x9dd6dc._0xa33437(msg.sender, address(this), _0x036596);\n\n        emit Mint(msg.sender, _0x036596, _0x80dff9);\n        return _0x80dff9;\n    }\n\n    function _0xc087be(uint256 _0x2ac028) external returns (uint256) {\n        require(_0xbb0be6[msg.sender] >= _0x2ac028, \"Insufficient balance\");\n\n        uint256 _0x516a5b = _0x0390cf();\n\n        uint256 _0x4a485e = (_0x2ac028 * _0x516a5b) / 1e18;\n\n        _0xbb0be6[msg.sender] -= _0x2ac028;\n        _0x3121ea -= _0x2ac028;\n\n        _0x9dd6dc.transfer(msg.sender, _0x4a485e);\n\n        emit Redeem(msg.sender, _0x4a485e, _0x2ac028);\n        return _0x4a485e;\n    }\n\n    function _0xe30684(\n        address _0xe32e55\n    ) external view returns (uint256) {\n        uint256 _0x516a5b = _0x0390cf();\n\n        return (_0xbb0be6[_0xe32e55] * _0x516a5b) / 1e18;\n    }\n}\n",
      "rename_map": {
        "exchangeRateMantissa": "_0x516a5b",
        "balanceOfUnderlying": "_0xe30684",
        "totalUnderlying": "_0xc64596",
        "totalReserves": "_0xd4fbe2",
        "transferFrom": "_0xa33437",
        "totalBorrows": "_0x5376fd",
        "redeemAmount": "_0x4a485e",
        "exchangeRate": "_0x0390cf",
        "redeemTokens": "_0x2ac028",
        "totalSupply": "_0x3121ea",
        "_underlying": "_0x9c511f",
        "mintAmount": "_0x036596",
        "underlying": "_0x9dd6dc",
        "mintTokens": "_0x80dff9",
        "balanceOf": "_0xbb0be6",
        "redeemer": "_0xa561f2",
        "decimals": "_0x6b6014",
        "account": "_0xe32e55",
        "symbol": "_0x17a604",
        "redeem": "_0xc087be",
        "minter": "_0x803a2c",
        "amount": "_0xc7f860",
        "cash": "_0xe33776",
        "mint": "_0x0b2d9f",
        "name": "_0x3c0ab8",
        "to": "_0x15c388"
      },
      "changes": [
        "Renamed 26 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_049",
      "transformed_id": "ss_l2_hex_sn_tc_049",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x75b683, uint256 _0xea7ff8) external returns (bool);\n\n    function _0xb25665(\n        address from,\n        address _0x75b683,\n        uint256 _0xea7ff8\n    ) external returns (bool);\n\n    function _0x35a0a3(address _0xebe82a) external view returns (uint256);\n}\n\ninterface IMarket {\n    function _0x07f2c2(\n        address _0xebe82a\n    )\n        external\n        view\n        returns (uint256 _0xa1dac4, uint256 _0x6ff98b, uint256 _0xd91183);\n}\n\ncontract DebtPreviewer {\n    function _0xbdfb7b(\n        address _0x651330,\n        address _0xebe82a\n    )\n        external\n        view\n        returns (\n            uint256 _0x9150cb,\n            uint256 _0xe89c79,\n            uint256 _0xdfed42\n        )\n    {\n        (uint256 _0xa1dac4, uint256 _0x6ff98b, uint256 _0xd91183) = IMarket(\n            _0x651330\n        )._0x07f2c2(_0xebe82a);\n\n        _0x9150cb = (_0xa1dac4 * _0xd91183) / 1e18;\n        _0xe89c79 = _0x6ff98b;\n\n        if (_0xe89c79 == 0) {\n            _0xdfed42 = type(uint256)._0xac2f1a;\n        } else {\n            _0xdfed42 = (_0x9150cb * 1e18) / _0xe89c79;\n        }\n\n        return (_0x9150cb, _0xe89c79, _0xdfed42);\n    }\n\n    function _0x419852(\n        address[] calldata _0x0e28a9,\n        address _0xebe82a\n    )\n        external\n        view\n        returns (\n            uint256 _0x6703d2,\n            uint256 _0x7ab4f5,\n            uint256 _0xeaf811\n        )\n    {\n        for (uint256 i = 0; i < _0x0e28a9.length; i++) {\n            (uint256 _0xa1dac4, uint256 _0xa3a662, ) = this._0xbdfb7b(\n                _0x0e28a9[i],\n                _0xebe82a\n            );\n\n            _0x6703d2 += _0xa1dac4;\n            _0x7ab4f5 += _0xa3a662;\n        }\n\n        if (_0x7ab4f5 == 0) {\n            _0xeaf811 = type(uint256)._0xac2f1a;\n        } else {\n            _0xeaf811 = (_0x6703d2 * 1e18) / _0x7ab4f5;\n        }\n\n        return (_0x6703d2, _0x7ab4f5, _0xeaf811);\n    }\n}\n\ncontract ExactlyMarket {\n    IERC20 public _0x12711f;\n    DebtPreviewer public _0xa9ae54;\n\n    mapping(address => uint256) public _0x5738af;\n    mapping(address => uint256) public _0x6ff98b;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(address _0xf73b12, address _0x5e0db3) {\n        _0x12711f = IERC20(_0xf73b12);\n        _0xa9ae54 = DebtPreviewer(_0x5e0db3);\n    }\n\n    function _0xfe578a(uint256 _0xea7ff8) external {\n        _0x12711f._0xb25665(msg.sender, address(this), _0xea7ff8);\n        _0x5738af[msg.sender] += _0xea7ff8;\n    }\n\n    function _0xf92b1f(uint256 _0xea7ff8, address[] calldata _0x0e28a9) external {\n        (uint256 _0x6703d2, uint256 _0x7ab4f5, ) = _0xa9ae54\n            ._0x419852(_0x0e28a9, msg.sender);\n\n        uint256 _0x4657d0 = _0x7ab4f5 + _0xea7ff8;\n\n        uint256 _0x135ef1 = (_0x6703d2 * COLLATERAL_FACTOR) / 100;\n        require(_0x4657d0 <= _0x135ef1, \"Insufficient collateral\");\n\n        _0x6ff98b[msg.sender] += _0xea7ff8;\n        _0x12711f.transfer(msg.sender, _0xea7ff8);\n    }\n\n    function _0x07f2c2(\n        address _0xebe82a\n    )\n        external\n        view\n        returns (uint256 _0xa1dac4, uint256 _0x187cfe, uint256 _0xd91183)\n    {\n        return (_0x5738af[_0xebe82a], _0x6ff98b[_0xebe82a], 1e18);\n    }\n}\n",
      "rename_map": {
        "previewMultipleMarkets": "_0x419852",
        "getAccountSnapshot": "_0x07f2c2",
        "collateralValue": "_0x9150cb",
        "totalCollateral": "_0x6703d2",
        "overallHealth": "_0xeaf811",
        "transferFrom": "_0xb25665",
        "exchangeRate": "_0xd91183",
        "healthFactor": "_0xdfed42",
        "previewDebt": "_0xbdfb7b",
        "_previewer": "_0x5e0db3",
        "collateral": "_0xa1dac4",
        "previewer": "_0xa9ae54",
        "balanceOf": "_0x35a0a3",
        "maxBorrow": "_0x135ef1",
        "debtValue": "_0xe89c79",
        "totalDebt": "_0x7ab4f5",
        "deposits": "_0x5738af",
        "borrowed": "_0x187cfe",
        "account": "_0xebe82a",
        "borrows": "_0x6ff98b",
        "markets": "_0x0e28a9",
        "newDebt": "_0x4657d0",
        "deposit": "_0xfe578a",
        "market": "_0x651330",
        "borrow": "_0xf92b1f",
        "amount": "_0xea7ff8",
        "_asset": "_0xf73b12",
        "asset": "_0x12711f",
        "debt": "_0xa3a662",
        "max": "_0xac2f1a",
        "to": "_0x75b683"
      },
      "changes": [
        "Renamed 31 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_050",
      "transformed_id": "ss_l2_hex_sn_tc_050",
      "level": "l2",
      "variant": "hex",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x2f4aac, uint256 _0x936313) external returns (bool);\n\n    function _0x76fbad(\n        address from,\n        address _0x2f4aac,\n        uint256 _0x936313\n    ) external returns (bool);\n\n    function _0x0b0f85(address _0x101d29) external view returns (uint256);\n}\n\ncontract MunchablesLockManager {\n    address public _0x981733;\n    address public _0xca2d01;\n\n    struct PlayerSettings {\n        uint256 _0xa49052;\n        address _0x61ed39;\n        uint256 _0x66d06b;\n        uint256 _0xb9b339;\n    }\n\n    mapping(address => PlayerSettings) public _0x5e235e;\n    mapping(address => uint256) public _0x4e1f81;\n\n    IERC20 public immutable _0x4b8e23;\n\n    event Locked(address _0x7adbe1, uint256 _0x936313, address _0x30477f);\n    event ConfigUpdated(address _0xccfe89, address _0xb45c3a);\n\n    constructor(address _0x6322b0) {\n        _0x981733 = msg.sender;\n        _0x4b8e23 = IERC20(_0x6322b0);\n    }\n\n    modifier _0x4ca241() {\n        require(msg.sender == _0x981733, \"Not admin\");\n        _;\n    }\n\n    function _0x060add(uint256 _0x936313, uint256 _0x489431) external {\n        require(_0x936313 > 0, \"Zero amount\");\n\n        _0x4b8e23._0x76fbad(msg.sender, address(this), _0x936313);\n\n        _0x4e1f81[msg.sender] += _0x936313;\n        _0x5e235e[msg.sender] = PlayerSettings({\n            _0xa49052: _0x936313,\n            _0x61ed39: msg.sender,\n            _0x66d06b: _0x489431,\n            _0xb9b339: block.timestamp\n        });\n\n        emit Locked(msg.sender, _0x936313, msg.sender);\n    }\n\n    function _0x24ebe6(address _0x54cd07) external _0x4ca241 {\n        address _0xccfe89 = _0xca2d01;\n        _0xca2d01 = _0x54cd07;\n\n        emit ConfigUpdated(_0xccfe89, _0x54cd07);\n    }\n\n    function _0xbe5e71(\n        address _0x7adbe1,\n        address _0x16cadb\n    ) external _0x4ca241 {\n        _0x5e235e[_0x7adbe1]._0x61ed39 = _0x16cadb;\n    }\n\n    function _0x561a05() external {\n        PlayerSettings memory _0x69acb6 = _0x5e235e[msg.sender];\n\n        require(_0x69acb6._0xa49052 > 0, \"No locked tokens\");\n        require(\n            block.timestamp >= _0x69acb6._0xb9b339 + _0x69acb6._0x66d06b,\n            \"Still locked\"\n        );\n\n        uint256 _0x936313 = _0x69acb6._0xa49052;\n\n        address _0x30477f = _0x69acb6._0x61ed39;\n\n        delete _0x5e235e[msg.sender];\n        _0x4e1f81[msg.sender] = 0;\n\n        _0x4b8e23.transfer(_0x30477f, _0x936313);\n    }\n\n    function _0xeb5209(address _0x7adbe1) external _0x4ca241 {\n        PlayerSettings memory _0x69acb6 = _0x5e235e[_0x7adbe1];\n        uint256 _0x936313 = _0x69acb6._0xa49052;\n        address _0x30477f = _0x69acb6._0x61ed39;\n\n        delete _0x5e235e[_0x7adbe1];\n        _0x4e1f81[_0x7adbe1] = 0;\n\n        _0x4b8e23.transfer(_0x30477f, _0x936313);\n    }\n\n    function _0x9f5825(address _0xc40621) external _0x4ca241 {\n        _0x981733 = _0xc40621;\n    }\n}\n",
      "rename_map": {
        "setConfigStorage": "_0x24ebe6",
        "setLockRecipient": "_0xbe5e71",
        "emergencyUnlock": "_0xeb5209",
        "playerSettings": "_0x5e235e",
        "playerBalances": "_0x4e1f81",
        "_configStorage": "_0x54cd07",
        "transferAdmin": "_0x9f5825",
        "lockRecipient": "_0x61ed39",
        "configStorage": "_0xca2d01",
        "lockStartTime": "_0xb9b339",
        "transferFrom": "_0x76fbad",
        "newRecipient": "_0x16cadb",
        "lockedAmount": "_0xa49052",
        "lockDuration": "_0x66d06b",
        "balanceOf": "_0x0b0f85",
        "recipient": "_0x30477f",
        "oldConfig": "_0xccfe89",
        "onlyAdmin": "_0x4ca241",
        "newConfig": "_0xb45c3a",
        "duration": "_0x489431",
        "settings": "_0x69acb6",
        "newAdmin": "_0xc40621",
        "account": "_0x101d29",
        "unlock": "_0x561a05",
        "player": "_0x7adbe1",
        "amount": "_0x936313",
        "admin": "_0x981733",
        "_weth": "_0x6322b0",
        "lock": "_0x060add",
        "weth": "_0x4b8e23",
        "to": "_0x2f4aac"
      },
      "changes": [
        "Renamed 31 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    }
  ]
}